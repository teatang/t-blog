<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren() | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/ab44062dd349/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg">
<meta property="article:published_time" content="2023-11-14T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-04T06:18:17.438Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()",
  "url": "https://blog.tbf1211.xx.kg/ab44062dd349/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg",
  "datePublished": "2023-11-14T22:24:00.000Z",
  "dateModified": "2026-01-04T06:18:17.438Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/ab44062dd349/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">453</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-26.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-14T22:24:00.000Z" title="发表于 2023-11-15 06:24:00">2023-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/Vue/">Vue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 <strong>虚拟 DOM (Virtual DOM)</strong> 及其配套的 <strong>Diff 算法 (补丁机制)</strong>。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：<code>patch()</code>, <code>patchVnode()</code>, 和 <code>updateChildren()</code>，并辅以 Mermaid 流程图进行可视化说明。</p>
</blockquote>
<div class="note info flat"><p>“虚拟 DOM 是前端性能优化的基石，而 Vue 的 <code>patch()</code> 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”</p>
</div>
<hr>
<h2 id="一、虚拟-DOM-Virtual-DOM-再探"><a href="#一、虚拟-DOM-Virtual-DOM-再探" class="headerlink" title="一、虚拟 DOM (Virtual DOM) 再探"></a>一、虚拟 DOM (Virtual DOM) 再探</h2><h3 id="1-1-什么是虚拟-DOM？"><a href="#1-1-什么是虚拟-DOM？" class="headerlink" title="1.1 什么是虚拟 DOM？"></a>1.1 什么是虚拟 DOM？</h3><p>虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：</p>
<ul>
<li><code>tag</code>：标签名（如 <code>div</code>、<code>p</code>，或者组件的配置对象）。</li>
<li><code>data</code>：一个对象，包含 DOM 元素的属性（<code>attrs</code>）、样式（<code>style</code>）、事件（<code>on</code>）、<code>key</code>、<code>class</code> 等。</li>
<li><code>children</code>：一个 VNode 数组，表示当前 VNode 的子节点。</li>
<li><code>text</code>：如果 VNode 是一个文本节点，则为文本内容。</li>
<li><code>elm</code>：对实际 DOM 元素的引用（在补丁 (<code>patch</code>) 过程中会被赋值）。</li>
</ul>
<h3 id="1-2-为什么需要虚拟-DOM？"><a href="#1-2-为什么需要虚拟-DOM？" class="headerlink" title="1.2 为什么需要虚拟 DOM？"></a>1.2 为什么需要虚拟 DOM？</h3><ol>
<li><strong>性能优化</strong>：直接操作真实 DOM 是非常耗费性能的。虚拟 DOM 将频繁的 DOM 操作集中起来，通过 Diff 算法计算出最小的变更集，然后一次性（批量）地更新真实 DOM，显著减少了重绘和回流的次数。</li>
<li><strong>开发体验</strong>：开发者只需关注数据的变化和组件状态，无需手动操作复杂的 DOM API，提高了开发效率。</li>
<li><strong>跨平台能力</strong>：因为虚拟 DOM 只是 JavaScript 对象，它可以被渲染到不同的平台（如 Web 浏览器、Native 应用、小程序等），而不仅仅是浏览器环境。</li>
</ol>
<h3 id="1-3-虚拟-DOM-到真实-DOM-的过程"><a href="#1-3-虚拟-DOM-到真实-DOM-的过程" class="headerlink" title="1.3 虚拟 DOM 到真实 DOM 的过程"></a>1.3 虚拟 DOM 到真实 DOM 的过程</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[Vue 组件数据&#x2F;状态变化] --&gt; B(render 函数生成新的 VNode 树)
    B --&gt; C{Diff 算法 &#x2F; patch 函数}
    D[旧的 VNode 树 （上次渲染结果）] --&gt; C
    C --&gt; E[生成补丁集 （最小差异）]
    E --&gt; F[更新真实 DOM]
  </pre></div>

<h2 id="二、Vue-补丁机制核心函数解析"><a href="#二、Vue-补丁机制核心函数解析" class="headerlink" title="二、Vue 补丁机制核心函数解析"></a>二、Vue 补丁机制核心函数解析</h2><p>当 Vue 的响应式数据发生变化时，如果组件被标记为需要重新渲染，它会重新执行 <code>render</code> 函数生成一颗新的 VNode 树。接下来，Vue 的渲染器会调用 <code>patch()</code> 函数，负责比较新旧 VNode 树并更新真实 DOM。</p>
<h3 id="2-1-patch-oldVnode-newVnode-：差异发现与更新的入口"><a href="#2-1-patch-oldVnode-newVnode-：差异发现与更新的入口" class="headerlink" title="2.1 patch(oldVnode, newVnode)：差异发现与更新的入口"></a>2.1 <code>patch(oldVnode, newVnode)</code>：差异发现与更新的入口</h3><p><code>patch()</code> 函数是整个渲染更新过程的入口。它的主要职责是根据 <code>oldVnode</code> 和 <code>newVnode</code> 的不同情形，执行相应的 DOM 操作，包括创建、更新或删除元素。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    start(&quot;patch（oldVnode, newVnode）&quot;) --&gt; A{oldVnode是真实DOM元素?&lt;br&gt;（如 #app 首次挂载）};
    A -- 是, 首次挂载 --&gt; B[创建 newVnode.elm &lt;br&gt;并替换真实DOM];
    A -- 否 --&gt; C{newVnode 存在?};
    C -- 否, oldVnode需删除 --&gt; D[移除 oldVnode.elm];
    C -- 是 --&gt; E{newVnode是文本VNode?};
    E -- 是, 文本节点 --&gt; F[更新 oldVnode.elm.textContent&lt;br&gt; &#x3D; newVnode.text];
    E -- 否 --&gt; G{sameVnode（oldVnode, &lt;br&gt;newVnode）相同VNode?};
    G -- 是, 相同VNode --&gt; H(patchVnode（oldVnode, &lt;br&gt;newVnode）);
    G -- 否, 不同VNode --&gt; I[销毁 oldVnode.elm, &lt;br&gt;创建并插入 newVnode.elm];
    B --&gt; K[返回 newVnode.elm];
    F --&gt; K;
    H --&gt; K;
    I --&gt; K;
  </pre></div>

<p><strong>关键逻辑点</strong>：</p>
<ol>
<li><strong>首次渲染 (Initial Mount)</strong>：<ul>
<li>如果 <code>oldVnode</code> 是一个真实 DOM 元素（通常是 <code>el</code> 选项提供的挂载点，如 <code>document.querySelector(&#39;#app&#39;)</code>），则 <code>newVnode</code> 会被完全创建并插入到 DOM 中，替换掉 <code>oldVnode</code>，并建立 <code>newVnode.elm</code> 对真实 DOM 的引用。</li>
</ul>
</li>
<li><strong>更新 (Update)</strong>：<ul>
<li>如果发现 <code>sameVnode(oldVnode, newVnode)</code> 返回 <code>true</code>（即它们代表同一个元素，主要通过 <code>key</code> 和 <code>tag</code> 判断），则进入 <code>patchVnode()</code> 进行更细致的比较和更新。</li>
<li>如果返回 <code>false</code>（它们不是 <code>sameVnode</code>），说明它们是完全不同的元素。此时，<code>oldVnode</code> 对应的真实 DOM 会被销毁，然后创建并插入 <code>newVnode</code> 对应的真实 DOM。</li>
</ul>
</li>
<li><code>newVnode</code> 不存在（<code>undefined</code>）：这意味着 <code>oldVnode</code> 对应的元素需要被移除。</li>
</ol>
<h3 id="2-2-patchVnode-oldVnode-newVnode-：同类节点的深度比对与更新"><a href="#2-2-patchVnode-oldVnode-newVnode-：同类节点的深度比对与更新" class="headerlink" title="2.2 patchVnode(oldVnode, newVnode)：同类节点的深度比对与更新"></a>2.2 <code>patchVnode(oldVnode, newVnode)</code>：同类节点的深度比对与更新</h3><p><code>patchVnode()</code> 是 <code>patch()</code> 函数中用于处理<strong>被认为是相同 VNode</strong> 的深度比较和更新的函数。它会对比两个 VNode 的属性、事件、子节点等，并执行最小化的 DOM 操作。</p>
<p><strong>Mermaid 流程图</strong>：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    start(&quot;patchVnode（oldVnode，newVnode）开始&quot;) --&gt; A[newVnode.elm &#x3D; oldVnode.elm（复用真实DOM）];
    A --&gt; B{oldVnode与newVnode的data（如props&#x2F;style&#x2F;event）不同?};
    B -- 是 --&gt; C[更新oldVnode.elm上的属性和事件];
    B -- 否 --&gt; D;
    C --&gt; D;

    D{newVnode有子节点?};
    D -- 是 --&gt; E{oldVnode有子节点?};
    E -- 是, 新旧都有子节点 --&gt; F(updateChildren（oldVnode.children, newVnode.children）);
    E -- 否, 旧只有文本或空 --&gt; G[清空oldVnode.elm内容, 添加newVnode的所有子节点];
    F --&gt; O(&quot;结束&quot;);
    G --&gt; O;

    D -- 否, newVnode无子节点 --&gt; H{oldVnode有子节点?};
    H -- 是, 旧有子节点需移除 --&gt; I[移除oldVnode.elm的所有子节点];
    H -- 否 --&gt; J;
    I --&gt; J;

    J{newVnode有文本内容?};
    J -- 是 --&gt; K[设置 oldVnode.elm.textContent &#x3D; newVnode.text];
    J -- 否 --&gt; L{oldVnode有文本内容?};
    L -- 是 --&gt; M[清空 oldVnode.elm.textContent];
    L -- 否 --&gt; O;
    K --&gt; O;
    M --&gt; O;
  </pre></div>

<p><strong>关键逻辑点</strong>：</p>
<ol>
<li><strong>复用 DOM 元素</strong>：<code>newVnode.elm = oldVnode.elm</code>。由于它们是 <code>sameVnode</code>，所以它们对应的真实 DOM 元素可以被复用。</li>
<li><strong>更新 VNode 的数据 (Props, Style, Class, Event Listener 等)</strong>：<code>updateAttrs(oldVnode, newVnode)</code> 等方法会对比 <code>oldVnode.data</code> 和 <code>newVnode.data</code>，只更新变化的属性，移除不再存在的属性，并重新绑定事件。</li>
<li><strong>处理子节点</strong>：这是最复杂也是最重要的部分。<ul>
<li><strong>新旧 VNode 都有子节点</strong>：调用 <code>updateChildren(oldVnode.children, newVnode.children)</code> 进行子节点列表的 Diff 比较。</li>
<li><strong>新 VNode 有子节点，旧 VNode 没有</strong>：清空旧的 DOM 元素内容，然后将 <code>newVnode.children</code> 全部添加到 DOM 中。</li>
<li><strong>新 VNode 没有子节点，旧 VNode 却有</strong>：则直接移除 <code>oldVnode</code> 的所有子节点对应的真实 DOM。</li>
<li><strong>处理文本节点</strong>：如果新 VNode 有文本内容 (<code>newVnode.text</code> 存在)，则将 DOM 元素的 <code>textContent</code> 设置为 <code>newVnode.text</code>。如果旧 VNode 有文本内容 (<code>oldVnode.text</code> 存在) 但新 VNode 既没有子节点也没有文本内容，则清空 DOM 元素的 <code>textContent</code>。</li>
</ul>
</li>
</ol>
<h3 id="2-3-updateChildren-oldChildren-newChildren-：子节点列表的-Diff-算法核心"><a href="#2-3-updateChildren-oldChildren-newChildren-：子节点列表的-Diff-算法核心" class="headerlink" title="2.3 updateChildren(oldChildren, newChildren)：子节点列表的 Diff 算法核心"></a>2.3 <code>updateChildren(oldChildren, newChildren)</code>：子节点列表的 Diff 算法核心</h3><p><code>updateChildren()</code> 是 Vue 2 Diff 算法的核心，它采用<strong>双端比较算法 (Two-Pointer Diff Algorithm)</strong> 来高效地比对新旧子 VNode 列表，最大限度地复用和移动 DOM 元素，减少不必要的创建和销毁。</p>
<p><strong>Mermaid 流程图</strong>：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    start(&quot;开始&quot;) --&gt; A[初始化四个指针:&lt;br&gt;oldStartIdx, oldEndIdx&lt;br&gt;newStartIdx, newEndIdx];

    A --&gt; B{&quot;while (oldStartIdx &lt;&#x3D; oldEndIdx&lt;br&gt;&amp;&amp; newStartIdx &lt;&#x3D; newEndIdx)&quot;};

    B -- 是 --&gt; GetNodes[获取当前VNode:&lt;br&gt;oldStartV, oldEndV&lt;br&gt;newStartV, newEndV];

    GetNodes --&gt; SkipOldStart{oldStartV 为空?};
    SkipOldStart -- 是 --&gt; IncOldStart[oldStartIdx++];
    SkipOldStart -- 否 --&gt; SkipOldEnd{oldEndV 为空?};
    SkipOldEnd -- 是 --&gt; DecOldEnd[oldEndIdx--];
    SkipOldEnd -- 否 --&gt; MatchHeadHead{&quot;sameVnode(oldStartV, newStartV)?&quot;};

    MatchHeadHead -- 是 --&gt; PatchHeadHead[&quot;patchVnode(头头),&lt;br&gt;oldStartIdx++, newStartIdx++&quot;];
    MatchHeadHead -- 否 --&gt; MatchTailTail{&quot;sameVnode(oldEndV, newEndV)?&quot;};

    MatchTailTail -- 是 --&gt; PatchTailTail[&quot;patchVnode(尾尾),&lt;br&gt;oldEndIdx--, newEndIdx--&quot;];
    MatchTailTail -- 否 --&gt; MatchOldHeadNewTail{&quot;sameVnode(oldStartV, newEndV)?&quot;};

    MatchOldHeadNewTail -- 是 --&gt; PatchOldHeadNewTail[&quot;patchVnode(旧头新尾),&lt;br&gt;移动 oldStartV DOM到oldEndV DOM之后,&lt;br&gt;oldStartIdx++, newEndIdx--&quot;];
    MatchOldHeadNewTail -- 否 --&gt; MatchOldTailNewHead{&quot;sameVnode(oldEndV, newStartV)?&quot;};

    MatchOldTailNewHead -- 是 --&gt; PatchOldTailNewHead[&quot;patchVnode(旧尾新头),&lt;br&gt;移动 oldEndV DOM到oldStartV DOM之前,&lt;br&gt;oldEndIdx--, newStartIdx++&quot;];
    MatchOldTailNewHead -- 否 --&gt; FallbackStrategy[&quot;通用匹配 (Fallback):&lt;br&gt;1. 尝试在 oldChildren 中查找 newStartV 的匹配VNode (By Key)&lt;br&gt;2. 如果找到: patchVnode, 移动DOM, 标记旧VNode已处理&lt;br&gt;3. 否则: 创建 newStartV 对应的DOM并插入&lt;br&gt;4. newStartIdx++&quot;];

    IncOldStart --&gt; B;
    DecOldEnd --&gt; B;
    PatchHeadHead --&gt; B;
    PatchTailTail --&gt; B;
    PatchOldHeadNewTail --&gt; B;
    PatchOldTailNewHead --&gt; B;
    FallbackStrategy --&gt; B;

    B -- 否 --&gt; CheckNewRemaining{&quot;newStartIdx &lt;&#x3D; newEndIdx?&lt;br&gt;(新节点剩余 - 新增)&quot;};
    CheckNewRemaining -- 是 --&gt; InsertRemaining[批量插入剩余新节点];
    CheckNewRemaining -- 否 --&gt; CheckOldRemaining{&quot;oldStartIdx &lt;&#x3D; oldEndIdx?&lt;br&gt;(旧节点剩余 - 删除)&quot;};

    CheckOldRemaining -- 是 --&gt; RemoveRemaining[批量移除剩余旧节点];
    CheckOldRemaining -- 否 --&gt; endNode(&quot;结束&quot;);

    InsertRemaining --&gt; endNode;
    RemoveRemaining --&gt; endNode;
  </pre></div>


<p><strong>关键逻辑点</strong>：</p>
<ol>
<li><strong>双端四向比较</strong>：<ul>
<li>Vue 的 Diff 算法会维护 <code>oldStartIdx</code> (旧开始索引), <code>oldEndIdx</code> (旧结束索引), <code>newStartIdx</code> (新开始索引), <code>newEndIdx</code> (新结束索引) 四个指针。</li>
<li>在循环中，它优先尝试从新旧子节点列表的头部和尾部进行四种快速匹配：<ul>
<li><strong>头头匹配 (<code>oldStart</code> vs <code>newStart</code>)</strong>：如果匹配，就地更新，两者指针都向右移动。</li>
<li><strong>尾尾匹配 (<code>oldEnd</code> vs <code>newEnd</code>)</strong>：如果匹配，就地更新，两者指针都向左移动。</li>
<li><strong>旧头新尾匹配 (<code>oldStart</code> vs <code>newEnd</code>)</strong>：如果匹配，说明旧的头节点移动到了新的尾部，更新后将对应的真实 DOM 移动到 <code>oldEndVnode</code> 对应的 DOM 之后。</li>
<li><strong>旧尾新头匹配 (<code>oldEnd</code> vs <code>newStart</code>)</strong>：如果匹配，说明旧的尾节点移动到了新的头部，更新后将对应的真实 DOM 移动到 <code>oldStartVnode</code> 对应的 DOM 之前。</li>
</ul>
</li>
<li>一旦匹配成功，就调用 <code>patchVnode</code> 更新节点，并根据匹配类型移动真实 DOM，同时移动相应的指针。</li>
</ul>
</li>
<li><strong>Fallback 策略（通过 <code>key</code> 查找）</strong>：<ul>
<li>如果上述四种情况都未匹配，Vue 会为 <code>oldChildren</code> 中未处理的节点建立一个 <code>key</code> 到索引的映射表。</li>
<li>然后尝试在新列表的 <code>newStartVnode</code> 中查找其 <code>key</code> 是否在旧列表中存在。</li>
<li>如果找到相同 <code>key</code> 且是 <code>sameVnode</code> 的旧节点：就 <code>patchVnode</code>，并将其对应的真实 DOM 移动到正确的位置。旧节点会被标记为已处理。</li>
<li>如果没找到或 <code>key</code> 不同但 <code>isSameVnode</code> 失败，则说明 <code>newStartVnode</code> 是一个全新的节点，需要创建并插入其对应的真实 DOM。</li>
</ul>
</li>
<li><strong>循环结束后的处理</strong>：<ul>
<li><strong>新增节点</strong>：如果循环结束后，<code>newChildren</code> 中仍有未处理的节点（<code>newStartIdx &lt;= newEndIdx</code>），说明它们是新添加的，需要创建并插入到 DOM 中。</li>
<li><strong>删除节点</strong>：如果循环结束后，<code>oldChildren</code> 中仍有未处理的节点（<code>oldStartIdx &lt;= oldEndIdx</code>），说明它们在 <code>newChildren</code> 中不存在，需要从 DOM 中移除。</li>
</ul>
</li>
</ol>
<h3 id="2-4-key-属性的决定性作用"><a href="#2-4-key-属性的决定性作用" class="headerlink" title="2.4 key 属性的决定性作用"></a>2.4 <code>key</code> 属性的决定性作用</h3><p>在 <code>updateChildren()</code> 中，<code>key</code> 属性起着至关重要的作用。它为每个 VNode 提供了唯一的身份标识。</p>
<ul>
<li><strong>唯一性</strong>：<code>key</code> 在同级 VNode 中必须是唯一的。</li>
<li><strong>稳定性</strong>：<code>key</code> 值应保持稳定，不应随机生成或使用数组索引（除非列表是静态的且永不变化）。</li>
<li><strong>作用</strong>：<ul>
<li><strong>精确识别</strong>：Vue 能够利用 <code>key</code> 精准地判断哪些 VNode 是同一个元素，只是位置变了，哪些是新增或删除的。</li>
<li><strong>高效复用</strong>：当 VNode 顺序变化时，拥有相同 <code>key</code> 的真实 DOM 元素和组件实例能够被尽可能地复用、移动，而不是销毁重建，从而保持组件内部状态（如输入框的焦点、滚动位置等）。</li>
<li><strong>性能优化</strong>：避免不必要的 DOM 操作，特别是在列表数据发生增删改排序时。</li>
</ul>
</li>
</ul>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>虚拟 DOM 和 Vue 的 <code>patch()</code> 机制是其高性能和良好开发体验的基石。</p>
<ul>
<li><code>patch()</code> 是整个更新流程的入口，负责根据新旧 VNode 的不同类型和关系，决定是创建、更新还是删除 DOM 节点。</li>
<li><code>patchVnode()</code> 专注处理被认为是同一元素的 VNode 之间的深度比较，更新它们的属性、样式和事件，并递归处理它们的子节点。</li>
<li><code>updateChildren()</code> 作为 Diff 算法的核心，通过巧妙的双端比较和 <code>key</code> 属性的辅助，高效地比对子节点列表，并执行最小化的 DOM 移动、插入和删除操作。</li>
</ul>
<p>理解这些核心函数的工作原理，不仅有助于深入掌握 Vue 的渲染机制，更能帮助我们写出更高效、更健壮的 Vue 应用。 Vue 3 虽然在细节上有所优化（如引入 PatchFlag 和 LIS 算法），但其核心的 Diff&#x2F;Patch 理念和 <code>sameVnode</code>、深度比较与子节点处理的模式是一脉相承的。Mermaid 图为理解这些复杂流程提供了直观的视觉辅助。</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/ab44062dd349/">https://blog.tbf1211.xx.kg/ab44062dd349/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-26.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/8ba79d4c7826/" title="Python SQLAlchemy 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python SQLAlchemy 详解</div></div><div class="info-2"><div class="info-item-1"> SQLAlchemy 是一个强大的 Python SQL 工具包和 ORM (Object Relational Mapper)，它为应用程序和数据库之间提供了完整的抽象层。SQLAlchemy 旨在提供高效且灵活的数据库访问，支持多种数据库后端，并允许开发者在对象操作和原生 SQL 语句之间进行灵活切换。  核心思想：将数据库操作封装为 Python 对象，既提供高层次的 ORM 抽象，简化数据模型管理；又保留低层次的 SQL 表达式语言，允许执行复杂的 SQL 查询，兼顾开发效率与性能优化。   一、为什么需要 SQLAlchemy？在 Python 应用中与数据库交互时，通常会遇到以下挑战：  数据库类型差异：不同的数据库（MySQL, PostgreSQL, SQLite, Oracle 等）有不同的 SQL 语法和连接 API。直接使用原生驱动代码会导致代码难以跨数据库移植。 SQL 语句管理：手动编写和维护 SQL 字符串容易出错，尤其是在处理复杂查询、表连接和条件过滤时，且存在 SQL 注入风险。 数据与对象映射：将数据库行数据手动转换为 Python 对象，以及...</div></div></div></a><a class="pagination-related" href="/946675bf7dca/" title="WebAssembly(Wasm)详解：浏览器中的下一代高性能计算"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</div></div><div class="info-2"><div class="info-item-1"> WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在现代Web浏览器中执行接近原生性能代码的方法。它被设计为一个可移植、体积小、加载快且与Web兼容的编译目标。Wasm 不仅限于浏览器环境，通过 WASI (WebAssembly System Interface) 等标准，它也能在服务器、物联网设备等非浏览器环境中高效运行。  核心思想：为各种编程语言（如 C&#x2F;C++、Rust、Go、Python 等）提供一个高性能、安全的编译目标，使其代码能在Web或其他沙盒环境中以接近原生速度运行。    一、为什么需要 WebAssembly？在 WebAssembly 出现之前，JavaScript 是 Web 平台唯一的编程语言。尽管 JavaScript 及其引擎（如 V8）在性能方面取得了巨大进步，但仍然存在一些固有局限性：  性能瓶颈：对于计算密集型任务（如图形处理、视频编码&#x2F;解码、科学计算、大型游戏），JavaScript 的动态类型、垃圾回收机制以及解释&#x2F;JIT编译特性，使其难以达到原生代码的性能水平。 语言选择受限：开...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/8258d22937ed/" title="Vue3 ref和reactive对比解析：深入理解响应式数据"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-04</div><div class="info-item-2">Vue3 ref和reactive对比解析：深入理解响应式数据</div></div><div class="info-2"><div class="info-item-1"> 在 Vue 3 的 Composition API 中，ref 和 reactive 是创建响应式状态的两个核心函数。它们都旨在将普通 JavaScript 数据转换为响应式数据，以便在数据变化时自动触发视图更新。然而，它们在处理数据类型、访问方式和底层机制上存在显著差异。理解这些差异对于有效地使用 Composition API 至关重要。  核心思想：ref 用于处理原始值和对象，通过 .value 访问其内部值，而 reactive 专门用于处理对象，直接访问对象的属性，且底层基于 Proxy 实现。   一、ref：处理原始值和对象ref 函数接受一个内部值（inner value），并返回一个响应式的 ref 对象。这个 ref 对象只有一个 value 属性，用来指向内部值。 1.1 定义和用法 定义：ref 可以接收任何类型的值作为参数：原始值 (string, number, boolean, null, undefined, Symbol) 或对象 (Object, Array)。 访问：在 JavaScript 中访问 ref 对象时，需要通过其 .valu...</div></div></div></a><a class="pagination-related" href="/f67db260675a/" title="Vue3 Hook(组合式 API)与Mixin对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="info-item-2">Vue3 Hook(组合式 API)与Mixin对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin 两种逻辑复用模式，从多方面进行对比分析，帮助开发者理解它们各自的优缺点，并选择最适合自己项目和团队的模式。   一、 理解 Vue 中的逻辑复用在 Vue 组件开发中，我们经常会遇到需要在多个组件中共享相同的逻辑（例如：处理鼠标位置、计时器、表单验证、主题切换等）。如果没有有效的复用机制，这些逻辑就会在不同组件中重复编写，导致代码冗余、难以维护。  Vue 提供了以下主要方式来解决逻辑复用问题：  Mixin (混入)：Vue 2 的主要逻辑复用方式，也在 Vue 3 中继续支持。 Composition API (组合式 API &#x2F; Vue 3 Hook)：Vue 3 引入...</div></div></div></a><a class="pagination-related" href="/d95444379272/" title="Pinia详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-10</div><div class="info-item-2">Pinia详解</div></div><div class="info-2"><div class="info-item-1"> Pinia 是一个直观、类型安全、轻量级的 Vue.js 状态管理库，专为 Vue 3 设计，但也支持 Vue 2。它是 Vuex 5 的非官方继任者，旨在提供更简洁、更灵活、更易于理解和使用的状态管理体验，同时完美支持 TypeScript。Pinia 不仅提供了 Vuex 的所有功能，还通过优化其 API 设计和提供更好的类型推断，解决了 Vuex 在大规模应用中遇到的一些痛点。  核心思想：Pinia 将状态分割成独立的“Store”，每个 Store 都是一个模块化的、自包含的状态管理单元，拥有自己的 state、getters、actions。这种设计使得状态管理更加模块化、可维护，并能够按需加载。   一、为什么选择 Pinia？在 Vue 3 中，Pinia 已经成为官方推荐的状态管理库，替代了Vuex。它带来的主要优势包括： 1.1 更好的 TypeScript 支持 类型安全：Pinia 从设计之初就考虑了 TypeScript。所有的 Store 定义、state、getters、actions 都有良好的类型推断，无需手动编写复杂的类型声明。 代码补全：在...</div></div></div></a><a class="pagination-related" href="/7cdd9f5b33c9/" title="前端项目工程化详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="info-item-2">前端项目工程化详解</div></div><div class="info-2"><div class="info-item-1"> 随着前端应用的复杂度日益增加，单纯依靠人工管理和协作已经无法满足高效、高质量开发的需求。前端工程化应运而生，它旨在通过将软件工程的思想和方法引入前端开发，构建一套系统化、标准化、自动化、体系化的解决方案，以提高开发效率、保障代码质量、降低维护成本。  前端工程化的核心思想是：以自动化取代人力，以工具取代重复劳动，以规范约束散漫。   一、什么是前端工程化？前端工程化是构建、管理和维护前端项目的实践和工具集。它涵盖了从项目初始化、开发、构建、测试到部署的整个生命周期，目标是提升团队协作效率、统一代码风格、保证项目质量、优化产物性能以及实现快速迭代。 它不仅仅是使用几个构建工具，更是一种体系化的思维方式和工作流。 二、为什么需要前端工程化？在没有工程化的时代，前端开发面临诸多挑战：  开发效率低下：手动重复任务（如文件合并、压缩），环境搭建复杂。 代码质量参差不齐：缺乏统一的代码规范和质量检查机制，导致 Bug 增多，难以维护。 团队协作困难：不同成员的代码风格差异大，冲突频繁，交接成本高。 项目性能不佳：缺乏自动化优化手段（如图片压缩、按需加载），页面加载慢。 部署上线复杂：手动...</div></div></div></a><a class="pagination-related" href="/c86d0a022c83/" title="React入门教程：快速构建交互式用户界面"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="info-item-2">React入门教程：快速构建交互式用户界面</div></div><div class="info-2"><div class="info-item-1"> React (通常称为 React.js 或 ReactJS) 是一个用于构建用户界面的 JavaScript 库，由 Facebook (现为 Meta) 创建和维护。它允许开发者声明式地创建复杂的、交互式的 UI，其核心思想是组件化和响应式更新。React 专注于视图层，与传统 MVC 模式中的 V (View) 相对应。  核心思想：“声明式地”构建组件化的 UI。开发者描述 UI 在给定状态下的样子，React 负责高效地更新 DOM 以匹配该状态。    重要提示: React 主要使用 TypeScript 或 JavaScript (JSX) 进行开发。本文档中的所有代码示例都将使用 TypeScript (TSX) 语言，以满足类型安全的需求。  一、为什么需要 React？在现代 Web 开发中，构建复杂的用户界面面临诸多挑战：  DOM 操作的复杂性与性能瓶颈：直接操作 DOM 繁琐且容易出错，尤其是在数据频繁变化时，手动优化 DOM 更新的性能极其困难。 代码组织与复用性：随着应用规模的增长，UI 代码变得难以管理，组件之间的逻辑耦合高，复用性差。 状态管...</div></div></div></a><a class="pagination-related" href="/884dd81c798b/" title="Pinia Colada详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">Pinia Colada详解</div></div><div class="info-2"><div class="info-item-1"> Pinia Colada 是一个为 Vue 3 和 Pinia 设计的高级数据管理和持久化工具，旨在简化异步数据获取、缓存、以及状态在浏览器存储中的持久化。它将 Pinia 的核心优势与强大的数据管理策略相结合，帮助开发者构建更健壮、响应更快、用户体验更流畅的 Web 应用。  核心思想：Pinia Colada 致力于将数据获取 (Fetching)、数据缓存 (Caching)、数据持久化 (Persistence) 和 后端状态同步 (Synchronization) 等复杂逻辑封装在易于使用的 Pinia Store 抽象之上。它使得处理异步数据像管理本地状态一样简单，同时提供声明式的 API 来控制数据的生命周期。   一、为什么需要 Pinia Colada？在现代 Web 应用中，处理异步数据（如来自 API 的数据）和管理其生命周期是一个常见的挑战。仅仅依靠 Pinia 的 actions 来 fetch 数据，并不能很好地解决以下问题：  数据重复请求：多个组件可能请求相同的数据，导致不必要的网络开销。 请求加载状态管理：手动维护每个请求的 loading 和...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">453</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%99%9A%E6%8B%9F-DOM-Virtual-DOM-%E5%86%8D%E6%8E%A2"><span class="toc-text">一、虚拟 DOM (Virtual DOM) 再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-DOM%EF%BC%9F"><span class="toc-text">1.1 什么是虚拟 DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM%EF%BC%9F"><span class="toc-text">1.2 为什么需要虚拟 DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%99%9A%E6%8B%9F-DOM-%E5%88%B0%E7%9C%9F%E5%AE%9E-DOM-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">1.3 虚拟 DOM 到真实 DOM 的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Vue-%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">二、Vue 补丁机制核心函数解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-patch-oldVnode-newVnode-%EF%BC%9A%E5%B7%AE%E5%BC%82%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-text">2.1 patch(oldVnode, newVnode)：差异发现与更新的入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-patchVnode-oldVnode-newVnode-%EF%BC%9A%E5%90%8C%E7%B1%BB%E8%8A%82%E7%82%B9%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%AF%94%E5%AF%B9%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">2.2 patchVnode(oldVnode, newVnode)：同类节点的深度比对与更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-updateChildren-oldChildren-newChildren-%EF%BC%9A%E5%AD%90%E8%8A%82%E7%82%B9%E5%88%97%E8%A1%A8%E7%9A%84-Diff-%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83"><span class="toc-text">2.3 updateChildren(oldChildren, newChildren)：子节点列表的 Diff 算法核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-key-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%B3%E5%AE%9A%E6%80%A7%E4%BD%9C%E7%94%A8"><span class="toc-text">2.4 key 属性的决定性作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">三、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-26.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>