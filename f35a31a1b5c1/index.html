<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PHP 各个版本新特性详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PHP 作为最流行的后端脚本语言之一，自诞生以来便不断演进。从早期的松散特性到现代的强类型、高性能，每一次版本迭代都带来了显著的改进。本文将详细回顾 PHP 7.0 以后，各个主要版本（7.x 和 8.x 系列）引入的新特性、性能提升和废弃功能，帮助开发者理解 PHP 的发展轨迹并更好地进行技术选型和代码迁移。  核心思想：PHP 的演进主线是：提高性能、增强类型系统、简化语法、引入现代编程范式">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP 各个版本新特性详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/f35a31a1b5c1/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="PHP 作为最流行的后端脚本语言之一，自诞生以来便不断演进。从早期的松散特性到现代的强类型、高性能，每一次版本迭代都带来了显著的改进。本文将详细回顾 PHP 7.0 以后，各个主要版本（7.x 和 8.x 系列）引入的新特性、性能提升和废弃功能，帮助开发者理解 PHP 的发展轨迹并更好地进行技术选型和代码迁移。  核心思想：PHP 的演进主线是：提高性能、增强类型系统、简化语法、引入现代编程范式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg">
<meta property="article:published_time" content="2024-01-07T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-23T03:56:22.830Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="语言版本">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PHP 各个版本新特性详解",
  "url": "https://blog.tbf1211.xx.kg/f35a31a1b5c1/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg",
  "datePublished": "2024-01-07T22:24:00.000Z",
  "dateModified": "2025-12-23T03:56:22.830Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/f35a31a1b5c1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PHP 各个版本新特性详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">425</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">219</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">PHP 各个版本新特性详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PHP 各个版本新特性详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-01-07T22:24:00.000Z" title="发表于 2024-01-08 06:24:00">2024-01-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PHP/">PHP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>PHP 作为最流行的后端脚本语言之一，自诞生以来便不断演进。从早期的松散特性到现代的强类型、高性能，每一次版本迭代都带来了显著的改进。本文将详细回顾 PHP 7.0 以后，各个主要版本（7.x 和 8.x 系列）引入的新特性、性能提升和废弃功能，帮助开发者理解 PHP 的发展轨迹并更好地进行技术选型和代码迁移。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>PHP 的演进主线是：提高性能、增强类型系统、简化语法、引入现代编程范式和清理历史遗留问题。</strong></p>
</div>
<hr>
<h2 id="一、PHP-7-0-2015年-性能飞跃的起点"><a href="#一、PHP-7-0-2015年-性能飞跃的起点" class="headerlink" title="一、PHP 7.0 (2015年) - 性能飞跃的起点"></a>一、PHP 7.0 (2015年) - 性能飞跃的起点</h2><p>PHP 7.0 是一个里程碑式的版本，其最大的亮点是引入了<strong>全新的 Zend Engine (Zend Engine 3.0，代号 PHPNG)</strong>，带来了惊人的性能提升。</p>
<h3 id="1-1-核心特性与性能提升"><a href="#1-1-核心特性与性能提升" class="headerlink" title="1.1 核心特性与性能提升"></a>1.1 核心特性与性能提升</h3><ul>
<li><strong>Zend Engine 3.0 (PHPNG)</strong>：这是 7.0 最大的亮点。与 PHP 5.6 相比，PHP 7.0 在实际应用中实现了 <strong>2 倍甚至更高的性能提升</strong>，大幅降低了内存消耗。这是通过重写 Zend Engine 的核心，优化了数据结构、Opcodes 处理和垃圾回收机制实现的。</li>
<li><strong>抽象语法树 (Abstract Syntax Tree, AST)</strong>：PHP 7.0 在内部引入了 AST，这为后续的性能优化、静态分析和编译器改进奠定了基础。</li>
<li><strong>标量类型声明 (Scalar Type Declarations)</strong>：<ul>
<li>允许对函数参数和返回值声明标量类型（<code>int</code>, <code>float</code>, <code>string</code>, <code>bool</code>）。</li>
<li>支持两种模式：<ul>
<li><strong>强制模式 (Coercive Mode)</strong>：默认模式，PHP 会尝试将传入的值转换为声明的类型（例如，<code>&quot;123&quot;</code> 会被转换为 <code>123</code>）。</li>
<li><strong>严格模式 (Strict Mode)</strong>：通过 <code>declare(strict_types=1);</code> 开启，不允许隐式类型转换，类型不匹配会抛出 <code>TypeError</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回值类型声明 (Return Type Declarations)</strong>：<ul>
<li>与标量类型声明类似，允许声明函数返回值的类型。</li>
</ul>
</li>
<li><strong>Null 合并运算符 (Null Coalescing Operator) <code>??</code></strong>：<ul>
<li>简化了检查变量是否存在并取值的逻辑。</li>
<li><code>$foo = $bar ?? &#39;default&#39;;</code> 等价于 <code>$foo = isset($bar) ? $bar : &#39;default&#39;;</code>。</li>
</ul>
</li>
<li><strong>太空船操作符 (Spaceship Operator) <code>&lt;=&gt;</code></strong>：<ul>
<li>用于比较两个表达式，当 <code>$a &lt; $b</code> 时返回 -1，当 <code>$a == $b</code> 时返回 0，当 <code>$a &gt; $b</code> 时返回 1。</li>
<li>主要用于排序回调函数。</li>
</ul>
</li>
<li><strong>匿名类 (Anonymous Classes)</strong>：<ul>
<li>允许直接在代码中定义和实例化没有名称的类，简化了只使用一次的简单对象的创建。</li>
</ul>
</li>
<li><strong>Group Use Declarations</strong>：<ul>
<li>允许在 <code>use</code> 语句中对来自同一命名空间的类、函数或常量进行分组，例如 <code>use Some\Namespace\&#123;ClassA, ClassB, ClassC as C&#125;;</code>。</li>
</ul>
</li>
<li><strong>Closure::call()</strong>：<ul>
<li>允许临时绑定一个闭包到另一个对象并调用它，无需修改对象的可见性。</li>
</ul>
</li>
<li><strong>Generator Return Expressions</strong>：<ul>
<li>允许生成器函数使用 <code>return</code> 语句返回最终值。</li>
</ul>
</li>
</ul>
<h3 id="1-2-废弃与移除"><a href="#1-2-废弃与移除" class="headerlink" title="1.2 废弃与移除"></a>1.2 废弃与移除</h3><ul>
<li>废弃了旧的 PHP 4 风格构造函数（与类名相同的函数）。</li>
<li>移除了 ASP 和 Script tag。</li>
<li>移除了 <code>mysql</code> 扩展（推荐使用 <code>mysqli</code> 或 PDO）。</li>
<li>移除了各种旧的、不推荐使用的功能。</li>
</ul>
<h2 id="二、PHP-7-1-2016年-持续完善类型系统"><a href="#二、PHP-7-1-2016年-持续完善类型系统" class="headerlink" title="二、PHP 7.1 (2016年) - 持续完善类型系统"></a>二、PHP 7.1 (2016年) - 持续完善类型系统</h2><p>PHP 7.1 在 7.0 的基础上，继续完善了类型系统，并引入了一些方便的语法糖。</p>
<h3 id="2-1-核心特性"><a href="#2-1-核心特性" class="headerlink" title="2.1 核心特性"></a>2.1 核心特性</h3><ul>
<li><strong>可为空类型 (Nullable Types)</strong>：<ul>
<li>在类型声明前加上 <code>?</code>，表示该参数或返回值可以是指定类型，也可以是 <code>null</code>。</li>
<li>例如：<code>function foo(?string $bar): ?int &#123;...&#125;</code>。</li>
</ul>
</li>
<li><strong>Void 返回类型 (Void Return Type)</strong>：<ul>
<li>函数不返回任何值时，可以声明返回类型为 <code>void</code>。</li>
<li>例如：<code>function logMessage(string $message): void &#123;...&#125;</code>。</li>
</ul>
</li>
<li><strong>类常量可见性 (Class Constant Visibility)</strong>：<ul>
<li>允许为类常量定义 <code>public</code>, <code>protected</code>, <code>private</code> 可见性。</li>
</ul>
</li>
<li><strong>多捕获异常 (Multi-catch Exception Handling)</strong>：<ul>
<li>在 <code>catch</code> 语句中可以使用 <code>|</code> 捕获多个异常类型。</li>
<li>例如：<code>catch (FirstException | SecondException $e) &#123;...&#125;</code>。</li>
</ul>
</li>
<li><strong>Iterable 伪类型 (Iterable Pseudo-type)</strong>：<ul>
<li>新的伪类型 <code>iterable</code>，可用于参数和返回值类型声明，表示该值是数组或 <code>Traversable</code> 接口的实现。</li>
</ul>
</li>
<li><strong>List Syntax With Keys</strong>：<ul>
<li>允许在 <code>list()</code> 结构中指定键，例如 <code>list(&#39;a&#39; =&gt; $a, &#39;b&#39; =&gt; $b) = $array;</code>。</li>
</ul>
</li>
<li><strong>HTTP&#x2F;2 Server Push 支持</strong>：<ul>
<li><code>curl</code> 扩展支持 HTTP&#x2F;2 Server Push (需要 cURL 7.46.0+)。</li>
</ul>
</li>
</ul>
<h3 id="2-2-废弃与移除"><a href="#2-2-废弃与移除" class="headerlink" title="2.2 废弃与移除"></a>2.2 废弃与移除</h3><ul>
<li>废弃了 <code>ext/mcrypt</code> 扩展，推荐使用 <code>ext/libsodium</code> 或 OpenSSL。</li>
<li>废弃了 <code>__FILE__</code> 魔术常量作为目录使用，推荐使用 <code>__DIR__</code>。</li>
</ul>
<h2 id="三、PHP-7-2-2017年-强化安全与现代功能"><a href="#三、PHP-7-2-2017年-强化安全与现代功能" class="headerlink" title="三、PHP 7.2 (2017年) - 强化安全与现代功能"></a>三、PHP 7.2 (2017年) - 强化安全与现代功能</h2><p>PHP 7.2 主要围绕安全性和一些现代功能的引入。</p>
<h3 id="3-1-核心特性"><a href="#3-1-核心特性" class="headerlink" title="3.1 核心特性"></a>3.1 核心特性</h3><ul>
<li><strong>新的 <code>object</code> 类型声明</strong>：<ul>
<li>引入了新的伪类型 <code>object</code>，允许将 <code>object</code> 作为函数参数和返回值类型声明。</li>
<li>例如：<code>function process(object $data): object &#123;...&#125;</code>。</li>
</ul>
</li>
<li><strong>Libsodium 扩展</strong>：<ul>
<li>将 <code>libsodium</code> 密码学库作为核心扩展集成到 PHP 中，提供了现代、安全的加密和哈希功能。</li>
<li>这是 PHP 首次将加密库内置到核心中。</li>
</ul>
</li>
<li><strong>参数类型反协变和返回值类型协变</strong>：<ul>
<li>子类方法的参数类型可以与父类方法参数类型不同，只要它更宽泛（反协变）。</li>
<li>子类方法的返回值类型可以与父类方法返回值类型不同，只要它更具体（协变）。</li>
</ul>
</li>
<li><strong>允许在 <code>trait</code> 中使用抽象方法</strong>：<ul>
<li><code>trait</code> 中可以包含抽象方法，要求使用 <code>trait</code> 的类实现这些抽象方法。</li>
</ul>
</li>
<li><strong>Trailing Comma in List Syntax</strong>：<ul>
<li>允许在 <code>list()</code> 语法中使用逗号作为最后一个元素的后缀，方便多行定义。</li>
<li>例如：<code>list($a, $b,) = [1, 2];</code>。</li>
</ul>
</li>
</ul>
<h3 id="3-2-废弃与移除"><a href="#3-2-废弃与移除" class="headerlink" title="3.2 废弃与移除"></a>3.2 废弃与移除</h3><ul>
<li>废弃了 <code>__autoload()</code> 函数，推荐使用 <code>spl_autoload_register()</code>。</li>
<li>废弃了 <code>each()</code> 函数。</li>
<li>废弃了 <code>create_function()</code> 函数。</li>
</ul>
<h2 id="四、PHP-7-3-2018年-语法糖与性能微调"><a href="#四、PHP-7-3-2018年-语法糖与性能微调" class="headerlink" title="四、PHP 7.3 (2018年) - 语法糖与性能微调"></a>四、PHP 7.3 (2018年) - 语法糖与性能微调</h2><p>PHP 7.3 带来了更多语法糖和性能微调。</p>
<h3 id="4-1-核心特性"><a href="#4-1-核心特性" class="headerlink" title="4.1 核心特性"></a>4.1 核心特性</h3><ul>
<li><strong>灵活的 Heredoc 和 Nowdoc 语法</strong>：<ul>
<li>允许在 Heredoc&#x2F;Nowdoc 标记中不缩进，并允许结束标记后跟分号。</li>
<li>例如：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span> = <span class="string">&lt;&lt;&lt;EOT</span></span><br><span class="line"><span class="string">    Hello world!</span></span><br><span class="line"><span class="string">    EOT</span>; <span class="comment">// 结束标记可以不缩进</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>List Reference Assignment (列表引用赋值)</strong>：<ul>
<li>允许在 <code>list()</code> 赋值时使用引用。</li>
<li>例如：<code>list(&amp;$a, &amp;$b) = $arr;</code>。</li>
</ul>
</li>
<li><strong><code>is_countable()</code> 函数</strong>：<ul>
<li>用于检查变量是否可以被 <code>count()</code> 函数计数（即是否是数组或实现了 <code>Countable</code> 接口的对象），避免了 <code>count()</code> 在不可计数类型上抛出警告。</li>
</ul>
</li>
<li><strong><code>array_key_first()</code> 和 <code>array_key_last()</code> 函数</strong>：<ul>
<li>获取数组的第一个或最后一个键。</li>
</ul>
</li>
<li><strong>JSON_THROW_ON_ERROR 常量</strong>：<ul>
<li><code>json_decode()</code> 和 <code>json_encode()</code> 函数在遇到错误时不再返回 <code>null</code>，而是抛出 <code>JsonException</code>。</li>
</ul>
</li>
<li><strong>PCRE2 支持</strong>：<ul>
<li>正则表达式引擎更新为 PCRE2，带来了更好的性能和更多的特性。</li>
</ul>
</li>
</ul>
<h3 id="4-2-废弃与移除"><a href="#4-2-废弃与移除" class="headerlink" title="4.2 废弃与移除"></a>4.2 废弃与移除</h3><ul>
<li>废弃了不区分大小写的常量定义。</li>
<li>废弃了 <code>image2wbmp()</code> 函数。</li>
</ul>
<h2 id="五、PHP-7-4-2019年-质的飞跃，为-PHP-8-铺路"><a href="#五、PHP-7-4-2019年-质的飞跃，为-PHP-8-铺路" class="headerlink" title="五、PHP 7.4 (2019年) - 质的飞跃，为 PHP 8 铺路"></a>五、PHP 7.4 (2019年) - 质的飞跃，为 PHP 8 铺路</h2><p>PHP 7.4 是 PHP 7.x 系列的最后一个主要版本，引入了大量重要特性，为 PHP 8.0 的到来做了很好的铺垫。</p>
<h3 id="5-1-核心特性"><a href="#5-1-核心特性" class="headerlink" title="5.1 核心特性"></a>5.1 核心特性</h3><ul>
<li><strong>类型化属性 (Typed Properties)</strong>：<ul>
<li>允许为类的属性声明类型，例如 <code>public string $name;</code>。</li>
<li>这是 PHP 类型系统的一大进步，使得代码更加健壮和易于维护。</li>
</ul>
</li>
<li><strong>箭头函数 (Arrow Functions) <code>fn()</code></strong>：<ul>
<li>提供了一种更简洁的匿名函数写法，用于单行表达式。</li>
<li>自动从父作用域捕获变量（按值），无需 <code>use</code> 关键字。</li>
<li>例如：<code>$result = array_map(fn($x) =&gt; $x * $x, $numbers);</code>。</li>
</ul>
</li>
<li><strong>Foregin Function Interface (FFI)</strong>：<ul>
<li>允许从 PHP 代码中直接调用 C 语言函数和访问 C 语言数据结构，而无需编写 PHP 扩展。</li>
<li>为 PHP 与底层系统交互提供了新的强大能力。</li>
</ul>
</li>
<li><strong>预加载 (Preloading)</strong>：<ul>
<li>在服务器启动时，将一系列 PHP 文件加载到 Opcache 内存中，并在随后的请求中直接使用，避免了每次请求的编译和加载开销。</li>
<li>显著提升了框架和大型应用的性能。</li>
</ul>
</li>
<li><strong>空合并赋值运算符 (Null Coalescing Assignment Operator) <code>??=</code></strong>：<ul>
<li>简化了检查变量是否为空并赋值的逻辑。</li>
<li><code>$array[&#39;key&#39;] ??= computeDefault();</code> 等价于 <code>if (!isset($array[&#39;key&#39;])) &#123; $array[&#39;key&#39;] = computeDefault(); &#125;</code>。</li>
</ul>
</li>
<li><strong>Spread Operator in Array Expression (数组展开运算符)</strong>：<ul>
<li>可以在数组字面量中使用 <code>...</code> 运算符展开数组。</li>
<li>例如：<code>$merged = [...$array1, ...$array2];</code>。</li>
</ul>
</li>
<li><strong>Casts for custom classes</strong>：<ul>
<li>允许对自定义类进行类型转换（不常用）。</li>
</ul>
</li>
<li><strong>密码学改进</strong>：<ul>
<li><code>password_hash()</code> 默认算法更新为 <code>ARGON2ID13</code>。</li>
</ul>
</li>
</ul>
<h3 id="5-2-废弃与移除"><a href="#5-2-废弃与移除" class="headerlink" title="5.2 废弃与移除"></a>5.2 废弃与移除</h3><ul>
<li>废弃了左结合的三元运算符。</li>
<li>废弃了不带参数调用 <code>get_parent_class()</code>。</li>
<li>废弃了 <code>implode()</code> 不符合参数顺序的用法。</li>
</ul>
<h2 id="六、PHP-8-0-2020年-现代化的重大飞跃"><a href="#六、PHP-8-0-2020年-现代化的重大飞跃" class="headerlink" title="六、PHP 8.0 (2020年) - 现代化的重大飞跃"></a>六、PHP 8.0 (2020年) - 现代化的重大飞跃</h2><p>PHP 8.0 是自 7.0 以来最重要的版本更新，引入了 JIT 编译器、联合类型等大量激动人心的新特性，并进一步提升了性能。</p>
<h3 id="6-1-核心特性与性能提升"><a href="#6-1-核心特性与性能提升" class="headerlink" title="6.1 核心特性与性能提升"></a>6.1 核心特性与性能提升</h3><ul>
<li><strong>JIT (Just In Time) 编译器</strong>：<ul>
<li>PHP 8.0 引入了两个 JIT 引擎：Tracing JIT 和 Function JIT。</li>
<li>它将部分热点代码在运行时直接编译成机器码执行，绕过 Zend VM。</li>
<li><strong>影响</strong>：对于 CPU 密集型任务（如数学计算、图像处理），性能有显著提升；对于典型的 Web 应用（I&#x2F;O 密集型），性能提升不如 7.0 显著，但仍有积极作用。</li>
</ul>
</li>
<li><strong>联合类型 (Union Types) <code>|</code></strong>：<ul>
<li>允许函数参数、返回值或属性接受多种不同类型。</li>
<li>例如：<code>public function foo(int|float $number): string|null &#123;...&#125;</code>。</li>
</ul>
</li>
<li><strong>属性 (Attributes &#x2F; Annotations)</strong>：<ul>
<li>一种将元数据添加到类、方法、属性、函数和参数的结构化方式。</li>
<li>取代了 PHPDoc 注释中用于框架配置的非标准约定，使得框架和工具能够以标准方式读取元数据。</li>
<li>例如：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[Route</span>(<span class="string">&quot;/api/users&quot;</span>, <span class="attr">methods</span>: [<span class="string">&quot;GET&quot;</span>])<span class="meta">]</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>构造器属性提升 (Constructor Property Promotion)</strong>：<ul>
<li>一种更简洁的语法，允许在构造函数的参数列表中直接定义并初始化类属性。</li>
<li>例如：<code>class User &#123; public function __construct(public string $name, public int $age) &#123;&#125; &#125;</code>。</li>
</ul>
</li>
<li><strong><code>match</code> 表达式</strong>：<ul>
<li>作为 <code>switch</code> 语句的更安全、更简洁的替代品。</li>
<li><code>match</code> 是一个表达式，会返回一个值。</li>
<li>支持多条件匹配、严格类型比较 ( <code>===</code> )，并且必须处理所有可能的匹配（或抛出 <code>UnhandledMatchError</code>）。</li>
<li>例如：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$result</span> = <span class="keyword">match</span> (<span class="variable">$status</span>) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> =&gt; <span class="string">&#x27;Pending&#x27;</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="string">&#x27;Approved&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span> =&gt; <span class="string">&#x27;Unknown&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong><code>nullsafe</code> 运算符 <code>?-&gt;</code></strong>：<ul>
<li>类似 JavaScript 的可选链（Optional Chaining），当链中任何一个元素为 <code>null</code> 时，整个表达式立即返回 <code>null</code> 而不会抛出 <code>TypeError</code>。</li>
<li>例如：<code>$country = $user?-&gt;getAddress()?-&gt;getCountry();</code>。</li>
</ul>
</li>
<li><strong>命名参数 (Named Arguments)</strong>：<ul>
<li>允许在调用函数时通过参数名来传递参数，无需严格按照参数顺序。</li>
<li>提高了代码可读性，并且可以跳过可选参数。</li>
<li>例如：<code>array_fill(start_index: 0, num: 100, value: &#39;foo&#39;);</code></li>
</ul>
</li>
<li><strong>更严格的类型检查</strong>：<ul>
<li>对内部函数和运算符进行了更严格的类型检查，减少了隐式类型转换的意外行为。</li>
</ul>
</li>
<li><strong>字符串到数字的比较优化</strong>：<ul>
<li>现在进行字符串和数字比较时，PHP 会优先将数字转换为字符串进行比较，而不是字符串转数字，减少了意外行为。</li>
</ul>
</li>
<li><strong><code>str_contains()</code>, <code>str_starts_with()</code>, <code>str_ends_with()</code> 函数</strong>：<ul>
<li>提供了更直观、更高效的字符串查找函数。</li>
</ul>
</li>
<li><strong>Weak Maps (弱映射)</strong>：<ul>
<li>键不会阻止垃圾回收，当键对象被垃圾回收后，其对应的映射条目也会自动移除。</li>
<li>适用于缓存等场景。</li>
</ul>
</li>
</ul>
<h3 id="6-2-废弃与移除"><a href="#6-2-废弃与移除" class="headerlink" title="6.2 废弃与移除"></a>6.2 废弃与移除</h3><ul>
<li>移除了 <code>create_function()</code>。</li>
<li>移除了 <code>@</code> 错误抑制符对 <code>E_ERROR</code> 和 <code>E_PARSE</code> 的作用。</li>
<li>废弃了 <code>@</code> 错误抑制符在一些特定上下文中的使用。</li>
<li>严格了数字字符串的转换行为。</li>
</ul>
<h2 id="七、PHP-8-1-2021年-枚举、只读属性和-Fiber"><a href="#七、PHP-8-1-2021年-枚举、只读属性和-Fiber" class="headerlink" title="七、PHP 8.1 (2021年) - 枚举、只读属性和 Fiber"></a>七、PHP 8.1 (2021年) - 枚举、只读属性和 Fiber</h2><p>PHP 8.1 持续引入现代语言特性，并关注并发和性能。</p>
<h3 id="7-1-核心特性"><a href="#7-1-核心特性" class="headerlink" title="7.1 核心特性"></a>7.1 核心特性</h3><ul>
<li><strong>枚举 (Enums)</strong>：<ul>
<li>引入了原生的枚举类型，允许定义一组命名常量，并且可以与类型系统集成。</li>
<li>支持纯枚举 (Pure Enums) 和支持值的枚举 (Backed Enums)。</li>
<li>例如：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Status</span>: <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> Pending = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> Approved = <span class="string">&#x27;approved&#x27;</span>;</span><br><span class="line">    <span class="keyword">case</span> Rejected = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">Status <span class="variable">$status</span></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>只读属性 (Readonly Properties)</strong>：<ul>
<li>允许将类属性声明为 <code>readonly</code>，一旦初始化（在构造函数中），就不能再被修改。</li>
<li>增强了对象的不变性。</li>
<li>例如：<code>class User &#123; public readonly string $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125; &#125;</code></li>
</ul>
</li>
<li><strong>Fibers (协程)</strong>：<ul>
<li>引入了用户空间的协程支持，允许在 PHP 中实现非阻塞的并发编程。</li>
<li><code>Fiber</code> 允许代码在执行过程中暂停和恢复，而无需使用生成器或回调地狱。</li>
<li>这是构建异步 PHP 应用（如 ReactPHP, Amphp）的基础。</li>
</ul>
</li>
<li><strong>交叉类型 (Intersection Types) <code>&amp;</code></strong>：<ul>
<li>允许参数、返回值或属性必须同时满足多个接口或类。</li>
<li>例如：<code>function process(Logger&amp;Cache $service) &#123;...&#125;</code>。</li>
</ul>
</li>
<li><strong>新的 <code>never</code> 返回类型</strong>：<ul>
<li>表示函数永远不会返回（要么抛出异常，要么终止脚本）。</li>
<li>对于一些工具函数和框架内部的函数很有用。</li>
</ul>
</li>
<li><strong><code>array_is_list()</code> 函数</strong>：<ul>
<li>检查一个数组是否是“列表” (即所有键都是连续的从 0 开始的整数，且没有间隙)。</li>
</ul>
</li>
<li><strong><code>fsync()</code> 和 <code>fdatasync()</code></strong>：<ul>
<li>文件系统同步函数。</li>
</ul>
</li>
<li><strong>First-class Callable Syntax (一等调用语法)</strong>：<ul>
<li>允许将任何可调用对象转换为 <code>Closure</code> 对象，而无需显式使用 <code>Closure::fromCallable()</code>。</li>
<li>例如：<code>$closure = my_function(...);</code> 或 <code>$closure = $object-&gt;method(...);</code>。</li>
</ul>
</li>
</ul>
<h3 id="7-2-废弃与移除"><a href="#7-2-废弃与移除" class="headerlink" title="7.2 废弃与移除"></a>7.2 废弃与移除</h3><ul>
<li>废弃了 <code>float</code> 到 <code>int</code> 的隐式转换 (<code>strict_types=1</code> 下会报错)。</li>
<li>废弃了在一些场景下 <code>new</code> 关键字在非对象上的使用。</li>
<li>一些内部函数的参数类型变严格。</li>
</ul>
<h2 id="八、PHP-8-2-2022年-只读类、Disjunctive-Normal-Form-DNF-类型"><a href="#八、PHP-8-2-2022年-只读类、Disjunctive-Normal-Form-DNF-类型" class="headerlink" title="八、PHP 8.2 (2022年) - 只读类、Disjunctive Normal Form (DNF) 类型"></a>八、PHP 8.2 (2022年) - 只读类、Disjunctive Normal Form (DNF) 类型</h2><p>PHP 8.2 继续在类型系统和安全方面发力。</p>
<h3 id="8-1-核心特性"><a href="#8-1-核心特性" class="headerlink" title="8.1 核心特性"></a>8.1 核心特性</h3><ul>
<li><strong>只读类 (Readonly Classes)</strong>：<ul>
<li>允许将整个类声明为 <code>readonly</code>，这意味着该类的所有属性都必须是只读的。</li>
<li>如果类包含 <code>readonly</code> 属性，则其所有属性必须是 <code>readonly</code> 的。</li>
<li>进一步增强了数据不变性。</li>
<li>例如：<code>readonly class User &#123; public string $name; public int $age; &#125;</code>。</li>
</ul>
</li>
<li><strong>弃用动态属性 (Deprecate Dynamic Properties)</strong>：<ul>
<li>在 PHP 8.2 中，尝试在类外部定义非声明属性会发出弃用警告。</li>
<li>在 PHP 9.0 中将被完全移除。</li>
<li>目标是提高代码的健壮性和可维护性，防止意外的属性创建。</li>
<li>如果需要动态属性，应明确使用 <code>#[AllowDynamicProperties]</code> 属性或继承 <code>stdClass</code>。</li>
</ul>
</li>
<li><strong>Disjunctive Normal Form (DNF) 类型</strong>：<ul>
<li>允许组合联合类型和交叉类型，以表达更复杂的类型约束。</li>
<li>例如：<code>(A&amp;B)|D</code> 表示类型必须是 A 和 B 的交叉类型，或者类型 D。</li>
<li><code>((A&amp;B)|C)|D</code>。</li>
</ul>
</li>
<li><strong>新的随机数扩展 (Random Extension)</strong>：<ul>
<li>提供了一个更健壮、更灵活、更可控的随机数生成器 API。</li>
<li>取代了旧的 <code>mt_rand()</code> 等函数，解决了其内部状态管理的限制。</li>
</ul>
</li>
<li><strong>常量中的敏感参数检测 (Sensitive Parameter Redaction)</strong>：<ul>
<li>通过 <code>#[SensitiveParameter]</code> 属性，可以在堆栈跟踪中自动隐藏敏感参数（如密码），防止在生产环境日志中泄露。</li>
<li>例如：<code>function login(string $username, #[SensitiveParameter] string $password) &#123; /* ... */ &#125;</code>。</li>
</ul>
</li>
<li><strong><code>true</code>, <code>false</code>, <code>null</code> 作为独立类型</strong>：<ul>
<li>允许在类型声明中使用 <code>true</code>, <code>false</code>, <code>null</code> 作为独立类型，使得类型系统更加精确。</li>
<li>例如：<code>function checkStatus(): true &#123; return true; &#125;</code>。</li>
</ul>
</li>
</ul>
<h3 id="8-2-废弃与移除"><a href="#8-2-废弃与移除" class="headerlink" title="8.2 废弃与移除"></a>8.2 废弃与移除</h3><ul>
<li>弃用动态属性（见上文）。</li>
<li><code>mb_convert_encoding()</code> 等多字节字符串函数中，一些不常用的编码别名被移除。</li>
</ul>
<h2 id="九、PHP-8-3-2023年-持续改进"><a href="#九、PHP-8-3-2023年-持续改进" class="headerlink" title="九、PHP 8.3 (2023年) - 持续改进"></a>九、PHP 8.3 (2023年) - 持续改进</h2><p>PHP 8.3 是一个维护和改进版本，包含了进一步的优化和少量新特性。</p>
<h3 id="9-1-核心特性"><a href="#9-1-核心特性" class="headerlink" title="9.1 核心特性"></a>9.1 核心特性</h3><ul>
<li><strong><code>#[Override]</code> 属性</strong>：<ul>
<li>一个静态分析属性，用于明确标记一个方法是重写父类或接口的方法。</li>
<li>如果标记了 <code>#[Override]</code> 的方法在父类&#x2F;接口中不存在同名方法，PHP 将会抛出编译时错误，防止因方法名拼写错误导致的 bug。</li>
<li>例如：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">#[Override</span><span class="meta">]</span> <span class="comment">// 明确表示这是对 ParentClass::foo() 的重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>深度克隆只读属性 (Deep Cloning of Readonly Properties)</strong>：<ul>
<li>在 <code>__clone()</code> 魔术方法中，允许对 <code>readonly</code> 属性进行深度克隆（即重新赋值）。</li>
<li>解决了只读属性在克隆时的一些限制，使得 <code>readonly</code> 类在需要进行复杂克隆操作时更加实用。</li>
</ul>
</li>
<li><strong>类常量类型 (Class Constant Type Declarations)</strong>：<ul>
<li>允许为类常量声明类型，进一步增强了类型系统的完整性。</li>
<li>例如：<code>const string NAME = &#39;App&#39;;</code>。</li>
</ul>
</li>
<li><strong><code>json_validate()</code> 函数</strong>：<ul>
<li>一个更高效的函数，用于检查一个字符串是否是有效的 JSON，而无需将其解析为 PHP 数组或对象。</li>
<li>对于只需要验证 JSON 有效性而不需要其内容的场景非常有用。</li>
</ul>
</li>
<li><strong>新的 <code>gc_status()</code> 函数</strong>：<ul>
<li>提供更详细的垃圾回收器状态信息。</li>
</ul>
</li>
<li><strong>随机数生成器改进</strong>：<ul>
<li><code>Randomizer</code> 类增加了新的方法和功能。</li>
</ul>
</li>
<li><strong>CURL 支持 <code>CURLINFO_EFFECTIVE_METHOD</code> 和 <code>CURLINFO_TOTAL_TIME_CONNNECT</code></strong>。</li>
</ul>
<h3 id="9-2-废弃与移除"><a href="#9-2-废弃与移除" class="headerlink" title="9.2 废弃与移除"></a>9.2 废弃与移除</h3><ul>
<li>废弃了 <code>mt_rand()</code> 和 <code>mt_srand()</code> 函数，推荐使用新的 <code>Randomizer</code> 类。</li>
</ul>
<h2 id="十、总结与展望"><a href="#十、总结与展望" class="headerlink" title="十、总结与展望"></a>十、总结与展望</h2><p>PHP 在 7.0 以后取得了巨大的进步，从一个被戏称为“最好用的模板语言”发展成为一个高性能、现代化、类型安全的后端语言。</p>
<ul>
<li><strong>性能方面</strong>：PHP 7.0 的 Zend Engine 3.0 和 PHP 8.0 的 JIT 编译器带来了革命性的性能提升，使 PHP 在 Web 应用领域更具竞争力。</li>
<li><strong>类型系统方面</strong>：从标量类型声明、返回值类型声明、可为空类型到类型化属性、联合类型、交叉类型、只读属性和枚举，PHP 的类型系统日益完善，使得代码更加健壮、可维护，并为静态分析工具提供了更多便利。</li>
<li><strong>语法与功能方面</strong>：箭头函数、Null 合并运算符、<code>match</code> 表达式、命名参数、属性等语法糖和新功能大大提升了开发效率和代码的可读性。</li>
<li><strong>安全与最佳实践</strong>：内置 <code>libsodium</code>、弃用动态属性、敏感参数隐藏等都体现了 PHP 社区对安全性和代码质量的重视。</li>
</ul>
<p>随着 PHP 版本的不断更新，我们可以预见它将继续在性能、类型安全、并发能力和开发者体验方面持续进步，为 Web 开发带来更多可能性。建议开发者始终关注最新版本，并尽可能升级到最新的稳定版本，以利用其带来的性能和功能优势。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/f35a31a1b5c1/">https://blog.tbf1211.xx.kg/f35a31a1b5c1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PHP/">PHP</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/">语言版本</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f5c29582f368/" title="Serverless 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Serverless 详解</div></div><div class="info-2"><div class="info-item-1"> Serverless (无服务器) 是一种云计算的执行模型，它允许开发者构建和运行应用程序而无需管理服务器。在这种模型下，云服务提供商负责服务器的调配、维护和扩展，开发者只需关注自己的代码逻辑。Serverless 并不是指“没有服务器”，而是指“开发者不需要关心服务器”。它通常包含两种核心服务模式：函数即服务 (Function-as-a-Service, FaaS) 和 后端即服务 (Backend-as-a-Service, BaaS)。  核心思想：将基础设施管理完全交给云服务商，开发者只需编写代码并部署，按实际使用量付费，实现极致的弹性伸缩和降低运维成本。   一、为什么需要 Serverless？传统的应用部署模型（物理机、虚拟机、容器）都需要开发者或运维团队投入大量精力进行服务器管理：  资源调配：预估并配置合适的 CPU、内存、存储。 操作系统管理：安装、打补丁、更新。 运行时环境：安装语言运行时、库、依赖。 扩展性：根据流量变化手动或自动伸缩服务器集群。 高可用性：设置负载均衡、故障转移机制。 监控与日志：部署监控 agent，收集日志。  这些“非功能性需求...</div></div></div></a><a class="pagination-related" href="/b9b684a2ebc6/" title="JWT (JSON Web Tokens) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JWT (JSON Web Tokens) 详解</div></div><div class="info-2"><div class="info-item-1"> JWT (JSON Web Token) 是一个开放标准 (RFC 7519)，它定义了一种简洁、自包含且安全的方式，用于在各方之间安全地传输信息。这些信息通过数字签名进行验证，可以被信任。JWT 通常用作无状态 (Stateless) 认证机制，替代传统的 Session-Cookie 模式。  核心思想：将用户认证信息和少量授权信息编码进 Token 本身，并通过签名确保其不可篡改。 服务端无需存储 Session 状态，只需验证 Token 即可。   一、为什么需要 JWT？传统的基于 Session-Cookie 的认证方式有其局限性：  有状态 (Stateful)：服务端需要存储每个用户的 Session 信息。随着用户量增加，存储和管理 Session 成为负担，特别是分布式部署和微服务架构下，Session 共享和同步变得复杂。 跨域问题：Cookie 默认是同源策略，跨域请求携带 Cookie 会比较复杂，需要复杂的 CORS (Cross-Origin Resource Sharing) 配置。 移动端不友好：移动应用通常不依赖 Cookie，需要更灵活的...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ceaafd31dca2/" title="GoLang 各版本新特性详解 (Go 1.0 至 Go 1.25)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-04</div><div class="info-item-2">GoLang 各版本新特性详解 (Go 1.0 至 Go 1.25)</div></div><div class="info-2"><div class="info-item-1"> Go 语言 (Golang) 自 2009 年由 Google 推出以来，以其简洁的语法、内置的并发支持、高效的编译速度和强大的标准库迅速获得了开发者的青睐。自 2012 年发布 Go 1.0 以来，Go 语言每半年发布一个主要版本，持续引入新特性、性能优化、工具改进和安全增强。理解这些版本特性对于 Go 开发者来说至关重要，它能帮助我们编写更高效、更现代且更具可维护性的代码。  核心思想： Go 语言的版本迭代始终秉持“简单性、可靠性、高效性”的原则，聚焦于提升开发效率、运行时性能、内存管理、工具链功能以及语言表达力。   一、Go 1.0 - 1.5：奠基与自举 (Bootstrapping)Go 语言在早期版本主要关注语言的稳定、核心功能的完善以及工具链的成熟。Go 1.5 是一个里程碑，实现了 Go 语言的自举。 1.1 Go 1.0 (2012-03-28) Go 语言的第一个稳定版本：标志着 Go 语言正式可以用于生产环境。 语言规范稳定：承诺 Go 1 兼容性，确保未来版本不会破坏 Go 1.0 代码的兼容性。 核心并发模型：Goroutine 和 Channel...</div></div></div></a><a class="pagination-related" href="/c85a04386656/" title="Vite配置详解：从入门到精通"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="info-item-2">Vite配置详解：从入门到精通</div></div><div class="info-2"><div class="info-item-1"> Vite 是一款由 Vue.js 作者尤雨溪开发的现代前端构建工具，它以其极速的开发服务器启动速度和闪电般的模块热更新 (HMR) 而闻名。Vite 利用浏览器原生的 ES Modules (ESM) 能力，在开发环境下跳过了打包步骤，直接提供模块给浏览器，从而大幅提升了开发体验。在生产环境下，Vite 采用 Rollup 进行打包，兼顾了性能和优化。本篇文档将深入探讨 Vite 的核心配置，帮助开发者充分利用 Vite 的能力。  核心思想：Vite 的配置以 vite.config.ts (或 .js) 文件为中心，使用 ESM 模块导出配置对象。它通过 plugins 数组扩展功能，通过 server 配置开发服务器，build 配置生产构建，resolve 配置模块解析，以及 css、json 等全局配置项，实现了高度可定制性和灵活性。    一、Vite 配置文件的基本结构Vite 的配置文件通常命名为 vite.config.js 或 vite.config.ts，位于项目根目录。它是一个 ESM 模块，负责导出一个配置对象。 1234567891011121314...</div></div></div></a><a class="pagination-related" href="/df020cf73515/" title="深入理解 JavaScript Fetch：为什么需要两次 await？"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-11</div><div class="info-item-2">深入理解 JavaScript Fetch：为什么需要两次 await？</div></div><div class="info-2"><div class="info-item-1"> JavaScript 中的 fetch API 提供了一种现代、强大的方式来发送网络请求。然而，初学者在使用 async/await 语法处理 fetch 请求时，经常会遇到一个困惑：为什么需要两次 await 才能获取到实际的数据？本文将深入探讨 fetch API 的设计原理，解释这“两次等待”背后的逻辑。  “Fetch API 的设计哲学：将 HTTP 响应的元数据与实际数据流分离处理。”   一、fetch API 概览fetch API 是 Web API 的一部分，用于替代老旧的 XMLHttpRequest 对象，提供了一个更强大、更灵活的用于获取资源的接口。它基于 Promise，使得异步请求的处理更加简洁。 一个典型的 fetch 请求（不使用 async/await）看起来是这样的： 123456789101112131415fetch(&#x27;https://api.example.com/data&#x27;)  .then(response =&gt; &#123;    // 第一次 then: 处理响应头和状态    if (!respons...</div></div></div></a><a class="pagination-related" href="/0a6eb114d7c3/" title="Java 虚拟线程 (Virtual Threads) 详解 - Project Loom 的成果"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-22</div><div class="info-item-2">Java 虚拟线程 (Virtual Threads) 详解 - Project Loom 的成果</div></div><div class="info-2"><div class="info-item-1"> 虚拟线程 (Virtual Threads) 是 Java 平台在 JDK 21 中正式引入 的一项革命性并发特性（作为 Project Loom 1 的主要成果）。它旨在显著简化高吞吐量并发应用的开发和维护，通过提供轻量级的、由 JVM 管理的线程，解决传统平台线程在高并发场景下的性能瓶颈和资源消耗问题。  核心思想：虚拟线程让开发者能够继续沿用更直观的“一请求一线程 (thread-per-request)”的编程模型，同时获得接近异步编程的扩展能力。它将阻塞 I&#x2F;O 操作的开销从昂贵的操作系统线程转移到了 JVM 层面，从而在不改变代码风格的情况下，极大提升了服务器应用的并发吞吐量。   一、为什么需要虚拟线程？(传统并发的痛点)在 Java 历史上，处理并发主要依赖于传统的 平台线程 (Platform Threads)，也就是我们通常所说的 java.lang.Thread 类实例。这些线程直接映射到操作系统 (OS) 线程。 传统平台线程在高并发场景下存在以下痛点：  资源开销大：每个平台线程都需要操作系统分配独立的栈空间（通常 1MB 或更多），以及维护...</div></div></div></a><a class="pagination-related" href="/1d1a23609f01/" title="Java 内存泄漏详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-13</div><div class="info-item-2">Java 内存泄漏详解</div></div><div class="info-2"><div class="info-item-1"> Java 内存泄漏 (Memory Leak) 是指程序中已不再需要使用的对象，仍然被“根对象”链所引用，导致垃圾回收器无法对其进行回收，从而占用宝贵的堆内存。随着程序的运行，内存泄漏会不断累积，最终可能导致应用程序运行缓慢、响应迟钝，直至抛出 OutOfMemoryError (OOM) 错误而崩溃。  核心思想：内存泄漏的本质是“应该被回收但未被回收的对象”。理解 Java 垃圾回收机制和对象生命周期是诊断和避免内存泄漏的关键。    一、什么是内存泄漏？在 Java 中，我们通常不直接管理内存，而是依赖 JVM 的垃圾回收器 (GC) 自动回收不再使用的对象。一个对象是否“不再需要”，GC 通过可达性分析算法来判断：如果从 GC Roots 无法到达某个对象，则认为该对象是“垃圾”，可以被回收。 内存泄漏的定义：当一个对象实际上已经不再需要（即业务逻辑上它已经“死亡”），但从 GC Roots 到它仍然存在一条强引用链 (Strong Reference Chain)，导致 GC 无法回收它所占用的内存。 这种情况下，JVM 误认为该对象仍然“存活”，从而阻止了它的回收。...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">425</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">219</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81PHP-7-0-2015%E5%B9%B4-%E6%80%A7%E8%83%BD%E9%A3%9E%E8%B7%83%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-text">一、PHP 7.0 (2015年) - 性能飞跃的起点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-text">1.1 核心特性与性能提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">1.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81PHP-7-1-2016%E5%B9%B4-%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">二、PHP 7.1 (2016年) - 持续完善类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">2.1 核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">2.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81PHP-7-2-2017%E5%B9%B4-%E5%BC%BA%E5%8C%96%E5%AE%89%E5%85%A8%E4%B8%8E%E7%8E%B0%E4%BB%A3%E5%8A%9F%E8%83%BD"><span class="toc-text">三、PHP 7.2 (2017年) - 强化安全与现代功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">3.1 核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">3.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81PHP-7-3-2018%E5%B9%B4-%E8%AF%AD%E6%B3%95%E7%B3%96%E4%B8%8E%E6%80%A7%E8%83%BD%E5%BE%AE%E8%B0%83"><span class="toc-text">四、PHP 7.3 (2018年) - 语法糖与性能微调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">4.1 核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">4.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81PHP-7-4-2019%E5%B9%B4-%E8%B4%A8%E7%9A%84%E9%A3%9E%E8%B7%83%EF%BC%8C%E4%B8%BA-PHP-8-%E9%93%BA%E8%B7%AF"><span class="toc-text">五、PHP 7.4 (2019年) - 质的飞跃，为 PHP 8 铺路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">5.1 核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">5.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81PHP-8-0-2020%E5%B9%B4-%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E9%87%8D%E5%A4%A7%E9%A3%9E%E8%B7%83"><span class="toc-text">六、PHP 8.0 (2020年) - 现代化的重大飞跃</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-text">6.1 核心特性与性能提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">6.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81PHP-8-1-2021%E5%B9%B4-%E6%9E%9A%E4%B8%BE%E3%80%81%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7%E5%92%8C-Fiber"><span class="toc-text">七、PHP 8.1 (2021年) - 枚举、只读属性和 Fiber</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">7.1 核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">7.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81PHP-8-2-2022%E5%B9%B4-%E5%8F%AA%E8%AF%BB%E7%B1%BB%E3%80%81Disjunctive-Normal-Form-DNF-%E7%B1%BB%E5%9E%8B"><span class="toc-text">八、PHP 8.2 (2022年) - 只读类、Disjunctive Normal Form (DNF) 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">8.1 核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">8.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81PHP-8-3-2023%E5%B9%B4-%E6%8C%81%E7%BB%AD%E6%94%B9%E8%BF%9B"><span class="toc-text">九、PHP 8.3 (2023年) - 持续改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">9.1 核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%BA%9F%E5%BC%83%E4%B8%8E%E7%A7%BB%E9%99%A4"><span class="toc-text">9.2 废弃与移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-text">十、总结与展望</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能体 (Agent) 详解：深入 LangChain 开发实践"/></a><div class="content"><a class="title" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践">智能体 (Agent) 详解：深入 LangChain 开发实践</a><time datetime="2025-12-10T22:24:00.000Z" title="发表于 2025-12-11 06:24:00">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-02.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>