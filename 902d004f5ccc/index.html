<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>浏览器指纹 (Browser Fingerprinting) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器指纹 (Browser Fingerprinting) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/902d004f5ccc/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg">
<meta property="article:published_time" content="2025-03-14T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-04T09:47:15.113Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "浏览器指纹 (Browser Fingerprinting) 详解",
  "url": "https://blog.tbf1211.xx.kg/902d004f5ccc/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg",
  "datePublished": "2025-03-14T22:24:00.000Z",
  "dateModified": "2026-02-04T09:47:15.113Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/902d004f5ccc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浏览器指纹 (Browser Fingerprinting) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">544</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-08.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">浏览器指纹 (Browser Fingerprinting) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">浏览器指纹 (Browser Fingerprinting) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-03-14T22:24:00.000Z" title="发表于 2025-03-15 06:24:00">2025-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。</p>
</blockquote>
<div class="note info flat"><p>“你的浏览器就像你的手纹一样，看似普通，却独一无二。”</p>
</div>
<hr>
<h2 id="一、什么是浏览器指纹？"><a href="#一、什么是浏览器指纹？" class="headerlink" title="一、什么是浏览器指纹？"></a>一、什么是浏览器指纹？</h2><p>浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。</p>
<p>这个“指纹”的强大之处在于其<strong>持久性</strong>和<strong>隐蔽性</strong>，用户很难通过常规手段进行清除或规避。</p>
<h2 id="二、浏览器指纹的工作原理"><a href="#二、浏览器指纹的工作原理" class="headerlink" title="二、浏览器指纹的工作原理"></a>二、浏览器指纹的工作原理</h2><p>网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括：</p>
<h3 id="1-HTTP-请求头信息-HTTP-Headers"><a href="#1-HTTP-请求头信息-HTTP-Headers" class="headerlink" title="1. HTTP 请求头信息 (HTTP Headers)"></a>1. HTTP 请求头信息 (HTTP Headers)</h3><p>这是最基础的指纹信息，每次 HTTP 请求都会携带：</p>
<ul>
<li><code>User-Agent</code>: 浏览器、操作系统和设备类型。</li>
<li><code>Accept-Language</code>: 浏览器接受的语言设置。</li>
<li><code>Accept-Encoding</code>: 浏览器接受的编码方式。</li>
</ul>
<h3 id="2-屏幕和显示器信息-Screen-Display"><a href="#2-屏幕和显示器信息-Screen-Display" class="headerlink" title="2. 屏幕和显示器信息 (Screen &amp; Display)"></a>2. 屏幕和显示器信息 (Screen &amp; Display)</h3><p>通过 <code>window.screen</code> 和 <code>window.innerWidth</code>&#x2F;<code>innerHeight</code> 等 API 获取：</p>
<ul>
<li>屏幕分辨率 (e.g., <code>1920x1080</code>)。</li>
<li>颜色深度 (e.g., <code>24-bit</code>)。</li>
<li>操作系统界面缩放比例 (DPI)。</li>
</ul>
<h3 id="3-插件和扩展信息-Plugins-Extensions"><a href="#3-插件和扩展信息-Plugins-Extensions" class="headerlink" title="3. 插件和扩展信息 (Plugins &amp; Extensions)"></a>3. 插件和扩展信息 (Plugins &amp; Extensions)</h3><p>过去常通过 <code>navigator.plugins</code> 和 <code>navigator.mimeTypes</code> 获取 Flash, Java 等插件信息。现在随着 Flash 等插件的淘汰，这个方法的重要性下降，但浏览器扩展依然可以被检测到。</p>
<h3 id="4-字体信息-Fonts"><a href="#4-字体信息-Fonts" class="headerlink" title="4. 字体信息 (Fonts)"></a>4. 字体信息 (Fonts)</h3><p>通过 JavaScript 检测系统上安装的字体列表。即使只是几款独特字体，也能显著增加指纹的独特性。</p>
<ul>
<li><strong>原理</strong>: 创建一个隐藏的 DOM 元素，设置待检测字体，然后测量该元素的宽度和高度。如果尺寸与默认字体不同，则说明该字体已安装。</li>
</ul>
<h3 id="5-Canvas-指纹-Canvas-Fingerprinting"><a href="#5-Canvas-指纹-Canvas-Fingerprinting" class="headerlink" title="5. Canvas 指纹 (Canvas Fingerprinting)"></a>5. Canvas 指纹 (Canvas Fingerprinting)</h3><p>这是目前最强大、最普遍的指纹技术之一。</p>
<ul>
<li><strong>原理</strong>: 浏览器使用 <code>Canvas</code> API 绘制（渲染）一段文本或图形。由于不同设备、操作系统、浏览器、GPU、字体渲染引擎甚至硬件驱动之间存在的微小差异，即使是完全相同的指令，渲染出的像素数据也会有微小的不同。</li>
<li><strong>过程</strong>:<ol>
<li>网站在 Canvas 上绘制一些文本（通常带一些渐变、阴影等效果）和图形。</li>
<li>将 Canvas 内容导出为图片数据（例如 <code>toDataURL()</code> 或 <code>getImageData()</code>）。</li>
<li>对图像数据进行哈希运算，生成一个唯一的字符串作为指纹。</li>
</ol>
</li>
<li><strong>独特性</strong>: 即使肉眼无法察觉的像素差异，也会导致哈希值不同。</li>
</ul>
<h3 id="6-AudioContext-指纹-AudioContext-Fingerprinting"><a href="#6-AudioContext-指纹-AudioContext-Fingerprinting" class="headerlink" title="6. AudioContext 指纹 (AudioContext Fingerprinting)"></a>6. AudioContext 指纹 (AudioContext Fingerprinting)</h3><p>与 Canvas 指纹类似，它利用 Web Audio API。</p>
<ul>
<li><strong>原理</strong>: 通过 JavaScript 创建一个 <code>AudioContext</code>，生成特定的音频波形，然后通过读取音频数据的特性（如音量、相位等）来生成哈希值。不同设备上的音频硬件、驱动、操作系统和软件库在处理音频时产生的微小差异，会导致相同音频指令的输出结果不一致。</li>
<li><strong>过程</strong>:<ol>
<li>使用 <code>AudioContext</code> 构造一个独特的音频信号图。</li>
<li>处理该信号（例如，进行压缩、混响等操作）。</li>
<li>将处理后的信号数据转换为哈希值。</li>
</ol>
</li>
<li><strong>独特性</strong>: 同样具有高度的唯一识别能力。</li>
</ul>
<h3 id="7-WebGL-指纹-WebGL-Fingerprinting"><a href="#7-WebGL-指纹-WebGL-Fingerprinting" class="headerlink" title="7. WebGL 指纹 (WebGL Fingerprinting)"></a>7. WebGL 指纹 (WebGL Fingerprinting)</h3><p>利用 WebGL API 访问 GPU 信息。</p>
<ul>
<li><strong>原理</strong>: 通过 WebGL 绘制 3D 图形，获取 GPU 的渲染细节和能力。不同显卡型号、驱动版本、操作系统对 WebGL 的实现差异会产生独特的渲染结果。</li>
<li><strong>过程</strong>: 获取 <code>renderer</code> 字符串、纹理单元数量、最大视口尺寸等，并结合渲染结果进行哈希。</li>
</ul>
<h3 id="8-WebRTC-和系统信息"><a href="#8-WebRTC-和系统信息" class="headerlink" title="8. WebRTC 和系统信息"></a>8. WebRTC 和系统信息</h3><ul>
<li><strong>本地 IP 地址</strong>: WebRTC 可以获取用户设备的本地 IP 地址，即使使用了 VPN。但这通常需要用户授权。</li>
<li><strong>操作系统和硬件</strong>: 通过 <code>navigator.platform</code>, <code>navigator.hardwareConcurrency</code> (CPU 核心数), <code>navigator.deviceMemory</code> (内存) 等获取。</li>
</ul>
<h3 id="9-时区和语言设置"><a href="#9-时区和语言设置" class="headerlink" title="9. 时区和语言设置"></a>9. 时区和语言设置</h3><p>通过 <code>Intl.DateTimeFormat().resolvedOptions().timeZone</code> 和 <code>navigator.language</code>&#x2F;<code>languages</code> 获取。</p>
<h3 id="10-其他细微差异"><a href="#10-其他细微差异" class="headerlink" title="10. 其他细微差异"></a>10. 其他细微差异</h3><ul>
<li><strong>电池状态 API</strong>: <code>navigator.getBattery()</code> (现在通常被限制使用)。</li>
<li><strong>摄像头&#x2F;麦克风设备 ID</strong>: 在某些情况下可能获取。</li>
<li><strong>浏览器对特定 CSS 属性、JS API 的实现差异或 BUG。</strong></li>
</ul>
<h2 id="三、浏览器指纹的挑战和影响"><a href="#三、浏览器指纹的挑战和影响" class="headerlink" title="三、浏览器指纹的挑战和影响"></a>三、浏览器指纹的挑战和影响</h2><h3 id="1-隐私问题"><a href="#1-隐私问题" class="headerlink" title="1. 隐私问题"></a>1. 隐私问题</h3><ul>
<li><strong>持久性追踪</strong>: 即使清除 cookies 或使用隐私模式，用户也可能被持续追踪，这破坏了用户的匿名性期望。</li>
<li><strong>数据聚合</strong>: 跨网站的数据聚合变得更加容易，用户在不同网站上的行为可能被关联起来，形成更完整的用户画像。</li>
<li><strong>个性化广告</strong>: 广告商可以更精准地投放广告，甚至基于用户的“隐形”数据进行定向。</li>
</ul>
<h3 id="2-安全问题"><a href="#2-安全问题" class="headerlink" title="2. 安全问题"></a>2. 安全问题</h3><ul>
<li><strong>身份伪造</strong>: 恶意攻击者如果能获取到你的浏览器指纹，可能尝试伪造你的设备身份，绕过一些简单的设备验证。</li>
<li><strong>账户接管</strong>: 与其他信息结合，可以增加账户被接管的风险。</li>
</ul>
<h3 id="3-法规和伦理争议"><a href="#3-法规和伦理争议" class="headerlink" title="3. 法规和伦理争议"></a>3. 法规和伦理争议</h3><ul>
<li>许多隐私法规（如 GDPR、CCPA）要求网站在收集用户数据前获得明确同意。浏览器指纹的隐蔽性使其难以符合这些规定。</li>
<li>关于这种“隐形追踪”是否符合伦理道德，一直存在争议。</li>
</ul>
<h2 id="四、如何对抗浏览器指纹？"><a href="#四、如何对抗浏览器指纹？" class="headerlink" title="四、如何对抗浏览器指纹？"></a>四、如何对抗浏览器指纹？</h2><p>对抗浏览器指纹是一个复杂且持续发展的猫鼠游戏，没有一劳永逸的解决方案，但以下方法可以增加识别难度：</p>
<h3 id="1-使用隐私浏览器"><a href="#1-使用隐私浏览器" class="headerlink" title="1. 使用隐私浏览器"></a>1. 使用隐私浏览器</h3><ul>
<li><strong>Tor 浏览器 (Tor Browser)</strong>: 被认为是目前对抗浏览器指纹最有效的工具之一。它通过标准化所有用户的指纹，使得所有 Tor 用户的浏览器看起来都一样，从而提高匿名性。</li>
<li><strong>Brave 浏览器</strong>: 内置了指纹保护功能，可以随机化或限制指纹信息的暴露。</li>
<li><strong>Firefox 的增强型跟踪保护</strong>: 提供“严格”模式，一定程度上减轻指纹追踪。</li>
</ul>
<h3 id="2-浏览器扩展-插件"><a href="#2-浏览器扩展-插件" class="headerlink" title="2. 浏览器扩展&#x2F;插件"></a>2. 浏览器扩展&#x2F;插件</h3><p>安装专门对抗指纹的扩展，例如：</p>
<ul>
<li><strong>CanvasBlocker</strong>: 阻止或欺骗 Canvas API。</li>
<li><strong>Trace</strong>: 尝试伪造或随机化多种指纹信息。</li>
<li><strong>Privacy Badger</strong>: 识别并阻止隐藏的追踪器。</li>
</ul>
<h3 id="3-通用设置调整"><a href="#3-通用设置调整" class="headerlink" title="3. 通用设置调整"></a>3. 通用设置调整</h3><ul>
<li><strong>禁用 JavaScript (慎重)</strong>: 禁用 JavaScript 会阻止绝大多数指纹收集，但也会导致绝大多数网站无法正常工作。</li>
<li><strong>频繁更换浏览器和设备</strong>: 实际操作性较差。</li>
<li><strong>使用虚拟机或沙箱环境</strong>: 每次启动都提供一个“全新”的浏览器环境，可以有效对抗指纹，但操作麻烦。</li>
</ul>
<h3 id="4-随机化指纹信息-SPOOFING"><a href="#4-随机化指纹信息-SPOOFING" class="headerlink" title="4. 随机化指纹信息 (SPOOFING)"></a>4. 随机化指纹信息 (SPOOFING)</h3><p>某些工具或浏览器，通过每次访问时随机化部分指纹信息（例如 User-Agent, Canvas 渲染结果的微小噪声），使得每次生成的指纹都略有不同，从而避免被关联。</p>
<h3 id="5-注意浏览习惯"><a href="#5-注意浏览习惯" class="headerlink" title="5. 注意浏览习惯"></a>5. 注意浏览习惯</h3><ul>
<li>尽量避免登录或使用不同身份访问同一网站。</li>
<li>定期审查和调整浏览器的隐私设置。</li>
</ul>
<h2 id="五、浏览器指纹的积极用途-双刃剑"><a href="#五、浏览器指纹的积极用途-双刃剑" class="headerlink" title="五、浏览器指纹的积极用途 (双刃剑)"></a>五、浏览器指纹的积极用途 (双刃剑)</h2><p>尽管主要被用于追踪和广告，浏览器指纹在某些情况下也有积极作用：</p>
<ol>
<li><strong>欺诈检测和预防</strong>: 银行、电商网站等可以使用指纹来检测可疑登录和欺诈交易，例如，如果用户突然从一个过去从未见过的指纹设备（即使 IP 地址在正常范围内）登录，可能会触发额外的安全验证。</li>
<li><strong>账户安全</strong>: 作为辅助验证手段，帮助识别用户设备，增强账户安全性。</li>
<li><strong>防止机器人和爬虫</strong>: 识别非人类访问，保护网站资源。</li>
<li><strong>提供更好的用户体验</strong>: 识别设备特性，为用户提供更匹配其设备性能的网页版本。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>浏览器指纹是数字时代隐私与便利之争的一个缩影。它揭示了我们在线行为的透明性远超我们想象。作为用户，了解其工作原理有助于我们更好地采取措施保护自己的隐私。作为开发者，我们需要在利用这些技术提供更好服务的同时，认真考虑其中的隐私风险和伦理界限，并遵守相关的政策法规。隐私保护是一个持续的挑战，需要技术、法律和用户意识的共同努力。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/902d004f5ccc/">https://blog.tbf1211.xx.kg/902d004f5ccc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-08.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/e4825d97fe27/" title="Netlify介绍"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Netlify介绍</div></div><div class="info-2"><div class="info-item-1"> Netlify 是一个领先的自动化平台，用于部署和托管现代 Web 项目。它将持续集成&#x2F;持续部署 (CI&#x2F;CD)、全球内容分发网络 (CDN)、Serverless Functions 和边缘计算等功能整合到一个统一的工作流中。Netlify 广受欢迎，尤其是在 Jamstack 生态系统中，它简化了 Web 应用程序的构建、部署和扩展过程，让开发者能够专注于代码，而无需管理复杂的服务器基础设施。  核心思想：Netlify 提供了一个一站式的“前端云”平台，它将 Git 仓库连接、自动化构建、全球 CDN 部署、Serverless 后端和附加服务无缝集成，旨在为开发者提供最快速、最简便的现代化 Web 应用部署体验。   一、为什么选择 Netlify？传统的 Web 部署通常涉及配置服务器、管理 CDN、设置 CI&#x2F;CD 管道等复杂任务。Netlify 应运而生，解决了这些痛点，提供了一套高效的解决方案：  极简部署：只需连接 Git 仓库，每次代码提交都会自动构建和部署。 Jamstack 优化：完美支持静态站点生成器 (SSG) 和单页应...</div></div></div></a><a class="pagination-related" href="/039eceb7c0db/" title="Golang Dig 深度解析：强大的依赖注入容器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang Dig 深度解析：强大的依赖注入容器</div></div><div class="info-2"><div class="info-item-1"> Dig 是 Google 开源的一个用于 Go 语言的依赖注入 (Dependency Injection, DI) 容器。它旨在帮助 Go 开发者管理复杂的应用程序对象图，通过自动化的方式解决组件之间的依赖关系，从而提高代码的可测试性、可维护性和模块化程度。  核心思想：Dig 通过 Go 语言的反射机制，在运行时分析函数的参数和返回值类型，自动构建并解析应用程序的依赖图。它将对象创建的逻辑（”提供者”）和对象使用的逻辑（”调用者”）分离，使得开发者无需手动管理复杂的对象实例化过程。   一、为什么需要依赖注入和 Dig？在构建复杂的 Go 应用程序时，组件之间往往存在错综复杂的依赖关系。手动管理这些依赖通常会导致以下问题：  代码耦合度高：当一个结构体直接实例化其依赖的结构体时，两者紧密耦合。 难以测试：紧密耦合使得单元测试难以进行，因为无法轻松替换依赖项（如用 Mock 对象替代真实的数据库连接）。 实例化逻辑分散：对象的创建逻辑可能散布在应用程序的各个部分，难以统一管理和追踪。 难以重构：修改一个组件的依赖可能需要修改所有使用它的地方。  依赖注入 (DI) 是一种软件...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/309197e65213/" title="DOM Clobbering 漏洞详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-07</div><div class="info-item-2">DOM Clobbering 漏洞详解</div></div><div class="info-2"><div class="info-item-1"> DOM Clobbering (DOM 覆盖) 是一种特殊的 Web 安全漏洞，它允许攻击者通过可控的 HTML 片段，意外地覆盖（”clobber”）或修改网页中的全局 JavaScript 变量、对象或属性。这种攻击方式利用了浏览器对带有 id 或 name 属性的 HTML 元素在全局 window 对象上创建引用或在 document 对象上创建属性的机制，从而篡改前端脚本的执行逻辑，最终可能导致 XSS (Cross-Site Scripting) 或其他客户端逻辑问题。  核心思想：通过注入特定的 HTML 元素（通常带有 id 或 name 属性），欺骗浏览器，使其将这些 HTML 元素作为 JavaScript 代码中预期的全局变量或对象属性来处理，从而导致类型混淆或值替换。   一、为什么会存在 DOM Clobbering？DOM Clobbering 漏洞的根源在于浏览器的一些遗留特性 (Legacy Features) 和 JavaScript 的设计原则：  全局命名空间污染：浏览器为了方便，将具有 id 属性的 HTML 元素自动作为 window ...</div></div></div></a><a class="pagination-related" href="/29965d782f2a/" title="Metasploit 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-18</div><div class="info-item-2">Metasploit 框架详解</div></div><div class="info-2"><div class="info-item-1"> Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1 什么是 Metasploit？Metasploit 是由 Rapid7 公司维护的一个著名的开源项目。它是一个漏洞利用框架，旨在协助渗透测试人员识别、利用和验证漏洞。它不仅仅是一个简单的漏洞扫描器，更是一个提供多种工具和方法的集成环境，几乎覆盖了渗透测试的整个生命周期。 1.2 Metasploit 的发展历史 2003年：由 H.D. Moore 发起，最初是一个 Perl 语言的项目。 2004年：发布 2.0 版本，首次引入了模块化架构。 2007年：框架被重写，使用 Ruby 语言，提高了灵活性和可维护性。 209年：Rapid7 收购 Metasploit 项目，并继续其开发...</div></div></div></a><a class="pagination-related" href="/f1d2005549f2/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-28</div><div class="info-item-2">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</div></div><div class="info-2"><div class="info-item-1"> 在过去十年中，前端开发领域由 JavaScript 框架（如 React, Vue, Angular）占据主导地位，它们将整个用户界面放在客户端，通过 API 与后端交互。然而，这种“单页应用 (SPA)”模式并非总是最佳选择，它带来了复杂的构建流程、初始加载性能问题、SEO 挑战以及较高的开发和维护成本。 HTMX 的出现，挑战了这一主流范式。它主张将交互逻辑回归到服务器端，通过简单的 HTML 属性就能实现 AJAX 请求、CSS 过渡、WebSocket 和服务器发送事件 (SSE)，在不编写一行 JavaScript 代码的情况下，实现丰富的动态用户体验。  本文将深入探讨 HTMX 的核心理念、工作原理、主要特性、优缺点以及适用场景，帮助你理解这个“返璞归真”但又极具创新力的工具。   一、 HTMX 是什么？核心理念与哲学HTMX 是一个小型 (约 15KB gzipped) 的 JavaScript 库，它通过扩展 HTML 原生能力，允许你在 HTML 元素上直接指定 AJAX 请求、CSS 动画、WebSocket 和服务器发送事件 (SSE) 行为。 其核心...</div></div></div></a><a class="pagination-related" href="/ac609e6566a8/" title="DAST (Dynamic Application Security Testing) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-02</div><div class="info-item-2">DAST (Dynamic Application Security Testing) 详解</div></div><div class="info-2"><div class="info-item-1"> DAST (Dynamic Application Security Testing)，中文译为动态应用程序安全测试，是一种黑盒安全测试方法。它通过模拟恶意攻击者的行为，在不接触应用程序源代码的情况下，对正在运行的应用程序（包括Web应用、API和服务）进行测试，以发现运行时存在的安全漏洞。 DAST 工具会向应用程序发送各种恶意输入和请求，然后分析应用程序的响应，以识别潜在的漏洞，例如 SQL 注入、跨站脚本 (XSS)、不安全的直接对象引用等。  核心思想：DAST 从外部视角模拟真实世界的攻击，测试应用程序在实际运行环境中的安全性。它关注的是应用程序在被部署和运行时可能暴露出的漏洞，而非代码本身的缺陷。   一、为什么需要 DAST？在软件开发生命周期 (SDLC) 中，确保应用程序安全至关重要。虽然静态应用程序安全测试 (SAST) 可以从代码层面发现漏洞，但 DAST 弥补了 SAST 的不足：  真实运行环境：DAST 在应用程序部署后运行，测试的是实际的配置、部署环境和第三方组件交互，能够发现只在运行时暴露的漏洞（例如，不正确的服务器配置、环境变量泄露、跨域资源共...</div></div></div></a><a class="pagination-related" href="/fc0a62ae56f9/" title="OAuth2.0详解：现代授权框架的核心原理与应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-09</div><div class="info-item-2">OAuth2.0详解：现代授权框架的核心原理与应用</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0（Open Authorization）是一个开放标准，定义了一套授权流程，允许用户（资源所有者）授权第三方应用访问他们在另一个服务提供者（授权服务器）上的受保护资源（资源服务器），而无需将自己的用户名和密码直接提供给第三方应用。它主要解决的是委托授权的问题，即“我授权应用A去访问我在服务B上的某些数据”。  核心区分：OAuth 2.0 是一个授权（Authorization）框架，而不是用来做认证（Authentication）。尽管它常常与认证机制（如 OpenID Connect）结合使用，但其核心职责是授予对资源的访问权限，而非验证用户身份。   一、OAuth 2.0 产生的背景与解决的问题在 OAuth 出现之前，如果一个第三方应用需要访问用户在其他服务（如 Google 相册、GitHub 代码库）上的数据，用户通常需要将自己的账号密码直接告知第三方应用。这种做法带来了严重的安全和便捷性问题：  凭据泄露风险：第三方应用一旦被攻破，或恶意使用，用户的完整凭据就会泄露，导致所有关联服务面临风险。 权限过大：第三方应用获得的是用户的完全控制权，无法...</div></div></div></a><a class="pagination-related" href="/7420d7912dc7/" title="CSS 注入 (CSS Injection) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-31</div><div class="info-item-2">CSS 注入 (CSS Injection) 详解</div></div><div class="info-2"><div class="info-item-1"> CSS 注入 (CSS Injection) 是一种客户端攻击技术，攻击者通过在网页中注入恶意的 Cascading Style Sheets (CSS) 代码，从而实现对页面样式、布局的篡改，甚至是窃取用户信息、进行用户行为监控、绕过某些安全机制等目的。它与常见的 XSS (Cross-Site Scripting) 攻击有所不同，CSS 注入本身不会直接执行 JavaScript 代码，但其危害不容小觑。  CSS 注入通常发生在 Web 应用程序未能正确净化或编码用户提供的输入，并将其不加识别地插入到 HTML &lt;style&gt; 标签、HTML 元素的 style 属性或外部 CSS 文件链接中时。它的强大之处在于能够利用 CSS 选择器和属性的特性，实现一些意想不到的攻击效果。   一、CSS 注入的产生机制CSS 注入的核心在于攻击者能够控制页面中 CSS 的一部分或全部。这通常发生在以下几种情况：  用户输入直接插入 &lt;style&gt; 标签内部：当应用程序允许用户输入的数据直接被渲染到 HTML 页面中的 &lt;style&gt; 标签内部时，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">544</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%EF%BC%9F"><span class="toc-text">一、什么是浏览器指纹？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、浏览器指纹的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HTTP-%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF-HTTP-Headers"><span class="toc-text">1. HTTP 请求头信息 (HTTP Headers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%8F%E5%B9%95%E5%92%8C%E6%98%BE%E7%A4%BA%E5%99%A8%E4%BF%A1%E6%81%AF-Screen-Display"><span class="toc-text">2. 屏幕和显示器信息 (Screen &amp; Display)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E4%BB%B6%E5%92%8C%E6%89%A9%E5%B1%95%E4%BF%A1%E6%81%AF-Plugins-Extensions"><span class="toc-text">3. 插件和扩展信息 (Plugins &amp; Extensions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E4%BD%93%E4%BF%A1%E6%81%AF-Fonts"><span class="toc-text">4. 字体信息 (Fonts)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Canvas-%E6%8C%87%E7%BA%B9-Canvas-Fingerprinting"><span class="toc-text">5. Canvas 指纹 (Canvas Fingerprinting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-AudioContext-%E6%8C%87%E7%BA%B9-AudioContext-Fingerprinting"><span class="toc-text">6. AudioContext 指纹 (AudioContext Fingerprinting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-WebGL-%E6%8C%87%E7%BA%B9-WebGL-Fingerprinting"><span class="toc-text">7. WebGL 指纹 (WebGL Fingerprinting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-WebRTC-%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-text">8. WebRTC 和系统信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%97%B6%E5%8C%BA%E5%92%8C%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE"><span class="toc-text">9. 时区和语言设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%85%B6%E4%BB%96%E7%BB%86%E5%BE%AE%E5%B7%AE%E5%BC%82"><span class="toc-text">10. 其他细微差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E5%BD%B1%E5%93%8D"><span class="toc-text">三、浏览器指纹的挑战和影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%90%E7%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">1. 隐私问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">2. 安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%95%E8%A7%84%E5%92%8C%E4%BC%A6%E7%90%86%E4%BA%89%E8%AE%AE"><span class="toc-text">3. 法规和伦理争议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8A%97%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%EF%BC%9F"><span class="toc-text">四、如何对抗浏览器指纹？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E9%9A%90%E7%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">1. 使用隐私浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95-%E6%8F%92%E4%BB%B6"><span class="toc-text">2. 浏览器扩展&#x2F;插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE%E8%B0%83%E6%95%B4"><span class="toc-text">3. 通用设置调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF-SPOOFING"><span class="toc-text">4. 随机化指纹信息 (SPOOFING)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E6%B5%8F%E8%A7%88%E4%B9%A0%E6%83%AF"><span class="toc-text">5. 注意浏览习惯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%E7%9A%84%E7%A7%AF%E6%9E%81%E7%94%A8%E9%80%94-%E5%8F%8C%E5%88%83%E5%89%91"><span class="toc-text">五、浏览器指纹的积极用途 (双刃剑)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-08.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>