<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>浏览器指纹 (Browser Fingerprinting) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器指纹 (Browser Fingerprinting) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/902d004f5ccc/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg">
<meta property="article:published_time" content="2025-03-14T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-07T07:50:15.075Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "浏览器指纹 (Browser Fingerprinting) 详解",
  "url": "https://blog.tbf1211.xx.kg/902d004f5ccc/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg",
  "datePublished": "2025-03-14T22:24:00.000Z",
  "dateModified": "2026-01-07T07:50:15.075Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/902d004f5ccc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浏览器指纹 (Browser Fingerprinting) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">474</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">82</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">浏览器指纹 (Browser Fingerprinting) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">浏览器指纹 (Browser Fingerprinting) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-03-14T22:24:00.000Z" title="发表于 2025-03-15 06:24:00">2025-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。</p>
</blockquote>
<div class="note info flat"><p>“你的浏览器就像你的手纹一样，看似普通，却独一无二。”</p>
</div>
<hr>
<h2 id="一、什么是浏览器指纹？"><a href="#一、什么是浏览器指纹？" class="headerlink" title="一、什么是浏览器指纹？"></a>一、什么是浏览器指纹？</h2><p>浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。</p>
<p>这个“指纹”的强大之处在于其<strong>持久性</strong>和<strong>隐蔽性</strong>，用户很难通过常规手段进行清除或规避。</p>
<h2 id="二、浏览器指纹的工作原理"><a href="#二、浏览器指纹的工作原理" class="headerlink" title="二、浏览器指纹的工作原理"></a>二、浏览器指纹的工作原理</h2><p>网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括：</p>
<h3 id="1-HTTP-请求头信息-HTTP-Headers"><a href="#1-HTTP-请求头信息-HTTP-Headers" class="headerlink" title="1. HTTP 请求头信息 (HTTP Headers)"></a>1. HTTP 请求头信息 (HTTP Headers)</h3><p>这是最基础的指纹信息，每次 HTTP 请求都会携带：</p>
<ul>
<li><code>User-Agent</code>: 浏览器、操作系统和设备类型。</li>
<li><code>Accept-Language</code>: 浏览器接受的语言设置。</li>
<li><code>Accept-Encoding</code>: 浏览器接受的编码方式。</li>
</ul>
<h3 id="2-屏幕和显示器信息-Screen-Display"><a href="#2-屏幕和显示器信息-Screen-Display" class="headerlink" title="2. 屏幕和显示器信息 (Screen &amp; Display)"></a>2. 屏幕和显示器信息 (Screen &amp; Display)</h3><p>通过 <code>window.screen</code> 和 <code>window.innerWidth</code>&#x2F;<code>innerHeight</code> 等 API 获取：</p>
<ul>
<li>屏幕分辨率 (e.g., <code>1920x1080</code>)。</li>
<li>颜色深度 (e.g., <code>24-bit</code>)。</li>
<li>操作系统界面缩放比例 (DPI)。</li>
</ul>
<h3 id="3-插件和扩展信息-Plugins-Extensions"><a href="#3-插件和扩展信息-Plugins-Extensions" class="headerlink" title="3. 插件和扩展信息 (Plugins &amp; Extensions)"></a>3. 插件和扩展信息 (Plugins &amp; Extensions)</h3><p>过去常通过 <code>navigator.plugins</code> 和 <code>navigator.mimeTypes</code> 获取 Flash, Java 等插件信息。现在随着 Flash 等插件的淘汰，这个方法的重要性下降，但浏览器扩展依然可以被检测到。</p>
<h3 id="4-字体信息-Fonts"><a href="#4-字体信息-Fonts" class="headerlink" title="4. 字体信息 (Fonts)"></a>4. 字体信息 (Fonts)</h3><p>通过 JavaScript 检测系统上安装的字体列表。即使只是几款独特字体，也能显著增加指纹的独特性。</p>
<ul>
<li><strong>原理</strong>: 创建一个隐藏的 DOM 元素，设置待检测字体，然后测量该元素的宽度和高度。如果尺寸与默认字体不同，则说明该字体已安装。</li>
</ul>
<h3 id="5-Canvas-指纹-Canvas-Fingerprinting"><a href="#5-Canvas-指纹-Canvas-Fingerprinting" class="headerlink" title="5. Canvas 指纹 (Canvas Fingerprinting)"></a>5. Canvas 指纹 (Canvas Fingerprinting)</h3><p>这是目前最强大、最普遍的指纹技术之一。</p>
<ul>
<li><strong>原理</strong>: 浏览器使用 <code>Canvas</code> API 绘制（渲染）一段文本或图形。由于不同设备、操作系统、浏览器、GPU、字体渲染引擎甚至硬件驱动之间存在的微小差异，即使是完全相同的指令，渲染出的像素数据也会有微小的不同。</li>
<li><strong>过程</strong>:<ol>
<li>网站在 Canvas 上绘制一些文本（通常带一些渐变、阴影等效果）和图形。</li>
<li>将 Canvas 内容导出为图片数据（例如 <code>toDataURL()</code> 或 <code>getImageData()</code>）。</li>
<li>对图像数据进行哈希运算，生成一个唯一的字符串作为指纹。</li>
</ol>
</li>
<li><strong>独特性</strong>: 即使肉眼无法察觉的像素差异，也会导致哈希值不同。</li>
</ul>
<h3 id="6-AudioContext-指纹-AudioContext-Fingerprinting"><a href="#6-AudioContext-指纹-AudioContext-Fingerprinting" class="headerlink" title="6. AudioContext 指纹 (AudioContext Fingerprinting)"></a>6. AudioContext 指纹 (AudioContext Fingerprinting)</h3><p>与 Canvas 指纹类似，它利用 Web Audio API。</p>
<ul>
<li><strong>原理</strong>: 通过 JavaScript 创建一个 <code>AudioContext</code>，生成特定的音频波形，然后通过读取音频数据的特性（如音量、相位等）来生成哈希值。不同设备上的音频硬件、驱动、操作系统和软件库在处理音频时产生的微小差异，会导致相同音频指令的输出结果不一致。</li>
<li><strong>过程</strong>:<ol>
<li>使用 <code>AudioContext</code> 构造一个独特的音频信号图。</li>
<li>处理该信号（例如，进行压缩、混响等操作）。</li>
<li>将处理后的信号数据转换为哈希值。</li>
</ol>
</li>
<li><strong>独特性</strong>: 同样具有高度的唯一识别能力。</li>
</ul>
<h3 id="7-WebGL-指纹-WebGL-Fingerprinting"><a href="#7-WebGL-指纹-WebGL-Fingerprinting" class="headerlink" title="7. WebGL 指纹 (WebGL Fingerprinting)"></a>7. WebGL 指纹 (WebGL Fingerprinting)</h3><p>利用 WebGL API 访问 GPU 信息。</p>
<ul>
<li><strong>原理</strong>: 通过 WebGL 绘制 3D 图形，获取 GPU 的渲染细节和能力。不同显卡型号、驱动版本、操作系统对 WebGL 的实现差异会产生独特的渲染结果。</li>
<li><strong>过程</strong>: 获取 <code>renderer</code> 字符串、纹理单元数量、最大视口尺寸等，并结合渲染结果进行哈希。</li>
</ul>
<h3 id="8-WebRTC-和系统信息"><a href="#8-WebRTC-和系统信息" class="headerlink" title="8. WebRTC 和系统信息"></a>8. WebRTC 和系统信息</h3><ul>
<li><strong>本地 IP 地址</strong>: WebRTC 可以获取用户设备的本地 IP 地址，即使使用了 VPN。但这通常需要用户授权。</li>
<li><strong>操作系统和硬件</strong>: 通过 <code>navigator.platform</code>, <code>navigator.hardwareConcurrency</code> (CPU 核心数), <code>navigator.deviceMemory</code> (内存) 等获取。</li>
</ul>
<h3 id="9-时区和语言设置"><a href="#9-时区和语言设置" class="headerlink" title="9. 时区和语言设置"></a>9. 时区和语言设置</h3><p>通过 <code>Intl.DateTimeFormat().resolvedOptions().timeZone</code> 和 <code>navigator.language</code>&#x2F;<code>languages</code> 获取。</p>
<h3 id="10-其他细微差异"><a href="#10-其他细微差异" class="headerlink" title="10. 其他细微差异"></a>10. 其他细微差异</h3><ul>
<li><strong>电池状态 API</strong>: <code>navigator.getBattery()</code> (现在通常被限制使用)。</li>
<li><strong>摄像头&#x2F;麦克风设备 ID</strong>: 在某些情况下可能获取。</li>
<li><strong>浏览器对特定 CSS 属性、JS API 的实现差异或 BUG。</strong></li>
</ul>
<h2 id="三、浏览器指纹的挑战和影响"><a href="#三、浏览器指纹的挑战和影响" class="headerlink" title="三、浏览器指纹的挑战和影响"></a>三、浏览器指纹的挑战和影响</h2><h3 id="1-隐私问题"><a href="#1-隐私问题" class="headerlink" title="1. 隐私问题"></a>1. 隐私问题</h3><ul>
<li><strong>持久性追踪</strong>: 即使清除 cookies 或使用隐私模式，用户也可能被持续追踪，这破坏了用户的匿名性期望。</li>
<li><strong>数据聚合</strong>: 跨网站的数据聚合变得更加容易，用户在不同网站上的行为可能被关联起来，形成更完整的用户画像。</li>
<li><strong>个性化广告</strong>: 广告商可以更精准地投放广告，甚至基于用户的“隐形”数据进行定向。</li>
</ul>
<h3 id="2-安全问题"><a href="#2-安全问题" class="headerlink" title="2. 安全问题"></a>2. 安全问题</h3><ul>
<li><strong>身份伪造</strong>: 恶意攻击者如果能获取到你的浏览器指纹，可能尝试伪造你的设备身份，绕过一些简单的设备验证。</li>
<li><strong>账户接管</strong>: 与其他信息结合，可以增加账户被接管的风险。</li>
</ul>
<h3 id="3-法规和伦理争议"><a href="#3-法规和伦理争议" class="headerlink" title="3. 法规和伦理争议"></a>3. 法规和伦理争议</h3><ul>
<li>许多隐私法规（如 GDPR、CCPA）要求网站在收集用户数据前获得明确同意。浏览器指纹的隐蔽性使其难以符合这些规定。</li>
<li>关于这种“隐形追踪”是否符合伦理道德，一直存在争议。</li>
</ul>
<h2 id="四、如何对抗浏览器指纹？"><a href="#四、如何对抗浏览器指纹？" class="headerlink" title="四、如何对抗浏览器指纹？"></a>四、如何对抗浏览器指纹？</h2><p>对抗浏览器指纹是一个复杂且持续发展的猫鼠游戏，没有一劳永逸的解决方案，但以下方法可以增加识别难度：</p>
<h3 id="1-使用隐私浏览器"><a href="#1-使用隐私浏览器" class="headerlink" title="1. 使用隐私浏览器"></a>1. 使用隐私浏览器</h3><ul>
<li><strong>Tor 浏览器 (Tor Browser)</strong>: 被认为是目前对抗浏览器指纹最有效的工具之一。它通过标准化所有用户的指纹，使得所有 Tor 用户的浏览器看起来都一样，从而提高匿名性。</li>
<li><strong>Brave 浏览器</strong>: 内置了指纹保护功能，可以随机化或限制指纹信息的暴露。</li>
<li><strong>Firefox 的增强型跟踪保护</strong>: 提供“严格”模式，一定程度上减轻指纹追踪。</li>
</ul>
<h3 id="2-浏览器扩展-插件"><a href="#2-浏览器扩展-插件" class="headerlink" title="2. 浏览器扩展&#x2F;插件"></a>2. 浏览器扩展&#x2F;插件</h3><p>安装专门对抗指纹的扩展，例如：</p>
<ul>
<li><strong>CanvasBlocker</strong>: 阻止或欺骗 Canvas API。</li>
<li><strong>Trace</strong>: 尝试伪造或随机化多种指纹信息。</li>
<li><strong>Privacy Badger</strong>: 识别并阻止隐藏的追踪器。</li>
</ul>
<h3 id="3-通用设置调整"><a href="#3-通用设置调整" class="headerlink" title="3. 通用设置调整"></a>3. 通用设置调整</h3><ul>
<li><strong>禁用 JavaScript (慎重)</strong>: 禁用 JavaScript 会阻止绝大多数指纹收集，但也会导致绝大多数网站无法正常工作。</li>
<li><strong>频繁更换浏览器和设备</strong>: 实际操作性较差。</li>
<li><strong>使用虚拟机或沙箱环境</strong>: 每次启动都提供一个“全新”的浏览器环境，可以有效对抗指纹，但操作麻烦。</li>
</ul>
<h3 id="4-随机化指纹信息-SPOOFING"><a href="#4-随机化指纹信息-SPOOFING" class="headerlink" title="4. 随机化指纹信息 (SPOOFING)"></a>4. 随机化指纹信息 (SPOOFING)</h3><p>某些工具或浏览器，通过每次访问时随机化部分指纹信息（例如 User-Agent, Canvas 渲染结果的微小噪声），使得每次生成的指纹都略有不同，从而避免被关联。</p>
<h3 id="5-注意浏览习惯"><a href="#5-注意浏览习惯" class="headerlink" title="5. 注意浏览习惯"></a>5. 注意浏览习惯</h3><ul>
<li>尽量避免登录或使用不同身份访问同一网站。</li>
<li>定期审查和调整浏览器的隐私设置。</li>
</ul>
<h2 id="五、浏览器指纹的积极用途-双刃剑"><a href="#五、浏览器指纹的积极用途-双刃剑" class="headerlink" title="五、浏览器指纹的积极用途 (双刃剑)"></a>五、浏览器指纹的积极用途 (双刃剑)</h2><p>尽管主要被用于追踪和广告，浏览器指纹在某些情况下也有积极作用：</p>
<ol>
<li><strong>欺诈检测和预防</strong>: 银行、电商网站等可以使用指纹来检测可疑登录和欺诈交易，例如，如果用户突然从一个过去从未见过的指纹设备（即使 IP 地址在正常范围内）登录，可能会触发额外的安全验证。</li>
<li><strong>账户安全</strong>: 作为辅助验证手段，帮助识别用户设备，增强账户安全性。</li>
<li><strong>防止机器人和爬虫</strong>: 识别非人类访问，保护网站资源。</li>
<li><strong>提供更好的用户体验</strong>: 识别设备特性，为用户提供更匹配其设备性能的网页版本。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>浏览器指纹是数字时代隐私与便利之争的一个缩影。它揭示了我们在线行为的透明性远超我们想象。作为用户，了解其工作原理有助于我们更好地采取措施保护自己的隐私。作为开发者，我们需要在利用这些技术提供更好服务的同时，认真考虑其中的隐私风险和伦理界限，并遵守相关的政策法规。隐私保护是一个持续的挑战，需要技术、法律和用户意识的共同努力。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/902d004f5ccc/">https://blog.tbf1211.xx.kg/902d004f5ccc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/e4825d97fe27/" title="Netlify介绍"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Netlify介绍</div></div><div class="info-2"><div class="info-item-1"> Netlify 是一个领先的自动化平台，用于部署和托管现代 Web 项目。它将持续集成&#x2F;持续部署 (CI&#x2F;CD)、全球内容分发网络 (CDN)、Serverless Functions 和边缘计算等功能整合到一个统一的工作流中。Netlify 广受欢迎，尤其是在 Jamstack 生态系统中，它简化了 Web 应用程序的构建、部署和扩展过程，让开发者能够专注于代码，而无需管理复杂的服务器基础设施。  核心思想：Netlify 提供了一个一站式的“前端云”平台，它将 Git 仓库连接、自动化构建、全球 CDN 部署、Serverless 后端和附加服务无缝集成，旨在为开发者提供最快速、最简便的现代化 Web 应用部署体验。   一、为什么选择 Netlify？传统的 Web 部署通常涉及配置服务器、管理 CDN、设置 CI&#x2F;CD 管道等复杂任务。Netlify 应运而生，解决了这些痛点，提供了一套高效的解决方案：  极简部署：只需连接 Git 仓库，每次代码提交都会自动构建和部署。 Jamstack 优化：完美支持静态站点生成器 (SSG) 和单页应...</div></div></div></a><a class="pagination-related" href="/039eceb7c0db/" title="Golang Dig 深度解析：强大的依赖注入容器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang Dig 深度解析：强大的依赖注入容器</div></div><div class="info-2"><div class="info-item-1"> Dig 是 Google 开源的一个用于 Go 语言的依赖注入 (Dependency Injection, DI) 容器。它旨在帮助 Go 开发者管理复杂的应用程序对象图，通过自动化的方式解决组件之间的依赖关系，从而提高代码的可测试性、可维护性和模块化程度。  核心思想：Dig 通过 Go 语言的反射机制，在运行时分析函数的参数和返回值类型，自动构建并解析应用程序的依赖图。它将对象创建的逻辑（”提供者”）和对象使用的逻辑（”调用者”）分离，使得开发者无需手动管理复杂的对象实例化过程。   一、为什么需要依赖注入和 Dig？在构建复杂的 Go 应用程序时，组件之间往往存在错综复杂的依赖关系。手动管理这些依赖通常会导致以下问题：  代码耦合度高：当一个结构体直接实例化其依赖的结构体时，两者紧密耦合。 难以测试：紧密耦合使得单元测试难以进行，因为无法轻松替换依赖项（如用 Mock 对象替代真实的数据库连接）。 实例化逻辑分散：对象的创建逻辑可能散布在应用程序的各个部分，难以统一管理和追踪。 难以重构：修改一个组件的依赖可能需要修改所有使用它的地方。  依赖注入 (DI) 是一种软件...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/f1d2005549f2/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-28</div><div class="info-item-2">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</div></div><div class="info-2"><div class="info-item-1"> 在过去十年中，前端开发领域由 JavaScript 框架（如 React, Vue, Angular）占据主导地位，它们将整个用户界面放在客户端，通过 API 与后端交互。然而，这种“单页应用 (SPA)”模式并非总是最佳选择，它带来了复杂的构建流程、初始加载性能问题、SEO 挑战以及较高的开发和维护成本。 HTMX 的出现，挑战了这一主流范式。它主张将交互逻辑回归到服务器端，通过简单的 HTML 属性就能实现 AJAX 请求、CSS 过渡、WebSocket 和服务器发送事件 (SSE)，在不编写一行 JavaScript 代码的情况下，实现丰富的动态用户体验。  本文将深入探讨 HTMX 的核心理念、工作原理、主要特性、优缺点以及适用场景，帮助你理解这个“返璞归真”但又极具创新力的工具。   一、 HTMX 是什么？核心理念与哲学HTMX 是一个小型 (约 15KB gzipped) 的 JavaScript 库，它通过扩展 HTML 原生能力，允许你在 HTML 元素上直接指定 AJAX 请求、CSS 动画、WebSocket 和服务器发送事件 (SSE) 行为。 其核心...</div></div></div></a><a class="pagination-related" href="/29965d782f2a/" title="Metasploit 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-18</div><div class="info-item-2">Metasploit 框架详解</div></div><div class="info-2"><div class="info-item-1"> Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1 什么是 Metasploit？Metasploit 是由 Rapid7 公司维护的一个著名的开源项目。它是一个漏洞利用框架，旨在协助渗透测试人员识别、利用和验证漏洞。它不仅仅是一个简单的漏洞扫描器，更是一个提供多种工具和方法的集成环境，几乎覆盖了渗透测试的整个生命周期。 1.2 Metasploit 的发展历史 2003年：由 H.D. Moore 发起，最初是一个 Perl 语言的项目。 2004年：发布 2.0 版本，首次引入了模块化架构。 2007年：框架被重写，使用 Ruby 语言，提高了灵活性和可维护性。 209年：Rapid7 收购 Metasploit 项目，并继续其开发...</div></div></div></a><a class="pagination-related" href="/08a7bab723f9/" title="Metasploit exploit&#x2F;multi&#x2F;handler 模块详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">Metasploit exploit&#x2F;multi&#x2F;handler 模块详解</div></div><div class="info-2"><div class="info-item-1"> exploit/multi/handler 是 Metasploit 框架中一个极其重要且应用广泛的模块。它本身并不是一个漏洞利用模块，而是一个通用的监听器（Listener），用于接收由 Metasploit 或 msfvenom 生成的各种 Payload 发起的反向连接（Reverse Shell）。它提供了一个灵活且强大的平台，用于管理渗透测试过程中获取的 Shell 会话，特别是 Meterpreter 会话。  核心思想：提供一个通用的、模块化的监听接口，等待远程目标系统主动连接，从而建立一个控制通道。它与用于生成Payload的msfvenom紧密配合，实现无缝的端到端攻击链。   一、exploit/multi/handler 简介1.1 什么是 exploit/multi/handler？exploit/multi/handler 是 Metasploit 中的一个混合型模块 (Auxiliary&#x2F;Exploit)。它被归类为 exploit，因为它最终目的是“利用”系统并获得 Shell，但它实际上不包含任何漏洞利用代码。它的主要功能是：  监听反...</div></div></div></a><a class="pagination-related" href="/1c9fa79b93e5/" title="Msfvenom 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="info-item-2">Msfvenom 详解</div></div><div class="info-2"><div class="info-item-1"> Msfvenom 是 Metasploit 框架中的一个强大而独立的命令行工具，它结合了 msfpayload（载荷生成器）和 msfencode（编码器）的功能，旨在生成各种格式的恶意载荷（Payload）并对其进行编码，以规避安全检测。它是渗透测试人员和红队成员创建自定义后门和绕过防御机制的利器。  核心思想：将攻击载荷（Shellcode）和输出格式（如 EXE、ELF、ASPX 等）分离，允许用户自由组合并按需编码，生成高度定制化的恶意文件。   一、Msfvenom 简介1.1 什么是 Msfvenom？msfvenom 是一个命令行工具，属于 Metasploit Framework 的一部分。它的主要功能是：  载荷生成 (Payload Generation)：创建各种操作系统（Windows, Linux, macOS, Android 等）和架构（x86, x64 等）的恶意载荷。 编码 (Encoding)：对生成的载荷进行编码，以尝试绕过杀毒软件的签名检测或处理特殊字符（如 NUL \x00）。 格式化 (Formatting)：将生成的载荷输出为多种文...</div></div></div></a><a class="pagination-related" href="/e208a03b114e/" title="JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)</div></div><div class="info-2"><div class="info-item-1"> JavaScript，正式名称为 ECMAScript (ES)，自 1997 年标准化以来，一直在不断发展。尤其是从 ES6 (ES2015) 开始，它进入了一个快速迭代的时代，每年都会发布一个新版本，引入大量的新特性、语法糖和标准库改进。理解这些新特性对于现代 JavaScript 开发者至关重要，它能帮助我们编写更简洁、更强大、更符合未来趋势的代码。  核心思想： ECMAScript 的版本迭代致力于提升开发效率、代码可读性、执行性能，并引入现代编程范式（如异步编程、模块化），同时保持向后兼容性。   一、早期版本：奠定基础 (ES1 - ES5)早期版本的 ECMAScript 奠定了 JavaScript 的基本语法和核心功能，但发展速度相对较慢。 1.1 ES1 (1997) - ES3 (1999) 基本语法：变量声明 (var)、函数、条件语句、循环、基本数据类型（字符串、数字、布尔、null、undefined）。 对象和数组：字面量创建、属性访问。 原型继承：基于原型的继承机制。 函数作用域：变量作用域规则。 try...catch：错误处理。 eval(...</div></div></div></a><a class="pagination-related" href="/fc0a62ae56f9/" title="OAuth2.0详解：现代授权框架的核心原理与应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-09</div><div class="info-item-2">OAuth2.0详解：现代授权框架的核心原理与应用</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0（Open Authorization）是一个开放标准，定义了一套授权流程，允许用户（资源所有者）授权第三方应用访问他们在另一个服务提供者（授权服务器）上的受保护资源（资源服务器），而无需将自己的用户名和密码直接提供给第三方应用。它主要解决的是委托授权的问题，即“我授权应用A去访问我在服务B上的某些数据”。  核心区分：OAuth 2.0 是一个授权（Authorization）框架，而不是用来做认证（Authentication）。尽管它常常与认证机制（如 OpenID Connect）结合使用，但其核心职责是授予对资源的访问权限，而非验证用户身份。   一、OAuth 2.0 产生的背景与解决的问题在 OAuth 出现之前，如果一个第三方应用需要访问用户在其他服务（如 Google 相册、GitHub 代码库）上的数据，用户通常需要将自己的账号密码直接告知第三方应用。这种做法带来了严重的安全和便捷性问题：  凭据泄露风险：第三方应用一旦被攻破，或恶意使用，用户的完整凭据就会泄露，导致所有关联服务面临风险。 权限过大：第三方应用获得的是用户的完全控制权，无法...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">474</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">82</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%EF%BC%9F"><span class="toc-text">一、什么是浏览器指纹？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、浏览器指纹的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HTTP-%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF-HTTP-Headers"><span class="toc-text">1. HTTP 请求头信息 (HTTP Headers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B1%8F%E5%B9%95%E5%92%8C%E6%98%BE%E7%A4%BA%E5%99%A8%E4%BF%A1%E6%81%AF-Screen-Display"><span class="toc-text">2. 屏幕和显示器信息 (Screen &amp; Display)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E4%BB%B6%E5%92%8C%E6%89%A9%E5%B1%95%E4%BF%A1%E6%81%AF-Plugins-Extensions"><span class="toc-text">3. 插件和扩展信息 (Plugins &amp; Extensions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E4%BD%93%E4%BF%A1%E6%81%AF-Fonts"><span class="toc-text">4. 字体信息 (Fonts)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Canvas-%E6%8C%87%E7%BA%B9-Canvas-Fingerprinting"><span class="toc-text">5. Canvas 指纹 (Canvas Fingerprinting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-AudioContext-%E6%8C%87%E7%BA%B9-AudioContext-Fingerprinting"><span class="toc-text">6. AudioContext 指纹 (AudioContext Fingerprinting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-WebGL-%E6%8C%87%E7%BA%B9-WebGL-Fingerprinting"><span class="toc-text">7. WebGL 指纹 (WebGL Fingerprinting)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-WebRTC-%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-text">8. WebRTC 和系统信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%97%B6%E5%8C%BA%E5%92%8C%E8%AF%AD%E8%A8%80%E8%AE%BE%E7%BD%AE"><span class="toc-text">9. 时区和语言设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%85%B6%E4%BB%96%E7%BB%86%E5%BE%AE%E5%B7%AE%E5%BC%82"><span class="toc-text">10. 其他细微差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E5%BD%B1%E5%93%8D"><span class="toc-text">三、浏览器指纹的挑战和影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%90%E7%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">1. 隐私问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">2. 安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%95%E8%A7%84%E5%92%8C%E4%BC%A6%E7%90%86%E4%BA%89%E8%AE%AE"><span class="toc-text">3. 法规和伦理争议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8A%97%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%EF%BC%9F"><span class="toc-text">四、如何对抗浏览器指纹？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E9%9A%90%E7%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-text">1. 使用隐私浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95-%E6%8F%92%E4%BB%B6"><span class="toc-text">2. 浏览器扩展&#x2F;插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE%E8%B0%83%E6%95%B4"><span class="toc-text">3. 通用设置调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF-SPOOFING"><span class="toc-text">4. 随机化指纹信息 (SPOOFING)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E6%B5%8F%E8%A7%88%E4%B9%A0%E6%83%AF"><span class="toc-text">5. 注意浏览习惯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%E7%9A%84%E7%A7%AF%E6%9E%81%E7%94%A8%E9%80%94-%E5%8F%8C%E5%88%83%E5%89%91"><span class="toc-text">五、浏览器指纹的积极用途 (双刃剑)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>