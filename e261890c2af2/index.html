<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSL/TLS 终止详解 (SSL/TLS Termination Explained) | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SSL&#x2F;TLS 终止 (SSL&#x2F;TLS Termination) 是指在客户端和后端服务器之间，由一个中间设备（如负载均衡器、反向代理、API 网关等）负责解密传入的 SSL&#x2F;TLS 加密流量，并在将请求转发到后端服务器之前对其进行处理的过程。同样地，该设备也负责对来自后端服务器的响应进行加密，然后发送给客户端。这个中间设备即充当了 SSL&#x2F;TLS 连接的">
<meta property="og:type" content="article">
<meta property="og:title" content="SSL&#x2F;TLS 终止详解 (SSL&#x2F;TLS Termination Explained)">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/e261890c2af2/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="SSL&#x2F;TLS 终止 (SSL&#x2F;TLS Termination) 是指在客户端和后端服务器之间，由一个中间设备（如负载均衡器、反向代理、API 网关等）负责解密传入的 SSL&#x2F;TLS 加密流量，并在将请求转发到后端服务器之前对其进行处理的过程。同样地，该设备也负责对来自后端服务器的响应进行加密，然后发送给客户端。这个中间设备即充当了 SSL&#x2F;TLS 连接的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg">
<meta property="article:published_time" content="2025-11-30T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-21T09:51:21.404Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="TLS">
<meta property="article:tag" content="HTTPS">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSL/TLS 终止详解 (SSL/TLS Termination Explained)",
  "url": "https://blog.tbf1211.xx.kg/e261890c2af2/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg",
  "datePublished": "2025-11-30T22:24:00.000Z",
  "dateModified": "2026-01-21T09:51:21.404Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/e261890c2af2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSL/TLS 终止详解 (SSL/TLS Termination Explained)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">512</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-13.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">SSL/TLS 终止详解 (SSL/TLS Termination Explained)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SSL/TLS 终止详解 (SSL/TLS Termination Explained)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-11-30T22:24:00.000Z" title="发表于 2025-12-01 06:24:00">2025-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>SSL&#x2F;TLS 终止 (SSL&#x2F;TLS Termination)</strong> 是指在客户端和后端服务器之间，由一个中间设备（如负载均衡器、反向代理、API 网关等）负责解密传入的 SSL&#x2F;TLS 加密流量，并在将请求转发到后端服务器之前对其进行处理的过程。同样地，该设备也负责对来自后端服务器的响应进行加密，然后发送给客户端。这个中间设备即充当了 SSL&#x2F;TLS 连接的“终点”。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将繁重的 SSL&#x2F;TLS 加密&#x2F;解密计算从后端应用服务器上卸载到专门的设备，以此提高后端服务器的性能、简化证书管理，并实现流量的可见性和控制。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-SSL-TLS-终止？"><a href="#一、为什么需要-SSL-TLS-终止？" class="headerlink" title="一、为什么需要 SSL&#x2F;TLS 终止？"></a>一、为什么需要 SSL&#x2F;TLS 终止？</h2><p>在现代网络架构中，尤其是面对高并发和微服务环境时，SSL&#x2F;TLS 终止变得尤为重要。它解决了直接在应用服务器上处理 SSL&#x2F;&#x2F;TLS 的诸多挑战：</p>
<ol>
<li><p><strong>性能优化 (Performance Offloading)</strong>：SSL&#x2F;TLS 加密和解密是一个计算密集型操作，涉及复杂的握手过程和密钥交换。将此任务从后端应用服务器卸载到专门的硬件或软件设备上，可以显著降低后端服务器的 CPU 负载，使其能将更多资源投入到处理核心业务逻辑上。</p>
</li>
<li><p><strong>简化证书管理 (Centralized Certificate Management)</strong>：通过在单一入口点（如负载均衡器）管理所有 SSL&#x2F;TLS 证书，可以大大简化证书的安装、更新和续订过程。应用服务器无需各自维护证书，减少了运维复杂性和出错概率。</p>
</li>
<li><p><strong>内部流量解密与检查 (Internal Traffic Visibility and Inspection)</strong>：一旦流量在终止点被解密，中间设备可以对请求进行深度检查和修改。这使得WAF (Web Application Firewall) 可以检测并抵御攻击，或者可以进行内容路由、数据压缩、缓存等操作，而无需后端服务器再次进行解密。</p>
</li>
<li><p><strong>提高安全性 (Enhanced Security)</strong>：</p>
<ul>
<li><strong>职责分离</strong>：将加密边界（面向互联网）与内部网络分离，确保只有经过验证和清理的流量才能进入内部。</li>
<li><strong>内部网络灵活加密</strong>：解密后的流量在内部网络中可以选择继续加密（端到端加密），也可以选择不加密（内部网络通常被认为是受信任的）。</li>
</ul>
</li>
<li><p><strong>支持旧版服务 (Support for Legacy Services)</strong>：某些旧版后端服务可能不支持 HTTPS，或者配置 HTTPS 过于复杂。通过 SSL&#x2F;TLS 终止，这些服务可以继续通过 HTTP 协议暴露在内部，而对外仍提供安全的 HTTPS 访问。</p>
</li>
</ol>
<h2 id="二、SSL-TLS-终止在哪里发生？"><a href="#二、SSL-TLS-终止在哪里发生？" class="headerlink" title="二、SSL&#x2F;TLS 终止在哪里发生？"></a>二、SSL&#x2F;TLS 终止在哪里发生？</h2><p>SSL&#x2F;TLS 终止通常发生在网络架构中面向客户端的边缘设备上，这些设备承担了代理和流量分发的功能：</p>
<ul>
<li><strong>负载均衡器 (Load Balancers)</strong>：是最常见的 SSL&#x2F;TLS 终止点。它们接收加密请求，解密后根据负载均衡算法将请求分发给后端服务器，后端服务器返回 HTTP 响应给负载均衡器，负载均衡器再加密后发送给客户端。</li>
<li><strong>反向代理服务器 (Reverse Proxies)</strong>：例如 Nginx、Apache (mod_ssl)、HAProxy 等。它们接收来自互联网的加密请求，解密后转发给内部服务器。这种方式常用于优化性能、增强安全性或集成 WAF。</li>
<li><strong>API 网关 (API Gateways)</strong>：在微服务架构中，API 网关作为所有 API 请求的单一入口，非常适合进行 SSL&#x2F;TLS 终止。它不仅处理加密&#x2F;解密，还可以进行认证、授权、限流、日志记录等。</li>
<li><strong>内容分发网络 (CDN) 边缘节点 (CDN Edge Nodes)</strong>：CDN 提供商通常会在其全球分布的边缘节点上进行 SSL&#x2F;TLS 终止，以尽可能靠近用户，减少延迟，并加速内容交付。</li>
</ul>
<h2 id="三、SSL-TLS-终止的工作流程"><a href="#三、SSL-TLS-终止的工作流程" class="headerlink" title="三、SSL&#x2F;TLS 终止的工作流程"></a>三、SSL&#x2F;TLS 终止的工作流程</h2><p>SSL&#x2F;TLS 终止的基本流程涉及到客户端、终止设备和后端服务器三方的交互。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as 客户端 (浏览器)
    participant Terminator as SSL&#x2F;TLS 终止设备 (负载均衡器&#x2F;反向代理)
    participant Backend as 后端应用服务器

    Client-&gt;&gt;Terminator: 1. 客户端发起 HTTPS 连接 (TCP 连接)
    Terminator--&gt;&gt;Client: 2. SSL&#x2F;TLS 握手开始 (发送证书, 协商加密套件)
    Client-&gt;&gt;Terminator: 3. 握手完成，客户端发送加密的 HTTP 请求
    Terminator-&gt;&gt;Terminator: 4. **解密** HTTP 请求
    Terminator-&gt;&gt;Backend: 5. 将解密后的 HTTP 请求转发给后端 (通常是 HTTP 协议)
    Backend-&gt;&gt;Terminator: 6. 处理请求并返回 HTTP 响应
    Terminator-&gt;&gt;Terminator: 7. **加密** HTTP 响应
    Terminator--&gt;&gt;Client: 8. 将加密后的 HTTPS 响应发送给客户端
    Client-&gt;&gt;Client: 9. 客户端解密并显示内容
  </pre></div>

<p><strong>详细步骤解析：</strong></p>
<ol>
<li><strong>客户端发起 HTTPS 连接</strong>：客户端（例如Web浏览器）尝试通过 HTTPS 连接到服务器。它会向 SSL&#x2F;TLS 终止设备发送一个 <code>ClientHello</code> 消息，启动 TLS 握手过程。</li>
<li><strong>SSL&#x2F;TLS 握手</strong>：<ul>
<li>终止设备响应 <code>ServerHello</code>，发送其自身的 SSL&#x2F;TLS 证书（包含公钥）和选定的加密套件。</li>
<li>客户端验证证书的有效性（信任链、有效期等）。</li>
<li>客户端生成一个预主密钥，使用终止设备的公钥对其加密，并发送给终止设备。</li>
<li>终止设备使用其私钥解密预主密钥，然后客户端和终止设备使用相同的算法生成会话密钥。</li>
<li>握手完成，后续通信将使用会话密钥进行加密。</li>
</ul>
</li>
<li><strong>加密 HTTP 请求</strong>：客户端使用会话密钥加密其 HTTP 请求，并通过已建立的 SSL&#x2F;TLS 安全通道发送给终止设备。</li>
<li><strong>解密 HTTP 请求</strong>：SSL&#x2F;TLS 终止设备使用之前协商的会话密钥解密客户端发送的加密 HTTP 请求。</li>
<li><strong>转发解密后的请求</strong>：解密后的 HTTP 请求（现在是明文）根据配置被转发到后端应用服务器。这通常是通过内部、非加密的 HTTP 连接完成，因为内部网络通常被认为是受信任的环境。</li>
<li><strong>后端处理与响应</strong>：后端服务器处理 HTTP 请求并生成 HTTP 响应。</li>
<li><strong>加密 HTTP 响应</strong>：终止设备接收到后端服务器的明文 HTTP 响应。它使用之前与客户端协商的会话密钥对该响应进行加密。</li>
<li><strong>发送加密响应</strong>：加密后的 HTTPS 响应通过 SSL&#x2F;TLS 安全通道发送回客户端。</li>
<li><strong>客户端解密</strong>：客户端使用其会话密钥解密响应，并处理收到的数据。</li>
</ol>
<h2 id="四、SSL-TLS-终止的两种模式"><a href="#四、SSL-TLS-终止的两种模式" class="headerlink" title="四、SSL&#x2F;TLS 终止的两种模式"></a>四、SSL&#x2F;TLS 终止的两种模式</h2><p>在讨论 SSL&#x2F;TLS 终止时，常常会涉及到终止流量后在内部网络中的处理方式：</p>
<ol>
<li><p><strong>SSL&#x2F;TLS 终止 (SSL&#x2F;TLS Termination)</strong>：</p>
<ul>
<li>客户端到终止设备：HTTPS (加密)</li>
<li>终止设备到后端服务器：HTTP (明文)</li>
<li><strong>优点</strong>：后端服务器零负担，无需处理 SSL&#x2F;TLS。</li>
<li><strong>缺点</strong>：内部网络流量为明文，如果内部网络不完全受信任，存在被窃听的风险。</li>
</ul>
</li>
<li><p><strong>SSL&#x2F;TLS 直通 (SSL&#x2F;TLS Passthrough)</strong>：</p>
<ul>
<li>客户端到终止设备：HTTPS (加密)</li>
<li>终止设备到后端服务器：HTTPS (加密)</li>
<li><strong>特点</strong>：终止设备不解密流量，只进行七层调度，将加密连接直接传递给后端服务器。</li>
<li><strong>优点</strong>：实现端到端的加密，整个路径都是安全的。</li>
<li><strong>缺点</strong>：后端服务器需要承担 SSL&#x2F;TLS 加密&#x2F;解密负担，无法进行基于内容的深度检查。</li>
<li><strong>适用场景</strong>：对数据隐私性要求极高的场景，或者当后端需要对自身证书进行严格控制时。</li>
</ul>
</li>
</ol>
<p>虽然 SSL&#x2F;TLS Passthrough 也可以视为一种“不终止”的行为，但在一些负载均衡器（如 L4 负载均衡器）配置中，它确实是一种操作模式选择。</p>
<h2 id="五、安全性考虑"><a href="#五、安全性考虑" class="headerlink" title="五、安全性考虑"></a>五、安全性考虑</h2><p>尽管 SSL&#x2F;TLS 终止带来了诸多好处，但在实施时也需要考虑其安全性影响：</p>
<ol>
<li><strong>终止设备的安全性</strong>：SSL&#x2F;TLS 终止设备成为安全关键点。它的安全漏洞或配置错误会导致整个系统的加密失效。因此，需要严格保护该设备，确保其配置正确、软件定期更新，并使用强密码和访问控制。</li>
<li><strong>内部网络的安全</strong>：如果终止设备到后端服务器的流量是明文 HTTP，那么内部网络必须是高度受信任和隔离的。任何内部网络中的窃听者都可以获取敏感信息。对于高安全要求的应用，建议在内部网络中也启用加密 (尽管通常不是通过 SSL&#x2F;TLS 终止设备，而是由后端服务器自身处理)。</li>
<li><strong>日志与审计</strong>：在终止设备上解密流量使得可以进行更详细的日志记录和审计，这对于安全事件分析至关重要。但也需要确保日志本身被妥善保护。</li>
<li><strong>证书管理</strong>：即使是中心化管理，证书的私钥也必须得到最严格的保护，防止泄露。</li>
</ol>
<h2 id="六、代码示例-Python"><a href="#六、代码示例-Python" class="headerlink" title="六、代码示例 (Python)"></a>六、代码示例 (Python)</h2><p>以下是一个简化的 Python 示例，模拟了客户端和服务器之间的 HTTPS 连接，以及一个伪 SSL&#x2F;TLS 终止器的概念。<br>这个例子并不能进行真实的 SSL&#x2F;TLS 终止，但可以帮助理解加密通信及中间处理的思路。<br>（注意：真实的 SSL&#x2F;TLS 终止涉及复杂的网络编程和TLS协议实现，超出了简单代码示例的范畴。此示例仅为概念性演示。）</p>
<p>首先，我们需要生成自签名证书和私钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 CA 私钥</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"><span class="comment"># 生成 CA 证书</span></span><br><span class="line">openssl req -new -x509 -key ca.key -out ca.crt -days 365</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服务器私钥</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"><span class="comment"># 生成服务器证书签名请求</span></span><br><span class="line">openssl req -new -key server.key -out server.csr -subj <span class="string">&quot;/CN=localhost&quot;</span></span><br><span class="line"><span class="comment"># 使用 CA 签名服务器证书</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 365</span><br></pre></td></tr></table></figure>

<p><strong>模拟后端 HTTP 服务器 (<code>backend_server.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.server</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHandler</span>(http.server.SimpleHTTPRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.send_response(<span class="number">200</span>)</span><br><span class="line">        <span class="variable language_">self</span>.send_header(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.end_headers()</span><br><span class="line">        response_data = &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello from backend!&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="variable language_">self</span>.path&#125;</span><br><span class="line">        <span class="variable language_">self</span>.wfile.write(json.dumps(response_data).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_POST</span>(<span class="params">self</span>):</span><br><span class="line">        content_length = <span class="built_in">int</span>(<span class="variable language_">self</span>.headers[<span class="string">&#x27;Content-Length&#x27;</span>])</span><br><span class="line">        post_data = <span class="variable language_">self</span>.rfile.read(content_length).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">      </span><br><span class="line">        <span class="variable language_">self</span>.send_response(<span class="number">200</span>)</span><br><span class="line">        <span class="variable language_">self</span>.send_header(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.end_headers()</span><br><span class="line">        response_data = &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Received POST data&quot;</span>, <span class="string">&quot;data&quot;</span>: json.loads(post_data)&#125;</span><br><span class="line">        <span class="variable language_">self</span>.wfile.write(json.dumps(response_data).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socketserver.TCPServer((<span class="string">&quot;&quot;</span>, PORT), MyHandler) <span class="keyword">as</span> httpd:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Serving backend HTTP server at port <span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    httpd.serve_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>模拟 SSL&#x2F;TLS 终止设备 (<code>terminator.py</code>)</strong></p>
<p>这个模拟器将监听 HTTPS 请求，解密它，然后用 HTTP 转发给后端，再将后端响应加密返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.server</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSL/TLS 终止设备监听的 HTTPS 端口</span></span><br><span class="line">TERMINATOR_PORT = <span class="number">8443</span></span><br><span class="line"><span class="comment"># 后端 HTTP 服务器地址</span></span><br><span class="line">BACKEND_SERVER_URL = <span class="string">&quot;http://localhost:8000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 证书路径</span></span><br><span class="line">CERTFILE = <span class="string">&quot;server.crt&quot;</span></span><br><span class="line">KEYFILE = <span class="string">&quot;server.key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminatorHandler</span>(http.server.SimpleHTTPRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_proxy_request</span>(<span class="params">self, method</span>):</span><br><span class="line">        <span class="comment"># 构建后端 URL</span></span><br><span class="line">        parsed_url = urlparse(<span class="variable language_">self</span>.path)</span><br><span class="line">        backend_path = parsed_url.path</span><br><span class="line">        <span class="keyword">if</span> parsed_url.query:</span><br><span class="line">            backend_path += <span class="string">&#x27;?&#x27;</span> + parsed_url.query</span><br><span class="line">      </span><br><span class="line">        backend_full_url = <span class="string">f&quot;<span class="subst">&#123;BACKEND_SERVER_URL&#125;</span><span class="subst">&#123;backend_path&#125;</span>&quot;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 提取请求头，去除不必要的头</span></span><br><span class="line">        headers = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="variable language_">self</span>.headers.items() <span class="keyword">if</span> k.lower() <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;host&#x27;</span>, <span class="string">&#x27;connection&#x27;</span>, <span class="string">&#x27;keep-alive&#x27;</span>, <span class="string">&#x27;accept-encoding&#x27;</span>, <span class="string">&#x27;content-length&#x27;</span>]&#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">                backend_response = requests.get(backend_full_url, headers=headers, verify=<span class="literal">False</span>) <span class="comment"># 内部通信简化 verify=False</span></span><br><span class="line">            <span class="keyword">elif</span> method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">                content_length = <span class="built_in">int</span>(<span class="variable language_">self</span>.headers.get(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">                post_data = <span class="variable language_">self</span>.rfile.read(content_length)</span><br><span class="line">                backend_response = requests.post(backend_full_url, data=post_data, headers=headers, verify=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.send_error(<span class="number">501</span>, <span class="string">&quot;Not Implemented&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将后端响应转发回客户端</span></span><br><span class="line">            <span class="variable language_">self</span>.send_response(backend_response.status_code)</span><br><span class="line">            <span class="keyword">for</span> header_name, header_value <span class="keyword">in</span> backend_response.headers.items():</span><br><span class="line">                 <span class="comment"># 过滤掉一些可能引起问题的响应头</span></span><br><span class="line">                <span class="keyword">if</span> header_name.lower() <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;transfer-encoding&#x27;</span>, <span class="string">&#x27;content-encoding&#x27;</span>, <span class="string">&#x27;content-length&#x27;</span>]:</span><br><span class="line">                    <span class="variable language_">self</span>.send_header(header_name, header_value)</span><br><span class="line">            <span class="variable language_">self</span>.end_headers()</span><br><span class="line">            <span class="variable language_">self</span>.wfile.write(backend_response.content)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="variable language_">self</span>.send_error(<span class="number">500</span>, <span class="string">f&quot;Backend error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Backend communication error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_GET</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Terminator received encrypted GET for <span class="subst">&#123;self.path&#125;</span>. Decrypting and forwarding to backend...&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._proxy_request(<span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_POST</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Terminator received encrypted POST for <span class="subst">&#123;self.path&#125;</span>. Decrypting and forwarding to backend...&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._proxy_request(<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadingHTTPServer</span>(socketserver.ThreadingMixIn, http.server.HTTPServer):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">with</span> ThreadingHTTPServer((<span class="string">&quot;&quot;</span>, TERMINATOR_PORT), TerminatorHandler) <span class="keyword">as</span> httpd:</span><br><span class="line">        httpd.socket = ssl.wrap_socket(</span><br><span class="line">            httpd.socket,</span><br><span class="line">            keyfile=KEYFILE,</span><br><span class="line">            certfile=CERTFILE,</span><br><span class="line">            server_side=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Serving SSL/TLS Terminator on port <span class="subst">&#123;TERMINATOR_PORT&#125;</span> with cert <span class="subst">&#123;CERTFILE&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Forwarding requests to backend at <span class="subst">&#123;BACKEND_SERVER_URL&#125;</span>&quot;</span>)</span><br><span class="line">        httpd.serve_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>模拟客户端 (<code>client.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"><span class="keyword">import</span> certifi <span class="comment"># 用于获取标准CA证书路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSL/TLS 终止设备的地址</span></span><br><span class="line">TERMINATOR_HOST = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">TERMINATOR_PORT = <span class="number">8443</span></span><br><span class="line"><span class="comment"># 根证书文件 (用来验证 Terminator 的证书)</span></span><br><span class="line">CA_CERT_FILE = <span class="string">&quot;ca.crt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_https_request</span>(<span class="params">path=<span class="string">&quot;/&quot;</span>, method=<span class="string">&quot;GET&quot;</span>, data=<span class="literal">None</span></span>):</span><br><span class="line">    url = <span class="string">f&quot;https://<span class="subst">&#123;TERMINATOR_HOST&#125;</span>:<span class="subst">&#123;TERMINATOR_PORT&#125;</span><span class="subst">&#123;path&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nClient making <span class="subst">&#123;method&#125;</span> request to: <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># requests 库默认会验证服务器证书。</span></span><br><span class="line">        <span class="comment"># 这里需要告诉它使用我们签发的 CA 证书来验证 Terminator 的证书。</span></span><br><span class="line">        <span class="comment"># 如果是生产环境，通常不需要指定 verify，requests 会使用系统CA。</span></span><br><span class="line">        <span class="comment"># 也可以设置为 False 跳过验证，但极不安全。</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># 尝试使用我们自定义的CA证书</span></span><br><span class="line">        response = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">            response = requests.get(url, verify=CA_CERT_FILE)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">            response = requests.post(url, json=data, verify=CA_CERT_FILE)</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Status Code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Response Body: <span class="subst">&#123;response.json()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.SSLError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SSL Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hint: Ensure &#x27;ca.crt&#x27; is correctly specified in &#x27;verify=&#x27; and the server&#x27;s certificate is signed by this CA.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connection Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hint: Ensure terminator.py is running and accessible on specified port.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An unexpected error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- Starting backend_server.py in a separate terminal ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- Starting terminator.py in another separate terminal ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nPress Enter to run client requests once servers are up...&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">  </span><br><span class="line">    make_https_request(<span class="string">&quot;/test&quot;</span>)</span><br><span class="line">    make_https_request(<span class="string">&quot;/another/path?query=param&quot;</span>)</span><br><span class="line">    make_https_request(<span class="string">&quot;/data&quot;</span>, method=<span class="string">&quot;POST&quot;</span>, data=&#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span>, <span class="string">&quot;id&quot;</span>: <span class="number">123</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>运行步骤：</strong></p>
<ol>
<li>在项目根目录下生成证书文件 (<code>ca.key</code>, <code>ca.crt</code>, <code>server.key</code>, <code>server.csr</code>, <code>server.crt</code>)</li>
<li>打开第一个终端，运行后端服务器：<code>python backend_server.py</code></li>
<li>打开第二个终端，运行 SSL&#x2F;TLS 终止器：<code>python terminator.py</code></li>
<li>打开第三个终端，运行客户端：<code>python client.py</code> (在提示时按回车继续)</li>
</ol>
<p>通过这个例子，你可以看到客户端向终止器发起 HTTPS 请求，终止器将其解密后发送给后端（HTTP），后端处理后返回 HTTP 响应给终止器，终止器再加密后返回给客户端。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>SSL&#x2F;TLS 终止是现代网络架构中不可或缺的一部分，它通过将密文的加解密任务从应用服务器卸载，有效地提升了性能、简化了管理、增强了安全性和可观察性。理解其工作原理、优缺点及适用场景对于构建高性能、安全且易于维护的分布式系统至关重要。正确地部署和配置 SSL&#x2F;TLS 终止点，并结合适当的安全实践，能够最大化其带来的优势，同时有效规避潜在的风险。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/e261890c2af2/">https://blog.tbf1211.xx.kg/e261890c2af2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/TLS/">TLS</a><a class="post-meta__tags" href="/tags/HTTPS/">HTTPS</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ac609e6566a8/" title="DAST (Dynamic Application Security Testing) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DAST (Dynamic Application Security Testing) 详解</div></div><div class="info-2"><div class="info-item-1"> DAST (Dynamic Application Security Testing)，中文译为动态应用程序安全测试，是一种黑盒安全测试方法。它通过模拟恶意攻击者的行为，在不接触应用程序源代码的情况下，对正在运行的应用程序（包括Web应用、API和服务）进行测试，以发现运行时存在的安全漏洞。 DAST 工具会向应用程序发送各种恶意输入和请求，然后分析应用程序的响应，以识别潜在的漏洞，例如 SQL 注入、跨站脚本 (XSS)、不安全的直接对象引用等。  核心思想：DAST 从外部视角模拟真实世界的攻击，测试应用程序在实际运行环境中的安全性。它关注的是应用程序在被部署和运行时可能暴露出的漏洞，而非代码本身的缺陷。   一、为什么需要 DAST？在软件开发生命周期 (SDLC) 中，确保应用程序安全至关重要。虽然静态应用程序安全测试 (SAST) 可以从代码层面发现漏洞，但 DAST 弥补了 SAST 的不足：  真实运行环境：DAST 在应用程序部署后运行，测试的是实际的配置、部署环境和第三方组件交互，能够发现只在运行时暴露的漏洞（例如，不正确的服务器配置、环境变量泄露、跨域资源共...</div></div></div></a><a class="pagination-related" href="/340c8b6e7b0a/" title="SAST (Static Application Security Testing) 工具详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SAST (Static Application Security Testing) 工具详解</div></div><div class="info-2"><div class="info-item-1"> SAST (Static Application Security Testing，静态应用安全测试) 是一种白盒 (White-box) 安全测试方法，它通过不执行代码的方式，对应用程序的源代码、字节码或二进制代码进行分析，以识别潜在的安全漏洞和缺陷。SAST 工具旨在开发生命周期 (SDLC) 的早期阶段（“左移”）发现问题，使得开发者可以在发布前修复这些漏洞。  SAST 工具通过深入分析代码逻辑、数据流和控制流，识别出可能导致安全问题的编码模式、配置错误或不安全的API使用。它是 DevSecOps 实践中不可或缺的一部分，能够帮助团队在开发早期以自动化方式持续保障软件质量和安全性。   一、为什么需要 SAST？在现代软件开发流程中，应用程序的复杂性不断增加，发布周期日益缩短。传统的后期安全测试（例如渗透测试）往往在开发周期的末尾进行，此时发现的漏洞修复成本高昂，且可能延误发布。SAST 旨在解决以下问题：  “左移”安全 (Shift-Left Security)：在编码阶段就发现并修复漏洞，避免其进入后续开发阶段，从而降低修复成本和时间。 早期漏洞检测：在不运行代...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/a97c16bf3fd0/" title="奇偶检验详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-14</div><div class="info-item-2">奇偶检验详解</div></div><div class="info-2"><div class="info-item-1"> 奇偶检验 (Parity Check) 是一种最简单、最古老的错误检测方法，用于验证数据在传输或存储过程中是否发生了一位或奇数位的错误。它通过在原始数据的基础上添加一个额外的比特位（称为奇偶校验位）来实现。  核心思想： 通过统计数据位中 ‘1’ 的数量是奇数还是偶数，并添加一个校验位来使其总数符合预设的奇偶性，从而在接收端检测数据是否被意外翻转。   一、奇偶检验的基本原理奇偶检验的基本思想是确保一组二进制位中 ‘1’ 的总数（包括校验位）始终是奇数或偶数。 1.1 两种类型根据要求的奇偶性，奇偶检验分为两种：  奇校验 (Odd Parity Check)：  发送方统计数据位中 ‘1’ 的个数。 如果 ‘1’ 的个数为偶数，则奇偶校验位设置为 ‘1’，使包括校验位在内的所有位中 ‘1’ 的总数为奇数。 如果 ‘1’ 的个数为奇数，则奇偶校验位设置为 ‘0’，使包括校验位在内的所有位中 ‘1’ 的总数仍为奇数。 目标：传输的整个数据串（数据位 + 校验位）中 ‘1’ 的个数为奇数。   偶校验 (Even Parity Check)：  发送方统计数据位中 ‘1’ 的个数。...</div></div></div></a><a class="pagination-related" href="/84980af09d70/" title="HTTP URL 与 IP:端口 的区别详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-25</div><div class="info-item-2">HTTP URL 与 IP:端口 的区别详解</div></div><div class="info-2"><div class="info-item-1"> 虽然 http://127.0.0.1:1080 和 127.0.0.1:1080 都指向本地机器上的 1080 端口，但它们在含义、使用上下文和系统处理方式上存在根本区别。前者是一个完整的 URL (Uniform Resource Locator)，明确指定了协议 (Protocol)；而后者仅仅是一个 地址:端口 组合，通常用于网络服务的监听或内部配置，本身不包含协议信息。  核心思想：协议 (http://) 定义了客户端与服务端通信的方式和规则，而 IP:端口 仅仅标识了一个网络端点。在不同上下文中，对 IP:端口 的处理方式会有所不同，例如浏览器会自动补全协议，而网络编程接口通常只接收 IP:端口 来监听。   一、核心概念定义在深入探讨两者区别之前，我们先定义几个关键概念： 1.1 IP 地址 (Internet Protocol Address)定义：一个分配给网络上设备的数字标签，用于在计算机网络中标识和定位设备。127.0.0.1 是一个特殊的 IP 地址，称为回环地址 (Loopback Address) 或 本地主机 (localhost)，它总是指向当...</div></div></div></a><a class="pagination-related" href="/a92b9122509b/" title="Ubuntu UFW (Uncomplicated Firewall) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-01</div><div class="info-item-2">Ubuntu UFW (Uncomplicated Firewall) 详解</div></div><div class="info-2"><div class="info-item-1"> UFW (Uncomplicated Firewall) 是 Ubuntu Linux 及其衍生发行版中一个简化且易于使用的防火墙配置工具。它作为 iptables 的前端，提供了一个用户友好的命令行界面，让普通用户和系统管理员能够更轻松地管理 Linux 内核的 Netfilter 防火墙规则。UFW 的目标是“不复杂”，即简化防火墙的管理，使其不再令人生畏。  核心思想： UFW 提供了一种高级抽象，将复杂的 iptables 命令封装成少数直观的指令，使得用户无需深入理解 iptables 规则链即可实现基本的防火墙配置。   一、为什么选择 UFW？Linux 系统内置了强大的 Netfilter 框架和 iptables 工具，但 iptables 的语法复杂，规则众多，对于初学者来说学习曲线陡峭。UFW 旨在解决以下问题：  简化防火墙管理：  易于上手：通过简单的命令即可配置常见的防火墙规则，无需掌握复杂的 iptables 语法。 减少错误：简化后的命令减少了因语法错误导致配置失误的风险。   增强系统安全性：  默认拒绝策略：UFW 默认采用“默认拒绝所有传入...</div></div></div></a><a class="pagination-related" href="/296c75615ac4/" title="L4 负载均衡详解 (Layer 4 Load Balancing Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-13</div><div class="info-item-2">L4 负载均衡详解 (Layer 4 Load Balancing Explained)</div></div><div class="info-2"><div class="info-item-1"> L4 负载均衡 (Layer 4 Load Balancing)，也称为传输层负载均衡，是一种在 OSI 模型第四层（传输层）上进行流量分发的负载均衡技术。它主要根据网络数据包的 IP 地址和端口号信息来决定将请求转发到哪个后端服务器，而不解析应用层数据（如 HTTP 头、URL 或 Cookie）。L4 负载均衡器在建立 TCP 连接之初或接收 UDP 数据包时就做出转发决策。  核心思想：基于连接或数据包的源&#x2F;目的 IP 和端口进行快速、高效的流量转发，实现后端服务器的水平扩展和高可用性。   一、为什么需要 L4 负载均衡？在许多高性能和高并发的应用场景中，L4 负载均衡是实现可扩展性和可靠性的基础组件：  高吞吐量和低延迟：由于 L4 负载均衡器不需要解析应用层协议内容，其处理速度非常快，能够处理极高的并发连接和请求，并保持较低的延迟。这对于对性能要求极高的应用至关重要。 协议无关性：L4 负载均衡不限于 HTTP&#x2F;HTTPS 协议，它可以对任何基于 TCP 或 UDP 的协议（如 SSH、FTP、SMTP、DNS、RTP 以及各种私有协议）进行负载...</div></div></div></a><a class="pagination-related" href="/c5054902e8b1/" title="iptables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-25</div><div class="info-item-2">iptables 详解</div></div><div class="info-2"><div class="info-item-1"> iptables 是 Linux 系统中一个强大的防火墙工具，它基于 Netfilter 框架。Netfilter 是 Linux 内核中的一个数据包过滤和修改框架，而 iptables 是用于在用户空间配置 Netfilter 规则的命令行工具。通过 iptables，系统管理员可以定义各种规则来过滤、修改、转发或拦截网络数据包，从而实现网络流量控制、端口转发、地址伪装等功能。可以说，iptables 是 Linux 系统网络安全和流量管理的基石。  核心思想：基于规则链对数据包进行匹配和处理。 数据包在网络协议栈中穿行时，会根据定义好的规则链进行检查，并按照链中的规则顺序执行相应的动作。   一、Netfilter 框架与 iptables 关系理解 iptables，首先要了解它与 Netfilter 的关系：  Netfilter：位于 Linux 内核中，是一个用于网络数据包过滤、修改、转发和跟踪的框架。它定义了几个”钩子” (Hooks) 点，当数据包经过这些钩子点时，Netfilter 会检查是否有注册的规则需要处理该数据包。 iptables：是用户空间的命令行...</div></div></div></a><a class="pagination-related" href="/9b793354c088/" title="nftables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-28</div><div class="info-item-2">nftables 详解</div></div><div class="info-2"><div class="info-item-1"> nftables 是 Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在逐步取代传统的 iptables (以及 ip6tables, arptables, ebtables) 工具集，提供一个统一的、高效的、更易于管理和扩展的防火墙解决方案。nftables 引入了一套全新的语法和设计理念，旨在解决 iptables 长期存在的一些问题，例如命令复杂性、重复代码以及 IPv4 和 IPv6 规则管理的独立性等。  核心思想：基于表达式的统一规则集，支持原子性更新，并针对 IPv4&#x2F;IPv6&#x2F;桥接等协议提供统一管理。 它的设计哲学是从指令式规则集转向声明式通用虚拟机指令，使得规则处理更高效、更灵活。   一、为什么需要 nftables？iptables 的局限性虽然 iptables 强大且稳定，但它在设计和使用上存在一些固有的局限性，促使 Netfilter 社区开发 nftables：  语法复杂且碎片化：  iptables (用于 IPv4)、ip6tables (用于 IPv6)、arptables (用于 ARP)、ebtab...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">512</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-SSL-TLS-%E7%BB%88%E6%AD%A2%EF%BC%9F"><span class="toc-text">一、为什么需要 SSL&#x2F;TLS 终止？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SSL-TLS-%E7%BB%88%E6%AD%A2%E5%9C%A8%E5%93%AA%E9%87%8C%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-text">二、SSL&#x2F;TLS 终止在哪里发生？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SSL-TLS-%E7%BB%88%E6%AD%A2%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">三、SSL&#x2F;TLS 终止的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SSL-TLS-%E7%BB%88%E6%AD%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">四、SSL&#x2F;TLS 终止的两种模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">五、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Python"><span class="toc-text">六、代码示例 (Python)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-13.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>