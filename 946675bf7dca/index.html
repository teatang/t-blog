<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WebAssembly(Wasm)详解：浏览器中的下一代高性能计算 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在 Web 浏览器中运行高性能代码的方式。它是一种可移植、大小紧凑、加载快、与 Web 生态系统兼容的技术，旨在作为 Web 的编译目标。简单来说，Wasm 允许你用 C&#x2F;C++, Rust, Go 等多种语言编写代码，然后编译成 Wasm 格式，并在浏览器中以接近原生性能的速度运行。  核心思想：WebAssem">
<meta property="og:type" content="article">
<meta property="og:title" content="WebAssembly(Wasm)详解：浏览器中的下一代高性能计算">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/946675bf7dca/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在 Web 浏览器中运行高性能代码的方式。它是一种可移植、大小紧凑、加载快、与 Web 生态系统兼容的技术，旨在作为 Web 的编译目标。简单来说，Wasm 允许你用 C&#x2F;C++, Rust, Go 等多种语言编写代码，然后编译成 Wasm 格式，并在浏览器中以接近原生性能的速度运行。  核心思想：WebAssem">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg">
<meta property="article:published_time" content="2023-11-12T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-24T07:56:13.720Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="WebAssembly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WebAssembly(Wasm)详解：浏览器中的下一代高性能计算",
  "url": "https://blog.tbf1211.xx.kg/946675bf7dca/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg",
  "datePublished": "2023-11-12T22:24:00.000Z",
  "dateModified": "2025-12-24T07:56:13.720Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/946675bf7dca/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WebAssembly(Wasm)详解：浏览器中的下一代高性能计算',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">431</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">222</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-31.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-12T22:24:00.000Z" title="发表于 2023-11-13 06:24:00">2023-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BA%93/">库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在 Web 浏览器中运行高性能代码的方式。它是一种可移植、大小紧凑、加载快、与 Web 生态系统兼容的技术，旨在作为 Web 的编译目标。简单来说，Wasm 允许你用 C&#x2F;C++, Rust, Go 等多种语言编写代码，然后编译成 Wasm 格式，并在浏览器中以接近原生性能的速度运行。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>WebAssembly 是一种高效的、可移植的二进制指令格式，作为编译目标，使得 C&#x2F;C++, Rust 等宿主语言编写的代码能在浏览器、服务器等 WebAssembly 运行时中以接近原生性能执行，弥补了 JavaScript 在计算密集型任务上的短板，并扩展了 Web 应用的能力边界。</strong></p>
</div>
<hr>
<h2 id="一、WebAssembly-简介"><a href="#一、WebAssembly-简介" class="headerlink" title="一、WebAssembly 简介"></a>一、WebAssembly 简介</h2><h3 id="1-1-什么是-WebAssembly？"><a href="#1-1-什么是-WebAssembly？" class="headerlink" title="1.1 什么是 WebAssembly？"></a>1.1 什么是 WebAssembly？</h3><p>WebAssembly，通常缩写为 Wasm，是一种设计为在 Web 浏览器中执行的字节码格式。它并不是一种编程语言，而是一种编译目标。你可以把 C、C++、Rust 等高级语言编译成 Wasm 模块，然后在支持 Wasm 的环境中运行这些模块。</p>
<p><strong>关键特性：</strong></p>
<ul>
<li><strong>高性能</strong>：Wasm 是一种低级字节码，可以被现代浏览器引擎快速解析、编译和执行，性能接近原生代码。</li>
<li><strong>可移植</strong>：Wasm 模块是平台无关的，可以在任何支持 WebAssembly 运行时的环境中运行（包括浏览器和一些非浏览器环境）。</li>
<li><strong>安全</strong>：Wasm 运行在一个沙盒环境中，与外界隔离，具有与 JavaScript 相同的安全模型。</li>
<li><strong>大小紧凑</strong>：Wasm 模块采用二进制格式，通常比 JavaScript 源文件更小，加载更快。</li>
<li><strong>与 JavaScript 互操作</strong>：Wasm 模块可以与 JavaScript 代码无缝集成，互相调用函数，共享数据。</li>
</ul>
<h3 id="1-2-WebAssembly-的起源和目标"><a href="#1-2-WebAssembly-的起源和目标" class="headerlink" title="1.2 WebAssembly 的起源和目标"></a>1.2 WebAssembly 的起源和目标</h3><p>WebAssembly 起源于对 Web 上高性能应用的需求。JavaScript 虽然在 Web 开发中占据主导地位，但在图像处理、视频编辑、3D 游戏、科学计算等计算密集型场景下，其性能瓶颈明显。在此之前，有 asm.js (JavaScript 的一个子集，通过 AOT 优化提供更佳性能) 作为过渡技术，为 Wasm 奠定了基础。</p>
<p><strong>WebAssembly 的最终目标是：</strong></p>
<ol>
<li><strong>在 Web 上实现高性能代码</strong>：使 Web 应用程序能够达到原生应用级别的性能。</li>
<li><strong>提供更广的语言支持</strong>：让开发者可以使用自己熟悉的语言（C&#x2F;C++, Rust, Go, Python 等）来开发 Web 应用。</li>
<li><strong>标准化</strong>：成为 W3C 的开放标准，确保跨浏览器兼容性。</li>
<li><strong>在非浏览器环境运行</strong>：WebAssembly 也在积极扩展到服务器、桌面应用、物联网等非浏览器场景，形成 WebAssembly Runtime (Wasmtime, Wasmer 等)。</li>
</ol>
<h3 id="1-3-WebAssembly-与-JavaScript-的关系"><a href="#1-3-WebAssembly-与-JavaScript-的关系" class="headerlink" title="1.3 WebAssembly 与 JavaScript 的关系"></a>1.3 WebAssembly 与 JavaScript 的关系</h3><p>Wasm <strong>不是</strong>要取代 JavaScript，而是要<strong>补充</strong> JavaScript。</p>
<ul>
<li><strong>JavaScript</strong>：是 Web 的主要脚本语言，擅长 DOM 操作、事件处理、网络请求和大多数业务逻辑。它具有动态、灵活、易于学习的特点。</li>
<li><strong>WebAssembly</strong>：是 Web 的<strong>汇编语言</strong>，专注于执行计算密集型任务，提供高性能。它在浏览器中通常通过 JavaScript 加载和控制。</li>
</ul>
<p>两者可以完美协作：JavaScript 负责 UI 交互和高层业务逻辑，而 Wasm 负责底层算法、图形渲染、物理引擎等对性能要求高的模块。</p>
<h2 id="二、WebAssembly-的核心概念与工作原理"><a href="#二、WebAssembly-的核心概念与工作原理" class="headerlink" title="二、WebAssembly 的核心概念与工作原理"></a>二、WebAssembly 的核心概念与工作原理</h2><h3 id="2-1-Wasm-模块-Module"><a href="#2-1-Wasm-模块-Module" class="headerlink" title="2.1 Wasm 模块 (Module)"></a>2.1 Wasm 模块 (Module)</h3><p>Wasm 模块是 WebAssembly 的部署单元。它类似于一个可执行文件或一个共享库。</p>
<ul>
<li>它包含编译后的 Wasm 二进制代码 (<code>.wasm</code> 文件)。</li>
<li>它定义了<strong>导入 (imports)</strong>：模块执行时需要的函数、全局变量或内存（由宿主环境提供，通常是 JavaScript）。</li>
<li>它定义了<strong>导出 (exports)</strong>：模块提供给宿主环境调用的函数、内存或表。</li>
</ul>
<h3 id="2-2-Wasm-实例-Instance"><a href="#2-2-Wasm-实例-Instance" class="headerlink" title="2.2 Wasm 实例 (Instance)"></a>2.2 Wasm 实例 (Instance)</h3><p>Wasm 实例是 Wasm 模块在运行时的一个具体实例。每个实例都有自己的内存、表和全局变量。你可以从同一个模块创建多个实例。</p>
<h3 id="2-3-内存-Linear-Memory"><a href="#2-3-内存-Linear-Memory" class="headerlink" title="2.3 内存 (Linear Memory)"></a>2.3 内存 (Linear Memory)</h3><p>Wasm 模块操作的是一块连续的、可增长的字节数组，称为<strong>线性内存 (Linear Memory)</strong>。</p>
<ul>
<li>这块内存由 Wasm 实例和 JavaScript 共享。</li>
<li>JavaScript 可以通过 <code>WebAssembly.Memory</code> 对象访问和操作这块内存。</li>
<li>Wasm 代码通过内存地址和大小直接读写这块内存。</li>
<li>这使得 Wasm 和 JavaScript 之间可以通过直接读写内存来高效地传递结构化数据，而不是通过序列化&#x2F;反序列化。</li>
</ul>
<h3 id="2-4-表-Table"><a href="#2-4-表-Table" class="headerlink" title="2.4 表 (Table)"></a>2.4 表 (Table)</h3><p>Wasm 表是可调整大小的、类型化的引用数组。它的主要用途是存储间接函数引用，这使得 Wasm 模块可以实现动态调度、回调函数等高级编程模式。</p>
<h3 id="2-5-编译和执行流程"><a href="#2-5-编译和执行流程" class="headerlink" title="2.5 编译和执行流程"></a>2.5 编译和执行流程</h3><ol>
<li><strong>编写源代码</strong>：使用 C&#x2F;C++, Rust 等高级语言编写程序。</li>
<li><strong>编译到 Wasm</strong>：使用 Emscripten (C&#x2F;C++), wasm-pack (Rust) 等工具链将源代码编译成 <code>.wasm</code> 二进制文件。</li>
<li><strong>加载和实例化</strong> (在浏览器中通常通过 JavaScript)：<ul>
<li><strong>获取 <code>.wasm</code> 文件</strong>：通过 <code>fetch</code> API 或其他方式获取 Wasm 模块的二进制数据。</li>
<li><strong>编译</strong>：浏览器引擎解析 <code>.wasm</code> 二进制数据，并将其编译成机器码。这一步通常是流式编译 (streaming compilation)，可以在下载文件的同时进行编译。</li>
<li><strong>实例化</strong>：创建 Wasm 模块的实例，包括初始化其内存、表和全局变量，并解析其导入和导出。</li>
</ul>
</li>
<li><strong>执行</strong>：JavaScript 调用 Wasm 实例的导出函数，或 Wasm 内部函数自行执行。</li>
</ol>
<h2 id="三、WebAssembly-的使用方式-C-示例"><a href="#三、WebAssembly-的使用方式-C-示例" class="headerlink" title="三、WebAssembly 的使用方式 (C++ 示例)"></a>三、WebAssembly 的使用方式 (C++ 示例)</h2><p>这里以 C++ 为例，展示如何编译和在 Web 中使用 Wasm。</p>
<h3 id="3-1-编写-C-代码-add-cpp"><a href="#3-1-编写-C-代码-add-cpp" class="headerlink" title="3.1 编写 C++ 代码 (add.cpp)"></a>3.1 编写 C++ 代码 (<code>add.cpp</code>)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="comment">// 确保函数名不被 C++ Name Mangling 改变</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; from WebAssembly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用-Emscripten-编译"><a href="#3-2-使用-Emscripten-编译" class="headerlink" title="3.2 使用 Emscripten 编译"></a>3.2 使用 Emscripten 编译</h3><p>Emscripten 是一个将 C&#x2F;C++ 代码编译到 WebAssembly 的工具链。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Emscripten (如果尚未安装)</span></span><br><span class="line"><span class="comment"># git clone https://github.com/emscripten-core/emsdk.git</span></span><br><span class="line"><span class="comment"># cd emsdk</span></span><br><span class="line"><span class="comment"># ./emsdk install latest</span></span><br><span class="line"><span class="comment"># ./emsdk activate latest</span></span><br><span class="line"><span class="comment"># source ./emsdk_env.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 add.cpp 为 Wasm 模块</span></span><br><span class="line"><span class="comment"># -o add.html: 生成 HTML 文件、JS 胶水代码和 Wasm 模块</span></span><br><span class="line"><span class="comment"># -O3: 优化等级</span></span><br><span class="line"><span class="comment"># -s EXPORTED_FUNCTIONS=[&#x27;_add&#x27;, &#x27;_greet&#x27;]: 导出这两个 C 函数</span></span><br><span class="line"><span class="comment"># -s EXPORT_ES6=1: 生成ES6模块格式，方便在JS中import</span></span><br><span class="line"><span class="comment"># -s MODULARIZE=1: 将 Emscripten 运行时封装成模块</span></span><br><span class="line"><span class="comment"># -s WASM=1: 强制生成 Wasm 而不是 asm.js</span></span><br><span class="line"><span class="comment"># -s ALLOW_MEMORY_GROWTH=1: 允许内存自动增长</span></span><br><span class="line"></span><br><span class="line">emcc add.cpp -o add.html -O3 -s EXPORTED_FUNCTIONS=[<span class="string">&#x27;_add&#x27;</span>,<span class="string">&#x27;_greet&#x27;</span>] -s EXPORT_ES6=1 -s MODULARIZE=1 -s WASM=1 -s ALLOW_MEMORY_GROWTH=1</span><br></pre></td></tr></table></figure>
<p>这将生成 <code>add.html</code> (一个简单的示例页面), <code>add.js</code> (JavaScript 胶水代码) 和 <code>add.wasm</code> (Wasm 二进制模块)。</p>
<h3 id="3-3-在-JavaScript-中加载和使用-Wasm"><a href="#3-3-在-JavaScript-中加载和使用-Wasm" class="headerlink" title="3.3 在 JavaScript 中加载和使用 Wasm"></a>3.3 在 JavaScript 中加载和使用 Wasm</h3><h4 id="方式一：使用-Emscripten-生成的胶水代码-add-js"><a href="#方式一：使用-Emscripten-生成的胶水代码-add-js" class="headerlink" title="方式一：使用 Emscripten 生成的胶水代码 (add.js)"></a>方式一：使用 Emscripten 生成的胶水代码 (<code>add.js</code>)</h4><p><code>add.js</code> 是 Emscripten 自动生成的，它处理了 Wasm 模块的加载、编译和实例化，并提供了统一的 Module 对象。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebAssembly C++ Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">import</span> <span class="title class_">Module</span> <span class="keyword">from</span> <span class="string">&#x27;./add.js&#x27;</span>; <span class="comment">// 导入胶水代码</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Module</span>().<span class="title function_">then</span>(<span class="function"><span class="params">wasmModule</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// exports 是 Wasm 模块导出的所有函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebAssembly module loaded!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = wasmModule.<span class="title function_">_add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用导出的 add 函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;10 + 20 =&quot;</span>, result); <span class="comment">// Output: 10 + 20 = 30</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 调用 greet 函数，注意 C 字符串需要在 Wasm 内存中处理</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> name = <span class="string">&quot;Wasm User&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> namePtr = wasmModule.<span class="title function_">stringToUTF8</span>(name, wasmModule.<span class="title function_">_malloc</span>(name.<span class="property">length</span> + <span class="number">1</span>), name.<span class="property">length</span> + <span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">            wasmModule.<span class="title function_">_greet</span>(namePtr); <span class="comment">// Output: Hello, Wasm User from WebAssembly!</span></span></span><br><span class="line"><span class="language-javascript">            wasmModule.<span class="title function_">_free</span>(namePtr);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式二：直接使用-WebAssembly-JavaScript-API-更底层"><a href="#方式二：直接使用-WebAssembly-JavaScript-API-更底层" class="headerlink" title="方式二：直接使用 WebAssembly JavaScript API (更底层)"></a>方式二：直接使用 WebAssembly JavaScript API (更底层)</h4><p>如果你不想用 Emscripten 的胶水代码，或使用 Rust&#x2F;Go 等其他工具链，可以直接使用 <code>WebAssembly</code> API。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebAssembly Raw API Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadWasm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 Wasm 模块</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;add.wasm&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> bytes = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 定义导入对象 (如果 Wasm 模块需要导入一些 JS 函数或内存)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> importObject = &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">env</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// Wasm 模块可能会导入一些函数，例如 Emscripten 的打印函数</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">_emscripten_memcpy_js</span>: <span class="function">(<span class="params">dest, src, len</span>) =&gt;</span> &#123;&#125;, <span class="comment">// 占位符或实现它</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 如果 C++ 代码使用了标准库，可能需要更多导入</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 例如，对于 std::cout，你需要提供一个 JS 函数来接收输出</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 通常 Emscripten 胶水代码替你处理了这些</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">__cxa_throw</span>: <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// 错误处理占位符</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// ... 更多由编译工具链决定的导入</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">          </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 编译和实例化 Wasm 模块</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> &#123; instance, <span class="variable language_">module</span> &#125; = <span class="keyword">await</span> <span class="title class_">WebAssembly</span>.<span class="title function_">instantiate</span>(bytes, importObject);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 访问导出的函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> add = instance.<span class="property">exports</span>.<span class="property">_add</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;10 + 20 =&quot;</span>, <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// Output: 10 + 20 = 30</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 访问并操作 Wasm 内存来传递字符串 (更复杂)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 需要获取 Wasm 实例的内存 export，并手动管理内存分配</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 这一步通常由胶水代码或更高级的库处理</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// const greetFn = instance.exports._greet;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// const memory = instance.exports.memory;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ... 手动将字符串写入内存</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// greetFn(ptr);</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">loadWasm</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：直接使用原生 WebAssembly API 在处理字符串、复杂数据结构和 C++ 标准库导入时会比较复杂，因为你需要手动管理 Wasm 的线性内存。Emscripten 胶水代码就是为了简化这些复杂性。</p>
<h2 id="四、WebAssembly-的应用场景"><a href="#四、WebAssembly-的应用场景" class="headerlink" title="四、WebAssembly 的应用场景"></a>四、WebAssembly 的应用场景</h2><ul>
<li><strong>高性能计算任务</strong>：<ul>
<li><strong>图像&#x2F;视频处理</strong>：滤镜、编码&#x2F;解码、实时编辑。</li>
<li><strong>3D 游戏引擎</strong>：将桌面游戏移植到 Web，或在浏览器中运行复杂 3D 渲染。</li>
<li><strong>科学计算&#x2F;模拟</strong>：物理引擎、机器学习推理、数据分析。</li>
<li><strong>加密&#x2F;解密</strong>：密码学算法。</li>
</ul>
</li>
<li><strong>富客户端应用&#x2F;桌面应用移植</strong>：<ul>
<li>将现有 C&#x2F;C++&#x2F;Rust 桌面应用（如 CAD 软件、IDE）移植到 Web。</li>
<li>例如，Figma、AutoCAD 等复杂应用都在部分使用 Wasm。</li>
</ul>
</li>
<li><strong>编解码器</strong>：音频&#x2F;视频编解码、文件压缩&#x2F;解压缩。</li>
<li><strong>编程语言运行时</strong>：在浏览器中运行 Python、Ruby 等语言的解释器。</li>
<li><strong>Web Workers 结合</strong>：在后台线程中运行 Wasm 模块，避免阻塞主线程，提升用户体验。</li>
<li><strong>服务器端 (Wasm outside browser)</strong>：作为轻量级、安全、高性能的通用运行时，用于 Serverless、插件系统、边缘计算等场景。例如 Wasmtime, Wasmer。</li>
</ul>
<h2 id="五、WebAssembly-的未来发展"><a href="#五、WebAssembly-的未来发展" class="headerlink" title="五、WebAssembly 的未来发展"></a>五、WebAssembly 的未来发展</h2><p>WebAssembly 仍在快速发展中，许多新特性正在提议和实现：</p>
<ul>
<li><strong>垃圾回收 (Garbage Collection, GC)</strong>：允许 Wasm 直接与宿主环境的 GC 交互，或拥有自己的 GC，从而更好地支持 Java, C# 等具有 GC 的语言。</li>
<li><strong>WebAssembly System Interface (WASI)</strong>：一套标准化的系统接口，使得 Wasm 模块可以在非浏览器环境（如服务器）下访问文件系统、网络等，而不依赖于特定的宿主。</li>
<li><strong>多线程</strong>：Wasm 模块能够利用多个线程进行并行计算。</li>
<li><strong>引用类型 (Reference Types)</strong>：改善 Wasm 与宿主环境（特别是 JavaScript）之间对象传递的效率和灵活性。</li>
<li><strong>组件模型 (Component Model)</strong>：提供更强大的互操作性和模块化能力，使得不同语言编译的 Wasm 模块更容易组合。</li>
<li><strong>调试工具</strong>：随着 Wasm 的普及，更强大的调试工具将是必然。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>WebAssembly 是 Web 技术的重大突破，它打破了 JavaScript 在性能和语言选择上的限制，将 Web 应用的边界扩展到前所未有的广度。它使得高性能的计算、复杂的算法、以及现有大量 C&#x2F;C++ 等代码库能够无缝地在浏览器中运行。Wasm 不仅增强了 Web 客户端的能力，其在服务器端和其他非浏览器环境中的潜力也使其成为通用运行时领域一颗冉冉升起的新星。对于追求极致性能、多语言支持以及跨平台能力的开发者来说，WebAssembly 无疑是一个值得深入学习和掌握的关键技术。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/946675bf7dca/">https://blog.tbf1211.xx.kg/946675bf7dca/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/WebAssembly/">WebAssembly</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ab44062dd349/" title="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</div></div><div class="info-2"><div class="info-item-1"> 现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：patch(), patchVnode(), 和 updateChildren()，并辅以 Mermaid 流程图进行可视化说明。  “虚拟 DOM 是前端性能优化的基石，而 Vue 的 patch() 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”   一、虚拟 DOM (Virtual DOM) 再探1.1 什么是虚拟 DOM？虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：  tag：标签名（如 d...</div></div></div></a><a class="pagination-related" href="/91353ff26772/" title="Peewee ORM 详解：接口使用与实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Peewee ORM 详解：接口使用与实践</div></div><div class="info-2"><div class="info-item-1"> Peewee 是一个小型、富有表现力、功能齐全的 Python ORM (Object-Relational Mapper)。它提供了一种简单且 Pythonic 的方式来与数据库进行交互，支持 SQLite、PostgreSQL 和 MySQL 等多种关系型数据库。Peewee 的设计理念是轻量级和易用性，使得开发者可以快速地构建应用程序，而无需编写大量的 SQL 语句。  核心思想：将数据库表映射为 Python 类，将表的行映射为类的实例，将表的列映射为类的属性。 通过 Python 对象和方法来操作数据库，从而抽象掉底层的 SQL 细节。   一、为什么选择 Peewee？在 Python 生态中，存在多种 ORM 解决方案，如 SQLAlchemy、Django ORM 等。Peewee 在其中脱颖而出，主要归因于以下特点：  轻量级与简洁性：Peewee 本身代码量较少，API 设计简洁直观，学习曲线平缓。 富有表现力：其查询 API 允许开发者使用类似 Python 原生语法的方式链式调用，构建复杂的查询。 兼容性强：支持 SQLite、PostgreSQL 和 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/23aa2938b836/" title="跨域问题详解及解决方案"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="info-item-2">跨域问题详解及解决方案</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，“跨域” (Cross-Origin) 是一个非常常见且令人困扰的问题。它源于浏览器的一项重要安全策略：同源策略 (Same-Origin Policy)。理解同源策略以及如何安全有效地解决跨域问题，是每个 Web 开发者必备的知识。  核心思想：同源策略是浏览器的一项安全机制，它限制了来自一个源的文档或脚本与来自另一个源的资源进行交互。当请求的目标源与当前页面的源不一致时，就发生了跨域。解决跨域问题的关键是让服务器端或中间代理明确允许跨域请求。    一、什么是同源策略 (Same-Origin Policy)？同源策略 是浏览器为了保护用户隐私和数据安全而制定的一项基本安全功能。它限制了一个 HMTL 文档中加载的脚本如何与来自不同源的资源进行交互。 1.1 “源”的定义如果两个 URL 的协议 (Protocol)、域名 (Domain) 和端口 (Port) 都相同，则称它们是“同源”的。只要其中任何一个不同，就被认为是“跨源”或“不同源”。    URL A URL B 结果 原因    http://example.com/a.html http...</div></div></div></a><a class="pagination-related" href="/402798405a2e/" title="如何从 HTTP 请求中获取用户 IP 地址详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="info-item-2">如何从 HTTP 请求中获取用户 IP 地址详解</div></div><div class="info-2"><div class="info-item-1"> 用户 IP 地址 (Internet Protocol Address) 是互联网上设备的唯一标识符，对于网络服务而言，获取用户 IP 地址是常见需求。它在诸多场景中扮演着关键角色，如日志记录、地理位置定位、安全分析、流量统计、反欺诈和访问控制等。然而，由于现代网络架构中广泛使用代理服务器、负载均衡器和 CDN (内容分发网络)，直接获取用户的真实 IP 地址并非总是直截了当。本文将详细探讨如何从 HTTP 请求中正确、安全地获取用户 IP 地址，并提供 Go 语言示例。  核心思想：获取用户 IP 地址的关键在于理解 HTTP 请求的 RemoteAddr (直接连接客户端的 IP) 和一系列 X-Forwarded-For, X-Real-IP 等非标准但广泛使用的 HTTP 头。正确解析这些信息需要结合部署环境（是否存在代理、CDN）及安全考量。   一、IP 地址及其获取的重要性1.1 什么是 IP 地址？IP 地址是分配给连接到计算机网络的设备的数字标签，用于在网络中标识和定位设备。它分为 IPv4（如 192.168.1.1）和 IPv6（如 2001:0db8:8...</div></div></div></a><a class="pagination-related" href="/c86d0a022c83/" title="React入门教程：快速构建交互式用户界面"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="info-item-2">React入门教程：快速构建交互式用户界面</div></div><div class="info-2"><div class="info-item-1"> React (通常称为 React.js 或 ReactJS) 是一个用于构建用户界面的 JavaScript 库，由 Facebook (现为 Meta) 创建和维护。它允许开发者声明式地创建复杂的、交互式的 UI，其核心思想是组件化和响应式更新。React 专注于视图层，与传统 MVC 模式中的 V (View) 相对应。  核心思想：“声明式地”构建组件化的 UI。开发者描述 UI 在给定状态下的样子，React 负责高效地更新 DOM 以匹配该状态。    重要提示: React 主要使用 TypeScript 或 JavaScript (JSX) 进行开发。本文档中的所有代码示例都将使用 TypeScript (TSX) 语言，以满足类型安全的需求。  一、为什么需要 React？在现代 Web 开发中，构建复杂的用户界面面临诸多挑战：  DOM 操作的复杂性与性能瓶颈：直接操作 DOM 繁琐且容易出错，尤其是在数据频繁变化时，手动优化 DOM 更新的性能极其困难。 代码组织与复用性：随着应用规模的增长，UI 代码变得难以管理，组件之间的逻辑耦合高，复用性差。 状态管...</div></div></div></a><a class="pagination-related" href="/ecbfce34b2dd/" title="基于TypeScript封装Axios成通用工具类"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-01</div><div class="info-item-2">基于TypeScript封装Axios成通用工具类</div></div><div class="info-2"><div class="info-item-1"> Axios 是一款基于 Promise 的 HTTP 客户端，可用于浏览器和 Node.js 环境。它提供了丰富的功能，如请求&#x2F;响应拦截器、取消请求、自动转换 JSON 等，使其成为前端和后端 HTTP 请求的流行选择。然而，在大型项目中直接使用裸露的 Axios 实例往往不够高效和灵活。通过 TypeScript 封装 Axios 成通用工具类，我们可以实现：统一的请求配置、自动的错误处理、请求&#x2F;响应的标准化、方便的业务逻辑扩展，以及通过 TypeScript 带来的类型安全和代码智能提示，从而提升开发效率和代码质量。  核心思想：将 Axios 的强大功能（如拦截器、配置）整合到一个类型安全的 TypeScript 类中，提供一个统一、可配置、易用的 HTTP 请求接口，并处理常见的业务场景，从而提升项目的可维护性和开发体验。    一、为什么需要封装 Axios？直接使用 Axios 发送请求虽然简单，但在实际项目中会遇到以下问题：  重复配置：每个请求都可能需要设置 baseURL、timeout、headers 等，导致大量重复代码。 错误处理不统...</div></div></div></a><a class="pagination-related" href="/f252362edcb7/" title="Sass(SCSS)和Less CSS预处理器详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="info-item-2">Sass(SCSS)和Less CSS预处理器详解</div></div><div class="info-2"><div class="info-item-1"> Sass (Syntactically Awesome Style Sheets) 和 Less (Leaner Style Sheets) 是目前最流行的两种 CSS 预处理器。它们扩展了 CSS 语言的功能，允许开发者使用变量、混合 (Mixins)、嵌套、函数、继承等编程特性来编写样式，极大地提高了 CSS 的可维护性、代码复用性和开发效率。本篇将详细介绍 Sass 和 Less 的特性、语法以及它们之间的异同。  核心思想：Sass 和 Less 通过添加编程语言特性（如变量、混合、嵌套、函数等），将样式代码模块化、动态化，最终编译为标准 CSS，从而提升 CSS 编写效率和可维护性。   一、CSS 预处理器概述1.1 为什么需要 CSS 预处理器？传统的 CSS 有以下痛点：  重复性：颜色、字体大小等值可能在多处重复，修改时需要修改所有地方。 可维护性差：缺乏变量、函数等概念，难以模块化和抽象。 没有逻辑性：无法进行条件判断、循环等操作。 选择器冗余：深度嵌套的选择器导致代码量庞大。 供应商前缀：手动添加 -webkit-, -moz- 等前缀繁琐且易出错。  C...</div></div></div></a><a class="pagination-related" href="/9474fb1165cb/" title="React 详解：核心 API 深度解读"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-27</div><div class="info-item-2">React 详解：核心 API 深度解读</div></div><div class="info-2"><div class="info-item-1"> React 是一个用于构建用户界面的 JavaScript 库。它以声明式的方式让开发者可以轻松构建复杂且交互性强的 UI。要真正驾驭 React，深入理解其核心 API 至关重要。这些 API 是构建组件、管理状态、处理副作用、优化性能以及与其他系统交互的基础。本文将对 React 的核心 API 进行深度解读，涵盖从组件定义到高级优化等各个方面。  核心思想：React 核心 API 围绕组件化、声明式UI、单向数据流和性能优化展开，通过 Hooks 极大地简化了函数组件的状态管理和副作用处理，使复杂逻辑更易组织和复用。   一、React 的核心模块与入口React 库被拆分为两个主要模块：react 和 react-dom。  react: 包含构建组件和定义其行为所需的核心 API（如 Component, useState, useEffect, createContext 等）。 react-dom: 提供与 DOM 交互的特定方法（如 render, createRoot 等），用于将 React 组件渲染到浏览器环境。  react-dom 主要 API1. ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">431</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">222</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81WebAssembly-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、WebAssembly 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-WebAssembly%EF%BC%9F"><span class="toc-text">1.1 什么是 WebAssembly？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-WebAssembly-%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-text">1.2 WebAssembly 的起源和目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-WebAssembly-%E4%B8%8E-JavaScript-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1.3 WebAssembly 与 JavaScript 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81WebAssembly-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、WebAssembly 的核心概念与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Wasm-%E6%A8%A1%E5%9D%97-Module"><span class="toc-text">2.1 Wasm 模块 (Module)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Wasm-%E5%AE%9E%E4%BE%8B-Instance"><span class="toc-text">2.2 Wasm 实例 (Instance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%86%85%E5%AD%98-Linear-Memory"><span class="toc-text">2.3 内存 (Linear Memory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%A1%A8-Table"><span class="toc-text">2.4 表 (Table)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.5 编译和执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81WebAssembly-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-C-%E7%A4%BA%E4%BE%8B"><span class="toc-text">三、WebAssembly 的使用方式 (C++ 示例)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BC%96%E5%86%99-C-%E4%BB%A3%E7%A0%81-add-cpp"><span class="toc-text">3.1 编写 C++ 代码 (add.cpp)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8-Emscripten-%E7%BC%96%E8%AF%91"><span class="toc-text">3.2 使用 Emscripten 编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%9C%A8-JavaScript-%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8-Wasm"><span class="toc-text">3.3 在 JavaScript 中加载和使用 Wasm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-Emscripten-%E7%94%9F%E6%88%90%E7%9A%84%E8%83%B6%E6%B0%B4%E4%BB%A3%E7%A0%81-add-js"><span class="toc-text">方式一：使用 Emscripten 生成的胶水代码 (add.js)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-WebAssembly-JavaScript-API-%E6%9B%B4%E5%BA%95%E5%B1%82"><span class="toc-text">方式二：直接使用 WebAssembly JavaScript API (更底层)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81WebAssembly-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、WebAssembly 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81WebAssembly-%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%8F%91%E5%B1%95"><span class="toc-text">五、WebAssembly 的未来发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-31.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>