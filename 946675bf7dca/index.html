<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WebAssembly(Wasm)详解：浏览器中的下一代高性能计算 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在现代Web浏览器中执行接近原生性能代码的方法。它被设计为一个可移植、体积小、加载快且与Web兼容的编译目标。Wasm 不仅限于浏览器环境，通过 WASI (WebAssembly System Interface) 等标准，它也能在服务器、物联网设备等非浏览器环境中高效运行。  核心思想：为各种编程语言（如 C&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="WebAssembly(Wasm)详解：浏览器中的下一代高性能计算">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/946675bf7dca/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在现代Web浏览器中执行接近原生性能代码的方法。它被设计为一个可移植、体积小、加载快且与Web兼容的编译目标。Wasm 不仅限于浏览器环境，通过 WASI (WebAssembly System Interface) 等标准，它也能在服务器、物联网设备等非浏览器环境中高效运行。  核心思想：为各种编程语言（如 C&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg">
<meta property="article:published_time" content="2023-11-12T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-06T09:33:58.472Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Web技术">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="WebAssembly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WebAssembly(Wasm)详解：浏览器中的下一代高性能计算",
  "url": "https://blog.tbf1211.xx.kg/946675bf7dca/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg",
  "datePublished": "2023-11-12T22:24:00.000Z",
  "dateModified": "2026-02-06T09:33:58.472Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/946675bf7dca/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WebAssembly(Wasm)详解：浏览器中的下一代高性能计算',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">546</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-06.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-12T22:24:00.000Z" title="发表于 2023-11-13 06:24:00">2023-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/Web%E6%8A%80%E6%9C%AF/">Web技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>WebAssembly (Wasm)</strong> 是一种二进制指令格式，它提供了一种在现代Web浏览器中执行接近原生性能代码的方法。它被设计为一个可移植、体积小、加载快且与Web兼容的编译目标。<code>Wasm</code> 不仅限于浏览器环境，通过 <strong>WASI (WebAssembly System Interface)</strong> 等标准，它也能在服务器、物联网设备等非浏览器环境中高效运行。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>为各种编程语言（如 C&#x2F;C++、Rust、Go、Python 等）提供一个高性能、安全的编译目标，使其代码能在Web或其他沙盒环境中以接近原生速度运行。</strong></p>
</div>

<hr>
<h2 id="一、为什么需要-WebAssembly？"><a href="#一、为什么需要-WebAssembly？" class="headerlink" title="一、为什么需要 WebAssembly？"></a>一、为什么需要 WebAssembly？</h2><p>在 WebAssembly 出现之前，JavaScript 是 Web 平台唯一的编程语言。尽管 JavaScript 及其引擎（如 V8）在性能方面取得了巨大进步，但仍然存在一些固有局限性：</p>
<ol>
<li><strong>性能瓶颈</strong>：对于计算密集型任务（如图形处理、视频编码&#x2F;解码、科学计算、大型游戏），JavaScript 的动态类型、垃圾回收机制以及解释&#x2F;JIT编译特性，使其难以达到原生代码的性能水平。</li>
<li><strong>语言选择受限</strong>：开发者只能使用 JavaScript 进行前端开发，而许多现有的大型库、应用程序和专业领域代码（如C&#x2F;C++编写的音视频编解码器、游戏引擎）无法直接在浏览器中复用。</li>
<li><strong>文件大小</strong>：JavaScript 代码通常以文本形式传输，包含冗余的字符和空白，影响加载速度。</li>
</ol>
<p>WebAssembly 的出现旨在解决这些痛点，它提供了一个新的运行时环境，具备以下优势：</p>
<ul>
<li><strong>接近原生的性能</strong>：Wasm 是一种低级字节码格式，可以被浏览器快速解析和编译为机器码，其执行速度远超 JavaScript。</li>
<li><strong>多语言支持</strong>：开发者可以使用C&#x2F;C++、Rust、Go、C#、Kotlin等多种语言编写代码，并将其编译成 Wasm，极大地拓宽了Web开发的语言生态。</li>
<li><strong>安全沙箱环境</strong>：Wasm 代码在沙箱环境中执行，与宿主环境（如浏览器）隔离，无法直接访问系统资源或修改DOM，提高了安全性。</li>
<li><strong>紧凑的二进制格式</strong>：Wasm 文件体积小，加载和启动速度快，尤其适合移动设备和带宽受限的环境。</li>
<li><strong>与 JavaScript 无缝协同</strong>：Wasm 可以与 JavaScript 互相调用，互相补充，共同完成Web应用功能。</li>
</ul>
<h2 id="二、WebAssembly-的核心概念"><a href="#二、WebAssembly-的核心概念" class="headerlink" title="二、WebAssembly 的核心概念"></a>二、WebAssembly 的核心概念</h2><h3 id="2-1-模块-Module"><a href="#2-1-模块-Module" class="headerlink" title="2.1 模块 (Module)"></a>2.1 模块 (Module)</h3><ul>
<li><strong>定义</strong>：一个 <code>Wasm Module</code> 类似于一个ES6模块或DLL&#x2F;SO文件。它包含了 WebAssembly 代码的二进制指令和相关的元数据。</li>
<li><strong>内容</strong>：模块定义了函数、全局变量、内存、表（Table）等。它是独立的、无状态的。</li>
<li><strong>用途</strong>：一个模块可以被编译一次并实例化多次。</li>
</ul>
<h3 id="2-2-实例-Instance"><a href="#2-2-实例-Instance" class="headerlink" title="2.2 实例 (Instance)"></a>2.2 实例 (Instance)</h3><ul>
<li><strong>定义</strong>：一个 <code>Wasm Instance</code> 是一个已加载并运行的模块。它包含了模块定义的所有可执行代码、数据以及在运行时创建的状态（如内存内容、全局变量的当前值）。</li>
<li><strong>特点</strong>：每个实例都是独立的，拥有自己的内存空间。</li>
</ul>
<h3 id="2-3-内存-Memory"><a href="#2-3-内存-Memory" class="headerlink" title="2.3 内存 (Memory)"></a>2.3 内存 (Memory)</h3><ul>
<li><strong>定义</strong>：<code>Wasm Memory</code> 是一个可增长的字节数组，WebAssembly 实例可以在其中存储和操作数据。它是一个线性内存空间，由页（page，每页64KB）组成。</li>
<li><strong>访问</strong>：Wasm 模块可以直接通过内存地址访问这段内存。JavaScript 也可以通过 <code>ArrayBuffer</code> 对象访问和修改它。</li>
</ul>
<h3 id="2-4-表-Table"><a href="#2-4-表-Table" class="headerlink" title="2.4 表 (Table)"></a>2.4 表 (Table)</h3><ul>
<li><strong>定义</strong>：<code>Wasm Table</code> 是一个可增长的引用类型数组，其中存储的是函数引用（function references）。</li>
<li><strong>用途</strong>：主要用于实现间接函数调用，例如C&#x2F;C++中的函数指针。</li>
</ul>
<h3 id="2-5-主机环境-Host-Environment-与-API"><a href="#2-5-主机环境-Host-Environment-与-API" class="headerlink" title="2.5 主机环境 (Host Environment) 与 API"></a>2.5 主机环境 (Host Environment) 与 API</h3><ul>
<li><strong>定义</strong>：运行 WebAssembly 的环境（如浏览器、Node.js、Wasmtime等）称为主机环境。</li>
<li><strong>交互</strong>：Wasm 模块可以通过导入（Import）和导出（Export）机制与主机环境进行交互。<ul>
<li><strong>导入 (Imports)</strong>：Wasm 模块可以从主机环境导入函数、内存或表。</li>
<li><strong>导出 (Exports)</strong>：Wasm 模块可以向主机环境导出其内部的函数、内存或表，供 JavaScript 或其他主机API调用。</li>
</ul>
</li>
<li><strong><code>WebAssembly</code> 全局对象</strong>：在浏览器中，JavaScript 通过全局的 <code>WebAssembly</code> 对象来加载、编译和实例化 Wasm 模块。</li>
</ul>
<h3 id="2-6-Wasm-文本格式-WAT-与-Wasm-二进制格式"><a href="#2-6-Wasm-文本格式-WAT-与-Wasm-二进制格式" class="headerlink" title="2.6 Wasm 文本格式 (WAT) 与 Wasm 二进制格式"></a>2.6 Wasm 文本格式 (WAT) 与 Wasm 二进制格式</h3><ul>
<li><p><strong>WAT (WebAssembly Text Format)</strong>：</p>
<ul>
<li>一种人类可读的汇编语言式文本格式，类似于汇编代码，但结构更清晰。</li>
<li>用于开发、调试和理解 Wasm 代码。</li>
<li><code>.wat</code> 文件。</li>
<li><strong>示例 (WAT):</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(module</span><br><span class="line">  (func $add (param $lhs i32) (param $rhs i32) (result i32)</span><br><span class="line">    local.get $lhs</span><br><span class="line">    local.get $rhs</span><br><span class="line">    i32.add)</span><br><span class="line">  (export &quot;add&quot; (func $add)))</span><br></pre></td></tr></table></figure>
上述代码定义了一个名为 <code>add</code> 的函数，接受两个 <code>i32</code> 类型的参数，返回一个 <code>i32</code> 类型的结果，并将该函数导出为 <code>add</code>。</li>
</ul>
</li>
<li><p><strong>Wasm (WebAssembly Binary Format)</strong>：</p>
<ul>
<li>一种紧凑、高效的二进制格式，是浏览器或 Wasm 运行时直接执行的指令集。</li>
<li><code>.wasm</code> 文件。</li>
<li>由 WAT 格式或其他高级语言编译而来。</li>
</ul>
</li>
</ul>
<h2 id="三、WebAssembly-的工作原理"><a href="#三、WebAssembly-的工作原理" class="headerlink" title="三、WebAssembly 的工作原理"></a>三、WebAssembly 的工作原理</h2><p>WebAssembly 的生命周期可以分为以下几个阶段：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;高级语言源码&lt;br&gt;(C&#x2F;C++, Rust, Go, TypeScript等)&quot;] --&gt; B{&quot;编译器&lt;br&gt;(LLVM, Emscripten, TinyGo等)&quot;}
    B --&gt; C[&quot;Wasm 二进制文件&lt;br&gt;(.wasm)&quot;]
    C --&gt; D[JavaScript 加载器]
    D --&gt; E[浏览器&#x2F;Wasm运行时]
    E --&gt; F[Wasm VM]
    F --&gt; G[执行Wasm指令&lt;br&gt;与JS交互]

    subgraph 编译阶段
        A --&gt; B
        B --&gt; C
    end

    subgraph 运行阶段
        C --&gt; D
        D --&gt; E
        E --&gt; F
        F --&gt; G
    end
  </pre></div>

<h3 id="3-1-编译阶段"><a href="#3-1-编译阶段" class="headerlink" title="3.1 编译阶段"></a>3.1 编译阶段</h3><p>开发者使用 C&#x2F;C++、Rust、Go 等高级语言编写代码，然后使用相应的编译器（如 Emscripten 用于 C&#x2F;C++，TinyGo 用于 Go，<code>wasm-pack</code> 用于 Rust）将其编译成 <code>.wasm</code> 格式的二进制文件。</p>
<ul>
<li><strong>示例 (Go 语言编译到 Wasm):</strong><br>假设有一个 Go 文件 <code>main.go</code>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 函数可以被导出并在 JavaScript 中调用</span></span><br><span class="line"><span class="comment">// 为了导出函数，我们需要在 Go 中使用`syscall/js`包</span></span><br><span class="line"><span class="comment">// 这里我们先展示一个简单函数，后续通过`wasm_exec.js`来桥接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数是Wasm模块的入口点，但通常在浏览器中由JS调用导出的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Go WebAssembly module started!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>编译命令 (使用 TinyGo):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tinygo build -o main.wasm -target wasm main.go</span><br></pre></td></tr></table></figure>
或者使用标准 Go 工具链 (需要 <code>wasm_exec.js</code> 辅助):<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOOS=js GOARCH=wasm go build -o main.wasm main.go</span><br><span class="line"><span class="comment"># 同时需要将 Go SDK 中的 wasm_exec.js 复制到项目目录</span></span><br><span class="line"><span class="built_in">cp</span> <span class="string">&quot;<span class="subst">$(go env GOROOT)</span>/misc/wasm/wasm_exec.js&quot;</span> .</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-加载与实例化"><a href="#3-2-加载与实例化" class="headerlink" title="3.2 加载与实例化"></a>3.2 加载与实例化</h3><p>浏览器或 Wasm 运行时通过 JavaScript API 加载 <code>.wasm</code> 文件，并将其编译成机器码，然后创建一个 Wasm 模块实例。</p>
<p><strong>JavaScript 代码示例 (加载和实例化 Wasm 模块):</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// 对于 Go 编译的 Wasm，通常需要引入 Go 提供的胶水文件 wasm_exec.js</span></span><br><span class="line"><span class="comment">// import &#x27;./wasm_exec.js&#x27;; // 在浏览器中可能通过 &lt;script&gt; 标签引入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadWebAssembly</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建 Go 实例，用于 Go runtime 环境</span></span><br><span class="line">    <span class="keyword">const</span> go = <span class="keyword">new</span> <span class="title class_">Go</span>(); <span class="comment">// Go 对象由 wasm_exec.js 提供</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：通过 fetch API 加载 .wasm 文件</span></span><br><span class="line">    <span class="comment">// const response = await fetch(&#x27;main.wasm&#x27;);</span></span><br><span class="line">    <span class="comment">// const wasmInstance = await WebAssembly.instantiateStreaming(response, go.importObject);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：通过 ArrayBuffer 加载 .wasm 文件</span></span><br><span class="line">    <span class="keyword">const</span> bytes = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;main.wasm&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">arrayBuffer</span>());</span><br><span class="line">    <span class="keyword">const</span> wasmInstance = <span class="keyword">await</span> <span class="title class_">WebAssembly</span>.<span class="title function_">instantiate</span>(bytes, go.<span class="property">importObject</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 Go Wasm 模块的主函数 (如果需要)</span></span><br><span class="line">    <span class="comment">// 对于 Go，go.run() 会执行 Wasm 模块的 main 函数</span></span><br><span class="line">    go.<span class="title function_">run</span>(wasmInstance.<span class="property">instance</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebAssembly module loaded and instantiated!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 Go 模块导出了函数，可以通过 wasmInstance.instance.exports 访问</span></span><br><span class="line">    <span class="comment">// 例如，假设 Go 导出了一个 add 函数：</span></span><br><span class="line">    <span class="comment">// const add = wasmInstance.instance.exports.add;</span></span><br><span class="line">    <span class="comment">// console.log(&quot;Result of add(5, 3):&quot;, add(5, 3)); // 注意：Go 语言导出函数需要特定的syscall/js接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保在 DOMContentLoaded 之后运行</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, loadWebAssembly);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：Go 语言要导出函数供 JavaScript 直接调用，需要使用 <code>syscall/js</code> 包中的 <code>js.FuncOf</code> 注册函数，并在 <code>main</code> 函数中保持程序运行（例如通过 <code>select &#123;&#125;</code>）。</p>
<p><strong>一个更完整的 Go 导出函数示例：</strong></p>
<p><code>main.go</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall/js&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(this js.Value, args []js.Value)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	a := args[<span class="number">0</span>].Int()</span><br><span class="line">	b := args[<span class="number">1</span>].Int()</span><br><span class="line">	result := a + b</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Go&#x27;s add function called with %d and %d, result: %d\n&quot;</span>, a, b, result)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerCallbacks</span><span class="params">()</span></span> &#123;</span><br><span class="line">	js.Global().Set(<span class="string">&quot;goAdd&quot;</span>, js.FuncOf(add)) <span class="comment">// 将 Go 的 add 函数导出为 JS 全局的 goAdd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Go WebAssembly module started, registering callbacks...&quot;</span>)</span><br><span class="line">	registerCallbacks()</span><br><span class="line">	&lt;-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">// 保持 Go 程序运行，等待 JS 调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译 <code>tinygo build -o main.wasm -target wasm main.go</code>。</p>
<p><code>index.html</code> (引入 <code>wasm_exec.js</code> 和 <code>main.js</code>):</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go WebAssembly Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;wasm_exec.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Go WebAssembly Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadWebAssembly</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> go = <span class="keyword">new</span> <span class="title class_">Go</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> bytes = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;main.wasm&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">arrayBuffer</span>());</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> wasmInstance = <span class="keyword">await</span> <span class="title class_">WebAssembly</span>.<span class="title function_">instantiate</span>(bytes, go.<span class="property">importObject</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            go.<span class="title function_">run</span>(wasmInstance.<span class="property">instance</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebAssembly module loaded and instantiated!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 现在可以通过 js.Global().Set 注册的函数来调用 Go 函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = <span class="title function_">goAdd</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 Go 导出的 goAdd 函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Result from goAdd(5, 3) called by JS:&quot;</span>, result);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, loadWebAssembly);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-执行"><a href="#3-3-执行" class="headerlink" title="3.3 执行"></a>3.3 执行</h3><p>一旦 Wasm 模块被实例化，其导出的函数就可以被 JavaScript 调用。Wasm VM 将执行这些函数，直接操作 Wasm 模块的线性内存和表。</p>
<h3 id="3-4-WebAssembly-System-Interface-WASI"><a href="#3-4-WebAssembly-System-Interface-WASI" class="headerlink" title="3.4 WebAssembly System Interface (WASI)"></a>3.4 WebAssembly System Interface (WASI)</h3><ul>
<li><strong>定义</strong>：WASI 是 WebAssembly 的一个模块化系统接口。它允许 WebAssembly 代码在非 Web 环境（如操作系统）中与系统资源（如文件系统、网络、命令行参数）进行安全交互。</li>
<li><strong>用途</strong>：通过 WASI，WebAssembly 可以在服务器端、边缘计算、桌面应用等场景下运行，实现真正的“一次编写，处处运行” (Write Once, Run Anywhere)，而不仅仅是局限于浏览器。</li>
</ul>
<h2 id="四、WebAssembly-的优势与适用场景"><a href="#四、WebAssembly-的优势与适用场景" class="headerlink" title="四、WebAssembly 的优势与适用场景"></a>四、WebAssembly 的优势与适用场景</h2><h3 id="4-1-优势"><a href="#4-1-优势" class="headerlink" title="4.1 优势"></a>4.1 优势</h3><ol>
<li><strong>高性能</strong>：接近原生代码的执行速度，非常适合计算密集型任务。</li>
<li><strong>多语言生态</strong>：支持编译多种高级语言到 Wasm，极大地丰富了 Web 开发的工具链。</li>
<li><strong>安全性</strong>：沙箱模型隔离了 Wasm 代码与宿主环境，提供了强大的安全保障。</li>
<li><strong>可移植性</strong>：Wasm 是一种标准化的字节码，可以在所有支持 Wasm 的平台和浏览器上运行。</li>
<li><strong>内存效率</strong>：线性内存模型和对底层硬件的良好映射，使其在内存使用上非常高效。</li>
<li><strong>启动速度快</strong>：二进制格式紧凑，解析和JIT编译速度快。</li>
</ol>
<h3 id="4-2-适用场景"><a href="#4-2-适用场景" class="headerlink" title="4.2 适用场景"></a>4.2 适用场景</h3><ul>
<li><strong>计算密集型应用</strong>：<ul>
<li><strong>游戏</strong>：将C&#x2F;C++游戏引擎移植到Web。</li>
<li><strong>图像&#x2F;视频编辑</strong>：高性能处理，如滤镜、编解码。</li>
<li><strong>CAD&#x2F;CAM</strong>：浏览器内的复杂模型渲染和计算。</li>
<li><strong>科学计算与数据可视化</strong>：在浏览器中运行高性能的数值算法。</li>
</ul>
</li>
<li><strong>现有代码库的复用</strong>：<ul>
<li>将大型C&#x2F;C++库（如 OpenCV, FFmpeg, SQLite）编译到Wasm，在Web端使用。</li>
</ul>
</li>
<li><strong>区块链与加密货币</strong>：<ul>
<li>智能合约的执行环境，提供可预测的性能和安全隔离。</li>
</ul>
</li>
<li><strong>边缘计算与无服务器函数</strong>：<ul>
<li>Wasm 的快速启动和沙箱特性使其成为在边缘设备或无服务器环境中运行轻量级计算任务的理想选择。</li>
</ul>
</li>
<li><strong>桌面应用与移动应用</strong>：<ul>
<li>通过 Electron&#x2F;Tauri 或特定运行时，Wasm 也可以用于构建跨平台的桌面和移动应用。</li>
</ul>
</li>
</ul>
<h2 id="五、WebAssembly-的局限性与未来展望"><a href="#五、WebAssembly-的局限性与未来展望" class="headerlink" title="五、WebAssembly 的局限性与未来展望"></a>五、WebAssembly 的局限性与未来展望</h2><h3 id="5-1-局限性"><a href="#5-1-局限性" class="headerlink" title="5.1 局限性"></a>5.1 局限性</h3><ol>
<li><strong>无法直接访问 DOM</strong>：Wasm 模块不能直接操作 Web 页面的 DOM 结构，必须通过 JavaScript 进行桥接。</li>
<li><strong>垃圾回收 (GC)</strong>：目前 Wasm 本身没有内置的垃圾回收机制（GC），需要编译源语言的 GC 运行时或手动管理内存。这增加了来自 GC 语言的编译复杂性。</li>
<li><strong>调试复杂性</strong>：调试 Wasm 代码比调试 JavaScript 更具挑战性，需要专门的工具支持。</li>
<li><strong>多线程支持</strong>：早期 Wasm 没有原生多线程支持，目前通过 SharedArrayBuffer 和 Web Workers 模拟，但标准化仍在推进中。</li>
<li><strong>工具链成熟度</strong>：虽然发展迅速，但与 JavaScript 生态相比，Wasm 的工具链和库生态仍在发展中。</li>
</ol>
<h3 id="5-2-未来展望"><a href="#5-2-未来展望" class="headerlink" title="5.2 未来展望"></a>5.2 未来展望</h3><p>WebAssembly 仍在快速发展，未来潜力巨大：</p>
<ol>
<li><strong>Wasm Component Model</strong>：一个旨在解决模块间互操作性、实现跨语言组件复用、并标准化 Wasm ABI 的提案，将极大提升 Wasm 的开发效率和灵活性。</li>
<li><strong>WasmGC (Garbage Collection)</strong>：Wasm 垃圾回收提案将允许像 Java、Kotlin、Python 等原生带有 GC 的语言更高效地编译到 Wasm，减少运行时大小并提升性能。</li>
<li><strong>多线程和 SIMD</strong>：原生多线程和单指令多数据 (SIMD) 指令集支持将进一步提升 Wasm 的并行计算能力和性能。</li>
<li><strong>WASI 演进</strong>：WASI 标准的不断完善将使得 Wasm 在系统编程领域的应用更加广泛和成熟。</li>
<li><strong>Post-MVP Features</strong>：持续集成更多高级功能，如异常处理、类型反射等，使其成为更完善的通用计算平台。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>WebAssembly 并非旨在取代 JavaScript，而是作为其强大的补充，共同构成了一个更强大、更高效的 Web 平台。它为 Web 带来了接近原生的性能，拓宽了 Web 开发的语言选择，并为 Web 应用开启了更广阔的可能性。随着其生态系统和标准化的不断成熟，WebAssembly 正逐渐从一个浏览器内的性能引擎，演变为一个通用的、安全、可移植的计算平台，其影响力将超越 Web 领域，触及服务器、边缘计算、桌面和移动应用等更多领域。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/946675bf7dca/">https://blog.tbf1211.xx.kg/946675bf7dca/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Web%E6%8A%80%E6%9C%AF/">Web技术</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/WebAssembly/">WebAssembly</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-06.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ab44062dd349/" title="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</div></div><div class="info-2"><div class="info-item-1"> 现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：patch(), patchVnode(), 和 updateChildren()，并辅以 Mermaid 流程图进行可视化说明。  “虚拟 DOM 是前端性能优化的基石，而 Vue 的 patch() 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”   一、虚拟 DOM (Virtual DOM) 再探1.1 什么是虚拟 DOM？虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：  tag：标签名（如 d...</div></div></div></a><a class="pagination-related" href="/91353ff26772/" title="Peewee ORM 详解：接口使用与实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Peewee ORM 详解：接口使用与实践</div></div><div class="info-2"><div class="info-item-1"> Peewee 是一个小型、富有表现力、功能齐全的 Python ORM (Object-Relational Mapper)。它提供了一种简单且 Pythonic 的方式来与数据库进行交互，支持 SQLite、PostgreSQL 和 MySQL 等多种关系型数据库。Peewee 的设计理念是轻量级和易用性，使得开发者可以快速地构建应用程序，而无需编写大量的 SQL 语句。  核心思想：将数据库表映射为 Python 类，将表的行映射为类的实例，将表的列映射为类的属性。 通过 Python 对象和方法来操作数据库，从而抽象掉底层的 SQL 细节。   一、为什么选择 Peewee？在 Python 生态中，存在多种 ORM 解决方案，如 SQLAlchemy、Django ORM 等。Peewee 在其中脱颖而出，主要归因于以下特点：  轻量级与简洁性：Peewee 本身代码量较少，API 设计简洁直观，学习曲线平缓。 富有表现力：其查询 API 允许开发者使用类似 Python 原生语法的方式链式调用，构建复杂的查询。 兼容性强：支持 SQLite、PostgreSQL 和 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/0c202b3d53be/" title="前端文件下载的各种方式的详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-19</div><div class="info-item-2">前端文件下载的各种方式的详解</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，文件下载是一个常见且重要的功能。无论是下载用户生成的数据、报告、图片，还是静态资源，前端开发者都需要掌握多种实现文件下载的方法。本文将详细探讨前端实现文件下载的各种技术，包括 HTML 原生方式、JavaScript 编程方式以及涉及服务器端配合的场景。  核心思想：前端文件下载的核心在于如何将文件数据（无论是服务器传输的还是客户端生成的）转化为可供浏览器识别并触发下载操作的格式（如 Blob 对象或直接的 URL），并通过特定的机制（如 &lt;a&gt; 标签的 download 属性或服务器响应头）来提示浏览器进行下载而非直接显示。   一、文件下载的基础概念在深入具体方法之前，我们先理解文件下载的一些基本概念：  下载 vs. 显示：浏览器在处理文件时，会根据 Content-Type 和 Content-Disposition 等 HTTP 响应头来决定是下载文件（保存到本地）还是在浏览器中直接显示（如图片、PDF）。 文件来源： 服务器端文件：文件存储在服务器上，前端通过 URL 请求获取。 客户端生成文件：文件内容由前端 JavaScript ...</div></div></div></a><a class="pagination-related" href="/23aa2938b836/" title="跨域问题详解及解决方案"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="info-item-2">跨域问题详解及解决方案</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，“跨域” (Cross-Origin) 是一个非常常见且令人困扰的问题。它源于浏览器的一项重要安全策略：同源策略 (Same-Origin Policy)。理解同源策略以及如何安全有效地解决跨域问题，是每个 Web 开发者必备的知识。  核心思想：同源策略是浏览器的一项安全机制，它限制了来自一个源的文档或脚本与来自另一个源的资源进行交互。当请求的目标源与当前页面的源不一致时，就发生了跨域。解决跨域问题的关键是让服务器端或中间代理明确允许跨域请求。    一、什么是同源策略 (Same-Origin Policy)？同源策略 是浏览器为了保护用户隐私和数据安全而制定的一项基本安全功能。它限制了一个 HMTL 文档中加载的脚本如何与来自不同源的资源进行交互。 1.1 “源”的定义如果两个 URL 的协议 (Protocol)、域名 (Domain) 和端口 (Port) 都相同，则称它们是“同源”的。只要其中任何一个不同，就被认为是“跨源”或“不同源”。    URL A URL B 结果 原因    http://example.com/a.html http...</div></div></div></a><a class="pagination-related" href="/40c57ff5cb61/" title="Pug(前Jade)模板引擎详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="info-item-2">Pug(前Jade)模板引擎详解</div></div><div class="info-2"><div class="info-item-1"> Pug（发音 &#x2F;pʌɡ&#x2F;），前身为 Jade，是一个高性能的 Node.js 模板引擎。它以其简洁、富有表现力的语法而闻名，旨在让 HTML 编写变得更加高效和愉快。Pug 摒弃了传统 HTML 的尖括号和闭合标签，转而使用缩进和基于文本的语法，这使得模板文件更小、更易读、也更不易出错。  核心思想：Pug 通过简洁的缩进语法替代冗长的 HTML 标签，提供强大的动态数据渲染、代码重用和条件逻辑功能。   一、Pug 简介1.1 什么是模板引擎？模板引擎是一种将数据填充到预定义模板中以生成最终输出（通常是 HTML 字符串）的工具。它将页面的结构（模板）与数据分离，使得前端开发更加模块化和可维护。 1.2 Pug 的特点 独特语法：使用缩进表示嵌套关系，无需关闭标签。 简洁明了：代码量显著少于对应的 HTML。 强大功能：支持变量、循环、条件判断、Mixin（类似于函数或组件）、包含（文件复用）、布局继承等高级特性。 编译到 HTML：Pug 模板最终会被编译成标准的 HTML。 Node.js 支持：作为 Node.js 的模板引擎，Pug 完美集成于 E...</div></div></div></a><a class="pagination-related" href="/f6760e6cdcc0/" title="Chrome 扩展程序 (Extension) 开发详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-15</div><div class="info-item-2">Chrome 扩展程序 (Extension) 开发详解</div></div><div class="info-2"><div class="info-item-1"> Chrome 扩展程序 (Chrome Extension) 是一种通过 Web 技术 (HTML, CSS, JavaScript) 构建的小型程序，旨在扩展 Google Chrome 浏览器的功能。它们运行在独立的、受沙盒保护的环境中，可以与浏览器功能深度集成，允许用户根据个人需求和工作流定制和增强其浏览体验。  核心思想：Chrome 扩展程序通过 manifest.json 文件定义其元数据、权限和组件，并通过各种 JavaScript 文件 (如后台脚本、内容脚本、弹出页面脚本) 与浏览器 API 交互，实现对网页内容、浏览器行为和用户界面的定制化增强。Chrome 扩展开发已全面转向 Manifest V3。   一、为什么开发 Chrome 扩展程序？Chrome 扩展程序为用户和开发者提供了独特的价值：  功能增强：为浏览器添加新的功能，如广告拦截、密码管理、翻译、截图工具等。 效率提升：自动化重复任务，整合第三方服务，优化工作流程。 定制化体验：修改网页 UI，注入自定义样式或脚本，提供个性化的浏览体验。 开发便捷：基于标准 Web 技术，学习曲线相对平缓，...</div></div></div></a><a class="pagination-related" href="/f02d15c85cac/" title="Server-Sent Events (SSE) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-15</div><div class="info-item-2">Server-Sent Events (SSE) 详解</div></div><div class="info-2"><div class="info-item-1"> Server-Sent Events (SSE) 是一种 HTML5 规范，允许服务器通过持久的 HTTP 连接，以文本流 (text-stream) 的形式向客户端推送事件。它提供了一种高效、简单的方式来实现服务器到客户端的单向实时通信，特别适用于需要从服务器端持续获取数据更新的场景，如实时数据流、通知推送等。  核心思想：SSE 利用标准的 HTTP&#x2F;1.1 协议，通过一个持久的 GET 请求建立连接，服务器端持续向客户端发送带有特定格式的数据流，客户端通过 EventSource API 监听并处理这些事件。   一、为什么需要 SSE？(实时通信的演进)在 Web 应用中，实现服务器向客户端的实时数据推送一直是开发者面临的挑战。随着技术的发展，出现了多种解决方案，SSE 是其中一种重要的选择。 1.1 传统轮询 (Polling) 定义：客户端定期（如每隔几秒）向服务器发送 HTTP 请求，询问是否有新的数据。 优点：实现简单，兼容性好。 缺点： 效率低下：大多数请求可能是无效的（无新数据），造成大量不必要的 HTTP 请求和服务器资源浪费。 延迟高：数据的实...</div></div></div></a><a class="pagination-related" href="/234c44d5851b/" title="HTML5 单页面应用 (SPA) 路由实现详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="info-item-2">HTML5 单页面应用 (SPA) 路由实现详解</div></div><div class="info-2"><div class="info-item-1"> 单页面应用 (Single Page Application, SPA) 是一种 Web 应用程序模型，它通过动态重写当前页面而非从服务器加载整个新页面来实现与用户的交互。这种模式极大地提升了用户体验，使其更接近桌面应用。SPA 的核心技术之一是客户端路由 (Client-Side Routing)，它允许应用程序在不进行整页刷新的情况下，根据 URL 路径的变化渲染不同的视图。  核心思想：HTML5 History API 允许 Web 应用程序在客户端直接操纵浏览器会话历史记录，从而实现 URL 的无刷新更新和状态管理，这是现代 SPA 路由的基础。   一、传统页面跳转与 SPA 路由的区别在深入探讨 SPA 路由之前，我们首先理解传统多页面应用 (Multi-Page Application, MPA) 的页面跳转机制及其与 SPA 的根本不同：  传统 MPA 页面跳转：  用户点击链接或提交表单。 浏览器向服务器发送 HTTP 请求，请求新的 HTML 页面。 服务器响应并发送完整的 HTML 文档。 浏览器销毁当前页面，加载并渲染新的 HTML 文档。   特点...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">546</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-WebAssembly%EF%BC%9F"><span class="toc-text">一、为什么需要 WebAssembly？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81WebAssembly-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、WebAssembly 的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A8%A1%E5%9D%97-Module"><span class="toc-text">2.1 模块 (Module)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9E%E4%BE%8B-Instance"><span class="toc-text">2.2 实例 (Instance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%86%85%E5%AD%98-Memory"><span class="toc-text">2.3 内存 (Memory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%A1%A8-Table"><span class="toc-text">2.4 表 (Table)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%B8%BB%E6%9C%BA%E7%8E%AF%E5%A2%83-Host-Environment-%E4%B8%8E-API"><span class="toc-text">2.5 主机环境 (Host Environment) 与 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Wasm-%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F-WAT-%E4%B8%8E-Wasm-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.6 Wasm 文本格式 (WAT) 与 Wasm 二进制格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81WebAssembly-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">三、WebAssembly 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="toc-text">3.1 编译阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">3.2 加载与实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%89%A7%E8%A1%8C"><span class="toc-text">3.3 执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-WebAssembly-System-Interface-WASI"><span class="toc-text">3.4 WebAssembly System Interface (WASI)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81WebAssembly-%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、WebAssembly 的优势与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E5%8A%BF"><span class="toc-text">4.1 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.2 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81WebAssembly-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-text">五、WebAssembly 的局限性与未来展望</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">5.1 局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-text">5.2 未来展望</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-06.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>