<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TLS (传输层安全协议) 深度详解：网络通信的守护者 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TLS (Transport Layer Security)，即传输层安全性协议，是用于在计算机网络上提供端到端安全通信的加密协议。它是 SSL (Secure Sockets Layer) 协议的继任者，两者常被混用，但技术上，现代网络浏览器及服务器都已使用 TLS 协议。TLS 主要提供数据隐私、数据完整性以及通信双方的身份认证，是互联网上最广泛使用的安全协议，例如 HTTPS (HTTP">
<meta property="og:type" content="article">
<meta property="og:title" content="TLS (传输层安全协议) 深度详解：网络通信的守护者">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/22aa4c322dbd/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="TLS (Transport Layer Security)，即传输层安全性协议，是用于在计算机网络上提供端到端安全通信的加密协议。它是 SSL (Secure Sockets Layer) 协议的继任者，两者常被混用，但技术上，现代网络浏览器及服务器都已使用 TLS 协议。TLS 主要提供数据隐私、数据完整性以及通信双方的身份认证，是互联网上最广泛使用的安全协议，例如 HTTPS (HTTP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg">
<meta property="article:published_time" content="2023-04-01T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-21T01:29:47.858Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="TLS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TLS (传输层安全协议) 深度详解：网络通信的守护者",
  "url": "https://blog.tbf1211.xx.kg/22aa4c322dbd/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg",
  "datePublished": "2023-04-01T22:24:00.000Z",
  "dateModified": "2026-01-21T01:29:47.858Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/22aa4c322dbd/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TLS (传输层安全协议) 深度详解：网络通信的守护者',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">507</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">TLS (传输层安全协议) 深度详解：网络通信的守护者</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TLS (传输层安全协议) 深度详解：网络通信的守护者</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-04-01T22:24:00.000Z" title="发表于 2023-04-02 06:24:00">2023-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>TLS (Transport Layer Security)</strong>，即<strong>传输层安全性协议</strong>，是用于在计算机网络上提供<strong>端到端安全通信</strong>的加密协议。它是 <strong>SSL (Secure Sockets Layer) 协议</strong>的继任者，两者常被混用，但技术上，现代网络浏览器及服务器都已使用 TLS 协议。TLS 主要提供<strong>数据隐私、数据完整性以及通信双方的身份认证</strong>，是互联网上最广泛使用的安全协议，例如 HTTPS (HTTP over TLS)、SMTPS、LDAPS 等都依赖于 TLS。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>在不可信的网络上，通过加密、认证和完整性校验，建立一个可信的加密通信通道。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-TLS？"><a href="#一、为什么需要-TLS？" class="headerlink" title="一、为什么需要 TLS？"></a>一、为什么需要 TLS？</h2><p>互联网的早期（例如纯 HTTP 时代），数据在传输过程中是<strong>明文</strong>的。这意味着：</p>
<ol>
<li><strong>窃听 (Eavesdropping)</strong>：任何中间人（如 ISP、路由器管理员、恶意攻击者）都可以截获并读取传输中的数据，包括用户密码、银行卡信息、私人消息等。</li>
<li><strong>篡改 (Tampering)</strong>：中间人不仅可以读取数据，还可以修改数据，例如在网页中植入恶意代码，或者更改用户提交的表单内容。</li>
<li><strong>身份伪装 (Impersonation)</strong>：客户端无法确认连接的服务器是否是真实的服务器，攻击者可以伪装成合法服务器，诱骗用户提交敏感信息（即<strong>钓鱼攻击</strong>）。</li>
</ol>
<p>TLS 旨在解决这些根本性的网络安全问题，确保通信的：</p>
<ul>
<li><strong>隐私性 (Confidentiality)</strong>：通过加密，确保只有通信双方能读取数据。</li>
<li><strong>完整性 (Integrity)</strong>：通过消息认证码 (MAC) 或数字签名，确保数据在传输过程中未被篡改。</li>
<li><strong>认证性 (Authentication)</strong>：通过数字证书，确保通信双方（特别是服务器）的身份是真实的。</li>
</ul>
<h2 id="二、TLS-的工作原理概述"><a href="#二、TLS-的工作原理概述" class="headerlink" title="二、TLS 的工作原理概述"></a>二、TLS 的工作原理概述</h2><p>TLS 协议的建立分为两个主要阶段：<strong>握手阶段 (Handshake Protocol)</strong> 和 <strong>记录阶段 (Record Protocol)</strong>。</p>
<ol>
<li><p><strong>握手阶段 (Handshake)</strong>：</p>
<ul>
<li>在正式传输应用数据之前，通信双方（客户端和服务器）会进行一系列的协商和交换，包括：<ul>
<li><strong>协商密码套件</strong>：确定使用哪些加密算法、散列算法等。</li>
<li><strong>身份认证</strong>：服务器向客户端提供数字证书以证明其身份，客户端可选地提供证书给服务器（客户端认证，不常用）。</li>
<li><strong>密钥交换</strong>：安全地协商出一个用于后续数据加密的共享会话密钥。</li>
</ul>
</li>
<li>这个阶段完成后，双方会建立一个安全的加密通道。</li>
</ul>
</li>
<li><p><strong>记录阶段 (Record)</strong>：</p>
<ul>
<li>一旦加密通道建立，应用数据（如 HTTP 请求&#x2F;响应）就会被拆分成多个记录 (Record)。</li>
<li>每个记录都会被<strong>加密</strong>，并添加<strong>消息认证码 (MAC)</strong> 以确保数据的完整性。</li>
<li>这些加密的记录通过底层的传输协议（如 TCP）进行传输。</li>
<li>接收方收到记录后，会先验证 MAC，如果通过则解密数据，然后将数据传递给上层应用。</li>
</ul>
</li>
</ol>
<h2 id="三、TLS-握手协议详解"><a href="#三、TLS-握手协议详解" class="headerlink" title="三、TLS 握手协议详解"></a>三、TLS 握手协议详解</h2><p>TLS 握手是整个安全通信建立的关键，其主要步骤如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    C-&gt;&gt;S: 1. Client Hello (支持的TLS版本、密码套件、随机数ClientRandom、SNI等)
    S-&gt;&gt;C: 2. Server Hello (选定的TLS版本、密码套件、随机数ServerRandom)
    S-&gt;&gt;C: 3. Certificate (服务器数字证书及其链)
    S-&gt;&gt;C: 4. Server Key Exchange (如果需要，如DHE、ECDHE)
    S-&gt;&gt;C: 5. Certificate Request (可选，如果需要客户端认证)
    S-&gt;&gt;C: 6. Server Hello Done (服务器握手消息结束)

    C-&gt;&gt;C: 7. 验证服务器证书&#x2F;提取服务器公钥&#x2F;生成预主密钥PreMasterSecret
    C-&gt;&gt;S: 8. Certificate (如果需要客户端认证)
    C-&gt;&gt;S: 9. Client Key Exchange (包含加密的PreMasterSecret或DHE&#x2F;ECDHE参数)
    C-&gt;&gt;S: 10. Certificate Verify (如果需要客户端认证，用客户端私钥签名PreMasterSecret)
    C-&gt;&gt;C: 11. 从PreMasterSecret和ClientRandom&#x2F;ServerRandom生成会话密钥
    C-&gt;&gt;S: 12. Change Cipher Spec (通知服务器后续加密通信)
    C-&gt;&gt;S: 13. Encrypted Handshake Message (客户端Finished消息，使用会话密钥加密)

    S-&gt;&gt;S: 14. 从PreMasterSecret和ClientRandom&#x2F;ServerRandom生成会话密钥
    S-&gt;&gt;S: 15. 验证客户端Finished消息
    S-&gt;&gt;C: 16. Change Cipher Spec (通知客户端后续加密通信)
    S-&gt;&gt;C: 17. Encrypted Handshake Message (服务器Finished消息，使用会话密钥加密)
    Note over C,S: TLS 握手完成，开始安全通信
    C&lt;&lt;-&gt;&gt;S: 18. Application Data (使用协商好的会话密钥加密)
  </pre></div>

<p><strong>重要步骤解析：</strong></p>
<ol>
<li><p><strong>Client Hello</strong>：</p>
<ul>
<li>客户端发起连接请求，包含：<ul>
<li>支持的 TLS 版本（如 TLS 1.2, TLS 1.3）</li>
<li>支持的密码套件列表（如 <code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code>）</li>
<li>一个随机数 <code>ClientRandom</code></li>
<li>SNI (Server Name Indication) 扩展（指定要访问的域名）</li>
<li>其他扩展信息（如 ALPN、Session Ticket 等）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Server Hello</strong>：</p>
<ul>
<li>服务器响应，包含：<ul>
<li>选择的 TLS 版本</li>
<li>从客户端列表中选择的密码套件</li>
<li>一个随机数 <code>ServerRandom</code></li>
<li>Session ID (如果恢复会话)</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Certificate</strong>：</p>
<ul>
<li>服务器发送其<strong>数字证书和证书链</strong>。证书中包含服务器的公钥和身份信息，由受信任的证书颁发机构 (CA) 签名。客户端使用 CA 证书验证服务器证书的真实性。</li>
</ul>
</li>
<li><p><strong>Server Key Exchange (可选)</strong>：</p>
<ul>
<li>如果选择的密码套件是基于 <strong>DHE (Diffie-Hellman Ephemeral) 或 ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)</strong> 等支持<strong>前向保密 (Forward Secrecy)</strong> 的密钥交换算法，服务器会在此处发送密钥交换的参数。</li>
<li>前向保密意味着即使长期私钥泄露，过去的会话数据也不会被解密。</li>
</ul>
</li>
<li><p><strong>Server Hello Done</strong>：</p>
<ul>
<li>服务器通知客户端所有握手消息已发送完毕。</li>
</ul>
</li>
<li><p><strong>客户端验证证书并生成 PreMasterSecret</strong>：</p>
<ul>
<li>客户端接收服务器证书：<ul>
<li>检查证书是否由受信任的 CA 签发。</li>
<li>验证证书是否过期、是否被吊销。</li>
<li>验证证书中的域名是否与请求的域名一致。</li>
</ul>
</li>
<li>如果证书验证通过：<ul>
<li>客户端生成一个随机数 <strong><code>PreMasterSecret</code></strong>。</li>
<li>使用服务器证书中的<strong>公钥</strong>加密 <code>PreMasterSecret</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Client Key Exchange</strong>：</p>
<ul>
<li>客户端将加密后的 <code>PreMasterSecret</code> 发送给服务器（或 DHE&#x2F;ECDHE 参数）。</li>
</ul>
</li>
<li><p><strong>生成会话密钥 (Session Key)</strong>：</p>
<ul>
<li>客户端和服务器分别使用 <code>ClientRandom</code>、<code>ServerRandom</code> 和 <code>PreMasterSecret</code>，通过一个协商好的<strong>密钥导出函数 (Key Derivation Function, KDF)</strong>，生成用于对称加密的<strong>会话密钥 (Session Key)</strong>。</li>
<li>这个会话密钥是临时且独一无二的，只用于当前会话的数据加密。</li>
</ul>
</li>
<li><p><strong>Change Cipher Spec &amp; Finished</strong>：</p>
<ul>
<li>双方互相发送 <code>Change Cipher Spec</code> 消息，表示后续的数据将使用新协商的会话密钥和加密算法进行加密。</li>
<li>接着发送一个加密的 <code>Finished</code> 消息，其中包含之前所有握手消息的哈希值，用于验证握手过程是否被篡改。</li>
</ul>
</li>
</ol>
<h2 id="四、TLS-的核心安全特性"><a href="#四、TLS-的核心安全特性" class="headerlink" title="四、TLS 的核心安全特性"></a>四、TLS 的核心安全特性</h2><ol>
<li><p><strong>认证 (Authentication)</strong>：</p>
<ul>
<li>主要通过<strong>数字证书</strong>实现。客户端验证服务器的证书，确认其身份。可选的客户端证书可用于服务器认证客户端。</li>
<li><strong>公钥基础设施 (PKI)</strong>：是实现证书认证的基础，包括证书颁发机构 (CA) 和证书撤销列表 (CRL)&#x2F;在线证书状态协议 (OCSP)。</li>
</ul>
</li>
<li><p><strong>加密 (Encryption)</strong>：</p>
<ul>
<li><strong>对称加密</strong>：在握手阶段协商出<strong>会话密钥</strong>后，后续的应用数据使用<strong>对称加密算法</strong>（如 AES-256、ChaCha20）进行加密和解密。对称加密速度快，适合大量数据传输。</li>
<li><strong>非对称加密</strong>：用于在握手阶段安全地交换会话密钥（如 RSA、DHE、ECDHE），或用于数字签名以验证身份。</li>
</ul>
</li>
<li><p><strong>完整性 (Integrity)</strong>：</p>
<ul>
<li>通过使用 <strong>消息认证码 (MAC)</strong> 或<strong>数字签名 (Digital Signature)</strong>（如 HMAC-SHA256、Poly1305）来确保数据在传输过程中没有被篡改。接收方会根据接收到的数据重新计算 MAC，并与随数据一同传输的 MAC 进行比对。</li>
</ul>
</li>
<li><p><strong>前向保密 (Forward Secrecy)</strong>：</p>
<ul>
<li>指即使长期使用的私钥（如服务器证书的私钥）在未来被泄露，过去通过该私钥建立的会话数据也不会因此被解密。</li>
<li>这通过使用<strong>临时密钥交换算法</strong>（如 Diffie-Hellman Ephemeral, DHE 或 ECDHE）实现。每次会话都生成新的、临时的共享密钥，一旦会话结束，临时密钥就会销毁。</li>
</ul>
</li>
</ol>
<h2 id="五、TLS-版本与演进"><a href="#五、TLS-版本与演进" class="headerlink" title="五、TLS 版本与演进"></a>五、TLS 版本与演进</h2><table>
<thead>
<tr>
<th align="left">TLS 版本</th>
<th align="left">发布时间</th>
<th align="left">关键特性</th>
<th align="left">常见算法</th>
<th align="left">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SSL 1.0</td>
<td align="left">(未公开发布)</td>
<td align="left">安全漏洞过多</td>
<td align="left">-</td>
<td align="left">已废弃，从未投入使用</td>
</tr>
<tr>
<td align="left">SSL 2.0</td>
<td align="left">1995</td>
<td align="left">第一个公开版本，但存在严重漏洞</td>
<td align="left">-</td>
<td align="left">已废弃 (RFC 6101 禁用)</td>
</tr>
<tr>
<td align="left">SSL 3.0</td>
<td align="left">1996</td>
<td align="left">改进了 2.0 的安全，但存在 POODLE 漏洞</td>
<td align="left">RSA, DES, 3DES, RC4</td>
<td align="left">已废弃 (RFC 7568 禁用)</td>
</tr>
<tr>
<td align="left"><strong>TLS 1.0</strong></td>
<td align="left">1999</td>
<td align="left">SSL 3.0 的升级版，功能类似但解决了 SSL 3.0 的漏洞。<br/> (但仍然存在一些已知漏洞，如 BEAST)</td>
<td align="left">RSA, AES, RC4, SHA1</td>
<td align="left">大多数现代浏览器&#x2F;服务器已弃用或不推荐</td>
</tr>
<tr>
<td align="left"><strong>TLS 1.1</strong></td>
<td align="left">2006</td>
<td align="left">增加了对隐式 IV 的保护，修复了 BEAST 漏洞的部分问题。<br/> (但仍存在一些弱点)</td>
<td align="left">RSA, AES, RC4, SHA1</td>
<td align="left">大多数现代浏览器&#x2F;服务器已弃用或不推荐</td>
</tr>
<tr>
<td align="left"><strong>TLS 1.2</strong></td>
<td align="left">2008</td>
<td align="left"><strong>目前最广泛使用的版本</strong>。引入了更强大的密码套件，支持 GCM 加密模式和 SHA-256 哈希。<br/> 支持 SNI、ALPN 等扩展。</td>
<td align="left">ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-GCM-SHA256，ChaCha20-Poly1305</td>
<td align="left"><strong>目前主流推荐版本，仍广泛使用</strong></td>
</tr>
<tr>
<td align="left"><strong>TLS 1.3</strong></td>
<td align="left">2018</td>
<td align="left"><strong>最新且最安全的版本</strong>。显著改进了性能和安全性：<br/>- <strong>更快的握手</strong>：0-RTT 或 1-RTT，相比 TLS 1.2 的 2-RTT 更快。<br/>- <strong>移除弱密码套件</strong>：废弃所有不安全的加密算法和散列算法。<br/>- <strong>强制前向保密</strong>：只允许支持前向保密的密钥交换算法。<br/>- <strong>加密大部分握手消息</strong>：例如 Server Hello 之后的消息，包括服务器证书，进一步增强隐私。</td>
<td align="left">ECDHE-RSA-AES256-GCM-SHA384, ChaCha20-Poly1305 等 AEAD 密码套件</td>
<td align="left"><strong>推荐使用，正在逐步普及</strong></td>
</tr>
</tbody></table>
<h2 id="六、TLS-的应用：HTTPS"><a href="#六、TLS-的应用：HTTPS" class="headerlink" title="六、TLS 的应用：HTTPS"></a>六、TLS 的应用：HTTPS</h2><p><strong>HTTPS (Hypertext Transfer Protocol Secure)</strong> 是最常见的基于 TLS 的应用协议。它通过在 HTTP 和 TCP 之间插入 TLS 层，为 Web 通信提供了安全性。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[应用层] --&gt; B[HTTP]
    B --&gt; C[SSL&#x2F;TLS]
    C --&gt; D[传输层]
    D --&gt; E[TCP]
    E --&gt; F[网络层]
    F --&gt; G[IP]
    G --&gt; H[数据链路层]
    H --&gt; I[以太网&#x2F;Wi-Fi]
  </pre></div>
<p>当您在浏览器中访问一个 HTTPS 网站时，实际发生的通信是：</p>
<ol>
<li>浏览器和 Web 服务器之间进行 TLS 握手，建立加密通道。</li>
<li>一旦 TLS 握手完成，浏览器发送的 HTTP 请求和服务器返回的 HTTP 响应都会经过 TLS 层进行加密和解密，确保数据传输的安全。</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>TLS 是现代互联网安全通信的基石。它通过结合非对称加密（用于密钥交换和身份认证）、对称加密（用于数据传输）和散列函数（用于数据完整性），构建了一个强大的安全框架。从 SSL 2.0 到最新的 TLS 1.3，该协议不断发展以应对新的安全威胁，并持续优化性能。理解 TLS 的工作原理，对于任何涉及网络安全、Web 开发和系统管理的专业人士来说，都是一项核心技能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/22aa4c322dbd/">https://blog.tbf1211.xx.kg/22aa4c322dbd/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/TLS/">TLS</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/59d0e10ae2fa/" title="HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私</div></div><div class="info-2"><div class="info-item-1"> HTTPS (Hypertext Transfer Protocol Secure)，即超文本传输安全协议，是在 HTTP 协议的基础上，通过添加 SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security) 协议层来提供安全性的网络协议。它确保了客户端（通常是浏览器）和服务器之间的数据传输加密、完整且经过认证，从而保护用户的隐私和数据的安全。  核心思想：在不安全的互联网上，为 HTTP 通信提供加密、身份认证和数据完整性保护，使得网站能够安全可靠地传输信息。   一、为什么需要 HTTPS？传统的 HTTP 协议是一种明文传输协议，其数据的传输是透明的，没有任何加密。这导致了多重重要的安全隐患：  数据窃听 (Eavesdropping &#x2F; Sniffing)：  任何网络中间节点（如 Wi-Fi 热点、路由器、ISP）都可以截获并读取用户与网站之间传输的所有数据，包括敏感信息如用户名、密码、银行卡号、邮件内容等。 例如，您在一个非 HTTPS 网站登录，您的用户名和密码在网络中就是明文传输，攻...</div></div></div></a><a class="pagination-related" href="/6a2e612aab63/" title="Java 常用关键字详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java 常用关键字详解</div></div><div class="info-2"><div class="info-item-1"> Java 关键字 (Keywords) 是 Java 语言中被赋予特殊含义的、预定义的、保留的标识符。它们不能用作变量名、类名、方法名或其他用户自定义的标识符。理解和正确使用这些关键字是编写有效 Java 代码的基础。本文将详细介绍 Java 中最常用的关键字及其功能。  核心思想：关键字是 Java 编译器识别和理解代码结构及行为的“命令词”。    一、基本概念Java 关键字在语言语法中扮演着核心角色，它们指示编译器如何解释和处理代码的特定部分。所有 Java 关键字都是小写字母。 二、数据类型关键字这些关键字用于声明变量的数据类型。  boolean：表示布尔类型，只有 true 和 false 两个值。1boolean isActive = true; byte：表示 8 位带符号整数，范围 -128 到 127。1byte level = 10; short：表示 16 位带符号整数，范围 -32768 到 32767。1short count = 1000; int：表示 32 位带符号整数，最常用的整数类型。1int score = 100000; long：表...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/425bf08190fa/" title="TLS Encrypted Client Hello (ECH) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="info-item-2">TLS Encrypted Client Hello (ECH) 详解</div></div><div class="info-2"><div class="info-item-1"> TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。  核心思想：在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。   一、为什么需要 ECH？SNI 的隐私痛点在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：明文 SNI (Server Name Indication)。 1.1 SNI 的作用SNI 是 TLS 协议的一个扩展，用于解决虚拟主机 (Virtual Hosting) 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 example.com 和 another.c...</div></div></div></a><a class="pagination-related" href="/8fad93ea4f62/" title="ALPN (Application-Layer Protocol Negotiation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="info-item-2">ALPN (Application-Layer Protocol Negotiation) 详解</div></div><div class="info-2"><div class="info-item-1"> ALPN (Application-Layer Protocol Negotiation)，即应用层协议协商，是 TLS (传输层安全) 协议的一个扩展，允许客户端和服务器在进行 TLS 握手时，协商决定在加密连接上使用哪个应用层协议。它在 RFC 7301 中被定义。ALPN 的出现，极大地简化了现代网络协议的部署和使用，尤其是对于 HTTP&#x2F;2 和未来的 QUIC 等协议。  核心思想：ALPN 将应用层协议的选择过程集成到 TLS 握手阶段，使得在建立加密连接的同时，也完成了应用层协议的确定，避免了额外的往返延迟，并允许在同一端口上运行多种应用层协议。   一、为什么需要 ALPN？在 ALPN 出现之前，协商应用层协议通常面临以下挑战：  端口绑定：传统的做法是为不同的应用层协议使用不同的端口。例如，HTTP 使用 80 端口，HTTPS 使用 443 端口，FTP 使用 21 端口。当引入新的协议（如 HTTP&#x2F;2 或 SPDY）时，如果想与现有协议共存，就必须使用新的端口，这会增加防火墙配置、负载均衡设置的复杂性，并且用户可能需要记住非标准的端口...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/18f2ce1e9660/" title="DNS (Domain Name System) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="info-item-2">DNS (Domain Name System) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS (Domain Name System) 是互联网的一项核心服务，它将人类可读的域名（如 www.example.com）转换为机器可读的 IP 地址（如 192.168.1.1 或 2001:0db8::1）。这种翻译功能使得用户可以方便地通过记忆友好的域名来访问网站和其他网络资源，而无需记住复杂的数字 IP 地址。DNS 本质上是一个分布式数据库系统，运行在应用层，通常使用 UDP 的 53 端口进行查询，TCP 53 端口用于区域传输 (zone transfer)。  核心思想：将域名映射到 IP 地址，提供一套全球性的、分层的、分布式数据库系统，从而实现互联网资源的定位和访问。   一、为什么需要 DNS？在互联网的早期，少量的计算机通过一个名为 HOSTS.TXT 的静态文件来完成主机名到 IP 地址的映射。然而，随着计算机数量的爆发式增长，这种中心化的、静态的管理方式变得不可行，主要原因如下：  人类记忆限制：用户难以记住大量复杂且不断变化的 IP 地址。 管理困难：集中式文件更新和同步的效率低下，无法适应全球范围内的网络变化。 扩展性差：集中式系统无法承...</div></div></div></a><a class="pagination-related" href="/a8d205bac226/" title="HTTP&#x2F;2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="info-item-2">HTTP&#x2F;2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">507</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TLS%EF%BC%9F"><span class="toc-text">一、为什么需要 TLS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TLS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-text">二、TLS 的工作原理概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TLS-%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、TLS 握手协议详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81TLS-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7"><span class="toc-text">四、TLS 的核心安全特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81TLS-%E7%89%88%E6%9C%AC%E4%B8%8E%E6%BC%94%E8%BF%9B"><span class="toc-text">五、TLS 版本与演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81TLS-%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9AHTTPS"><span class="toc-text">六、TLS 的应用：HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-18.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>