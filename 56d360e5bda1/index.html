<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SNAT 与 DNAT 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NAT (Network Address Translation，网络地址转换) 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：源网络地址转换 (SNAT - Source Network Address Translation) 和 目的网络地址转换 (DNAT -">
<meta property="og:type" content="article">
<meta property="og:title" content="SNAT 与 DNAT 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/56d360e5bda1/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="NAT (Network Address Translation，网络地址转换) 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：源网络地址转换 (SNAT - Source Network Address Translation) 和 目的网络地址转换 (DNAT -">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg">
<meta property="article:published_time" content="2024-10-22T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-06T10:03:38.387Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SNAT 与 DNAT 详解",
  "url": "https://blog.tbf1211.xx.kg/56d360e5bda1/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg",
  "datePublished": "2024-10-22T22:24:00.000Z",
  "dateModified": "2026-01-06T10:03:38.387Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/56d360e5bda1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SNAT 与 DNAT 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">470</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-08.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">SNAT 与 DNAT 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SNAT 与 DNAT 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-10-22T22:24:00.000Z" title="发表于 2024-10-23 06:24:00">2024-10-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>NAT (Network Address Translation，网络地址转换)</strong> 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：<strong>源网络地址转换 (SNAT - Source Network Address Translation)</strong> 和 <strong>目的网络地址转换 (DNAT - Destination Network Address Translation)</strong>。理解这两种机制对于网络设计、故障排查和安全性至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：</p>
<ul>
<li><strong>SNAT</strong>：解决“内部网络中主机如何安全地、共享地<strong>访问外部网络资源</strong>”的问题，修改<strong>出站</strong>数据包的<strong>源地址</strong>。</li>
<li><strong>DNAT</strong>：解决“外部网络中主机如何安全地<strong>访问内部提供的服务</strong>”的问题，修改<strong>入站</strong>数据包的<strong>目的地址</strong>。</li>
</ul>
</div>

<hr>
<h2 id="一、网络地址转换-NAT-概述"><a href="#一、网络地址转换-NAT-概述" class="headerlink" title="一、网络地址转换 (NAT) 概述"></a>一、网络地址转换 (NAT) 概述</h2><p>NAT 技术最初是为了缓解 IPv4 地址枯竭问题而设计，它允许一个内部私有 IP 网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信。除了地址共享，NAT 也为内部网络提供了一层基本的安全隔离，隐藏了内部网络的拓扑结构。</p>
<p>IP 数据包在通过 NAT 设备时，其头部信息中的 IP 地址和&#x2F;或端口号会被修改。这个转换过程是双向的，即从内部到外部以及从外部到内部的流量都会受到影响，确保通信的正常进行。</p>
<h2 id="二、SNAT-Source-Network-Address-Translation-详解"><a href="#二、SNAT-Source-Network-Address-Translation-详解" class="headerlink" title="二、SNAT (Source Network Address Translation) 详解"></a>二、SNAT (Source Network Address Translation) 详解</h2><h3 id="2-1-定义与原理"><a href="#2-1-定义与原理" class="headerlink" title="2.1 定义与原理"></a>2.1 定义与原理</h3><p><strong>SNAT (Source Network Address Translation)，源网络地址转换</strong>，顾名思义，是针对 IP 数据包的<strong>源地址</strong>进行修改的一种 NAT 形式。它通常用于：</p>
<ol>
<li>当内部私有网络中的主机需要访问外部公共网络（如互联网）时，将数据包的<strong>私有源 IP 地址</strong>转换为 NAT 设备上的<strong>公共 IP 地址</strong>。</li>
<li>（可选）同时，如果多个内部主机共享同一个公共 IP 地址（即 <strong>PAT&#x2F;NAPT - Port Address Translation&#x2F;Network Address Port Translation</strong>），SNAT 还会修改数据包的<strong>源端口号</strong>，以区分不同的内部会话。这是目前最常见的 SNAT 形式，也被称为“NAT Overload”。</li>
</ol>
<p><strong>工作原理：</strong></p>
<p>当一个内部主机发起对外部网络的请求数据包，并经过边界设备（如路由器、防火墙）时：</p>
<ol>
<li><strong>出站方向</strong>：<ul>
<li>边界设备截获数据包，检查其源 IP 地址（内部私有 IP）。</li>
<li>根据 SNAT 规则，设备将数据包的<strong>源 IP 地址</strong>修改为自己拥有的<strong>公共 IP 地址</strong>。</li>
<li>如果配置为 PAT，且此公共 IP 已经有其他内部主机占用，NAT 设备还会修改数据包的<strong>源端口号</strong>（选择一个未被占用的高位端口），以确保唯一性。</li>
<li>NAT 设备在其内部的连接表中记录下：<code>(内部源IP:内部源端口) &lt;-&gt; (公共IP:NAT分配端口)</code> 的映射关系。</li>
<li>修改后的数据包被发送到外部网络。</li>
</ul>
</li>
<li><strong>入站方向（响应）</strong>：<ul>
<li>当外部服务器响应此请求时，其目的 IP 地址是 NAT 设备分配的公共 IP 和端口。</li>
<li>NAT 设备收到响应后，会查找其连接表，根据目的 IP 和端口将数据包的<strong>目的地址和端口</strong>反向转换为内部主机的<strong>私有 IP 和原始端口</strong>。</li>
<li>然后将数据包转发给内部主机。</li>
</ul>
</li>
</ol>
<p><strong>SNAT 过程示意图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph Internet
        ExternalServer(外部服务器: 8.8.8.8:80)
    end
    subgraph Router_Firewall [边界路由器&#x2F;防火墙]
        PublicIP(公网接口IP: 203.0.113.1)
        NATTable_1(SNAT&#x2F;PAT 连接表)
    end
    subgraph Internal_Network
        InternalHost(内部主机: 192.168.1.10:12345)
    end

    InternalHost -- &quot;1. 原始请求&lt;br&gt;(源: 192.168.1.10:12345,&lt;br&gt;目的: 8.8.8.8:80)&quot; --&gt; Router_Firewall
    Router_Firewall -- &quot;2. SNAT 转换&lt;br&gt;(修改源 IP 和端口)&lt;br&gt;并记录映射: 192.168.1.10:12345 -&gt; 203.0.113.1:20001&quot; --&gt; ExternalServer
  
    ExternalServer -- &quot;3. 外部响应&lt;br&gt;(源: 8.8.8.8:80,&lt;br&gt;目的: 203.0.113.1:20001)&quot; --&gt; Router_Firewall
    Router_Firewall -- &quot;4. SNAT 反向转换&lt;br&gt;(根据映射恢复目的 IP 和端口)&lt;br&gt;目的: 192.168.1.10:12345&quot; --&gt; InternalHost
  </pre></div>

<h3 id="2-2-常见的-SNAT-应用场景"><a href="#2-2-常见的-SNAT-应用场景" class="headerlink" title="2.2 常见的 SNAT 应用场景"></a>2.2 常见的 SNAT 应用场景</h3><ol>
<li><strong>家庭&#x2F;企业内部网络访问互联网</strong>：这是最常见的应用。家里或公司内所有设备（如电脑、手机）通过一个路由器上的公共 IP 地址访问互联网。路由器扮演了 SNAT 的角色。</li>
<li><strong>云计算环境中的私有网络到公共网络访问</strong>：VMware、VirtualBox 等虚拟化平台，或公有云服务（如 AWS VPC、Azure VNet）中的私有子网中的虚拟机，通过安全组和路由策略，利用网关进行 SNAT 访问外部。</li>
<li><strong>负载均衡器后的后端服务器对外访问</strong>：当请求经过负载均衡器到达后端服务器后，后端服务器响应时可能需要进行 SNAT，以确保响应数据包的源 IP 是负载均衡器的 IP，而不是后端服务器的私有 IP。这能避免直接将内部拓扑暴露给客户端，也能确保返回流量经过负载均衡器（尤其是“回源模式”的负载均衡）。</li>
<li><strong>防火墙策略</strong>：SNAT 通常与防火墙策略结合，控制内部网络与外部网络的通信权限，并通过隐藏内部 IP 提高安全性。</li>
</ol>
<h3 id="2-3-配置示例-Linux-iptables"><a href="#2-3-配置示例-Linux-iptables" class="headerlink" title="2.3 配置示例 (Linux iptables)"></a>2.3 配置示例 (Linux iptables)</h3><p>在 Linux 系统中，<code>iptables</code> 工具是配置 NAT 规则的核心。SNAT 规则在 <code>nat</code> 表的 <code>POSTROUTING</code> 链中实现，通常用于修改<strong>出站</strong>数据包的源地址。</p>
<p><strong>场景</strong>：</p>
<ul>
<li>内部网络：<code>192.168.1.0/24</code></li>
<li>边界设备（Linux 服务器作为路由器）的外网接口：<code>eth0</code></li>
<li>边界设备（Linux 服务器作为路由器）的公网 IP：<code>203.0.113.1</code></li>
<li>边界设备（Linux 服务器作为路由器）的内网接口：<code>eth1</code></li>
</ul>
<p><strong>目标</strong>：将所有来自 <code>192.168.1.0/24</code> 内部网络的出站请求的源 IP 转换为 <code>203.0.113.1</code>。</p>
<p><strong><code>iptables</code> 命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 允许内核进行 IP 转发 (必须启用，否则路由器无法转发数据包)</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 清除旧的 nat 表规则 (生产环境谨慎操作，可能导致网络中断)</span></span><br><span class="line"><span class="comment"># iptables -t nat -F</span></span><br><span class="line"><span class="comment"># iptables -t nat -X</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加 SNAT 规则到 POSTROUTING 链</span></span><br><span class="line"><span class="comment">#    -t nat: 指定 nat 表</span></span><br><span class="line"><span class="comment">#    -A POSTROUTING: 添加到 POSTROUTING 链的末尾 (在路由决策之后执行)</span></span><br><span class="line"><span class="comment">#    -s 192.168.1.0/24: 匹配源 IP 地址范围为 192.168.1.0/24 (内部网络主机)</span></span><br><span class="line"><span class="comment">#    -o eth0: 匹配出站接口为 eth0 (数据包将从这个接口发送到外部网络)</span></span><br><span class="line"><span class="comment">#    -j SNAT: 跳转到 SNAT 动作</span></span><br><span class="line"><span class="comment">#    --to-source 203.0.113.1: 将数据包的源 IP 地址修改为 203.0.113.1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to-source 203.0.113.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者，如果公网 IP 是动态变化的 (如家庭拨号上网)，可以使用 MASQUERADE</span></span><br><span class="line"><span class="comment"># MASQUERADE 会自动获取 eth0 接口当前的 IP 地址进行转换，更灵活。</span></span><br><span class="line"><span class="comment"># sudo iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 配置 FORWARD 链以允许流量转发 (filter 表规则，非常重要)</span></span><br><span class="line"><span class="comment"># 默认情况下，INPUT、OUTPUT 和 FORWARD 链的策略可能是 DROP，需要显式允许。</span></span><br><span class="line"><span class="comment"># 允许已建立和相关联的连接通过 (对于返回的响应流量)</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"><span class="comment"># 允许从内部网络 (eth1) 到外部网络 (eth0) 发起的新连接</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -i eth1 -o eth0 -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 保存 iptables 规则 (确保规则在重启后依然有效)</span></span><br><span class="line"><span class="comment"># 不同 Linux 发行版保存方式不同：</span></span><br><span class="line"><span class="comment"># CentOS/RHEL (旧版本): sudo service iptables save 或 sudo sh -c &quot;iptables-save &gt; /etc/sysconfig/iptables&quot;</span></span><br><span class="line"><span class="comment"># Ubuntu/Debian: sudo apt-get install iptables-persistent &amp;&amp; sudo netfilter-persistent save</span></span><br><span class="line"><span class="comment"># Systemd (现代Linux): sudo iptables-save &gt; /etc/iptables/rules.v4 (或相应路径，需要安装 iptables-persistent)</span></span><br></pre></td></tr></table></figure>

<h2 id="三、DNAT-Destination-Network-Address-Translation-详解"><a href="#三、DNAT-Destination-Network-Address-Translation-详解" class="headerlink" title="三、DNAT (Destination Network Address Translation) 详解"></a>三、DNAT (Destination Network Address Translation) 详解</h2><h3 id="3-1-定义与原理"><a href="#3-1-定义与原理" class="headerlink" title="3.1 定义与原理"></a>3.1 定义与原理</h3><p><strong>DNAT (Destination Network Address Translation)，目的网络地址转换</strong>，顾名思义，是针对 IP 数据包的<strong>目的地址</strong>进行修改的一种 NAT 形式。它通常用于：</p>
<ol>
<li>将外部对 NAT 设备上<strong>公共 IP 地址和端口</strong>的请求，透明地转发到内部私有网络中的特定服务器的<strong>私有 IP 地址和端口</strong>。</li>
<li>这个过程对于外部客户端是透明的，客户端看到的始终是公共 IP 地址和端口。<strong>端口转发 (Port Forwarding)</strong> 是 DNAT 的一个特殊且非常常见的应用。</li>
</ol>
<p><strong>工作原理：</strong></p>
<p>当一个来自外部网络的请求数据包到达边界设备（如路由器、防火墙）时：</p>
<ol>
<li><strong>入站方向</strong>：<ul>
<li>边界设备截获数据包，检查其目的 IP 地址（公共 IP 地址）和目的端口。</li>
<li>如果该数据包的目的 IP 地址和端口符合预设的 DNAT 规则，边界设备会查找其内部的 DNAT 映射表。</li>
<li>根据 DNAT 规则，设备将数据包的<strong>目的 IP 地址</strong>修改为内部服务器的<strong>私有 IP 地址</strong>。</li>
<li>（可选）同时，设备也可能修改数据包的<strong>目的端口</strong>为内部服务器的<strong>真实端口</strong>（例如，外部访问 8080，内部实际是 80）。</li>
<li>NAT 设备在其内部的连接表中记录下：<code>(公共IP:公共端口) -&gt; (内部IP:内部端口)</code> 以及客户端的源地址信息。</li>
<li>修改后的数据包被发送到内部网络，到达目标私有服务器。</li>
</ul>
</li>
<li><strong>出站方向（响应）</strong>：<ul>
<li>当内部服务器响应外部请求时，其源 IP 是内部私有 IP，目的 IP 是外部客户端 IP。</li>
<li>这个响应数据包流经边界设备时，通常会自动进行 SNAT (源地址转换)。NAT 设备会根据之前建立的连接映射关系，将数据包的<strong>源 IP 和端口</strong>反向转换为边界设备的<strong>公共 IP 和端口</strong>（即外部客户端最初请求的那个 PublicIP:DestPort）。</li>
<li>然后将数据包发送回外部客户端。</li>
</ul>
</li>
</ol>
<p><strong>DNAT 过程示意图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph Internet
        ExternalClient(外部客户端: 1.1.1.1:50000)
    end
    subgraph Router_Firewall [边界防火墙&#x2F;路由器]
        PublicIP(公网接口IP: 203.0.113.1:80)
        NATTable_2(DNAT&#x2F;SNAT 连接表)
    end
    subgraph Internal_Network
        InternalWebServer(内部Web服务器: 192.168.1.100:80)
    end

    ExternalClient -- &quot;1. 原始请求&lt;br&gt;(源: 1.1.1.1:50000,&lt;br&gt;目的: 203.0.113.1:80)&quot; --&gt; Router_Firewall
    Router_Firewall -- &quot;2. DNAT 转换&lt;br&gt;(修改目的 IP 和端口)&lt;br&gt;记录映射: 203.0.113.1:80 -&gt; 192.168.1.100:80&quot; --&gt; InternalWebServer
  
    InternalWebServer -- &quot;3. 内部响应&lt;br&gt;(源: 192.168.1.100:80,&lt;br&gt;目的: 1.1.1.1:50000)&quot; --&gt; Router_Firewall
    Router_Firewall -- &quot;4. SNAT 反向转换&lt;br&gt;(根据映射恢复源 IP 和端口)&lt;br&gt;源: 203.0.113.1:80&quot; --&gt; ExternalClient
  </pre></div>

<h3 id="3-2-常见的-DNAT-应用场景"><a href="#3-2-常见的-DNAT-应用场景" class="headerlink" title="3.2 常见的 DNAT 应用场景"></a>3.2 常见的 DNAT 应用场景</h3><ol>
<li><strong>发布内部 Web 服务器&#x2F;FTP 服务器等</strong>：最常见的应用是，将互联网对公共 IP 地址的 80&#x2F;443 端口请求，转发到内部 Web 服务器的私有 IP 地址。</li>
<li><strong>端口转发 (Port Forwarding)</strong>：将外部对公共 IP 的某个特定端口请求（如 <code>Public_IP:8080</code>），转发到内部服务器的相同或不同端口（如 <code>192.168.1.100:80</code>）。这也常用于将多个服务映射到同一个公共 IP 的不同端口。</li>
<li><strong>远程桌面&#x2F;SSH 访问内部主机</strong>：将外部对公共 IP 的某个特定端口（如 <code>Public_IP:33890</code>）的请求，转发到内部某台 PC 的私有 IP 的 3389 端口（远程桌面）。</li>
<li><strong>负载均衡器前的 VIP (Virtual IP)</strong>：负载均衡器通常会使用 DNAT 将流向其虚拟 IP (VIP) 的流量分发到后端真实的服务器 IP 地址上。</li>
</ol>
<h3 id="3-3-配置示例-Linux-iptables"><a href="#3-3-配置示例-Linux-iptables" class="headerlink" title="3.3 配置示例 (Linux iptables)"></a>3.3 配置示例 (Linux iptables)</h3><p>DNAT 规则在 <code>nat</code> 表的 <code>PREROUTING</code> 链中实现，通常用于修改<strong>入站</strong>数据包的目的地址。</p>
<p><strong>场景</strong>：</p>
<ul>
<li>公网 IP (边界设备外网接口 IP)：<code>203.0.113.1</code></li>
<li>内部 Web 服务器私有 IP：<code>192.168.1.100</code></li>
</ul>
<p><strong>目标</strong>：将所有访问 <code>203.0.113.1:80</code> 的外部请求转发到 <code>192.168.1.100:80</code>。</p>
<p><strong><code>iptables</code> 命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 允许内核进行 IP 转发 (必须启用)</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 清除旧的 nat 表规则 (生产环境谨慎操作)</span></span><br><span class="line"><span class="comment"># sudo iptables -t nat -F</span></span><br><span class="line"><span class="comment"># sudo iptables -t nat -X</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加 DNAT 规则到 PREROUTING 链</span></span><br><span class="line"><span class="comment">#    -t nat: 指定 nat 表</span></span><br><span class="line"><span class="comment">#    -A PREROUTING: 添加到 PREROUTING 链的末尾 (在路由决策之前执行)</span></span><br><span class="line"><span class="comment">#    -p tcp: 匹配 TCP 协议</span></span><br><span class="line"><span class="comment">#    --dport 80: 匹配目的端口为 80 (即外部客户端请求的端口)</span></span><br><span class="line"><span class="comment">#    -d 203.0.113.1: 匹配目的 IP 为边界设备的公网 IP</span></span><br><span class="line"><span class="comment">#    -j DNAT: 跳转到 DNAT 动作</span></span><br><span class="line"><span class="comment">#    --to-destination 192.168.1.100:80: 将数据包的目的 IP 修改为 192.168.1.100，目的端口修改为 80 (如果InternalWebServer端口不同，这里也应指定)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -A PREROUTING -p tcp --dport 80 -d 203.0.113.1 -j DNAT --to-destination 192.168.1.100:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 配置 FORWARD 链以允许流量转发 (filter 表规则，非常重要)</span></span><br><span class="line"><span class="comment"># DNAT 发生在 PREROUTING 链，在路由判断之前，数据包的目的 IP 已经被修改为内部 IP。</span></span><br><span class="line"><span class="comment"># 此时，需要 FORWARD 链允许流量从外网接口 (eth0) 到内网接口 (eth1) 进入内部网络。</span></span><br><span class="line"><span class="comment"># 允许从 eth0 流入、eth1 流出、目的地址为 192.168.1.100 的 TCP 80 端口流量通过</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -i eth0 -o eth1 -p tcp --dport 80 -d 192.168.1.100 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许已建立和相关联的连接通过 (对于服务器响应回外部客户端的流量)</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 通常，当内部服务器响应外部客户端时，数据包的源 IP 仍是其私有 IP (192.168.1.100)。</span></span><br><span class="line"><span class="comment">#    为了让外部客户端能正确接收，并且响应能对称地通过NAT设备返回，</span></span><br><span class="line"><span class="comment">#    响应流量还需要进行 SNAT，将其源 IP 转换为外部客户端最初连接的公共 IP (203.0.113.1)。</span></span><br><span class="line"><span class="comment">#    在很多情况下，iptables 的 conntrack 模块会自动处理这个响应的 SNAT。</span></span><br><span class="line"><span class="comment">#    但在某些复杂网络配置或多层 NAT 环境中，可能需要显式配置。</span></span><br><span class="line"><span class="comment">#    例如，如果内部服务器的默认网关不是 NAT 设备，或者响应流量经由其他路径返回，</span></span><br><span class="line"><span class="comment">#    则可能需要确保出站接口的 SNAT 规则捕获这些响应包。</span></span><br><span class="line"><span class="comment">#    假设 eth0 是外网网卡接口，eth1 是内网网卡接口。</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -A POSTROUTING -s 192.168.1.100 -o eth0 -j SNAT --to-source 203.0.113.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 保存 iptables 规则</span></span><br></pre></td></tr></table></figure>

<h2 id="四、SNAT-与-DNAT-的比较与互补性"><a href="#四、SNAT-与-DNAT-的比较与互补性" class="headerlink" title="四、SNAT 与 DNAT 的比较与互补性"></a>四、SNAT 与 DNAT 的比较与互补性</h2><h3 id="4-1-关键区别"><a href="#4-1-关键区别" class="headerlink" title="4.1 关键区别"></a>4.1 关键区别</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">SNAT (源网络地址转换)</th>
<th align="left">DNAT (目的网络地址转换)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>修改对象</strong></td>
<td align="left">数据包的<strong>源 IP 地址和&#x2F;或源端口</strong>。</td>
<td align="left">数据包的<strong>目的 IP 地址和&#x2F;或目的端口</strong>。</td>
</tr>
<tr>
<td align="left"><strong>流量方向</strong></td>
<td align="left">发生在<strong>出站</strong>数据包 (从内部到外部)。</td>
<td align="left">发生在<strong>入站</strong>数据包 (从外部到内部)。</td>
</tr>
<tr>
<td align="left"><strong>应用目的</strong></td>
<td align="left">允许内部私有 IP 主机共享公共 IP 访问外部网络。</td>
<td align="left">将外部请求重定向到内部私有 IP 服务。</td>
</tr>
<tr>
<td align="left"><strong>常见场景</strong></td>
<td align="left">内部 PC 访问互联网，私有服务器通过公网 IP 访问第三方 API。</td>
<td align="left">外部用户访问内部 Web&#x2F;FTP 服务器，端口转发。</td>
</tr>
<tr>
<td align="left"><strong>安全性影响</strong></td>
<td align="left">隐藏内部网络拓扑，提供基础安全屏障，外部无法直接探测内部主机。</td>
<td align="left">将内部服务暴露到外部，需结合防火墙严格控制访问策略。</td>
</tr>
<tr>
<td align="left"><strong>iptables 链</strong></td>
<td align="left"><code>nat</code> 表的 <code>POSTROUTING</code> 链。</td>
<td align="left"><code>nat</code> 表的 <code>PREROUTING</code> 链。</td>
</tr>
<tr>
<td align="left"><strong>透明性</strong></td>
<td align="left">外部看到的是 NAT 设备作为源，不知道内部真实发送者。</td>
<td align="left">外部看到的是 NAT 设备作为目的，不知道内部真实服务者。</td>
</tr>
</tbody></table>
<h3 id="4-2-完整通信流程中的作用"><a href="#4-2-完整通信流程中的作用" class="headerlink" title="4.2 完整通信流程中的作用"></a>4.2 完整通信流程中的作用</h3><p>在一个典型的客户端-服务器通信流程中，SNAT 和 DNAT 往往是协同工作的，它们共同确保了会话在私有和公共 IP 空间之间的正确映射和转发：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant ExtClient as 外部客户端 (1.1.1.1:50000)
    participant FirewallRouter as 边界防火墙&#x2F;路由器 (公共IP: 203.0.113.1)
    participant InternalServer as 内部服务器 (192.168.1.100:80)

    note over ExtClient, InternalServer: 外部客户端访问内部服务器的服务 (例如网站)

    ExtClient-&gt;&gt;FirewallRouter: 1. 外部请求&lt;br&gt; (源: 1.1.1.1:50000,&lt;br&gt;目的: 203.0.113.1:80)
    activate FirewallRouter
    FirewallRouter-&gt;&gt;FirewallRouter: 2. **DNAT 转换**：依据规则&lt;br&gt;修改**目的IP和端口**为 192.168.1.100:80&lt;br&gt;并记录此映射
    FirewallRouter-&gt;&gt;InternalServer: 3. **转发至内部服务器**&lt;br&gt; (源: 1.1.1.1:50000,&lt;br&gt;目的: 192.168.1.100:80)
    deactivate FirewallRouter

    InternalServer-&gt;&gt;InternalServer: 4. 内部服务器处理请求并生成响应

    InternalServer-&gt;&gt;FirewallRouter: 5. 内部响应&lt;br&gt; (源: 192.168.1.100:80,&lt;br&gt;目的: 1.1.1.1:50000)
    activate FirewallRouter
    FirewallRouter-&gt;&gt;FirewallRouter: 6. **SNAT 转换**：依据之前记录的会话&lt;br&gt;修改**源IP和端口**为 203.0.113.1:80&lt;br&gt;(或动态分配的端口)
    FirewallRouter-&gt;&gt;ExtClient: 7. **转发至外部客户端**&lt;br&gt; (源: 203.0.113.1:80,&lt;br&gt;目的: 1.1.1.1:50000)
    deactivate FirewallRouter
  </pre></div>

<p>这个流程展示了 DNAT 处理入站的请求，修改目的地址；而 SNAT (通常是 DNAT 规则自动关联的，或手动配置的) 处理出站的响应，修改源地址。两者协同工作，确保响应能够正确返回给外部客户端，并且外部客户端看到的始终是公共 IP 地址。</p>
<h2 id="五、安全性与管理考量"><a href="#五、安全性与管理考量" class="headerlink" title="五、安全性与管理考量"></a>五、安全性与管理考量</h2><ol>
<li><strong>最小权限原则</strong>：<ul>
<li><strong>DNAT</strong>：只对需要外部访问的特定服务开放必要的端口，并可限制允许访问的源 IP 地址范围。避免将所有端口直接转发，增加攻击面。</li>
<li><strong>SNAT (PAT)</strong>：虽然通过隐藏内部 IP 提供了一层安全性，但仍需结合防火墙规则限制内部主机对外访问的类型和目的地（例如，禁止访问恶意网站）。</li>
</ul>
</li>
<li><strong>HTTPS&#x2F;SSL</strong>：所有涉及敏感数据的外部访问都<strong>必须</strong>通过 HTTPS 进行加密，保护数据在传输中的安全，即使 NAT 设备也无法看到明文内容。</li>
<li><strong>日志记录与审计</strong>：启用 NAT 设备的连接日志功能，记录所有地址转换的会话信息。这对于安全审计、故障排查和入侵检测至关重要。</li>
<li><strong>服务强化</strong>：被 DNAT 到内部的服务器必须进行严格的安全加固，确保其操作系统和应用程序没有已知漏洞，并定期更新补丁。</li>
<li><strong>高可用性</strong>：NAT 设备是内部网络对外通信和对外提供服务的关键单点，应考虑采用高可用性方案（如 VRRP、HSRP），防止设备故障导致服务中断。</li>
<li><strong>复杂性管理</strong>：过多的 DNAT 规则和复杂的 NAT 链会增加网络配置的复杂性和管理难度，增加出错的风险。对于复杂的服务发布需求，可以考虑使用反向代理（如 Nginx、HAProxy）作为 DNAT 的补充或替代，提供更灵活的路由、负载均衡和安全特性。</li>
<li><strong>ALG (Application Layer Gateway)</strong>：一些应用层协议（如 FTP、SIP）在数据包载荷中包含 IP 地址或端口信息。NAT 穿透这些协议需要 ALG 的支持，否则可能导致通信中断。现代路由器和防火墙通常默认支持常见的 ALG。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>SNAT 和 DNAT 是 NAT 技术的两个核心组成部分，各自扮演着不同的角色，但又在实践中紧密结合，共同支撑着 IPv4 网络的互联互通。SNAT 允许内部网络共享公共 IP 地址访问外部资源并提供了基础的安全防护；而 DNAT 则使得内部服务能够透明地被外部网络访问。</p>
<p>尽管它们在 IPv4 时代解决了地址枯竭和网络隔离的许多问题，但也引入了端到端连接的复杂性。随着 IPv6 的逐步普及，地址短缺问题得到解决，NAT 的重要性将逐渐降低，网络将更多地回归到端到端连接的简单与透明。然而，在可预见的未来，SNAT 和 DNAT 仍将是现有 IPv4 网络环境中不可或缺的关键技术。正确理解和配置 SNAT 与 DNAT，是构建健壮、安全网络基础设施的基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/56d360e5bda1/">https://blog.tbf1211.xx.kg/56d360e5bda1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-08.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/a8310012f32b/" title="Git 从开发测试到上线的流程详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git 从开发测试到上线的流程详解</div></div><div class="info-2"><div class="info-item-1"> Git 作为一个分布式版本控制系统，在现代软件开发中扮演着核心角色。它不仅能追踪代码变更、协调团队协作，还能支撑复杂的开发、测试到上线的全流程管理。本文将详细阐述基于 Git 的标准开发、测试到上线流程，旨在提供一个清晰、可操作的实践指南。  核心思想：利用 Git 的分支管理能力，清晰地划分开发阶段，确保代码质量，并实现高效、可追溯的部署。   一、Git 分支模型选择在开始流程之前，选择一个合适的分支模型至关重要。常见的分支模型包括 Git Flow 和 GitHub Flow (或 GitLab Flow)。 1.1 Git FlowGit Flow 是一种较为复杂的、结构化的分支模型，适用于发布周期较长、版本发布严格的项目。它定义了五种主要分支：  main (或 master) 分支：用于存放生产环境稳定代码。只有当代码准备好发布时，才合并到此分支。每次合并到 main 都应该打上版本标签。 develop 分支：用于存放最新开发完成的代码，是所有功能开发分支的集成点。 feature 分支：用于开发新功能。通常从 develop 分支创建，完成功能开发后合并回 de...</div></div></div></a><a class="pagination-related" href="/181b03349cc9/" title="Dockge介绍与部署：下一代 Docker Compose UI"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Dockge介绍与部署：下一代 Docker Compose UI</div></div><div class="info-2"><div class="info-item-1"> Dockge 是一个现代化、用户友好的 Docker Compose 管理 Web UI，旨在简化 Docker Compose 栈的部署、管理和监控。它提供了一个直观的图形界面，让用户能够通过浏览器轻松地创建、编辑、部署、启动、停止和监控他们的 docker-compose.yml 文件所定义的容器服务。Dockge 特别适用于需要方便地管理多个 Compose 栈，或不习惯命令行操作的场景。  核心思想：将 Docker Compose 的命令行操作图形化，提供实时反馈和集中管理能力。    一、为什么需要 Dockge？Docker Compose 是管理多容器 Docker 应用程序的强大工具，但其操作主要依赖命令行。对于不熟悉 CLI 的用户，或需要同时管理大量 Compose 栈的场景，命令行操作可能显得繁琐且效率低下。Dockge 旨在解决这些痛点：  图形化操作：提供直观的 Web 界面，替代复杂的命令行输入。 实时日志与状态：方便用户查看容器的实时日志和运行状态。 集中管理：在一个界面中管理所有 docker-compose.yml 文件定义的栈。 文件编辑：...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/da4a047de713/" title="中国电信 CN2 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="info-item-2">中国电信 CN2 网络详解</div></div><div class="info-2"><div class="info-item-1"> CN2 (ChinaNet Next Generation Carrying Network)，即中国电信下一代承载网络，是中国电信于 2005 年推出的新一代骨干网络。它旨在提供高质量、高可靠、低延迟的网络服务，主要面向政府、企业和高端个人用户。CN2 与传统的 ChinaNet (AS4134，163骨干网) 在架构和技术上都有显著区别，以提供更优质的国际互联体验。  核心思想：将互联网流量分为“优质”和“普通”两类通道，CN2 提供优质通道，通过更少的跳数、更小的丢包率和更低的延迟，显著提升国际互联的稳定性和速度。   一、为什么需要 CN2？1.1 ChinaNet (163骨干网) 的局限性传统的中国电信互联网骨干网，通常被称为 163 网（因其 AS 号为 4134，而 163 是其常用接入号），是国内用户最广泛使用的网络。然而，163 网在国际互联方面存在一些固有的问题：  链路拥堵：作为最常用的骨干网，163 网承载了大量流量，尤其在国际出口处容易出现拥堵，导致延迟高、丢包率大。 路由跳数多：在国际互联时，163 网的路由路径通常较长，经过的中间节点和运营商较多...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a><a class="pagination-related" href="/19a6c2b992d7/" title="IPv6 (Internet Protocol Version 6) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">IPv6 (Internet Protocol Version 6) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv6 (Internet Protocol Version 6) 是互联网协议 (IP) 的最新版本，旨在取代其前身 IPv4。它解决了 IPv4 长期存在的地址枯竭问题，并引入了多项设计改进，以更好地适应现代互联网的需求，包括支持更简单的头部处理、增强的安全性、更好的服务质量 (QoS) 和更强大的移动性功能。  核心思想：从根本上解决 IPv4 地址短缺问题，同时优化协议设计，为万物互联 (IoT)、5G 和未来网络应用提供坚实基础。    一、为什么需要 IPv6？IPv4 (Internet Protocol Version 4) 作为互联网的核心协议已成功运行数十年，但随着互联网的爆炸式增长，其固有的设计局限性日益凸显：  地址枯竭 (Address Exhaustion)：IPv4 地址空间为 32 位，最多有约 43 亿个地址。尽管采取了无类别域间路由 (CIDR) 和网络地址转换 (NAT) 等技术来延缓地址枯竭，但根源问题并未解决。全球各区域的 IPv4 地址池已基本分配完毕，成为互联网进一步发展的瓶颈。 NAT 的复杂性与限制：网络地址转换 (NAT) ...</div></div></div></a><a class="pagination-related" href="/c70453d6b6cb/" title="CIDR和子网掩码详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="info-item-2">CIDR和子网掩码详解</div></div><div class="info-2"><div class="info-item-1"> CIDR (Classless Inter-Domain Routing，无类别域间路由) 和子网掩码 (Subnet Mask) 是 IP 地址管理和路由技术中的两个核心概念。它们共同解决了传统 IP 地址分类的局限性，实现了更高效的 IP 地址分配和更灵活的网络划分。理解这两个概念对于构建和管理现代 IP 网络至关重要。  核心思想：CIDR 使用“IP 地址&#x2F;前缀长度”的格式，通过前缀长度直接表示网络部分和主机部分，从而废除了传统的 A&#x2F;B&#x2F;C 类地址概念。子网掩码则是这种前缀长度的二进制表示，用于在 IP 地址中区分网络地址和主机地址。   一、IP 地址基础回顾在深入 CIDR 和子网掩码之前，我们先快速回顾一下 IP 地址的基础知识：  IP 地址 (IPv4)：一个 32 位的二进制数字，通常表示为四个十进制数（0-255）由点分隔的形式，例如 192.168.1.1。 网络地址 (Network Address)：用于标识一个 IP 子网，所有在该子网内的主机都共享相同的网络地址。 主机地址 (Host Address)：用于标识子...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">470</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-NAT-%E6%A6%82%E8%BF%B0"><span class="toc-text">一、网络地址转换 (NAT) 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SNAT-Source-Network-Address-Translation-%E8%AF%A6%E8%A7%A3"><span class="toc-text">二、SNAT (Source Network Address Translation) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-text">2.1 定义与原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B8%B8%E8%A7%81%E7%9A%84-SNAT-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.2 常见的 SNAT 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B-Linux-iptables"><span class="toc-text">2.3 配置示例 (Linux iptables)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81DNAT-Destination-Network-Address-Translation-%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、DNAT (Destination Network Address Translation) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-text">3.1 定义与原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B8%B8%E8%A7%81%E7%9A%84-DNAT-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.2 常见的 DNAT 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B-Linux-iptables"><span class="toc-text">3.3 配置示例 (Linux iptables)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SNAT-%E4%B8%8E-DNAT-%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E4%BA%92%E8%A1%A5%E6%80%A7"><span class="toc-text">四、SNAT 与 DNAT 的比较与互补性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-text">4.1 关键区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AE%8C%E6%95%B4%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.2 完整通信流程中的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E7%AE%A1%E7%90%86%E8%80%83%E9%87%8F"><span class="toc-text">五、安全性与管理考量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-08.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>