<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM 详解与调优 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 虚拟机 (JVM - Java Virtual Machine) 是 Java 程序运行的基石，它是一个抽象的计算机器，负责将 Java 字节码 (.class 文件) 翻译成机器指令并执行。JVM 屏蔽了底层操作系统的差异，实现了 Java 的“一次编译，到处运行” (Write Once, Run Anywhere) 的跨平台特性。深入理解 JVM 的架构、内存管理和垃圾回收机制，">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 详解与调优">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/8af9f3feb76a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Java 虚拟机 (JVM - Java Virtual Machine) 是 Java 程序运行的基石，它是一个抽象的计算机器，负责将 Java 字节码 (.class 文件) 翻译成机器指令并执行。JVM 屏蔽了底层操作系统的差异，实现了 Java 的“一次编译，到处运行” (Write Once, Run Anywhere) 的跨平台特性。深入理解 JVM 的架构、内存管理和垃圾回收机制，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg">
<meta property="article:published_time" content="2024-10-28T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-05T09:25:21.070Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="程序设计">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM 详解与调优",
  "url": "https://blog.tbf1211.xx.kg/8af9f3feb76a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg",
  "datePublished": "2024-10-28T22:24:00.000Z",
  "dateModified": "2026-02-05T09:25:21.070Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/8af9f3feb76a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM 详解与调优',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">545</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-32.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM 详解与调优</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JVM 详解与调优</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-10-28T22:24:00.000Z" title="发表于 2024-10-29 06:24:00">2024-10-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Java 虚拟机 (JVM - Java Virtual Machine)</strong> 是 Java 程序运行的基石，它是一个抽象的计算机器，负责将 Java 字节码 (<code>.class</code> 文件) 翻译成机器指令并执行。JVM 屏蔽了底层操作系统的差异，实现了 Java 的“一次编译，到处运行” (Write Once, Run Anywhere) 的跨平台特性。深入理解 JVM 的架构、内存管理和垃圾回收机制，对于编写高性能、稳定可靠的 Java 应用程序至关重要，也是进行系统调优的基础。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>JVM 是 Java 程序的运行时环境，通过管理内存、执行字节码和进行垃圾回收，实现跨平台运行。JVM 调优的核心在于理解内存区域、垃圾回收器行为，并根据应用特性选择合适的参数，以平衡吞吐量、延迟和内存消耗。</strong></p>
</div>

<hr>
<h2 id="一、JVM-架构概述"><a href="#一、JVM-架构概述" class="headerlink" title="一、JVM 架构概述"></a>一、JVM 架构概述</h2><p>JVM 架构主要由以下几个核心组件构成：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[Class Loader Subsystem - &lt;br&gt;类加载子系统] --&gt; B[Runtime Data Areas - &lt;br&gt;运行时数据区]
    B --&gt; C[Execution Engine - 执行引擎]
    C --&gt; D[Native Method Interface - &lt;br&gt;本地方法接口]
    D --&gt; E[Native Method Libraries - &lt;br&gt;本地方法库]

    subgraph User Defined Class
        UserClass[&quot;Java Code (.java)&quot;] --&gt; Bytecode[&quot;Bytecode (.class)&quot;]
    end

    Bytecode --&gt; A
  </pre></div>

<h3 id="1-1-类加载子系统-Class-Loader-Subsystem"><a href="#1-1-类加载子系统-Class-Loader-Subsystem" class="headerlink" title="1.1 类加载子系统 (Class Loader Subsystem)"></a>1.1 类加载子系统 (Class Loader Subsystem)</h3><p>负责在程序运行时动态加载 <code>.class</code> 文件到 JVM 的内存中。它包括三个主要阶段：</p>
<ol>
<li><p><strong>加载 (Loading)</strong>：</p>
<ul>
<li>通过类的完全限定名获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li>
<li>类加载器有：<strong>启动类加载器 (Bootstrap ClassLoader)</strong>、<strong>扩展类加载器 (Extension ClassLoader)</strong>、<strong>应用程序类加载器 (Application ClassLoader)</strong>，它们遵循<strong>双亲委派模型</strong>。</li>
</ul>
</li>
<li><p><strong>链接 (Linking)</strong>：</p>
<ul>
<li><strong>验证 (Verification)</strong>：确保 <code>.class</code> 文件的字节流符合 JVM 规范，不会危害 JVM 的安全。</li>
<li><strong>准备 (Preparation)</strong>：为类的静态变量分配内存，并初始化为默认值（如 <code>int</code> 为 0，<code>boolean</code> 为 <code>false</code>，引用类型为 <code>null</code>）。<strong>此时不会执行任何 Java 代码</strong>。</li>
<li><strong>解析 (Resolution)</strong>：将常量池中的符号引用（如类名、方法名、字段名）转换为直接引用（内存地址）。</li>
</ul>
</li>
<li><p><strong>初始化 (Initialization)</strong>：</p>
<ul>
<li>执行类构造器 <code>&lt;clinit&gt;()</code> 方法（编译器自动收集类中所有静态变量的赋值动作和静态代码块中的语句合并生成）。</li>
<li>这是类加载过程的最后一步，此时才真正开始执行类中定义的 Java 代码。</li>
</ul>
</li>
</ol>
<h3 id="1-2-运行时数据区-Runtime-Data-Areas"><a href="#1-2-运行时数据区-Runtime-Data-Areas" class="headerlink" title="1.2 运行时数据区 (Runtime Data Areas)"></a>1.2 运行时数据区 (Runtime Data Areas)</h3><p>这是 JVM 内存管理的核心，分为多个区域，有的随 JVM 进程启动而存在，有的随线程创建而销毁。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    A[Runtime Data Areas] --&gt; B[Method Area - 方法区]
    A --&gt; C[Heap - 堆]
    A --&gt; D[JVM Stacks - JVM 栈]
    A --&gt; E[Program Counter Register - 程序计数器]
    A --&gt; F[Native Method Stacks - 本地方法栈]

    B &amp; C -- Shared by All Threads --&gt; Z[JVM Process]
    D &amp; E &amp; F -- Private to Each Thread --&gt; Y[Thread Instance]
  </pre></div>

<ol>
<li><p><strong>方法区 (Method Area)</strong>：</p>
<ul>
<li>所有线程共享。</li>
<li>用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等。</li>
<li>在 JDK 8 之前，HotSpot JVM 中方法区通常被称为<strong>永久代 (PermGen)</strong>。</li>
<li>在 JDK 8 及之后，永久代被<strong>元空间 (Metaspace)</strong> 取代，元空间直接使用本地内存，不再在 JVM 堆中。</li>
</ul>
</li>
<li><p><strong>堆 (Heap)</strong>：</p>
<ul>
<li>所有线程共享。</li>
<li>JVM 管理的最大一块内存区域，用于存储<strong>对象实例</strong>和<strong>数组</strong>。</li>
<li>是垃圾回收器 (Garbage Collector) 主要管理的地方，因此又被称为“GC 堆”。</li>
<li>堆通常划分为<strong>新生代 (Young Generation)</strong> 和<strong>老年代 (Old Generation)</strong>。</li>
</ul>
</li>
<li><p><strong>JVM 栈 (JVM Stacks)</strong>：</p>
<ul>
<li>每个线程私有。</li>
<li>生命周期与线程相同。</li>
<li>每个方法执行时会创建一个<strong>栈帧 (Stack Frame)</strong>，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>方法调用和返回的过程，就对应着栈帧的入栈和出栈。</li>
</ul>
</li>
<li><p><strong>程序计数器 (Program Counter Register)</strong>：</p>
<ul>
<li>每个线程私有。</li>
<li>一块较小的内存空间，用于存储当前线程执行的字节码的行号指示器。</li>
<li>在多线程环境下，当线程被切换回来时，PC 寄存器能知道上次程序执行到哪里。</li>
<li><strong>是 JVM 中唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况的区域</strong>。</li>
</ul>
</li>
<li><p><strong>本地方法栈 (Native Method Stacks)</strong>：</p>
<ul>
<li>每个线程私有。</li>
<li>与 JVM 栈类似，但它为 JVM 执行 Native 方法 (即非 Java 代码，通常用 C&#x2F;C++ 编写) 提供服务。</li>
</ul>
</li>
</ol>
<h3 id="1-3-执行引擎-Execution-Engine"><a href="#1-3-执行引擎-Execution-Engine" class="headerlink" title="1.3 执行引擎 (Execution Engine)"></a>1.3 执行引擎 (Execution Engine)</h3><p>负责执行字节码指令。它包含：</p>
<ol>
<li><strong>解释器 (Interpreter)</strong>：逐行解释执行字节码。启动速度快，但执行效率低。</li>
<li><strong>即时编译器 (JIT Compiler - Just-In-Time Compiler)</strong>：<ul>
<li>在运行时将热点代码（被频繁执行的代码）直接编译成本地机器码，然后缓存起来，下次直接执行机器码，提高执行效率。</li>
<li>分为 <strong>C1 编译器 (Client Compiler)</strong> 和 <strong>C2 编译器 (Server Compiler)</strong>。<ul>
<li>C1 编译器：优化程度低，编译速度快，适用于启动速度要求高的客户端应用。</li>
<li>C2 编译器：优化程度高，编译速度慢，适用于需要长时间运行且对峰值性能要求高的服务器应用。</li>
</ul>
</li>
<li><strong>分层编译 (Tiered Compilation)</strong>：在 JDK 7u4 之后默认启用，结合了 C1 和 C2 的优点，在程序启动初期用 C1 快速编译，随后对热点代码用 C2 深度优化。</li>
</ul>
</li>
<li><strong>垃圾回收器 (Garbage Collector)</strong>：管理堆内存的自动回收。</li>
</ol>
<h3 id="1-4-本地方法接口-Native-Method-Interface-本地方法库-Native-Method-Libraries"><a href="#1-4-本地方法接口-Native-Method-Interface-本地方法库-Native-Method-Libraries" class="headerlink" title="1.4 本地方法接口 (Native Method Interface) &amp; 本地方法库 (Native Method Libraries)"></a>1.4 本地方法接口 (Native Method Interface) &amp; 本地方法库 (Native Method Libraries)</h3><ul>
<li><strong>本地方法接口 (JNI - Java Native Interface)</strong>：允许 Java 代码与用其他语言（如 C&#x2F;C++）编写的本地应用程序和库进行交互。</li>
<li><strong>本地方法库</strong>：JNI 调用本地方法时需要使用的库。</li>
</ul>
<h2 id="二、垃圾回收-Garbage-Collection-GC"><a href="#二、垃圾回收-Garbage-Collection-GC" class="headerlink" title="二、垃圾回收 (Garbage Collection - GC)"></a>二、垃圾回收 (Garbage Collection - GC)</h2><p>JVM 的核心特性之一是自动内存管理，即垃圾回收。它负责自动发现并回收不再使用的对象所占用的内存。</p>
<h3 id="2-1-如何判断对象“死亡”"><a href="#2-1-如何判断对象“死亡”" class="headerlink" title="2.1 如何判断对象“死亡”"></a>2.1 如何判断对象“死亡”</h3><ol>
<li><p><strong>引用计数法 (Reference Counting)</strong>：</p>
<ul>
<li>给每个对象添加一个引用计数器，每当有一个地方引用它，计数器就加 1；引用失效时，计数器就减 1。任何时刻计数器为 0 的对象就是不可能再被使用的。</li>
<li><strong>缺点</strong>：难以解决对象之间相互循环引用的问题。</li>
<li><strong>Java 虚拟机没有采用此方法。</strong></li>
</ul>
</li>
<li><p><strong>可达性分析算法 (Reachability Analysis)</strong>：</p>
<ul>
<li>以一系列被称为 <strong>GC Roots</strong> 的对象作为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链 (Reference Chain)。</li>
<li>当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，可以被回收。</li>
<li><strong>GC Roots 包括</strong>：<ul>
<li>虚拟机栈中（栈帧中的局部变量表）引用的对象。</li>
<li>本地方法栈中 JNI 引用的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>所有被 <code>synchronized</code> 持有的对象。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-2-垃圾回收算法"><a href="#2-2-垃圾回收算法" class="headerlink" title="2.2 垃圾回收算法"></a>2.2 垃圾回收算法</h3><ol>
<li><p><strong>标记-清除算法 (Mark-Sweep)</strong>：</p>
<ul>
<li><strong>标记</strong>：从 GC Roots 开始标记所有存活对象。</li>
<li><strong>清除</strong>：遍历整个堆，回收所有未被标记的对象所占用的内存。</li>
<li><strong>缺点</strong>：<ul>
<li>效率问题：标记和清除过程效率都不高。</li>
<li>空间问题：产生大量不连续的内存碎片，可能导致后续需要较大连续内存的对象无法分配，不得不提前触发另一次 GC。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复制算法 (Copying)</strong>：</p>
<ul>
<li>将可用内存分为大小相等的两块，每次只使用其中一块。</li>
<li>当这块内存用完时，将存活对象复制到另一块内存上，然后清除已使用内存块的所有内容。</li>
<li><strong>优点</strong>：<ul>
<li>不会产生内存碎片。</li>
<li>GC 效率高。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>内存利用率只有 50%。</li>
<li>不适用于对象存活率高的老年代。</li>
</ul>
</li>
<li><strong>应用</strong>：常用于新生代（因为新生代对象朝生夕死，存活率低）。HotSpot JVM 的新生代通常采用<strong>分代复制算法 (Generational Copying)</strong>，将新生代分为一个 <code>Eden</code> 区和两个 <code>Survivor</code> 区 (<code>S0</code>, <code>S1</code>)，比例通常为 8:1:1。每次只使用 <code>Eden</code> 和一个 <code>Survivor</code>，回收时将 <code>Eden</code> 和 <code>S0</code> 中存活的对象复制到 <code>S1</code>，清空 <code>Eden</code> 和 <code>S0</code>。</li>
</ul>
</li>
<li><p><strong>标记-整理算法 (Mark-Compact)</strong>：</p>
<ul>
<li><strong>标记</strong>：与标记-清除算法一样，标记出所有存活对象。</li>
<li><strong>整理</strong>：将所有存活对象向一端移动，然后直接清理掉端边界以外的内存。</li>
<li><strong>优点</strong>：<ul>
<li>解决了内存碎片问题。</li>
<li>适用于对象存活率高的老年代。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>效率比复制算法低。</li>
<li>移动对象会触发 <strong>Stop-The-World (STW)</strong>，暂停所有用户线程。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分代收集算法 (Generational Collection)</strong>：</p>
<ul>
<li>现代 JVM 垃圾回收器普遍采用的策略。</li>
<li>基于“弱分代假说”：绝大多数对象都是朝生夕死的。</li>
<li>将堆内存划分为<strong>新生代 (Young Generation)</strong> 和<strong>老年代 (Old Generation)</strong>。<ul>
<li><strong>新生代</strong>：通常使用复制算法，回收频率高，每次回收 (Minor GC) 大部分对象都会死亡。</li>
<li><strong>老年代</strong>：通常使用标记-整理或标记-清除（与整理组合）算法，回收频率低，每次回收 (Major GC &#x2F; Full GC) 会进行全面扫描。</li>
</ul>
</li>
<li>当一个对象在新生代经历多次 GC 后仍然存活（默认 15 次，可以通过 <code>-XX:MaxTenuringThreshold</code> 设置），就会被<strong>晋升 (Promotion)</strong> 到老年代。</li>
</ul>
</li>
</ol>
<h3 id="2-3-常见的垃圾回收器"><a href="#2-3-常见的垃圾回收器" class="headerlink" title="2.3 常见的垃圾回收器"></a>2.3 常见的垃圾回收器</h3><p>HotSpot JVM 提供了多种垃圾回收器，各有优缺点，适用于不同的应用场景。</p>
<ul>
<li><p><strong>Serial 收集器</strong>：</p>
<ul>
<li>最古老、最简单的收集器。</li>
<li>单线程工作，在进行 GC 时，必须暂停所有用户线程 (STW)。</li>
<li>适用于客户端模式下内存不大的场景。</li>
</ul>
</li>
<li><p><strong>ParNew 收集器</strong>：</p>
<ul>
<li>Serial 收集器的多线程版本。</li>
<li>新生代收集器，多线程并行回收，也会 STW。</li>
<li>常与 CMS 收集器配合使用。</li>
</ul>
</li>
<li><p><strong>Parallel Scavenge 收集器</strong>：</p>
<ul>
<li>新生代收集器，与 ParNew 类似，也是多线程并行回收。</li>
<li><strong>目标是达到一个可控制的吞吐量 (Throughput)</strong>。</li>
<li>提供了 <code>-XX:MaxGCPauseMillis</code> (最大 GC 停顿时间) 和 <code>-XX:GCTimeRatio</code> (GC 时间与总时间的比率) 参数来控制吞吐量和停顿时间。</li>
</ul>
</li>
<li><p><strong>Serial Old 收集器</strong>：</p>
<ul>
<li>Serial 收集器的老年代版本。</li>
<li>单线程、标记-整理算法。</li>
<li>主要用于客户端模式下的 JVM，或作为 CMS&#x2F;Parallel Scavenge 收集器的后备方案。</li>
</ul>
</li>
<li><p><strong>Parallel Old 收集器</strong>：</p>
<ul>
<li>Parallel Scavenge 收集器的老年代版本。</li>
<li>多线程、标记-整理算法。</li>
<li>注重吞吐量，适用于重视吞吐量和 CPU 资源敏感的场景。</li>
</ul>
</li>
<li><p><strong>CMS (Concurrent Mark Sweep) 收集器</strong>：</p>
<ul>
<li><strong>目标是获取最短回收停顿时间 (Low Pause Time)</strong>。</li>
<li>采用“标记-清除”算法。</li>
<li>工作过程：<ol>
<li><strong>初始标记 (Initial Mark)</strong>：短暂停顿，标记 GC Roots 能直接关联到的对象。</li>
<li><strong>并发标记 (Concurrent Mark)</strong>：与用户线程并发执行，从初始标记的对象开始遍历整个对象图。</li>
<li><strong>重新标记 (Remark)</strong>：短暂停顿，修正并发标记期间因用户程序运行而导致标记产生变动的对象。</li>
<li><strong>并发清除 (Concurrent Sweep)</strong>：与用户线程并发执行，清除已死亡对象。</li>
</ol>
</li>
<li><strong>优点</strong>：并发收集，停顿时间短。</li>
<li><strong>缺点</strong>：<ul>
<li>对 CPU 资源敏感。</li>
<li>无法处理<strong>浮动垃圾 (Floating Garbage)</strong>。</li>
<li>基于标记-清除算法，会产生内存碎片。</li>
<li>需要预留一部分空间供并发收集时使用。</li>
</ul>
</li>
<li><strong>JDK 9 废弃，JDK 14 移除。</strong></li>
</ul>
</li>
<li><p><strong>G1 (Garbage-First) 收集器</strong>：</p>
<ul>
<li><strong>分代收集器</strong>，但不再严格划分新生代和老年代，而是将堆划分为多个<strong>大小相等的 Region</strong> (区域)。</li>
<li>G1 收集器可以<strong>建立可预测的停顿时间模型</strong>。</li>
<li>工作过程：<ol>
<li><strong>初始标记 (Initial Mark)</strong>：短暂停顿，标记 GC Roots 能直接关联到的对象。</li>
<li><strong>并发标记 (Concurrent Mark)</strong>：与用户线程并发执行，扫描整个堆。</li>
<li><strong>最终标记 (Final Mark)</strong>：短暂停顿，处理并发阶段结束后仍遗留下来的或在并发标记期间被修改的对象。</li>
<li><strong>筛选回收 (Evacuation)</strong>：短暂停顿，对各个 Region 的回收价值和成本进行排序，根据用户期望的停顿时间，回收一部分 Region。G1 会优先回收那些回收价值最大的 Region (Garbage First)。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li>可预测的停顿时间。</li>
<li>区域化管理，避免全堆扫描。</li>
<li>既能处理大对象，又能处理碎片问题。</li>
</ul>
</li>
<li><strong>JDK 9 默认垃圾回收器。</strong></li>
</ul>
</li>
<li><p><strong>ZGC (Z Garbage Collector)</strong>：</p>
<ul>
<li><strong>JDK 11 引入，JDK 15 正式可用。</strong></li>
<li><strong>目标是实现极低停顿时间 (毫秒级甚至亚毫秒级)，支持 TB 级别的堆内存。</strong></li>
<li>采用并发标记、并发回收，<strong>几乎所有 GC 阶段都与用户线程并发执行</strong>。</li>
<li>基于着色指针 (Colored Pointers) 和读屏障 (Read Barrier) 技术。</li>
<li><strong>优点</strong>：极低停顿，支持大堆。</li>
<li><strong>缺点</strong>：对硬件要求高，对吞吐量有一定影响，且刚推出时兼容性不如 G1。</li>
</ul>
</li>
<li><p><strong>Shenandoah 收集器</strong>：</p>
<ul>
<li><strong>JDK 12 引入，与 ZGC 类似，目标也是低停顿，主要由 Red Hat 开发。</strong></li>
<li>采用并发整理、转发指针 (Forwarding Pointers) 和读屏障技术。</li>
</ul>
</li>
</ul>
<h3 id="2-4-GC-日志分析"><a href="#2-4-GC-日志分析" class="headerlink" title="2.4 GC 日志分析"></a>2.4 GC 日志分析</h3><p>通过 <code>-Xlog:gc*</code> 或更早版本的 <code>-XX:+PrintGCDetails</code> 可以打印详细的 GC 日志，有助于理解 GC 行为和问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JDK 9+</span></span><br><span class="line">java -Xlog:gc*=info -jar your_application.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># JDK 8</span></span><br><span class="line">java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:./gc.log -jar your_application.jar</span><br></pre></td></tr></table></figure>

<h2 id="三、JVM-内存参数调优"><a href="#三、JVM-内存参数调优" class="headerlink" title="三、JVM 内存参数调优"></a>三、JVM 内存参数调优</h2><p>JVM 调优主要是调整堆内存、方法区大小，以及选择合适的垃圾回收器和其相关参数，以达到最佳的性能指标 (吞吐量、响应时间等)。</p>
<h3 id="3-1-堆内存参数"><a href="#3-1-堆内存参数" class="headerlink" title="3.1 堆内存参数"></a>3.1 堆内存参数</h3><ul>
<li><code>-Xms&lt;size&gt;</code>：设置 JVM 堆的<strong>初始分配大小</strong>。默认物理内存的 1&#x2F;64。</li>
<li><code>-Xmx&lt;size&gt;</code>：设置 JVM 堆的<strong>最大分配大小</strong>。默认物理内存的 1&#x2F;4。<ul>
<li><strong>建议</strong>：<code>Xms</code> 和 <code>Xmx</code> 设置为相同值，可以避免 JVM 在运行时动态调整堆大小带来的额外开销。</li>
</ul>
</li>
<li><code>-Xmn&lt;size&gt;</code>：设置新生代的大小。<ul>
<li><strong>建议</strong>：新生代设置为整个堆的 1&#x2F;4 到 1&#x2F;3。</li>
</ul>
</li>
<li><code>-XX:NewRatio=&lt;ratio&gt;</code>：设置新生代与老年代的比值。例如 <code>-XX:NewRatio=2</code> 表示新生代占 1，老年代占 2，新生代占整个堆的 1&#x2F;3。</li>
<li><code>-XX:SurvivorRatio=&lt;ratio&gt;</code>：设置 <code>Eden</code> 区与一个 <code>Survivor</code> 区的比值。例如 <code>-XX:SurvivorRatio=8</code> 表示 <code>Eden:S0:S1 = 8:1:1</code>。</li>
<li><code>-XX:MaxTenuringThreshold=&lt;threshold&gt;</code>：设置对象在新生代晋升老年代的年龄阈值。默认 15。</li>
</ul>
<h3 id="3-2-方法区-元空间参数"><a href="#3-2-方法区-元空间参数" class="headerlink" title="3.2 方法区&#x2F;元空间参数"></a>3.2 方法区&#x2F;元空间参数</h3><ul>
<li><code>-XX:PermSize=&lt;size&gt;</code> (JDK 8 之前)：设置永久代初始大小。</li>
<li><code>-XX:MaxPermSize=&lt;size&gt;</code> (JDK 8 之前)：设置永久代最大大小。</li>
<li><code>-XX:MetaspaceSize=&lt;size&gt;</code> (JDK 8 及之后)：设置元空间初始大小。</li>
<li><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code> (JDK 8 及之后)：设置元空间最大大小。<ul>
<li><strong>建议</strong>：根据应用加载的类数量进行调整，避免频繁的 Metaspace GC 导致停顿。</li>
</ul>
</li>
</ul>
<h3 id="3-3-垃圾回收器选择与参数"><a href="#3-3-垃圾回收器选择与参数" class="headerlink" title="3.3 垃圾回收器选择与参数"></a>3.3 垃圾回收器选择与参数</h3><p>根据应用特性选择合适的 GC 策略：</p>
<ul>
<li><p><strong>吞吐量优先 (Throughput First)</strong>：适用于后台批处理、数据分析等不需要太关注停顿时间的场景。</p>
<ul>
<li><strong>JVM 参数</strong>：<code>NewRatio</code>、<code>SurvivorRatio</code> 等调整分代比例，<code>-XX:+UseParallelGC</code> (新生代) 和 <code>-XX:+UseParallelOldGC</code> (老年代)。</li>
<li><strong>主要参数</strong>：<code>-XX:MaxGCPauseMillis</code> (控制最大 GC 停顿时间，但可能牺牲吞吐量)、<code>-XX:GCTimeRatio</code> (GC 时间占总时间比)。</li>
</ul>
</li>
<li><p><strong>低延迟&#x2F;短停顿优先 (Low Latency First)</strong>：适用于高并发、实时响应的 Web 应用、GUI 应用。</p>
<ul>
<li><strong>JVM 参数</strong>：<ul>
<li><strong>G1 收集器</strong> (JDK 9+ 默认)：<code>-XX:+UseG1GC</code><ul>
<li><code>-XX:MaxGCPauseMillis=&lt;millis&gt;</code>：设置期望的最大 GC 停顿时间 (默认 200ms)。G1 会尽力尝试达到，但不保证。</li>
<li><code>-XX:G1HeapRegionSize=&lt;size&gt;</code>：设置 G1 Region 大小 (默认是根据堆大小自动调整)。</li>
</ul>
</li>
<li><strong>ZGC&#x2F;Shenandoah 收集器</strong> (JDK 11+)：<code>-XX:+UseZGC</code> &#x2F; <code>-XX:+UseShenandoahGC</code><ul>
<li>通常不需要太多调优参数，因为它们设计目标就是极低停顿。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>其他常用 GC 参数</strong>：</p>
<ul>
<li><code>-XX:+PrintGCDetails</code> (JDK 8) &#x2F; <code>-Xlog:gc*=info</code> (JDK 9+)：打印详细 GC 日志。</li>
<li><code>-XX:+DisableExplicitGC</code>：禁止显式调用 <code>System.gc()</code>。</li>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：当发生 OOM 时，生成堆转储文件，便于事后分析。</li>
<li><code>-XX:HeapDumpPath=&lt;path&gt;</code>：指定堆转储文件路径。</li>
</ul>
</li>
</ul>
<h3 id="3-4-调优流程"><a href="#3-4-调优流程" class="headerlink" title="3.4 调优流程"></a>3.4 调优流程</h3><ol>
<li><strong>监控与基线测试</strong>：使用 JMX、JVisualVM、Arthas、GCViewer 等工具监控应用运行时的内存使用、GC 情况、CPU 负载。建立性能基线。</li>
<li><strong>分析 GC 日志</strong>：通过 GC 日志分析 GC 频率、停顿时间、内存回收量，找出 GC 热点和瓶颈。</li>
<li><strong>调整堆大小和比例</strong>：根据 GC 情况调整 <code>Xms</code>、<code>Xmx</code>、<code>NewRatio</code>、<code>SurvivorRatio</code>，目标是减少 Full GC 的发生，并优化 Minor GC 的效率。</li>
<li><strong>选择和调整 GC 收集器</strong>：根据应用对吞吐量和延迟的需求，选择合适的收集器 (ParallelGC、G1、ZGC 等)，并调整其特定参数。</li>
<li><strong>代码层面优化</strong>：<ul>
<li><strong>对象生命周期管理</strong>：减少不必要的对象创建，尤其是循环内部的对象创建。</li>
<li><strong>避免内存泄漏</strong>：及时释放不再使用的对象引用，尤其是在集合类、事件监听器中。</li>
<li><strong>并发优化</strong>：合理使用并发工具类，减少锁竞争。</li>
<li><strong>NIO&#x2F;零拷贝</strong>：在 I&#x2F;O 密集型应用中使用 NIO 或零拷贝技术。</li>
</ul>
</li>
<li><strong>重复测试与分析</strong>：每次参数调整后，都需要重新进行基线测试和 GC 日志分析，对比性能指标，直至达到满意的效果。</li>
</ol>
<h2 id="四、JVM-监控与分析工具"><a href="#四、JVM-监控与分析工具" class="headerlink" title="四、JVM 监控与分析工具"></a>四、JVM 监控与分析工具</h2><ul>
<li><strong>JVisualVM (Java VisualVM)</strong>：<ul>
<li>JDK 自带的 GUI 工具，提供性能分析、内存分析、线程分析、GC 监控等功能。</li>
<li>可以连接本地或远程 JVM 进程。</li>
</ul>
</li>
<li><strong>JConsole (Java Monitoring and Management Console)</strong>：<ul>
<li>JDK 自带的 GUI 工具，用于监控 JVM 的内存、线程、类加载、CPU 使用率等。</li>
</ul>
</li>
<li><strong>JStack</strong>：<ul>
<li>JDK 自带的命令行工具，用于打印指定 Java 进程的线程栈信息，常用于分析死锁、无限循环等问题。</li>
</ul>
</li>
<li><strong>JMap</strong>：<ul>
<li>JDK 自带的命令行工具，用于生成堆内存快照 (Heap Dump)，可以分析内存泄漏。</li>
</ul>
</li>
<li><strong>Arthas</strong>：<ul>
<li>阿里巴巴开源的 Java 诊断工具，功能强大，支持在线排查、诊断、监控 JVM。</li>
</ul>
</li>
<li><strong>GCViewer</strong>：<ul>
<li>GC 日志分析工具，将 GC 日志可视化，方便分析 GC 行为。</li>
</ul>
</li>
<li><strong>YourKit &#x2F; JProfiler</strong>：<ul>
<li>商业级性能分析工具，功能更强大、更全面。</li>
</ul>
</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>JVM 是 Java 应用程序的运行时核心，深入理解其架构、内存模型和垃圾回收机制是 Java 工程师进阶的必经之路。JVM 调优并非一蹴而就，它是一个<strong>持续的、迭代的</strong>过程，需要结合实际应用场景、性能目标，通过<strong>监控、分析、调整</strong>的循环来进行。掌握 JVM 的原理和调优技巧，不仅能够解决生产环境中的各种性能问题，还能帮助我们编写出更高效、更健壮的 Java 应用程序。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/8af9f3feb76a/">https://blog.tbf1211.xx.kg/8af9f3feb76a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/4fb32da58385/" title="golangci-lint 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">golangci-lint 详解</div></div><div class="info-2"><div class="info-item-1"> golangci-lint 是 Go 语言生态系统中一个快速、功能丰富的 linter 聚合器，它汇集了上百种静态代码分析工具 (linters)，并以并行、缓存和统一配置的方式运行它们。它的目标是帮助 Go 开发者在不牺牲性能的前提下，保持代码的高质量和一致性。  核心思想：将多个 Go 语言的静态分析工具整合到一个高效的命令行工具中，提供统一的配置和快速的执行，从而简化代码质量检查流程。   一、为什么需要 golangci-lint？Go 语言在代码风格和规范方面有 gofmt 和 go vet 等官方工具。然而，随着项目复杂度的增加，团队往往需要更全面的静态分析来捕捉潜在的 bug、性能问题、安全漏洞和违反最佳实践的代码。社区为此开发了大量的独立 linter 工具，例如 staticcheck、errcheck、gosec 等。 如果没有 golangci-lint，开发者将面临以下挑战：  管理复杂性：需要单独安装、配置和运行多个 linter 工具，这会增加工作流的复杂性。 性能问题：单独运行每个 linter 可能会导致重复解析源代码，从而降低效率，尤其是在大型...</div></div></div></a><a class="pagination-related" href="/65ed4d3a4af3/" title="Python 自定义类的运算符重载详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python 自定义类的运算符重载详解</div></div><div class="info-2"><div class="info-item-1"> 运算符重载 (Operator Overloading) 允许自定义类的实例对标准运算符（如 +, -, *, /, ==, &lt;, [] 等）作出响应。通过在自定义类中定义特定的魔术方法 (Magic Methods) 或称 双下划线方法 (Dunder Methods)，我们可以改变这些运算符的行为，使其适用于我们自己定义的对象。这使得自定义类的实例能够像内置类型一样自然地进行操作，提高了代码的可读性和表达力。  核心思想：通过实现 Python 的特殊方法 (以双下划线 __ 开头和结尾)，我们可以控制自定义对象如何响应内置运算符和函数。这些特殊方法是 Python 语言的“钩子”，允许我们自定义对象的行为。   一、为什么需要运算符重载？考虑一个场景：我们正在创建一个表示二维向量的 Vector 类。如果没有运算符重载，我们可能需要这样写： 12345678910111213141516class Vector:    def __init__(self, x, y):        self.x = x        self.y = y    def add(s...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1d1a23609f01/" title="Java 内存泄漏详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-13</div><div class="info-item-2">Java 内存泄漏详解</div></div><div class="info-2"><div class="info-item-1"> Java 内存泄漏 (Memory Leak) 是指程序中已不再需要使用的对象，仍然被“根对象”链所引用，导致垃圾回收器无法对其进行回收，从而占用宝贵的堆内存。随着程序的运行，内存泄漏会不断累积，最终可能导致应用程序运行缓慢、响应迟钝，直至抛出 OutOfMemoryError (OOM) 错误而崩溃。  核心思想：内存泄漏的本质是“应该被回收但未被回收的对象”。理解 Java 垃圾回收机制和对象生命周期是诊断和避免内存泄漏的关键。    一、什么是内存泄漏？在 Java 中，我们通常不直接管理内存，而是依赖 JVM 的垃圾回收器 (GC) 自动回收不再使用的对象。一个对象是否“不再需要”，GC 通过可达性分析算法来判断：如果从 GC Roots 无法到达某个对象，则认为该对象是“垃圾”，可以被回收。 内存泄漏的定义：当一个对象实际上已经不再需要（即业务逻辑上它已经“死亡”），但从 GC Roots 到它仍然存在一条强引用链 (Strong Reference Chain)，导致 GC 无法回收它所占用的内存。 这种情况下，JVM 误认为该对象仍然“存活”，从而阻止了它的回收。...</div></div></div></a><a class="pagination-related" href="/94cd78552baf/" title="MyBatis-Plus (MP) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-24</div><div class="info-item-2">MyBatis-Plus (MP) 详解</div></div><div class="info-2"><div class="info-item-1"> MyBatis-Plus (MP) 是一个基于 MyBatis 的增强工具，它在 MyBatis 的基础上提供了许多便捷的功能，旨在简化开发、提高效率。MP 提供了无侵入式的特性，即它仅在 MyBatis 的基础上进行增强，不改变 MyBatis 原有的逻辑和配置，可以与 MyBatis 完全兼容。它的核心目标是少写代码，甚至不用写 SQL，即可完成大部分常见的 CRUD (创建、读取、更新、删除) 操作。  核心思想：MyBatis-Plus 通过提供通用的 CRUD 接口、强大的条件构造器、代码生成器以及一系列自动化功能，极大地减少了开发者在持久层的工作量，使得 MyBatis 更加易用，开发效率更高，同时保留了 MyBatis 对 SQL 的高度控制能力。    一、为什么需要 MyBatis-Plus？尽管 MyBatis 已经是一个非常优秀的持久层框架，解决了传统 JDBC 的许多痛点，但在实际开发中，仍然存在一些重复性劳动：  大量重复的 CRUD SQL：对于每个实体类，都需要编写大量的 insert, selectById, updateById, delete...</div></div></div></a><a class="pagination-related" href="/4a5f313d588b/" title="JDBC (Java Database Connectivity) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-20</div><div class="info-item-2">JDBC (Java Database Connectivity) 详解</div></div><div class="info-2"><div class="info-item-1"> JDBC (Java Database Connectivity) 是 Java 语言中用于访问关系型数据库的标准 Java API (应用程序编程接口)。它提供了一套统一的接口，允许 Java 应用程序以独立于数据库供应商的方式连接到各种关系型数据库（如 MySQL、Oracle、PostgreSQL、SQL Server 等），执行 SQL 语句，并处理查询结果。  核心思想：JDBC 提供了一个通用的抽象层，使得 Java 开发者可以使用一套标准的 API 来与任何支持 JDBC 规范的关系型数据库进行交互，而无需关心底层数据库的具体实现细节。    一、为什么需要 JDBC？在 JDBC 出现之前，Java 应用程序要连接和操作数据库，需要为每种数据库编写特定的代码。这意味着：  缺乏通用性：每更换一个数据库，应用程序的代码就需要大幅修改。 开发效率低：开发者需要熟悉不同数据库的私有 API。 维护成本高：代码难以维护和扩展。  JDBC 的目标就是解决这些问题，提供一个**“一次编写，处处运行” (Write Once, Run Anywhere)** 的数据库访问解...</div></div></div></a><a class="pagination-related" href="/1ce020133b41/" title="Java 泛型 (Generics) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="info-item-2">Java 泛型 (Generics) 详解</div></div><div class="info-2"><div class="info-item-1"> Java 泛型 (Generics) 是在 JDK 5.0 中引入的一项重要语言特性，它允许在定义类、接口和方法时，使用类型参数 (Type Parameters) 来表示不确定的类型。这样，编译器可以在编译时对类型进行检查，从而在运行时避免 ClassCastException 等类型转换异常，提高了代码的类型安全性 (Type Safety)、重用性 (Reusability) 和可读性 (Readability)。  核心思想：Java 泛型通过引入类型参数，使得代码可以操作各种类型的数据而无需运行时强制类型转换，从而在编译时提供了更强的类型检查，减少了运行时错误，并提升了代码的通用性和安全性。    一、为什么需要泛型？在泛型出现之前，Java 集合框架（如 ArrayList, HashMap）可以存放任何类型的对象，因为它们操作的是 Object 类型。这带来了两个主要问题：  类型不安全：编译器无法检查集合中存储的实际类型。如果从集合中取出一个对象并强制转换为不正确的类型，就会在运行时抛出 ClassCastException。 代码冗余：每次从集合中取出对象时，...</div></div></div></a><a class="pagination-related" href="/0a6eb114d7c3/" title="Java 虚拟线程 (Virtual Threads) 详解 - Project Loom 的成果"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-22</div><div class="info-item-2">Java 虚拟线程 (Virtual Threads) 详解 - Project Loom 的成果</div></div><div class="info-2"><div class="info-item-1"> 虚拟线程 (Virtual Threads) 是 Java 平台在 JDK 21 中正式引入 的一项革命性并发特性（作为 Project Loom 1 的主要成果）。它旨在显著简化高吞吐量并发应用的开发和维护，通过提供轻量级的、由 JVM 管理的线程，解决传统平台线程在高并发场景下的性能瓶颈和资源消耗问题。  核心思想：虚拟线程让开发者能够继续沿用更直观的“一请求一线程 (thread-per-request)”的编程模型，同时获得接近异步编程的扩展能力。它将阻塞 I&#x2F;O 操作的开销从昂贵的操作系统线程转移到了 JVM 层面，从而在不改变代码风格的情况下，极大提升了服务器应用的并发吞吐量。   一、为什么需要虚拟线程？(传统并发的痛点)在 Java 历史上，处理并发主要依赖于传统的 平台线程 (Platform Threads)，也就是我们通常所说的 java.lang.Thread 类实例。这些线程直接映射到操作系统 (OS) 线程。 传统平台线程在高并发场景下存在以下痛点：  资源开销大：每个平台线程都需要操作系统分配独立的栈空间（通常 1MB 或更多），以及维护...</div></div></div></a><a class="pagination-related" href="/25dabaebd519/" title="JUnit (单元测试框架) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-17</div><div class="info-item-2">JUnit (单元测试框架) 详解</div></div><div class="info-2"><div class="info-item-1"> JUnit 是一个开源的 Java 语言单元测试框架，也是 Java 开发中最常用、最具影响力的测试框架之一。它提供了一套用于编写和运行可重复测试的工具集，旨在帮助开发者实现测试驱动开发 (TDD) 和确保代码质量。JUnit 是 xUnit 家族的一员，它的核心理念是：先编写测试，再编写业务代码，并确保测试能够通过，从而验证代码的正确性。  核心思想：JUnit 提供了一套标准化的注解和断言方法，使得开发者能够以结构化、可自动化执行的方式，对程序中的最小可测试单元（通常是方法）进行验证，确保其行为符合预期。    一、为什么需要单元测试与 JUnit？在软件开发过程中，测试是不可或缺的一环。单元测试尤其重要，它专注于测试程序中最小的功能模块（例如一个类的一个方法）。没有单元测试，开发者会面临以下挑战：  代码质量难以保证：无法及时发现代码中的逻辑错误、边界条件问题。 回归测试困难：修改现有代码后，很难确保没有引入新的 Bug 到原有功能中。 重构风险高：缺乏测试覆盖的代码，在重构时容易引入新的问题，因为无法快速验证重构后的代码是否依然正确。 调试成本高：问题往往在集成测试或生...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">545</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81JVM-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-text">一、JVM 架构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F-Class-Loader-Subsystem"><span class="toc-text">1.1 类加载子系统 (Class Loader Subsystem)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-Runtime-Data-Areas"><span class="toc-text">1.2 运行时数据区 (Runtime Data Areas)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-Execution-Engine"><span class="toc-text">1.3 执行引擎 (Execution Engine)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3-Native-Method-Interface-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%BA%93-Native-Method-Libraries"><span class="toc-text">1.4 本地方法接口 (Native Method Interface) &amp; 本地方法库 (Native Method Libraries)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-Garbage-Collection-GC"><span class="toc-text">二、垃圾回收 (Garbage Collection - GC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E2%80%9C%E6%AD%BB%E4%BA%A1%E2%80%9D"><span class="toc-text">2.1 如何判断对象“死亡”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2.2 垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">2.3 常见的垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-text">2.4 GC 日志分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81JVM-%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-text">三、JVM 内存参数调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%A0%86%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-text">3.1 堆内存参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%85%83%E7%A9%BA%E9%97%B4%E5%8F%82%E6%95%B0"><span class="toc-text">3.2 方法区&#x2F;元空间参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%80%89%E6%8B%A9%E4%B8%8E%E5%8F%82%E6%95%B0"><span class="toc-text">3.3 垃圾回收器选择与参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%B0%83%E4%BC%98%E6%B5%81%E7%A8%8B"><span class="toc-text">3.4 调优流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JVM-%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">四、JVM 监控与分析工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-32.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>