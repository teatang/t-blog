<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WebView 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="WebView 是一个嵌入式浏览器组件，允许原生移动应用程序 (Native App) 在其 UI 内部显示网页内容。它不是一个完整的 Web 浏览器应用程序，而是一个可以集成到原生应用中的控件，通过它应用可以加载并渲染 HTML、CSS 和 JavaScript 内容，从而将 Web 技术的能力引入原生界面。  核心思想：在原生应用中提供一个轻量级的、可编程的 Web 浏览器环境，实现原生与">
<meta property="og:type" content="article">
<meta property="og:title" content="WebView 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/26cdb2447b3d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="WebView 是一个嵌入式浏览器组件，允许原生移动应用程序 (Native App) 在其 UI 内部显示网页内容。它不是一个完整的 Web 浏览器应用程序，而是一个可以集成到原生应用中的控件，通过它应用可以加载并渲染 HTML、CSS 和 JavaScript 内容，从而将 Web 技术的能力引入原生界面。  核心思想：在原生应用中提供一个轻量级的、可编程的 Web 浏览器环境，实现原生与">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg">
<meta property="article:published_time" content="2026-01-17T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-30T03:20:58.375Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2026">
<meta property="article:tag" content="WebView">
<meta property="article:tag" content="移动开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WebView 详解",
  "url": "https://blog.tbf1211.xx.kg/26cdb2447b3d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg",
  "datePublished": "2026-01-17T22:24:00.000Z",
  "dateModified": "2026-01-30T03:20:58.375Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/26cdb2447b3d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WebView 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-16.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">WebView 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">WebView 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/">移动开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>WebView</strong> 是一个<strong>嵌入式浏览器组件</strong>，允许原生移动应用程序 (Native App) 在其 UI 内部显示网页内容。它不是一个完整的 Web 浏览器应用程序，而是一个可以集成到原生应用中的控件，通过它应用可以加载并渲染 HTML、CSS 和 JavaScript 内容，从而将 Web 技术的能力引入原生界面。</p>
</blockquote>
<div class="note info flat"><p>核心思想：在原生应用中提供一个轻量级的、可编程的 Web 浏览器环境，实现原生与 Web 内容的无缝融合和交互。</p>
</div>
<hr>
<h2 id="一、什么是-WebView？"><a href="#一、什么是-WebView？" class="headerlink" title="一、什么是 WebView？"></a>一、什么是 WebView？</h2><p>WebView 本质上是一个没有地址栏、工具栏等浏览器 UI 的浏览器内核。它能够解析并渲染网页，执行 JavaScript，处理 HTTP 请求等，但这些行为都受限于其所在的宿主原生应用。开发者可以通过 WebView 将 HTML5 应用、网页、动态内容或完整的混合应用 (Hybrid App) 集成到原生应用中。</p>
<p><strong>WebView 的主要作用：</strong></p>
<ul>
<li>在原生应用中展示网页内容，例如新闻文章、用户协议、商品详情页等。</li>
<li>构建混合应用，将部分或全部 UI 通过 Web 技术实现，以提高开发效率和跨平台能力。</li>
<li>实现应用内的授权登录流程 (如 OAuth2)。</li>
<li>动态更新应用内容，无需发布新版本。</li>
</ul>
<h2 id="二、WebView-的工作原理"><a href="#二、WebView-的工作原理" class="headerlink" title="二、WebView 的工作原理"></a>二、WebView 的工作原理</h2><p>WebView 的核心在于其<strong>内嵌的浏览器引擎</strong>。不同的平台使用不同的底层引擎：</p>
<ol>
<li><p><strong>Android 平台</strong>：</p>
<ul>
<li>在 Android 4.4 (KitKat) 之前，Android WebView 基于开源的 <strong>WebKit</strong> 引擎。</li>
<li>从 Android 4.4 开始，WebView 改为基于 <strong>Chromium</strong> 项目（Google Chrome 浏览器的开源基础），使用 <strong>Blink 渲染引擎</strong>。</li>
<li>自 Android 5.0 (Lollipop) 起，WebView 作为独立的 APK (通过 Google Play Services 或系统更新) 进行更新，与系统解耦，这意味着用户可以通过 Google Play Store 更新 WebView 组件，从而获得最新的 Web 标准支持、性能改进和安全补丁，而无需等待系统更新。</li>
<li><strong>进程模型</strong>：现代 Android WebView 可以运行在独立的进程中，增强了应用的稳定性和安全性。</li>
</ul>
</li>
<li><p><strong>iOS 平台</strong>：</p>
<ul>
<li>早期 iOS 提供了 <strong>UIWebView</strong> 组件，基于 Apple 的 <strong>WebKit</strong> 引擎。但由于其性能、内存占用和安全性问题，已被 Apple 弃用 (Deprecated)。</li>
<li>自 iOS 8.0 开始，Apple 引入了更强大、更高效、更安全的 <strong>WKWebView</strong> 组件，它同样基于 <strong>WebKit</strong> 引擎。</li>
<li><strong>WKWebView</strong> 的优势包括：独立的进程 (提高稳定性，避免内存溢出导致应用崩溃)、更快的 JavaScript 性能、更低的内存占用、以及更好的原生交互机制。</li>
</ul>
</li>
</ol>
<p><strong>通用工作流程：</strong></p>
<ol>
<li><strong>初始化</strong>：原生应用在布局中创建并添加 WebView 实例。</li>
<li><strong>加载内容</strong>：原生代码调用 WebView 的方法 (如 <code>loadUrl()</code> 或 <code>loadHTMLString()</code>) 加载指定的 URL 或 HTML 字符串。</li>
<li><strong>解析渲染</strong>：WebView 的浏览器引擎开始解析 HTML、CSS，构建 DOM 树和渲染树，并绘制到屏幕上。</li>
<li><strong>执行 JavaScript</strong>：JavaScript 代码在 WebView 的沙箱环境中执行，可以动态修改 DOM、处理用户事件、发起网络请求等。</li>
<li><strong>交互</strong>：通过特定的“桥接”机制，Web 内容中的 JavaScript 可以调用原生应用的功能，反之原生应用也可以调用 Web 内容中的 JavaScript 函数。</li>
</ol>
<h2 id="三、主流平台的-WebView-实现"><a href="#三、主流平台的-WebView-实现" class="headerlink" title="三、主流平台的 WebView 实现"></a>三、主流平台的 WebView 实现</h2><h3 id="3-1-Android-WebView"><a href="#3-1-Android-WebView" class="headerlink" title="3.1 Android WebView"></a>3.1 Android WebView</h3><p>在 Android 中，<code>android.webkit.WebView</code> 是核心类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android WebView 基本使用示例 (Kotlin 伪代码)</span></span><br><span class="line"><span class="keyword">import</span> android.webkit.WebView</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebViewClient <span class="comment">// 用于控制页面导航</span></span><br><span class="line"><span class="keyword">import</span> android.webkit.WebSettings <span class="comment">// 用于配置WebView</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> webView: WebView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main) <span class="comment">// 假设布局文件中有 WebView 组件</span></span><br><span class="line"></span><br><span class="line">        webView = findViewById(R.id.my_webview)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 WebView</span></span><br><span class="line">        <span class="keyword">val</span> webSettings: WebSettings = webView.settings</span><br><span class="line">        webSettings.javaScriptEnabled = <span class="literal">true</span> <span class="comment">// 允许执行 JavaScript</span></span><br><span class="line">        webSettings.domStorageEnabled = <span class="literal">true</span> <span class="comment">// 允许使用 DOM 存储（localStorage, sessionStorage）</span></span><br><span class="line">        webSettings.setSupportZoom(<span class="literal">true</span>) <span class="comment">// 允许缩放</span></span><br><span class="line">        webSettings.builtInZoomControls = <span class="literal">true</span> <span class="comment">// 显示缩放控制</span></span><br><span class="line">        webSettings.displayZoomControls = <span class="literal">false</span> <span class="comment">// 隐藏缩放控制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 WebViewClient：处理各种通知和请求事件</span></span><br><span class="line">        webView.webViewClient = <span class="keyword">object</span> : WebViewClient() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(view: <span class="type">WebView</span>?, url: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">                <span class="comment">// 返回 true 表示由 WebView 内部加载 URL，返回 false 表示交给系统浏览器处理</span></span><br><span class="line">                <span class="comment">// 通常用于拦截特定 URL 或实现自定义导航逻辑</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPageFinished</span><span class="params">(view: <span class="type">WebView</span>?, url: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.onPageFinished(view, url)</span><br><span class="line">                <span class="comment">// 页面加载完成后的操作</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ... 其他事件回调</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 WebChromeClient：处理与 UI 相关的事件，如进度、标题、JavaScript 对话框、文件选择等</span></span><br><span class="line">        webView.webChromeClient = <span class="keyword">object</span> : WebChromeClient() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressChanged</span><span class="params">(view: <span class="type">WebView</span>?, newProgress: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.onProgressChanged(view, newProgress)</span><br><span class="line">                <span class="comment">// 网页加载进度</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceivedTitle</span><span class="params">(view: <span class="type">WebView</span>?, title: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.onReceivedTitle(view, title)</span><br><span class="line">                <span class="comment">// 获取网页标题</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... 其他事件回调，如 onJsAlert, onShowFileChooser 等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载网页</span></span><br><span class="line">        webView.loadUrl(<span class="string">&quot;https://www.example.com&quot;</span>)</span><br><span class="line">        <span class="comment">// 或者加载本地 HTML 文件</span></span><br><span class="line">        <span class="comment">// webView.loadUrl(&quot;file:///android_asset/my_local_page.html&quot;)</span></span><br><span class="line">        <span class="comment">// 或者加载 HTML 字符串</span></span><br><span class="line">        <span class="comment">// webView.loadDataWithBaseURL(null, &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello WebView!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (webView.canGoBack()) &#123;</span><br><span class="line">            webView.goBack() <span class="comment">// 如果 WebView 可以回退，则回退页面</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onBackPressed() <span class="comment">// 否则执行原生回退操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-iOS-WKWebView"><a href="#3-2-iOS-WKWebView" class="headerlink" title="3.2 iOS WKWebView"></a>3.2 iOS WKWebView</h3><p>在 iOS 中，<code>WebKit</code> 框架提供了 <code>WKWebView</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS WKWebView 基本使用示例 (Swift 伪代码)</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> WebKit <span class="comment">// 导入 WebKit 框架</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_ inherited__">UIViewController</span>, <span class="title class_ inherited__">WKNavigationDelegate</span>, <span class="title class_ inherited__">WKUIDelegate</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> webView: <span class="type">WKWebView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置 WKWebView</span></span><br><span class="line">        <span class="keyword">let</span> webConfiguration <span class="operator">=</span> <span class="type">WKWebViewConfiguration</span>()</span><br><span class="line">        <span class="comment">// 可以添加用户脚本、消息处理器等</span></span><br><span class="line"></span><br><span class="line">        webView <span class="operator">=</span> <span class="type">WKWebView</span>(frame: .zero, configuration: webConfiguration)</span><br><span class="line">        webView.navigationDelegate <span class="operator">=</span> <span class="keyword">self</span> <span class="comment">// 设置导航代理</span></span><br><span class="line">        webView.uiDelegate <span class="operator">=</span> <span class="keyword">self</span> <span class="comment">// 设置 UI 代理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 webView 添加到视图层级</span></span><br><span class="line">        view.addSubview(webView)</span><br><span class="line">        webView.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            webView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),</span><br><span class="line">            webView.leadingAnchor.constraint(equalTo: view.leadingAnchor),</span><br><span class="line">            webView.trailingAnchor.constraint(equalTo: view.trailingAnchor),</span><br><span class="line">            webView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载网页</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://www.example.com&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: url)</span><br><span class="line">            webView.load(request)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 或者加载 HTML 字符串</span></span><br><span class="line">        <span class="comment">// webView.loadHTMLString(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello WKWebView!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, baseURL: nil)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - WKNavigationDelegate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面开始加载时调用</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didStartProvisionalNavigation</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;页面开始加载&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面加载完成时调用</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFinish</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;页面加载完成&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面加载失败时调用</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">didFailProvisionalNavigation</span> <span class="params">navigation</span>: <span class="type">WKNavigation</span>!, <span class="params">withError</span> <span class="params">error</span>: <span class="type">Error</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;页面加载失败: <span class="subst">\(error.localizedDescription)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 决定是否允许导航</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">decidePolicyFor</span> <span class="params">navigationAction</span>: <span class="type">WKNavigationAction</span>, <span class="params">decisionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">WKNavigationActionPolicy</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> navigationAction.request.url &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;尝试导航到: <span class="subst">\(url.absoluteString)</span>&quot;</span>)</span><br><span class="line">            <span class="comment">// 可以在这里拦截 URL，例如打开外部应用，或阻止特定跳转</span></span><br><span class="line">            <span class="keyword">if</span> url.host <span class="operator">==</span> <span class="string">&quot;blockthisdomain.com&quot;</span> &#123;</span><br><span class="line">                decisionHandler(.cancel) <span class="comment">// 阻止导航</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(.allow) <span class="comment">// 允许导航</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - WKUIDelegate (处理 JavaScript 对话框，如 alert, confirm, prompt)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">webView</span>(<span class="keyword">_</span> <span class="params">webView</span>: <span class="type">WKWebView</span>, <span class="params">runJavaScriptAlertPanelWithMessage</span> <span class="params">message</span>: <span class="type">String</span>, <span class="params">initiatedByFrame</span> <span class="params">frame</span>: <span class="type">WKFrameInfo</span>, <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> alert <span class="operator">=</span> <span class="type">UIAlertController</span>(title: <span class="string">&quot;Alert&quot;</span>, message: message, preferredStyle: .alert)</span><br><span class="line">        alert.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">&quot;OK&quot;</span>, style: .default, handler: &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            completionHandler()</span><br><span class="line">        &#125;))</span><br><span class="line">        present(alert, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他 WKUIDelegate 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、核心功能与交互"><a href="#四、核心功能与交互" class="headerlink" title="四、核心功能与交互"></a>四、核心功能与交互</h2><h3 id="4-1-内容加载"><a href="#4-1-内容加载" class="headerlink" title="4.1 内容加载"></a>4.1 内容加载</h3><ul>
<li><strong>加载 URL</strong>：最常见的方式，直接加载一个远程或本地的 Web 页面。</li>
<li><strong>加载 HTML 字符串</strong>：将一段 HTML 字符串直接显示在 WebView 中，常用于显示静态文本或少量动态内容。</li>
<li><strong>加载本地文件</strong>：通过 <code>file:///android_asset/</code> (Android) 或 <code>Bundle.main.url(forResource:withExtension:)</code> (iOS) 加载应用内存储的 HTML、CSS、JS 文件。</li>
</ul>
<h3 id="4-2-JavaScript-与-Native-交互-JavaScript-Bridge"><a href="#4-2-JavaScript-与-Native-交互-JavaScript-Bridge" class="headerlink" title="4.2 JavaScript 与 Native 交互 (JavaScript Bridge)"></a>4.2 JavaScript 与 Native 交互 (JavaScript Bridge)</h3><p>这是 WebView 的核心功能之一，允许原生应用和 Web 页面相互调用对方的功能。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph &quot;原生应用 (Native App)&quot;
        NativeCode[原生代码]
    end

    subgraph WebView
        WebContainer[&quot;Web容器 (WebView)&quot;]
    end

    subgraph &quot;Web页面 (HTML&#x2F;JS)&quot;
        JSCode[JavaScript 代码]
    end

    NativeCode -- 1. 调用 evaluateJavascript&#x2F;&lt;br&gt;evaluateJavaScript --&gt; JSCode
    JSCode -- 2. 调用原生的 bridge 方法 --&gt; NativeCode

    WebContainer -- 封装 --&gt; JSCode
    NativeCode -- 封装 --&gt; WebContainer
  </pre></div>

<ul>
<li><p><strong>原生调用 JavaScript (Native to JS)</strong>：</p>
<ul>
<li><strong>Android</strong>：使用 <code>WebView.evaluateJavascript(script, callback)</code> (Android 4.4+) 或 <code>WebView.loadUrl(&quot;javascript:myFunction(&#39;param&#39;)&quot;)</code>。</li>
<li><strong>iOS</strong>：使用 <code>WKWebView.evaluateJavaScript(script, completionHandler:)</code>。</li>
<li><strong>示例 (JavaScript)：</strong> <code>window.myJsFunction(&#39;Hello from Native&#39;);</code></li>
</ul>
</li>
<li><p><strong>JavaScript 调用原生 (JS to Native)</strong>：</p>
<ul>
<li><strong>Android</strong>：<ul>
<li><strong><code>addJavascriptInterface</code></strong>：通过 <code>WebView.addJavascriptInterface(javaObject, &quot;Android&quot;)</code> 将一个 Java&#x2F;Kotlin 对象映射到 JavaScript 全局对象 (<code>window.Android</code>)。JavaScript 可以直接调用 <code>window.Android.myNativeMethod()</code>。</li>
<li><strong>安全风险</strong>：<code>addJavascriptInterface</code> 存在严重安全漏洞，可能被恶意 JavaScript 反射调用原生任意方法。<strong>强烈建议仅在 Android API 级别低于 17 时才使用，且需对被调用的方法进行严格安全检查。在 Android 17 (Jelly Bean MR1) 及以上，应该使用 <code>@JavascriptInterface</code> 注解，并且只暴露必要的方法。</strong></li>
<li><strong>推荐方案</strong>：拦截 URL 方案 (URL Scheme) 或者使用 <code>WebChromeClient</code> 的 <code>onJsPrompt</code> 方法进行通信。</li>
</ul>
</li>
<li><strong>iOS</strong>：<ul>
<li><strong><code>WKScriptMessageHandler</code></strong>：通过 <code>WKUserContentController</code> 注册消息处理器。JavaScript 通过 <code>window.webkit.messageHandlers.yourHandler.postMessage(&#39;Hello from JS&#39;)</code> 发送消息，原生应用通过 <code>userContentController(_:didReceive:)</code> 接收。这种方式比 Android 的 <code>addJavascriptInterface</code> 更安全。</li>
<li><strong>URL Scheme 拦截</strong>：与 Android 类似，JS 通过修改 <code>location.href</code> 或 <code>iframe.src</code> 发送特定格式的 URL，原生通过 <code>WKNavigationDelegate</code> 拦截并解析该 URL。</li>
</ul>
</li>
</ul>
<p><strong>JavaScript 示例 (调用原生)：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android (假设原生接口名为 &#x27;Android&#x27;)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">Android</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">Android</span>.<span class="property">callNativeMethod</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">Android</span>.<span class="title function_">callNativeMethod</span>(<span class="string">&#x27;参数数据&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS (假设消息处理器名为 &#x27;yourHandler&#x27;)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">webkit</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span>.<span class="property">yourHandler</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span>.<span class="property">yourHandler</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;someEvent&#x27;</span>, <span class="attr">data</span>: <span class="string">&#x27;hello&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用 URL Scheme 方式</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;myapp://native_method?param=value&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3-导航控制"><a href="#4-3-导航控制" class="headerlink" title="4.3 导航控制"></a>4.3 导航控制</h3><p>开发者可以通过实现 <code>WebViewClient</code> (Android) 或 <code>WKNavigationDelegate</code> (iOS) 的代理方法来拦截和控制 WebView 的导航行为。例如，阻止 WebView 加载某些 URL，或者将特定 URL 交给系统浏览器处理。</p>
<h3 id="4-4-Cookie-管理"><a href="#4-4-Cookie-管理" class="headerlink" title="4.4 Cookie 管理"></a>4.4 Cookie 管理</h3><p>WebView 默认支持 Cookie。Android 提供了 <code>CookieManager</code>，iOS 提供了 <code>HTTPCookieStorage</code>，可以用于设置、获取和清除 Cookie。</p>
<h3 id="4-5-文件上传与下载"><a href="#4-5-文件上传与下载" class="headerlink" title="4.5 文件上传与下载"></a>4.5 文件上传与下载</h3><p>需要通过 <code>WebChromeClient</code> (Android 的 <code>onShowFileChooser</code>) 或 <code>WKUIDelegate</code> (iOS 需自定义实现) 来处理文件选择器的弹出，并将用户选择的文件传递给 Web 页面。</p>
<h2 id="五、WebView-的典型应用场景"><a href="#五、WebView-的典型应用场景" class="headerlink" title="五、WebView 的典型应用场景"></a>五、WebView 的典型应用场景</h2><ol>
<li><strong>混合应用 (Hybrid Apps)</strong>：<ul>
<li>使用框架如 Cordova (PhoneGap), React Native (结合 <code>react-native-webview</code>), Flutter (结合 <code>webview_flutter</code>) 来开发跨平台应用，核心 UI 和逻辑使用 Web 技术，通过 WebView 渲染。</li>
</ul>
</li>
<li><strong>应用内浏览器 (In-App Browser)</strong>：<ul>
<li>当用户点击应用内的外部链接时，不是跳转到系统浏览器，而是在应用内部通过 WebView 打开，保持用户在应用内体验。</li>
</ul>
</li>
<li><strong>显示动态内容</strong>：<ul>
<li>用于加载营销活动页、广告页、公告通知、新闻资讯等需要频繁更新且无需发版的内容。</li>
</ul>
</li>
<li><strong>加载本地资源</strong>：<ul>
<li>显示应用内置的用户协议、帮助文档、HTML 动画等。</li>
</ul>
</li>
<li><strong>OAuth2 等授权登录流程</strong>：<ul>
<li>许多第三方登录（如微信、QQ、GitHub 授权）会跳转到授权页面，通过 WebView 加载这些页面并监听回调 URL 来获取授权码。</li>
</ul>
</li>
</ol>
<h2 id="六、WebView-的优缺点"><a href="#六、WebView-的优缺点" class="headerlink" title="六、WebView 的优缺点"></a>六、WebView 的优缺点</h2><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h3><ol>
<li><strong>跨平台与代码复用</strong>：可以使用一套 Web 代码库在 Android 和 iOS 上运行，大幅提高开发效率。</li>
<li><strong>动态更新</strong>：Web 内容可以随时更新，无需提交应用商店审核，即可实现功能迭代和 Bug 修复。</li>
<li><strong>快速迭代</strong>：Web 开发周期通常比原生短，适合快速原型开发和需求变更频繁的场景。</li>
<li><strong>开发成本低</strong>：Web 前端开发者可以无缝进入移动应用开发领域。</li>
<li><strong>内容丰富度</strong>：可以利用 Web 的强大表现力实现复杂的 UI 和交互效果。</li>
</ol>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h3><ol>
<li><strong>性能问题</strong>：<ul>
<li><strong>启动速度</strong>：WebView 的启动和渲染通常比原生组件慢。</li>
<li><strong>内存占用</strong>：WebView 是一个完整的浏览器内核，会消耗较多的内存和 CPU 资源。</li>
<li><strong>渲染流畅度</strong>：复杂或动画效果多的页面可能不如原生流畅。</li>
</ul>
</li>
<li><strong>用户体验差异</strong>：<ul>
<li>Web 组件的样式、手势、动画等可能与原生系统风格不一致，导致用户体验割裂。</li>
<li>键盘弹出、页面滚动等行为可能与原生有差异。</li>
</ul>
</li>
<li><strong>兼容性与稳定性</strong>：<ul>
<li>不同 Android 版本、不同手机厂商的 WebView 实现可能存在差异，导致兼容性问题。</li>
<li>WebView 崩溃可能导致整个应用崩溃 (尤其是在旧版 Android 或 <code>UIWebView</code> 上)。</li>
</ul>
</li>
<li><strong>安全性风险</strong>：<ul>
<li><strong>XSS (跨站脚本攻击)</strong>：恶意 JavaScript 代码可能注入并窃取用户数据或执行非法操作。</li>
<li><strong>JS Bridge 漏洞</strong>：不安全的 JavaScript 接口暴露可能被利用。</li>
<li><strong>本地文件访问</strong>：未严格限制的本地文件访问可能导致信息泄露。</li>
</ul>
</li>
<li><strong>功能限制</strong>：<ul>
<li>WebView 对原生硬件和系统 API 的直接访问能力有限，需要通过复杂的桥接机制。</li>
<li>缺乏原生组件的丰富性，部分复杂交互难以实现。</li>
</ul>
</li>
</ol>
<h2 id="七、安全性考虑与最佳实践"><a href="#七、安全性考虑与最佳实践" class="headerlink" title="七、安全性考虑与最佳实践"></a>七、安全性考虑与最佳实践</h2><p>由于 WebView 能够加载和执行外部内容，因此它引入了显著的安全风险。必须采取严格的安全措施。</p>
<h3 id="7-1-安全性考虑"><a href="#7-1-安全性考虑" class="headerlink" title="7.1 安全性考虑"></a>7.1 安全性考虑</h3><ol>
<li><strong>XSS (Cross-Site Scripting) 攻击</strong>：如果 WebView 加载的页面存在 XSS 漏洞，攻击者可以注入恶意 JavaScript 代码，窃取 Cookie、本地存储数据，甚至通过 JS Bridge 调用原生接口。</li>
<li><strong>JavaScript Bridge 漏洞</strong>：<ul>
<li><strong>Android <code>addJavascriptInterface</code> 滥用</strong>：在 Android 4.2 (API 17) 及以下版本，如果暴露的 Java 对象没有严格限制，恶意 JavaScript 可以通过反射机制调用任意 Java 对象的方法，造成严重的安全漏洞。即使在更新的版本中，不恰当的使用也可能导致问题。</li>
<li><strong>URL Scheme 劫持</strong>：攻击者可能伪造合法的 URL Scheme 请求，欺骗原生应用执行敏感操作。</li>
</ul>
</li>
<li><strong>本地文件访问漏洞</strong>：如果 WebView 被允许访问本地文件 (<code>file://</code> scheme)，恶意网页可能读取应用沙箱或其他敏感文件。</li>
<li><strong>不安全的证书校验</strong>：未正确校验 HTTPS 证书，可能导致中间人攻击。</li>
<li><strong>Cookie 共享与隔离</strong>：原生应用和 WebView 默认可能共享 Cookie，这在某些场景下可能造成安全隐患或会话劫持。</li>
<li><strong>WebView 劫持&#x2F;注入</strong>：在某些情况下，攻击者可以在 WebView 中注入恶意内容，或者劫持 WebView 的行为。</li>
</ol>
<h3 id="7-2-最佳实践"><a href="#7-2-最佳实践" class="headerlink" title="7.2 最佳实践"></a>7.2 最佳实践</h3><ol>
<li><strong>严格限制 JS 接口的暴露</strong>：<ul>
<li><strong>Android</strong>：<ul>
<li>避免在 API 17 及以下版本使用 <code>addJavascriptInterface</code>。</li>
<li>在 API 17 及以上版本，对暴露给 JavaScript 的 Java&#x2F;Kotlin 方法，必须使用 <code>@JavascriptInterface</code> 注解，并且只暴露绝对必要的方法。</li>
<li>通过 URL Scheme 拦截或 <code>onJsPrompt</code> 实现 JS 调用 Native，并对数据进行严格校验。</li>
</ul>
</li>
<li><strong>iOS</strong>：优先使用 <code>WKScriptMessageHandler</code>，对接收到的消息进行严格的类型和内容校验。</li>
</ul>
</li>
<li><strong>实施 URL 白名单机制</strong>：<ul>
<li>只允许 WebView 加载信任域名下的 URL。对于其他 URL，阻止加载或交由系统浏览器处理。</li>
<li>对通过 <code>shouldOverrideUrlLoading</code> (Android) 或 <code>decidePolicyForNavigationAction</code> (iOS) 拦截的 URL 进行严格校验。</li>
</ul>
</li>
<li><strong>禁用本地文件访问 (除非绝对必要)</strong>：<ul>
<li><strong>Android</strong>：<code>webView.settings.setAllowFileAccess(false)</code> 和 <code>webView.settings.setAllowContentAccess(false)</code>。</li>
<li><strong>iOS</strong>：WKWebView 默认限制了本地文件访问，但仍需谨慎处理 <code>file://</code> scheme。</li>
</ul>
</li>
<li><strong>始终使用 HTTPS 加载网页</strong>：<ul>
<li>确保 WebView 加载的所有 URL 都是 HTTPS。</li>
<li>正确实现 <code>onReceivedSslError</code> (Android) 或 <code>authenticationChallenge</code> (iOS) 并进行严格的证书校验，不轻易忽略 SSL 错误。</li>
</ul>
</li>
<li><strong>谨慎处理 Cookie</strong>：<ul>
<li>考虑 WebView 和原生应用之间的 Cookie 隔离策略。</li>
<li>对于敏感信息，避免通过 Cookie 传输，或确保 Cookie 具备 <code>HttpOnly</code> 和 <code>Secure</code> 属性。</li>
</ul>
</li>
<li><strong>及时更新 WebView 组件</strong>：<ul>
<li>在 Android 上，鼓励用户更新 Google Play System Updates，以确保 WebView 处于最新版本，从而获得最新的安全补丁。</li>
</ul>
</li>
<li><strong>限制 WebView 的能力</strong>：<ul>
<li>根据需求禁用不必要的功能，如 <code>JavaScript</code>、<code>DOM Storage</code>、<code>Plugins</code>、<code>File Access</code> 等。</li>
<li><code>webView.settings.setJavaScriptCanOpenWindowsAutomatically(false)</code> 禁用 JS 自动打开窗口。</li>
</ul>
</li>
<li><strong>错误处理和日志记录</strong>：<ul>
<li>捕获 WebView 加载和渲染过程中的错误，并记录日志，以便及时发现和解决问题。</li>
</ul>
</li>
<li><strong>User-Agent 标识</strong>：<ul>
<li>在 WebView 的 User-Agent 中添加特定标识，以便服务器区分来自原生应用的 WebView 请求和普通浏览器请求，并提供不同的内容或安全策略。</li>
</ul>
</li>
</ol>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>WebView 是一个功能强大且灵活的组件，它弥合了原生应用和 Web 技术之间的鸿沟，为移动应用带来了丰富的动态内容和开发效率。然而，其强大的能力也伴随着复杂的安全挑战。开发者在使用 WebView 时，必须对其工作原理、平台差异、尤其是潜在的安全风险有深入的理解，并严格遵循最佳实践，才能构建出稳定、高效且安全的应用。在性能和用户体验要求极高的场景下，仍需权衡选择原生开发；但在内容动态化、跨平台和快速迭代的场景中，WebView 依然是不可或缺的利器。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/26cdb2447b3d/">https://blog.tbf1211.xx.kg/26cdb2447b3d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2026/">2026</a><a class="post-meta__tags" href="/tags/WebView/">WebView</a><a class="post-meta__tags" href="/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/">移动开发</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-16.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/1d2a942bda1e/" title="Terraform 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Terraform 详解</div></div><div class="info-2"><div class="info-item-1"> Terraform 是由 HashiCorp 公司开发的一款开源基础设施即代码 (Infrastructure as Code, IaC) 工具。它允许用户通过声明式配置文件来定义、预置和管理云服务及其他基础设施资源，从而实现基础设施的自动化部署、版本控制和可重复性。  利用 Terraform，可以将基础设施（例如虚拟机、存储、网络、数据库等）编码为配置文件，然后通过统一的流程对这些基础设施进行部署、更新和销毁。这不仅提高了效率，减少了手动操作带来的错误，还使基础设施的变更可追踪、可审计，极大地改善了团队协作和运维能力。   一、为什么需要 Terraform？传统的IT基础设施管理通常涉及大量的人工操作，例如通过云服务提供商的控制台手动创建和配置资源。这种方式存在诸多问题：  效率低下且易出错：手动操作费时费力，且难以保证一致性，容易因人为失误导致配置漂移。 缺乏版本控制：基础设施的配置无法像应用代码一样进行版本管理，难以追踪历史变更和进行回滚。 环境不一致：在开发、测试和生产环境之间保持配置一致性成为难题。 难以扩展：面对大规模的基础设施部署和快速变化的需求时，手动管理模...</div></div></div></a><a class="pagination-related" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">AI 辅助编程的关键要点与代码幻觉防范</div></div><div class="info-2"><div class="info-item-1"> AI 辅助编程，通常指利用大型语言模型 (LLM) 如 GPT、Claude、Copilot 等来帮助开发者完成代码生成、代码补全、错误检查、文档编写等任务。它极大地提高了开发效率，但同时也引入了新的挑战，其中最突出的就是 “代码幻觉 (Code Hallucinations)”。代码幻觉是指 AI 生成了看似合理但实际上错误、不存在、或与需求不符的代码、API 调用或概念。  核心思想：AI 是强大的工具而非万能的替代品。在使用 AI 辅助编程时，开发者必须保持批判性思维，通过有效的“提示工程”和严谨的“人工验证”来驾驭 AI，防止其产生误导性的“代码幻觉”。   一、AI 辅助编程的核心优势与风险1.1 核心优势 提高效率：快速生成样板代码、函数骨架、测试用例等，减少重复劳动。 知识获取：作为“超级Stack Overflow”，快速查询 API 用法、框架最佳实践、算法实现等。 学习辅助：解释复杂代码、概念，帮助新手快速理解。 跨语言&#x2F;框架能力：在不熟悉的语言或框架中提供初步帮助。 重构与优化建议：提出改进代码结构、性能或可读性的建议。  1.2 主要风险 代码...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1d2a942bda1e/" title="Terraform 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-20</div><div class="info-item-2">Terraform 详解</div></div><div class="info-2"><div class="info-item-1"> Terraform 是由 HashiCorp 公司开发的一款开源基础设施即代码 (Infrastructure as Code, IaC) 工具。它允许用户通过声明式配置文件来定义、预置和管理云服务及其他基础设施资源，从而实现基础设施的自动化部署、版本控制和可重复性。  利用 Terraform，可以将基础设施（例如虚拟机、存储、网络、数据库等）编码为配置文件，然后通过统一的流程对这些基础设施进行部署、更新和销毁。这不仅提高了效率，减少了手动操作带来的错误，还使基础设施的变更可追踪、可审计，极大地改善了团队协作和运维能力。   一、为什么需要 Terraform？传统的IT基础设施管理通常涉及大量的人工操作，例如通过云服务提供商的控制台手动创建和配置资源。这种方式存在诸多问题：  效率低下且易出错：手动操作费时费力，且难以保证一致性，容易因人为失误导致配置漂移。 缺乏版本控制：基础设施的配置无法像应用代码一样进行版本管理，难以追踪历史变更和进行回滚。 环境不一致：在开发、测试和生产环境之间保持配置一致性成为难题。 难以扩展：面对大规模的基础设施部署和快速变化的需求时，手动管理模...</div></div></div></a><a class="pagination-related" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-07</div><div class="info-item-2">传统命令行工具的现代补强与替代方案详解</div></div><div class="info-2"><div class="info-item-1"> 随着技术的发展和用户体验需求的变化，许多经典的 Unix&#x2F;Linux 命令行工具虽然功能强大且稳定，但在交互性、可视化、性能和便捷性方面，逐渐暴露出一些局限性。为了提升命令行操作的效率、可读性和舒适度，社区涌现出大量用 Go、Rust 等现代语言编写的“补强”或“替代”工具。本文将详细介绍一系列旨在现代化命令行体验的工具。  核心思想：并非完全取代经典工具，而是通过提供更丰富的功能、更美观的输出、更快的执行速度和更友好的交互方式，来增强或补充传统命令行工具的能力，以适应现代开发和系统管理的需求。   一、文件查看与内容处理1.1 cat 的补强：bat 传统工具：cat (concatenate files and print on the standard output) 现代补强：bat bat 是 cat 的一个语法高亮、分页和 Git 集成增强版。它不仅能显示文件内容，还能： 语法高亮：对代码文件自动进行语法高亮显示，支持多种编程语言。 行号显示：默认显示行号，方便代码审查和定位。 Git 集成：在显示文件时，会自动显示 Git 变更标记（如新增、修改）。 分...</div></div></div></a><a class="pagination-related" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-01</div><div class="info-item-2">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</div></div><div class="info-2"><div class="info-item-1"> 在 Golang 中，内置的 map 类型不是并发安全的。当多个 goroutine 同时对 map 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 map，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 sync.Mutex 保护 map、使用 sync.RWMutex 保护 map，以及 Go 1.9 引入的 sync.Map，并对它们的特点、适用场景和性能进行对比分析。  核心问题：Go 内置 map 非并发安全。核心解决方案：  sync.Mutex：最简单粗暴，读写都加排他锁。 sync.RWMutex：读写分离锁，允许多个读操作并行，写操作独占。 sync.Map：专为读多写少、键不冲突或键值对持续增长的场景优化，内置无锁或乐观锁机制。     一、Go 内置 map 的并发问题Go 语言设计者有意将内置 map 设计为非并发安全的，主要出于以下考虑：  性能：为了避免在每次 map 操作时都承担锁的开销，从而在单线...</div></div></div></a><a class="pagination-related" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-28</div><div class="info-item-2">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</div></div><div class="info-2"><div class="info-item-1"> 随着现代 Web 应用的日益复杂，前端渲染模式也变得多样化，以应对不同的性能、SEO、用户体验和开发效率需求。本文将详细解析五种主要的前端渲染模式：客户端渲染 (Client-Side Rendering, CSR)、服务器端渲染 (Server-Side Rendering, SSR)、静态站点生成 (Static Site Generation, SSG)、增量静态再生 (Incremental Static Regeneration, ISR) 和 分布式持久化渲染 (Distributed Persistent Rendering, DPR)。理解这些模式有助于开发者根据项目需求做出最佳选择。  核心思想：这些渲染模式本质上是为了平衡加载速度 (Performance)、搜索引擎优化 (SEO)、首次内容绘制 (First Contentful Paint, FCP) 和可交互时间 (Time To Interactive, TTI)、以及开发复杂性与部署灵活性之间的权衡。   一、客户端渲染 (Client-Side Rendering, CSR)1.1 定义客户端渲...</div></div></div></a><a class="pagination-related" href="/fa3d796f3333/" title="MessagePack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-09</div><div class="info-item-2">MessagePack 详解</div></div><div class="info-2"><div class="info-item-1"> MessagePack 是一个高效的二进制序列化格式，它允许你在多种语言之间交换数据，就像 JSON 一样。但与 JSON 不同的是，MessagePack 以更紧凑的二进制形式表示数据，这通常使其具有更小的消息大小和更快的编码&#x2F;解码速度。它被设计为一个“像 JSON 但更快更小”的替代品，特别适用于网络协议、数据存储以及低功耗设备等对性能和带宽敏感的场景。  核心思想：将结构化数据（如对象、数组、基本类型）编码成紧凑的二进制流，以实现高效的数据传输和存储。   一、什么是 MessagePack？MessagePack 是一种基于二进制的数据交换格式，其设计目标是高效、紧凑和跨语言兼容。它通过一种优化的二进制表示来序列化各种数据类型，包括整数、浮点数、字符串、二进制数据、数组和映射。其官方网站将其描述为“一个整洁、紧凑的二进制序列化格式”。 与文本格式（如 JSON）相比，MessagePack 的主要优势在于：  更小的消息尺寸：通过减少冗余信息并直接使用二进制表示数据类型，MessagePack 生成的数据通常比同等 JSON 数据小。 更快的处理速度：由于节省...</div></div></div></a><a class="pagination-related" href="/7a02193c3680/" title="React Native 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="info-item-2">React Native 详解</div></div><div class="info-2"><div class="info-item-1"> React Native 是 Facebook（现 Meta）于 2015 年推出的一个开源移动应用开发框架。它允许开发者使用 JavaScript 和 React 编写代码，同时将应用编译为原生 (Native) 的 iOS 和 Android 应用。其核心理念是“Learn once, write anywhere”——开发者只需学习一套技术栈（React 和 JavaScript），即可构建在多个平台运行的移动应用。  核心思想： React Native 并非将 Web 应用打包为移动应用（如 Cordova&#x2F;Ionic），而是通过 JavaScript 桥接，将 React 组件转换为真正的原生 UI 组件，从而提供接近原生应用的性能和用户体验，同时享受前端开发的高效率。   一、为什么选择 React Native？传统的移动应用开发通常需要为 iOS（使用 Swift&#x2F;Objective-C）和 Android（使用 Java&#x2F;Kotlin）分别编写两套代码，维护成本高昂。React Native 旨在解决这一痛点，提供以下核心优势：...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-WebView%EF%BC%9F"><span class="toc-text">一、什么是 WebView？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81WebView-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、WebView 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BB%E6%B5%81%E5%B9%B3%E5%8F%B0%E7%9A%84-WebView-%E5%AE%9E%E7%8E%B0"><span class="toc-text">三、主流平台的 WebView 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Android-WebView"><span class="toc-text">3.1 Android WebView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-iOS-WKWebView"><span class="toc-text">3.2 iOS WKWebView</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BA%A4%E4%BA%92"><span class="toc-text">四、核心功能与交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%86%85%E5%AE%B9%E5%8A%A0%E8%BD%BD"><span class="toc-text">4.1 内容加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-JavaScript-%E4%B8%8E-Native-%E4%BA%A4%E4%BA%92-JavaScript-Bridge"><span class="toc-text">4.2 JavaScript 与 Native 交互 (JavaScript Bridge)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6"><span class="toc-text">4.3 导航控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Cookie-%E7%AE%A1%E7%90%86"><span class="toc-text">4.4 Cookie 管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="toc-text">4.5 文件上传与下载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81WebView-%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、WebView 的典型应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81WebView-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">六、WebView 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BC%98%E7%82%B9"><span class="toc-text">6.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">6.2 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">七、安全性考虑与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">7.1 安全性考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">7.2 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-16.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>