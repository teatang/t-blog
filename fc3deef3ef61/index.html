<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>构建工具 Gradle 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化构建工具。它使用 Groovy 语言（或 Kotlin DSL）来编写构建脚本，提供了一种声明式和命令式兼备的强大构建方式。Gradle 融合了 Ant 的灵活性和 Maven 的约定式管理及依赖管理能力，旨在为多项目构建提供更强大的支持、更高的性能和更灵活的配置。  核心思想：Gradle 采用 基于">
<meta property="og:type" content="article">
<meta property="og:title" content="构建工具 Gradle 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/fc3deef3ef61/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化构建工具。它使用 Groovy 语言（或 Kotlin DSL）来编写构建脚本，提供了一种声明式和命令式兼备的强大构建方式。Gradle 融合了 Ant 的灵活性和 Maven 的约定式管理及依赖管理能力，旨在为多项目构建提供更强大的支持、更高的性能和更灵活的配置。  核心思想：Gradle 采用 基于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg">
<meta property="article:published_time" content="2023-06-10T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-08T08:10:25.579Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="项目构建">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="包管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "构建工具 Gradle 详解",
  "url": "https://blog.tbf1211.xx.kg/fc3deef3ef61/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg",
  "datePublished": "2023-06-10T22:24:00.000Z",
  "dateModified": "2026-01-08T08:10:25.579Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/fc3deef3ef61/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '构建工具 Gradle 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">477</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">231</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">82</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-07.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">构建工具 Gradle 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">构建工具 Gradle 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-10T22:24:00.000Z" title="发表于 2023-06-11 06:24:00">2023-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/">项目构建</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Gradle</strong> 是一个基于 Apache Ant 和 Apache Maven 概念的<strong>项目自动化构建工具</strong>。它使用 Groovy 语言（或 Kotlin DSL）来编写构建脚本，提供了一种声明式和命令式兼备的强大构建方式。Gradle 融合了 Ant 的灵活性和 Maven 的约定式管理及依赖管理能力，旨在为多项目构建提供更强大的支持、更高的性能和更灵活的配置。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：Gradle 采用 <strong>基于 Groovy&#x2F;Kotlin DSL 的脚本</strong> 来定义构建逻辑，结合了 <strong>增量编译</strong> 和 <strong>构建缓存</strong> 技术，以实现高性能。它通过 <strong>自定义任务和插件</strong> 提供了极高的灵活性，同时通过 <strong>约定优于配置</strong> 的原则降低了复杂性。</p>
</div>
<hr>
<h2 id="一、为什么需要-Gradle？"><a href="#一、为什么需要-Gradle？" class="headerlink" title="一、为什么需要 Gradle？"></a>一、为什么需要 Gradle？</h2><p>尽管 Maven 在 Java 项目构建中取得了巨大成功，但它也存在一些局限性，促使了 Gradle 的出现和流行：</p>
<ol>
<li><strong>Maven 的 XML 配置冗长复杂</strong>：<ul>
<li><code>pom.xml</code> 文件随着项目规模的增长会变得非常庞大和难以阅读。</li>
<li>XML 配置相比于编程语言，表达能力有限，实现复杂逻辑时会很繁琐。</li>
</ul>
</li>
<li><strong>Maven 的灵活性不足</strong>：<ul>
<li>Maven 严格遵循“约定优于配置”，虽然简化了常见场景，但在需要定制化构建逻辑时，Maven 的插件扩展机制和生命周期钩子相对笨拙。</li>
</ul>
</li>
<li><strong>Maven 的性能问题</strong>：<ul>
<li>Maven 不支持增量编译。每次构建都会编译所有需要编译的源文件，即使只有少量更改。</li>
<li>Maven 的多模块构建在某些情况下可能效率不高。</li>
</ul>
</li>
</ol>
<p>Gradle 旨在解决这些痛点，提供一个<strong>更强大、更灵活、更高效</strong>的构建工具：</p>
<ul>
<li><strong>声明式与命令式结合的脚本 (Groovy&#x2F;Kotlin DSL)</strong>：<ul>
<li>使用 Groovy 或 Kotlin 脚本来定义构建逻辑，相比 XML 更简洁、更具表现力。</li>
<li>既能声明性地定义项目结构和依赖，也能命令性地编写复杂的自定义任务。</li>
</ul>
</li>
<li><strong>出色的性能</strong>：<ul>
<li>支持<strong>增量编译</strong> (Incremental Builds)：只编译发生变化的文件，显著提升编译速度。</li>
<li>支持<strong>构建缓存</strong> (Build Cache)：可以复用之前构建的输出，甚至是其他机器上的构建结果。</li>
<li>支持<strong>并行执行</strong>：并发执行相互独立的任务。</li>
</ul>
</li>
<li><strong>灵活的多项目构建</strong>：<ul>
<li>天生为多项目（多模块）构建设计，管理复杂的多模块结构更加简单高效。</li>
</ul>
</li>
<li><strong>强大的可扩展性</strong>：<ul>
<li>一切皆任务 (Task)：可以轻松创建自定义任务和插件。</li>
<li>丰富的插件生态系统。</li>
</ul>
</li>
<li><strong>兼容 Maven 仓库</strong>：<ul>
<li>可以无缝使用 Maven 的依赖管理体系和中央仓库。</li>
</ul>
</li>
<li><strong>平滑迁移</strong>：<ul>
<li>支持 Maven 的 <code>pom.xml</code> 文件作为依赖管理，使从 Maven 迁移到 Gradle 更加容易。</li>
</ul>
</li>
</ul>
<h2 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h2><h3 id="2-1-Project-和-Task"><a href="#2-1-Project-和-Task" class="headerlink" title="2.1 Project 和 Task"></a>2.1 Project 和 Task</h3><p>Gradle 将所有构建过程抽象为<strong>项目 (Project)</strong> 和<strong>任务 (Task)</strong>。</p>
<ul>
<li><strong>Project (项目)</strong>：<ul>
<li>在 Gradle 中，每一个 <code>build.gradle</code> 文件都代表一个 Project。</li>
<li>一个 Project 通常对应一个可独立部署的组件（如 JAR 包、WAR 包、Web 应用），或是一个聚合其他 Project 的父模块。</li>
<li>Project 包含了一系列 Task。</li>
</ul>
</li>
<li><strong>Task (任务)</strong>：<ul>
<li>Task 是 Gradle 构建的基本执行单元，例如编译源代码、运行测试、打包 JAR 文件、生成文档等。</li>
<li>每个 Task 都有一个名称，并定义了要执行的特定操作。</li>
<li>Task 可以有依赖关系，Gradle 会根据依赖顺序执行 Task。</li>
</ul>
</li>
</ul>
<p><strong><code>build.gradle</code> 示例 (Groovy DSL)</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个插件</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span> <span class="comment">// 应用 Java 插件，自带编译、测试、打包等任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义项目的分组、名称和版本</span></span><br><span class="line">group <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 Java 版本</span></span><br><span class="line">java &#123;</span><br><span class="line">    sourceCompatibility = <span class="string">&#x27;17&#x27;</span></span><br><span class="line">    targetCompatibility = <span class="string">&#x27;17&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仓库配置，Gradle 会从这里查找依赖</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral() <span class="comment">// 使用 Maven Central 仓库</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖配置</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 编译时依赖</span></span><br><span class="line">    implementation <span class="string">&#x27;org.slf4j:slf4j-api:2.0.7&#x27;</span></span><br><span class="line">    <span class="comment">// 测试时依赖</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.10.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.10.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Task (命令式写法)</span></span><br><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123; <span class="comment">// 定义 Task 要执行的动作</span></span><br><span class="line">        println <span class="string">&#x27;Hello from Gradle Task!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个自定义 Task，依赖于 &#x27;hello&#x27; Task</span></span><br><span class="line">task goodbye(<span class="attr">type:</span> MyCustomTask) &#123;</span><br><span class="line">    message = <span class="string">&#x27;Goodbye from custom task!&#x27;</span></span><br><span class="line">    dependsOn hello <span class="comment">// goodbye 任务依赖于 hello 任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomTask</span> <span class="keyword">extends</span> <span class="title class_">DefaultTask</span> &#123;</span><br><span class="line">    <span class="meta">@Input</span> <span class="keyword">var</span> message = <span class="string">&quot;Default message&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    fun run() &#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-构建脚本-Build-Scripts"><a href="#2-2-构建脚本-Build-Scripts" class="headerlink" title="2.2 构建脚本 (Build Scripts)"></a>2.2 构建脚本 (Build Scripts)</h3><p>Gradle 构建脚本使用 Groovy 或 Kotlin DSL (Domain Specific Language) 编写，通常位于 <code>build.gradle</code> 文件中。</p>
<ul>
<li><strong>Groovy DSL (默认)</strong>：基于 Groovy 语言，语法灵活，支持省略括号、点号等。</li>
<li><strong>Kotlin DSL (推荐)</strong>：基于 Kotlin 语言，提供更强大的 IDE 支持 (代码补全、类型安全、重构)，逐渐成为主流。文件名为 <code>build.gradle.kts</code>。</li>
</ul>
<p><strong>Kotlin DSL 示例</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins 块使用 `plugins &#123; ... &#125;` 而不是 `apply plugin: &#x27;...&#x27;`</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    java</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">&quot;com.example&quot;</span></span><br><span class="line">version = <span class="string">&quot;1.0-SNAPSHOT&quot;</span></span><br><span class="line"></span><br><span class="line">java &#123;</span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_17</span><br><span class="line">    targetCompatibility = JavaVersion.VERSION_17</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.slf4j:slf4j-api:2.0.7&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.junit.jupiter:junit-jupiter-api:5.10.0&quot;</span>)</span><br><span class="line">    testRuntimeOnly(<span class="string">&quot;org.junit.jupiter:junit-jupiter-engine:5.10.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin DSL 中定义任务通常使用 `tasks.register`</span></span><br><span class="line">tasks.register(<span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello from Gradle Task (Kotlin)!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-插件-Plugins"><a href="#2-3-插件-Plugins" class="headerlink" title="2.3 插件 (Plugins)"></a>2.3 插件 (Plugins)</h3><p>Gradle 的核心功能也是通过<strong>插件</strong>实现的。插件可以向项目添加新的 Task、配置约定、扩展现有 Task 等。</p>
<ul>
<li><strong>核心插件</strong>：如 <code>java</code> (编译、测试 Java 代码), <code>application</code> (支持可执行 JAR), <code>war</code> (构建 Web 应用)。</li>
<li><strong>常用插件</strong>：<code>spring-boot</code> (Spring Boot 项目), <code>idea</code> (生成 IntelliJ IDEA 项目文件), <code>kotlin</code> (Kotlin 项目)。</li>
</ul>
<p>应用插件的方式：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Groovy DSL</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;3.2.0&#x27;</span> <span class="comment">// 外部插件需要指定版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者旧式写法</span></span><br><span class="line"><span class="comment">// apply plugin: &#x27;java&#x27;</span></span><br><span class="line"><span class="comment">// apply plugin: &#x27;war&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin DSL</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    java</span><br><span class="line">    id(<span class="string">&quot;org.springframework.boot&quot;</span>) version <span class="string">&quot;3.2.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-依赖管理-Dependency-Management"><a href="#2-4-依赖管理-Dependency-Management" class="headerlink" title="2.4 依赖管理 (Dependency Management)"></a>2.4 依赖管理 (Dependency Management)</h3><p>Gradle 的依赖管理功能与 Maven 类似，但更加灵活。它也可以从 Maven 仓库、JCenter 或其他自定义仓库下载依赖。</p>
<ul>
<li><strong>依赖配置块</strong>：<code>dependencies &#123; ... &#125;</code></li>
<li><strong>依赖类型 (或称为配置)</strong>：<ul>
<li><code>implementation</code> (推荐)：用于编译和运行时，不会将 API 暴露给依赖此模块的模块，有助于更快的增量编译。</li>
<li><code>api</code>：用于编译和运行时，会将 API 暴露给依赖此模块的模块，类似于旧的 <code>compile</code> 作用。</li>
<li><code>compileOnly</code>：只在编译时需要，包不会被打包进最终构件。</li>
<li><code>runtimeOnly</code>：只在运行时需要，编译时不需要。</li>
<li><code>testImplementation</code>：测试编译和运行时需要。</li>
<li><code>testRuntimeOnly</code>：测试运行时需要。</li>
<li><code>annotationProcessor</code>：用于注解处理器。</li>
</ul>
</li>
</ul>
<p><strong>依赖的声明方式</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Groovy DSL</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;groupId:artifactId:version&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.10.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">``````kotlin</span><br><span class="line"><span class="comment">// Kotlin DSL (通常字符串需要双引号，且推荐使用 `()`)</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;groupId:artifactId:version&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.junit.jupiter:junit-jupiter-api:5.10.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>依赖冲突解决</strong>：<br>Gradle 会自动尝试解决依赖冲突，默认会选择最新版本。你也可以手动进行配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123;</span><br><span class="line">        <span class="comment">// 强制使用某个版本</span></span><br><span class="line">        force <span class="string">&#x27;com.google.guava:guava:32.0.0-jre&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排除某个传递性依赖</span></span><br><span class="line">        eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">            <span class="keyword">if</span> (details.requested.group == <span class="string">&#x27;org.slf4j&#x27;</span> &amp;&amp; details.requested.name == <span class="string">&#x27;slf4j-api&#x27;</span>) &#123;</span><br><span class="line">                details.useVersion <span class="string">&#x27;2.0.7&#x27;</span> <span class="comment">// 强制 slf4j-api 使用 2.0.7</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Gradle-构建流程与结构"><a href="#三、Gradle-构建流程与结构" class="headerlink" title="三、Gradle 构建流程与结构"></a>三、Gradle 构建流程与结构</h2><h3 id="3-1-标准目录结构"><a href="#3-1-标准目录结构" class="headerlink" title="3.1 标准目录结构"></a>3.1 标准目录结构</h3><p>类似于 Maven，Gradle 也有其推荐的项目布局：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">project-root/</span><br><span class="line">├── build.gradle              &lt;- 根项目的构建脚本 (Groovy DSL)</span><br><span class="line">├── settings.gradle           &lt;- 声明项目的子模块</span><br><span class="line">├── gradelew                  &lt;- Gradle Wrapper 脚本 (Linux/macOS)</span><br><span class="line">├── gradlew.bat               &lt;- Gradle Wrapper 脚本 (Windows)</span><br><span class="line">├── .gradle/                  &lt;- Gradle 缓存目录</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/                 &lt;- 主代码和资源文件</span><br><span class="line">│   │   ├── java/             &lt;- Java 源代码</span><br><span class="line">│   │   ├── resources/        &lt;- 资源文件</span><br><span class="line">│   │   └── webapp/           &lt;- Web 应用根目录 (仅适用于 war 包)</span><br><span class="line">│   └── test/                 &lt;- 测试代码和资源文件</span><br><span class="line">│       ├── java/             &lt;- Java 测试源代码</span><br><span class="line">│       └── resources/        &lt;- 测试资源文件</span><br><span class="line">└── build/                    &lt;- 构建输出目录，由 Gradle 自动生成</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Gradle-Wrapper"><a href="#3-2-Gradle-Wrapper" class="headerlink" title="3.2 Gradle Wrapper"></a>3.2 Gradle Wrapper</h3><p>Gradle Wrapper (gradlew) 是推荐的 Gradle 使用方式。它允许你在没有预先安装 Gradle 的机器上运行 Gradle 构建。</p>
<ul>
<li>Wrapper 负责下载和安装指定版本的 Gradle。</li>
<li>确保所有开发者使用相同版本的 Gradle 进行构建，避免“在我机器上跑得好好的”问题。</li>
<li>使用 <code>gradlew</code> (Linux&#x2F;macOS) 或 <code>gradlew.bat</code> (Windows) 命令而不是 <code>gradle</code> 命令来执行构建。</li>
</ul>
<h3 id="3-3-多项目构建-Multi-Project-Builds"><a href="#3-3-多项目构建-Multi-Project-Builds" class="headerlink" title="3.3 多项目构建 (Multi-Project Builds)"></a>3.3 多项目构建 (Multi-Project Builds)</h3><p>Gradle 多项目构建的核心是 <code>settings.gradle</code> (settings.gradle.kts) 文件。</p>
<ul>
<li><code>settings.gradle</code> 负责定义项目的结构，通过 <code>include</code> 方法声明子模块。</li>
<li>每个子模块都有自己的 <code>build.gradle</code> 文件。</li>
<li>根目录的 <code>build.gradle</code> 可以定义所有子模块的公共配置。</li>
</ul>
<p><strong><code>settings.gradle</code> 示例</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">&#x27;my-multi-project&#x27;</span></span><br><span class="line">include <span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;library&#x27;</span> <span class="comment">// 包含 app 和 library 两个子模块</span></span><br></pre></td></tr></table></figure>
<p><strong><code>build.gradle</code> (根目录)</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subprojects &#123; <span class="comment">// 为所有子模块应用此配置</span></span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        implementation <span class="string">&#x27;org.slf4j:slf4j-api:2.0.7&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-构建生命周期"><a href="#3-4-构建生命周期" class="headerlink" title="3.4 构建生命周期"></a>3.4 构建生命周期</h3><p>Gradle 的构建生命周期分为三个阶段：</p>
<ol>
<li><strong>初始化 (Initialization)</strong>：<ul>
<li><code>settings.gradle</code> 和 <code>settings.gradle.kts</code> 文件被执行。</li>
<li>确定哪些 Project 参与构建，并创建对应的 Project 实例。</li>
</ul>
</li>
<li><strong>配置 (Configuration)</strong>：<ul>
<li>所有 Project 的 <code>build.gradle</code> 或 <code>build.gradle.kts</code> 文件被执行。</li>
<li>解析所有 Task、它们的属性和依赖关系。</li>
<li>这是构建脚本的主要执行阶段。</li>
</ul>
</li>
<li><strong>执行 (Execution)</strong>：<ul>
<li>根据配置阶段解析的 Task 依赖图，Gradle 执行请求的 Task 及其依赖的 Task。</li>
<li>这个阶段会应用增量编译和构建缓存等优化。</li>
</ul>
</li>
</ol>
<h2 id="四、常用-Gradle-命令"><a href="#四、常用-Gradle-命令" class="headerlink" title="四、常用 Gradle 命令"></a>四、常用 Gradle 命令</h2><ul>
<li><code>./gradlew tasks</code>：列出所有可用的 Task。</li>
<li><code>./gradlew build</code>：执行默认的 <code>build</code> Task，通常会编译、测试、打包。</li>
<li><code>./gradlew clean</code>：清理构建输出目录。</li>
<li><code>./gradlew test</code>：运行所有测试。</li>
<li><code>./gradlew jar</code>：打包 JAR 文件。</li>
<li><code>./gradlew run</code>：运行应用 (如果应用了 <code>application</code> 插件)。</li>
<li><code>./gradlew --info</code> &#x2F; <code>./gradlew --debug</code>：显示更详细的日志信息。</li>
<li><code>./gradlew --stop</code>：停止 Gradle Daemon (后台进程)。</li>
<li><code>./gradlew help --task &lt;taskName&gt;</code>：获取指定 Task 的帮助信息。</li>
<li>在多模块项目中，可以在子模块目录执行 <code>./gradlew &lt;taskName&gt;</code>，或在根目录执行 <code>./gradlew :&lt;moduleName&gt;:&lt;taskName&gt;</code>。</li>
</ul>
<h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><ul>
<li><strong>Gradle Daemon</strong>：一个后台进程，启动一次后可以重复使用，避免了每次构建都重新启动 JVM，显著加快后续构建速度。</li>
<li><strong>构建缓存 (Build Cache)</strong>：缓存构建任务的输入和输出。如果任务的输入没有变化，Gradle 可以直接复用缓存中的输出，而无需重新执行任务。可以配置本地缓存和远程缓存。</li>
<li><strong>增量构建 (Incremental Build)</strong>：Gradle 会跟踪输入文件，只有当输入文件发生变化时才重新执行任务。</li>
<li><strong>配置优化</strong>：优化脚本，避免在配置阶段执行耗时操作。</li>
</ul>
<h2 id="六、与-Maven-的比较"><a href="#六、与-Maven-的比较" class="headerlink" title="六、与 Maven 的比较"></a>六、与 Maven 的比较</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Maven</th>
<th align="left">Gradle</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>构建脚本</strong></td>
<td align="left">XML (pom.xml)</td>
<td align="left">Groovy DSL (build.gradle) 或 Kotlin DSL (build.gradle.kts)</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">约定优于配置，不够灵活，定制化困难。</td>
<td align="left">灵活度高，可轻松定制任务和插件，Groovy&#x2F;Kotlin 编程能力。</td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left">XML 冗长，层级多。</td>
<td align="left">DSL 更简洁，更易读，但需要熟悉 Groovy&#x2F;Kotlin 语法。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">仅支持全量编译，无构建缓存，速度相对较慢。</td>
<td align="left">支持增量编译、构建缓存、Gradle Daemon，速度通常更快。</td>
</tr>
<tr>
<td align="left"><strong>多模块</strong></td>
<td align="left">基于父 POM 继承，配置较复杂。</td>
<td align="left">基于 <code>settings.gradle</code> 和 <code>subprojects()</code> 实现，更灵活高效。</td>
</tr>
<tr>
<td align="left"><strong>依赖管理</strong></td>
<td align="left">良好，基于 XML。</td>
<td align="left">强大，基于 DSL，提供更多控制，如依赖冲突解决策略、排除传递依赖等。</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">相对平缓，主要学习 XML 结构和生命周期。</td>
<td align="left">steeper，需要掌握 Groovy&#x2F;Kotlin 语法和 Gradle DSL 概念。</td>
</tr>
<tr>
<td align="left"><strong>IDE 支持</strong></td>
<td align="left">广泛且成熟。</td>
<td align="left">良好，特别是 Kotlin DSL 带来了更好的 IDE 体验。</td>
</tr>
</tbody></table>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Gradle 是一个现代化、高性能、高度灵活的 Java 项目构建工具。它通过引入 Groovy&#x2F;Kotlin DSL、增量编译、构建缓存和强大的插件机制，解决了 Maven 在灵活性和性能方面的不足。</p>
<p>对于追求极致构建性能、需要高度定制化构建逻辑、或管理复杂多模块项目的开发者而言，Gradle 是一个非常理想的选择。它在 Android 开发领域已成为事实标准，并在 Java 后端和微服务领域越来越受欢迎。虽然其学习曲线可能比 Maven 略陡峭，但它带来的强大功能和效率提升绝对值得投入学习。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/fc3deef3ef61/">https://blog.tbf1211.xx.kg/fc3deef3ef61/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/">项目构建</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/">包管理</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-07.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f52f9b242f1c/" title="Python装饰器详解：从基础到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python装饰器详解：从基础到高级应用</div></div><div class="info-2"><div class="info-item-1"> Python 装饰器 (Decorators) 是一种高级的 Python 语法糖，它允许你在不修改原始函数定义的情况下，增强或修改函数的功能。装饰器本质上是一个 Python 函数，它接收一个函数作为参数，并返回一个修改后或增强后的新函数。它们是实现“开闭原则”（对扩展开放，对修改关闭）的重要工具，常用于日志记录、性能测试、事务处理、权限验证等场景，属于面向切面编程 (AOP) 的范畴。  核心思想：装饰器是“函数套函数”的语法糖，通过闭包的特性，在不改变被装饰函数代码的情况下，为其添加预处理、后处理或其他功能。    一、理解装饰器前的预备知识要真正理解装饰器，我们需要先掌握几个 Python 核心概念： 1.1 函数是第一类对象 (First-Class Objects)在 Python 中，函数与其他数据类型（如整数、字符串）一样，是第一类对象。这意味着你可以：  将函数赋值给变量 将函数作为参数传递给其他函数 将函数作为另一个函数的返回值 在数据结构中存储函数  示例： 123456789101112131415161718192021def greet(name):...</div></div></div></a><a class="pagination-related" href="/06bc4d655ced/" title="Python Beautiful Soup详解：高效网页数据抓取与解析利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python Beautiful Soup详解：高效网页数据抓取与解析利器</div></div><div class="info-2"><div class="info-item-1"> Beautiful Soup 是一个 Python 库，用于从 HTML 或 XML 文件中提取数据。它通过解析文档并提供用于导航、搜索和修改解析树的 Pythonic 接口，将复杂的 HTML&#x2F;XML 文档转化为易于处理的数据结构。Beautiful Soup 与 requests 等 HTTP 库结合使用，是构建网络爬虫进行数据抓取的强大工具。  核心思想：Beautiful Soup 将杂乱的 HTML&#x2F;XML 文档“煲成一锅美味的汤”，让你能够轻松地在其中挑选出你需要的数据元素，如同在厨房里筛选食材一样简单。   一、为什么需要 Beautiful Soup？在网络上，大量有价值的信息以 HTML 页面的形式存在。如果我们需要从这些页面中获取结构化数据（例如，产品信息、新闻标题、评论内容），直接操作原始的 HTML 字符串是非常困难和脆弱的。传统的字符串查找和正则表达式虽然可行，但存在以下问题：  HTML 结构复杂：HTML 标签嵌套层级深，结构不规则，使用正则表达式难以精确匹配。 HTML 容错性：浏览器会自动纠正不规范的 HTML 结构，但正则...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/5febe994b52e/" title="Java 构建工具 Maven 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">Java 构建工具 Maven 详解</div></div><div class="info-2"><div class="info-item-1"> Apache Maven (Maven) 是一个强大的项目管理和构建自动化工具，主要服务于基于 Java 的项目。它遵循约定优于配置 (Convention over Configuration) 的原则，提供了一个标准化的项目结构和生命周期，用于编译、测试、打包、部署等任务。Maven 的核心目标是让项目构建过程标准化、可预测且易于维护，同时提供强大的依赖管理功能。  核心思想：Maven 将项目视为一系列相互依赖的模块，通过一个声明式的 XML 文件 (pom.xml) 来管理项目的构建、报告和文档。它推崇一套标准的项目布局和生命周期，从而减少开发者在配置上的工作量。   一、为什么需要 Maven？在 Maven 出现之前，Java 项目的构建和管理通常面临诸多挑战：  依赖管理混乱： 项目所需的所有第三方 JAR 包都需要手动下载并添加到项目的 classpath 中。 如果多个项目使用相同库的不同版本，容易引发冲突 (JAR Hell)。 依赖的依赖（传递性依赖）管理起来更加复杂。   构建过程非标准化： 不同的项目可能有不同的构建脚本 (如 Ant)，导致构建步骤不...</div></div></div></a><a class="pagination-related" href="/be930ce35928/" title="Java 常用设计模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-30</div><div class="info-item-2">Java 常用设计模式详解</div></div><div class="info-2"><div class="info-item-1"> 设计模式 (Design Patterns) 是在软件工程中，针对特定问题场景提出的一套经过验证的、可复用的解决方案。它们是从实践中总结出来的，是软件开发过程中的最佳实践。学习和应用设计模式，可以帮助开发者构建出结构清晰、可维护、可扩展、复用性强的软件系统，同时也能促进团队成员之间的沟通。  核心思想：设计模式的目标是提升软件的灵活性 (Flexibility)、可重用性 (Reusability) 和可扩展性 (Extensibility)，同时降低维护成本 (Maintainability)。它们不是代码，而是解决特定问题的思想和方法。   一、设计模式的分类根据 GoF (Gang of Four，《设计模式：可复用面向对象软件的基础》的四位作者) 的经典分类，设计模式主要分为三类：  创建型模式 (Creational Patterns)： 关注对象的创建机制，目标是解耦对象的创建与使用，从而提供更大的灵活性。 包括：单例 (Singleton)、工厂方法 (Factory Method)、抽象工厂 (Abstract Factory)、建造者 (Builder)、原型...</div></div></div></a><a class="pagination-related" href="/396257856dc6/" title="Java Collections Framework 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="info-item-2">Java Collections Framework 详解</div></div><div class="info-2"><div class="info-item-1"> Java Collections Framework (JCF) 是 Java 语言中一套标准的接口、类和算法的集合，用于存储和操作对象组。它提供了一系列高性能的数据结构实现，如列表、集合、映射等，这些数据结构被精心设计以满足各种常见的数据存储和检索需求。JCF 旨在统一管理、操作对象集合的 API，提高 Java 程序的生产力和性能。  核心思想：JCF 提供了一致的 API 来处理不同类型的数据结构，如列表、集合和映射，并与用于操作这些结构的标准算法（排序、搜索等）相结合。它允许开发者专注于业务逻辑，而不是底层数据结构的实现细节。   一、JCF 的发展历程与目的在 JCF 出现之前 (即 JDK 1.2 之前)，Java 提供了 Vector、Hashtable 等线程安全的旧式集合类，以及数组。这些类功能有限，API 不统一，且缺乏泛型支持，使用起来不便。 JCF 的引入旨在解决以下问题：  统一 API：提供一套统一的接口和类，使得操作不同类型的集合具有相似的代码模式。 提高性能：提供高效的数据结构实现，并利用算法优化常见操作。 减少学习成本：开发者只需学习一套 AP...</div></div></div></a><a class="pagination-related" href="/62acbead38d8/" title="Python 打包工具 uv 详解：下一代包管理器与构建器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-12</div><div class="info-item-2">Python 打包工具 uv 详解：下一代包管理器与构建器</div></div><div class="info-2"><div class="info-item-1"> uv 是由 Astral 公司开发的一款高性能 Rust 实现的 Python 包安装器和解析器，旨在全面替代 pip、pip-tools 和 virtualenv。它以其惊人的速度、严谨的兼容性和现代化功能，正迅速成为 Python 生态系统中的一个重要工具。  核心思想：提供一个单一、快速且可靠的命令行工具，覆盖 Python 包管理生命周期中的关键操作，从环境创建到依赖解析、安装和锁定。   一、引言：为什么需要 uv？Python 包管理长期以来面临着一些挑战，尤其是在性能和一致性方面：  pip 的局限性： 速度慢：pip 在解析大型项目或复杂依赖树时速度较慢，因为它每次都会重新计算依赖，且在网络请求和磁盘 I&#x2F;O 方面未高度优化。 依赖解析不确定性：pip 的解析器有时会出现非确定性行为，对于复杂的依赖冲突，不一定能给出最佳或唯一的解决方案。 缺乏锁定文件机制：pip 本身没有内置的锁定文件（requirements.txt 固然可以锁定，但不是通过 pip 自身的解析冲突机制而来）生成能力，需要 pip-tools 等额外工具。   virtualenv...</div></div></div></a><a class="pagination-related" href="/92d90a6caba1/" title="Python 项目管理工具 Poetry 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">Python 项目管理工具 Poetry 详解</div></div><div class="info-2"><div class="info-item-1"> Poetry 是一款现代化的 Python 项目管理和打包工具。它将依赖管理、虚拟环境管理、打包和发布功能集成在一个直观的命令行界面中。Poetry 的核心理念是提供一个统一的、声明式的项目配置方式，以 pyproject.toml 文件 (遵循 PEP 518 和 PEP 621) 作为所有项目元数据和依赖的唯一真实来源。  核心思想：Poetry 旨在通过一个工具，简化 Python 项目从创建到发布的全生命周期管理，确保环境隔离、依赖可重现性和便捷的打包发布流程。   一、为什么需要 Poetry？传统的 Python 项目管理方式通常涉及多个工具和手动步骤，带来了诸多痛点：  pip 和 requirements.txt 的局限性： requirements.txt 仅记录直接依赖，不处理传递性依赖，容易导致环境不一致。 缺乏强大的依赖解析能力，解决包版本冲突困难。 没有统一的元数据管理，项目信息分散在 setup.py、README.md 等文件中。   虚拟环境管理不便： 需要手动创建 venv 或 virtualenv，并手动激活、切换。 项目与虚拟环境的关联不够...</div></div></div></a><a class="pagination-related" href="/13fd43244420/" title="Java 编码规范详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="info-item-2">Java 编码规范详解</div></div><div class="info-2"><div class="info-item-1"> Java 编码规范 是指在编写 Java 代码时，为了提高代码的可读性 (Readability)、可维护性 (Maintainability)、可扩展性 (Extensibility) 和团队协作效率而制定的一系列约定和规则。遵循统一的编码规范能够使代码风格保持一致，降低新人上手难度，减少潜在错误，并提升软件开发的整体质量。  核心思想：代码不仅仅是实现功能的工具，更是团队成员之间沟通的载体。一致的、规范的代码风格能够显著减少理解成本和维护成本。   一、为什么需要编码规范？编码规范的重要性体现在以下几个方面：  提高可读性：统一的风格使得代码逻辑更易于理解，无论代码由谁编写。 提高可维护性：规范的代码结构和注释有助于快速定位问题、理解功能并进行修改。 促进团队协作：在多开发人员参与的项目中，统一的规范能确保代码库风格一致，减少合并冲突和返工。 减少错误：清晰的命名和结构可以避免一些常见的编程错误。 提升代码质量：规范往往也包含了最佳实践，有助于编写出更健壮、更高效的代码。 代码审查效率：在代码审查时，审查者可以更专注于业务逻辑和潜在缺陷，而不是纠结于代码风格。  二、通用原...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">477</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">231</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">82</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Gradle%EF%BC%9F"><span class="toc-text">一、为什么需要 Gradle？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Project-%E5%92%8C-Task"><span class="toc-text">2.1 Project 和 Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC-Build-Scripts"><span class="toc-text">2.2 构建脚本 (Build Scripts)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8F%92%E4%BB%B6-Plugins"><span class="toc-text">2.3 插件 (Plugins)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-Dependency-Management"><span class="toc-text">2.4 依赖管理 (Dependency Management)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Gradle-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-text">三、Gradle 构建流程与结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%87%E5%87%86%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">3.1 标准目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Gradle-Wrapper"><span class="toc-text">3.2 Gradle Wrapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA-Multi-Project-Builds"><span class="toc-text">3.3 多项目构建 (Multi-Project Builds)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.4 构建生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8-Gradle-%E5%91%BD%E4%BB%A4"><span class="toc-text">四、常用 Gradle 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">五、性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%B8%8E-Maven-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">六、与 Maven 的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-07.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>