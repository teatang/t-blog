<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>构建工具 Gradle 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化构建工具。它使用 Groovy 语言（或 Kotlin DSL）来编写构建脚本，提供了一种声明式和命令式兼备的强大构建方式。Gradle 融合了 Ant 的灵活性和 Maven 的约定式管理及依赖管理能力，旨在为多项目构建提供更强大的支持、更高的性能和更灵活的配置。  核心思想：Gradle 采用 基于">
<meta property="og:type" content="article">
<meta property="og:title" content="构建工具 Gradle 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/fc3deef3ef61/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化构建工具。它使用 Groovy 语言（或 Kotlin DSL）来编写构建脚本，提供了一种声明式和命令式兼备的强大构建方式。Gradle 融合了 Ant 的灵活性和 Maven 的约定式管理及依赖管理能力，旨在为多项目构建提供更强大的支持、更高的性能和更灵活的配置。  核心思想：Gradle 采用 基于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg">
<meta property="article:published_time" content="2023-06-10T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-06T09:33:58.464Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="项目构建">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="包管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "构建工具 Gradle 详解",
  "url": "https://blog.tbf1211.xx.kg/fc3deef3ef61/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg",
  "datePublished": "2023-06-10T22:24:00.000Z",
  "dateModified": "2026-02-06T09:33:58.464Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/fc3deef3ef61/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '构建工具 Gradle 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">546</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">构建工具 Gradle 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">构建工具 Gradle 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-10T22:24:00.000Z" title="发表于 2023-06-11 06:24:00">2023-06-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/">项目构建</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Gradle</strong> 是一个基于 Apache Ant 和 Apache Maven 概念的<strong>项目自动化构建工具</strong>。它使用 Groovy 语言（或 Kotlin DSL）来编写构建脚本，提供了一种声明式和命令式兼备的强大构建方式。Gradle 融合了 Ant 的灵活性和 Maven 的约定式管理及依赖管理能力，旨在为多项目构建提供更强大的支持、更高的性能和更灵活的配置。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：Gradle 采用 <strong>基于 Groovy&#x2F;Kotlin DSL 的脚本</strong> 来定义构建逻辑，结合了 <strong>增量编译</strong> 和 <strong>构建缓存</strong> 技术，以实现高性能。它通过 <strong>自定义任务和插件</strong> 提供了极高的灵活性，同时通过 <strong>约定优于配置</strong> 的原则降低了复杂性。</p>
</div>
<hr>
<h2 id="一、为什么需要-Gradle？"><a href="#一、为什么需要-Gradle？" class="headerlink" title="一、为什么需要 Gradle？"></a>一、为什么需要 Gradle？</h2><p>尽管 Maven 在 Java 项目构建中取得了巨大成功，但它也存在一些局限性，促使了 Gradle 的出现和流行：</p>
<ol>
<li><strong>Maven 的 XML 配置冗长复杂</strong>：<ul>
<li><code>pom.xml</code> 文件随着项目规模的增长会变得非常庞大和难以阅读。</li>
<li>XML 配置相比于编程语言，表达能力有限，实现复杂逻辑时会很繁琐。</li>
</ul>
</li>
<li><strong>Maven 的灵活性不足</strong>：<ul>
<li>Maven 严格遵循“约定优于配置”，虽然简化了常见场景，但在需要定制化构建逻辑时，Maven 的插件扩展机制和生命周期钩子相对笨拙。</li>
</ul>
</li>
<li><strong>Maven 的性能问题</strong>：<ul>
<li>Maven 不支持增量编译。每次构建都会编译所有需要编译的源文件，即使只有少量更改。</li>
<li>Maven 的多模块构建在某些情况下可能效率不高。</li>
</ul>
</li>
</ol>
<p>Gradle 旨在解决这些痛点，提供一个<strong>更强大、更灵活、更高效</strong>的构建工具：</p>
<ul>
<li><strong>声明式与命令式结合的脚本 (Groovy&#x2F;Kotlin DSL)</strong>：<ul>
<li>使用 Groovy 或 Kotlin 脚本来定义构建逻辑，相比 XML 更简洁、更具表现力。</li>
<li>既能声明性地定义项目结构和依赖，也能命令性地编写复杂的自定义任务。</li>
</ul>
</li>
<li><strong>出色的性能</strong>：<ul>
<li>支持<strong>增量编译</strong> (Incremental Builds)：只编译发生变化的文件，显著提升编译速度。</li>
<li>支持<strong>构建缓存</strong> (Build Cache)：可以复用之前构建的输出，甚至是其他机器上的构建结果。</li>
<li>支持<strong>并行执行</strong>：并发执行相互独立的任务。</li>
</ul>
</li>
<li><strong>灵活的多项目构建</strong>：<ul>
<li>天生为多项目（多模块）构建设计，管理复杂的多模块结构更加简单高效。</li>
</ul>
</li>
<li><strong>强大的可扩展性</strong>：<ul>
<li>一切皆任务 (Task)：可以轻松创建自定义任务和插件。</li>
<li>丰富的插件生态系统。</li>
</ul>
</li>
<li><strong>兼容 Maven 仓库</strong>：<ul>
<li>可以无缝使用 Maven 的依赖管理体系和中央仓库。</li>
</ul>
</li>
<li><strong>平滑迁移</strong>：<ul>
<li>支持 Maven 的 <code>pom.xml</code> 文件作为依赖管理，使从 Maven 迁移到 Gradle 更加容易。</li>
</ul>
</li>
</ul>
<h2 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h2><h3 id="2-1-Project-和-Task"><a href="#2-1-Project-和-Task" class="headerlink" title="2.1 Project 和 Task"></a>2.1 Project 和 Task</h3><p>Gradle 将所有构建过程抽象为<strong>项目 (Project)</strong> 和<strong>任务 (Task)</strong>。</p>
<ul>
<li><strong>Project (项目)</strong>：<ul>
<li>在 Gradle 中，每一个 <code>build.gradle</code> 文件都代表一个 Project。</li>
<li>一个 Project 通常对应一个可独立部署的组件（如 JAR 包、WAR 包、Web 应用），或是一个聚合其他 Project 的父模块。</li>
<li>Project 包含了一系列 Task。</li>
</ul>
</li>
<li><strong>Task (任务)</strong>：<ul>
<li>Task 是 Gradle 构建的基本执行单元，例如编译源代码、运行测试、打包 JAR 文件、生成文档等。</li>
<li>每个 Task 都有一个名称，并定义了要执行的特定操作。</li>
<li>Task 可以有依赖关系，Gradle 会根据依赖顺序执行 Task。</li>
</ul>
</li>
</ul>
<p><strong><code>build.gradle</code> 示例 (Groovy DSL)</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个插件</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span> <span class="comment">// 应用 Java 插件，自带编译、测试、打包等任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义项目的分组、名称和版本</span></span><br><span class="line">group <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 Java 版本</span></span><br><span class="line">java &#123;</span><br><span class="line">    sourceCompatibility = <span class="string">&#x27;17&#x27;</span></span><br><span class="line">    targetCompatibility = <span class="string">&#x27;17&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仓库配置，Gradle 会从这里查找依赖</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral() <span class="comment">// 使用 Maven Central 仓库</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖配置</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 编译时依赖</span></span><br><span class="line">    implementation <span class="string">&#x27;org.slf4j:slf4j-api:2.0.7&#x27;</span></span><br><span class="line">    <span class="comment">// 测试时依赖</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.10.0&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.10.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 Task (命令式写法)</span></span><br><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123; <span class="comment">// 定义 Task 要执行的动作</span></span><br><span class="line">        println <span class="string">&#x27;Hello from Gradle Task!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个自定义 Task，依赖于 &#x27;hello&#x27; Task</span></span><br><span class="line">task goodbye(<span class="attr">type:</span> MyCustomTask) &#123;</span><br><span class="line">    message = <span class="string">&#x27;Goodbye from custom task!&#x27;</span></span><br><span class="line">    dependsOn hello <span class="comment">// goodbye 任务依赖于 hello 任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomTask</span> <span class="keyword">extends</span> <span class="title class_">DefaultTask</span> &#123;</span><br><span class="line">    <span class="meta">@Input</span> <span class="keyword">var</span> message = <span class="string">&quot;Default message&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    fun run() &#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-构建脚本-Build-Scripts"><a href="#2-2-构建脚本-Build-Scripts" class="headerlink" title="2.2 构建脚本 (Build Scripts)"></a>2.2 构建脚本 (Build Scripts)</h3><p>Gradle 构建脚本使用 Groovy 或 Kotlin DSL (Domain Specific Language) 编写，通常位于 <code>build.gradle</code> 文件中。</p>
<ul>
<li><strong>Groovy DSL (默认)</strong>：基于 Groovy 语言，语法灵活，支持省略括号、点号等。</li>
<li><strong>Kotlin DSL (推荐)</strong>：基于 Kotlin 语言，提供更强大的 IDE 支持 (代码补全、类型安全、重构)，逐渐成为主流。文件名为 <code>build.gradle.kts</code>。</li>
</ul>
<p><strong>Kotlin DSL 示例</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins 块使用 `plugins &#123; ... &#125;` 而不是 `apply plugin: &#x27;...&#x27;`</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    java</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">&quot;com.example&quot;</span></span><br><span class="line">version = <span class="string">&quot;1.0-SNAPSHOT&quot;</span></span><br><span class="line"></span><br><span class="line">java &#123;</span><br><span class="line">    sourceCompatibility = JavaVersion.VERSION_17</span><br><span class="line">    targetCompatibility = JavaVersion.VERSION_17</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.slf4j:slf4j-api:2.0.7&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.junit.jupiter:junit-jupiter-api:5.10.0&quot;</span>)</span><br><span class="line">    testRuntimeOnly(<span class="string">&quot;org.junit.jupiter:junit-jupiter-engine:5.10.0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin DSL 中定义任务通常使用 `tasks.register`</span></span><br><span class="line">tasks.register(<span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello from Gradle Task (Kotlin)!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-插件-Plugins"><a href="#2-3-插件-Plugins" class="headerlink" title="2.3 插件 (Plugins)"></a>2.3 插件 (Plugins)</h3><p>Gradle 的核心功能也是通过<strong>插件</strong>实现的。插件可以向项目添加新的 Task、配置约定、扩展现有 Task 等。</p>
<ul>
<li><strong>核心插件</strong>：如 <code>java</code> (编译、测试 Java 代码), <code>application</code> (支持可执行 JAR), <code>war</code> (构建 Web 应用)。</li>
<li><strong>常用插件</strong>：<code>spring-boot</code> (Spring Boot 项目), <code>idea</code> (生成 IntelliJ IDEA 项目文件), <code>kotlin</code> (Kotlin 项目)。</li>
</ul>
<p>应用插件的方式：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Groovy DSL</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;3.2.0&#x27;</span> <span class="comment">// 外部插件需要指定版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者旧式写法</span></span><br><span class="line"><span class="comment">// apply plugin: &#x27;java&#x27;</span></span><br><span class="line"><span class="comment">// apply plugin: &#x27;war&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kotlin DSL</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    java</span><br><span class="line">    id(<span class="string">&quot;org.springframework.boot&quot;</span>) version <span class="string">&quot;3.2.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-依赖管理-Dependency-Management"><a href="#2-4-依赖管理-Dependency-Management" class="headerlink" title="2.4 依赖管理 (Dependency Management)"></a>2.4 依赖管理 (Dependency Management)</h3><p>Gradle 的依赖管理功能与 Maven 类似，但更加灵活。它也可以从 Maven 仓库、JCenter 或其他自定义仓库下载依赖。</p>
<ul>
<li><strong>依赖配置块</strong>：<code>dependencies &#123; ... &#125;</code></li>
<li><strong>依赖类型 (或称为配置)</strong>：<ul>
<li><code>implementation</code> (推荐)：用于编译和运行时，不会将 API 暴露给依赖此模块的模块，有助于更快的增量编译。</li>
<li><code>api</code>：用于编译和运行时，会将 API 暴露给依赖此模块的模块，类似于旧的 <code>compile</code> 作用。</li>
<li><code>compileOnly</code>：只在编译时需要，包不会被打包进最终构件。</li>
<li><code>runtimeOnly</code>：只在运行时需要，编译时不需要。</li>
<li><code>testImplementation</code>：测试编译和运行时需要。</li>
<li><code>testRuntimeOnly</code>：测试运行时需要。</li>
<li><code>annotationProcessor</code>：用于注解处理器。</li>
</ul>
</li>
</ul>
<p><strong>依赖的声明方式</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Groovy DSL</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;groupId:artifactId:version&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.10.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">``````kotlin</span><br><span class="line"><span class="comment">// Kotlin DSL (通常字符串需要双引号，且推荐使用 `()`)</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;groupId:artifactId:version&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.junit.jupiter:junit-jupiter-api:5.10.0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>依赖冲突解决</strong>：<br>Gradle 会自动尝试解决依赖冲突，默认会选择最新版本。你也可以手动进行配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123;</span><br><span class="line">        <span class="comment">// 强制使用某个版本</span></span><br><span class="line">        force <span class="string">&#x27;com.google.guava:guava:32.0.0-jre&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排除某个传递性依赖</span></span><br><span class="line">        eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">            <span class="keyword">if</span> (details.requested.group == <span class="string">&#x27;org.slf4j&#x27;</span> &amp;&amp; details.requested.name == <span class="string">&#x27;slf4j-api&#x27;</span>) &#123;</span><br><span class="line">                details.useVersion <span class="string">&#x27;2.0.7&#x27;</span> <span class="comment">// 强制 slf4j-api 使用 2.0.7</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Gradle-构建流程与结构"><a href="#三、Gradle-构建流程与结构" class="headerlink" title="三、Gradle 构建流程与结构"></a>三、Gradle 构建流程与结构</h2><h3 id="3-1-标准目录结构"><a href="#3-1-标准目录结构" class="headerlink" title="3.1 标准目录结构"></a>3.1 标准目录结构</h3><p>类似于 Maven，Gradle 也有其推荐的项目布局：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">project-root/</span><br><span class="line">├── build.gradle              &lt;- 根项目的构建脚本 (Groovy DSL)</span><br><span class="line">├── settings.gradle           &lt;- 声明项目的子模块</span><br><span class="line">├── gradelew                  &lt;- Gradle Wrapper 脚本 (Linux/macOS)</span><br><span class="line">├── gradlew.bat               &lt;- Gradle Wrapper 脚本 (Windows)</span><br><span class="line">├── .gradle/                  &lt;- Gradle 缓存目录</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/                 &lt;- 主代码和资源文件</span><br><span class="line">│   │   ├── java/             &lt;- Java 源代码</span><br><span class="line">│   │   ├── resources/        &lt;- 资源文件</span><br><span class="line">│   │   └── webapp/           &lt;- Web 应用根目录 (仅适用于 war 包)</span><br><span class="line">│   └── test/                 &lt;- 测试代码和资源文件</span><br><span class="line">│       ├── java/             &lt;- Java 测试源代码</span><br><span class="line">│       └── resources/        &lt;- 测试资源文件</span><br><span class="line">└── build/                    &lt;- 构建输出目录，由 Gradle 自动生成</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Gradle-Wrapper"><a href="#3-2-Gradle-Wrapper" class="headerlink" title="3.2 Gradle Wrapper"></a>3.2 Gradle Wrapper</h3><p>Gradle Wrapper (gradlew) 是推荐的 Gradle 使用方式。它允许你在没有预先安装 Gradle 的机器上运行 Gradle 构建。</p>
<ul>
<li>Wrapper 负责下载和安装指定版本的 Gradle。</li>
<li>确保所有开发者使用相同版本的 Gradle 进行构建，避免“在我机器上跑得好好的”问题。</li>
<li>使用 <code>gradlew</code> (Linux&#x2F;macOS) 或 <code>gradlew.bat</code> (Windows) 命令而不是 <code>gradle</code> 命令来执行构建。</li>
</ul>
<h3 id="3-3-多项目构建-Multi-Project-Builds"><a href="#3-3-多项目构建-Multi-Project-Builds" class="headerlink" title="3.3 多项目构建 (Multi-Project Builds)"></a>3.3 多项目构建 (Multi-Project Builds)</h3><p>Gradle 多项目构建的核心是 <code>settings.gradle</code> (settings.gradle.kts) 文件。</p>
<ul>
<li><code>settings.gradle</code> 负责定义项目的结构，通过 <code>include</code> 方法声明子模块。</li>
<li>每个子模块都有自己的 <code>build.gradle</code> 文件。</li>
<li>根目录的 <code>build.gradle</code> 可以定义所有子模块的公共配置。</li>
</ul>
<p><strong><code>settings.gradle</code> 示例</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">&#x27;my-multi-project&#x27;</span></span><br><span class="line">include <span class="string">&#x27;app&#x27;</span>, <span class="string">&#x27;library&#x27;</span> <span class="comment">// 包含 app 和 library 两个子模块</span></span><br></pre></td></tr></table></figure>
<p><strong><code>build.gradle</code> (根目录)</strong>：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subprojects &#123; <span class="comment">// 为所有子模块应用此配置</span></span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        implementation <span class="string">&#x27;org.slf4j:slf4j-api:2.0.7&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-构建生命周期"><a href="#3-4-构建生命周期" class="headerlink" title="3.4 构建生命周期"></a>3.4 构建生命周期</h3><p>Gradle 的构建生命周期分为三个阶段：</p>
<ol>
<li><strong>初始化 (Initialization)</strong>：<ul>
<li><code>settings.gradle</code> 和 <code>settings.gradle.kts</code> 文件被执行。</li>
<li>确定哪些 Project 参与构建，并创建对应的 Project 实例。</li>
</ul>
</li>
<li><strong>配置 (Configuration)</strong>：<ul>
<li>所有 Project 的 <code>build.gradle</code> 或 <code>build.gradle.kts</code> 文件被执行。</li>
<li>解析所有 Task、它们的属性和依赖关系。</li>
<li>这是构建脚本的主要执行阶段。</li>
</ul>
</li>
<li><strong>执行 (Execution)</strong>：<ul>
<li>根据配置阶段解析的 Task 依赖图，Gradle 执行请求的 Task 及其依赖的 Task。</li>
<li>这个阶段会应用增量编译和构建缓存等优化。</li>
</ul>
</li>
</ol>
<h2 id="四、常用-Gradle-命令"><a href="#四、常用-Gradle-命令" class="headerlink" title="四、常用 Gradle 命令"></a>四、常用 Gradle 命令</h2><ul>
<li><code>./gradlew tasks</code>：列出所有可用的 Task。</li>
<li><code>./gradlew build</code>：执行默认的 <code>build</code> Task，通常会编译、测试、打包。</li>
<li><code>./gradlew clean</code>：清理构建输出目录。</li>
<li><code>./gradlew test</code>：运行所有测试。</li>
<li><code>./gradlew jar</code>：打包 JAR 文件。</li>
<li><code>./gradlew run</code>：运行应用 (如果应用了 <code>application</code> 插件)。</li>
<li><code>./gradlew --info</code> &#x2F; <code>./gradlew --debug</code>：显示更详细的日志信息。</li>
<li><code>./gradlew --stop</code>：停止 Gradle Daemon (后台进程)。</li>
<li><code>./gradlew help --task &lt;taskName&gt;</code>：获取指定 Task 的帮助信息。</li>
<li>在多模块项目中，可以在子模块目录执行 <code>./gradlew &lt;taskName&gt;</code>，或在根目录执行 <code>./gradlew :&lt;moduleName&gt;:&lt;taskName&gt;</code>。</li>
</ul>
<h2 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><ul>
<li><strong>Gradle Daemon</strong>：一个后台进程，启动一次后可以重复使用，避免了每次构建都重新启动 JVM，显著加快后续构建速度。</li>
<li><strong>构建缓存 (Build Cache)</strong>：缓存构建任务的输入和输出。如果任务的输入没有变化，Gradle 可以直接复用缓存中的输出，而无需重新执行任务。可以配置本地缓存和远程缓存。</li>
<li><strong>增量构建 (Incremental Build)</strong>：Gradle 会跟踪输入文件，只有当输入文件发生变化时才重新执行任务。</li>
<li><strong>配置优化</strong>：优化脚本，避免在配置阶段执行耗时操作。</li>
</ul>
<h2 id="六、与-Maven-的比较"><a href="#六、与-Maven-的比较" class="headerlink" title="六、与 Maven 的比较"></a>六、与 Maven 的比较</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Maven</th>
<th align="left">Gradle</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>构建脚本</strong></td>
<td align="left">XML (pom.xml)</td>
<td align="left">Groovy DSL (build.gradle) 或 Kotlin DSL (build.gradle.kts)</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">约定优于配置，不够灵活，定制化困难。</td>
<td align="left">灵活度高，可轻松定制任务和插件，Groovy&#x2F;Kotlin 编程能力。</td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left">XML 冗长，层级多。</td>
<td align="left">DSL 更简洁，更易读，但需要熟悉 Groovy&#x2F;Kotlin 语法。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">仅支持全量编译，无构建缓存，速度相对较慢。</td>
<td align="left">支持增量编译、构建缓存、Gradle Daemon，速度通常更快。</td>
</tr>
<tr>
<td align="left"><strong>多模块</strong></td>
<td align="left">基于父 POM 继承，配置较复杂。</td>
<td align="left">基于 <code>settings.gradle</code> 和 <code>subprojects()</code> 实现，更灵活高效。</td>
</tr>
<tr>
<td align="left"><strong>依赖管理</strong></td>
<td align="left">良好，基于 XML。</td>
<td align="left">强大，基于 DSL，提供更多控制，如依赖冲突解决策略、排除传递依赖等。</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">相对平缓，主要学习 XML 结构和生命周期。</td>
<td align="left">steeper，需要掌握 Groovy&#x2F;Kotlin 语法和 Gradle DSL 概念。</td>
</tr>
<tr>
<td align="left"><strong>IDE 支持</strong></td>
<td align="left">广泛且成熟。</td>
<td align="left">良好，特别是 Kotlin DSL 带来了更好的 IDE 体验。</td>
</tr>
</tbody></table>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Gradle 是一个现代化、高性能、高度灵活的 Java 项目构建工具。它通过引入 Groovy&#x2F;Kotlin DSL、增量编译、构建缓存和强大的插件机制，解决了 Maven 在灵活性和性能方面的不足。</p>
<p>对于追求极致构建性能、需要高度定制化构建逻辑、或管理复杂多模块项目的开发者而言，Gradle 是一个非常理想的选择。它在 Android 开发领域已成为事实标准，并在 Java 后端和微服务领域越来越受欢迎。虽然其学习曲线可能比 Maven 略陡峭，但它带来的强大功能和效率提升绝对值得投入学习。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/fc3deef3ef61/">https://blog.tbf1211.xx.kg/fc3deef3ef61/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/">项目构建</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/">包管理</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/a148e5499a60/" title="IPSec (Internet Protocol Security) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">IPSec (Internet Protocol Security) 详解</div></div><div class="info-2"><div class="info-item-1"> IPSec (Internet Protocol Security) 是一套在 IP 层 (网络层) 提供安全服务的协议族。它不依赖于任何特定的应用程序，而是通过加密和认证 IP 数据包在网络中安全传输。IPSec 广泛应用于构建 VPN (Virtual Private Network - 虚拟专用网络)，为远程用户、分支机构和云资源提供安全的、端到端的通信。它提供了数据完整性、数据源认证、防重放保护以及数据机密性等关键安全服务。  核心思想：IPSec 通过在网络层透明地加密和认证 IP 数据包，为 IP 通信提供端到端的安全保障，是构建安全 VPN 和保护 IP 流量的核心技术。   一、IPSec 概述1.1 什么是 IPSec？IPSec 是由 IETF (Internet Engineering Task Force) 定义的一整套开放标准的协议族，它工作在 OSI 模型的网络层 (Layer 3)。其核心目标是为 IP 通信提供高级安全功能，而无需修改应用程序。 1.2 为什么需要 IPSec？传统的 IP 协议本身无法提供数据的机密性、完整性或认证。数据在公共网...</div></div></div></a><a class="pagination-related" href="/06bc4d655ced/" title="Python Beautiful Soup详解：高效网页数据抓取与解析利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python Beautiful Soup详解：高效网页数据抓取与解析利器</div></div><div class="info-2"><div class="info-item-1"> Beautiful Soup 是一个 Python 库，用于从 HTML 或 XML 文件中提取数据。它通过解析文档并提供用于导航、搜索和修改解析树的 Pythonic 接口，将复杂的 HTML&#x2F;XML 文档转化为易于处理的数据结构。Beautiful Soup 与 requests 等 HTTP 库结合使用，是构建网络爬虫进行数据抓取的强大工具。  核心思想：Beautiful Soup 将杂乱的 HTML&#x2F;XML 文档“煲成一锅美味的汤”，让你能够轻松地在其中挑选出你需要的数据元素，如同在厨房里筛选食材一样简单。   一、为什么需要 Beautiful Soup？在网络上，大量有价值的信息以 HTML 页面的形式存在。如果我们需要从这些页面中获取结构化数据（例如，产品信息、新闻标题、评论内容），直接操作原始的 HTML 字符串是非常困难和脆弱的。传统的字符串查找和正则表达式虽然可行，但存在以下问题：  HTML 结构复杂：HTML 标签嵌套层级深，结构不规则，使用正则表达式难以精确匹配。 HTML 容错性：浏览器会自动纠正不规范的 HTML 结构，但正则...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/5febe994b52e/" title="Java 构建工具 Maven 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="info-item-2">Java 构建工具 Maven 详解</div></div><div class="info-2"><div class="info-item-1"> Apache Maven (Maven) 是一个强大的项目管理和构建自动化工具，主要服务于基于 Java 的项目。它遵循约定优于配置 (Convention over Configuration) 的原则，提供了一个标准化的项目结构和生命周期，用于编译、测试、打包、部署等任务。Maven 的核心目标是让项目构建过程标准化、可预测且易于维护，同时提供强大的依赖管理功能。  核心思想：Maven 将项目视为一系列相互依赖的模块，通过一个声明式的 XML 文件 (pom.xml) 来管理项目的构建、报告和文档。它推崇一套标准的项目布局和生命周期，从而减少开发者在配置上的工作量。   一、为什么需要 Maven？在 Maven 出现之前，Java 项目的构建和管理通常面临诸多挑战：  依赖管理混乱： 项目所需的所有第三方 JAR 包都需要手动下载并添加到项目的 classpath 中。 如果多个项目使用相同库的不同版本，容易引发冲突 (JAR Hell)。 依赖的依赖（传递性依赖）管理起来更加复杂。   构建过程非标准化： 不同的项目可能有不同的构建脚本 (如 Ant)，导致构建步骤不...</div></div></div></a><a class="pagination-related" href="/92d90a6caba1/" title="Python 项目管理工具 Poetry 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-10</div><div class="info-item-2">Python 项目管理工具 Poetry 详解</div></div><div class="info-2"><div class="info-item-1"> Poetry 是一款现代化的 Python 项目管理和打包工具。它将依赖管理、虚拟环境管理、打包和发布功能集成在一个直观的命令行界面中。Poetry 的核心理念是提供一个统一的、声明式的项目配置方式，以 pyproject.toml 文件 (遵循 PEP 518 和 PEP 621) 作为所有项目元数据和依赖的唯一真实来源。  核心思想：Poetry 旨在通过一个工具，简化 Python 项目从创建到发布的全生命周期管理，确保环境隔离、依赖可重现性和便捷的打包发布流程。   一、为什么需要 Poetry？传统的 Python 项目管理方式通常涉及多个工具和手动步骤，带来了诸多痛点：  pip 和 requirements.txt 的局限性： requirements.txt 仅记录直接依赖，不处理传递性依赖，容易导致环境不一致。 缺乏强大的依赖解析能力，解决包版本冲突困难。 没有统一的元数据管理，项目信息分散在 setup.py、README.md 等文件中。   虚拟环境管理不便： 需要手动创建 venv 或 virtualenv，并手动激活、切换。 项目与虚拟环境的关联不够...</div></div></div></a><a class="pagination-related" href="/8d6f5f56de5e/" title="Python Setuptools 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-27</div><div class="info-item-2">Python Setuptools 详解</div></div><div class="info-2"><div class="info-item-1"> Setuptools 是一个强大的 Python 库，用于简化 Python 项目的打包 (packaging)、分发 (distribution) 和安装 (installation)。它是 distutils 库的增强版，提供了一系列高级功能，如声明项目元数据、自动发现包、安装依赖项、创建可执行脚本和支持插件机制等。Setuptools 已经成为 Python 项目管理和分发的事实标准 (de facto standard)。  核心思想：将 Python 代码、资源文件、元数据和依赖项封装成标准化的发行包 (Source Distribution 或 Wheel)，方便用户通过 pip 等工具安装和管理，从而实现代码的轻松共享和复用。   一、为什么需要 Setuptools？在 Python 项目开发中，尤其当项目需要被他人使用、共享或部署到不同环境时，会遇到以下问题：  代码复用与分发：如何将自己的 Python 代码模块化，并方便地分享给他人使用？简单地复制粘贴文件显然不是一个可持续的方案。 依赖管理：我的项目依赖了哪些第三方库？如何确保用户在安装我的项目时，这些依...</div></div></div></a><a class="pagination-related" href="/13fd43244420/" title="Java 编码规范详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="info-item-2">Java 编码规范详解</div></div><div class="info-2"><div class="info-item-1"> Java 编码规范 是指在编写 Java 代码时，为了提高代码的可读性 (Readability)、可维护性 (Maintainability)、可扩展性 (Extensibility) 和团队协作效率而制定的一系列约定和规则。遵循统一的编码规范能够使代码风格保持一致，降低新人上手难度，减少潜在错误，并提升软件开发的整体质量。  核心思想：代码不仅仅是实现功能的工具，更是团队成员之间沟通的载体。一致的、规范的代码风格能够显著减少理解成本和维护成本。   一、为什么需要编码规范？编码规范的重要性体现在以下几个方面：  提高可读性：统一的风格使得代码逻辑更易于理解，无论代码由谁编写。 提高可维护性：规范的代码结构和注释有助于快速定位问题、理解功能并进行修改。 促进团队协作：在多开发人员参与的项目中，统一的规范能确保代码库风格一致，减少合并冲突和返工。 减少错误：清晰的命名和结构可以避免一些常见的编程错误。 提升代码质量：规范往往也包含了最佳实践，有助于编写出更健壮、更高效的代码。 代码审查效率：在代码审查时，审查者可以更专注于业务逻辑和潜在缺陷，而不是纠结于代码风格。  二、通用原...</div></div></div></a><a class="pagination-related" href="/8d32c59da40a/" title="Vitest 详解：下一代前端测试框架"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-29</div><div class="info-item-2">Vitest 详解：下一代前端测试框架</div></div><div class="info-2"><div class="info-item-1"> Vitest 是一个由 Vite 驱动的下一代单元测试框架，旨在提供一个快速、现代且极具效率的测试体验。它与 Vite 深度集成，共享相同的配置、转换和解析器，从而为使用 Vite 构建的前端项目提供了无缝的测试解决方案。Vitest 的诞生，部分是为了解决传统前端测试工具（如 Jest）在大型项目中启动慢、HMR（热模块替换）支持不足等痛点。  核心思想：Vitest 利用 Vite 的 ESM-first 开发服务器和闪电般的 HMR 能力，为 JavaScript&#x2F;TypeScript 项目带来前所未有的快速测试体验，尤其适合基于 Vite 的现代前端项目。   一、为什么选择 Vitest？在前端开发日益复杂的今天，测试是保证代码质量和项目稳定性的关键环节。传统的测试框架，如 Jest，尽管功能强大，但在面对现代前端构建工具（如 ESM、TypeScript、JSX&#x2F;TSX 转换）时，往往需要额外的配置和转换步骤，导致测试启动慢、HMR 效率不高。Vitest 应运而生，旨在解决这些问题。 1.1 核心优势 Vite 驱动，极致速度：  直接利用 V...</div></div></div></a><a class="pagination-related" href="/7cdd9f5b33c9/" title="前端项目工程化详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="info-item-2">前端项目工程化详解</div></div><div class="info-2"><div class="info-item-1"> 随着前端应用的复杂度日益增加，单纯依靠人工管理和协作已经无法满足高效、高质量开发的需求。前端工程化应运而生，它旨在通过将软件工程的思想和方法引入前端开发，构建一套系统化、标准化、自动化、体系化的解决方案，以提高开发效率、保障代码质量、降低维护成本。  前端工程化的核心思想是：以自动化取代人力，以工具取代重复劳动，以规范约束散漫。   一、什么是前端工程化？前端工程化是构建、管理和维护前端项目的实践和工具集。它涵盖了从项目初始化、开发、构建、测试到部署的整个生命周期，目标是提升团队协作效率、统一代码风格、保证项目质量、优化产物性能以及实现快速迭代。 它不仅仅是使用几个构建工具，更是一种体系化的思维方式和工作流。 二、为什么需要前端工程化？在没有工程化的时代，前端开发面临诸多挑战：  开发效率低下：手动重复任务（如文件合并、压缩），环境搭建复杂。 代码质量参差不齐：缺乏统一的代码规范和质量检查机制，导致 Bug 增多，难以维护。 团队协作困难：不同成员的代码风格差异大，冲突频繁，交接成本高。 项目性能不佳：缺乏自动化优化手段（如图片压缩、按需加载），页面加载慢。 部署上线复杂：手动...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">546</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Gradle%EF%BC%9F"><span class="toc-text">一、为什么需要 Gradle？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Project-%E5%92%8C-Task"><span class="toc-text">2.1 Project 和 Task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC-Build-Scripts"><span class="toc-text">2.2 构建脚本 (Build Scripts)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8F%92%E4%BB%B6-Plugins"><span class="toc-text">2.3 插件 (Plugins)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-Dependency-Management"><span class="toc-text">2.4 依赖管理 (Dependency Management)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Gradle-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-text">三、Gradle 构建流程与结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%87%E5%87%86%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">3.1 标准目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Gradle-Wrapper"><span class="toc-text">3.2 Gradle Wrapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA-Multi-Project-Builds"><span class="toc-text">3.3 多项目构建 (Multi-Project Builds)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.4 构建生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8-Gradle-%E5%91%BD%E4%BB%A4"><span class="toc-text">四、常用 Gradle 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">五、性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%B8%8E-Maven-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">六、与 Maven 的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-18.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>