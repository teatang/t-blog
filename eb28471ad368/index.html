<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Cloudflare Argo Tunnel 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Cloudflare Argo Tunnel 是一种安全连接服务，它允许用户通过 Cloudflare 全球网络，以仅出站 (outbound-only) 的方式将私有服务（如Web服务器、SSH、数据库等）安全地暴露给互联网，而无需在源服务器上打开任何入站防火墙端口。这有效地将源服务器隐藏在 Cloudflare 网络之后，从而保护其免受直接攻击和IP泄露。  核心思想：消除传统防火墙入站端口">
<meta property="og:type" content="article">
<meta property="og:title" content="Cloudflare Argo Tunnel 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/eb28471ad368/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Cloudflare Argo Tunnel 是一种安全连接服务，它允许用户通过 Cloudflare 全球网络，以仅出站 (outbound-only) 的方式将私有服务（如Web服务器、SSH、数据库等）安全地暴露给互联网，而无需在源服务器上打开任何入站防火墙端口。这有效地将源服务器隐藏在 Cloudflare 网络之后，从而保护其免受直接攻击和IP泄露。  核心思想：消除传统防火墙入站端口">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg">
<meta property="article:published_time" content="2025-09-29T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:34:25.638Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Serverless">
<meta property="article:tag" content="云服务">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Cloudflare">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cloudflare Argo Tunnel 详解",
  "url": "https://blog.tbf1211.xx.kg/eb28471ad368/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg",
  "datePublished": "2025-09-29T22:24:00.000Z",
  "dateModified": "2026-02-01T09:34:25.638Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/eb28471ad368/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cloudflare Argo Tunnel 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-01.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Cloudflare Argo Tunnel 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Cloudflare Argo Tunnel 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-09-29T22:24:00.000Z" title="发表于 2025-09-30 06:24:00">2025-09-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Cloudflare Argo Tunnel</strong> 是一种<strong>安全连接服务</strong>，它允许用户通过 Cloudflare 全球网络，以<strong>仅出站 (outbound-only)</strong> 的方式将私有服务（如Web服务器、SSH、数据库等）安全地暴露给互联网，而无需在源服务器上打开任何入站防火墙端口。这有效地将源服务器隐藏在 Cloudflare 网络之后，从而保护其免受直接攻击和IP泄露。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：<strong>消除传统防火墙入站端口的需求，通过建立从源服务器到 Cloudflare 边缘网络的持久性、加密的出站连接，实现服务暴露。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-Argo-Tunnel？"><a href="#一、为什么需要-Argo-Tunnel？" class="headerlink" title="一、为什么需要 Argo Tunnel？"></a>一、为什么需要 Argo Tunnel？</h2><p>传统的将内部服务暴露给互联网的方式通常涉及：</p>
<ol>
<li><strong>开放防火墙端口</strong>：在服务器的防火墙或路由器上配置端口转发，允许外部流量直接进入。这增加了攻击面，要求持续监控和维护安全组规则。</li>
<li><strong>公网 IP 地址</strong>：源服务器需要一个公网 IP 地址，使其直接暴露在互联网上，容易成为DDoS攻击、端口扫描、漏洞探测的目标。</li>
<li><strong>VPN 或堡垒机</strong>：对于内部访问，可能需要复杂的 VPN 设置或维护堡垒机，增加了运维复杂性。</li>
</ol>
<p>Argo Tunnel 旨在解决这些问题，提供一种<strong>更安全、更简洁、更符合零信任原则</strong>的解决方案：</p>
<ul>
<li><strong>零入站端口</strong>：源服务器无需开放任何入站端口，仅发起出站连接，大大减少了攻击面。</li>
<li><strong>隐藏源 IP</strong>：所有流量都经过 Cloudflare 边缘网络代理，源服务器的真实 IP 地址不会暴露。</li>
<li><strong>集成 Cloudflare 安全功能</strong>：自动获得 Cloudflare 的DDoS防护、WAF (Web Application Firewall)、Rate Limiting等保护。</li>
<li><strong>简化网络配置</strong>：无需复杂的端口转发或NAT配置。</li>
<li><strong>零信任访问集成</strong>：可与 Cloudflare Access 结合，对访问隧道的用户进行身份验证和授权，实现更细粒度的访问控制。</li>
<li><strong>私有网络连接</strong>：不仅可以暴露公共服务，也可以用于将私有网络或本地资源安全地连接到 Cloudflare 零信任平台，实现内部资源的远程访问。</li>
</ul>
<h2 id="二、Argo-Tunnel-的工作原理"><a href="#二、Argo-Tunnel-的工作原理" class="headerlink" title="二、Argo Tunnel 的工作原理"></a>二、Argo Tunnel 的工作原理</h2><p>Argo Tunnel 的核心是 <code>cloudflared</code> 守护进程（客户端），它运行在您的私有网络或源服务器上。</p>
<h3 id="2-1-核心组件"><a href="#2-1-核心组件" class="headerlink" title="2.1 核心组件"></a>2.1 核心组件</h3><ul>
<li><strong><code>cloudflared</code> 客户端</strong>：一个轻量级的开源守护进程，运行在您的基础设施内部（如服务器、VM、容器）。它负责建立并维护到 Cloudflare 边缘网络的连接。</li>
<li><strong>Cloudflare 边缘网络</strong>：Cloudflare 的全球数据中心网络。它作为客户端请求的入口点和隧道流量的终点。</li>
<li><strong>DNS 记录</strong>：用于将用户请求路由到 Cloudflare 边缘网络。</li>
</ul>
<h3 id="2-2-工作流程"><a href="#2-2-工作流程" class="headerlink" title="2.2 工作流程"></a>2.2 工作流程</h3><p>Argo Tunnel 的工作原理可以概括为以下步骤：</p>
<ol>
<li><strong><code>cloudflared</code> 启动隧道</strong>：当 <code>cloudflared</code> 客户端启动时，它会主动向最近的 Cloudflare 边缘数据中心建立多个<strong>加密的、持久的、仅出站的 TCP 连接</strong>。这些连接通常使用 TLS 进行加密。</li>
<li><strong>DNS 路由</strong>：您需要在 Cloudflare DNS 中为您的服务配置一个 CNAME 记录，指向 <code>&lt;tunnel-uuid&gt;.cfargotunnel.com</code> 或 <code>your-hostname.your-domain.com</code>。这意味着所有发往您服务的请求都会首先被路由到 Cloudflare 边缘网络。</li>
<li><strong>请求处理</strong>：<ul>
<li>当用户尝试访问您的服务时 (例如 <code>https://your-app.your-domain.com</code>)，他们的请求首先到达 Cloudflare 边缘网络。</li>
<li>Cloudflare 边缘网络接收到请求后，会通过之前由 <code>cloudflared</code> 建立的持久隧道，将请求转发给运行在您本地的 <code>cloudflared</code> 客户端。</li>
<li><code>cloudflared</code> 客户端收到请求后，会将其转发到您本地网络中配置的内部服务（例如 <code>http://localhost:8000</code> 或 <code>http://192.168.1.100:3000</code>）。</li>
<li>服务处理请求并返回响应，响应同样通过 <code>cloudflared</code> 客户端、隧道、Cloudflare 边缘网络，最终返回给用户。</li>
</ul>
</li>
</ol>
<p><strong>流量示意图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant User
    participant Cloudflare_DNS as Cloudflare DNS
    participant Cloudflare_Edge as Cloudflare Edge Network
    participant Cloudflared_Client as Your Server (cloudflared client)
    participant Local_Service as Your Local Service

    User-&gt;&gt;Cloudflare_DNS: 1. DNS Query (your-app.your-domain.com)
    Cloudflare_DNS--&gt;&gt;User: 2. Resolve to Cloudflare Edge IP

    User-&gt;&gt;Cloudflare_Edge: 3. HTTP(S) Request to Cloudflare Edge
    Cloudflared_Client--&gt;&gt;Cloudflare_Edge: 4. (Outbound) Establishes persistent encrypted tunnels
    Cloudflare_Edge-&gt;&gt;Cloudflared_Client: 5. Forwards HTTP(S) Request through tunnel
    Cloudflared_Client-&gt;&gt;Local_Service: 6. Forwards Request to Local Service (e.g., localhost:8000)
    Local_Service--&gt;&gt;Cloudflared_Client: 7. Response from Local Service
    Cloudflared_Client--&gt;&gt;Cloudflare_Edge: 8. Returns Response through tunnel
    Cloudflare_Edge--&gt;&gt;User: 9. Returns HTTP(S) Response to User
  </pre></div>

<h3 id="2-3-关键概念定义"><a href="#2-3-关键概念定义" class="headerlink" title="2.3 关键概念定义"></a>2.3 关键概念定义</h3><ul>
<li><strong>Cloudflare Edge Network (Cloudflare 边缘网络)</strong>：由 Cloudflare 在全球部署的数千个数据中心组成的网络。它位于用户和源服务器之间，提供DDoS防护、WAF、缓存等服务，并作为 Argo Tunnel 流量的入口和出口。</li>
<li><strong>Zero Trust (零信任)</strong>：一种安全模型，其核心原则是“永不信任，始终验证”。在零信任架构中，任何用户、设备或应用程序，无论其位于内部网络还是外部网络，在访问资源之前都必须经过严格的身份验证和授权。Argo Tunnel 结合 Cloudflare Access 是实现零信任的有效工具。</li>
</ul>
<h2 id="三、Argo-Tunnel-的主要优势"><a href="#三、Argo-Tunnel-的主要优势" class="headerlink" title="三、Argo Tunnel 的主要优势"></a>三、Argo Tunnel 的主要优势</h2><ol>
<li><p><strong>极高的安全性</strong>：</p>
<ul>
<li><strong>隐藏源站 IP</strong>：源服务器无需公网 IP，其真实 IP 永远不会暴露给最终用户。</li>
<li><strong>零入站端口</strong>：消除了在防火墙上打开端口的需求，大大减少了网络攻击面。</li>
<li><strong>加密通信</strong>：<code>cloudflared</code> 与 Cloudflare 边缘网络之间的所有通信都通过 TLS 加密。</li>
<li><strong>集成 Cloudflare 安全防护</strong>：自动享受 Cloudflare 的DDoS防护、WAF、机器人管理等高级安全功能。</li>
</ul>
</li>
<li><p><strong>简化网络管理</strong>：</p>
<ul>
<li>无需配置复杂的端口转发、NAT规则或VPN。</li>
<li>适合动态 IP 环境，因为 <code>cloudflared</code> 会主动连接，无需固定 IP。</li>
</ul>
</li>
<li><p><strong>灵活的访问控制</strong>：</p>
<ul>
<li>可以与 Cloudflare Access 结合，实现基于身份、设备态势和上下文的精细化访问策略，满足零信任架构要求。</li>
<li>轻松暴露内部开发环境、测试服务器、数据库、SSH 服务等。</li>
</ul>
</li>
<li><p><strong>高可用性和性能</strong>：</p>
<ul>
<li><code>cloudflared</code> 会自动连接到最近的 Cloudflare 边缘节点，并建立多个并发连接以提供冗余和负载均衡。</li>
<li>利用 Cloudflare 全球网络的低延迟和高带宽。</li>
</ul>
</li>
<li><p><strong>适用场景广泛</strong>：</p>
<ul>
<li>暴露家庭网络中的自建服务（如NAS、博客）。</li>
<li>连接云平台上的私有实例，无需VPN。</li>
<li>为容器、Kubernetes 集群中的服务提供外部访问。</li>
<li>取代传统的 VPN 用于远程办公访问内部资源。</li>
</ul>
</li>
</ol>
<h2 id="四、如何配置-Argo-Tunnel-CLI-示例"><a href="#四、如何配置-Argo-Tunnel-CLI-示例" class="headerlink" title="四、如何配置 Argo Tunnel (CLI 示例)"></a>四、如何配置 Argo Tunnel (CLI 示例)</h2><p>以下是使用 <code>cloudflared</code> CLI 配置 Argo Tunnel 的基本步骤。</p>
<h3 id="4-1-1-安装-cloudflared"><a href="#4-1-1-安装-cloudflared" class="headerlink" title="4.1 1. 安装 cloudflared"></a>4.1 1. 安装 <code>cloudflared</code></h3><p><code>cloudflared</code> 是一个跨平台的命令行工具。您可以从 Cloudflare 的官方 GitHub 仓库下载预编译的二进制文件，或使用包管理器安装。</p>
<p><strong>Linux (Debian&#x2F;Ubuntu 示例):</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i cloudflared.deb</span><br></pre></td></tr></table></figure>

<p><strong>macOS (Homebrew 示例):</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cloudflared</span><br></pre></td></tr></table></figure>

<p><strong>Windows (Scoop 示例):</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install cloudflared</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-登录-Cloudflare-账户"><a href="#4-2-2-登录-Cloudflare-账户" class="headerlink" title="4.2 2. 登录 Cloudflare 账户"></a>4.2 2. 登录 Cloudflare 账户</h3><p>运行此命令将在浏览器中打开一个 Cloudflare 登录页面，完成认证后，<code>cloudflared</code> 会生成一个 <code>cert.pem</code> 证书文件，用于后续操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel login</span><br></pre></td></tr></table></figure>

<p>该命令会在默认路径 (<code>~/.cloudflared/cert.pem</code> 或 <code>$HOME/.cloudflared/cert.pem</code>) 创建一个证书文件。</p>
<h3 id="4-3-3-创建-Tunnel"><a href="#4-3-3-创建-Tunnel" class="headerlink" title="4.3 3. 创建 Tunnel"></a>4.3 3. 创建 Tunnel</h3><p>为您的隧道创建一个名称。此命令会生成一个唯一的隧道 ID 和一个 <code>credentials.json</code> 文件，其中包含隧道的认证信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel create my-web-tunnel</span><br></pre></td></tr></table></figure>

<p>这会在 <code>~/.cloudflared/</code> 目录下创建一个与隧道名称对应的子目录，例如 <code>~/.cloudflared/my-web-tunnel/credentials.json</code>。</p>
<h3 id="4-4-4-定义-Tunnel-配置-config-yml"><a href="#4-4-4-定义-Tunnel-配置-config-yml" class="headerlink" title="4.4 4. 定义 Tunnel 配置 (config.yml)"></a>4.4 4. 定义 Tunnel 配置 (config.yml)</h3><p>创建一个 <code>config.yml</code> 文件来定义隧道如何路由流量。通常放在 <code>~/.cloudflared/config.yml</code> 或 <code>~/.cloudflared/&lt;tunnel-name&gt;.yml</code>。</p>
<p><strong>示例 <code>config.yml</code>：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tunnel:</span> <span class="string">&lt;YOUR_TUNNEL_UUID&gt;</span> <span class="comment"># 替换为实际的隧道UUID，可从 `cloudflared tunnel create` 命令输出或 `~/.cloudflared/my-web-tunnel/credentials.json` 中获取</span></span><br><span class="line"><span class="attr">credentials-file:</span> <span class="string">/root/.cloudflared/&lt;YOUR_TUNNEL_NAME&gt;/credentials.json</span> <span class="comment"># 替换为实际路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">your-app.your-domain.com</span> <span class="comment"># 您想要暴露的公网域名</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">http://localhost:8000</span>     <span class="comment"># 您的内部服务地址</span></span><br><span class="line">    <span class="comment"># 如果服务需要 HTTPS 并且您的内部服务也支持 HTTPS，请使用 https://localhost:8443</span></span><br><span class="line">    <span class="comment"># originRequest:</span></span><br><span class="line">    <span class="comment">#   noTLSVerify: true # 如果内部服务是HTTPS且证书自签名，可以添加此项 (不推荐用于生产环境)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">http_status:404</span> <span class="comment"># 默认catch-all规则，处理所有未匹配的请求，返回404</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><code>&lt;YOUR_TUNNEL_UUID&gt;</code> 是您创建隧道时生成的唯一标识符。</li>
<li><code>&lt;YOUR_TUNNEL_NAME&gt;</code> 是您创建隧道时指定的名称。</li>
<li><code>service</code> 可以是 HTTP&#x2F;HTTPS 服务，也可以是 SSH (<code>ssh://localhost:22</code>)、VNC、RDP 等。</li>
</ul>
<h3 id="4-5-5-配置-DNS-记录"><a href="#4-5-5-配置-DNS-记录" class="headerlink" title="4.5 5. 配置 DNS 记录"></a>4.5 5. 配置 DNS 记录</h3><p>将您的公网域名指向 Cloudflare。您可以手动在 Cloudflare Dashboard 中创建 CNAME 记录，或者使用 <code>cloudflared</code> CLI 自动配置。</p>
<p><strong>自动配置 DNS (假设您的域名已在 Cloudflare 管理):</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel route dns my-web-tunnel your-app.your-domain.com</span><br></pre></td></tr></table></figure>

<p>这将为 <code>your-app.your-domain.com</code> 创建一个 CNAME 记录，指向您的隧道。</p>
<h3 id="4-6-6-运行-Tunnel"><a href="#4-6-6-运行-Tunnel" class="headerlink" title="4.6 6. 运行 Tunnel"></a>4.6 6. 运行 Tunnel</h3><p>使用配置好的 <code>config.yml</code> 启动隧道。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel run my-web-tunnel</span><br></pre></td></tr></table></figure>

<p>此时，<code>cloudflared</code> 会建立到 Cloudflare 边缘网络的连接，您的服务就可以通过 <code>https://your-app.your-domain.com</code> 访问了。</p>
<h3 id="4-7-7-将-cloudflared-作为服务运行-Systemd-示例"><a href="#4-7-7-将-cloudflared-作为服务运行-Systemd-示例" class="headerlink" title="4.7 7. 将 cloudflared 作为服务运行 (Systemd 示例)"></a>4.7 7. 将 <code>cloudflared</code> 作为服务运行 (Systemd 示例)</h3><p>为了确保 <code>cloudflared</code> 在服务器启动时自动运行并在失败时重启，推荐将其配置为系统服务。</p>
<p><strong>创建一个 Systemd 服务文件 (例如 <code>/etc/systemd/system/cloudflared-tunnel@.service</code>):</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Cloudflare Tunnel for %i</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=root <span class="comment"># 或者一个更安全的非特权用户，例如 &#x27;cloudflared&#x27;，前提是该用户对 cert.pem 和 credentials.json 有读权限</span></span><br><span class="line"><span class="attr">WorkingDirectory</span>=/root/.cloudflared/ <span class="comment"># cloudflared 相关文件所在的目录</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/bin/cloudflared tunnel --config /root/.cloudflared/%i.yml run %i <span class="comment"># 确保 /usr/local/bin/cloudflared 是正确的路径</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">5</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<p><strong>启用并启动服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> cloudflared-tunnel@my-web-tunnel.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl start cloudflared-tunnel@my-web-tunnel.service</span><br><span class="line"><span class="built_in">sudo</span> systemctl status cloudflared-tunnel@my-web-tunnel.service</span><br></pre></td></tr></table></figure>
<p>请根据您的实际文件路径和隧道名称进行调整。</p>
<h2 id="五、安全性考虑"><a href="#五、安全性考虑" class="headerlink" title="五、安全性考虑"></a>五、安全性考虑</h2><p>尽管 Argo Tunnel 大幅提升了安全性，但仍需注意以下几点：</p>
<ol>
<li><p><strong><code>cloudflared</code> 客户端安全</strong>：</p>
<ul>
<li><strong>更新及时</strong>：确保 <code>cloudflared</code> 客户端始终保持最新版本，以获取最新的安全补丁。</li>
<li><strong>最小权限</strong>：如果可能，将 <code>cloudflared</code> 作为一个非特权用户运行，并限制其对敏感文件的访问权限。</li>
<li><strong>主机安全</strong>：运行 <code>cloudflared</code> 的主机本身应遵循最佳安全实践，包括操作系统更新、最小化安装、防火墙配置等。</li>
</ul>
</li>
<li><p><strong>隧道凭证安全</strong>：</p>
<ul>
<li><code>cert.pem</code> 和 <code>credentials.json</code> 文件包含您的 Cloudflare 账户和隧道认证信息，务必妥善保管，防止泄露。</li>
<li>这些文件应该有严格的访问权限设置（例如仅限于 <code>root</code> 或 <code>cloudflared</code> 用户读取）。</li>
</ul>
</li>
<li><p><strong>内部服务安全</strong>：</p>
<ul>
<li>Argo Tunnel 保护了您的源站 IP，但并不意味着内部服务可以不设防。内部服务依然需要遵循安全编码实践，防范XSS、SQL注入等应用层漏洞。</li>
<li><strong>HTTPS&#x2F;TLS</strong>：即使 <code>cloudflared</code> 客户端与 Cloudflare 边缘网络之间是加密的，如果内部服务支持 HTTPS，也建议使用 HTTPS 进行内部通信，实现端到端加密。如果内部服务使用自签名证书，可以在 <code>config.yml</code> 中配置 <code>noTLSVerify: true</code> (但需了解风险)。</li>
</ul>
</li>
<li><p><strong>Zero Trust Access Policies</strong>：</p>
<ul>
<li>对于需要限制访问的内部服务，强烈建议结合 Cloudflare Access 使用。通过配置 Access 策略，可以要求用户进行身份验证（例如通过 SSO 提供商），并根据用户身份、组、设备状态等条件授权访问。</li>
</ul>
</li>
<li><p><strong>日志和监控</strong>：</p>
<ul>
<li>定期检查 <code>cloudflared</code> 的日志输出，以及 Cloudflare Dashboard 中的流量和安全日志，及时发现异常行为。</li>
</ul>
</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Cloudflare Argo Tunnel 是一种强大且优雅的解决方案，用于安全地将内部服务暴露给互联网。它通过建立仅出站的加密隧道，消除了传统防火墙入站端口的需求，隐藏了源站 IP，并集成了 Cloudflare 领先的安全防护能力。结合 Cloudflare Access，Argo Tunnel 能够构建一个完善的零信任访问模型，极大地简化了网络管理和提升了整体安全性，成为现代基础设施和远程访问的理想选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/eb28471ad368/">https://blog.tbf1211.xx.kg/eb28471ad368/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Serverless/">Serverless</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Cloudflare/">Cloudflare</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/b10b8bccf756/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go语言指向指针的指针(Pointer to Pointer)详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，指针是一种重要的概念，它存储了一个变量的内存地址。我们通常通过 * 运算符来解引用指针，获取指针指向的值。但 Go 语言还支持更复杂的指针类型，例如指向指针的指针 (Pointer to Pointer)，也称为二级指针 (Double Pointer)。虽然在日常开发中不常用，但理解其工作原理对于深入理解内存管理、某些高级数据结构（如链表、树的修改操作）或在特定场景下修改指针本身的值至关重要。  核心概念：一个指针变量存储一个普通变量的地址，而指向指针的指针存储一个指针变量的地址。   一、基本指针回顾在深入指向指针的指针之前，我们先快速回顾一下 Go 语言中的基本指针：  定义指针：使用 * 符号和类型名来声明一个指针变量，例如 *int 表示一个指向 int 类型的指针。 获取地址：使用 &amp; 运算符来获取一个变量的内存地址。 解引用：使用 * 运算符来访问指针指向的内存中的值。  示例： 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &...</div></div></div></a><a class="pagination-related" href="/f1d2005549f2/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</div></div><div class="info-2"><div class="info-item-1"> 在过去十年中，前端开发领域由 JavaScript 框架（如 React, Vue, Angular）占据主导地位，它们将整个用户界面放在客户端，通过 API 与后端交互。然而，这种“单页应用 (SPA)”模式并非总是最佳选择，它带来了复杂的构建流程、初始加载性能问题、SEO 挑战以及较高的开发和维护成本。 HTMX 的出现，挑战了这一主流范式。它主张将交互逻辑回归到服务器端，通过简单的 HTML 属性就能实现 AJAX 请求、CSS 过渡、WebSocket 和服务器发送事件 (SSE)，在不编写一行 JavaScript 代码的情况下，实现丰富的动态用户体验。  本文将深入探讨 HTMX 的核心理念、工作原理、主要特性、优缺点以及适用场景，帮助你理解这个“返璞归真”但又极具创新力的工具。   一、 HTMX 是什么？核心理念与哲学HTMX 是一个小型 (约 15KB gzipped) 的 JavaScript 库，它通过扩展 HTML 原生能力，允许你在 HTML 元素上直接指定 AJAX 请求、CSS 动画、WebSocket 和服务器发送事件 (SSE) 行为。 其核心...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1cdd169d9683/" title="Cloudflare免费服务详解：守护与加速你的在线资产"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-26</div><div class="info-item-2">Cloudflare免费服务详解：守护与加速你的在线资产</div></div><div class="info-2"><div class="info-item-1"> 在今天的互联网世界，网站和应用程序的性能、安全性和可用性至关重要。对于许多个人站长、小型企业和开发者而言，昂贵的基础设施和安全解决方案往往是难以承受的负担。而这正是 Cloudflare 的价值所在。Cloudflare 以其强大的全球网络和创新的技术，提供了一系列业界领先的免费服务，旨在让任何在线资产都能轻松享受到企业级的性能、安全和可靠性。  “Cloudflare 的免费套餐，不仅仅是‘入门级’，它为数百万网站提供了生产环境级别的保护和加速。对于个人站长和中小企业来说，它是构建和维护在线业务不可或缺的免费‘瑞士军刀’。”   一、Cloudflare 免费服务概述Cloudflare 成立于 2009 年，目标是“构建更好的互联网”。它通过在全球部署大量的边缘节点 (Edge Network)，将 CDN、DNS、DDoS 保护、WAF (Web Application Firewall, Web应用防火墙)、SSL&#x2F;TLS 加密等功能集成在一个平台中。其免费服务涵盖了网站运营的多个核心方面：  DNS 管理：全球最快的 DNS 解析服务。 CDN 加速：内容分...</div></div></div></a><a class="pagination-related" href="/ffb632aa27a9/" title="Cloudflare Workers 代码编写详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-27</div><div class="info-item-2">Cloudflare Workers 代码编写详解</div></div><div class="info-2"><div class="info-item-1"> Cloudflare Workers 是一项基于 V8 引擎的 Serverless 平台，允许开发者在 Cloudflare 的全球网络边缘部署和运行 JavaScript、TypeScript 或 WebAssembly 代码。它将计算逻辑尽可能地靠近用户，从而极大地减少延迟，提高应用响应速度。Workers 的特点是超低延迟、高并发、易于部署和扩展，是构建现代无服务器应用的强大工具。  核心思想：Cloudflare Workers 允许开发者在 Cloudflare 的全球边缘网络上运行轻量级、高性能的无服务器函数。核心开发模式是编写符合 Service Worker API 或 ES Modules 规范的 JavaScript&#x2F;TypeScript 代码，响应 HTTP 请求、与 KV 存储交互、执行自定义逻辑，并通过 Wrangler CLI 进行部署和管理。   一、Cloudflare Workers 基础概念 边缘计算 (Edge Computing)：Workers 代码运行在全球 275+ 个 Cloudflare 数据中心中的任何一个，靠近最...</div></div></div></a><a class="pagination-related" href="/e4825d97fe27/" title="Netlify介绍"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">Netlify介绍</div></div><div class="info-2"><div class="info-item-1"> Netlify 是一个领先的自动化平台，用于部署和托管现代 Web 项目。它将持续集成&#x2F;持续部署 (CI&#x2F;CD)、全球内容分发网络 (CDN)、Serverless Functions 和边缘计算等功能整合到一个统一的工作流中。Netlify 广受欢迎，尤其是在 Jamstack 生态系统中，它简化了 Web 应用程序的构建、部署和扩展过程，让开发者能够专注于代码，而无需管理复杂的服务器基础设施。  核心思想：Netlify 提供了一个一站式的“前端云”平台，它将 Git 仓库连接、自动化构建、全球 CDN 部署、Serverless 后端和附加服务无缝集成，旨在为开发者提供最快速、最简便的现代化 Web 应用部署体验。   一、为什么选择 Netlify？传统的 Web 部署通常涉及配置服务器、管理 CDN、设置 CI&#x2F;CD 管道等复杂任务。Netlify 应运而生，解决了这些痛点，提供了一套高效的解决方案：  极简部署：只需连接 Git 仓库，每次代码提交都会自动构建和部署。 Jamstack 优化：完美支持静态站点生成器 (SSG) 和单页应...</div></div></div></a><a class="pagination-related" href="/320c0615580a/" title="云服务模型详解：SaaS、PaaS、IaaS、BaaS、FaaS"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-05</div><div class="info-item-2">云服务模型详解：SaaS、PaaS、IaaS、BaaS、FaaS</div></div><div class="info-2"><div class="info-item-1"> 随着云计算技术的飞速发展，传统的本地部署 (On-Premise) 模式正逐步被各种 “即服务” (as-a-Service, XaaS) 模型所取代。这些模型为企业和开发者提供了不同层次的抽象和管理便利性，从而降低了运营成本、提高了部署效率和系统弹性。本文将深入解析 IaaS (基础设施即服务)、PaaS (平台即服务)、SaaS (软件即服务) 这三大核心模型，并进一步探讨 BaaS (后端即服务) 和 FaaS (函数即服务) 这些更为专业化的云服务模式。  一、引言：XaaS 模型的演进与核心理念“即服务” (as-a-Service, XaaS) 是一个涵盖广泛的云计算术语，它描述了通过互联网按需提供 IT 资源的服务模式。其核心理念是将 IT 基础设施、平台或软件作为一种服务交付给用户，用户无需购买、安装、维护底层硬件和软件，只需根据使用量付费。 XaaS 模型的主要目标是：  降低成本：减少前期硬件投资和长期运维费用。 提高灵活性：根据业务需求快速扩展或缩减资源。 聚焦核心业务：将 IT 运营的复杂性转移给服务提供商，企业可以更专注于自身的业务创新。 增强可用性与...</div></div></div></a><a class="pagination-related" href="/15920229f914/" title="Supabase 深度解析"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-03</div><div class="info-item-2">Supabase 深度解析</div></div><div class="info-2"><div class="info-item-1"> Supabase 是一个开源的 Firebase 替代品，它提供了一整套后端即服务 (BaaS) 工具，旨在帮助开发者更快地构建应用。Its core philosophical difference from Firebase lies in its foundation: Supabase is built entirely around PostgreSQL作为其核心数据存储，并围绕 PostgreSQL 提供了认证、实时订阅、存储和边缘函数等一系列服务。这使得开发者可以使用熟悉的 SQL 语言来管理数据和定义业务逻辑，同时享受现代化 BaaS 服务的便利。  核心思想：以强大的开源关系型数据库 PostgreSQL 为中心，提供一套集成且可扩展的 BaaS 服务，实现从数据库到 API、认证、实时功能的无缝连接。    一、为什么需要 Supabase？传统上，构建一个功能完善的应用程序需要开发者处理大量的后端基础设施工作，包括：  数据库管理：选择、设置、维护数据库，编写 CRUD API。 用户认证和授权：实现用户注册、登录、密码重置、JWT 管理、权限控制。 实时...</div></div></div></a><a class="pagination-related" href="/f5c29582f368/" title="Serverless 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="info-item-2">Serverless 详解</div></div><div class="info-2"><div class="info-item-1"> Serverless (无服务器) 是一种云计算的执行模型，它允许开发者构建和运行应用程序而无需管理服务器。在这种模型下，云服务提供商负责服务器的调配、维护和扩展，开发者只需关注自己的代码逻辑。Serverless 并不是指“没有服务器”，而是指“开发者不需要关心服务器”。它通常包含两种核心服务模式：函数即服务 (Function-as-a-Service, FaaS) 和 后端即服务 (Backend-as-a-Service, BaaS)。  核心思想：将基础设施管理完全交给云服务商，开发者只需编写代码并部署，按实际使用量付费，实现极致的弹性伸缩和降低运维成本。   一、为什么需要 Serverless？传统的应用部署模型（物理机、虚拟机、容器）都需要开发者或运维团队投入大量精力进行服务器管理：  资源调配：预估并配置合适的 CPU、内存、存储。 操作系统管理：安装、打补丁、更新。 运行时环境：安装语言运行时、库、依赖。 扩展性：根据流量变化手动或自动伸缩服务器集群。 高可用性：设置负载均衡、故障转移机制。 监控与日志：部署监控 agent，收集日志。  这些“非功能性需求...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Argo-Tunnel%EF%BC%9F"><span class="toc-text">一、为什么需要 Argo Tunnel？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Argo-Tunnel-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、Argo Tunnel 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">2.1 核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2 工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="toc-text">2.3 关键概念定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Argo-Tunnel-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF"><span class="toc-text">三、Argo Tunnel 的主要优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Argo-Tunnel-CLI-%E7%A4%BA%E4%BE%8B"><span class="toc-text">四、如何配置 Argo Tunnel (CLI 示例)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%AE%89%E8%A3%85-cloudflared"><span class="toc-text">4.1 1. 安装 cloudflared</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%99%BB%E5%BD%95-Cloudflare-%E8%B4%A6%E6%88%B7"><span class="toc-text">4.2 2. 登录 Cloudflare 账户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%88%9B%E5%BB%BA-Tunnel"><span class="toc-text">4.3 3. 创建 Tunnel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-4-%E5%AE%9A%E4%B9%89-Tunnel-%E9%85%8D%E7%BD%AE-config-yml"><span class="toc-text">4.4 4. 定义 Tunnel 配置 (config.yml)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-5-%E9%85%8D%E7%BD%AE-DNS-%E8%AE%B0%E5%BD%95"><span class="toc-text">4.5 5. 配置 DNS 记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-6-%E8%BF%90%E8%A1%8C-Tunnel"><span class="toc-text">4.6 6. 运行 Tunnel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-7-%E5%B0%86-cloudflared-%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C-Systemd-%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.7 7. 将 cloudflared 作为服务运行 (Systemd 示例)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">五、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-01.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>