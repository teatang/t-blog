<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>I2C (Inter-Integrated Circuit) 协议详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="I2C (Inter-Integrated Circuit) 是一种多主从、半双工、同步串行通信协议，由 Philips Semiconductors (现 NXP) 在 1982 年开发。它以其简单的两线接口（SDA 和 SCL）而闻名，广泛应用于微控制器和各种外设之间进行短距离、中低速的数据交换。I2C 协议因其引脚少、易于扩展等特点，在传感器、EEPROM、LCD 驱动器、实时时钟等众多嵌">
<meta property="og:type" content="article">
<meta property="og:title" content="I2C (Inter-Integrated Circuit) 协议详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/0c4aac42b1a8/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="I2C (Inter-Integrated Circuit) 是一种多主从、半双工、同步串行通信协议，由 Philips Semiconductors (现 NXP) 在 1982 年开发。它以其简单的两线接口（SDA 和 SCL）而闻名，广泛应用于微控制器和各种外设之间进行短距离、中低速的数据交换。I2C 协议因其引脚少、易于扩展等特点，在传感器、EEPROM、LCD 驱动器、实时时钟等众多嵌">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg">
<meta property="article:published_time" content="2024-09-03T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-21T09:51:21.382Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="嵌入式系统">
<meta property="article:tag" content="硬件编程">
<meta property="article:tag" content="硬件协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "I2C (Inter-Integrated Circuit) 协议详解",
  "url": "https://blog.tbf1211.xx.kg/0c4aac42b1a8/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg",
  "datePublished": "2024-09-03T22:24:00.000Z",
  "dateModified": "2026-01-21T09:51:21.382Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/0c4aac42b1a8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'I2C (Inter-Integrated Circuit) 协议详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">512</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">I2C (Inter-Integrated Circuit) 协议详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">I2C (Inter-Integrated Circuit) 协议详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-09-03T22:24:00.000Z" title="发表于 2024-09-04 06:24:00">2024-09-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/">嵌入式系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%8D%8F%E8%AE%AE/">硬件协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>I2C (Inter-Integrated Circuit)</strong> 是一种多主从、半双工、同步串行通信协议，由 Philips Semiconductors (现 NXP) 在 1982 年开发。它以其简单的两线接口（SDA 和 SCL）而闻名，广泛应用于微控制器和各种外设之间进行短距离、中低速的数据交换。I2C 协议因其引脚少、易于扩展等特点，在传感器、EEPROM、LCD 驱动器、实时时钟等众多嵌入式系统中扮演着重要角色。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>基于两条线（SDA、SCL）实现多主多从通信，通过设备地址进行寻址，并有应答机制确保数据传输可靠性。</strong> 线材少、可扩展性强，但速度相对较慢。</p>
</div>
<hr>
<h2 id="一、I2C-协议概述"><a href="#一、I2C-协议概述" class="headerlink" title="一、I2C 协议概述"></a>一、I2C 协议概述</h2><p>I2C 是一种<strong>多主多从 (Multi-Master, Multi-Slave)</strong> 架构的通信协议，允许总线上有多个主设备和多个从设备。</p>
<ul>
<li><strong>主设备 (Master)</strong>：发起和终止通信，生成时钟信号 (SCL)，并向从设备发送或请求数据。</li>
<li><strong>从设备 (Slave)</strong>：响应主设备的请求，根据分配的唯一地址进行通信。</li>
</ul>
<p><strong>主要特点：</strong></p>
<ol>
<li><strong>两线接口</strong>：仅需要两条线——<strong>SDA (串行数据线)</strong> 和 <strong>SCL (串行时钟线)</strong>。</li>
<li><strong>多主多从</strong>：同一总线上可以挂载多个主设备和多个从设备。</li>
<li><strong>同步 (Synchronous)</strong>：通信由一个共享的时钟信号 (SCL) 进行同步。</li>
<li><strong>半双工 (Half-Duplex)</strong>：数据只能在一个方向上传输（要么主设备发送，要么从设备发送），不能同时双向传输。</li>
<li><strong>基于地址寻址</strong>：每个从设备在总线上都有一个唯一的 7 位或 10 位地址，主设备通过地址选择目标从设备。</li>
<li><strong>具应答 (ACK) 机制</strong>：每次发送一个字节后，接收方会发送一个应答信号 (ACK) 或非应答信号 (NACK)，以确认数据是否成功接收。</li>
<li><strong>速度模式</strong>：支持多种速度模式，如标准模式 (100 kbps)、快速模式 (400 kbps)、快速模式+ (1 Mbps)、高速模式 (3.4 Mbps) 等。</li>
</ol>
<h2 id="二、I2C-接口的两条线"><a href="#二、I2C-接口的两条线" class="headerlink" title="二、I2C 接口的两条线"></a>二、I2C 接口的两条线</h2><p>I2C 通信的核心是两条线：</p>
<ol>
<li><strong>SDA (Serial Data Line)</strong>：<strong>串行数据线</strong>。用于双向传输数据。</li>
<li><strong>SCL (Serial Clock Line)</strong>：<strong>串行时钟线</strong>。由 Master 生成，用于同步数据传输。</li>
</ol>
<p>两条线都必须连接到<strong>上拉电阻 (Pull-up Resistor)</strong>。当总线空闲时，SDA 和 SCL 均为高电平。这使得 I2C 成为<strong>开漏 (Open-Drain)</strong> 或 <strong>开集 (Open-Collector)</strong> 总线。</p>
<p><strong>I2C 连接示意图:</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph Master Device
        M_SDA[SDA] --- M_SCL[SCL]
    end

    subgraph Slave Device 1
        S1_SDA[SDA] --- S1_SCL[SCL]
    end

    subgraph Slave Device 2
        S2_SDA[SDA] --- S2_SCL[SCL]
    end

    Rp_SDA[Rpullup] --- VCC(VCC)
    Rp_SCL[Rpullup] --- VCC(VCC)


    M_SDA -- SDA --&gt; S1_SDA
    M_SDA -- SDA --&gt; S2_SDA
    S1_SDA -- SDA --&gt; Rp_SDA
    S2_SDA -- SDA --&gt; Rp_SDA
  
    M_SCL -- SCL --&gt; S1_SCL
    M_SCL -- SCL --&gt; S2_SCL
    S1_SCL -- SCL --&gt; Rp_SCL
    S2_SCL -- SCL --&gt; Rp_SCL
  </pre></div>

<p><strong>上拉电阻的作用：</strong></p>
<ul>
<li>确保当设备不驱动总线时，线路保持高电平。</li>
<li>允许多个设备共同驱动总线（开漏输出）。当任何一个设备将线路拉低时，线路就为低电平；所有设备都释放线路时，线路通过上拉电阻恢复高电平。这实现了“线与”逻辑。</li>
</ul>
<h2 id="三、I2C-通信协议细节"><a href="#三、I2C-通信协议细节" class="headerlink" title="三、I2C 通信协议细节"></a>三、I2C 通信协议细节</h2><p>I2C 通信遵循特定的时序和数据组织结构。</p>
<h3 id="3-1-传输步骤概览"><a href="#3-1-传输步骤概览" class="headerlink" title="3.1 传输步骤概览"></a>3.1 传输步骤概览</h3><p>一个完整的 I2C 传输通常包含以下步骤：</p>
<ol>
<li><strong>起始条件 (START Condition)</strong></li>
<li><strong>发送从设备地址和读写位</strong></li>
<li><strong>接收方发送应答 (ACK) &#x2F; 非应答 (NACK)</strong></li>
<li><strong>数据传输（Master 发送 &#x2F; Master 接收）</strong></li>
<li><strong>接收方发送应答 (ACK) &#x2F; 非应答 (NACK)</strong></li>
<li><strong>停止条件 (STOP Condition)</strong></li>
</ol>
<h3 id="3-2-起始和停止条件"><a href="#3-2-起始和停止条件" class="headerlink" title="3.2 起始和停止条件"></a>3.2 起始和停止条件</h3><ul>
<li><strong>起始条件 (START)</strong>：当 SCL 为高电平时，SDA 从高电平变为低电平。这是主设备开始通信的信号。</li>
<li><strong>停止条件 (STOP)</strong>：当 SCL 为高电平时，SDA 从低电平变为高电平。这是主设备结束通信的信号。</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant SCL
    participant SDA

    Note over SCL,SDA: Bus Idle (SCL&#x3D;H, SDA&#x3D;H)
    SDA-&gt;SDA: Change H to L (while SCL High)
    Note over SCL,SDA: START Condition
    SCL-&gt;SCL: Starts toggling
    SDA-&gt;SDA: Transmit Data (during SCL Low)
    SCL-&gt;SCL: Continue toggling
    SDA-&gt;SDA: Transmit Data (during SCL Low)
    Note over SCL,SDA: Data Transfer
    SCL-&gt;SCL: Stay High
    SDA-&gt;SDA: Change L to H (while SCL High)
    Note over SCL,SDA: STOP Condition
    Note over SCL,SDA: Bus Idle (SCL&#x3D;H, SDA&#x3D;H)
  </pre></div>

<h3 id="3-3-数据传输"><a href="#3-3-数据传输" class="headerlink" title="3.3 数据传输"></a>3.3 数据传输</h3><ul>
<li><strong>数据有效性</strong>：当 SCL 为高电平期间，SDA 上的数据必须保持稳定。只有在 SCL 为低电平期间，SDA 上的数值才能改变（数据位从 Master 移位到 Slave，或反之）。</li>
<li><strong>字节传输</strong>：数据以 8 位字节的形式传输，每次传输一个字节。</li>
<li><strong>应答 (ACK) &#x2F; 非应答 (NACK)</strong>：在每个 8 位字节传输完成后，发送方会释放 SDA 线，接收方在第 9 个时钟脉冲期间拉低 SDA 作为应答 (ACK)。如果接收方没有拉低 SDA，则表示非应答 (NACK)，通常意味着接收失败、设备忙或不支持该命令。</li>
</ul>
<p><strong>数据传输时序图 (单字节写入为例):</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Master
    participant Slave

    Note over Master,Slave: Bus Idle (SDA&#x3D;H, SCL&#x3D;H)
    Master-&gt;Slave: START Condition (SDA: H-&gt;L while SCL: H)
    Master-&gt;Slave: Send 7-bit Slave Address + Write Bit (0)
 
    Slave-&gt;Master: ACK (pull SDA low for 9th SCL pulse)
  
    Master-&gt;Slave: Send Data Byte 1
    Slave-&gt;Master: ACK

    Master-&gt;Slave: Send Data Byte 2
    Slave-&gt;Master: ACK
  
    Master-&gt;Slave: STOP Condition (SDA: L-&gt;H while SCL: H)
    Note over Master,Slave: Bus Idle (SDA&#x3D;H, SCL&#x3D;H)
  </pre></div>

<h3 id="3-4-从设备地址和读写位"><a href="#3-4-从设备地址和读写位" class="headerlink" title="3.4 从设备地址和读写位"></a>3.4 从设备地址和读写位</h3><p>在起始条件之后，主设备会发送一个字节，其中包含：</p>
<ul>
<li><strong>7 位从设备地址</strong>：用于唯一标识总线上的目标从设备。</li>
<li><strong>1 位读写位 (R&#x2F;W#)</strong>：<ul>
<li><code>0</code> 表示主设备要<strong>写入</strong>（发送）数据到从设备。</li>
<li><code>1</code> 表示主设备要<strong>读取</strong>（接收）数据从从设备。</li>
</ul>
</li>
</ul>
<p>所以，第一个传输的字节实际上是 <code>[Slave Address (7 bits)][R/W# (1 bit)]</code>。</p>
<h3 id="3-5-10-位地址模式-扩展"><a href="#3-5-10-位地址模式-扩展" class="headerlink" title="3.5 10 位地址模式 (扩展)"></a>3.5 10 位地址模式 (扩展)</h3><p>除了标准的 7 位地址，I2C 也支持 10 位地址寻址，以允许更多的设备连接。10 位地址模式通过特定的前缀字节来区分。</p>
<h2 id="四、I2C-的优缺点"><a href="#四、I2C-的优缺点" class="headerlink" title="四、I2C 的优缺点"></a>四、I2C 的优缺点</h2><h3 id="4-1-优点："><a href="#4-1-优点：" class="headerlink" title="4.1 优点："></a>4.1 优点：</h3><ol>
<li><strong>引脚数量少</strong>：只需要 SDA 和 SCL 两根线，节省了微控制器的 I&#x2F;O 资源和 PCB 走线空间。</li>
<li><strong>多主多从</strong>：支持多个主设备和多个从设备在同一总线上通信，系统扩展性强。</li>
<li><strong>地址寻址</strong>：通过设备地址选择通信目标，方便管理多个从设备。</li>
<li><strong>应答机制</strong>：提供数据传输的可靠性确认，接收方发送 ACK&#x2F;NACK。</li>
<li><strong>软件实现简单</strong>：相对于一些更复杂的协议，I2C 容易用软件模拟实现。</li>
</ol>
<h3 id="4-2-缺点："><a href="#4-2-缺点：" class="headerlink" title="4.2 缺点："></a>4.2 缺点：</h3><ol>
<li><strong>速度相对慢</strong>：标准模式下只有 100 kbps，快速模式也只有 400 kbps，不如 SPI 协议快。</li>
<li><strong>复杂性较高</strong>：时序相对 SPI 复杂，需要处理起始&#x2F;停止条件、地址寻址、应答位等。</li>
<li><strong>总线电容和上拉电阻选择</strong>：对总线电容敏感，在长距离或高速模式下，选择合适的上拉电阻值变得重要，且可能需要更强的驱动能力。</li>
<li><strong>没有片选线</strong>：由于依靠地址寻址，如果两个 I2C 设备具有相同的地址，则无法在同一总线上使用。</li>
<li><strong>半双工通信</strong>：无法同时发送和接收数据。</li>
</ol>
<h2 id="五、I2C-的应用场景"><a href="#五、I2C-的应用场景" class="headerlink" title="五、I2C 的应用场景"></a>五、I2C 的应用场景</h2><p>I2C 在各种嵌入式应用中广泛使用，尤其是在需要连接多个低速外设的场合：</p>
<ul>
<li><strong>传感器</strong>：温度传感器、湿度传感器、加速度计、陀螺仪、磁力计等。</li>
<li><strong>存储器</strong>：EEPROM (电可擦除可编程只读存储器)。</li>
<li><strong>实时时钟 (RTC)</strong>。</li>
<li><strong>LCD&#x2F;OLED 屏幕控制器</strong>。</li>
<li><strong>I&#x2F;O 扩展器</strong>：通过 I2C 控制额外的 GPIO。</li>
<li><strong>电源管理</strong>芯片。</li>
<li><strong>ADC&#x2F;DAC</strong> (模数&#x2F;数模转换器)。</li>
</ul>
<h2 id="六、I2C-编程示例-Arduino-Go-TinyGo"><a href="#六、I2C-编程示例-Arduino-Go-TinyGo" class="headerlink" title="六、I2C 编程示例 (Arduino &#x2F; Go - TinyGo)"></a>六、I2C 编程示例 (Arduino &#x2F; Go - TinyGo)</h2><h3 id="6-1-Arduino-C-示例-Master-发送数据到-Slave"><a href="#6-1-Arduino-C-示例-Master-发送数据到-Slave" class="headerlink" title="6.1 Arduino (C++) 示例 (Master 发送数据到 Slave)"></a>6.1 Arduino (C++) 示例 (Master 发送数据到 Slave)</h3><p>Arduino IDE 为 I2C 通信提供了方便的 <code>Wire</code> 库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span> <span class="comment">// 引入 Wire 库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设从设备地址为 0x27 (常见的 LCD I2C 模块地址)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SLAVE_ADDRESS = <span class="number">0x27</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line">  Wire.<span class="built_in">begin</span>(); <span class="comment">// 初始化 I2C 总线，作为 Master</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;I2C Master init complete.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Wire.<span class="built_in">beginTransmission</span>(SLAVE_ADDRESS); <span class="comment">// 开始与从设备通信，指定地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(<span class="string">&quot;Hello I2C!&quot;</span>); <span class="comment">// 发送字符串</span></span><br><span class="line">  Wire.<span class="built_in">write</span>(<span class="number">0x0A</span>);         <span class="comment">// 发送一个字节 (换行符)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结束传输，发送停止条件</span></span><br><span class="line">  <span class="comment">// 返回值：</span></span><br><span class="line">  <span class="comment">// 0: success</span></span><br><span class="line">  <span class="comment">// 1: data too long to fit in transmit buffer</span></span><br><span class="line">  <span class="comment">// 2: received NACK on transmit of address</span></span><br><span class="line">  <span class="comment">// 3: received NACK on transmit of data</span></span><br><span class="line">  <span class="comment">// 4: other error</span></span><br><span class="line">  byte status = Wire.<span class="built_in">endTransmission</span>(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Data sent successfully.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;Error sending data, status: &quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>); <span class="comment">// 每2秒发送一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-TinyGo-Go-on-ESP32-示例-Master-读写数据"><a href="#6-2-TinyGo-Go-on-ESP32-示例-Master-读写数据" class="headerlink" title="6.2 TinyGo (Go) on ESP32 示例 (Master 读写数据)"></a>6.2 TinyGo (Go) on ESP32 示例 (Master 读写数据)</h3><p>TinyGo 同样提供了 <code>machine</code> 包来控制 I2C 外设。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;machine&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 I2C 通信引脚和从设备地址</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	I2C_SDA = machine.GPIO21 <span class="comment">// ESP32 默认 SDA</span></span><br><span class="line">	I2C_SCL = machine.GPIO22 <span class="comment">// ESP32 默认 SCL</span></span><br><span class="line">	SLAVE_ADDR = <span class="number">0x27</span> <span class="comment">// 假设的从设备地址</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	i2c = machine.I2C0 <span class="comment">// 使用 I2C0 接口</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	machine.InitSerial() <span class="comment">// 初始化串口用于调试输出</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置 I2C 外设</span></span><br><span class="line">	i2c.Configure(machine.I2CConfig&#123;</span><br><span class="line">		SDA:       I2C_SDA,</span><br><span class="line">		SCL:       I2C_SCL,</span><br><span class="line">		Frequency: machine.I2C400kHz, <span class="comment">// 设置为快速模式 400kHz</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;I2C Master init complete. Scanning...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// I2C 设备扫描 (可选，用于发现总线上的设备)</span></span><br><span class="line">	scanI2CDevices()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写入数据示例</span></span><br><span class="line">	writeData := []<span class="type">byte</span>(<span class="string">&quot;Hello from TinyGo!&quot;</span>)</span><br><span class="line">	err := i2c.Tx(<span class="type">uint16</span>(SLAVE_ADDR), writeData, <span class="literal">nil</span>) <span class="comment">// 写操作: address, data_to_write, data_to_read</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;I2C Write Error:&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;Data &#x27;&quot;</span>, <span class="type">string</span>(writeData), <span class="string">&quot;&#x27; sent to 0x&quot;</span>, byteToHex(SLAVE_ADDR), <span class="string">&quot; successfully.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取数据示例 (这里假设从设备在写入后立即发送数据，实际情况会先写寄存器地址再读)</span></span><br><span class="line">    <span class="comment">// 通常从一个特定寄存器读取，例如先发送寄存器地址，再读取</span></span><br><span class="line">    <span class="comment">// 假设我们要读取一个字节作为示例</span></span><br><span class="line">    readBuf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)</span><br><span class="line">    err = i2c.Tx(<span class="type">uint16</span>(SLAVE_ADDR), <span class="literal">nil</span>, readBuf) <span class="comment">// 读操作: address, nil, data_to_read</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;I2C Read Error:&quot;</span>, err.Error())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;Data 0x&quot;</span>, byteToHex(readBuf[<span class="number">0</span>]), <span class="string">&quot; recieved from 0x&quot;</span>, byteToHex(SLAVE_ADDR), <span class="string">&quot; successfully.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：将 byte 转换为十六进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteToHex</span><span class="params">(b <span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	hex := <span class="string">&quot;0123456789ABCDEF&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(hex[b&gt;&gt;<span class="number">4</span>]) + <span class="type">string</span>(hex[b&amp;<span class="number">0x0F</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：扫描 I2C 设备</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanI2CDevices</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;Scanning I2C bus for devices...&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> addr := <span class="type">uint16</span>(<span class="number">1</span>); addr &lt; <span class="number">127</span>; addr++ &#123; <span class="comment">// 7位地址范围</span></span><br><span class="line">		<span class="comment">// 尝试进行空写操作，看是否有设备响应</span></span><br><span class="line">		err := i2c.Tx(addr, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;Found I2C device at address 0x&quot;</span>, byteToHex(<span class="type">byte</span>(addr)))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;I2C scan complete.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>I2C 协议以其简单的两线接口、多主多从能力和地址寻址机制，在嵌入式系统中广泛应用于连接各种外设。它提供了可靠的数据传输，但速度相对较慢，且对总线电容和上拉电阻的选择有一定的要求。在进行 I2C 开发时，理解其起始&#x2F;停止条件、设备地址、读写位和应答机制至关重要。正确配置总线和选择合适的设备地址，将确保设备间的稳定通信。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/0c4aac42b1a8/">https://blog.tbf1211.xx.kg/0c4aac42b1a8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/">嵌入式系统</a><a class="post-meta__tags" href="/tags/%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A8%8B/">硬件编程</a><a class="post-meta__tags" href="/tags/%E7%A1%AC%E4%BB%B6%E5%8D%8F%E8%AE%AE/">硬件协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/12e9c1578ae9/" title="SPI (Serial Peripheral Interface) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SPI (Serial Peripheral Interface) 协议详解</div></div><div class="info-2"><div class="info-item-1"> SPI (Serial Peripheral Interface) 是一种高性能、全双工、同步串行通信协议，由 Motorola 公司在 1980 年代中期开发。它主要用于在微控制器 (Master) 和各种外设 (Slave) 之间进行短距离、高速的数据交换。SPI 协议因其简单、灵活和高速的特点，在闪存、EEPROM、传感器、实时时钟、LCD 驱动器等众多嵌入式应用中得到了广泛应用。  核心思想：基于四条线（SCLK、MOSI、MISO、CS）实现同步全双工通信，Master 驱动时钟，并通过 CS 选择 Slave。 速度快，但线材多且不具备地址分配能力。   一、SPI 协议概述SPI 是一种主从式 (Master-Slave) 架构的通信协议，通常有一个主设备 (Master) 和一个或多个从设备 (Slave)。  主设备 (Master)：负责启动和控制通信，提供时钟信号。 从设备 (Slave)：在主设备的控制下进行数据传输。  主要特点：  全双工 (Full-Duplex)：主设备和从设备可以同时发送和接收数据。 同步 (Synchronous)：通信由一个...</div></div></div></a><a class="pagination-related" href="/33b687b11065/" title="GoLang gRPC 详解：构建高性能、跨语言的微服务"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">GoLang gRPC 详解：构建高性能、跨语言的微服务</div></div><div class="info-2"><div class="info-item-1"> Golang (Go) 因其并发特性、高效的运行时和优秀的网络编程能力，成为开发高性能后端服务，特别是微服务和 RPC 服务的热门选择。gRPC 作为 Google 主导的 RPC 框架，与 Go 语言有着天然的契合。本文将详细介绍如何使用 Go 语言开发 gRPC 项目，包括环境搭建、.proto 文件定义、代码生成、客户端与服务器实现，以及高级特性。  前置条件： 读者需要对 Go 语言有基本的了解，并已安装 Go 开发环境。   一、环境准备在开始 Go gRPC 项目开发之前，需要安装以下工具：  Go 语言环境：确保 Go 已正确安装，并配置好 GOPATH 和 GOROOT。1go version Protobuf 编译器 (protoc)：用于将 .proto 文件编译成 Go 代码。 下载地址：Protocol Buffers GitHub Releases 根据操作系统下载对应版本，解压后将 bin 目录添加到系统 PATH 环境变量中。 验证安装：1protoc --version   Go gRPC 插件：用于 protoc 生成 Go 语言的 gRPC ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/12e9c1578ae9/" title="SPI (Serial Peripheral Interface) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-05</div><div class="info-item-2">SPI (Serial Peripheral Interface) 协议详解</div></div><div class="info-2"><div class="info-item-1"> SPI (Serial Peripheral Interface) 是一种高性能、全双工、同步串行通信协议，由 Motorola 公司在 1980 年代中期开发。它主要用于在微控制器 (Master) 和各种外设 (Slave) 之间进行短距离、高速的数据交换。SPI 协议因其简单、灵活和高速的特点，在闪存、EEPROM、传感器、实时时钟、LCD 驱动器等众多嵌入式应用中得到了广泛应用。  核心思想：基于四条线（SCLK、MOSI、MISO、CS）实现同步全双工通信，Master 驱动时钟，并通过 CS 选择 Slave。 速度快，但线材多且不具备地址分配能力。   一、SPI 协议概述SPI 是一种主从式 (Master-Slave) 架构的通信协议，通常有一个主设备 (Master) 和一个或多个从设备 (Slave)。  主设备 (Master)：负责启动和控制通信，提供时钟信号。 从设备 (Slave)：在主设备的控制下进行数据传输。  主要特点：  全双工 (Full-Duplex)：主设备和从设备可以同时发送和接收数据。 同步 (Synchronous)：通信由一个...</div></div></div></a><a class="pagination-related" href="/077506775fc0/" title="并行通信与串行通信详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-11</div><div class="info-item-2">并行通信与串行通信详解</div></div><div class="info-2"><div class="info-item-1"> 并行通信 (Parallel Communication) 和 串行通信 (Serial Communication) 是数据传输的两种基本方式，它们描述了数据位在时间上的组织方式。理解这两种模式对于设计和选择合适的通信接口至关重要，无论是在计算机内部、设备之间还是网络通信中。  核心思想：  并行通信：一次传输多个数据位，速度快，但需要多条线路。 串行通信：一次传输一个数据位，速度相对慢，但只需要少数线路。    一、并行通信 (Parallel Communication)1.1 基本原理并行通信是指数据以比特组（通常是一个字节或一个字）的形式，在多条独立的线路上同时进行传输。每条线传输一个比特位，所有比特位在同一时刻并行到达接收端。      graph TD     subgraph 发送端         Data_In_P[&quot;数据输入 (例如 8 位)&quot;]         ShiftReg_P[并行移位寄存器]     end      subgraph &quot;传输介质 (8条独立数据线)&quot;         Line0[数据线 0...</div></div></div></a><a class="pagination-related" href="/6e7008be1f3e/" title="MQTT (Message Queuing Telemetry Transport) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-09</div><div class="info-item-2">MQTT (Message Queuing Telemetry Transport) 协议详解</div></div><div class="info-2"><div class="info-item-1"> MQTT (Message Queuing Telemetry Transport) 是一种基于 发布&#x2F;订阅 (Publish&#x2F;Subscribe) 模式的轻量级消息协议。它专门设计用于在资源受限的设备和低带宽、高延迟或不可靠的网络环境下，提供可靠的消息传输服务。MQTT 因其简洁、高效和对物联网 (IoT) 场景的良好支持而广受欢迎。  核心思想：MQTT 通过引入一个中心化的消息代理 (Broker) 来解耦消息的发布者 (Publisher) 和订阅者 (Subscriber)，实现异步通信。这种模式使得设备之间无需直接通信，降低了系统的复杂性和耦合度。   一、为什么需要 MQTT？传统的客户端&#x2F;服务器 (Client&#x2F;Server) 模式在物联网场景下存在一些局限性：  资源受限：物联网设备通常内存小、处理能力弱、功耗要求高，复杂的 HTTP&#x2F;HTTPS 协议开销较大。 网络环境恶劣：蜂窝网络、卫星网络等可能存在高延迟、低带宽、频繁断线等问题。 一对多&#x2F;多对一通信：许多物联网应用需要一个设备向多个接收者发送数...</div></div></div></a><a class="pagination-related" href="/1b96782841d6/" title="CAN协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-07</div><div class="info-item-2">CAN协议详解</div></div><div class="info-2"><div class="info-item-1"> CAN (Controller Area Network) 协议 是一种高性能的、面向消息的、串行通信总线协议，最初由德国博世 (Bosch) 公司在1980年代开发，旨在解决汽车电子系统中大量的ECU (Electronic Control Unit) 之间复杂而繁琐的布线问题。如今，CAN协议已广泛应用于汽车、工业自动化、医疗设备、航空电子、机器人等多个领域，成为嵌入式系统中最常用的通信协议之一。  核心思想：CAN协议是一种多主、总线仲裁、基于消息广播、高可靠性的串行通信协议。它允许网络中的所有节点在不中断其他节点通信的情况下，通过非破坏性仲裁机制共享总线，并提供强大的错误检测和故障隔离能力。   一、CAN协议的核心特点CAN协议之所以如此流行，得益于其独特的设计理念和以下核心特点：  多主通信 (Multi-Master)：网络中的任何节点都可以作为发送方，在总线空闲时发起通信。所有连接到总线的节点都可以接收并处理消息。 非破坏性位仲裁 (Non-Destructive Bitwise Arbitration)： 这是CAN协议最独特和强大的功能之一。当多个节点同时试...</div></div></div></a><a class="pagination-related" href="/582be6b6f205/" title="UART (通用异步收发传输器) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-06</div><div class="info-item-2">UART (通用异步收发传输器) 详解</div></div><div class="info-2"><div class="info-item-1"> UART (Universal Asynchronous Receiver&#x2F;Transmitter)，即通用异步收发传输器，是一种硬件设备，用于通过串行端口在计算机或微控制器与外设之间进行异步串行通信。它是最常见、最基本的串行通信方式之一，广泛应用于设备调试、传感器数据传输、模块间通信等场景。  核心思想：UART 通过两根线（发送线 TX 和接收线 RX）以位为单位，按照预设的波特率、数据位、停止位和奇偶校验位，异步传输数据，无需时钟线。   一、为什么需要 UART？在微控制器和外部设备（如电脑、传感器、其他微控制器、蓝牙模块、GPS 模块等）之间进行数据交换是嵌入式系统的核心需求。  并行通信的局限性：并行通信（如 SPI 的某些模式）虽然速度快，但需要多根数据线（例如 8 位数据需要 8 根线），这会增加硬件成本、PCB 布线难度和功耗，尤其是在远距离传输时容易产生信号同步问题。 串行通信的优势：串行通信每次只发送一个数据位，大大减少了所需的信号线数量（UART 只需要两根线），简化了硬件设计。 异步通信的简便性：UART 是一种异步通信协议，这意味着发送方和...</div></div></div></a><a class="pagination-related" href="/8f61c0491f9b/" title="ESP32 脉冲信号处理详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">ESP32 脉冲信号处理详解</div></div><div class="info-2"><div class="info-item-1"> ESP32 是一款功能强大的 Wi-Fi 和蓝牙双模芯片，其丰富的硬件外设使其在处理各种脉冲信号方面表现出色。无论是生成精确的脉冲，还是精确测量外部脉冲，ESP32 都提供了多种灵活高效的解决方案。本文将详细介绍 ESP32 处理脉冲信号的几种主要方式及其适用场景。  核心思想： ESP32 通过集成专用硬件模块（如 PWM、RMT、PCNT）来高效、精确地生成和测量脉冲信号，从而解放 CPU，提高实时性和系统整体性能。   一、脉冲信号基础脉冲信号是指在电平或强度上发生短暂变化的信号。在数字电子中，脉冲通常表现为高电平 (High) 和低电平 (Low) 之间的快速切换。 脉冲的几个关键参数：  周期 (Period)：一个完整脉冲波形所需的时间。 频率 (Frequency)：每秒钟脉冲重复的次数，频率 &#x3D; 1 &#x2F; 周期。 脉宽 (Pulse Width)：脉冲处于高电平或低电平的持续时间。 占空比 (Duty Cycle)：高电平脉宽与周期之比，通常以百分比表示。$占空比 &#x3D; (高电平脉宽 &#x2F; 周期) \times 100%$   ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">512</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81I2C-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-text">一、I2C 协议概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81I2C-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%A4%E6%9D%A1%E7%BA%BF"><span class="toc-text">二、I2C 接口的两条线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81I2C-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%BB%86%E8%8A%82"><span class="toc-text">三、I2C 通信协议细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BC%A0%E8%BE%93%E6%AD%A5%E9%AA%A4%E6%A6%82%E8%A7%88"><span class="toc-text">3.1 传输步骤概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%B5%B7%E5%A7%8B%E5%92%8C%E5%81%9C%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.2 起始和停止条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">3.3 数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BB%8E%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E5%92%8C%E8%AF%BB%E5%86%99%E4%BD%8D"><span class="toc-text">3.4 从设备地址和读写位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-10-%E4%BD%8D%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F-%E6%89%A9%E5%B1%95"><span class="toc-text">3.5 10 位地址模式 (扩展)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81I2C-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">四、I2C 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">4.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">4.2 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81I2C-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、I2C 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81I2C-%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B-Arduino-Go-TinyGo"><span class="toc-text">六、I2C 编程示例 (Arduino &#x2F; Go - TinyGo)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Arduino-C-%E7%A4%BA%E4%BE%8B-Master-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0-Slave"><span class="toc-text">6.1 Arduino (C++) 示例 (Master 发送数据到 Slave)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-TinyGo-Go-on-ESP32-%E7%A4%BA%E4%BE%8B-Master-%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-text">6.2 TinyGo (Go) on ESP32 示例 (Master 读写数据)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-18.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>