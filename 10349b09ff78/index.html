<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Signal Protocol 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Signal Protocol（前身为 TextSecure Protocol）是一个现代的、开源的、密码学加强的端到端加密 (End-to-End Encryption, E2EE) 协议，旨在为异步和同步即时通讯应用提供消息的机密性、完整性、认证性和不可抵赖性。它由 Open Whisper Systems（现为 Signal Foundation 和 Signal Messenger LL">
<meta property="og:type" content="article">
<meta property="og:title" content="Signal Protocol 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/10349b09ff78/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Signal Protocol（前身为 TextSecure Protocol）是一个现代的、开源的、密码学加强的端到端加密 (End-to-End Encryption, E2EE) 协议，旨在为异步和同步即时通讯应用提供消息的机密性、完整性、认证性和不可抵赖性。它由 Open Whisper Systems（现为 Signal Foundation 和 Signal Messenger LL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg">
<meta property="article:published_time" content="2026-02-03T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-26T03:25:52.183Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Signal Protocol 详解",
  "url": "https://blog.tbf1211.xx.kg/10349b09ff78/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg",
  "datePublished": "2026-02-03T22:24:00.000Z",
  "dateModified": "2026-02-26T03:25:52.183Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/10349b09ff78/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Signal Protocol 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">557</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Signal Protocol 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Signal Protocol 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Signal Protocol</strong>（前身为 TextSecure Protocol）是一个<strong>现代的、开源的、密码学加强的端到端加密 (End-to-End Encryption, E2EE) 协议</strong>，旨在为异步和同步即时通讯应用提供消息的机密性、完整性、认证性和不可抵赖性。它由 Open Whisper Systems（现为 Signal Foundation 和 Signal Messenger LLC）开发，最初用于 Signal 应用，现已被WhatsApp、Facebook Messenger（在“秘密对话”模式下）、Google Messages（在 RCS 聊天中）等主流通讯应用广泛采用，成为业界公认的E2EE黄金标准之一。</p>
</blockquote>
<div class="note info flat"><p>核心思想：Signal Protocol 通过巧妙结合<strong>双棘轮算法 (Double Ratchet Algorithm)</strong>、<strong>预密钥 (Pre-keys)</strong> 和 <strong>扩展的 Diffie-Hellman 密钥交换 (X3DH)</strong>，实现了<strong>前向保密性 (Forward Secrecy)</strong> 和 <strong>未来保密性&#x2F;后向保密性 (Future Secrecy&#x2F;Post-Compromise Security)</strong>，确保即使长期密钥或一部分会话密钥被泄露，过去和未来的消息仍能保持安全。</p>
</div>
<hr>
<h2 id="一、为什么需要-Signal-Protocol？"><a href="#一、为什么需要-Signal-Protocol？" class="headerlink" title="一、为什么需要 Signal Protocol？"></a>一、为什么需要 Signal Protocol？</h2><p>在数字通讯日益普及的今天，用户隐私面临着多重威胁：</p>
<ul>
<li><strong>数据窃听</strong>：消息在传输过程中可能被第三方截获和阅读。</li>
<li><strong>服务器入侵</strong>：即使通讯服务商的服务器被攻破，存储在其中的消息也可能被窃取。</li>
<li><strong>政府或恶意实体监控</strong>：通过各种手段强制服务商提供用户数据。</li>
<li><strong>中间人攻击 (Man-in-the-Middle Attacks)</strong>：攻击者截获并篡改通信双方的消息。</li>
</ul>
<p><strong>端到端加密 (E2EE)</strong> 是解决这些问题的核心技术。E2EE 确保消息从发送方设备发出时即加密，只有接收方设备才能解密。在整个传输路径中，包括服务器在内，任何第三方都无法读取消息内容。</p>
<p>Signal Protocol 正是为了提供一个强大、高效且经过验证的 E2EE 解决方案而设计的。</p>
<h2 id="二、Signal-Protocol-的核心概念与密码学基础"><a href="#二、Signal-Protocol-的核心概念与密码学基础" class="headerlink" title="二、Signal Protocol 的核心概念与密码学基础"></a>二、Signal Protocol 的核心概念与密码学基础</h2><p>Signal Protocol 的安全基石在于其对以下密码学原语和概念的巧妙运用：</p>
<ol>
<li><strong>非对称加密 (Asymmetric Encryption)</strong>：使用一对公钥和私钥。公钥用于加密，私钥用于解密。Signal Protocol 使用 <strong>椭圆曲线 Diffie-Hellman (ECDH)</strong> 密钥交换来建立共享的秘密。<ul>
<li><strong>ECDH</strong>：允许通信双方通过不安全的公开信道协商出一个共享的秘密密钥，而无需提前共享任何秘密。</li>
</ul>
</li>
<li><strong>对称加密 (Symmetric Encryption)</strong>：使用相同的密钥进行加密和解密。Signal Protocol 使用对称密钥（如 AES256）来加密实际的消息内容，因为对称加密比非对称加密效率更高。</li>
<li><strong>密钥派生函数 (Key Derivation Function, KDF)</strong>：从一个或多个秘密值生成新的、高质量的加密密钥的函数。在 Signal Protocol 中用于从 ECDH 协商的共享秘密中派生出多个不同的会话密钥。</li>
<li><strong>前向保密性 (Forward Secrecy, FS)</strong>：即使一个长期私钥被泄露，过去加密的会话内容仍然保持安全。这是通过确保每个会话的密钥都是临时的、独立的且尽快销毁来实现的。</li>
<li><strong>未来保密性 &#x2F; 后向保密性 (Future Secrecy &#x2F; Post-Compromise Security, PCS)</strong>：即使当前会话密钥被泄露，未来的会话内容仍然保持安全。这是通过每次消息交换都更新会话密钥，且不依赖于过去的任何泄露密钥来实现的。</li>
</ol>
<h2 id="三、Signal-Protocol-的关键机制"><a href="#三、Signal-Protocol-的关键机制" class="headerlink" title="三、Signal Protocol 的关键机制"></a>三、Signal Protocol 的关键机制</h2><p>Signal Protocol 的核心是 <strong>扩展的 Diffie-Hellman (X3DH) 密钥交换</strong> 和 <strong>双棘轮算法 (Double Ratchet Algorithm)</strong>。</p>
<h3 id="3-1-扩展的-Diffie-Hellman-X3DH-密钥交换协议"><a href="#3-1-扩展的-Diffie-Hellman-X3DH-密钥交换协议" class="headerlink" title="3.1 扩展的 Diffie-Hellman (X3DH) 密钥交换协议"></a>3.1 扩展的 Diffie-Hellman (X3DH) 密钥交换协议</h3><p>X3DH 协议用于在两个用户首次建立通信时，以异步方式（例如，一个用户不在线）协商一个共享的根密钥 (<code>SK</code>)。它通过结合静态密钥和临时密钥来实现：</p>
<ul>
<li><strong>身份密钥对 (Identity Key Pair, IK)</strong>：长期的、签名过的密钥对。每个用户拥有一对，用于身份识别和签名。</li>
<li><strong>签名预密钥对 (Signed Pre-key Pair, SPK)</strong>：中期的、由身份私钥签名的密钥对。用户生成几对，并将其公钥连同签名上传到服务器。</li>
<li><strong>一次性预密钥对 (One-Time Pre-key Pair, OPK)</strong>：短期的、未使用签名的密钥对。用户生成大量，并将其公钥上传到服务器。一旦使用就被销毁。</li>
</ul>
<p><strong>交换流程概述</strong>：</p>
<ol>
<li><strong>预发布</strong>：Alice 将她自己的一些（SPK, OPK）公钥上传到服务器。Bob 也做同样的事情。</li>
<li><strong>初始联系</strong>：当 Alice 想要向 Bob 发送消息时，她从服务器请求 Bob 的公钥包 (Key Bundle)，其中包含：<ul>
<li>Bob 的身份公钥 (IK_Bob)</li>
<li>Bob 的签名预密钥公钥 (SPK_Bob)</li>
<li>Bob 的签名预密钥签名 (Signature of SPK_Bob by IK_Bob)</li>
<li>Bob 的一个一次性预密钥公钥 (OPK_Bob)。如果 Bob 没有可用的一次性预密钥，就使用没有 OPK 的 Key Bundle。</li>
</ul>
</li>
<li><strong>协商共享秘密</strong>：Alice 使用自己的私钥和从服务器获取的 Bob 的公钥，进行四次 ECDH 密钥协商，计算出四个共享秘密：<ul>
<li>DH(IK_Alice, IK_Bob)</li>
<li>DH(EK_Alice, IK_Bob)  (EK_Alice 是 Alice 生成的临时 Ephemeral Key Pair)</li>
<li>DH(IK_Alice, SPK_Bob)</li>
<li>DH(EK_Alice, SPK_Bob)</li>
<li>如果 Bob 有 OPK_Bob，则再计算 DH(IK_Alice, OPK_Bob) 或 DH(EK_Alice, OPK_Bob)<br>这些共享秘密通过密钥派生函数 (KDF) 组合在一起，生成一个初始的<strong>根密钥 (Root Key, RK)</strong> 和<strong>链密钥 (Chain Key, CK)</strong>。</li>
</ul>
</li>
<li><strong>销毁 OPK</strong>：一旦 OPK_Bob 被 Alice 使用，服务器就会将其从 Key Bundle 中删除。</li>
<li><strong>首次消息发送</strong>：Alice 使用这个根密钥和链密钥，通过双棘轮算法开始加密第一条消息并发送给 Bob。消息中包含 Alice 的 Ephemeral Public Key (EK_Alice)。</li>
</ol>
<p>X3DH 协议确保了即使 Bob 不在线，Alice 也能安全地开始与 Bob 的加密通信，并提供了身份认证。</p>
<h3 id="3-2-双棘轮算法-Double-Ratchet-Algorithm"><a href="#3-2-双棘轮算法-Double-Ratchet-Algorithm" class="headerlink" title="3.2 双棘轮算法 (Double Ratchet Algorithm)"></a>3.2 双棘轮算法 (Double Ratchet Algorithm)</h3><p>双棘轮算法是 Signal Protocol 的核心，它实现了<strong>前向保密性</strong>和<strong>未来保密性</strong>。每次消息发送都会更新会话密钥，确保即使当前链上的某个密钥泄露，也不会影响到其他密钥。</p>
<p>双棘轮算法维护了以下几个重要概念：</p>
<ul>
<li><strong>根密钥 (Root Key, RK)</strong>：用于派生后继的根密钥和链密钥。</li>
<li><strong>发送链密钥 (Sending Chain Key, SCK)</strong>：用于派生发送消息的对称加密密钥。</li>
<li><strong>接收链密钥 (Receiving Chain Key, RCK)</strong>：用于派生接收消息的对称加密密钥。</li>
<li><strong>消息密钥 (Message Key, MK)</strong>：实际用于加密和解密每一条消息的对称密钥。</li>
<li><strong>发送方&#x2F;接收方棘轮公钥 (Ephemeral Key Pair)</strong>：用于每次密钥更新的新的 ECDH 密钥对。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<p>双棘轮算法结合了两种“棘轮”机制：</p>
<ol>
<li><p><strong>对称密钥棘轮 (Symmetric-Key Ratchet)</strong>：</p>
<ul>
<li>每次发送消息时，基于当前的链密钥 (SCK 或 RCK) 使用 KDF 派生出新的消息密钥 (MK)。然后，再从旧的链密钥生成一个新的链密钥。</li>
<li>这意味着每一条消息都有一个<strong>新的、独立的、一次性的消息密钥</strong>。</li>
<li>如果攻击者获得当前链密钥，他们可以解密以该链密钥加密的未来消息，但无法解密过去的（已派生出并销毁其生成密钥的）消息。这提供了<strong>前向保密性</strong>。</li>
</ul>
</li>
<li><p><strong>DH 棘轮 (Diffie-Hellman Ratchet)</strong>：</p>
<ul>
<li>每次两个通信方更新棘轮公钥时，双方会执行一个新的 ECDH 密钥交换。</li>
<li>这个新的 ECDH 共享秘密被用于更新根密钥 (RK)，然后由 RK 派生出新的发送链密钥和接收链密钥。</li>
<li><strong>关键点</strong>：如果攻击者在某个时刻窃取了所有链密钥，一旦发生一次成功的 DH 密钥更新（即双方都交换了新的棘轮公钥），攻击者就无法解密未来的消息了，因为新的链密钥是由新的、未曾泄露的 DH 秘密派生而来的。这提供了<strong>未来保密性&#x2F;后向保密性</strong>。</li>
</ul>
</li>
</ol>
<p>通过这两种棘轮机制的结合，确保了无论攻击者何时获取了通信方的秘密信息（只要不是持续的完全控制），都能最大程度地限制泄露的范围。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph &quot;Initial Setup (X3DH)&quot;
        A[Alice IK, SPK, OPK] --&gt;|Upload Public Keys| Server;
        B[Bob IK, SPK, OPK] --&gt;|Upload Public Keys| Server;
        Alice[Alice] --Request Bob&#39;s Key Bundle--&gt; Server;
        Alice --&quot;Calculates Initial RK, SCK(Alice), RCK(Bob) (via 4 ECDH)&quot;--&gt; Bob;
    end

    subgraph Double Ratchet Algorithm
        direction LR
        A_DR[Alice&#39;s Double Ratchet State]
        B_DR[Bob&#39;s Double Ratchet State]

        A_DR --&gt;|Generate new Ephemeral Key EK_A| A_DR
        A_DR --&gt;|Derive SCK, RCK from RK; MK from SCK| A_DR

        A_DR --&gt;|&quot;Encrypt Message (MK_A), Attach EK_A&quot;| B_DR;
        B_DR --&gt;|Update RCK, derive MK_A from RCK, Decrypt Message| B_DR;
        B_DR --&gt;|Generate new Ephemeral Key EK_B| B_DR
        B_DR --&gt;|Derive SCK, RCK from RK; MK from SCK| B_DR

        B_DR --&gt;|&quot;Encrypt Message (MK_B), Attach EK_B&quot;| A_DR;
        A_DR --&gt;|Update RCK, derive MK_B from RCK, Decrypt Message| A_DR;
    end
  </pre></div>


<h2 id="四、身份验证"><a href="#四、身份验证" class="headerlink" title="四、身份验证"></a>四、身份验证</h2><p>Signal Protocol 提供了机制来验证通信方身份，以防止中间人攻击：</p>
<ul>
<li><strong>安全码 (Safety Numbers)</strong>：Signal 应用会生成一个由数字或二维码表示的“安全码”。用户可以通过面对面比对或通过安全信道验证这个安全码。如果安全码一致，则可以确认双方正在与正确的对象通信。当身份密钥或签名预密钥发生变化时，安全码会发生变化，通知用户可能存在中间人攻击或某一方更换了设备。</li>
</ul>
<h2 id="五、Signal-Protocol-的广泛应用"><a href="#五、Signal-Protocol-的广泛应用" class="headerlink" title="五、Signal Protocol 的广泛应用"></a>五、Signal Protocol 的广泛应用</h2><p>Signal Protocol 因其强大的安全性、开源性以及严谨的密码学设计，已被广泛应用于：</p>
<ul>
<li><strong>Signal Messenger</strong>：所有消息、群组聊天、语音和视频通话都默认使用 Signal Protocol 进行端到端加密。</li>
<li><strong>WhatsApp</strong>：自 2016 年起，WhatsApp 的所有个人和群组聊天、语音和视频通话都默认使用 Signal Protocol 进行端到端加密。</li>
<li><strong>Facebook Messenger</strong>：在“秘密对话”模式下使用 Signal Protocol。</li>
<li><strong>Google Messages</strong>：在支持 RCS (Rich Communication Services) 的对话中，如果双方设备都启用了端到端加密，则使用 Signal Protocol。</li>
<li><strong>Skype</strong>：在“私人对话”模式下使用 Signal Protocol。</li>
<li><strong>Wire</strong>：安全通讯应用，也采用了 Signal Protocol。</li>
</ul>
<h2 id="六、与-MTProto-的对比"><a href="#六、与-MTProto-的对比" class="headerlink" title="六、与 MTProto 的对比"></a>六、与 MTProto 的对比</h2><table>
<thead>
<tr>
<th align="left">特性 &#x2F; 协议</th>
<th align="left">Signal Protocol</th>
<th align="left">MTProto (Telegram)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主要设计者</strong></td>
<td align="left">Open Whisper Systems (Signal Foundation)</td>
<td align="left">Nikolai Durov (Telegram)</td>
</tr>
<tr>
<td align="left"><strong>协议类型</strong></td>
<td align="left"><strong>业经验证的 E2EE 协议</strong></td>
<td align="left"><strong>Telegram 自定义协议</strong></td>
</tr>
<tr>
<td align="left"><strong>端到端加密 (E2EE)</strong></td>
<td align="left"><strong>所有个人聊天和群组聊天默认开启</strong></td>
<td align="left"><strong>仅秘密聊天 (Secret Chats) 开启</strong>；普通云聊天是客户端-服务器加密</td>
</tr>
<tr>
<td align="left"><strong>前向&#x2F;未来保密性</strong></td>
<td align="left"><strong>支持</strong> (通过双棘轮算法)</td>
<td align="left"><strong>秘密聊天支持</strong>；云聊天不明确，通常认为不如 Signal 严格</td>
</tr>
<tr>
<td align="left"><strong>密钥交换</strong></td>
<td align="left"><strong>X3DH</strong> (Extended Diffie-Hellman)</td>
<td align="left">基于 RSA 和 Diffie-Hellman 自定义流程</td>
</tr>
<tr>
<td align="left"><strong>会话密钥管理</strong></td>
<td align="left"><strong>双棘轮算法</strong> (每次消息更新)</td>
<td align="left">秘密聊天中也有密钥更新机制，但不如双棘轮灵活严谨</td>
</tr>
<tr>
<td align="left"><strong>消息加密算法</strong></td>
<td align="left">AES256-GCM, HMAC-SHA256</td>
<td align="left">AES256-IGE, SHA256</td>
</tr>
<tr>
<td align="left"><strong>身份验证 (AoT)</strong></td>
<td align="left"><strong>安全码比对</strong></td>
<td align="left">秘密聊天中的设备指纹比对</td>
</tr>
<tr>
<td align="left"><strong>开源状态</strong></td>
<td align="left"><strong>协议规范和库完全开源且经过广泛审计</strong></td>
<td align="left"><strong>客户端开源，服务器端代码不开源</strong>；协议规范公开</td>
</tr>
<tr>
<td align="left"><strong>行业采纳</strong></td>
<td align="left"><strong>被广泛采纳为 E2EE 黄金标准</strong> (WhatsApp, Google Messages, FB Messenger)</td>
<td align="left">仅 Telegram 自身使用</td>
</tr>
<tr>
<td align="left"><strong>学术审查</strong></td>
<td align="left"><strong>经过大量学术审查和同行评审</strong></td>
<td align="left">较少严格的第三方独立学术审查，由 Telegram 组织了一些竞赛</td>
</tr>
</tbody></table>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Signal Protocol 代表了现代端到端加密通讯的最高水平。它通过结合 X3DH 密钥交换和双棘轮算法，实现了强大<strong>前向保密性</strong>和<strong>未来保密性</strong>，确保了用户通信的隐私不受侵害，即使部分通信秘密被泄露，也能最大程度地限制安全影响。其<strong>开源的特性</strong>和<strong>广泛的学术审查</strong>使其成为业界公认的 E2EE 黄金标准，被众多主流即时通讯应用采用。对于任何关心数字隐私和安全的个人或组织而言，理解和支持 Signal Protocol 及其衍生应用都至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/10349b09ff78/">https://blog.tbf1211.xx.kg/10349b09ff78/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">婴儿早期语音发展中的“Mama”与“Baba”现象探究</div></div><div class="info-2"><div class="info-item-1"> “Mama”与“Baba”现象 是指婴儿在早期语言发展阶段，普遍性地、常常是其最早发出的两个具有清晰音节结构的声音，通常被成年人解读为对父母的呼唤。这一现象并非偶然，而是语言学、发展心理学、认知科学以及社会互动等多方面因素共同作用的结果。本报告将从多个维度深入剖析婴儿为何会普遍性地发出这些特定的音节。  核心观点：婴儿发出“Mama”和“Baba”并非一开始就带有明确的指代意义，而是生理发音机制的便捷性、认知发展阶段的特性以及社会环境的强化作用共同促成的。    一、语音学与生理学基础：发音的便捷性婴儿的口腔肌肉和发音器官在早期处于发育阶段，其运动控制能力有限。从语音学角度来看，“m”、“b”和“a”这些音素的结合，对于尚未完全掌握复杂发音技巧的婴儿而言，具有极高的生理便捷性。 1.1 双唇音（Bilabial Consonants）的易发性双唇音（Bilabial Consonants） 指的是发音时双唇闭合或接近，气流通过或振动双唇产生的辅音。例如：  &#x2F;m&#x2F;：鼻腔双唇音 (bilabial nasal)，发音时双唇闭合，软腭下降，气流通过鼻腔。这是所有...</div></div></div></a><a class="pagination-related" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ECMAScript ShadowRealm 详解</div></div><div class="info-2"><div class="info-item-1"> ShadowRealm 是一个 ECMAScript 提案（目前处于 Stage 3 阶段），旨在为 JavaScript 提供一种新的代码隔离机制。它允许在当前 Realm 中创建一个与主 Realm 具有分离的全局对象 (global object) 和 内置对象 (intrinsic objects) 集合的“影子 Realm”。通过 ShadowRealm，开发者可以在一个安全的、受控的环境中执行不受信任的代码或隔离不同的应用程序组件，提供类似于 iframe 但在 JS 层面更细粒度的沙箱能力。  核心思想：ShadowRealm 创建了一个轻量级的 JavaScript 执行环境沙箱。它提供了一套独立的全局对象和内置对象，但共享相同的事件循环 (event loop) 和微任务队列 (microtask queue)。这种隔离有助于提高代码安全性、隔离第三方库、避免全局污染，并为模块化和可插拔架构提供更强大的支持。   一、为什么需要 ShadowRealm？在 JavaScript 生态系统中，代码隔离一直是一个重要的需求，尤其是在以下场景中：  运行不受信任的代...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/8c33e0b80528/" title="MTProto 加密协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-13</div><div class="info-item-2">MTProto 加密协议详解</div></div><div class="info-2"><div class="info-item-1"> MTProto 是 Telegram 即时通讯应用使用的自定义加密协议。它由尼古拉·杜罗夫 (Nikolai Durov) 设计，旨在实现高速、安全、多设备同步和抗审查的消息传输。MTProto 并非基于现有标准加密协议，而是为适应 Telegram 的特定需求而从头构建。它是一个多层级的协议，涵盖了传输、加密和 API 抽象，是 Telegram 提供其核心价值主张（速度和安全性）的基石。  核心思想：MTProto 是一个专为移动设备和分布式架构优化的加密协议，通过其分层设计和高效二进制格式，在保证强大加密安全性的同时，提供极速响应和无缝的多设备云同步能力。它是 Telegram 服务得以运行的底层技术支柱。   一、背景与起源Telegram 于 2013 年推出时，其创始人帕维尔·杜罗夫 (Pavel Durov) 及其 брат尼古拉·杜罗夫 (Nikolai Durov) 对当时市场上主流的即时通讯协议的性能和安全性感到不满。他们认为这些协议在移动网络环境下效率低下，且未充分考虑多设备同步的需求。因此，尼古拉·杜罗夫着手设计了一个全新的协议，即 MTProto，其目...</div></div></div></a><a class="pagination-related" href="/22aa4c322dbd/" title="TLS (传输层安全协议) 深度详解：网络通信的守护者"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="info-item-2">TLS (传输层安全协议) 深度详解：网络通信的守护者</div></div><div class="info-2"><div class="info-item-1"> TLS (Transport Layer Security)，即传输层安全性协议，是用于在计算机网络上提供端到端安全通信的加密协议。它是 SSL (Secure Sockets Layer) 协议的继任者，两者常被混用，但技术上，现代网络浏览器及服务器都已使用 TLS 协议。TLS 主要提供数据隐私、数据完整性以及通信双方的身份认证，是互联网上最广泛使用的安全协议，例如 HTTPS (HTTP over TLS)、SMTPS、LDAPS 等都依赖于 TLS。  核心思想：在不可信的网络上，通过加密、认证和完整性校验，建立一个可信的加密通信通道。   一、为什么需要 TLS？互联网的早期（例如纯 HTTP 时代），数据在传输过程中是明文的。这意味着：  窃听 (Eavesdropping)：任何中间人（如 ISP、路由器管理员、恶意攻击者）都可以截获并读取传输中的数据，包括用户密码、银行卡信息、私人消息等。 篡改 (Tampering)：中间人不仅可以读取数据，还可以修改数据，例如在网页中植入恶意代码，或者更改用户提交的表单内容。 身份伪装 (Impersonation)：客户端...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/2dc209b3606e/" title="OSI 七层模型详解 (The OSI 7-Layer Model Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-12</div><div class="info-item-2">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</div></div><div class="info-2"><div class="info-item-1"> OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。  核心思想：将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。   一、为什么需要 OSI 模型？在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个统一的标准来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：  标准化：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。 模块化：将复杂的网络通...</div></div></div></a><a class="pagination-related" href="/c5be75f3ed25/" title="WebSocket 详解：实现全双工实时通信"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="info-item-2">WebSocket 详解：实现全双工实时通信</div></div><div class="info-2"><div class="info-item-1"> WebSocket 是一种在单个 TCP 连接上进行全双工（Full-Duplex）通信的网络协议。它在 Web 浏览器和服务器之间提供了一个持久化的连接，允许双方在任何时候发送消息，而无需像传统的 HTTP 请求那样需要先发送请求再接收响应。WebSocket 解决了传统 Web 应用中实现实时通信的诸多难题，是构建实时 Web 应用的关键技术之一。  核心思想：从 HTTP 协议“握手”后，将底层 TCP 连接“升级”为 WebSocket 连接，实现客户端与服务器之间长时间、双向、无阻塞的消息传输，从而大幅降低通信开销，提升实时应用的性能。   一、为什么需要 WebSocket？传统 HTTP 的局限性在 WebSocket 出现之前，Web 应用程序要实现实时通信，如聊天室、股票行情、在线游戏、推送通知等，面临着传统 HTTP 协议的固有局限性：  半双工 (Half-Duplex) 通信：HTTP 协议是单向请求-响应模型。客户端发送请求，服务器返回响应。服务器无法主动向客户端发送消息，除非客户端先发起请求。 效率低下： 频繁连接建立与断开：每个 HTTP 请求都需...</div></div></div></a><a class="pagination-related" href="/18f2ce1e9660/" title="DNS (Domain Name System) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="info-item-2">DNS (Domain Name System) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS (Domain Name System) 是互联网的一项核心服务，它将人类可读的域名（如 www.example.com）转换为机器可读的 IP 地址（如 192.168.1.1 或 2001:0db8::1）。这种翻译功能使得用户可以方便地通过记忆友好的域名来访问网站和其他网络资源，而无需记住复杂的数字 IP 地址。DNS 本质上是一个分布式数据库系统，运行在应用层，通常使用 UDP 的 53 端口进行查询，TCP 53 端口用于区域传输 (zone transfer)。  核心思想：将域名映射到 IP 地址，提供一套全球性的、分层的、分布式数据库系统，从而实现互联网资源的定位和访问。   一、为什么需要 DNS？在互联网的早期，少量的计算机通过一个名为 HOSTS.TXT 的静态文件来完成主机名到 IP 地址的映射。然而，随着计算机数量的爆发式增长，这种中心化的、静态的管理方式变得不可行，主要原因如下：  人类记忆限制：用户难以记住大量复杂且不断变化的 IP 地址。 管理困难：集中式文件更新和同步的效率低下，无法适应全球范围内的网络变化。 扩展性差：集中式系统无法承...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">557</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Signal-Protocol%EF%BC%9F"><span class="toc-text">一、为什么需要 Signal Protocol？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Signal-Protocol-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-text">二、Signal Protocol 的核心概念与密码学基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Signal-Protocol-%E7%9A%84%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6"><span class="toc-text">三、Signal Protocol 的关键机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%89%A9%E5%B1%95%E7%9A%84-Diffie-Hellman-X3DH-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1 扩展的 Diffie-Hellman (X3DH) 密钥交换协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%8C%E6%A3%98%E8%BD%AE%E7%AE%97%E6%B3%95-Double-Ratchet-Algorithm"><span class="toc-text">3.2 双棘轮算法 (Double Ratchet Algorithm)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-text">四、身份验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Signal-Protocol-%E7%9A%84%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8"><span class="toc-text">五、Signal Protocol 的广泛应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%B8%8E-MTProto-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">六、与 MTProto 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e3b0c5d197a/" title="Web Components 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Components 详解"/></a><div class="content"><a class="title" href="/4e3b0c5d197a/" title="Web Components 详解">Web Components 详解</a><time datetime="2026-02-07T22:24:00.000Z" title="发表于 2026-02-08 06:24:00">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-17.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>