<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Signal Protocol 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Signal Protocol（前身为 TextSecure Protocol）是一个现代的、开源的、密码学加强的端到端加密 (End-to-End Encryption, E2EE) 协议，旨在为异步和同步即时通讯应用提供消息的机密性、完整性、认证性和不可抵赖性。它由 Open Whisper Systems（现为 Signal Foundation 和 Signal Messenger LL">
<meta property="og:type" content="article">
<meta property="og:title" content="Signal Protocol 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/10349b09ff78/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Signal Protocol（前身为 TextSecure Protocol）是一个现代的、开源的、密码学加强的端到端加密 (End-to-End Encryption, E2EE) 协议，旨在为异步和同步即时通讯应用提供消息的机密性、完整性、认证性和不可抵赖性。它由 Open Whisper Systems（现为 Signal Foundation 和 Signal Messenger LL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg">
<meta property="article:published_time" content="2026-02-03T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-04T09:47:15.129Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Signal Protocol 详解",
  "url": "https://blog.tbf1211.xx.kg/10349b09ff78/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg",
  "datePublished": "2026-02-03T22:24:00.000Z",
  "dateModified": "2026-02-04T09:47:15.129Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/10349b09ff78/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Signal Protocol 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">544</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-16.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Signal Protocol 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Signal Protocol 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Signal Protocol</strong>（前身为 TextSecure Protocol）是一个<strong>现代的、开源的、密码学加强的端到端加密 (End-to-End Encryption, E2EE) 协议</strong>，旨在为异步和同步即时通讯应用提供消息的机密性、完整性、认证性和不可抵赖性。它由 Open Whisper Systems（现为 Signal Foundation 和 Signal Messenger LLC）开发，最初用于 Signal 应用，现已被WhatsApp、Facebook Messenger（在“秘密对话”模式下）、Google Messages（在 RCS 聊天中）等主流通讯应用广泛采用，成为业界公认的E2EE黄金标准之一。</p>
</blockquote>
<div class="note info flat"><p>核心思想：Signal Protocol 通过巧妙结合<strong>双棘轮算法 (Double Ratchet Algorithm)</strong>、<strong>预密钥 (Pre-keys)</strong> 和 <strong>扩展的 Diffie-Hellman 密钥交换 (X3DH)</strong>，实现了<strong>前向保密性 (Forward Secrecy)</strong> 和 <strong>未来保密性&#x2F;后向保密性 (Future Secrecy&#x2F;Post-Compromise Security)</strong>，确保即使长期密钥或一部分会话密钥被泄露，过去和未来的消息仍能保持安全。</p>
</div>
<hr>
<h2 id="一、为什么需要-Signal-Protocol？"><a href="#一、为什么需要-Signal-Protocol？" class="headerlink" title="一、为什么需要 Signal Protocol？"></a>一、为什么需要 Signal Protocol？</h2><p>在数字通讯日益普及的今天，用户隐私面临着多重威胁：</p>
<ul>
<li><strong>数据窃听</strong>：消息在传输过程中可能被第三方截获和阅读。</li>
<li><strong>服务器入侵</strong>：即使通讯服务商的服务器被攻破，存储在其中的消息也可能被窃取。</li>
<li><strong>政府或恶意实体监控</strong>：通过各种手段强制服务商提供用户数据。</li>
<li><strong>中间人攻击 (Man-in-the-Middle Attacks)</strong>：攻击者截获并篡改通信双方的消息。</li>
</ul>
<p><strong>端到端加密 (E2EE)</strong> 是解决这些问题的核心技术。E2EE 确保消息从发送方设备发出时即加密，只有接收方设备才能解密。在整个传输路径中，包括服务器在内，任何第三方都无法读取消息内容。</p>
<p>Signal Protocol 正是为了提供一个强大、高效且经过验证的 E2EE 解决方案而设计的。</p>
<h2 id="二、Signal-Protocol-的核心概念与密码学基础"><a href="#二、Signal-Protocol-的核心概念与密码学基础" class="headerlink" title="二、Signal Protocol 的核心概念与密码学基础"></a>二、Signal Protocol 的核心概念与密码学基础</h2><p>Signal Protocol 的安全基石在于其对以下密码学原语和概念的巧妙运用：</p>
<ol>
<li><strong>非对称加密 (Asymmetric Encryption)</strong>：使用一对公钥和私钥。公钥用于加密，私钥用于解密。Signal Protocol 使用 <strong>椭圆曲线 Diffie-Hellman (ECDH)</strong> 密钥交换来建立共享的秘密。<ul>
<li><strong>ECDH</strong>：允许通信双方通过不安全的公开信道协商出一个共享的秘密密钥，而无需提前共享任何秘密。</li>
</ul>
</li>
<li><strong>对称加密 (Symmetric Encryption)</strong>：使用相同的密钥进行加密和解密。Signal Protocol 使用对称密钥（如 AES256）来加密实际的消息内容，因为对称加密比非对称加密效率更高。</li>
<li><strong>密钥派生函数 (Key Derivation Function, KDF)</strong>：从一个或多个秘密值生成新的、高质量的加密密钥的函数。在 Signal Protocol 中用于从 ECDH 协商的共享秘密中派生出多个不同的会话密钥。</li>
<li><strong>前向保密性 (Forward Secrecy, FS)</strong>：即使一个长期私钥被泄露，过去加密的会话内容仍然保持安全。这是通过确保每个会话的密钥都是临时的、独立的且尽快销毁来实现的。</li>
<li><strong>未来保密性 &#x2F; 后向保密性 (Future Secrecy &#x2F; Post-Compromise Security, PCS)</strong>：即使当前会话密钥被泄露，未来的会话内容仍然保持安全。这是通过每次消息交换都更新会话密钥，且不依赖于过去的任何泄露密钥来实现的。</li>
</ol>
<h2 id="三、Signal-Protocol-的关键机制"><a href="#三、Signal-Protocol-的关键机制" class="headerlink" title="三、Signal Protocol 的关键机制"></a>三、Signal Protocol 的关键机制</h2><p>Signal Protocol 的核心是 <strong>扩展的 Diffie-Hellman (X3DH) 密钥交换</strong> 和 <strong>双棘轮算法 (Double Ratchet Algorithm)</strong>。</p>
<h3 id="3-1-扩展的-Diffie-Hellman-X3DH-密钥交换协议"><a href="#3-1-扩展的-Diffie-Hellman-X3DH-密钥交换协议" class="headerlink" title="3.1 扩展的 Diffie-Hellman (X3DH) 密钥交换协议"></a>3.1 扩展的 Diffie-Hellman (X3DH) 密钥交换协议</h3><p>X3DH 协议用于在两个用户首次建立通信时，以异步方式（例如，一个用户不在线）协商一个共享的根密钥 (<code>SK</code>)。它通过结合静态密钥和临时密钥来实现：</p>
<ul>
<li><strong>身份密钥对 (Identity Key Pair, IK)</strong>：长期的、签名过的密钥对。每个用户拥有一对，用于身份识别和签名。</li>
<li><strong>签名预密钥对 (Signed Pre-key Pair, SPK)</strong>：中期的、由身份私钥签名的密钥对。用户生成几对，并将其公钥连同签名上传到服务器。</li>
<li><strong>一次性预密钥对 (One-Time Pre-key Pair, OPK)</strong>：短期的、未使用签名的密钥对。用户生成大量，并将其公钥上传到服务器。一旦使用就被销毁。</li>
</ul>
<p><strong>交换流程概述</strong>：</p>
<ol>
<li><strong>预发布</strong>：Alice 将她自己的一些（SPK, OPK）公钥上传到服务器。Bob 也做同样的事情。</li>
<li><strong>初始联系</strong>：当 Alice 想要向 Bob 发送消息时，她从服务器请求 Bob 的公钥包 (Key Bundle)，其中包含：<ul>
<li>Bob 的身份公钥 (IK_Bob)</li>
<li>Bob 的签名预密钥公钥 (SPK_Bob)</li>
<li>Bob 的签名预密钥签名 (Signature of SPK_Bob by IK_Bob)</li>
<li>Bob 的一个一次性预密钥公钥 (OPK_Bob)。如果 Bob 没有可用的一次性预密钥，就使用没有 OPK 的 Key Bundle。</li>
</ul>
</li>
<li><strong>协商共享秘密</strong>：Alice 使用自己的私钥和从服务器获取的 Bob 的公钥，进行四次 ECDH 密钥协商，计算出四个共享秘密：<ul>
<li>DH(IK_Alice, IK_Bob)</li>
<li>DH(EK_Alice, IK_Bob)  (EK_Alice 是 Alice 生成的临时 Ephemeral Key Pair)</li>
<li>DH(IK_Alice, SPK_Bob)</li>
<li>DH(EK_Alice, SPK_Bob)</li>
<li>如果 Bob 有 OPK_Bob，则再计算 DH(IK_Alice, OPK_Bob) 或 DH(EK_Alice, OPK_Bob)<br>这些共享秘密通过密钥派生函数 (KDF) 组合在一起，生成一个初始的<strong>根密钥 (Root Key, RK)</strong> 和<strong>链密钥 (Chain Key, CK)</strong>。</li>
</ul>
</li>
<li><strong>销毁 OPK</strong>：一旦 OPK_Bob 被 Alice 使用，服务器就会将其从 Key Bundle 中删除。</li>
<li><strong>首次消息发送</strong>：Alice 使用这个根密钥和链密钥，通过双棘轮算法开始加密第一条消息并发送给 Bob。消息中包含 Alice 的 Ephemeral Public Key (EK_Alice)。</li>
</ol>
<p>X3DH 协议确保了即使 Bob 不在线，Alice 也能安全地开始与 Bob 的加密通信，并提供了身份认证。</p>
<h3 id="3-2-双棘轮算法-Double-Ratchet-Algorithm"><a href="#3-2-双棘轮算法-Double-Ratchet-Algorithm" class="headerlink" title="3.2 双棘轮算法 (Double Ratchet Algorithm)"></a>3.2 双棘轮算法 (Double Ratchet Algorithm)</h3><p>双棘轮算法是 Signal Protocol 的核心，它实现了<strong>前向保密性</strong>和<strong>未来保密性</strong>。每次消息发送都会更新会话密钥，确保即使当前链上的某个密钥泄露，也不会影响到其他密钥。</p>
<p>双棘轮算法维护了以下几个重要概念：</p>
<ul>
<li><strong>根密钥 (Root Key, RK)</strong>：用于派生后继的根密钥和链密钥。</li>
<li><strong>发送链密钥 (Sending Chain Key, SCK)</strong>：用于派生发送消息的对称加密密钥。</li>
<li><strong>接收链密钥 (Receiving Chain Key, RCK)</strong>：用于派生接收消息的对称加密密钥。</li>
<li><strong>消息密钥 (Message Key, MK)</strong>：实际用于加密和解密每一条消息的对称密钥。</li>
<li><strong>发送方&#x2F;接收方棘轮公钥 (Ephemeral Key Pair)</strong>：用于每次密钥更新的新的 ECDH 密钥对。</li>
</ul>
<p><strong>工作原理</strong>：</p>
<p>双棘轮算法结合了两种“棘轮”机制：</p>
<ol>
<li><p><strong>对称密钥棘轮 (Symmetric-Key Ratchet)</strong>：</p>
<ul>
<li>每次发送消息时，基于当前的链密钥 (SCK 或 RCK) 使用 KDF 派生出新的消息密钥 (MK)。然后，再从旧的链密钥生成一个新的链密钥。</li>
<li>这意味着每一条消息都有一个<strong>新的、独立的、一次性的消息密钥</strong>。</li>
<li>如果攻击者获得当前链密钥，他们可以解密以该链密钥加密的未来消息，但无法解密过去的（已派生出并销毁其生成密钥的）消息。这提供了<strong>前向保密性</strong>。</li>
</ul>
</li>
<li><p><strong>DH 棘轮 (Diffie-Hellman Ratchet)</strong>：</p>
<ul>
<li>每次两个通信方更新棘轮公钥时，双方会执行一个新的 ECDH 密钥交换。</li>
<li>这个新的 ECDH 共享秘密被用于更新根密钥 (RK)，然后由 RK 派生出新的发送链密钥和接收链密钥。</li>
<li><strong>关键点</strong>：如果攻击者在某个时刻窃取了所有链密钥，一旦发生一次成功的 DH 密钥更新（即双方都交换了新的棘轮公钥），攻击者就无法解密未来的消息了，因为新的链密钥是由新的、未曾泄露的 DH 秘密派生而来的。这提供了<strong>未来保密性&#x2F;后向保密性</strong>。</li>
</ul>
</li>
</ol>
<p>通过这两种棘轮机制的结合，确保了无论攻击者何时获取了通信方的秘密信息（只要不是持续的完全控制），都能最大程度地限制泄露的范围。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph &quot;Initial Setup (X3DH)&quot;
        A[Alice IK, SPK, OPK] --&gt;|Upload Public Keys| Server;
        B[Bob IK, SPK, OPK] --&gt;|Upload Public Keys| Server;
        Alice[Alice] --Request Bob&#39;s Key Bundle--&gt; Server;
        Alice --&quot;Calculates Initial RK, SCK(Alice), RCK(Bob) (via 4 ECDH)&quot;--&gt; Bob;
    end

    subgraph Double Ratchet Algorithm
        direction LR
        A_DR[Alice&#39;s Double Ratchet State]
        B_DR[Bob&#39;s Double Ratchet State]

        A_DR --&gt;|Generate new Ephemeral Key EK_A| A_DR
        A_DR --&gt;|Derive SCK, RCK from RK; MK from SCK| A_DR

        A_DR --&gt;|&quot;Encrypt Message (MK_A), Attach EK_A&quot;| B_DR;
        B_DR --&gt;|Update RCK, derive MK_A from RCK, Decrypt Message| B_DR;
        B_DR --&gt;|Generate new Ephemeral Key EK_B| B_DR
        B_DR --&gt;|Derive SCK, RCK from RK; MK from SCK| B_DR

        B_DR --&gt;|&quot;Encrypt Message (MK_B), Attach EK_B&quot;| A_DR;
        A_DR --&gt;|Update RCK, derive MK_B from RCK, Decrypt Message| A_DR;
    end
  </pre></div>


<h2 id="四、身份验证"><a href="#四、身份验证" class="headerlink" title="四、身份验证"></a>四、身份验证</h2><p>Signal Protocol 提供了机制来验证通信方身份，以防止中间人攻击：</p>
<ul>
<li><strong>安全码 (Safety Numbers)</strong>：Signal 应用会生成一个由数字或二维码表示的“安全码”。用户可以通过面对面比对或通过安全信道验证这个安全码。如果安全码一致，则可以确认双方正在与正确的对象通信。当身份密钥或签名预密钥发生变化时，安全码会发生变化，通知用户可能存在中间人攻击或某一方更换了设备。</li>
</ul>
<h2 id="五、Signal-Protocol-的广泛应用"><a href="#五、Signal-Protocol-的广泛应用" class="headerlink" title="五、Signal Protocol 的广泛应用"></a>五、Signal Protocol 的广泛应用</h2><p>Signal Protocol 因其强大的安全性、开源性以及严谨的密码学设计，已被广泛应用于：</p>
<ul>
<li><strong>Signal Messenger</strong>：所有消息、群组聊天、语音和视频通话都默认使用 Signal Protocol 进行端到端加密。</li>
<li><strong>WhatsApp</strong>：自 2016 年起，WhatsApp 的所有个人和群组聊天、语音和视频通话都默认使用 Signal Protocol 进行端到端加密。</li>
<li><strong>Facebook Messenger</strong>：在“秘密对话”模式下使用 Signal Protocol。</li>
<li><strong>Google Messages</strong>：在支持 RCS (Rich Communication Services) 的对话中，如果双方设备都启用了端到端加密，则使用 Signal Protocol。</li>
<li><strong>Skype</strong>：在“私人对话”模式下使用 Signal Protocol。</li>
<li><strong>Wire</strong>：安全通讯应用，也采用了 Signal Protocol。</li>
</ul>
<h2 id="六、与-MTProto-的对比"><a href="#六、与-MTProto-的对比" class="headerlink" title="六、与 MTProto 的对比"></a>六、与 MTProto 的对比</h2><table>
<thead>
<tr>
<th align="left">特性 &#x2F; 协议</th>
<th align="left">Signal Protocol</th>
<th align="left">MTProto (Telegram)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主要设计者</strong></td>
<td align="left">Open Whisper Systems (Signal Foundation)</td>
<td align="left">Nikolai Durov (Telegram)</td>
</tr>
<tr>
<td align="left"><strong>协议类型</strong></td>
<td align="left"><strong>业经验证的 E2EE 协议</strong></td>
<td align="left"><strong>Telegram 自定义协议</strong></td>
</tr>
<tr>
<td align="left"><strong>端到端加密 (E2EE)</strong></td>
<td align="left"><strong>所有个人聊天和群组聊天默认开启</strong></td>
<td align="left"><strong>仅秘密聊天 (Secret Chats) 开启</strong>；普通云聊天是客户端-服务器加密</td>
</tr>
<tr>
<td align="left"><strong>前向&#x2F;未来保密性</strong></td>
<td align="left"><strong>支持</strong> (通过双棘轮算法)</td>
<td align="left"><strong>秘密聊天支持</strong>；云聊天不明确，通常认为不如 Signal 严格</td>
</tr>
<tr>
<td align="left"><strong>密钥交换</strong></td>
<td align="left"><strong>X3DH</strong> (Extended Diffie-Hellman)</td>
<td align="left">基于 RSA 和 Diffie-Hellman 自定义流程</td>
</tr>
<tr>
<td align="left"><strong>会话密钥管理</strong></td>
<td align="left"><strong>双棘轮算法</strong> (每次消息更新)</td>
<td align="left">秘密聊天中也有密钥更新机制，但不如双棘轮灵活严谨</td>
</tr>
<tr>
<td align="left"><strong>消息加密算法</strong></td>
<td align="left">AES256-GCM, HMAC-SHA256</td>
<td align="left">AES256-IGE, SHA256</td>
</tr>
<tr>
<td align="left"><strong>身份验证 (AoT)</strong></td>
<td align="left"><strong>安全码比对</strong></td>
<td align="left">秘密聊天中的设备指纹比对</td>
</tr>
<tr>
<td align="left"><strong>开源状态</strong></td>
<td align="left"><strong>协议规范和库完全开源且经过广泛审计</strong></td>
<td align="left"><strong>客户端开源，服务器端代码不开源</strong>；协议规范公开</td>
</tr>
<tr>
<td align="left"><strong>行业采纳</strong></td>
<td align="left"><strong>被广泛采纳为 E2EE 黄金标准</strong> (WhatsApp, Google Messages, FB Messenger)</td>
<td align="left">仅 Telegram 自身使用</td>
</tr>
<tr>
<td align="left"><strong>学术审查</strong></td>
<td align="left"><strong>经过大量学术审查和同行评审</strong></td>
<td align="left">较少严格的第三方独立学术审查，由 Telegram 组织了一些竞赛</td>
</tr>
</tbody></table>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Signal Protocol 代表了现代端到端加密通讯的最高水平。它通过结合 X3DH 密钥交换和双棘轮算法，实现了强大<strong>前向保密性</strong>和<strong>未来保密性</strong>，确保了用户通信的隐私不受侵害，即使部分通信秘密被泄露，也能最大程度地限制安全影响。其<strong>开源的特性</strong>和<strong>广泛的学术审查</strong>使其成为业界公认的 E2EE 黄金标准，被众多主流即时通讯应用采用。对于任何关心数字隐私和安全的个人或组织而言，理解和支持 Signal Protocol 及其衍生应用都至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/10349b09ff78/">https://blog.tbf1211.xx.kg/10349b09ff78/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-16.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ECMAScript ShadowRealm 详解</div></div><div class="info-2"><div class="info-item-1"> ShadowRealm 是一个 ECMAScript 提案（目前处于 Stage 3 阶段），旨在为 JavaScript 提供一种新的代码隔离机制。它允许在当前 Realm 中创建一个与主 Realm 具有分离的全局对象 (global object) 和 内置对象 (intrinsic objects) 集合的“影子 Realm”。通过 ShadowRealm，开发者可以在一个安全的、受控的环境中执行不受信任的代码或隔离不同的应用程序组件，提供类似于 iframe 但在 JS 层面更细粒度的沙箱能力。  核心思想：ShadowRealm 创建了一个轻量级的 JavaScript 执行环境沙箱。它提供了一套独立的全局对象和内置对象，但共享相同的事件循环 (event loop) 和微任务队列 (microtask queue)。这种隔离有助于提高代码安全性、隔离第三方库、避免全局污染，并为模块化和可插拔架构提供更强大的支持。   一、为什么需要 ShadowRealm？在 JavaScript 生态系统中，代码隔离一直是一个重要的需求，尤其是在以下场景中：  运行不受信任的代...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/8c33e0b80528/" title="MTProto 加密协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-13</div><div class="info-item-2">MTProto 加密协议详解</div></div><div class="info-2"><div class="info-item-1"> MTProto 是 Telegram 即时通讯应用使用的自定义加密协议。它由尼古拉·杜罗夫 (Nikolai Durov) 设计，旨在实现高速、安全、多设备同步和抗审查的消息传输。MTProto 并非基于现有标准加密协议，而是为适应 Telegram 的特定需求而从头构建。它是一个多层级的协议，涵盖了传输、加密和 API 抽象，是 Telegram 提供其核心价值主张（速度和安全性）的基石。  核心思想：MTProto 是一个专为移动设备和分布式架构优化的加密协议，通过其分层设计和高效二进制格式，在保证强大加密安全性的同时，提供极速响应和无缝的多设备云同步能力。它是 Telegram 服务得以运行的底层技术支柱。   一、背景与起源Telegram 于 2013 年推出时，其创始人帕维尔·杜罗夫 (Pavel Durov) 及其 брат尼古拉·杜罗夫 (Nikolai Durov) 对当时市场上主流的即时通讯协议的性能和安全性感到不满。他们认为这些协议在移动网络环境下效率低下，且未充分考虑多设备同步的需求。因此，尼古拉·杜罗夫着手设计了一个全新的协议，即 MTProto，其目...</div></div></div></a><a class="pagination-related" href="/8a2eec4e192e/" title="LSP (Language Server Protocol) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="info-item-2">LSP (Language Server Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> LSP (Language Server Protocol) 是一个开放的、基于 JSON-RPC 的协议，用于在编程语言特有的服务（通常称为 Language Server）和开发工具（通常是 Editor 或 IDE，称为 Client）之间进行通信。其核心目标是解耦语言特有的功能实现与开发工具的用户界面，从而极大地简化了多语言、多工具环境下的开发体验。  核心思想：将语言的智能特性（如代码补全、跳转定义、错误检查等）从开发工具中抽离出来，放入一个独立的进程（Language Server），然后开发工具通过标准协议（LSP）与这个进程通信。    一、为什么需要 LSP？在 LSP 出现之前，每当要为一个新的编程语言或一个新的开发工具提供智能特性时，开发者都需要进行大量的重复工作。这个问题可以形象地描述为 N*M 问题：  N 种编程语言 (Python, Java, Go, C#, JavaScript…) M 种开发工具 (VS Code, Vim, Emacs, Sublime Text, Eclipse, IntelliJ…)  传统模式下，如果要在 M 种编辑器...</div></div></div></a><a class="pagination-related" href="/fa3d796f3333/" title="MessagePack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-09</div><div class="info-item-2">MessagePack 详解</div></div><div class="info-2"><div class="info-item-1"> MessagePack 是一个高效的二进制序列化格式，它允许你在多种语言之间交换数据，就像 JSON 一样。但与 JSON 不同的是，MessagePack 以更紧凑的二进制形式表示数据，这通常使其具有更小的消息大小和更快的编码&#x2F;解码速度。它被设计为一个“像 JSON 但更快更小”的替代品，特别适用于网络协议、数据存储以及低功耗设备等对性能和带宽敏感的场景。  核心思想：将结构化数据（如对象、数组、基本类型）编码成紧凑的二进制流，以实现高效的数据传输和存储。   一、什么是 MessagePack？MessagePack 是一种基于二进制的数据交换格式，其设计目标是高效、紧凑和跨语言兼容。它通过一种优化的二进制表示来序列化各种数据类型，包括整数、浮点数、字符串、二进制数据、数组和映射。其官方网站将其描述为“一个整洁、紧凑的二进制序列化格式”。 与文本格式（如 JSON）相比，MessagePack 的主要优势在于：  更小的消息尺寸：通过减少冗余信息并直接使用二进制表示数据类型，MessagePack 生成的数据通常比同等 JSON 数据小。 更快的处理速度：由于节省...</div></div></div></a><a class="pagination-related" href="/c5be75f3ed25/" title="WebSocket 详解：实现全双工实时通信"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="info-item-2">WebSocket 详解：实现全双工实时通信</div></div><div class="info-2"><div class="info-item-1"> WebSocket 是一种在单个 TCP 连接上进行全双工（Full-Duplex）通信的网络协议。它在 Web 浏览器和服务器之间提供了一个持久化的连接，允许双方在任何时候发送消息，而无需像传统的 HTTP 请求那样需要先发送请求再接收响应。WebSocket 解决了传统 Web 应用中实现实时通信的诸多难题，是构建实时 Web 应用的关键技术之一。  核心思想：从 HTTP 协议“握手”后，将底层 TCP 连接“升级”为 WebSocket 连接，实现客户端与服务器之间长时间、双向、无阻塞的消息传输，从而大幅降低通信开销，提升实时应用的性能。   一、为什么需要 WebSocket？传统 HTTP 的局限性在 WebSocket 出现之前，Web 应用程序要实现实时通信，如聊天室、股票行情、在线游戏、推送通知等，面临着传统 HTTP 协议的固有局限性：  半双工 (Half-Duplex) 通信：HTTP 协议是单向请求-响应模型。客户端发送请求，服务器返回响应。服务器无法主动向客户端发送消息，除非客户端先发起请求。 效率低下： 频繁连接建立与断开：每个 HTTP 请求都需...</div></div></div></a><a class="pagination-related" href="/9be87a9e79b5/" title="KCP协议详解：一个快速可靠的UDP上层协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-13</div><div class="info-item-2">KCP协议详解：一个快速可靠的UDP上层协议</div></div><div class="info-2"><div class="info-item-1"> KCP (Fast and Reliable UDP protocol) 是一个由 skywind3000 (吴云) 在 2014 年开源的快速可靠的 UDP 上层协议。它的设计目标是在网络状况不佳（高延迟、高丢包率）的环境下，提供比 TCP 更快的传输速度和更低的延迟，同时保持数据的可靠性。KCP 并不是一个完整的网络协议栈，而是一个可嵌入式的库，它运行在 UDP 协议之上，提供了 TCP 所具备的可靠性、流量控制和拥塞控制等机制，但针对延迟和重传进行了优化。  核心思想：在保障数据可靠性的前提下，通过优化重传机制、激进发送和控制重传间隔等方法，尽可能地减少传输延迟，以适应游戏、实时音视频等对延迟高度敏感的应用。   一、为什么需要 KCP？TCP 协议是互联网上最常用的可靠传输协议，但它在一些场景下存在明显的局限性：  慢启动 (Slow Start)：TCP 为了避免网络拥塞，在连接建立初期会限制发送速率，逐渐增加。这对于短连接或突发数据传输会增加初始延迟。 队头阻塞 (Head-of-Line Blocking, HOLB)：TCP 的报文是严格按序到达的。如果某个数据...</div></div></div></a><a class="pagination-related" href="/425bf08190fa/" title="TLS Encrypted Client Hello (ECH) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="info-item-2">TLS Encrypted Client Hello (ECH) 详解</div></div><div class="info-2"><div class="info-item-1"> TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。  核心思想：在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。   一、为什么需要 ECH？SNI 的隐私痛点在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：明文 SNI (Server Name Indication)。 1.1 SNI 的作用SNI 是 TLS 协议的一个扩展，用于解决虚拟主机 (Virtual Hosting) 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 example.com 和 another.c...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">544</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Signal-Protocol%EF%BC%9F"><span class="toc-text">一、为什么需要 Signal Protocol？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Signal-Protocol-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-text">二、Signal Protocol 的核心概念与密码学基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Signal-Protocol-%E7%9A%84%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6"><span class="toc-text">三、Signal Protocol 的关键机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%89%A9%E5%B1%95%E7%9A%84-Diffie-Hellman-X3DH-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1 扩展的 Diffie-Hellman (X3DH) 密钥交换协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%8C%E6%A3%98%E8%BD%AE%E7%AE%97%E6%B3%95-Double-Ratchet-Algorithm"><span class="toc-text">3.2 双棘轮算法 (Double Ratchet Algorithm)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-text">四、身份验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Signal-Protocol-%E7%9A%84%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8"><span class="toc-text">五、Signal Protocol 的广泛应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%B8%8E-MTProto-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">六、与 MTProto 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-16.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>