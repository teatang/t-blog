<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ChaCha20 流密码加密算法详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ChaCha20 是一种高性能、高安全性的对称流密码算法，由 Google 的 Dan Bernstein 于 2008 年设计。它是 Salsa20 算法的改进版本，旨在提供比其前辈更高的抗攻击能力和更简洁的实现。ChaCha20 因其卓越的性能和安全性，已成为 TLS 协议中的重要组成部分，特别是在移动设备和低功耗环境中，替代了传统的 AES-GCM。  核心思想：通过一个密钥 (Key)">
<meta property="og:type" content="article">
<meta property="og:title" content="ChaCha20 流密码加密算法详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/4ef6c4138b39/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="ChaCha20 是一种高性能、高安全性的对称流密码算法，由 Google 的 Dan Bernstein 于 2008 年设计。它是 Salsa20 算法的改进版本，旨在提供比其前辈更高的抗攻击能力和更简洁的实现。ChaCha20 因其卓越的性能和安全性，已成为 TLS 协议中的重要组成部分，特别是在移动设备和低功耗环境中，替代了传统的 AES-GCM。  核心思想：通过一个密钥 (Key)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg">
<meta property="article:published_time" content="2024-08-15T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-06T08:03:39.911Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="加密算法">
<meta property="article:tag" content="对称加密">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ChaCha20 流密码加密算法详解",
  "url": "https://blog.tbf1211.xx.kg/4ef6c4138b39/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg",
  "datePublished": "2024-08-15T22:24:00.000Z",
  "dateModified": "2025-12-06T08:03:39.911Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/4ef6c4138b39/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ChaCha20 流密码加密算法详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">346</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">206</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">74</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-06.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">ChaCha20 流密码加密算法详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ChaCha20 流密码加密算法详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-15T22:24:00.000Z" title="发表于 2024-08-16 06:24:00">2024-08-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/4ef6c4138b39/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>ChaCha20</strong> 是一种高性能、高安全性的<strong>对称流密码算法</strong>，由 Google 的 Dan Bernstein 于 2008 年设计。它是 Salsa20 算法的改进版本，旨在提供比其前辈更高的抗攻击能力和更简洁的实现。ChaCha20 因其卓越的性能和安全性，已成为 TLS 协议中的重要组成部分，特别是在移动设备和低功耗环境中，替代了传统的 AES-GCM。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：通过一个<strong>密钥 (Key)</strong> 和一个<strong>随机数 (Nonce)</strong> 生成一个<strong>无限长的伪随机密钥流</strong>，然后将密钥流与明文进行<strong>异或 (XOR)</strong> 操作得到密文。解密时，使用相同的密钥和随机数生成相同的密钥流，再与密文异或即可还原明文。</p>
</div>
<hr>
<h2 id="一、流密码-Stream-Cipher-简介"><a href="#一、流密码-Stream-Cipher-简介" class="headerlink" title="一、流密码 (Stream Cipher) 简介"></a>一、流密码 (Stream Cipher) 简介</h2><p>流密码是一种对称加密算法，它将明文的每个比特或每个字节与一个伪随机密钥流的对应比特或字节进行组合（通常是异或）来生成密文。</p>
<h3 id="1-1-与分组密码-Block-Cipher-的区别"><a href="#1-1-与分组密码-Block-Cipher-的区别" class="headerlink" title="1.1 与分组密码 (Block Cipher) 的区别"></a>1.1 与分组密码 (Block Cipher) 的区别</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">流密码 (Stream Cipher)</th>
<th align="left">分组密码 (Block Cipher)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left">逐位&#x2F;逐字节加密</td>
<td align="left">将明文分成固定大小的块，逐块加密</td>
</tr>
<tr>
<td align="left"><strong>密钥流</strong></td>
<td align="left">基于密钥和初始化向量生成伪随机密钥流</td>
<td align="left">对密钥进行复杂变换，直接加密数据块</td>
</tr>
<tr>
<td align="left"><strong>错误传播</strong></td>
<td align="left">一般不会扩散 (比特错只影响一个比特)</td>
<td align="left">会扩散，一个比特错误可能导致整个块解密失败</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">通常更快，软件实现效率高</td>
<td align="left">比流密码慢，硬件实现效率高</td>
</tr>
<tr>
<td align="left"><strong>应用</strong></td>
<td align="left">实时通信、资源受限设备</td>
<td align="left">大量数据存储、通用加密</td>
</tr>
<tr>
<td align="left"><strong>典型算法</strong></td>
<td align="left">ChaCha20, RC4</td>
<td align="left">AES, DES</td>
</tr>
</tbody></table>
<h3 id="1-2-流密码的安全性要求"><a href="#1-2-流密码的安全性要求" class="headerlink" title="1.2 流密码的安全性要求"></a>1.2 流密码的安全性要求</h3><ul>
<li><strong>密钥流的随机性</strong>：密钥流必须具备高度的随机性，难以预测。</li>
<li><strong>长周期</strong>：密钥流的周期必须足够长，不重复或难以重复。</li>
<li><strong>抗统计攻击</strong>：密钥流不应存在可被统计分析利用的模式。</li>
<li><strong>抗代数攻击</strong>：密钥流生成函数不应存在可被代数方法攻击的弱点。</li>
</ul>
<h2 id="二、ChaCha20-算法基础"><a href="#二、ChaCha20-算法基础" class="headerlink" title="二、ChaCha20 算法基础"></a>二、ChaCha20 算法基础</h2><p>ChaCha20 是基于一个 256 位密钥和 96 位 Nonce（随机数）工作的。它生成 64 字节（512 位）的密钥流块。</p>
<h3 id="2-1-核心组件：状态矩阵"><a href="#2-1-核心组件：状态矩阵" class="headerlink" title="2.1 核心组件：状态矩阵"></a>2.1 核心组件：状态矩阵</h3><p>ChaCha20 的内部状态是一个 <code>4x4</code> 的 <code>uint32</code> 矩阵 (16 个 32 位字)，共 64 字节。这个状态矩阵由以下部分初始化：</p>
<ol>
<li><strong>常数 (Constants)</strong>：4 个 32 位字 (<code>&quot;expand 32-byte k&quot;</code>)。</li>
<li><strong>密钥 (Key)</strong>：8 个 32 位字 (256 位密钥)。</li>
<li><strong>计数器 (Block Counter)</strong>：1 个 32 位字。每次生成 64 字节密钥流块时递增 1。</li>
<li><strong>随机数&#x2F;初始化向量 (Nonce&#x2F;IV)</strong>：3 个 32 位字 (96 位 Nonce)。</li>
</ol>
<p><strong>状态矩阵结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----+----+----+----+</span><br><span class="line">| c0 | c1 | c2 | c3 |  &lt;- Constants</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| k0 | k1 | k2 | k3 |  &lt;- Key (part 1)</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| k4 | k5 | k6 | k7 |  &lt;- Key (part 2)</span><br><span class="line">+----+----+----+----+</span><br><span class="line">| b0 | n0 | n1 | n2 |  &lt;- Counter + Nonce</span><br><span class="line">+----+----+----+----+</span><br></pre></td></tr></table></figure>

<h3 id="2-2-核心运算：QR-函数-Quarter-Round"><a href="#2-2-核心运算：QR-函数-Quarter-Round" class="headerlink" title="2.2 核心运算：QR 函数 (Quarter-Round)"></a>2.2 核心运算：QR 函数 (Quarter-Round)</h3><p>ChaCha20 的核心是 <code>Quarter-Round (QR)</code> 函数，它对状态矩阵中的 4 个字进行一次置乱操作。这个函数保证了扩散 (diffusion) 和混淆 (confusion)。</p>
<p><strong>QR 函数的输入</strong>：4 个 32 位字 <code>a, b, c, d</code>。<br><strong>QR 函数的操作</strong> (都是 modulo 2^32 运算)：</p>
<ol>
<li><code>a += b</code></li>
<li><code>d ^= a</code></li>
<li><code>d = (d &lt;&lt;&lt; 16)</code> (d 左旋 16 位)</li>
<li><code>c += d</code></li>
<li><code>b ^= c</code></li>
<li><code>b = (b &lt;&lt;&lt; 12)</code> (b 左旋 12 位)</li>
<li><code>a += b</code></li>
<li><code>d ^= a</code></li>
<li><code>d = (d &lt;&lt;&lt; 8)</code> (d 左旋 8 位)</li>
<li><code>c += d</code></li>
<li><code>b ^= c</code></li>
<li><code>b = (b &lt;&lt;&lt; 7)</code> (b 左旋 7 位)</li>
</ol>
<p>这个 QR 函数是高度并行的，对现代 CPU 的性能非常友好。</p>
<h3 id="2-3-状态更新：12-轮置乱-Rounds"><a href="#2-3-状态更新：12-轮置乱-Rounds" class="headerlink" title="2.3 状态更新：12 轮置乱 (Rounds)"></a>2.3 状态更新：12 轮置乱 (Rounds)</h3><p>ChaCha20 在生成一个密钥流块时，会对初始化的状态矩阵进行 <strong>20 轮 (rounds) 置乱</strong>（Salsa20 是 20 轮，ChaCha20 的名称中的 20 就来源于此）。每轮包含 4 次“列操作”和 4 次“对角线操作”。</p>
<p><strong>一轮操作流程</strong>：</p>
<ol>
<li><strong>列操作 (Column Rounds)</strong>：对状态矩阵的每列执行一次 QR 函数。<ul>
<li><code>QR(s[0], s[4], s[8], s[12])</code></li>
<li><code>QR(s[1], s[5], s[9], s[13])</code></li>
<li><code>QR(s[2], s[6], s[10], s[14])</code></li>
<li><code>QR(s[3], s[7], s[11], s[15])</code></li>
</ul>
</li>
<li><strong>对角线操作 (Diagonal Rounds)</strong>：对状态矩阵的每“主对角线”执行一次 QR 函数。<ul>
<li><code>QR(s[0], s[5], s[10], s[15])</code></li>
<li><code>QR(s[1], s[6], s[11], s[12])</code></li>
<li><code>QR(s[2], s[7], s[8], s[13])</code></li>
<li><code>QR(s[3], s[4], s[9], s[14])</code></li>
</ul>
</li>
</ol>
<p>经过 20 轮（10 次列操作 + 10 次对角线操作）的置乱后，会得到一个最终的<strong>工作状态矩阵</strong>。</p>
<h3 id="2-4-生成密钥流块"><a href="#2-4-生成密钥流块" class="headerlink" title="2.4 生成密钥流块"></a>2.4 生成密钥流块</h3><ol>
<li>将经过 20 轮置乱后的<strong>工作状态矩阵</strong>的每个字与最初的<strong>初始化状态矩阵</strong>的对应字进行<strong>模加 (Addition Modulo 2^32)</strong>。</li>
<li>将这个结果矩阵扁平化为 64 字节的比特串，这就是一个<strong>密钥流块 (Key Stream Block)</strong>。</li>
<li>这个密钥流块会与明文块进行异或操作，得到密文块。</li>
</ol>
<p><strong>流程图</strong> (简化的生成密钥流块流程)：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;Key (256-bit)&quot;] --&gt; B{Initial State Matrix}
    C[&quot;Nonce (96-bit)&quot;] --&gt; B
    D[&quot;Block Counter (32-bit)&quot;] --&gt; B
    B --&gt; E[20 Rounds of QR Operations]
    E --&gt; F{Working State Matrix}
    F --&gt; G[&quot;Add Initial State Matrix (word-wise modulo 2^32)&quot;]
    G --&gt; H[Flatten to 64 bytes]
    H --&gt; I[&quot;Key Stream Block (64 bytes)&quot;]
    I --&gt; J[XOR with Plaintext Block]
    J --&gt; K[Ciphertext Block]
  </pre></div>

<h3 id="2-5-加密与解密"><a href="#2-5-加密与解密" class="headerlink" title="2.5 加密与解密"></a>2.5 加密与解密</h3><ul>
<li><strong>加密</strong>：明文块 <code>P</code> 与密钥流块 <code>K_stream</code> 异或得到密文块 <code>C</code>：<code>C = P XOR K_stream</code>。</li>
<li><strong>解密</strong>：密文块 <code>C</code> 与相同的密钥流块 <code>K_stream</code> 异或得到明文块 <code>P</code>：<code>P = C XOR K_stream</code>。</li>
</ul>
<p>由于异或运算的特性 <code>(A XOR B) XOR B = A</code>，所以加解密过程是完全对称的。</p>
<h2 id="三、ChaCha20-Poly1305"><a href="#三、ChaCha20-Poly1305" class="headerlink" title="三、ChaCha20-Poly1305"></a>三、ChaCha20-Poly1305</h2><p>ChaCha20 通常与 <strong>Poly1305 消息认证码 (MAC)</strong> 结合使用，形成 <strong>ChaCha20-Poly1305 AEAD</strong> (Authenticated Encryption with Associated Data) 模式。</p>
<h3 id="3-1-为什么需要-AEAD-模式？"><a href="#3-1-为什么需要-AEAD-模式？" class="headerlink" title="3.1 为什么需要 AEAD 模式？"></a>3.1 为什么需要 AEAD 模式？</h3><p>纯粹的流密码（如原始 ChaCha20）只提供<strong>数据机密性</strong>，不能保证：</p>
<ul>
<li><strong>数据完整性 (Integrity)</strong>：防止密文被篡改。</li>
<li><strong>数据真实性 (Authenticity)</strong>：确认数据确实来自声称的发送方。</li>
</ul>
<p>AEAD 模式（如 ChaCha20-Poly1305, AES-GCM）通过引入 MAC 来同时保证机密性、完整性和真实性。</p>
<h3 id="3-2-Poly1305-简介"><a href="#3-2-Poly1305-简介" class="headerlink" title="3.2 Poly1305 简介"></a>3.2 Poly1305 简介</h3><p>Poly1305 是一种由 Dan Bernstein 设计的快速消息认证码。它基于一次性密钥 (one-time key) 和多项式乘法计算 MAC 标签。</p>
<h3 id="3-3-ChaCha20-Poly1305-AEAD-工作原理"><a href="#3-3-ChaCha20-Poly1305-AEAD-工作原理" class="headerlink" title="3.3 ChaCha20-Poly1305 AEAD 工作原理"></a>3.3 ChaCha20-Poly1305 AEAD 工作原理</h3><ol>
<li>使用 ChaCha20 生成密钥流，加密明文得到密文。</li>
<li>使用 ChaCha20 密钥流中的一部分（称为 Poly1305 密钥）以及 Nonce 和一些额外认证数据 (Associated Data, AD)。</li>
<li>将密文和 AD 作为输入，利用 Poly1305 计算出一个 MAC 标签。</li>
<li>发送方将密文、Nonce 和 MAC 标签一同发送给接收方。</li>
</ol>
<p>接收方在解密前会先用相同的密钥、Nonce 和 AD 重新计算 MAC 标签，并与接收到的标签进行比较。只有当标签匹配且解密成功时，才认为数据是有效的。</p>
<p>ChaCha20-Poly1305 模式因其高性能和安全性，被广泛应用于 HTTPS (TLS 1.2&#x2F;1.3)、VPN (WireGuard) 和其他网络协议中。</p>
<h2 id="四、ChaCha20-的优缺点与适用场景"><a href="#四、ChaCha20-的优缺点与适用场景" class="headerlink" title="四、ChaCha20 的优缺点与适用场景"></a>四、ChaCha20 的优缺点与适用场景</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><ul>
<li><strong>高性能</strong>：ChaCha20 的内部操作（加法、异或、循环移位）对现代 CPU 极其友好，易于高效的软件实现。这使得它在没有硬件加速的 CPU 上比 AES 更快。</li>
<li><strong>安全性高</strong>：经过广泛的密码学分析，目前没有已知的有效攻击方法。20 轮设计提供了高强度的安全余量。</li>
<li><strong>简洁性</strong>：算法设计相对简洁，代码量小，不易引入实现错误。</li>
<li><strong>无需查找表</strong>：与 AES 不同，ChaCha20 不需要查找表，这有助于抵抗侧信道攻击，并且在缓存较小的 CPU 上表现更佳。</li>
<li><strong>无专利</strong>：完全公开且免版税。</li>
<li><strong>与 Poly1305 完美结合</strong>：ChaCha20-Poly1305 提供了强大的 AEAD 功能。</li>
</ul>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><ul>
<li><strong>相对较新</strong>：虽然已经非常成熟，但相较于 AES，其标准化和部署时间较短。</li>
<li><strong>硬件加速程度</strong>：目前大多数硬件加速都是针对 AES 的，ChaCha20 在硬件性能上可能不如专门优化的 AES。</li>
</ul>
<h3 id="4-3-适用场景"><a href="#4-3-适用场景" class="headerlink" title="4.3 适用场景"></a>4.3 适用场景</h3><ul>
<li><strong>TLS&#x2F;SSL</strong>：特别是在 Google Chrome 浏览器与服务器之间的通信中广泛使用，尤其是在移动设备上，因为它能提供更好的性能。</li>
<li><strong>VPN (WireGuard)</strong>：下一代安全 VPN 协议 WireGuard 核心加密算法就是 ChaCha20-Poly1305。</li>
<li><strong>移动设备和嵌入式系统</strong>：由于其高效的软件实现和对 ARM 等架构的优化，非常适合资源受限或没有 AES 硬件加速的设备。</li>
<li><strong>通用数据加密</strong>：任何需要高性能、高安全性对称加密的场景。</li>
</ul>
<h2 id="五、Go-语言实现-ChaCha20-Poly1305"><a href="#五、Go-语言实现-ChaCha20-Poly1305" class="headerlink" title="五、Go 语言实现 ChaCha20-Poly1305"></a>五、Go 语言实现 ChaCha20-Poly1305</h2><p>Go 语言标准库通过 <code>golang.org/x/crypto/chacha20poly1305</code> 包提供了 ChaCha20-Poly1305 AEAD 的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/crypto/chacha20poly1305&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// generateRandomBytes 生成指定长度的随机字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateRandomBytes</span><span class="params">(n <span class="type">int</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	_, err := io.ReadFull(rand.Reader, b)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;生成随机字节失败: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 生成 256 位 (32 字节) 的密钥</span></span><br><span class="line">	key, err := generateRandomBytes(chacha20poly1305.KeySize)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;生成密钥失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;密钥 (Hex): %x\n&quot;</span>, key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 创建 ChaCha20-Poly1305 AEAD cipher</span></span><br><span class="line">	aead, err := chacha20poly1305.New(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;创建 AEAD 密码器失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 生成 Nonce (必须是随机的，且每个加密操作必须不同，但不需要保密)</span></span><br><span class="line">	<span class="comment">// Nonce 的大小通常是 chacha20poly1305.NonceSize (12 字节/96 位)</span></span><br><span class="line">	nonce, err := generateRandomBytes(aead.NonceSize())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;生成 Nonce 失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Nonce (Hex): %x\n&quot;</span>, nonce)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 定义明文和附加认证数据 (Associated Data, AD)</span></span><br><span class="line">	plaintext := []<span class="type">byte</span>(<span class="string">&quot;这是需要加密和验证的绝密消息！Go语言 ChaCha20-Poly1305 示例。&quot;</span>)</span><br><span class="line">	associatedData := []<span class="type">byte</span>(<span class="string">&quot;这是附加认证数据，不加密但需要验证完整性。例如，协议版本号或会话ID。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n原始明文: %s\n&quot;</span>, <span class="type">string</span>(plaintext))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;附加认证数据 (AD): %s\n&quot;</span>, <span class="type">string</span>(associatedData))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 加密并生成 MAC 标签</span></span><br><span class="line">	<span class="comment">// Seal 函数的 out 缓冲区会包含密文和 MAC 标签</span></span><br><span class="line">	<span class="comment">// 格式通常是 nonce + ciphertext + tag</span></span><br><span class="line">	ciphertextWithTag := aead.Seal(<span class="literal">nil</span>, nonce, plaintext, associatedData)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n加密后的数据 (密文+标签, Hex): %x\n&quot;</span>, ciphertextWithTag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 解密并验证 MAC 标签</span></span><br><span class="line">	<span class="comment">// Open 函数会在解密前验证 MAC 标签，如果验证失败会返回错误</span></span><br><span class="line">	decryptedPlaintext, err := aead.Open(<span class="literal">nil</span>, nonce, ciphertextWithTag, associatedData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;解密或MAC验证失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;解密后的明文: %s\n&quot;</span>, <span class="type">string</span>(decryptedPlaintext))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">string</span>(plaintext) == <span class="type">string</span>(decryptedPlaintext) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;\n加密、解密和MAC验证成功！数据完整且真实。&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;\n解密后的数据与原始数据不匹配，加密或解密失败。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 7. 模拟数据篡改，验证 MAC 机制</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 模拟数据篡改 ---&quot;</span>)</span><br><span class="line">	<span class="comment">// 篡改密文的一个字节</span></span><br><span class="line">	tamperedCiphertextWithTag := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(ciphertextWithTag))</span><br><span class="line">	<span class="built_in">copy</span>(tamperedCiphertextWithTag, ciphertextWithTag)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tamperedCiphertextWithTag) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tamperedCiphertextWithTag[<span class="number">0</span>] ^= <span class="number">0x01</span> <span class="comment">// 修改第一个字节</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = aead.Open(<span class="literal">nil</span>, nonce, tamperedCiphertextWithTag, associatedData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;尝试解密篡改数据 (预期失败): %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解密篡改数据成功 (不应该发生)! MAC 验证失效。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 篡改 Associated Data</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 模拟 AD 篡改 ---&quot;</span>)</span><br><span class="line">	tamperedAssociatedData := []<span class="type">byte</span>(<span class="string">&quot;篡改过的附加认证数据&quot;</span>)</span><br><span class="line">	_, err = aead.Open(<span class="literal">nil</span>, nonce, ciphertextWithTag, tamperedAssociatedData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;尝试解密原始密文但 AD 篡改 (预期失败): %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解密成功但 AD 篡改 (不应该发生)! MAC 验证失效。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">密钥 (Hex): 91d36d...</span><br><span class="line">Nonce (Hex): f154e5...</span><br><span class="line"></span><br><span class="line">原始明文: 这是需要加密和验证的绝密消息！Go语言 ChaCha20-Poly1305 示例。</span><br><span class="line">附加认证数据 (AD): 这是附加认证数据，不加密但需要验证完整性。例如，协议版本号或会话ID。</span><br><span class="line"></span><br><span class="line">加密后的数据 (密文+标签, Hex): 040f7b....</span><br><span class="line">解密后的明文: 这是需要加密和验证的绝密消息！Go语言 ChaCha20-Poly1305 示例。</span><br><span class="line"></span><br><span class="line">加密、解密和MAC验证成功！数据完整且真实。</span><br><span class="line"></span><br><span class="line">--- 模拟数据篡改 ---</span><br><span class="line">尝试解密篡改数据 (预期失败): chacha20poly1305: message authentication failed</span><br><span class="line"></span><br><span class="line">--- 模拟 AD 篡改 ---</span><br><span class="line">尝试解密原始密文但 AD 篡改 (预期失败): chacha20poly1305: message authentication failed</span><br></pre></td></tr></table></figure>
<p>此 Go 语言示例演示了如何使用 <code>chacha20poly1305</code> 包进行密钥生成、Nonce 生成、数据的加密、解密以及 MAC 标签的验证。它还通过模拟篡改密文和附加认证数据来展示 MAC 机制如何保护数据的完整性和真实性。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>ChaCha20 流密码及其 AEAD 模式 ChaCha20-Poly1305 是现代密码学中的一个重要进展。它以其卓越的性能、高安全性、简洁的实现和免版税的特性，在多种应用场景中展现出强大的优势，尤其是在移动设备和 Web (TLS) 领域，成为 AES-GCM 的有力替代者。理解 ChaCha20 的工作原理和安全特性，对于构建安全、高效的网络通信和数据保护系统至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/4ef6c4138b39/">https://blog.tbf1211.xx.kg/4ef6c4138b39/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a><a class="post-meta__tags" href="/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">对称加密</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-06.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/75b66b0f0910/" title="RSA (Rivest–Shamir–Adleman) 加密算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RSA (Rivest–Shamir–Adleman) 加密算法详解</div></div><div class="info-2"><div class="info-item-1"> RSA 是一种非对称加密算法，由 Ron Rivest、Adi Shamir 和 Leonard Adleman 于 1977 年提出，并以他们姓氏的首字母命名。它是目前应用最广泛的公钥密码算法之一，广泛用于数据加密、数字签名以及密钥交换等领域。RSA 的安全性基于大整数分解的困难性，即给定两个大素数 p 和 q，计算它们的乘积 n = p * q 是容易的，但给定 n 却很难反向分解出 p 和 q。  一、引言：公钥密码学的基石在密码学领域，我们通常将加密算法分为两大类：对称加密和非对称加密。  对称加密 (Symmetric Encryption)：使用相同的密钥进行加密和解密。优点是速度快，但密钥分发和管理是其主要挑战。 非对称加密 (Asymmetric Encryption &#x2F; Public-key Cryptography)：使用一对密钥，即一个公钥 (Public Key) 和一个私钥 (Private Key)。公钥可以公开，用于加密或验证签名；私钥必须严格保密，用于解密或生成签名。  RSA 算法是公钥密码学的代表，解决了对称加密中密钥分发的难题。其...</div></div></div></a><a class="pagination-related" href="/6bc2a8397773/" title="AES (Advanced Encryption Standard) 加密算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">AES (Advanced Encryption Standard) 加密算法详解</div></div><div class="info-2"><div class="info-item-1"> AES (Advanced Encryption Standard)，即高级加密标准，是目前应用最广泛的对称密钥分组加密算法。它于 2001 年由美国国家标准与技术研究院 (NIST) 发布，取代了 DES (Data Encryption Standard) 成为联邦政府推荐的加密标准。AES 的设计基于替代-置换网络 (Substitution-Permutation Network, SPN) 结构，具有高效、安全和易于实现的特点，被广泛应用于网络通信、数据存储、文件加密等各种场景。  一、引言：对称加密的王者在现代密码学中，对称加密算法因其加解密速度快而常用于对大量数据进行加密。AES 是其中的翘楚，被认为是当今最安全的对称加密算法之一。  对称加密 (Symmetric Encryption)：使用相同的密钥进行加密和解密。优点是效率高，适合加密大量数据；缺点是密钥分发和管理复杂。 分组密码 (Block Cipher)：将明文数据分成固定大小的块（例如 AES 是 128 位），对每个块独立进行加密。  AES 具有以下关键特性：  块大小 (Block Size)...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6bc2a8397773/" title="AES (Advanced Encryption Standard) 加密算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-15</div><div class="info-item-2">AES (Advanced Encryption Standard) 加密算法详解</div></div><div class="info-2"><div class="info-item-1"> AES (Advanced Encryption Standard)，即高级加密标准，是目前应用最广泛的对称密钥分组加密算法。它于 2001 年由美国国家标准与技术研究院 (NIST) 发布，取代了 DES (Data Encryption Standard) 成为联邦政府推荐的加密标准。AES 的设计基于替代-置换网络 (Substitution-Permutation Network, SPN) 结构，具有高效、安全和易于实现的特点，被广泛应用于网络通信、数据存储、文件加密等各种场景。  一、引言：对称加密的王者在现代密码学中，对称加密算法因其加解密速度快而常用于对大量数据进行加密。AES 是其中的翘楚，被认为是当今最安全的对称加密算法之一。  对称加密 (Symmetric Encryption)：使用相同的密钥进行加密和解密。优点是效率高，适合加密大量数据；缺点是密钥分发和管理复杂。 分组密码 (Block Cipher)：将明文数据分成固定大小的块（例如 AES 是 128 位），对每个块独立进行加密。  AES 具有以下关键特性：  块大小 (Block Size)...</div></div></div></a><a class="pagination-related" href="/6ae53edcb727/" title="MD5 (Message-Digest Algorithm 5)算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-18</div><div class="info-item-2">MD5 (Message-Digest Algorithm 5)算法详解</div></div><div class="info-2"><div class="info-item-1"> MD5 (Message Digest Algorithm 5) 是一种广泛使用的加密散列函数，由 Ronald Rivest 于 1991 年设计。它能够将任意长度的输入数据（通常称为“消息”或“原文”）通过哈希运算转换成一个固定长度的 128 位（16 字节）散列值，通常以 32 位十六进制字符串表示。MD5 的设计初衷是用于验证数据完整性，即确保数据在传输或存储过程中未被篡改。  重要安全提示： MD5 算法已被证实存在严重的碰撞漏洞。这意味着可以找到两个不同的输入数据，它们会产生完全相同的 MD5 散列值。因此，MD5 已不再被认为是安全的加密哈希函数，不应再用于需要密码学安全性的场景，如数字签名、密码存储（即使加盐也不推荐）或生成 SSL 证书。 它主要仍用于非安全敏感场景下的文件完整性校验和快速数据比对。   一、引言：哈希函数的基本概念哈希函数 (Hash Function)，也称为散列函数，是一类将任意大小的数据映射到固定大小值的函数。在密码学领域，加密哈希函数 (Cryptographic Hash Function) 需要满足更严格的特性：  确定性 (De...</div></div></div></a><a class="pagination-related" href="/e3c3e34cbfa2/" title="SHA (Secure Hash Algorithm) 系列算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-20</div><div class="info-item-2">SHA (Secure Hash Algorithm) 系列算法详解</div></div><div class="info-2"><div class="info-item-1"> SHA (Secure Hash Algorithm) 是一系列由美国国家安全局 (NSA) 设计，并由美国国家标准与技术研究院 (NIST) 发布的安全散列算法。与 MD5 类似，SHA 算法家族将任意长度的输入数据（消息）转换为固定长度的小型字节串，即消息摘要 (Message Digest) 或 哈希值 (Hash Value)。SHA 系列算法在密码学和信息安全领域扮演着至关重要的角色，广泛应用于数字签名、数据完整性校验、密码存储和区块链等场景。  核心思想：通过设计精密的数学和逻辑运算，确保输入数据的微小改变会导致输出哈希值的巨大、不可预测的变化（雪崩效应），并使其具有单向性和抗碰撞性，从而提供数据的完整性和认证功能。   一、SHA 算法家族概述SHA 家族包括以下主要算法版本：  SHA-0：1993 年发布，很快发现安全漏洞，被 SHA-1 取代。 SHA-1：1995 年发布，输出 160 位哈希值。曾被广泛使用，但现在已被认为不安全。 SHA-2：2001 年发布，是一个包含多个变体的家族，包括 SHA-224, SHA-256, SHA-384, SHA-...</div></div></div></a><a class="pagination-related" href="/d3c7b6c4e397/" title="SHA-256 算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-21</div><div class="info-item-2">SHA-256 算法详解</div></div><div class="info-2"><div class="info-item-1"> SHA-256 (Secure Hash Algorithm 256) 是 SHA-2 (Secure Hash Algorithm 2) 系列中最常用和最广为人知的加密散列函数之一。它由美国国家标准与技术研究院 (NIST) 于 2001 年发布，作为 MD5 和 SHA-1 的替代品，旨在提供更高的安全强度。SHA-256 能够将任意长度的输入数据（消息）通过哈希运算转换成一个固定长度的 256 位（32 字节）散列值，通常以 64 位十六进制字符串表示。它广泛应用于数字签名、数据完整性校验、密码存储以及区块链技术等领域，是目前主流且被认为安全的哈希算法。  一、加密哈希函数的基本特性在深入 SHA-256 之前，理解一个安全的加密哈希函数应具备的关键特性至关重要：  确定性 (Deterministic)：相同的输入消息总是产生相同的哈希值。 计算效率 (Computational Efficiency)：对于任意输入消息，计算其哈希值是高效的。 抗原像性 &#x2F; 单向性 (Preimage Resistance &#x2F; One-Way)：给定一个哈希值，从计...</div></div></div></a><a class="pagination-related" href="/75b66b0f0910/" title="RSA (Rivest–Shamir–Adleman) 加密算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-18</div><div class="info-item-2">RSA (Rivest–Shamir–Adleman) 加密算法详解</div></div><div class="info-2"><div class="info-item-1"> RSA 是一种非对称加密算法，由 Ron Rivest、Adi Shamir 和 Leonard Adleman 于 1977 年提出，并以他们姓氏的首字母命名。它是目前应用最广泛的公钥密码算法之一，广泛用于数据加密、数字签名以及密钥交换等领域。RSA 的安全性基于大整数分解的困难性，即给定两个大素数 p 和 q，计算它们的乘积 n = p * q 是容易的，但给定 n 却很难反向分解出 p 和 q。  一、引言：公钥密码学的基石在密码学领域，我们通常将加密算法分为两大类：对称加密和非对称加密。  对称加密 (Symmetric Encryption)：使用相同的密钥进行加密和解密。优点是速度快，但密钥分发和管理是其主要挑战。 非对称加密 (Asymmetric Encryption &#x2F; Public-key Cryptography)：使用一对密钥，即一个公钥 (Public Key) 和一个私钥 (Private Key)。公钥可以公开，用于加密或验证签名；私钥必须严格保密，用于解密或生成签名。  RSA 算法是公钥密码学的代表，解决了对称加密中密钥分发的难题。其...</div></div></div></a><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-03</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">346</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">206</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">74</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B5%81%E5%AF%86%E7%A0%81-Stream-Cipher-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、流密码 (Stream Cipher) 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%8E%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-Block-Cipher-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.1 与分组密码 (Block Cipher) 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B5%81%E5%AF%86%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%A6%81%E6%B1%82"><span class="toc-text">1.2 流密码的安全性要求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ChaCha20-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">二、ChaCha20 算法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%8A%B6%E6%80%81%E7%9F%A9%E9%98%B5"><span class="toc-text">2.1 核心组件：状态矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A0%B8%E5%BF%83%E8%BF%90%E7%AE%97%EF%BC%9AQR-%E5%87%BD%E6%95%B0-Quarter-Round"><span class="toc-text">2.2 核心运算：QR 函数 (Quarter-Round)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%EF%BC%9A12-%E8%BD%AE%E7%BD%AE%E4%B9%B1-Rounds"><span class="toc-text">2.3 状态更新：12 轮置乱 (Rounds)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E6%B5%81%E5%9D%97"><span class="toc-text">2.4 生成密钥流块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86"><span class="toc-text">2.5 加密与解密</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ChaCha20-Poly1305"><span class="toc-text">三、ChaCha20-Poly1305</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-AEAD-%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">3.1 为什么需要 AEAD 模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Poly1305-%E7%AE%80%E4%BB%8B"><span class="toc-text">3.2 Poly1305 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-ChaCha20-Poly1305-AEAD-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">3.3 ChaCha20-Poly1305 AEAD 工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ChaCha20-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、ChaCha20 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E7%82%B9"><span class="toc-text">4.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">4.2 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.3 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-ChaCha20-Poly1305"><span class="toc-text">五、Go 语言实现 ChaCha20-Poly1305</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/15920229f914/" title="Supabase 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supabase 深度解析"/></a><div class="content"><a class="title" href="/15920229f914/" title="Supabase 深度解析">Supabase 深度解析</a><time datetime="2025-12-02T22:24:00.000Z" title="发表于 2025-12-03 06:24:00">2025-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1ae20d2726d8/" title="MiniRTC 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MiniRTC 详解"/></a><div class="content"><a class="title" href="/1ae20d2726d8/" title="MiniRTC 详解">MiniRTC 详解</a><time datetime="2025-11-28T22:24:00.000Z" title="发表于 2025-11-29 06:24:00">2025-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/be24ef88e59a/" title="WebRTC 技术详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebRTC 技术详解"/></a><div class="content"><a class="title" href="/be24ef88e59a/" title="WebRTC 技术详解">WebRTC 技术详解</a><time datetime="2025-11-27T22:24:00.000Z" title="发表于 2025-11-28 06:24:00">2025-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/53e63dc49a04/" title="PyInstaller 深度解析与指令详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PyInstaller 深度解析与指令详解"/></a><div class="content"><a class="title" href="/53e63dc49a04/" title="PyInstaller 深度解析与指令详解">PyInstaller 深度解析与指令详解</a><time datetime="2025-11-24T22:24:00.000Z" title="发表于 2025-11-25 06:24:00">2025-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/61fddda6a7a8/" title="Go 语言 GC (Garbage Collection) 机制详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 语言 GC (Garbage Collection) 机制详解"/></a><div class="content"><a class="title" href="/61fddda6a7a8/" title="Go 语言 GC (Garbage Collection) 机制详解">Go 语言 GC (Garbage Collection) 机制详解</a><time datetime="2025-11-23T22:24:00.000Z" title="发表于 2025-11-24 06:24:00">2025-11-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-06.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>