<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>五层因特网协议栈深度详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。">
<meta property="og:type" content="article">
<meta property="og:title" content="五层因特网协议栈深度详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/5d5f7c78ff8d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-30.jpg">
<meta property="article:published_time" content="2023-12-13T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-17T08:09:09.092Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-30.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "五层因特网协议栈深度详解",
  "url": "https://blog.tbf1211.xx.kg/5d5f7c78ff8d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-30.jpg",
  "datePublished": "2023-12-13T22:24:00.000Z",
  "dateModified": "2026-01-17T08:09:09.092Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/5d5f7c78ff8d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '五层因特网协议栈深度详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-30.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">五层因特网协议栈深度详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">五层因特网协议栈深度详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-12-13T22:24:00.000Z" title="发表于 2023-12-14 06:24:00">2023-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>五层因特网协议栈</strong>，也常被称为 <strong>TCP&#x2F;IP 五层模型</strong>，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将互联网的通信过程划分为五个逻辑层级，自顶向下依次为应用层、传输层、网络层、数据链路层和物理层，每层负责不同的通信职责，协同工作以实现全球互联。</strong></p>
</div>
<hr>
<h2 id="一、为什么选择五层协议栈？"><a href="#一、为什么选择五层协议栈？" class="headerlink" title="一、为什么选择五层协议栈？"></a>一、为什么选择五层协议栈？</h2><p>尽管 OSI 七层模型提供了非常详细的理论分层，但由于其设计时在标准制定上花费了大量时间，并且部分层次划分在实际实现中显得过于细致，导致其未能大规模落地。相反，TCP&#x2F;IP 协议族在互联网的早期发展中迅速崛起并成为事实标准。五层协议栈结合了二者的优点：</p>
<ol>
<li><strong>实用性</strong>：它直接反映了 TCP&#x2F;IP 协议族栈的工作方式，是互联网实际运行的写照。</li>
<li><strong>简洁性</strong>：相比 OSI 七层模型，它将 OSI 的应用层、表示层、会话层合并为<strong>应用层</strong>；将数据链路层和物理层作为独立的两个层，使得模型既能体现物理介质和链路控制，又不过于复杂。</li>
<li><strong>易于理解和教学</strong>：层次划分清晰，便于理解数据从应用程序到物理介质的流转过程。</li>
<li><strong>工程实现匹配</strong>：网络设备和操作系统的网络模块设计通常与此模型相对应。</li>
</ol>
<h2 id="二、五层协议栈结构及各层功能"><a href="#二、五层协议栈结构及各层功能" class="headerlink" title="二、五层协议栈结构及各层功能"></a>二、五层协议栈结构及各层功能</h2><p>数据在发送端从上层向下层传输，每层会添加自己的<strong>协议头 (Header)</strong> 或帧尾 (Trailer) 进行封装 (Encapsulation)；在接收端则从下层向上层传输，每层剥离 (Decapsulation) 自己的协议头。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;应用层 (Application Layer)&quot;] -- 提供网络服务给应用程序 --&gt; A_DATA(应用数据)
    T[&quot;传输层 (Transport Layer)&quot;] -- 端到端可靠传输、流量控制 --&gt; T_SEGMENT(段 Segment)
    N[&quot;网络层 (Network Layer)&quot;] -- 逻辑寻址、路由 --&gt; N_PACKET(包 Packet)
    D[&quot;数据链路层 (Data Link Layer)&quot;] -- 物理寻址、帧封装、错误检测 --&gt; D_FRAME(帧 Frame)
    H[&quot;物理层 (Physical Layer)&quot;] -- 传输比特流 --&gt; H_BIT(比特流 Bit)

    A_DATA --&gt; T_SEGMENT
    T_SEGMENT --&gt; N_PACKET
    N_PACKET --&gt; D_FRAME
    D_FRAME --&gt; H_BIT

    subgraph 发送方
        A
        T
        N
        D
        H
    end

    subgraph 接收方
        H_R[&quot;物理层 (Physical Layer)&quot;] -- 接收比特流 --&gt; H_R_BIT(比特流 Bit)
        D_R[&quot;数据链路层 (Data Link Layer)&quot;] -- 帧解析、错误检测 --&gt; D_R_FRAME(帧 Frame)
        N_R[&quot;网络层 (Network Layer)&quot;] -- 路由、逻辑寻址 --&gt; N_R_PACKET(包 Packet)
        T_R[&quot;传输层 (Transport Layer)&quot;] -- 端到端传输、流控 --&gt; T_R_SEGMENT(段 Segment)
        A_R[&quot;应用层 (Application Layer)&quot;] -- 应用程序接收数据 --&gt; A_R_DATA(应用数据)
    end

    H_BIT --通过物理介质--&gt; H_R_BIT
    H_R_BIT --&gt; D_R_FRAME
    D_R_FRAME --&gt; N_R_PACKET
    N_R_PACKET --&gt; T_R_SEGMENT
    T_R_SEGMENT --&gt; A_R_DATA
  </pre></div>

<h3 id="2-1-物理层-Physical-Layer-最底层"><a href="#2-1-物理层-Physical-Layer-最底层" class="headerlink" title="2.1 物理层 (Physical Layer) - 最底层"></a>2.1 物理层 (Physical Layer) - 最底层</h3><ul>
<li><strong>功能</strong>：定义了传输数据的电气、机械、过程和功能特性。它负责在物理媒体上透明地传输原始的<strong>比特流 (Bits)</strong>。简单来说，就是如何利用物理介质（如网线、光纤、无线电波）发送和接收0&#x2F;1的电信号、光信号或电磁波，以及这些信号的编码方式。</li>
<li><strong>主要任务</strong>：<ul>
<li>定义传输介质、接口标准 (如 RJ45、USB)。</li>
<li>定义数据编码和线路传输方式。</li>
<li>发送和接收原始比特流。</li>
</ul>
</li>
<li><strong>网络设备</strong>：网卡、集线器 (Hub)、中继器 (Repeater)、调制解调器 (Modem) 等。</li>
<li><strong>协议举例</strong>：所有物理介质和接口标准，如以太网的 100BASE-TX, 1000BASE-T (关于电信号传输)、Wi-Fi 的 802.11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac&#x2F;ax (关于无线电波传输)。</li>
</ul>
<h3 id="2-2-数据链路层-Data-Link-Layer-第-2-层"><a href="#2-2-数据链路层-Data-Link-Layer-第-2-层" class="headerlink" title="2.2 数据链路层 (Data Link Layer) - 第 2 层"></a>2.2 数据链路层 (Data Link Layer) - 第 2 层</h3><ul>
<li><strong>功能</strong>：在物理层提供的不可靠比特流传输的基础上，建立、维护和终止逻辑连接，将比特流封装成<strong>帧 (Frames)</strong>，并进行错误检测和物理寻址 (MAC 地址)。它负责在<strong>直接相连的节点之间</strong>可靠地传输数据。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>帧的封装和解封装</strong>：将网络层的数据报封装成帧，添加帧头 (包含源&#x2F;目的 MAC 地址) 和帧尾 (包含 CRC 校验)。</li>
<li><strong>物理寻址 (MAC 寻址)</strong>：根据设备网卡的 MAC 地址识别同一局域网内的设备。</li>
<li><strong>错误检测和纠正</strong>：通过 CRC 校验码等机制检测传输错误。</li>
<li><strong>流量控制</strong>：调节发送速率，避免接收方溢出。</li>
<li><strong>介质访问控制 (MAC)</strong>：协调多个设备对共享物理介质的访问（如以太网的 CSMA&#x2F;CD，Wi-Fi 的 CSMA&#x2F;CA）。</li>
</ul>
</li>
<li><strong>数据单元</strong>：帧 (Frame)。</li>
<li><strong>网络设备</strong>：网卡、交换机 (Switch)、网桥 (Bridge)。</li>
<li><strong>协议举例</strong>：Ethernet (以太网)、PPP (点对点协议)、Wi-Fi (IEEE 802.11)。</li>
</ul>
<h3 id="2-3-网络层-Network-Layer-第-3-层"><a href="#2-3-网络层-Network-Layer-第-3-层" class="headerlink" title="2.3 网络层 (Network Layer) - 第 3 层"></a>2.3 网络层 (Network Layer) - 第 3 层</h3><ul>
<li><strong>功能</strong>：负责对数据包进行<strong>逻辑寻址 (IP 地址)</strong>，实现不同网络之间的<strong>路由 (Routing)</strong>。它确保数据包能够从源主机传输到目的主机，即使它们不在同一个局域网中。网络层关心的是主机到主机的通信。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>逻辑寻址</strong>：使用 IP 地址唯一标识全球范围内的网络设备。</li>
<li><strong>路由选择</strong>：根据路由表和路由算法决定数据包转发的最佳路径，将数据包从源网络传输到目的网络。</li>
<li><strong>拥塞控制</strong>：试图避免网络拥塞。</li>
<li><strong>分段与重组 (Fragmentation&#x2F;Reassembly)</strong>：将过大的数据包分割成小块以适应底层数据链路层的 MTU (最大传输单元)，并在接收端重新组装。</li>
</ul>
</li>
<li><strong>数据单元</strong>：数据包 (Packet) 或数据报 (Datagram)。</li>
<li><strong>网络设备</strong>：路由器 (Router)、三层交换机。</li>
<li><strong>协议举例</strong>：IP (Internet Protocol, 包括 IPv4 和 IPv6)、ICMP (Internet Control Message Protocol, 用于差错报告和网络查询)、ARP (Address Resolution Protocol, 地址解析协议, 用于 IP 地址到 MAC 地址的映射)。</li>
</ul>
<h3 id="2-4-传输层-Transport-Layer-第-4-层"><a href="#2-4-传输层-Transport-Layer-第-4-层" class="headerlink" title="2.4 传输层 (Transport Layer) - 第 4 层"></a>2.4 传输层 (Transport Layer) - 第 4 层</h3><ul>
<li><strong>功能</strong>：提供<strong>端到端 (End-to-End)</strong> 的可靠或不可靠数据传输服务。它负责将应用层的数据分成更小的<strong>段 (Segments)</strong>，并在接收端重新组装，确保数据完整、有序地到达<strong>正确的应用程序进程</strong>。传输层关心的是进程到进程的通信。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>端口寻址</strong>：通过端口号 (Port Number) 识别目标主机上的特定应用程序进程。</li>
<li><strong>复用和分用 (Multiplexing&#x2F;Demultiplexing)</strong>：允许多个应用程序共享同一个网络连接，并将接收到的数据分发给正确的应用程序。</li>
<li><strong>面向连接或无连接传输</strong>：<ul>
<li><strong>TCP (Transmission Control Protocol)</strong>：提供可靠的、面向连接的传输服务（三次握手建立连接，四次挥手断开连接），保证数据有序、无差错、不丢失、不重复地到达。具有流量控制、拥塞控制和差错控制机制。</li>
<li><strong>UDP (User Datagram Protocol)</strong>：提供不可靠的、无连接的传输服务。效率高，开销小，但不管数据是否到达，不保证顺序和完整性。</li>
</ul>
</li>
<li><strong>分段与重组</strong>：将应用数据分割成合适的段，并在接收端重新组装。</li>
</ul>
</li>
<li><strong>数据单元</strong>：TCP 段 (TCP Segment) 或 UDP 数据报 (UDP Datagram)。</li>
<li><strong>协议举例</strong>：TCP、UDP。</li>
</ul>
<h3 id="2-5-应用层-Application-Layer-最顶层"><a href="#2-5-应用层-Application-Layer-最顶层" class="headerlink" title="2.5 应用层 (Application Layer) - 最顶层"></a>2.5 应用层 (Application Layer) - 最顶层</h3><ul>
<li><strong>功能</strong>：为用户提供直接面对的网络服务，以及应用程序之间的数据交换。它是用户与网络交互的接口，包括所有为用户提供具体服务的协议。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>实现服务</strong>：文件传输、电子邮件、远程登录、Web 浏览、域名解析等。</li>
<li><strong>数据表示</strong>：虽然五层模型中没有单独的表示层，但其功能（如数据格式化、加密&#x2F;解密、压缩&#x2F;解压缩）通常由应用层协议自身或其调用的库来实现。</li>
</ul>
</li>
<li><strong>数据单元</strong>：应用层消息 (Message)。</li>
<li><strong>协议举例</strong>：<ul>
<li><strong>HTTP (Hypertext Transfer Protocol)</strong>：万维网 (WWW) 的数据通信协议。</li>
<li><strong>HTTPS (HTTP Secure)</strong>：加密的 HTTP 版本，通常通过 TLS&#x2F;SSL 实现加密。</li>
<li><strong>FTP (File Transfer Protocol)</strong>：文件传输协议。</li>
<li><strong>SMTP (Simple Mail Transfer Protocol)</strong>：邮件发送协议。</li>
<li><strong>POP3 (Post Office Protocol version 3)</strong>：邮件接收协议。</li>
<li><strong>IMAP (Internet Message Access Protocol)</strong>：另一种邮件接收协议。</li>
<li><strong>DNS (Domain Name System)</strong>：域名解析协议，将域名解析为 IP 地址。</li>
<li><strong>Telnet&#x2F;SSH (Secure Shell)</strong>：远程登录协议。</li>
<li><strong>SNMP (Simple Network Management Protocol)</strong>：简单网络管理协议。</li>
</ul>
</li>
</ul>
<h2 id="三、数据传输过程中的封装与解封装"><a href="#三、数据传输过程中的封装与解封装" class="headerlink" title="三、数据传输过程中的封装与解封装"></a>三、数据传输过程中的封装与解封装</h2><p>数据从应用程序发送到物理介质，再到另一个应用程序的过程，本质上就是信息的层层封装和解封装。</p>
<p><strong>发送方 (Encapsulation)</strong>：</p>
<ol>
<li><strong>应用层</strong>：应用程序生成待发送的原始<strong>应用数据 (Data)</strong>。</li>
<li><strong>传输层</strong>：应用数据被分割，添加 TCP 或 UDP <strong>头部</strong> (包含源&#x2F;目的端口号)，形成 <strong>TCP 段</strong> 或 <strong>UDP 数据报</strong>。</li>
<li><strong>网络层</strong>：传输层数据被封装，添加 IP <strong>头部</strong> (包含源&#x2F;目的 IP 地址)，形成 <strong>IP 数据报</strong> (IP Packet)。</li>
<li><strong>数据链路层</strong>：IP 数据报被封装，添加 MAC <strong>头部</strong> (包含源&#x2F;目的 MAC 地址) 和 <strong>帧尾</strong> (Frame Trailer，包含 CRC 校验)，形成<strong>帧 (Frame)</strong>。</li>
<li><strong>物理层</strong>：帧中的比特流被编码转换为电信号、光信号或无线电波，并通过物理介质发送出去。</li>
</ol>
<p><strong>接收方 (Decapsulation)</strong>：</p>
<ol>
<li><strong>物理层</strong>：从物理介质接收到原始的电信号、光信号或电磁波，将其解码恢复为<strong>比特流</strong>，然后组装成<strong>帧</strong>。</li>
<li><strong>数据链路层</strong>：检查帧头帧尾、CRC 校验，验证数据的完整性，如果 MAC 地址匹配则剥离 MAC <strong>头部</strong>和<strong>帧尾</strong>，将剩下的<strong>IP 数据报</strong>交给网络层。</li>
<li><strong>网络层</strong>：检查 IP <strong>头部</strong>，根据目的 IP 地址判断数据报是否是发给本主机。如果正确，剥离 IP <strong>头部</strong>，将剩下的 <strong>TCP 段</strong> 或 <strong>UDP 数据报</strong> 交给传输层。</li>
<li><strong>传输层</strong>：检查 TCP&#x2F;UDP <strong>头部</strong>，根据目的端口号将数据传递给对应的应用程序进程。剥离 TCP&#x2F;UDP <strong>头部</strong>，将重新组装好的<strong>应用数据</strong>交给应用层。</li>
<li><strong>应用层</strong>：应用程序接收到最终处理好的<strong>应用数据</strong>。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph &quot;发送方 (Encapsulation)&quot;
        A_Send[应用层数据] --&gt;|添加TCP&#x2F;UDP Header| T_Segment[传输层段&#x2F;数据报]
        T_Segment --&gt;|添加IP Header| N_Packet[网络层IP数据报]
        N_Packet --&gt;|添加MAC Header&#x2F;Trailer| D_Frame[数据链路层帧]
        D_Frame --&gt;|编码为电&#x2F;光信号| H_Bits[物理层比特流]
    end

    H_Bits --通过网络--&gt; H_Bits_Rx[物理层比特流]

    subgraph &quot;接收方 (Decapsulation)&quot;
        H_Bits_Rx --&gt;|解码为比特流| D_Frame_Rx[数据链路层帧]
        D_Frame_Rx --&gt;|剥离MAC Header&#x2F;Trailer| N_Packet_Rx[网络层IP数据报]
        N_Packet_Rx --&gt;|剥离IP Header| T_Segment_Rx[传输层段&#x2F;数据报]
        T_Segment_Rx --&gt;|剥离TCP&#x2F;UDP Header| A_Receive[应用层数据]
    end

    style A_Send fill:#DDEBF7,stroke:#333,stroke-width:1px
    style T_Segment fill:#CCE6FF,stroke:#333,stroke-width:1px
    style N_Packet fill:#99CCFF,stroke:#333,stroke-width:1px
    style D_Frame fill:#66B3FF,stroke:#333,stroke-width:1px
    style H_Bits fill:#3399FF,stroke:#333,stroke-width:1px

    style H_Bits_Rx fill:#B2F7DD,stroke:#333,stroke-width:1px
    style D_Frame_Rx fill:#85E5BB,stroke:#333,stroke-width:1px
    style N_Packet_Rx fill:#5CD899,stroke:#333,stroke-width:1px
    style T_Segment_Rx fill:#33CC77,stroke:#333,stroke-width:1px
    style A_Receive fill:#00B359,stroke:#333,stroke-width:1px
  </pre></div>

<h2 id="四、各层网络设备扮演的角色"><a href="#四、各层网络设备扮演的角色" class="headerlink" title="四、各层网络设备扮演的角色"></a>四、各层网络设备扮演的角色</h2><p>不同的网络设备工作在协议栈的不同层级，共同协作完成数据传输：</p>
<ul>
<li><p><strong>物理层设备</strong>：</p>
<ul>
<li><strong>网卡 (Network Interface Card, NIC)</strong>：安装在主机内部，提供物理连接并实现物理层和数据链路层部分功能。</li>
<li><strong>集线器 (Hub)</strong>：物理层设备，简单地将接收到的信号广播到所有其他端口，不具备寻址和错误检测能力。</li>
<li><strong>中继器 (Repeater)</strong>：用于放大和整形信号，延长网络传输距离。</li>
<li><strong>光猫&#x2F;调制解调器 (Modem)</strong>：将数字信号转换为模拟信号，以便在电话线、光纤等介质上传输。</li>
</ul>
</li>
<li><p><strong>数据链路层设备</strong>：</p>
<ul>
<li><strong>交换机 (Switch)</strong>：根据 MAC 地址进行数据转发，隔离冲突域，提供更高的带宽利用率。</li>
<li><strong>网桥 (Bridge)</strong>：连接两个或多个局域网，根据 MAC 地址转发帧。</li>
</ul>
</li>
<li><p><strong>网络层设备</strong>：</p>
<ul>
<li><strong>路由器 (Router)</strong>：根据 IP 地址进行数据包转发，连接不同的网络（子网），实现跨网络的通信和路由选择。</li>
<li><strong>三层交换机</strong>：兼具交换机 (二层) 和路由器 (三层) 的功能，可以在局域网内部进行 IP 路由。</li>
</ul>
</li>
<li><p><strong>传输层设备</strong>：</p>
<ul>
<li><strong>防火墙 (Firewall)</strong>：可以基于 IP 地址和端口号过滤数据包，进行访问控制。</li>
<li><strong>负载均衡器 (Load Balancer)</strong>：可以根据传输层信息 (如 TCP&#x2F;UDP 端口) 将请求分发到后端服务器。</li>
</ul>
</li>
<li><p><strong>应用层设备</strong>：</p>
<ul>
<li><strong>代理服务器 (Proxy Server)</strong>：在应用层对请求进行转发、缓存、过滤等操作。</li>
<li><strong>防火墙 (Firewall)</strong>：高级防火墙可以基于应用层协议 (如 HTTP, FTP) 识别和过滤数据。</li>
<li><strong>网关 (Gateway)</strong>：连接两个使用不同协议的系统，通常在应用层进行协议转换。</li>
</ul>
</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>五层因特网协议栈是理解现代网络通信的基础。它简洁而高效地概括了数据如何从一个应用程序穿越全球基础设施到达另一个应用程序的整个旅程。从物理层的比特传输，到数据链路层的帧控制，再到网络层的 IP 寻址和路由，最后通过传输层的端到端连接和应用层的服务，每个层次都扮演着不可或缺的角色。深入理解每一层的功能、协议和数据单元，对于网络设计、故障排除以及开发高效的分布式系统都至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/5d5f7c78ff8d/">https://blog.tbf1211.xx.kg/5d5f7c78ff8d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-30.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/a73293a9d623/" title="Golang 匿名函数详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang 匿名函数详解</div></div><div class="info-2"><div class="info-item-1"> Golang 匿名函数 (Anonymous Function)，也被称为 函数字面量 (Function Literal)，是指没有明确名称的函数。它们可以在代码中的任何位置定义，并且可以直接执行或赋值给变量。匿名函数是 Go 语言支持函数式编程范式的重要特性之一，尤其在需要定义一次性函数、闭包或作为 Goroutine 和回调函数等场景中发挥着关键作用。  核心思想：将函数定义视为一种值，可以像处理其他类型的值一样处理它：赋值、作为参数传递、作为返回值返回，并且能够捕获其定义范围内的外部变量。   一、匿名函数的定义与基本语法匿名函数的基本语法与普通函数类似，只是省略了函数名。 基本结构： 123func(参数列表) (返回值列表) &#123;    // 函数体&#125;  示例： 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123;    // 1. 直接定义并执行匿名函数    func() &#123;        fmt.Prin...</div></div></div></a><a class="pagination-related" href="/2dc209b3606e/" title="OSI 七层模型详解 (The OSI 7-Layer Model Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</div></div><div class="info-2"><div class="info-item-1"> OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。  核心思想：将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。   一、为什么需要 OSI 模型？在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个统一的标准来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：  标准化：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。 模块化：将复杂的网络通...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/59d0e10ae2fa/" title="HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-05</div><div class="info-item-2">HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私</div></div><div class="info-2"><div class="info-item-1"> HTTPS (Hypertext Transfer Protocol Secure)，即超文本传输安全协议，是在 HTTP 协议的基础上，通过添加 SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security) 协议层来提供安全性的网络协议。它确保了客户端（通常是浏览器）和服务器之间的数据传输加密、完整且经过认证，从而保护用户的隐私和数据的安全。  核心思想：在不安全的互联网上，为 HTTP 通信提供加密、身份认证和数据完整性保护，使得网站能够安全可靠地传输信息。   一、为什么需要 HTTPS？传统的 HTTP 协议是一种明文传输协议，其数据的传输是透明的，没有任何加密。这导致了多重重要的安全隐患：  数据窃听 (Eavesdropping &#x2F; Sniffing)：  任何网络中间节点（如 Wi-Fi 热点、路由器、ISP）都可以截获并读取用户与网站之间传输的所有数据，包括敏感信息如用户名、密码、银行卡号、邮件内容等。 例如，您在一个非 HTTPS 网站登录，您的用户名和密码在网络中就是明文传输，攻...</div></div></div></a><a class="pagination-related" href="/abf64f03363d/" title="HTTP Upgrade 请求详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="info-item-2">HTTP Upgrade 请求详解</div></div><div class="info-2"><div class="info-item-1"> HTTP Upgrade 请求 是一种特殊的 HTTP&#x2F;1.1 机制，允许客户端和服务器在已经建立的 TCP 连接上，将当前协议从 HTTP&#x2F;1.1 切换到另一个不同的、更高级别的协议。最常见的应用场景是将 HTTP 连接升级到 WebSocket 协议，从而实现全双工、低延迟的持久连接。  核心思想：Upgrade 请求是 HTTP&#x2F;1.1 中用于协议协商的机制，允许在一个已有的 TCP 连接上，在客户端和服务器都同意的情况下，从 HTTP 切换到其他协议，避免了重新建立连接的开销，并开启更强大的通信模式。   一、为什么需要 HTTP Upgrade？HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 都是无状态的请求-响应协议。对于每个请求，客户端发送请求，服务器发送响应，然后连接可以关闭（非持久连接）或保持一段时间用于后续的 HTTP 请求（持久连接，Keep-Alive）。 这种请求-响应模式对于传统的 Web 页面浏览非常高效。然而，随着 Web 应用复杂度的增加，许多场景需要更高级的通信模式：  实时通信：聊天应用、在线游戏、...</div></div></div></a><a class="pagination-related" href="/2dc209b3606e/" title="OSI 七层模型详解 (The OSI 7-Layer Model Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-12</div><div class="info-item-2">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</div></div><div class="info-2"><div class="info-item-1"> OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。  核心思想：将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。   一、为什么需要 OSI 模型？在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个统一的标准来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：  标准化：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。 模块化：将复杂的网络通...</div></div></div></a><a class="pagination-related" href="/425bf08190fa/" title="TLS Encrypted Client Hello (ECH) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="info-item-2">TLS Encrypted Client Hello (ECH) 详解</div></div><div class="info-2"><div class="info-item-1"> TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。  核心思想：在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。   一、为什么需要 ECH？SNI 的隐私痛点在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：明文 SNI (Server Name Indication)。 1.1 SNI 的作用SNI 是 TLS 协议的一个扩展，用于解决虚拟主机 (Virtual Hosting) 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 example.com 和 another.c...</div></div></div></a><a class="pagination-related" href="/55a0c7732ea3/" title="QUIC (Quick UDP Internet Connections) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="info-item-2">QUIC (Quick UDP Internet Connections) 详解</div></div><div class="info-2"><div class="info-item-1"> QUIC (Quick UDP Internet Connections) 是由 Google 最早开发的一种通用的传输层网络协议，它旨在通过在 UDP 协议之上实现可靠性和安全性来加速 HTTP 流量。QUIC 合并了 TCP、TLS 和 HTTP&#x2F;2 的最佳特性，并针对现代互联网环境进行了优化，解决了 TCP 的一些固有局限性。目前，QUIC 已经由 IETF (Internet Engineering Task Force) 标准化为 RFC 9000 系列，并作为 HTTP&#x2F;3 的底层传输协议。  核心思想：QUIC 将 TCP 连接管理、TLS 加密和 HTTP&#x2F;2 多路复用等功能集成到 UDP 上，通过 0-RTT 连接、独立流、更快的连接迁移和可插拔拥塞控制，实现了低延迟、高吞吐量和强大的安全性。   一、为什么需要 QUIC？尽管 TCP&#x2F;IP 协议栈在过去几十年中支撑了整个互联网，但随着网络应用的发展和移动设备的普及，TCP 的一些固有缺陷逐渐显现出来：  TCP 三次握手延迟 (3-RTT)：每次建立新的 TCP 连接...</div></div></div></a><a class="pagination-related" href="/a8d205bac226/" title="HTTP&#x2F;2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="info-item-2">HTTP&#x2F;2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A0%88%EF%BC%9F"><span class="toc-text">一、为什么选择五层协议栈？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%BB%93%E6%9E%84%E5%8F%8A%E5%90%84%E5%B1%82%E5%8A%9F%E8%83%BD"><span class="toc-text">二、五层协议栈结构及各层功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%89%A9%E7%90%86%E5%B1%82-Physical-Layer-%E6%9C%80%E5%BA%95%E5%B1%82"><span class="toc-text">2.1 物理层 (Physical Layer) - 最底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-Data-Link-Layer-%E7%AC%AC-2-%E5%B1%82"><span class="toc-text">2.2 数据链路层 (Data Link Layer) - 第 2 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BD%91%E7%BB%9C%E5%B1%82-Network-Layer-%E7%AC%AC-3-%E5%B1%82"><span class="toc-text">2.3 网络层 (Network Layer) - 第 3 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%A0%E8%BE%93%E5%B1%82-Transport-Layer-%E7%AC%AC-4-%E5%B1%82"><span class="toc-text">2.4 传输层 (Transport Layer) - 第 4 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%BA%94%E7%94%A8%E5%B1%82-Application-Layer-%E6%9C%80%E9%A1%B6%E5%B1%82"><span class="toc-text">2.5 应用层 (Application Layer) - 最顶层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="toc-text">三、数据传输过程中的封装与解封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E6%89%AE%E6%BC%94%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-text">四、各层网络设备扮演的角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-30.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>