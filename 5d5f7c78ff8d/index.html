<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>五层因特网协议栈深度详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。">
<meta property="og:type" content="article">
<meta property="og:title" content="五层因特网协议栈深度详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/5d5f7c78ff8d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg">
<meta property="article:published_time" content="2023-12-13T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-25T12:41:00.574Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "五层因特网协议栈深度详解",
  "url": "https://blog.tbf1211.xx.kg/5d5f7c78ff8d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg",
  "datePublished": "2023-12-13T22:24:00.000Z",
  "dateModified": "2026-01-25T12:41:00.574Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/5d5f7c78ff8d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '五层因特网协议栈深度详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">519</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-25.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">五层因特网协议栈深度详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">五层因特网协议栈深度详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-12-13T22:24:00.000Z" title="发表于 2023-12-14 06:24:00">2023-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>五层因特网协议栈</strong>，也常被称为 <strong>TCP&#x2F;IP 五层模型</strong>，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将互联网的通信过程划分为五个逻辑层级，自顶向下依次为应用层、传输层、网络层、数据链路层和物理层，每层负责不同的通信职责，协同工作以实现全球互联。</strong></p>
</div>
<hr>
<h2 id="一、为什么选择五层协议栈？"><a href="#一、为什么选择五层协议栈？" class="headerlink" title="一、为什么选择五层协议栈？"></a>一、为什么选择五层协议栈？</h2><p>尽管 OSI 七层模型提供了非常详细的理论分层，但由于其设计时在标准制定上花费了大量时间，并且部分层次划分在实际实现中显得过于细致，导致其未能大规模落地。相反，TCP&#x2F;IP 协议族在互联网的早期发展中迅速崛起并成为事实标准。五层协议栈结合了二者的优点：</p>
<ol>
<li><strong>实用性</strong>：它直接反映了 TCP&#x2F;IP 协议族栈的工作方式，是互联网实际运行的写照。</li>
<li><strong>简洁性</strong>：相比 OSI 七层模型，它将 OSI 的应用层、表示层、会话层合并为<strong>应用层</strong>；将数据链路层和物理层作为独立的两个层，使得模型既能体现物理介质和链路控制，又不过于复杂。</li>
<li><strong>易于理解和教学</strong>：层次划分清晰，便于理解数据从应用程序到物理介质的流转过程。</li>
<li><strong>工程实现匹配</strong>：网络设备和操作系统的网络模块设计通常与此模型相对应。</li>
</ol>
<h2 id="二、五层协议栈结构及各层功能"><a href="#二、五层协议栈结构及各层功能" class="headerlink" title="二、五层协议栈结构及各层功能"></a>二、五层协议栈结构及各层功能</h2><p>数据在发送端从上层向下层传输，每层会添加自己的<strong>协议头 (Header)</strong> 或帧尾 (Trailer) 进行封装 (Encapsulation)；在接收端则从下层向上层传输，每层剥离 (Decapsulation) 自己的协议头。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;应用层 (Application Layer)&quot;] -- 提供网络服务给应用程序 --&gt; A_DATA(应用数据)
    T[&quot;传输层 (Transport Layer)&quot;] -- 端到端可靠传输、流量控制 --&gt; T_SEGMENT(段 Segment)
    N[&quot;网络层 (Network Layer)&quot;] -- 逻辑寻址、路由 --&gt; N_PACKET(包 Packet)
    D[&quot;数据链路层 (Data Link Layer)&quot;] -- 物理寻址、帧封装、错误检测 --&gt; D_FRAME(帧 Frame)
    H[&quot;物理层 (Physical Layer)&quot;] -- 传输比特流 --&gt; H_BIT(比特流 Bit)

    A_DATA --&gt; T_SEGMENT
    T_SEGMENT --&gt; N_PACKET
    N_PACKET --&gt; D_FRAME
    D_FRAME --&gt; H_BIT

    subgraph 发送方
        A
        T
        N
        D
        H
    end

    subgraph 接收方
        H_R[&quot;物理层 (Physical Layer)&quot;] -- 接收比特流 --&gt; H_R_BIT(比特流 Bit)
        D_R[&quot;数据链路层 (Data Link Layer)&quot;] -- 帧解析、错误检测 --&gt; D_R_FRAME(帧 Frame)
        N_R[&quot;网络层 (Network Layer)&quot;] -- 路由、逻辑寻址 --&gt; N_R_PACKET(包 Packet)
        T_R[&quot;传输层 (Transport Layer)&quot;] -- 端到端传输、流控 --&gt; T_R_SEGMENT(段 Segment)
        A_R[&quot;应用层 (Application Layer)&quot;] -- 应用程序接收数据 --&gt; A_R_DATA(应用数据)
    end

    H_BIT --通过物理介质--&gt; H_R_BIT
    H_R_BIT --&gt; D_R_FRAME
    D_R_FRAME --&gt; N_R_PACKET
    N_R_PACKET --&gt; T_R_SEGMENT
    T_R_SEGMENT --&gt; A_R_DATA
  </pre></div>

<h3 id="2-1-物理层-Physical-Layer-最底层"><a href="#2-1-物理层-Physical-Layer-最底层" class="headerlink" title="2.1 物理层 (Physical Layer) - 最底层"></a>2.1 物理层 (Physical Layer) - 最底层</h3><ul>
<li><strong>功能</strong>：定义了传输数据的电气、机械、过程和功能特性。它负责在物理媒体上透明地传输原始的<strong>比特流 (Bits)</strong>。简单来说，就是如何利用物理介质（如网线、光纤、无线电波）发送和接收0&#x2F;1的电信号、光信号或电磁波，以及这些信号的编码方式。</li>
<li><strong>主要任务</strong>：<ul>
<li>定义传输介质、接口标准 (如 RJ45、USB)。</li>
<li>定义数据编码和线路传输方式。</li>
<li>发送和接收原始比特流。</li>
</ul>
</li>
<li><strong>网络设备</strong>：网卡、集线器 (Hub)、中继器 (Repeater)、调制解调器 (Modem) 等。</li>
<li><strong>协议举例</strong>：所有物理介质和接口标准，如以太网的 100BASE-TX, 1000BASE-T (关于电信号传输)、Wi-Fi 的 802.11a&#x2F;b&#x2F;g&#x2F;n&#x2F;ac&#x2F;ax (关于无线电波传输)。</li>
</ul>
<h3 id="2-2-数据链路层-Data-Link-Layer-第-2-层"><a href="#2-2-数据链路层-Data-Link-Layer-第-2-层" class="headerlink" title="2.2 数据链路层 (Data Link Layer) - 第 2 层"></a>2.2 数据链路层 (Data Link Layer) - 第 2 层</h3><ul>
<li><strong>功能</strong>：在物理层提供的不可靠比特流传输的基础上，建立、维护和终止逻辑连接，将比特流封装成<strong>帧 (Frames)</strong>，并进行错误检测和物理寻址 (MAC 地址)。它负责在<strong>直接相连的节点之间</strong>可靠地传输数据。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>帧的封装和解封装</strong>：将网络层的数据报封装成帧，添加帧头 (包含源&#x2F;目的 MAC 地址) 和帧尾 (包含 CRC 校验)。</li>
<li><strong>物理寻址 (MAC 寻址)</strong>：根据设备网卡的 MAC 地址识别同一局域网内的设备。</li>
<li><strong>错误检测和纠正</strong>：通过 CRC 校验码等机制检测传输错误。</li>
<li><strong>流量控制</strong>：调节发送速率，避免接收方溢出。</li>
<li><strong>介质访问控制 (MAC)</strong>：协调多个设备对共享物理介质的访问（如以太网的 CSMA&#x2F;CD，Wi-Fi 的 CSMA&#x2F;CA）。</li>
</ul>
</li>
<li><strong>数据单元</strong>：帧 (Frame)。</li>
<li><strong>网络设备</strong>：网卡、交换机 (Switch)、网桥 (Bridge)。</li>
<li><strong>协议举例</strong>：Ethernet (以太网)、PPP (点对点协议)、Wi-Fi (IEEE 802.11)。</li>
</ul>
<h3 id="2-3-网络层-Network-Layer-第-3-层"><a href="#2-3-网络层-Network-Layer-第-3-层" class="headerlink" title="2.3 网络层 (Network Layer) - 第 3 层"></a>2.3 网络层 (Network Layer) - 第 3 层</h3><ul>
<li><strong>功能</strong>：负责对数据包进行<strong>逻辑寻址 (IP 地址)</strong>，实现不同网络之间的<strong>路由 (Routing)</strong>。它确保数据包能够从源主机传输到目的主机，即使它们不在同一个局域网中。网络层关心的是主机到主机的通信。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>逻辑寻址</strong>：使用 IP 地址唯一标识全球范围内的网络设备。</li>
<li><strong>路由选择</strong>：根据路由表和路由算法决定数据包转发的最佳路径，将数据包从源网络传输到目的网络。</li>
<li><strong>拥塞控制</strong>：试图避免网络拥塞。</li>
<li><strong>分段与重组 (Fragmentation&#x2F;Reassembly)</strong>：将过大的数据包分割成小块以适应底层数据链路层的 MTU (最大传输单元)，并在接收端重新组装。</li>
</ul>
</li>
<li><strong>数据单元</strong>：数据包 (Packet) 或数据报 (Datagram)。</li>
<li><strong>网络设备</strong>：路由器 (Router)、三层交换机。</li>
<li><strong>协议举例</strong>：IP (Internet Protocol, 包括 IPv4 和 IPv6)、ICMP (Internet Control Message Protocol, 用于差错报告和网络查询)、ARP (Address Resolution Protocol, 地址解析协议, 用于 IP 地址到 MAC 地址的映射)。</li>
</ul>
<h3 id="2-4-传输层-Transport-Layer-第-4-层"><a href="#2-4-传输层-Transport-Layer-第-4-层" class="headerlink" title="2.4 传输层 (Transport Layer) - 第 4 层"></a>2.4 传输层 (Transport Layer) - 第 4 层</h3><ul>
<li><strong>功能</strong>：提供<strong>端到端 (End-to-End)</strong> 的可靠或不可靠数据传输服务。它负责将应用层的数据分成更小的<strong>段 (Segments)</strong>，并在接收端重新组装，确保数据完整、有序地到达<strong>正确的应用程序进程</strong>。传输层关心的是进程到进程的通信。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>端口寻址</strong>：通过端口号 (Port Number) 识别目标主机上的特定应用程序进程。</li>
<li><strong>复用和分用 (Multiplexing&#x2F;Demultiplexing)</strong>：允许多个应用程序共享同一个网络连接，并将接收到的数据分发给正确的应用程序。</li>
<li><strong>面向连接或无连接传输</strong>：<ul>
<li><strong>TCP (Transmission Control Protocol)</strong>：提供可靠的、面向连接的传输服务（三次握手建立连接，四次挥手断开连接），保证数据有序、无差错、不丢失、不重复地到达。具有流量控制、拥塞控制和差错控制机制。</li>
<li><strong>UDP (User Datagram Protocol)</strong>：提供不可靠的、无连接的传输服务。效率高，开销小，但不管数据是否到达，不保证顺序和完整性。</li>
</ul>
</li>
<li><strong>分段与重组</strong>：将应用数据分割成合适的段，并在接收端重新组装。</li>
</ul>
</li>
<li><strong>数据单元</strong>：TCP 段 (TCP Segment) 或 UDP 数据报 (UDP Datagram)。</li>
<li><strong>协议举例</strong>：TCP、UDP。</li>
</ul>
<h3 id="2-5-应用层-Application-Layer-最顶层"><a href="#2-5-应用层-Application-Layer-最顶层" class="headerlink" title="2.5 应用层 (Application Layer) - 最顶层"></a>2.5 应用层 (Application Layer) - 最顶层</h3><ul>
<li><strong>功能</strong>：为用户提供直接面对的网络服务，以及应用程序之间的数据交换。它是用户与网络交互的接口，包括所有为用户提供具体服务的协议。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>实现服务</strong>：文件传输、电子邮件、远程登录、Web 浏览、域名解析等。</li>
<li><strong>数据表示</strong>：虽然五层模型中没有单独的表示层，但其功能（如数据格式化、加密&#x2F;解密、压缩&#x2F;解压缩）通常由应用层协议自身或其调用的库来实现。</li>
</ul>
</li>
<li><strong>数据单元</strong>：应用层消息 (Message)。</li>
<li><strong>协议举例</strong>：<ul>
<li><strong>HTTP (Hypertext Transfer Protocol)</strong>：万维网 (WWW) 的数据通信协议。</li>
<li><strong>HTTPS (HTTP Secure)</strong>：加密的 HTTP 版本，通常通过 TLS&#x2F;SSL 实现加密。</li>
<li><strong>FTP (File Transfer Protocol)</strong>：文件传输协议。</li>
<li><strong>SMTP (Simple Mail Transfer Protocol)</strong>：邮件发送协议。</li>
<li><strong>POP3 (Post Office Protocol version 3)</strong>：邮件接收协议。</li>
<li><strong>IMAP (Internet Message Access Protocol)</strong>：另一种邮件接收协议。</li>
<li><strong>DNS (Domain Name System)</strong>：域名解析协议，将域名解析为 IP 地址。</li>
<li><strong>Telnet&#x2F;SSH (Secure Shell)</strong>：远程登录协议。</li>
<li><strong>SNMP (Simple Network Management Protocol)</strong>：简单网络管理协议。</li>
</ul>
</li>
</ul>
<h2 id="三、数据传输过程中的封装与解封装"><a href="#三、数据传输过程中的封装与解封装" class="headerlink" title="三、数据传输过程中的封装与解封装"></a>三、数据传输过程中的封装与解封装</h2><p>数据从应用程序发送到物理介质，再到另一个应用程序的过程，本质上就是信息的层层封装和解封装。</p>
<p><strong>发送方 (Encapsulation)</strong>：</p>
<ol>
<li><strong>应用层</strong>：应用程序生成待发送的原始<strong>应用数据 (Data)</strong>。</li>
<li><strong>传输层</strong>：应用数据被分割，添加 TCP 或 UDP <strong>头部</strong> (包含源&#x2F;目的端口号)，形成 <strong>TCP 段</strong> 或 <strong>UDP 数据报</strong>。</li>
<li><strong>网络层</strong>：传输层数据被封装，添加 IP <strong>头部</strong> (包含源&#x2F;目的 IP 地址)，形成 <strong>IP 数据报</strong> (IP Packet)。</li>
<li><strong>数据链路层</strong>：IP 数据报被封装，添加 MAC <strong>头部</strong> (包含源&#x2F;目的 MAC 地址) 和 <strong>帧尾</strong> (Frame Trailer，包含 CRC 校验)，形成<strong>帧 (Frame)</strong>。</li>
<li><strong>物理层</strong>：帧中的比特流被编码转换为电信号、光信号或无线电波，并通过物理介质发送出去。</li>
</ol>
<p><strong>接收方 (Decapsulation)</strong>：</p>
<ol>
<li><strong>物理层</strong>：从物理介质接收到原始的电信号、光信号或电磁波，将其解码恢复为<strong>比特流</strong>，然后组装成<strong>帧</strong>。</li>
<li><strong>数据链路层</strong>：检查帧头帧尾、CRC 校验，验证数据的完整性，如果 MAC 地址匹配则剥离 MAC <strong>头部</strong>和<strong>帧尾</strong>，将剩下的<strong>IP 数据报</strong>交给网络层。</li>
<li><strong>网络层</strong>：检查 IP <strong>头部</strong>，根据目的 IP 地址判断数据报是否是发给本主机。如果正确，剥离 IP <strong>头部</strong>，将剩下的 <strong>TCP 段</strong> 或 <strong>UDP 数据报</strong> 交给传输层。</li>
<li><strong>传输层</strong>：检查 TCP&#x2F;UDP <strong>头部</strong>，根据目的端口号将数据传递给对应的应用程序进程。剥离 TCP&#x2F;UDP <strong>头部</strong>，将重新组装好的<strong>应用数据</strong>交给应用层。</li>
<li><strong>应用层</strong>：应用程序接收到最终处理好的<strong>应用数据</strong>。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph &quot;发送方 (Encapsulation)&quot;
        A_Send[应用层数据] --&gt;|添加TCP&#x2F;UDP Header| T_Segment[传输层段&#x2F;数据报]
        T_Segment --&gt;|添加IP Header| N_Packet[网络层IP数据报]
        N_Packet --&gt;|添加MAC Header&#x2F;Trailer| D_Frame[数据链路层帧]
        D_Frame --&gt;|编码为电&#x2F;光信号| H_Bits[物理层比特流]
    end

    H_Bits --通过网络--&gt; H_Bits_Rx[物理层比特流]

    subgraph &quot;接收方 (Decapsulation)&quot;
        H_Bits_Rx --&gt;|解码为比特流| D_Frame_Rx[数据链路层帧]
        D_Frame_Rx --&gt;|剥离MAC Header&#x2F;Trailer| N_Packet_Rx[网络层IP数据报]
        N_Packet_Rx --&gt;|剥离IP Header| T_Segment_Rx[传输层段&#x2F;数据报]
        T_Segment_Rx --&gt;|剥离TCP&#x2F;UDP Header| A_Receive[应用层数据]
    end

    style A_Send fill:#DDEBF7,stroke:#333,stroke-width:1px
    style T_Segment fill:#CCE6FF,stroke:#333,stroke-width:1px
    style N_Packet fill:#99CCFF,stroke:#333,stroke-width:1px
    style D_Frame fill:#66B3FF,stroke:#333,stroke-width:1px
    style H_Bits fill:#3399FF,stroke:#333,stroke-width:1px

    style H_Bits_Rx fill:#B2F7DD,stroke:#333,stroke-width:1px
    style D_Frame_Rx fill:#85E5BB,stroke:#333,stroke-width:1px
    style N_Packet_Rx fill:#5CD899,stroke:#333,stroke-width:1px
    style T_Segment_Rx fill:#33CC77,stroke:#333,stroke-width:1px
    style A_Receive fill:#00B359,stroke:#333,stroke-width:1px
  </pre></div>

<h2 id="四、各层网络设备扮演的角色"><a href="#四、各层网络设备扮演的角色" class="headerlink" title="四、各层网络设备扮演的角色"></a>四、各层网络设备扮演的角色</h2><p>不同的网络设备工作在协议栈的不同层级，共同协作完成数据传输：</p>
<ul>
<li><p><strong>物理层设备</strong>：</p>
<ul>
<li><strong>网卡 (Network Interface Card, NIC)</strong>：安装在主机内部，提供物理连接并实现物理层和数据链路层部分功能。</li>
<li><strong>集线器 (Hub)</strong>：物理层设备，简单地将接收到的信号广播到所有其他端口，不具备寻址和错误检测能力。</li>
<li><strong>中继器 (Repeater)</strong>：用于放大和整形信号，延长网络传输距离。</li>
<li><strong>光猫&#x2F;调制解调器 (Modem)</strong>：将数字信号转换为模拟信号，以便在电话线、光纤等介质上传输。</li>
</ul>
</li>
<li><p><strong>数据链路层设备</strong>：</p>
<ul>
<li><strong>交换机 (Switch)</strong>：根据 MAC 地址进行数据转发，隔离冲突域，提供更高的带宽利用率。</li>
<li><strong>网桥 (Bridge)</strong>：连接两个或多个局域网，根据 MAC 地址转发帧。</li>
</ul>
</li>
<li><p><strong>网络层设备</strong>：</p>
<ul>
<li><strong>路由器 (Router)</strong>：根据 IP 地址进行数据包转发，连接不同的网络（子网），实现跨网络的通信和路由选择。</li>
<li><strong>三层交换机</strong>：兼具交换机 (二层) 和路由器 (三层) 的功能，可以在局域网内部进行 IP 路由。</li>
</ul>
</li>
<li><p><strong>传输层设备</strong>：</p>
<ul>
<li><strong>防火墙 (Firewall)</strong>：可以基于 IP 地址和端口号过滤数据包，进行访问控制。</li>
<li><strong>负载均衡器 (Load Balancer)</strong>：可以根据传输层信息 (如 TCP&#x2F;UDP 端口) 将请求分发到后端服务器。</li>
</ul>
</li>
<li><p><strong>应用层设备</strong>：</p>
<ul>
<li><strong>代理服务器 (Proxy Server)</strong>：在应用层对请求进行转发、缓存、过滤等操作。</li>
<li><strong>防火墙 (Firewall)</strong>：高级防火墙可以基于应用层协议 (如 HTTP, FTP) 识别和过滤数据。</li>
<li><strong>网关 (Gateway)</strong>：连接两个使用不同协议的系统，通常在应用层进行协议转换。</li>
</ul>
</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>五层因特网协议栈是理解现代网络通信的基础。它简洁而高效地概括了数据如何从一个应用程序穿越全球基础设施到达另一个应用程序的整个旅程。从物理层的比特传输，到数据链路层的帧控制，再到网络层的 IP 寻址和路由，最后通过传输层的端到端连接和应用层的服务，每个层次都扮演着不可或缺的角色。深入理解每一层的功能、协议和数据单元，对于网络设计、故障排除以及开发高效的分布式系统都至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/5d5f7c78ff8d/">https://blog.tbf1211.xx.kg/5d5f7c78ff8d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-25.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/a73293a9d623/" title="Golang 匿名函数详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang 匿名函数详解</div></div><div class="info-2"><div class="info-item-1"> Golang 匿名函数 (Anonymous Function)，也被称为 函数字面量 (Function Literal)，是指没有明确名称的函数。它们可以在代码中的任何位置定义，并且可以直接执行或赋值给变量。匿名函数是 Go 语言支持函数式编程范式的重要特性之一，尤其在需要定义一次性函数、闭包或作为 Goroutine 和回调函数等场景中发挥着关键作用。  核心思想：将函数定义视为一种值，可以像处理其他类型的值一样处理它：赋值、作为参数传递、作为返回值返回，并且能够捕获其定义范围内的外部变量。   一、匿名函数的定义与基本语法匿名函数的基本语法与普通函数类似，只是省略了函数名。 基本结构： 123func(参数列表) (返回值列表) &#123;    // 函数体&#125;  示例： 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123;    // 1. 直接定义并执行匿名函数    func() &#123;        fmt.Prin...</div></div></div></a><a class="pagination-related" href="/2dc209b3606e/" title="OSI 七层模型详解 (The OSI 7-Layer Model Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</div></div><div class="info-2"><div class="info-item-1"> OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。  核心思想：将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。   一、为什么需要 OSI 模型？在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个统一的标准来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：  标准化：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。 模块化：将复杂的网络通...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6479020306f5/" title="HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="info-item-2">HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;3 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 QUIC (Quick UDP Internet Connections) 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全性及在复杂网络环境下的韧性，从而彻底改变 Web 资源的传输方式。  核心思想：HTTP&#x2F;3 运行在 QUIC 协议之上，而 QUIC 又运行在 UDP 协议之上。通过在传输层而非应用层引入多路复用、内置 TLS 1.3 加密、连接迁移等特性，HTTP&#x2F;3 提供了一个比 HTTP&#x2F;2 更快、更稳定、更安全的 Web 体验，尤其在移动网络和有损网络环境下表现突出。   一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景HTTP&#x2F;2 作为 HTTP&#x2F;1.1 的继任者，通过头部压缩、多路复用和服务器推送等机制，显著提升了...</div></div></div></a><a class="pagination-related" href="/9be87a9e79b5/" title="KCP协议详解：一个快速可靠的UDP上层协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-13</div><div class="info-item-2">KCP协议详解：一个快速可靠的UDP上层协议</div></div><div class="info-2"><div class="info-item-1"> KCP (Fast and Reliable UDP protocol) 是一个由 skywind3000 (吴云) 在 2014 年开源的快速可靠的 UDP 上层协议。它的设计目标是在网络状况不佳（高延迟、高丢包率）的环境下，提供比 TCP 更快的传输速度和更低的延迟，同时保持数据的可靠性。KCP 并不是一个完整的网络协议栈，而是一个可嵌入式的库，它运行在 UDP 协议之上，提供了 TCP 所具备的可靠性、流量控制和拥塞控制等机制，但针对延迟和重传进行了优化。  核心思想：在保障数据可靠性的前提下，通过优化重传机制、激进发送和控制重传间隔等方法，尽可能地减少传输延迟，以适应游戏、实时音视频等对延迟高度敏感的应用。   一、为什么需要 KCP？TCP 协议是互联网上最常用的可靠传输协议，但它在一些场景下存在明显的局限性：  慢启动 (Slow Start)：TCP 为了避免网络拥塞，在连接建立初期会限制发送速率，逐渐增加。这对于短连接或突发数据传输会增加初始延迟。 队头阻塞 (Head-of-Line Blocking, HOLB)：TCP 的报文是严格按序到达的。如果某个数据...</div></div></div></a><a class="pagination-related" href="/8fad93ea4f62/" title="ALPN (Application-Layer Protocol Negotiation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="info-item-2">ALPN (Application-Layer Protocol Negotiation) 详解</div></div><div class="info-2"><div class="info-item-1"> ALPN (Application-Layer Protocol Negotiation)，即应用层协议协商，是 TLS (传输层安全) 协议的一个扩展，允许客户端和服务器在进行 TLS 握手时，协商决定在加密连接上使用哪个应用层协议。它在 RFC 7301 中被定义。ALPN 的出现，极大地简化了现代网络协议的部署和使用，尤其是对于 HTTP&#x2F;2 和未来的 QUIC 等协议。  核心思想：ALPN 将应用层协议的选择过程集成到 TLS 握手阶段，使得在建立加密连接的同时，也完成了应用层协议的确定，避免了额外的往返延迟，并允许在同一端口上运行多种应用层协议。   一、为什么需要 ALPN？在 ALPN 出现之前，协商应用层协议通常面临以下挑战：  端口绑定：传统的做法是为不同的应用层协议使用不同的端口。例如，HTTP 使用 80 端口，HTTPS 使用 443 端口，FTP 使用 21 端口。当引入新的协议（如 HTTP&#x2F;2 或 SPDY）时，如果想与现有协议共存，就必须使用新的端口，这会增加防火墙配置、负载均衡设置的复杂性，并且用户可能需要记住非标准的端口...</div></div></div></a><a class="pagination-related" href="/bfc3178a0093/" title="FRP (Fast Reverse Proxy) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="info-item-2">FRP (Fast Reverse Proxy) 详解</div></div><div class="info-2"><div class="info-item-1"> FRP (Fast Reverse Proxy) 是一个高性能的内网穿透和反向代理工具，它允许您将位于内网（局域网）中的服务（如 Web 服务器、SSH、数据库等）通过一台具有公网 IP 的服务器暴露给公网用户访问。在当前 IPv4 地址资源日益紧张，许多家庭和小型办公室难以获取公网 IP 的背景下，FRP 提供了便捷、高效的解决方案。  核心思想：FRP 通过在公网服务器上运行一个 frps (服务端) 和在内网机器上运行一个 frpc (客户端) 来建立连接。内网流量经由 frpc 转发到 frps，再由 frps 转发到公网用户，实现内网服务的公网访问。   一、为什么需要 FRP？在许多场景下，我们需要从外部网络访问位于内网的服务，但常常面临以下问题：  没有公网 IP：大多数家庭宽带用户和一些小型企业用户不再拥有独立的公网 IPv4 地址。他们处于运营商的 NAT (Network Address Translation) 之后，无法直接从外部访问内网设备。 端口转发困难：即使有公网 IP，也可能需要手动在路由器上配置端口转发规则，这对于不熟悉网络配置的用户来说可能比...</div></div></div></a><a class="pagination-related" href="/058452c6e7a6/" title="TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="info-item-2">TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石</div></div><div class="info-2"><div class="info-item-1"> TCP (Transmission Control Protocol)，即传输控制协议，是 Internet 协议套件 (Internet Protocol Suite) 中的核心协议之一，位于传输层。它提供可靠的、面向连接的、基于字节流的全双工通信服务。TCP 协议确保了数据能够按序、无差错地从一个应用进程传输到另一个应用进程。  核心思想：在不可靠的 IP 层之上，通过一系列机制（如序号、确认、重传、流量控制、拥塞控制）构建一个高度可靠、有序的数据传输通道。   一、为什么需要 TCP？在网络模型中，IP 协议（网络层）提供了尽力而为 (best-effort) 的数据报服务，它不保证数据包的到达、顺序或不重复。然而，大多数应用（如网页浏览、文件传输、电子邮件）都需要一个可靠的数据传输服务。TCP 正是为了弥补 IP 协议的这些不足而设计的，它在应用层和网络层之间提供了一个可靠的、虚拟的通信管道。 TCP 的主要职责包括：  可靠性：确保数据无损、无错地到达目的地。 有序性：确保数据包以正确的顺序交付给接收方。 流量控制：防止发送方发送数据过快，导致接收方缓冲区溢出。 拥塞...</div></div></div></a><a class="pagination-related" href="/2dc209b3606e/" title="OSI 七层模型详解 (The OSI 7-Layer Model Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-12</div><div class="info-item-2">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</div></div><div class="info-2"><div class="info-item-1"> OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。  核心思想：将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。   一、为什么需要 OSI 模型？在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个统一的标准来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：  标准化：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。 模块化：将复杂的网络通...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">519</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A0%88%EF%BC%9F"><span class="toc-text">一、为什么选择五层协议栈？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%BB%93%E6%9E%84%E5%8F%8A%E5%90%84%E5%B1%82%E5%8A%9F%E8%83%BD"><span class="toc-text">二、五层协议栈结构及各层功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%89%A9%E7%90%86%E5%B1%82-Physical-Layer-%E6%9C%80%E5%BA%95%E5%B1%82"><span class="toc-text">2.1 物理层 (Physical Layer) - 最底层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-Data-Link-Layer-%E7%AC%AC-2-%E5%B1%82"><span class="toc-text">2.2 数据链路层 (Data Link Layer) - 第 2 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BD%91%E7%BB%9C%E5%B1%82-Network-Layer-%E7%AC%AC-3-%E5%B1%82"><span class="toc-text">2.3 网络层 (Network Layer) - 第 3 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%A0%E8%BE%93%E5%B1%82-Transport-Layer-%E7%AC%AC-4-%E5%B1%82"><span class="toc-text">2.4 传输层 (Transport Layer) - 第 4 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%BA%94%E7%94%A8%E5%B1%82-Application-Layer-%E6%9C%80%E9%A1%B6%E5%B1%82"><span class="toc-text">2.5 应用层 (Application Layer) - 最顶层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="toc-text">三、数据传输过程中的封装与解封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E6%89%AE%E6%BC%94%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-text">四、各层网络设备扮演的角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-25.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>