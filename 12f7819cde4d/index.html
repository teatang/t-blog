<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>虚拟专用网络 (VPN) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虚拟专用网络 (VPN - Virtual Private Network) 是一种用于在公共网络（如互联网）上建立安全的、加密的连接的技术。它允许用户安全地访问远程网络，如同直接连接到该网络一样。VPN 通过隧道 (Tunneling)、加密 (Encryption) 和认证 (Authentication) 机制，确保数据在传输过程中的隐私性、完整性和安全性，是现代远程办公、保护在线隐私和访">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟专用网络 (VPN) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/12f7819cde4d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="虚拟专用网络 (VPN - Virtual Private Network) 是一种用于在公共网络（如互联网）上建立安全的、加密的连接的技术。它允许用户安全地访问远程网络，如同直接连接到该网络一样。VPN 通过隧道 (Tunneling)、加密 (Encryption) 和认证 (Authentication) 机制，确保数据在传输过程中的隐私性、完整性和安全性，是现代远程办公、保护在线隐私和访">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg">
<meta property="article:published_time" content="2024-08-08T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-05T09:25:21.066Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "虚拟专用网络 (VPN) 详解",
  "url": "https://blog.tbf1211.xx.kg/12f7819cde4d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg",
  "datePublished": "2024-08-08T22:24:00.000Z",
  "dateModified": "2026-02-05T09:25:21.066Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/12f7819cde4d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '虚拟专用网络 (VPN) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">545</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-28.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">虚拟专用网络 (VPN) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">虚拟专用网络 (VPN) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-08T22:24:00.000Z" title="发表于 2024-08-09 06:24:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>虚拟专用网络 (VPN - Virtual Private Network)</strong> 是一种用于在公共网络（如互联网）上建立安全的、加密的连接的技术。它允许用户安全地访问远程网络，如同直接连接到该网络一样。VPN 通过<strong>隧道 (Tunneling)</strong>、<strong>加密 (Encryption)</strong> 和<strong>认证 (Authentication)</strong> 机制，确保数据在传输过程中的隐私性、完整性和安全性，是现代远程办公、保护在线隐私和访问受限内容的关键技术。</p>
</blockquote>
<div class="note info flat"><p>核心功能：在不安全的公共网络上构建安全的、加密的“隧道”，实现远程设备或网络的安全互联。</p>
</div>
<hr>
<h2 id="一、为什么需要-VPN？"><a href="#一、为什么需要-VPN？" class="headerlink" title="一、为什么需要 VPN？"></a>一、为什么需要 VPN？</h2><p>在日益开放和互联的网络环境中，VPN 解决了许多核心的网络通信挑战：</p>
<ol>
<li><strong>数据安全与隐私保护</strong>：<ul>
<li>在 Wi-Fi 热点等公共网络中，数据未经加密传输容易被窃听或篡改。VPN 对所有流量进行加密，保护用户隐私。</li>
<li>防止互联网服务提供商 (ISP) 监控用户的在线活动。</li>
<li>避免政府或第三方机构对网络流量的审查和监控。</li>
</ul>
</li>
<li><strong>远程安全访问企业资源</strong>：<ul>
<li>员工在家中或出差时，需要安全、便捷地访问公司内部网络资源（文件服务器、内部应用等）。VPN 提供了远程用户到公司网络的加密通道。</li>
</ul>
</li>
<li><strong>绕过地理限制与审查</strong>：<ul>
<li>某些在线服务或内容可能因地理位置限制而无法访问。VPN 可以模拟用户从其他国家&#x2F;地区访问，绕过这些限制。</li>
<li>在互联网内容受到审查或限制的地区，VPN 可以帮助用户访问被封锁的信息。</li>
</ul>
</li>
<li><strong>匿名性</strong>：<ul>
<li>VPN 可以隐藏用户的真实 IP 地址，使其在网络上的活动更具匿名性，提高在线隐私。</li>
</ul>
</li>
</ol>
<h2 id="二、VPN-的工作原理"><a href="#二、VPN-的工作原理" class="headerlink" title="二、VPN 的工作原理"></a>二、VPN 的工作原理</h2><p>VPN 的核心在于在不安全的公共网络上构建一个<strong>安全的逻辑连接</strong>，这个连接通常被称为“隧道”。</p>
<h3 id="2-1-隧道技术-Tunneling"><a href="#2-1-隧道技术-Tunneling" class="headerlink" title="2.1 隧道技术 (Tunneling)"></a>2.1 隧道技术 (Tunneling)</h3><ul>
<li><strong>定义</strong>：隧道技术是在一个协议（传输协议）中封装另一个协议（负载协议）数据包的过程。VPN 在公共网络上建立一个虚拟的专用通道，所有通过 VPN 连接传输的数据都会被封装在这个“隧道”中。</li>
<li><strong>过程</strong>：<ol>
<li>VPN 客户端首先与 VPN 服务器建立连接。</li>
<li>客户端要发送的数据包（原始数据包）首先由 VPN 客户端软件接收。</li>
<li>VPN 客户端将这些原始数据包进行封装，添加新的 VPN 协议头（例如 PPTP、L2TP、OpenVPN 等），并在封装前进行加密。</li>
<li>封装后的数据包通过公共网络发送到 VPN 服务器。</li>
<li>VPN 服务器接收到封装并加密的数据包后，会对其进行解密和解封装，还原出原始数据包。</li>
<li>VPN 服务器将解封装后的原始数据包转发到目标网络或互联网。</li>
<li>反向流量也以相同的方式进行封装和传输。</li>
</ol>
</li>
</ul>
<h3 id="2-2-加密-Encryption"><a href="#2-2-加密-Encryption" class="headerlink" title="2.2 加密 (Encryption)"></a>2.2 加密 (Encryption)</h3><ul>
<li><strong>定义</strong>：加密是对数据进行编码的过程，只有拥有正确密钥的人才能将其解码。VPN 对通过隧道传输的所有数据进行加密，以防止窃听者读取数据。</li>
<li><strong>常用加密算法</strong>：AES (Advanced Encryption Standard)、3DES (Triple DES) 等。加密强度通常以密钥长度表示（如 AES-256）。</li>
<li><strong>作用</strong>：即使数据包在传输过程中被截获，也无法被解密和理解，从而保护了通信内容的隐私。</li>
</ul>
<h3 id="2-3-认证-Authentication"><a href="#2-3-认证-Authentication" class="headerlink" title="2.3 认证 (Authentication)"></a>2.3 认证 (Authentication)</h3><ul>
<li><strong>定义</strong>：认证是验证用户或设备身份的过程，确保只有授权的用户才能访问 VPN 网络。</li>
<li><strong>常用认证方式</strong>：<ul>
<li><strong>用户名&#x2F;密码</strong>：最常见的认证方式。</li>
<li><strong>数字证书</strong>：通过颁发和验证数字证书来确认客户端和服务器的身份，提供更强的安全性。</li>
<li><strong>预共享密钥 (PSK)</strong>：在建立连接前，客户端和服务器共享一个密钥。</li>
<li><strong>一次性密码 (OTP)</strong>、<strong>双因素认证 (2FA)</strong> 等。</li>
</ul>
</li>
<li><strong>作用</strong>：防止未经授权的用户连接到 VPN 服务器或伪造 VPN 服务器。</li>
</ul>
<h3 id="2-4-VPN-工作流示意图"><a href="#2-4-VPN-工作流示意图" class="headerlink" title="2.4 VPN 工作流示意图"></a>2.4 VPN 工作流示意图</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[用户设备 - VPN客户端] --&gt;|原始数据| B(VPN软件 封装 &amp; 加密)
    B --&gt;|&quot;VPN数据包 (加密 &amp; 封装)&quot;| C{公共网络&#x2F;互联网}
    C --&gt;|&quot;VPN数据包 (加密 &amp; 封装)&quot;| D[VPN服务器 解密 &amp; 解封装]
    D --&gt;|原始数据| E[目标网络&#x2F;互联网]
    E --&gt;|目标响应数据| F[目标网络&#x2F;互联网]
    F --&gt;|原始响应数据| D
    D --&gt;|&quot;VPN响应数据包 (加密 &amp; 封装)&quot;| C
    C --&gt;|&quot;VPN响应数据包 (加密 &amp; 封装)&quot;| B
    B --&gt;|原始响应数据| A
  
    subgraph VPN Client Side
        A
        B
    end

    subgraph &quot;Internet (Insecure)&quot;
        C
    end

    subgraph VPN Server Side
        D
    end

    subgraph Destination
        E
        F
    end
  </pre></div>

<h2 id="三、主流-VPN-协议"><a href="#三、主流-VPN-协议" class="headerlink" title="三、主流 VPN 协议"></a>三、主流 VPN 协议</h2><p>不同的 VPN 协议在安全性、速度、兼容性和易用性方面各有侧重。</p>
<h3 id="3-1-PPTP-Point-to-Point-Tunneling-Protocol"><a href="#3-1-PPTP-Point-to-Point-Tunneling-Protocol" class="headerlink" title="3.1 PPTP (Point-to-Point Tunneling Protocol)"></a>3.1 PPTP (Point-to-Point Tunneling Protocol)</h3><ul>
<li><strong>特点</strong>：历史悠久，兼容性好，几乎所有操作系统都内置支持。速度较快，但<strong>安全性差</strong>，易受攻击。</li>
<li><strong>加密&#x2F;认证</strong>：依赖 MPPE 对数据进行加密，MS-CHAPv2 进行认证。</li>
<li><strong>现状</strong>：由于存在严重安全漏洞，<strong>已不推荐使用</strong>，尤其是在需要高安全性的场景。</li>
</ul>
<h3 id="3-2-L2TP-IPsec-Layer-2-Tunneling-Protocol-over-IPsec"><a href="#3-2-L2TP-IPsec-Layer-2-Tunneling-Protocol-over-IPsec" class="headerlink" title="3.2 L2TP&#x2F;IPsec (Layer 2 Tunneling Protocol over IPsec)"></a>3.2 L2TP&#x2F;IPsec (Layer 2 Tunneling Protocol over IPsec)</h3><ul>
<li><strong>特点</strong>：L2TP 提供隧道，但本身不加密，依靠 IPsec (Internet Protocol Security) 协议套件来提供数据加密、认证和完整性保护。广泛支持，安全性较好。</li>
<li><strong>加密&#x2F;认证</strong>：IPsec 提供了强大的加密（如 AES）和认证（如预共享密钥、数字证书）。</li>
<li><strong>缺点</strong>：相比 OpenVPN，通常速度稍慢，且可能在 NAT 环境下遇到穿透问题 (NAT traversal)。实现较复杂。</li>
</ul>
<h3 id="3-3-OpenVPN"><a href="#3-3-OpenVPN" class="headerlink" title="3.3 OpenVPN"></a>3.3 OpenVPN</h3><ul>
<li><strong>特点</strong>：开源、高度可配置、安全性极高、灵活、跨平台支持良好。使用 SSL&#x2F;TLS 协议栈进行密钥交换和数据加密。</li>
<li><strong>加密&#x2F;认证</strong>：支持多种加密算法（如 AES-256）和强大的认证方式（用户名&#x2F;密码、数字证书）。</li>
<li><strong>优势</strong>：能够很好地穿透防火墙和 NAT 设备，是目前最受欢迎和推荐的 VPN 协议之一。</li>
<li><strong>缺点</strong>：可能需要第三方客户端软件，配置相对复杂。</li>
</ul>
<h3 id="3-4-WireGuard"><a href="#3-4-WireGuard" class="headerlink" title="3.4 WireGuard"></a>3.4 WireGuard</h3><ul>
<li><strong>特点</strong>：相对较新，设计目标是简洁、高性能和高安全性。代码量小（约 4000 行），更易于审计。</li>
<li><strong>加密&#x2F;认证</strong>：使用现代密码学算法（如 ChaCha20 for encryption, Poly1305 for authentication），基于密钥对而非证书。</li>
<li><strong>优势</strong>：速度极快，连接建立迅速，低延迟，资源消耗少。内置于 Linux 内核。</li>
<li><strong>缺点</strong>：较新，生态系统正在完善中。部分高级功能（如流量混淆）可能不如 OpenVPN 丰富。</li>
</ul>
<h3 id="3-5-其他协议"><a href="#3-5-其他协议" class="headerlink" title="3.5 其他协议"></a>3.5 其他协议</h3><ul>
<li><strong>SSTP (Secure Socket Tunneling Protocol)</strong>：微软开发的协议，使用 SSL&#x2F;TLS 隧道，安全性高，可以很好地穿透防火墙。主要在 Windows 环境下使用。</li>
<li><strong>IKEv2&#x2F;IPsec (Internet Key Exchange version 2 over IPsec)</strong>：由微软和思科合作开发，具有快速重连（MOBIKE 扩展）、抗丢包能力强、移动设备支持好等特点。安全性高，性能优异。</li>
</ul>
<h2 id="四、VPN-的类型"><a href="#四、VPN-的类型" class="headerlink" title="四、VPN 的类型"></a>四、VPN 的类型</h2><p>根据其连接方式和应用场景，VPN 主要分为以下几类：</p>
<h3 id="4-1-远程访问-VPN-Remote-Access-VPN-Client-to-Site-VPN"><a href="#4-1-远程访问-VPN-Remote-Access-VPN-Client-to-Site-VPN" class="headerlink" title="4.1 远程访问 VPN (Remote Access VPN &#x2F; Client-to-Site VPN)"></a>4.1 远程访问 VPN (Remote Access VPN &#x2F; Client-to-Site VPN)</h3><ul>
<li><strong>场景</strong>：单个用户（如远程员工、个人用户）通过公共网络连接到企业网络或 VPN 服务提供商的网络。</li>
<li><strong>方式</strong>：用户设备上安装 VPN 客户端软件，建立到 VPN 服务器的加密隧道。</li>
<li><strong>用途</strong>：远程办公、个人隐私保护、绕过地理限制。</li>
</ul>
<h3 id="4-2-站点到站点-VPN-Site-to-Site-VPN"><a href="#4-2-站点到站点-VPN-Site-to-Site-VPN" class="headerlink" title="4.2 站点到站点 VPN (Site-to-Site VPN)"></a>4.2 站点到站点 VPN (Site-to-Site VPN)</h3><ul>
<li><strong>场景</strong>：连接两个或多个地理位置分散的局域网 (LAN)，使其在逻辑上形成一个大的私有网络。</li>
<li><strong>方式</strong>：通常由路由器或防火墙等网络设备之间建立 VPN 隧道，对整个网络进行加密，而不是单个客户端。</li>
<li><strong>用途</strong>：连接企业分支机构、合作伙伴网络。</li>
</ul>
<h3 id="4-3-SSL-VPN-Web-based-VPN-Clientless-VPN"><a href="#4-3-SSL-VPN-Web-based-VPN-Clientless-VPN" class="headerlink" title="4.3 SSL VPN (Web-based VPN &#x2F; Clientless VPN)"></a>4.3 SSL VPN (Web-based VPN &#x2F; Clientless VPN)</h3><ul>
<li><strong>场景</strong>：用户通过普通的 Web 浏览器访问公司内网资源。</li>
<li><strong>方式</strong>：利用 SSL&#x2F;TLS 协议，无需安装专门的客户端软件（或只安装轻量级插件），通过浏览器即可建立加密连接。</li>
<li><strong>用途</strong>：提供对内部 Web 应用、文件共享等资源的便捷、安全的访问。</li>
</ul>
<h2 id="五、Python-编程概念示例：数据封装与解封装模拟"><a href="#五、Python-编程概念示例：数据封装与解封装模拟" class="headerlink" title="五、Python 编程概念示例：数据封装与解封装模拟"></a>五、Python 编程概念示例：数据封装与解封装模拟</h2><p>实际的 VPN 实现非常复杂，涉及到操作系统内核、网络驱动、各种加密算法和协议栈。下面的 Python 代码仅用于<strong>概念性地模拟</strong> VPN 中的数据<strong>封装 (Encapsulation)</strong> 和<strong>解封装 (Decapsulation)</strong>，以及简单的加密&#x2F;解密过程，并非实际可用的 VPN 客户端实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet <span class="comment"># 这是一个真实的Python加密库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 模拟加密和解密 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成一个用于演示的加密密钥&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Fernet.generate_key()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_data</span>(<span class="params">data: <span class="built_in">bytes</span>, key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 Fernet 对数据进行加密&quot;&quot;&quot;</span></span><br><span class="line">    f = Fernet(key)</span><br><span class="line">    <span class="keyword">return</span> f.encrypt(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_data</span>(<span class="params">encrypted_data: <span class="built_in">bytes</span>, key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 Fernet 对加密数据进行解密&quot;&quot;&quot;</span></span><br><span class="line">    f = Fernet(key)</span><br><span class="line">    <span class="keyword">return</span> f.decrypt(encrypted_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 模拟 VPN 隧道协议头和数据 ---</span></span><br><span class="line">VPN_HEADER_PREFIX = <span class="string">b&quot;VPN_TUNNEL_V1:&quot;</span></span><br><span class="line">VPN_FOOTER_SUFFIX = <span class="string">b&quot;:END_VPN&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encapsulate_data</span>(<span class="params">original_data: <span class="built_in">str</span>, encryption_key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟 VPN 客户端的封装过程：</span></span><br><span class="line"><span class="string">    1. 将原始数据编码为字节。</span></span><br><span class="line"><span class="string">    2. 加密字节数据。</span></span><br><span class="line"><span class="string">    3. 添加模拟的 VPN 协议头和尾。</span></span><br><span class="line"><span class="string">    4. 对最终数据进行 Base64 编码，使其在传输时更安全（例如通过非二进制友好的信道）。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    original_bytes = original_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    encrypted_bytes = encrypt_data(original_bytes, encryption_key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟添加 VPN 协议头和尾</span></span><br><span class="line">    tunneled_data = VPN_HEADER_PREFIX + encrypted_bytes + VPN_FOOTER_SUFFIX</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 进一步进行 Base64 编码，方便传输和表示</span></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(tunneled_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decapsulate_data</span>(<span class="params">tunneled_encoded_data: <span class="built_in">bytes</span>, encryption_key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟 VPN 服务器的解封装过程：</span></span><br><span class="line"><span class="string">    1. 对接收到的数据进行 Base64 解码。</span></span><br><span class="line"><span class="string">    2. 检查并移除模拟的 VPN 协议头和尾。</span></span><br><span class="line"><span class="string">    3. 解密数据。</span></span><br><span class="line"><span class="string">    4. 将解密后的字节解码为字符串。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        decoded_tunneled_data = base64.b64decode(tunneled_encoded_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查并移除 VPN 协议头和尾</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> decoded_tunneled_data.startswith(VPN_HEADER_PREFIX) <span class="keyword">or</span> \</span><br><span class="line">           <span class="keyword">not</span> decoded_tunneled_data.endswith(VPN_FOOTER_SUFFIX):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error: Invalid VPN tunnel format.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">      </span><br><span class="line">        encrypted_bytes = decoded_tunneled_data[<span class="built_in">len</span>(VPN_HEADER_PREFIX):-<span class="built_in">len</span>(VPN_FOOTER_SUFFIX)]</span><br><span class="line">      </span><br><span class="line">        decrypted_bytes = decrypt_data(encrypted_bytes, encryption_key)</span><br><span class="line">        <span class="keyword">return</span> decrypted_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error during decapsulation: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 模拟 VPN 通信流 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 概念性 VPN 通信模拟 ---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 客户端和服务器拥有共享密钥</span></span><br><span class="line">vpn_shared_key = generate_key()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;模拟共享加密密钥 (部分): <span class="subst">&#123;vpn_shared_key[:<span class="number">10</span>]&#125;</span>...&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 原始数据 (假设是一个 HTTP 请求)</span></span><br><span class="line">original_client_data = <span class="string">&quot;GET /secret_resource HTTP/1.1\r\nHost: internal.example.com\r\nUser-Agent: MyVPNClient\r\n\r\n&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n客户端原始数据: &#x27;<span class="subst">&#123;original_client_data.strip()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 客户端封装和加密数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 客户端处理 ---&quot;</span>)</span><br><span class="line">tunneled_data_for_transmission = encapsulate_data(original_client_data, vpn_shared_key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;封装并加密后的数据 (准备传输): <span class="subst">&#123;tunneled_data_for_transmission[:<span class="number">80</span>]&#125;</span>...&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据长度 (传输前): <span class="subst">&#123;<span class="built_in">len</span>(original_client_data)&#125;</span> bytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据长度 (传输后): <span class="subst">&#123;<span class="built_in">len</span>(tunneled_data_for_transmission)&#125;</span> bytes (通常会变长)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 数据通过公共网络传输...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. VPN 服务器接收并解封装数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 服务器处理 ---&quot;</span>)</span><br><span class="line">received_original_data = decapsulate_data(tunneled_data_for_transmission, vpn_shared_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> received_original_data:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;服务器解封装并解密后的数据: &#x27;<span class="subst">&#123;received_original_data.strip()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 通信成功：数据经过 VPN 隧道安全传输 ---&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 通信失败：数据未能正确解封装 ---&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、VPN-的优缺点"><a href="#六、VPN-的优缺点" class="headerlink" title="六、VPN 的优缺点"></a>六、VPN 的优缺点</h2><h3 id="6-1-优点："><a href="#6-1-优点：" class="headerlink" title="6.1 优点："></a>6.1 优点：</h3><ol>
<li><strong>提高安全性</strong>：加密所有通过 VPN 隧道传输的数据，防止数据被窃听、篡改。</li>
<li><strong>增强隐私性</strong>：隐藏用户的真实 IP 地址，防止 ISP、网站或第三方跟踪用户的在线活动。</li>
<li><strong>远程访问</strong>：允许用户安全地访问公司或个人局域网资源。</li>
<li><strong>绕过审查和地理限制</strong>：突破网络限制，访问全球内容。</li>
<li><strong>成本效益</strong>：利用公共互联网建立安全连接，避免昂贵的专线。</li>
</ol>
<h3 id="6-2-缺点与挑战："><a href="#6-2-缺点与挑战：" class="headerlink" title="6.2 缺点与挑战："></a>6.2 缺点与挑战：</h3><ol>
<li><strong>可能降低网速</strong>：加密、解密和隧道封装会增加数据处理开销，可能导致连接速度变慢和延迟增加。</li>
<li><strong>配置复杂性</strong>：部署和配置 VPN 解决方案（尤其是在企业环境中）可能比较复杂。</li>
<li><strong>可靠性问题</strong>：VPN 服务器的质量、带宽和位置都会影响连接的稳定性和速度。</li>
<li><strong>法律和管辖权</strong>：某些国家或地区对 VPN 的使用有限制甚至禁止。</li>
<li><strong>VPN 服务商信任</strong>：用户需要信任 VPN 服务提供商不会记录或滥用其数据。免费 VPN 服务可能存在隐私风险。</li>
<li><strong>电池消耗</strong>：移动设备上常驻的 VPN 连接可能会增加电池消耗。</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>VPN 是一项强大的网络技术，它通过在不安全的公共网络上创建安全的、加密的隧道，为用户提供了数据保密性、完整性、身份认证以及对远程网络的访问能力。从个人隐私保护到企业级的远程办公和分支机构互联，VPN 都扮演着不可或缺的角色。在选择和使用 VPN 时，用户应根据其特定的安全需求、性能要求和信任模型，选择合适的协议和可靠的服务提供商。随着网络安全威胁的不断演进，VPN 技术也在持续发展，以应对新的挑战。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/12f7819cde4d/">https://blog.tbf1211.xx.kg/12f7819cde4d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/294ecfb9f29c/" title="Vue3响应式原理深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Vue3响应式原理深度解析</div></div><div class="info-2"><div class="info-item-1"> Vue.js 的核心特性之一是其响应式系统 (Reactivity System)。在 Vue 3 中，响应式系统经历了重大革新，从 Vue 2 基于 Object.defineProperty 的实现全面升级为基于 JavaScript Proxy。这一转变解决了 Vue 2 中存在的诸多限制，如无法检测对象属性的添加&#x2F;删除、无法有效监听数组变动等，并为 Composition API (组合式 API) 提供了坚实的基础。深入理解 Vue 3 的响应式原理，对于编写高效、可维护的 Vue 应用至关重要。  核心思想：Vue 3 的响应式系统借助 Proxy 对象劫持数据对象的读取 (get) 和修改 (set) 操作，并在副作用函数 (Effect Function，如组件渲染函数、计算属性、侦听器) 执行时收集其依赖 (track)。当响应式数据发生变化时，系统会通知所有依赖于该数据的副作用函数重新执行 (trigger)，从而实现数据的自动更新到 UI。    一、响应式系统概述响应式系统是一个能够自动追踪数据变化并作出相应更新的机制。在 Vue 中，当数据变...</div></div></div></a><a class="pagination-related" href="/099de403ef3d/" title="Golang 缓冲Channel和无缓冲Channel的区别"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang 缓冲Channel和无缓冲Channel的区别</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言的并发编程模型中，Channel 是 Goroutine 之间通信和同步的核心机制。Channel 提供了一种安全、同步的方式来传递数据。根据其容量大小，Channel 可以分为两种类型：无缓冲 Channel (Unbuffered Channel) 和 缓冲 Channel (Buffered Channel)。理解这两种 Channel 的区别以及它们各自的适用场景，是编写高效、正确 Go 并发代码的关键。  核心思想：无缓冲 Channel 强调“同步”通信，发送方和接收方必须同时就绪。缓冲 Channel 则允许“异步”通信，发送方可以在接收方未就绪时发送数据，但容量有限。   一、Channel 简介在 Go 中，Channel 是类型化的管道，可以通过它们发送和接收特定类型的值。它遵循“通过通信共享内存，而不是通过共享内存来通信”的并发哲学。 声明 Channel 的基本语法： 12345// 声明一个传递 int 类型数据的无缓冲 Channelvar ch1 chan int// 声明一个传递 string 类型数据的缓冲 Channel，容量为...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/56d360e5bda1/" title="SNAT 与 DNAT 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">SNAT 与 DNAT 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：源网络地址转换 (SNAT - Source Network Address Translation) 和 目的网络地址转换 (DNAT - Destination Network Address Translation)。理解这两种机制对于网络设计、故障排查和安全性至关重要。  核心思想：  SNAT：解决“内部网络中主机如何安全地、共享地访问外部网络资源”的问题，修改出站数据包的源地址。 DNAT：解决“外部网络中主机如何安全地访问内部提供的服务”的问题，修改入站数据包的目的地址。     一、网络地址转换 (NAT) 概述NAT 技术最初是为了缓解 IPv4 地址枯竭问题而设计，它允许一个内部私有 IP 网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信。除了地址共享，NAT 也为内部网络提供了一层基本的安全隔...</div></div></div></a><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/f7642a181610/" title="CDN (内容分发网络) 服务详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">CDN (内容分发网络) 服务详解</div></div><div class="info-2"><div class="info-item-1"> CDN (Content Delivery Network)，即内容分发网络，是一种构建在现有网络基础之上的智能虚拟网络。它通过将站点内容发布到离用户最近的全球边缘节点，使用户在请求内容时，能够从距离自己最近的服务器获取数据，从而显著加速内容传输、减轻源站负载、提高用户体验和保障服务可用性。  核心思想：将内容缓存到离用户近的地方，让用户就近获取，缩短物理距离，从而缩短加载时间。   一、为什么需要 CDN？在没有 CDN 的情况下，用户访问网站的所有请求都会直接发送到源服务器。这存在几个问题：  访问速度慢：当用户与源服务器之间地理距离较远时，数据传输路径长，网络延迟高，导致页面加载缓慢，尤其是对于图片、视频等大文件。 网络拥堵：跨国或跨洲际网络传输容易受到骨干网带宽限制和拥堵的影响。 源站负载高：所有用户的请求都直接冲击源服务器，在高并发场景下可能导致源服务器过载、响应变慢甚至崩溃。 单点故障风险：源服务器一旦出现故障或遭受攻击，整个网站将无法访问。 安全性弱：源站直接暴露在公网，容易成为 DDoS 攻击的目标。  CDN 旨在解决上述问题，提供以下核心价值：  加速访问：...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a><a class="pagination-related" href="/b8edc2276249/" title="雪花算法 (Snowflake Algorithm) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-19</div><div class="info-item-2">雪花算法 (Snowflake Algorithm) 详解</div></div><div class="info-2"><div class="info-item-1"> 雪花算法 (Snowflake Algorithm) 是 Twitter 公司开源的一种分布式唯一 ID 生成算法。它旨在解决在分布式系统中生成全局唯一、递增（但非严格递增）且高性能 ID 的需求。其生成的 ID 是一个 64 位的整数，具有时间有序性，并且不依赖于数据库，易于扩展。  核心思想：将 64 位的 Long 型 ID 拆分为多个字段，分别存储时间戳、数据中心 ID、机器 ID 和序列号，通过位运算拼接以保证全局唯一性和大致的时间有序性。   一、为什么需要雪花算法？在分布式系统中，传统的单点自增 ID 方案面临巨大挑战：  唯一性问题：不同的数据库实例或服务节点可能生成相同的 ID。 性能瓶颈：为了保证唯一性，可能需要引入中心化的 ID 生成服务或数据库锁，成为系统瓶颈。 可用性问题：中心化服务一旦宕机，整个系统的 ID 生成将受影响。  虽然 UUID 能够保证全局唯一性，但它存在一些缺点：  存储和传输效率低：128 位，比 64 位 ID 更占用空间，索引性能较差。 无序性：UUID 是无序的，插入数据库时会导致 B+ 树索引频繁分裂和重建，影响数据库性能。...</div></div></div></a><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-03</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">545</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-VPN%EF%BC%9F"><span class="toc-text">一、为什么需要 VPN？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81VPN-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、VPN 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF-Tunneling"><span class="toc-text">2.1 隧道技术 (Tunneling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8A%A0%E5%AF%86-Encryption"><span class="toc-text">2.2 加密 (Encryption)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%AE%A4%E8%AF%81-Authentication"><span class="toc-text">2.3 认证 (Authentication)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-VPN-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">2.4 VPN 工作流示意图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BB%E6%B5%81-VPN-%E5%8D%8F%E8%AE%AE"><span class="toc-text">三、主流 VPN 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-PPTP-Point-to-Point-Tunneling-Protocol"><span class="toc-text">3.1 PPTP (Point-to-Point Tunneling Protocol)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-L2TP-IPsec-Layer-2-Tunneling-Protocol-over-IPsec"><span class="toc-text">3.2 L2TP&#x2F;IPsec (Layer 2 Tunneling Protocol over IPsec)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-OpenVPN"><span class="toc-text">3.3 OpenVPN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-WireGuard"><span class="toc-text">3.4 WireGuard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.5 其他协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81VPN-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">四、VPN 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-VPN-Remote-Access-VPN-Client-to-Site-VPN"><span class="toc-text">4.1 远程访问 VPN (Remote Access VPN &#x2F; Client-to-Site VPN)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AB%99%E7%82%B9%E5%88%B0%E7%AB%99%E7%82%B9-VPN-Site-to-Site-VPN"><span class="toc-text">4.2 站点到站点 VPN (Site-to-Site VPN)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-SSL-VPN-Web-based-VPN-Clientless-VPN"><span class="toc-text">4.3 SSL VPN (Web-based VPN &#x2F; Clientless VPN)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Python-%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%B0%81%E8%A3%85%E6%A8%A1%E6%8B%9F"><span class="toc-text">五、Python 编程概念示例：数据封装与解封装模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81VPN-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">六、VPN 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">6.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%BA%E7%82%B9%E4%B8%8E%E6%8C%91%E6%88%98%EF%BC%9A"><span class="toc-text">6.2 缺点与挑战：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-28.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>