<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>虚拟专用网络 (VPN) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虚拟专用网络 (VPN - Virtual Private Network) 是一种用于在公共网络（如互联网）上建立安全的、加密的连接的技术。它允许用户安全地访问远程网络，如同直接连接到该网络一样。VPN 通过隧道 (Tunneling)、加密 (Encryption) 和认证 (Authentication) 机制，确保数据在传输过程中的隐私性、完整性和安全性，是现代远程办公、保护在线隐私和访">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟专用网络 (VPN) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/12f7819cde4d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="虚拟专用网络 (VPN - Virtual Private Network) 是一种用于在公共网络（如互联网）上建立安全的、加密的连接的技术。它允许用户安全地访问远程网络，如同直接连接到该网络一样。VPN 通过隧道 (Tunneling)、加密 (Encryption) 和认证 (Authentication) 机制，确保数据在传输过程中的隐私性、完整性和安全性，是现代远程办公、保护在线隐私和访">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg">
<meta property="article:published_time" content="2024-08-08T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T07:40:52.294Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "虚拟专用网络 (VPN) 详解",
  "url": "https://blog.tbf1211.xx.kg/12f7819cde4d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg",
  "datePublished": "2024-08-08T22:24:00.000Z",
  "dateModified": "2026-02-01T07:40:52.294Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/12f7819cde4d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '虚拟专用网络 (VPN) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-26.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">虚拟专用网络 (VPN) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">虚拟专用网络 (VPN) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-08T22:24:00.000Z" title="发表于 2024-08-09 06:24:00">2024-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>虚拟专用网络 (VPN - Virtual Private Network)</strong> 是一种用于在公共网络（如互联网）上建立安全的、加密的连接的技术。它允许用户安全地访问远程网络，如同直接连接到该网络一样。VPN 通过<strong>隧道 (Tunneling)</strong>、<strong>加密 (Encryption)</strong> 和<strong>认证 (Authentication)</strong> 机制，确保数据在传输过程中的隐私性、完整性和安全性，是现代远程办公、保护在线隐私和访问受限内容的关键技术。</p>
</blockquote>
<div class="note info flat"><p>核心功能：在不安全的公共网络上构建安全的、加密的“隧道”，实现远程设备或网络的安全互联。</p>
</div>
<hr>
<h2 id="一、为什么需要-VPN？"><a href="#一、为什么需要-VPN？" class="headerlink" title="一、为什么需要 VPN？"></a>一、为什么需要 VPN？</h2><p>在日益开放和互联的网络环境中，VPN 解决了许多核心的网络通信挑战：</p>
<ol>
<li><strong>数据安全与隐私保护</strong>：<ul>
<li>在 Wi-Fi 热点等公共网络中，数据未经加密传输容易被窃听或篡改。VPN 对所有流量进行加密，保护用户隐私。</li>
<li>防止互联网服务提供商 (ISP) 监控用户的在线活动。</li>
<li>避免政府或第三方机构对网络流量的审查和监控。</li>
</ul>
</li>
<li><strong>远程安全访问企业资源</strong>：<ul>
<li>员工在家中或出差时，需要安全、便捷地访问公司内部网络资源（文件服务器、内部应用等）。VPN 提供了远程用户到公司网络的加密通道。</li>
</ul>
</li>
<li><strong>绕过地理限制与审查</strong>：<ul>
<li>某些在线服务或内容可能因地理位置限制而无法访问。VPN 可以模拟用户从其他国家&#x2F;地区访问，绕过这些限制。</li>
<li>在互联网内容受到审查或限制的地区，VPN 可以帮助用户访问被封锁的信息。</li>
</ul>
</li>
<li><strong>匿名性</strong>：<ul>
<li>VPN 可以隐藏用户的真实 IP 地址，使其在网络上的活动更具匿名性，提高在线隐私。</li>
</ul>
</li>
</ol>
<h2 id="二、VPN-的工作原理"><a href="#二、VPN-的工作原理" class="headerlink" title="二、VPN 的工作原理"></a>二、VPN 的工作原理</h2><p>VPN 的核心在于在不安全的公共网络上构建一个<strong>安全的逻辑连接</strong>，这个连接通常被称为“隧道”。</p>
<h3 id="2-1-隧道技术-Tunneling"><a href="#2-1-隧道技术-Tunneling" class="headerlink" title="2.1 隧道技术 (Tunneling)"></a>2.1 隧道技术 (Tunneling)</h3><ul>
<li><strong>定义</strong>：隧道技术是在一个协议（传输协议）中封装另一个协议（负载协议）数据包的过程。VPN 在公共网络上建立一个虚拟的专用通道，所有通过 VPN 连接传输的数据都会被封装在这个“隧道”中。</li>
<li><strong>过程</strong>：<ol>
<li>VPN 客户端首先与 VPN 服务器建立连接。</li>
<li>客户端要发送的数据包（原始数据包）首先由 VPN 客户端软件接收。</li>
<li>VPN 客户端将这些原始数据包进行封装，添加新的 VPN 协议头（例如 PPTP、L2TP、OpenVPN 等），并在封装前进行加密。</li>
<li>封装后的数据包通过公共网络发送到 VPN 服务器。</li>
<li>VPN 服务器接收到封装并加密的数据包后，会对其进行解密和解封装，还原出原始数据包。</li>
<li>VPN 服务器将解封装后的原始数据包转发到目标网络或互联网。</li>
<li>反向流量也以相同的方式进行封装和传输。</li>
</ol>
</li>
</ul>
<h3 id="2-2-加密-Encryption"><a href="#2-2-加密-Encryption" class="headerlink" title="2.2 加密 (Encryption)"></a>2.2 加密 (Encryption)</h3><ul>
<li><strong>定义</strong>：加密是对数据进行编码的过程，只有拥有正确密钥的人才能将其解码。VPN 对通过隧道传输的所有数据进行加密，以防止窃听者读取数据。</li>
<li><strong>常用加密算法</strong>：AES (Advanced Encryption Standard)、3DES (Triple DES) 等。加密强度通常以密钥长度表示（如 AES-256）。</li>
<li><strong>作用</strong>：即使数据包在传输过程中被截获，也无法被解密和理解，从而保护了通信内容的隐私。</li>
</ul>
<h3 id="2-3-认证-Authentication"><a href="#2-3-认证-Authentication" class="headerlink" title="2.3 认证 (Authentication)"></a>2.3 认证 (Authentication)</h3><ul>
<li><strong>定义</strong>：认证是验证用户或设备身份的过程，确保只有授权的用户才能访问 VPN 网络。</li>
<li><strong>常用认证方式</strong>：<ul>
<li><strong>用户名&#x2F;密码</strong>：最常见的认证方式。</li>
<li><strong>数字证书</strong>：通过颁发和验证数字证书来确认客户端和服务器的身份，提供更强的安全性。</li>
<li><strong>预共享密钥 (PSK)</strong>：在建立连接前，客户端和服务器共享一个密钥。</li>
<li><strong>一次性密码 (OTP)</strong>、<strong>双因素认证 (2FA)</strong> 等。</li>
</ul>
</li>
<li><strong>作用</strong>：防止未经授权的用户连接到 VPN 服务器或伪造 VPN 服务器。</li>
</ul>
<h3 id="2-4-VPN-工作流示意图"><a href="#2-4-VPN-工作流示意图" class="headerlink" title="2.4 VPN 工作流示意图"></a>2.4 VPN 工作流示意图</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[用户设备 - VPN客户端] --&gt;|原始数据| B(VPN软件 封装 &amp; 加密)
    B --&gt;|&quot;VPN数据包 (加密 &amp; 封装)&quot;| C{公共网络&#x2F;互联网}
    C --&gt;|&quot;VPN数据包 (加密 &amp; 封装)&quot;| D[VPN服务器 解密 &amp; 解封装]
    D --&gt;|原始数据| E[目标网络&#x2F;互联网]
    E --&gt;|目标响应数据| F[目标网络&#x2F;互联网]
    F --&gt;|原始响应数据| D
    D --&gt;|&quot;VPN响应数据包 (加密 &amp; 封装)&quot;| C
    C --&gt;|&quot;VPN响应数据包 (加密 &amp; 封装)&quot;| B
    B --&gt;|原始响应数据| A
  
    subgraph VPN Client Side
        A
        B
    end

    subgraph &quot;Internet (Insecure)&quot;
        C
    end

    subgraph VPN Server Side
        D
    end

    subgraph Destination
        E
        F
    end
  </pre></div>

<h2 id="三、主流-VPN-协议"><a href="#三、主流-VPN-协议" class="headerlink" title="三、主流 VPN 协议"></a>三、主流 VPN 协议</h2><p>不同的 VPN 协议在安全性、速度、兼容性和易用性方面各有侧重。</p>
<h3 id="3-1-PPTP-Point-to-Point-Tunneling-Protocol"><a href="#3-1-PPTP-Point-to-Point-Tunneling-Protocol" class="headerlink" title="3.1 PPTP (Point-to-Point Tunneling Protocol)"></a>3.1 PPTP (Point-to-Point Tunneling Protocol)</h3><ul>
<li><strong>特点</strong>：历史悠久，兼容性好，几乎所有操作系统都内置支持。速度较快，但<strong>安全性差</strong>，易受攻击。</li>
<li><strong>加密&#x2F;认证</strong>：依赖 MPPE 对数据进行加密，MS-CHAPv2 进行认证。</li>
<li><strong>现状</strong>：由于存在严重安全漏洞，<strong>已不推荐使用</strong>，尤其是在需要高安全性的场景。</li>
</ul>
<h3 id="3-2-L2TP-IPsec-Layer-2-Tunneling-Protocol-over-IPsec"><a href="#3-2-L2TP-IPsec-Layer-2-Tunneling-Protocol-over-IPsec" class="headerlink" title="3.2 L2TP&#x2F;IPsec (Layer 2 Tunneling Protocol over IPsec)"></a>3.2 L2TP&#x2F;IPsec (Layer 2 Tunneling Protocol over IPsec)</h3><ul>
<li><strong>特点</strong>：L2TP 提供隧道，但本身不加密，依靠 IPsec (Internet Protocol Security) 协议套件来提供数据加密、认证和完整性保护。广泛支持，安全性较好。</li>
<li><strong>加密&#x2F;认证</strong>：IPsec 提供了强大的加密（如 AES）和认证（如预共享密钥、数字证书）。</li>
<li><strong>缺点</strong>：相比 OpenVPN，通常速度稍慢，且可能在 NAT 环境下遇到穿透问题 (NAT traversal)。实现较复杂。</li>
</ul>
<h3 id="3-3-OpenVPN"><a href="#3-3-OpenVPN" class="headerlink" title="3.3 OpenVPN"></a>3.3 OpenVPN</h3><ul>
<li><strong>特点</strong>：开源、高度可配置、安全性极高、灵活、跨平台支持良好。使用 SSL&#x2F;TLS 协议栈进行密钥交换和数据加密。</li>
<li><strong>加密&#x2F;认证</strong>：支持多种加密算法（如 AES-256）和强大的认证方式（用户名&#x2F;密码、数字证书）。</li>
<li><strong>优势</strong>：能够很好地穿透防火墙和 NAT 设备，是目前最受欢迎和推荐的 VPN 协议之一。</li>
<li><strong>缺点</strong>：可能需要第三方客户端软件，配置相对复杂。</li>
</ul>
<h3 id="3-4-WireGuard"><a href="#3-4-WireGuard" class="headerlink" title="3.4 WireGuard"></a>3.4 WireGuard</h3><ul>
<li><strong>特点</strong>：相对较新，设计目标是简洁、高性能和高安全性。代码量小（约 4000 行），更易于审计。</li>
<li><strong>加密&#x2F;认证</strong>：使用现代密码学算法（如 ChaCha20 for encryption, Poly1305 for authentication），基于密钥对而非证书。</li>
<li><strong>优势</strong>：速度极快，连接建立迅速，低延迟，资源消耗少。内置于 Linux 内核。</li>
<li><strong>缺点</strong>：较新，生态系统正在完善中。部分高级功能（如流量混淆）可能不如 OpenVPN 丰富。</li>
</ul>
<h3 id="3-5-其他协议"><a href="#3-5-其他协议" class="headerlink" title="3.5 其他协议"></a>3.5 其他协议</h3><ul>
<li><strong>SSTP (Secure Socket Tunneling Protocol)</strong>：微软开发的协议，使用 SSL&#x2F;TLS 隧道，安全性高，可以很好地穿透防火墙。主要在 Windows 环境下使用。</li>
<li><strong>IKEv2&#x2F;IPsec (Internet Key Exchange version 2 over IPsec)</strong>：由微软和思科合作开发，具有快速重连（MOBIKE 扩展）、抗丢包能力强、移动设备支持好等特点。安全性高，性能优异。</li>
</ul>
<h2 id="四、VPN-的类型"><a href="#四、VPN-的类型" class="headerlink" title="四、VPN 的类型"></a>四、VPN 的类型</h2><p>根据其连接方式和应用场景，VPN 主要分为以下几类：</p>
<h3 id="4-1-远程访问-VPN-Remote-Access-VPN-Client-to-Site-VPN"><a href="#4-1-远程访问-VPN-Remote-Access-VPN-Client-to-Site-VPN" class="headerlink" title="4.1 远程访问 VPN (Remote Access VPN &#x2F; Client-to-Site VPN)"></a>4.1 远程访问 VPN (Remote Access VPN &#x2F; Client-to-Site VPN)</h3><ul>
<li><strong>场景</strong>：单个用户（如远程员工、个人用户）通过公共网络连接到企业网络或 VPN 服务提供商的网络。</li>
<li><strong>方式</strong>：用户设备上安装 VPN 客户端软件，建立到 VPN 服务器的加密隧道。</li>
<li><strong>用途</strong>：远程办公、个人隐私保护、绕过地理限制。</li>
</ul>
<h3 id="4-2-站点到站点-VPN-Site-to-Site-VPN"><a href="#4-2-站点到站点-VPN-Site-to-Site-VPN" class="headerlink" title="4.2 站点到站点 VPN (Site-to-Site VPN)"></a>4.2 站点到站点 VPN (Site-to-Site VPN)</h3><ul>
<li><strong>场景</strong>：连接两个或多个地理位置分散的局域网 (LAN)，使其在逻辑上形成一个大的私有网络。</li>
<li><strong>方式</strong>：通常由路由器或防火墙等网络设备之间建立 VPN 隧道，对整个网络进行加密，而不是单个客户端。</li>
<li><strong>用途</strong>：连接企业分支机构、合作伙伴网络。</li>
</ul>
<h3 id="4-3-SSL-VPN-Web-based-VPN-Clientless-VPN"><a href="#4-3-SSL-VPN-Web-based-VPN-Clientless-VPN" class="headerlink" title="4.3 SSL VPN (Web-based VPN &#x2F; Clientless VPN)"></a>4.3 SSL VPN (Web-based VPN &#x2F; Clientless VPN)</h3><ul>
<li><strong>场景</strong>：用户通过普通的 Web 浏览器访问公司内网资源。</li>
<li><strong>方式</strong>：利用 SSL&#x2F;TLS 协议，无需安装专门的客户端软件（或只安装轻量级插件），通过浏览器即可建立加密连接。</li>
<li><strong>用途</strong>：提供对内部 Web 应用、文件共享等资源的便捷、安全的访问。</li>
</ul>
<h2 id="五、Python-编程概念示例：数据封装与解封装模拟"><a href="#五、Python-编程概念示例：数据封装与解封装模拟" class="headerlink" title="五、Python 编程概念示例：数据封装与解封装模拟"></a>五、Python 编程概念示例：数据封装与解封装模拟</h2><p>实际的 VPN 实现非常复杂，涉及到操作系统内核、网络驱动、各种加密算法和协议栈。下面的 Python 代码仅用于<strong>概念性地模拟</strong> VPN 中的数据<strong>封装 (Encapsulation)</strong> 和<strong>解封装 (Decapsulation)</strong>，以及简单的加密&#x2F;解密过程，并非实际可用的 VPN 客户端实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet <span class="comment"># 这是一个真实的Python加密库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 模拟加密和解密 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成一个用于演示的加密密钥&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Fernet.generate_key()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_data</span>(<span class="params">data: <span class="built_in">bytes</span>, key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 Fernet 对数据进行加密&quot;&quot;&quot;</span></span><br><span class="line">    f = Fernet(key)</span><br><span class="line">    <span class="keyword">return</span> f.encrypt(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_data</span>(<span class="params">encrypted_data: <span class="built_in">bytes</span>, key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 Fernet 对加密数据进行解密&quot;&quot;&quot;</span></span><br><span class="line">    f = Fernet(key)</span><br><span class="line">    <span class="keyword">return</span> f.decrypt(encrypted_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 模拟 VPN 隧道协议头和数据 ---</span></span><br><span class="line">VPN_HEADER_PREFIX = <span class="string">b&quot;VPN_TUNNEL_V1:&quot;</span></span><br><span class="line">VPN_FOOTER_SUFFIX = <span class="string">b&quot;:END_VPN&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encapsulate_data</span>(<span class="params">original_data: <span class="built_in">str</span>, encryption_key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟 VPN 客户端的封装过程：</span></span><br><span class="line"><span class="string">    1. 将原始数据编码为字节。</span></span><br><span class="line"><span class="string">    2. 加密字节数据。</span></span><br><span class="line"><span class="string">    3. 添加模拟的 VPN 协议头和尾。</span></span><br><span class="line"><span class="string">    4. 对最终数据进行 Base64 编码，使其在传输时更安全（例如通过非二进制友好的信道）。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    original_bytes = original_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    encrypted_bytes = encrypt_data(original_bytes, encryption_key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟添加 VPN 协议头和尾</span></span><br><span class="line">    tunneled_data = VPN_HEADER_PREFIX + encrypted_bytes + VPN_FOOTER_SUFFIX</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 进一步进行 Base64 编码，方便传输和表示</span></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(tunneled_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decapsulate_data</span>(<span class="params">tunneled_encoded_data: <span class="built_in">bytes</span>, encryption_key: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟 VPN 服务器的解封装过程：</span></span><br><span class="line"><span class="string">    1. 对接收到的数据进行 Base64 解码。</span></span><br><span class="line"><span class="string">    2. 检查并移除模拟的 VPN 协议头和尾。</span></span><br><span class="line"><span class="string">    3. 解密数据。</span></span><br><span class="line"><span class="string">    4. 将解密后的字节解码为字符串。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        decoded_tunneled_data = base64.b64decode(tunneled_encoded_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查并移除 VPN 协议头和尾</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> decoded_tunneled_data.startswith(VPN_HEADER_PREFIX) <span class="keyword">or</span> \</span><br><span class="line">           <span class="keyword">not</span> decoded_tunneled_data.endswith(VPN_FOOTER_SUFFIX):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error: Invalid VPN tunnel format.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">      </span><br><span class="line">        encrypted_bytes = decoded_tunneled_data[<span class="built_in">len</span>(VPN_HEADER_PREFIX):-<span class="built_in">len</span>(VPN_FOOTER_SUFFIX)]</span><br><span class="line">      </span><br><span class="line">        decrypted_bytes = decrypt_data(encrypted_bytes, encryption_key)</span><br><span class="line">        <span class="keyword">return</span> decrypted_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error during decapsulation: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 模拟 VPN 通信流 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 概念性 VPN 通信模拟 ---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 客户端和服务器拥有共享密钥</span></span><br><span class="line">vpn_shared_key = generate_key()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;模拟共享加密密钥 (部分): <span class="subst">&#123;vpn_shared_key[:<span class="number">10</span>]&#125;</span>...&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 原始数据 (假设是一个 HTTP 请求)</span></span><br><span class="line">original_client_data = <span class="string">&quot;GET /secret_resource HTTP/1.1\r\nHost: internal.example.com\r\nUser-Agent: MyVPNClient\r\n\r\n&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n客户端原始数据: &#x27;<span class="subst">&#123;original_client_data.strip()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 客户端封装和加密数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 客户端处理 ---&quot;</span>)</span><br><span class="line">tunneled_data_for_transmission = encapsulate_data(original_client_data, vpn_shared_key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;封装并加密后的数据 (准备传输): <span class="subst">&#123;tunneled_data_for_transmission[:<span class="number">80</span>]&#125;</span>...&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据长度 (传输前): <span class="subst">&#123;<span class="built_in">len</span>(original_client_data)&#125;</span> bytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数据长度 (传输后): <span class="subst">&#123;<span class="built_in">len</span>(tunneled_data_for_transmission)&#125;</span> bytes (通常会变长)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 数据通过公共网络传输...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. VPN 服务器接收并解封装数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 服务器处理 ---&quot;</span>)</span><br><span class="line">received_original_data = decapsulate_data(tunneled_data_for_transmission, vpn_shared_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> received_original_data:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;服务器解封装并解密后的数据: &#x27;<span class="subst">&#123;received_original_data.strip()&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 通信成功：数据经过 VPN 隧道安全传输 ---&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 通信失败：数据未能正确解封装 ---&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、VPN-的优缺点"><a href="#六、VPN-的优缺点" class="headerlink" title="六、VPN 的优缺点"></a>六、VPN 的优缺点</h2><h3 id="6-1-优点："><a href="#6-1-优点：" class="headerlink" title="6.1 优点："></a>6.1 优点：</h3><ol>
<li><strong>提高安全性</strong>：加密所有通过 VPN 隧道传输的数据，防止数据被窃听、篡改。</li>
<li><strong>增强隐私性</strong>：隐藏用户的真实 IP 地址，防止 ISP、网站或第三方跟踪用户的在线活动。</li>
<li><strong>远程访问</strong>：允许用户安全地访问公司或个人局域网资源。</li>
<li><strong>绕过审查和地理限制</strong>：突破网络限制，访问全球内容。</li>
<li><strong>成本效益</strong>：利用公共互联网建立安全连接，避免昂贵的专线。</li>
</ol>
<h3 id="6-2-缺点与挑战："><a href="#6-2-缺点与挑战：" class="headerlink" title="6.2 缺点与挑战："></a>6.2 缺点与挑战：</h3><ol>
<li><strong>可能降低网速</strong>：加密、解密和隧道封装会增加数据处理开销，可能导致连接速度变慢和延迟增加。</li>
<li><strong>配置复杂性</strong>：部署和配置 VPN 解决方案（尤其是在企业环境中）可能比较复杂。</li>
<li><strong>可靠性问题</strong>：VPN 服务器的质量、带宽和位置都会影响连接的稳定性和速度。</li>
<li><strong>法律和管辖权</strong>：某些国家或地区对 VPN 的使用有限制甚至禁止。</li>
<li><strong>VPN 服务商信任</strong>：用户需要信任 VPN 服务提供商不会记录或滥用其数据。免费 VPN 服务可能存在隐私风险。</li>
<li><strong>电池消耗</strong>：移动设备上常驻的 VPN 连接可能会增加电池消耗。</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>VPN 是一项强大的网络技术，它通过在不安全的公共网络上创建安全的、加密的隧道，为用户提供了数据保密性、完整性、身份认证以及对远程网络的访问能力。从个人隐私保护到企业级的远程办公和分支机构互联，VPN 都扮演着不可或缺的角色。在选择和使用 VPN 时，用户应根据其特定的安全需求、性能要求和信任模型，选择合适的协议和可靠的服务提供商。随着网络安全威胁的不断演进，VPN 技术也在持续发展，以应对新的挑战。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/12f7819cde4d/">https://blog.tbf1211.xx.kg/12f7819cde4d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-26.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/294ecfb9f29c/" title="Vue3响应式原理深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Vue3响应式原理深度解析</div></div><div class="info-2"><div class="info-item-1"> Vue.js 的核心特性之一是其响应式系统 (Reactivity System)。在 Vue 3 中，响应式系统经历了重大革新，从 Vue 2 基于 Object.defineProperty 的实现全面升级为基于 JavaScript Proxy。这一转变解决了 Vue 2 中存在的诸多限制，如无法检测对象属性的添加&#x2F;删除、无法有效监听数组变动等，并为 Composition API (组合式 API) 提供了坚实的基础。深入理解 Vue 3 的响应式原理，对于编写高效、可维护的 Vue 应用至关重要。  核心思想：Vue 3 的响应式系统借助 Proxy 对象劫持数据对象的读取 (get) 和修改 (set) 操作，并在副作用函数 (Effect Function，如组件渲染函数、计算属性、侦听器) 执行时收集其依赖 (track)。当响应式数据发生变化时，系统会通知所有依赖于该数据的副作用函数重新执行 (trigger)，从而实现数据的自动更新到 UI。    一、响应式系统概述响应式系统是一个能够自动追踪数据变化并作出相应更新的机制。在 Vue 中，当数据变...</div></div></div></a><a class="pagination-related" href="/099de403ef3d/" title="Golang 缓冲Channel和无缓冲Channel的区别"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang 缓冲Channel和无缓冲Channel的区别</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言的并发编程模型中，Channel 是 Goroutine 之间通信和同步的核心机制。Channel 提供了一种安全、同步的方式来传递数据。根据其容量大小，Channel 可以分为两种类型：无缓冲 Channel (Unbuffered Channel) 和 缓冲 Channel (Buffered Channel)。理解这两种 Channel 的区别以及它们各自的适用场景，是编写高效、正确 Go 并发代码的关键。  核心思想：无缓冲 Channel 强调“同步”通信，发送方和接收方必须同时就绪。缓冲 Channel 则允许“异步”通信，发送方可以在接收方未就绪时发送数据，但容量有限。   一、Channel 简介在 Go 中，Channel 是类型化的管道，可以通过它们发送和接收特定类型的值。它遵循“通过通信共享内存，而不是通过共享内存来通信”的并发哲学。 声明 Channel 的基本语法： 12345// 声明一个传递 int 类型数据的无缓冲 Channelvar ch1 chan int// 声明一个传递 string 类型数据的缓冲 Channel，容量为...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/19a6c2b992d7/" title="IPv6 (Internet Protocol Version 6) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">IPv6 (Internet Protocol Version 6) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv6 (Internet Protocol Version 6) 是互联网协议 (IP) 的最新版本，旨在取代其前身 IPv4。它解决了 IPv4 长期存在的地址枯竭问题，并引入了多项设计改进，以更好地适应现代互联网的需求，包括支持更简单的头部处理、增强的安全性、更好的服务质量 (QoS) 和更强大的移动性功能。  核心思想：从根本上解决 IPv4 地址短缺问题，同时优化协议设计，为万物互联 (IoT)、5G 和未来网络应用提供坚实基础。    一、为什么需要 IPv6？IPv4 (Internet Protocol Version 4) 作为互联网的核心协议已成功运行数十年，但随着互联网的爆炸式增长，其固有的设计局限性日益凸显：  地址枯竭 (Address Exhaustion)：IPv4 地址空间为 32 位，最多有约 43 亿个地址。尽管采取了无类别域间路由 (CIDR) 和网络地址转换 (NAT) 等技术来延缓地址枯竭，但根源问题并未解决。全球各区域的 IPv4 地址池已基本分配完毕，成为互联网进一步发展的瓶颈。 NAT 的复杂性与限制：网络地址转换 (NAT) ...</div></div></div></a><a class="pagination-related" href="/62ea6394243a/" title="RPC(Remote Procedure Call)远程过程调用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">RPC(Remote Procedure Call)远程过程调用详解</div></div><div class="info-2"><div class="info-item-1"> RPC (Remote Procedure Call)，即远程过程调用，是一种分布式计算技术，它允许程序调用位于不同地址空间（通常是不同计算机上）的子程序或函数，就像调用本地子程序一样。RPC 屏蔽了底层网络通信的复杂性，让开发者可以专注于业务逻辑，提高开发效率。  核心思想： RPC 的目标是透明化 (Transparency) 远程服务的调用过程，让客户端感觉就像在调用本地方法，而实际上调用的请求被序列化并通过网络传输到远程服务，远程服务执行后将结果序列化并返回给客户端。   一、为什么需要 RPC？在传统的单体应用中，所有功能都运行在同一个进程中，方法调用直接发生在内存中。然而，随着业务复杂性和系统规模的增长，单体应用面临诸多挑战：  扩展性差：难以针对不同模块的负载压力独立扩展。 开发效率低：团队协作困难，代码冲突多。 容错性差：单个模块故障可能导致整个系统崩溃。 技术栈限制：难以在不同模块中使用最佳技术栈。  为了解决这些问题，系统架构逐渐向分布式系统和微服务架构演进。在这种架构中，一个大型应用被拆分成多个独立的服务，每个服务运行在不同的进程中，甚至不同的物理机器上。...</div></div></div></a><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/c70453d6b6cb/" title="CIDR和子网掩码详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-28</div><div class="info-item-2">CIDR和子网掩码详解</div></div><div class="info-2"><div class="info-item-1"> CIDR (Classless Inter-Domain Routing，无类别域间路由) 和子网掩码 (Subnet Mask) 是 IP 地址管理和路由技术中的两个核心概念。它们共同解决了传统 IP 地址分类的局限性，实现了更高效的 IP 地址分配和更灵活的网络划分。理解这两个概念对于构建和管理现代 IP 网络至关重要。  核心思想：CIDR 使用“IP 地址&#x2F;前缀长度”的格式，通过前缀长度直接表示网络部分和主机部分，从而废除了传统的 A&#x2F;B&#x2F;C 类地址概念。子网掩码则是这种前缀长度的二进制表示，用于在 IP 地址中区分网络地址和主机地址。   一、IP 地址基础回顾在深入 CIDR 和子网掩码之前，我们先快速回顾一下 IP 地址的基础知识：  IP 地址 (IPv4)：一个 32 位的二进制数字，通常表示为四个十进制数（0-255）由点分隔的形式，例如 192.168.1.1。 网络地址 (Network Address)：用于标识一个 IP 子网，所有在该子网内的主机都共享相同的网络地址。 主机地址 (Host Address)：用于标识子...</div></div></div></a><a class="pagination-related" href="/45a8b220c3e8/" title="中国移动 CMI 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-18</div><div class="info-item-2">中国移动 CMI 网络详解</div></div><div class="info-2"><div class="info-item-1"> CMI (China Mobile International)，即中国移动国际网络，是中国移动的国际出口骨干网络。与中国电信的 CN2 和中国联通的 AS4837&#x2F;AS9929 类似，CMI 专注于提供中国移动用户的高质量国际互联服务。它随着中国移动国际业务的扩张而迅速发展，成为连接中国大陆与全球各地的重要网络基础设施之一。  核心思想：CMI 是中国移动为提升其用户国际访问体验而建立的国际骨干网络。它通过建设自有海缆和海外节点，提供相对稳定、大带宽的国际互联通道。   一、为什么需要 CMI？1.1 中国移动网络的挑战在早期的国际互联方面，中国移动（China Mobile）主要依靠租用其他运营商的国际出口带宽，或者将流量转接到中国电信或中国联通的网络进行国际互联。这种方式存在一些固有的问题：  网络质量不稳定：路由路径通常较长，经过的中间运营商和节点多，导致延迟高、丢包率大。 带宽不足：租用带宽的成本和可用性限制，使得在国际流量高峰期容易出现拥堵。 服务不可控：缺乏对国际链路的端到端控制，难以保证服务质量 (QoS)。 成本高昂：长期租用国际带宽的成本较高。  ...</div></div></div></a><a class="pagination-related" href="/dec2dcdddd31/" title="单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-14</div><div class="info-item-2">单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解</div></div><div class="info-2"><div class="info-item-1"> 在计算机网络中，数据包从一个源发送到多个目的地的策略被称为通信模式。理解这些模式——单播 (Unicast)、组播 (Multicast)、广播 (Broadcast) 和任播 (Anycast)——对于网络设计、数据传输优化以及故障排除至关重要。它们定义了数据如何寻址和如何在网络中传播，各自适用于不同的应用场景，并对网络性能和资源消耗有着显著影响。  核心思想：根据数据包的目的地数量和选择策略，将网络通信划分为四种基本模式，每种模式都有其独特的传输效率、资源利用和应用场景。   一、传输模式概述   传输模式 描述 接收方数量 IP 地址类型 传输效率 主要应用    单播 一对一传输。最常见的模式。 1 普通 IP 地址 高 (点对点) HTTP, TCP, Telnet, SSH, FTP   广播 一对所有传输，限于同一广播域内。 所有 广播地址 (255.255.255.255) 低 (网络泛洪) ARP, DHCP, OLPC, 唤醒局域网   组播 一对多传输，发送给特定组中的成员。 多个 组播地址 (224.0.0.0/4) 高 (路由支持) 视频直播, 在线游...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-VPN%EF%BC%9F"><span class="toc-text">一、为什么需要 VPN？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81VPN-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、VPN 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF-Tunneling"><span class="toc-text">2.1 隧道技术 (Tunneling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8A%A0%E5%AF%86-Encryption"><span class="toc-text">2.2 加密 (Encryption)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%AE%A4%E8%AF%81-Authentication"><span class="toc-text">2.3 认证 (Authentication)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-VPN-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">2.4 VPN 工作流示意图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BB%E6%B5%81-VPN-%E5%8D%8F%E8%AE%AE"><span class="toc-text">三、主流 VPN 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-PPTP-Point-to-Point-Tunneling-Protocol"><span class="toc-text">3.1 PPTP (Point-to-Point Tunneling Protocol)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-L2TP-IPsec-Layer-2-Tunneling-Protocol-over-IPsec"><span class="toc-text">3.2 L2TP&#x2F;IPsec (Layer 2 Tunneling Protocol over IPsec)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-OpenVPN"><span class="toc-text">3.3 OpenVPN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-WireGuard"><span class="toc-text">3.4 WireGuard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.5 其他协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81VPN-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">四、VPN 的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-VPN-Remote-Access-VPN-Client-to-Site-VPN"><span class="toc-text">4.1 远程访问 VPN (Remote Access VPN &#x2F; Client-to-Site VPN)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AB%99%E7%82%B9%E5%88%B0%E7%AB%99%E7%82%B9-VPN-Site-to-Site-VPN"><span class="toc-text">4.2 站点到站点 VPN (Site-to-Site VPN)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-SSL-VPN-Web-based-VPN-Clientless-VPN"><span class="toc-text">4.3 SSL VPN (Web-based VPN &#x2F; Clientless VPN)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Python-%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%B0%81%E8%A3%85%E6%A8%A1%E6%8B%9F"><span class="toc-text">五、Python 编程概念示例：数据封装与解封装模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81VPN-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">六、VPN 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">6.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%BA%E7%82%B9%E4%B8%8E%E6%8C%91%E6%88%98%EF%BC%9A"><span class="toc-text">6.2 缺点与挑战：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-26.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>