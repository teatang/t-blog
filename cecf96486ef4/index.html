<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IPC (Inter-Process Communication) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IPC (Inter-Process Communication)，即进程间通信，是指在多任务操作系统中，不同进程之间进行数据交换和同步行为的一种机制。由于每个进程通常拥有独立的内存空间，不能直接访问其他进程的数据，因此 IPC 机制是构建复杂、协作型多进程应用的关键。它使得进程能够共享信息、协调活动，从而实现更强大的功能和更高的系统效率。  核心思想：克服进程间内存隔离的障碍，提供一套规范化的">
<meta property="og:type" content="article">
<meta property="og:title" content="IPC (Inter-Process Communication) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/cecf96486ef4/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="IPC (Inter-Process Communication)，即进程间通信，是指在多任务操作系统中，不同进程之间进行数据交换和同步行为的一种机制。由于每个进程通常拥有独立的内存空间，不能直接访问其他进程的数据，因此 IPC 机制是构建复杂、协作型多进程应用的关键。它使得进程能够共享信息、协调活动，从而实现更强大的功能和更高的系统效率。  核心思想：克服进程间内存隔离的障碍，提供一套规范化的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg">
<meta property="article:published_time" content="2026-01-04T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-17T08:09:09.124Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="异步编程">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="编程技巧">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "IPC (Inter-Process Communication) 详解",
  "url": "https://blog.tbf1211.xx.kg/cecf96486ef4/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg",
  "datePublished": "2026-01-04T22:24:00.000Z",
  "dateModified": "2026-01-17T08:09:09.124Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/cecf96486ef4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IPC (Inter-Process Communication) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-32.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">IPC (Inter-Process Communication) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">IPC (Inter-Process Communication) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>IPC (Inter-Process Communication)</strong>，即<strong>进程间通信</strong>，是指在多任务操作系统中，不同进程之间进行数据交换和同步行为的一种机制。由于每个进程通常拥有独立的内存空间，不能直接访问其他进程的数据，因此 IPC 机制是构建复杂、协作型多进程应用的关键。它使得进程能够共享信息、协调活动，从而实现更强大的功能和更高的系统效率。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>克服进程间内存隔离的障碍，提供一套规范化的方法，让独立运行的进程能够安全、有效地交换数据和同步操作。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-IPC？"><a href="#一、为什么需要-IPC？" class="headerlink" title="一、为什么需要 IPC？"></a>一、为什么需要 IPC？</h2><p>在现代操作系统中，进程是资源分配和调度的基本单位。为了保证系统的稳定性和安全性，操作系统为每个进程分配独立的内存地址空间。这种内存隔离虽然能有效防止一个进程的错误影响其他进程，但也带来了以下问题：</p>
<ol>
<li><strong>信息共享</strong>：进程间需要共享数据或状态。例如，一个数据生产者进程生成数据，一个数据消费者进程处理数据。</li>
<li><strong>模块化</strong>：将一个大型复杂的应用程序拆分成多个独立的、职责单一的进程，每个进程专注于特定任务。这些进程需要相互协作才能完成整体功能。</li>
<li><strong>性能提升</strong>：通过并行处理，将不同的任务分配给不同的进程在多核处理器上同时执行，从而提高计算效率。</li>
<li><strong>事件通知</strong>：一个进程需要通知另一个进程某个事件已经发生。</li>
<li><strong>资源管理</strong>：多个进程需要协调对共享资源的访问，以避免竞态条件和数据不一致。</li>
</ol>
<p>IPC 机制就是为了解决这些问题而生，它提供了多种不同的通信模型，以适应不同的应用场景和性能需求。</p>
<h2 id="二、IPC-的核心概念"><a href="#二、IPC-的核心概念" class="headerlink" title="二、IPC 的核心概念"></a>二、IPC 的核心概念</h2><p>在深入 IPC 机制之前，理解几个相关概念非常重要：</p>
<ol>
<li><strong>进程 (Process)</strong>：程序的一次执行过程，拥有独立的内存地址空间、文件描述符、寄存器等资源。进程是操作系统进行资源分配和调度的基本单位。</li>
<li><strong>线程 (Thread)</strong>：是进程内的执行单元，共享进程的内存地址空间和大部分资源。线程间通信通常比进程间通信更简单（直接访问共享内存），但共享状态也带来了同步的复杂性。本文主要关注进程间通信。</li>
<li><strong>同步 (Synchronization)</strong>：协调多个并发进程或线程的操作，以确保它们按照预期的顺序执行，并正确访问共享资源。常见的同步原语有互斥锁 (Mutex)、信号量 (Semaphore) 等。</li>
<li><strong>并发 (Concurrency) 与 并行 (Parallelism)</strong>：<ul>
<li><strong>并发</strong>：指多个任务在同一时间段内交替执行，宏观上看起来是同时进行，微观上可能在一个核上分时执行。</li>
<li><strong>并行</strong>：指多个任务在同一时刻真正地同时执行，需要多核处理器支持。</li>
</ul>
</li>
</ol>
<h2 id="三、常见的-IPC-机制"><a href="#三、常见的-IPC-机制" class="headerlink" title="三、常见的 IPC 机制"></a>三、常见的 IPC 机制</h2><p>操作系统提供了多种 IPC 机制，每种机制都有其特点和适用场景。</p>
<h3 id="3-1-1-管道-Pipes"><a href="#3-1-1-管道-Pipes" class="headerlink" title="3.1 1. 管道 (Pipes)"></a>3.1 1. 管道 (Pipes)</h3><p><strong>定义</strong>：管道是最早也是最简单的 IPC 形式之一。它提供一个字节流的通信通道，数据以先进先出 (FIFO) 的方式传输。</p>
<p><strong>分类</strong>：</p>
<ul>
<li><p><strong>匿名管道 (Anonymous Pipes)</strong>：</p>
<ul>
<li><strong>特点</strong>：通常用于具有<strong>亲缘关系</strong>的进程（如父子进程或兄弟进程）之间通信。它由操作系统内核维护，没有文件系统中的对应名称。通常是半双工（单向），如果需要双向通信，需要创建两个管道。</li>
<li><strong>工作原理</strong>：父进程创建管道后，<code>fork</code> 出子进程，子进程会继承父进程的文件描述符。父子进程通过读写管道的两端进行通信。</li>
<li><strong>局限性</strong>：生命周期与创建它的进程组绑定，进程终止管道也消失。只能在同一台机器上使用。</li>
</ul>
</li>
<li><p><strong>命名管道 (Named Pipes &#x2F; FIFOs)</strong>：</p>
<ul>
<li><strong>特点</strong>：克服了匿名管道的局限性，允许<strong>无亲缘关系</strong>的进程之间进行通信。它在文件系统中有一个对应的名称（像普通文件一样），可以被任何有权限的进程打开和读写。</li>
<li><strong>工作原理</strong>：一个进程通过文件路径创建命名管道，另一个或多个进程打开该路径进行读写。</li>
<li><strong>局限性</strong>：仍然是半双工，且通常仅限于同一台机器上的进程。</li>
</ul>
</li>
</ul>
<p><strong>Mermaid 图示 (匿名管道)：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[Parent Process] -- Creates Pipe --&gt; B(Pipe)
    A -- forks --&gt; C[Child Process]
    A -- Writes to Write End --&gt; B
    C -- Reads from Read End --&gt; B
  </pre></div>

<p><strong>Python 示例 (匿名管道)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anonymous_pipe_example</span>():</span><br><span class="line">    r, w = os.pipe() <span class="comment"># 创建一个管道，r是读端文件描述符，w是写端文件描述符</span></span><br><span class="line"></span><br><span class="line">    pid = os.fork()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pid &gt; <span class="number">0</span>: <span class="comment"># 父进程</span></span><br><span class="line">        os.close(r) <span class="comment"># 父进程关闭读端</span></span><br><span class="line">        message = <span class="string">&quot;Hello from parent!&quot;</span></span><br><span class="line">        os.write(w, message.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 写入管道</span></span><br><span class="line">        os.close(w) <span class="comment"># 关闭写端</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Parent sent: &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        os.wait() <span class="comment"># 等待子进程结束</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 子进程</span></span><br><span class="line">        os.close(w) <span class="comment"># 子进程关闭写端</span></span><br><span class="line">        data = os.read(r, <span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># 从管道读取数据</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Child received: &#x27;<span class="subst">&#123;data&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        os.close(r) <span class="comment"># 关闭读端</span></span><br><span class="line">        os._exit(<span class="number">0</span>) <span class="comment"># 子进程退出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- Anonymous Pipe Example ---&quot;</span>)</span><br><span class="line">    anonymous_pipe_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-消息队列-Message-Queues"><a href="#3-2-2-消息队列-Message-Queues" class="headerlink" title="3.2 2. 消息队列 (Message Queues)"></a>3.2 2. 消息队列 (Message Queues)</h3><p><strong>定义</strong>：消息队列是存放在内核中的消息链表，允许进程以间接的方式发送和接收离散的消息。每个消息都有一个类型，接收进程可以根据类型选择性地接收消息。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>解耦</strong>：发送者和接收者之间无需直接连接，发送者将消息放入队列即可，接收者可以随时从队列中取出。</li>
<li><strong>异步</strong>：发送消息后，发送者可以立即继续执行，无需等待接收者处理。</li>
<li><strong>存储在内核</strong>：消息在发送后会存储在内核中，直到被接收者取走，保证消息的持久性（在系统重启前）。</li>
<li><strong>消息优先级</strong>：某些实现允许为消息指定优先级。</li>
</ul>
<p><strong>Mermaid 图示：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    P1[Process A] -- Puts Message --&gt; MQ(Message Queue in Kernel)
    P2[Process B] -- Gets Message --&gt; MQ
    MQ -- Stores Messages --&gt; Data[Message 1, Message 2, ...]
  </pre></div>

<p><strong>Python 示例 (使用 <code>multiprocessing.Queue</code>)：</strong></p>
<p><code>multiprocessing.Queue</code> 是 Python <code>multiprocessing</code> 模块提供的高级抽象，它在底层可能使用管道或更复杂的机制实现，但提供了消息队列的语义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sender</span>(<span class="params">queue</span>):</span><br><span class="line">    message = <span class="string">&quot;Data from Sender&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sender: Sending &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    queue.put(message)</span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 模拟工作</span></span><br><span class="line">    queue.put(<span class="string">&quot;STOP&quot;</span>) <span class="comment"># 发送停止信号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sender: Done.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiver</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Receiver: Waiting for messages...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        message = queue.get() <span class="comment"># 从队列获取消息</span></span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;STOP&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Receiver: Received STOP signal. Exiting.&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Receiver: Received &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>) <span class="comment"># 模拟处理消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message_queue_example</span>():</span><br><span class="line">    q = multiprocessing.Queue() <span class="comment"># 创建一个队列</span></span><br><span class="line"></span><br><span class="line">    p_sender = multiprocessing.Process(target=sender, args=(q,))</span><br><span class="line">    p_receiver = multiprocessing.Process(target=receiver, args=(q,))</span><br><span class="line"></span><br><span class="line">    p_sender.start()</span><br><span class="line">    p_receiver.start()</span><br><span class="line"></span><br><span class="line">    p_sender.join()</span><br><span class="line">    p_receiver.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Message Queue Example ---&quot;</span>)</span><br><span class="line">    message_queue_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-共享内存-Shared-Memory"><a href="#3-3-3-共享内存-Shared-Memory" class="headerlink" title="3.3 3. 共享内存 (Shared Memory)"></a>3.3 3. 共享内存 (Shared Memory)</h3><p><strong>定义</strong>：共享内存是最高效的 IPC 方式。它允许两个或多个进程直接访问同一块物理内存区域。一旦内存映射建立，进程可以直接读写该内存，无需通过内核。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>速度最快</strong>：避免了数据在内核空间和用户空间之间的复制，实现了直接访问。</li>
<li><strong>复杂性高</strong>：由于多个进程直接访问同一块内存，必须使用同步机制（如信号量、互斥锁）来避免竞态条件和数据不一致。</li>
<li><strong>数据结构</strong>：开发者需要自行管理共享内存中的数据结构和布局。</li>
</ul>
<p><strong>Mermaid 图示：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[Process A] -- Maps Segment --&gt; SM(Shared Memory Segment)
    B[Process B] -- Maps Segment --&gt; SM
    A -- Reads&#x2F;Writes Data --&gt; SM
    B -- Reads&#x2F;Writes Data --&gt; SM
    A --- S1[Semaphore&#x2F;Mutex]
    B --- S1
    S1 -- Controls Access --&gt; SM
  </pre></div>

<p><strong>Python 示例 (使用 <code>multiprocessing.shared_memory</code>)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> shared_memory</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writer</span>(<span class="params">name, shape, dtype</span>):</span><br><span class="line">    <span class="comment"># 重新连接到已存在的共享内存</span></span><br><span class="line">    shm_b = shared_memory.SharedMemory(name=name)</span><br><span class="line">    <span class="comment"># 创建一个Numpy数组视图</span></span><br><span class="line">    np_array = np.ndarray(shape, dtype=dtype, buffer=shm_b.buf)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Writer: Writing to shared memory...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        np_array[i] = i * <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Writer: Wrote <span class="subst">&#123;np_array[i]&#125;</span>&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Writer: Done writing.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    shm_b.close() <span class="comment"># 关闭共享内存连接，但不会销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reader</span>(<span class="params">name, shape, dtype</span>):</span><br><span class="line">    <span class="comment"># 重新连接到已存在的共享内存</span></span><br><span class="line">    shm_c = shared_memory.SharedMemory(name=name)</span><br><span class="line">    np_array = np.ndarray(shape, dtype=dtype, buffer=shm_c.buf)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Reader: Reading from shared memory...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Reader: Read <span class="subst">&#123;np_array[i]&#125;</span>&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.7</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Reader: Done reading.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    shm_c.close() <span class="comment"># 关闭共享内存连接，但不会销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shared_memory_example</span>():</span><br><span class="line">    <span class="comment"># 创建一个共享内存块</span></span><br><span class="line">    <span class="comment"># 注意：需要手动管理共享内存的生命周期</span></span><br><span class="line">    a = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]) <span class="comment"># 示例数据</span></span><br><span class="line">    shm = shared_memory.SharedMemory(create=<span class="literal">True</span>, size=a.nbytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过 Numpy 视图将数据写入共享内存</span></span><br><span class="line">    np_array_orig = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)</span><br><span class="line">    np_array_orig[:] = a[:] <span class="comment"># 将初始数据复制到共享内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shared memory created with name: <span class="subst">&#123;shm.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p_writer = mp.Process(target=writer, args=(shm.name, a.shape, a.dtype))</span><br><span class="line">    p_reader = mp.Process(target=reader, args=(shm.name, a.shape, a.dtype))</span><br><span class="line"></span><br><span class="line">    p_writer.start()</span><br><span class="line">    p_reader.start()</span><br><span class="line"></span><br><span class="line">    p_writer.join()</span><br><span class="line">    p_reader.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在所有进程都完成使用后，解除共享内存的链接和销毁</span></span><br><span class="line">    shm.close()</span><br><span class="line">    shm.unlink() <span class="comment"># 销毁共享内存段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Shared Memory Example ---&quot;</span>)</span><br><span class="line">    shared_memory_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-信号量-Semaphores"><a href="#3-4-4-信号量-Semaphores" class="headerlink" title="3.4 4. 信号量 (Semaphores)"></a>3.4 4. 信号量 (Semaphores)</h3><p><strong>定义</strong>：信号量是用于控制对共享资源访问的同步原语。它本质上是一个计数器，用于管理对资源的并发访问数量。</p>
<p><strong>类型</strong>：</p>
<ul>
<li><strong>二进制信号量 (Binary Semaphore &#x2F; Mutex)</strong>：值只能是 0 或 1，用于实现互斥访问（一次只有一个进程能访问资源）。</li>
<li><strong>计数信号量 (Counting Semaphore)</strong>：值可以大于 1，用于控制对具有多个相同实例的资源（如数据库连接池）的访问。</li>
</ul>
<p><strong>操作</strong>：</p>
<ul>
<li><code>P</code> (Wait&#x2F;Acquire&#x2F;Down)：尝试获取资源。如果信号量值大于 0，则减 1 并继续执行；否则，进程阻塞直到信号量大于 0。</li>
<li><code>V</code> (Signal&#x2F;Release&#x2F;Up)：释放资源。将信号量值加 1。如果有进程在等待该信号量，则唤醒一个进程。</li>
</ul>
<p><strong>Python 示例 (使用 <code>multiprocessing.Semaphore</code>)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_with_semaphore</span>(<span class="params">semaphore, <span class="built_in">id</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>: Trying to acquire resource.&quot;</span>)</span><br><span class="line">    semaphore.acquire() <span class="comment"># P 操作，获取信号量</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>: Acquired resource. Working for 1 second.&quot;</span>)</span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.5</span>, <span class="number">2</span>)) <span class="comment"># 模拟访问资源并工作</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        semaphore.release() <span class="comment"># V 操作，释放信号量</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>: Released resource.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">semaphore_example</span>():</span><br><span class="line">    <span class="comment"># 创建一个计数信号量，初始值为2，表示最多允许2个进程同时访问资源</span></span><br><span class="line">    semaphore = multiprocessing.Semaphore(<span class="number">2</span>)</span><br><span class="line">    processes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker_with_semaphore, args=(semaphore, i))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All workers finished.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Semaphore Example ---&quot;</span>)</span><br><span class="line">    semaphore_example()</span><br></pre></td></tr></table></figure>

<p><strong>Go 语言注意事项</strong>：Go 语言的 <code>sync.Mutex</code> 和 <code>sync.WaitGroup</code> 等同步原语主要用于<strong>goroutine (协程)</strong> 之间的同步，它们是在单个进程内部的<strong>线程级</strong>同步。对于<strong>进程间</strong>的信号量，Go 语言标准库没有直接提供跨平台的抽象，通常需要通过 Cgo 调用操作系统的特定 API (如 Linux 的 <code>sysv_sem</code> 或 POSIX 信号量)。</p>
<h3 id="3-5-5-套接字-Sockets"><a href="#3-5-5-套接字-Sockets" class="headerlink" title="3.5 5. 套接字 (Sockets)"></a>3.5 5. 套接字 (Sockets)</h3><p><strong>定义</strong>：套接字是网络通信的基石，但也可以用于同一台机器上的进程间通信。它提供了一个抽象层，允许进程通过标准网络协议（TCP&#x2F;IP、UDP）进行数据交换。</p>
<p><strong>分类</strong>：</p>
<ul>
<li><strong>Unix 域套接字 (Unix Domain Sockets &#x2F; UDS)</strong>：<ul>
<li><strong>特点</strong>：仅限于同一台机器上的进程间通信。它不涉及网络协议栈，直接通过文件系统路径进行通信。效率比网络套接字高，且具有文件系统权限控制。</li>
<li><strong>工作原理</strong>：客户端和服务器进程通过一个文件系统路径（例如 <code>/tmp/my_socket</code>）建立连接。</li>
</ul>
</li>
<li><strong>网络套接字 (Network Sockets)</strong>：<ul>
<li><strong>特点</strong>：可以通过网络在不同主机之间进行通信，也可以在同一主机上进行通信。使用 IP 地址和端口号来识别通信端点。</li>
<li><strong>工作原理</strong>：客户端和服务器进程通过 IP 地址和端口号建立连接。</li>
</ul>
</li>
</ul>
<p><strong>Mermaid 图示 (客户端-服务器模式)：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    C[Client Process] -- Connects to --&gt; S(Server Process)
    S -- Listens on Socket --&gt; Sock(Socket Address)
    C -- Sends Data --&gt; Sock
    S -- Receives Data --&gt; Sock
    Sock -- Binds to --&gt; IP_Port[IP Address:Port &#x2F; Unix Path]
  </pre></div>

<p><strong>Python 示例 (Unix 域套接字)：</strong></p>
<ul>
<li><p><strong>服务器端 (<code>uds_server.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uds_server</span>():</span><br><span class="line">    <span class="comment"># 确保 socket 文件不存在</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(SOCKET_PATH):</span><br><span class="line">        os.remove(SOCKET_PATH)</span><br><span class="line"></span><br><span class="line">    server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line">    server.bind(SOCKET_PATH)</span><br><span class="line">    server.listen(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;UDS Server listening on <span class="subst">&#123;SOCKET_PATH&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Accepted connection from <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        message = data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Server received: &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        conn.sendall(<span class="string">f&quot;Server echoed: <span class="subst">&#123;message&#125;</span>&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br><span class="line">    server.close()</span><br><span class="line">    os.remove(SOCKET_PATH)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UDS Server closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uds_server()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端 (<code>uds_client.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uds_client</span>():</span><br><span class="line">    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect(SOCKET_PATH)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;UDS Client connected to <span class="subst">&#123;SOCKET_PATH&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        messages = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;How are you?&quot;</span>, <span class="string">&quot;This is a test.&quot;</span>, <span class="string">&quot;quit&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> messages:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Client sending: &#x27;<span class="subst">&#123;msg&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">            client.sendall(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            response = client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Client received: &#x27;<span class="subst">&#123;response&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Client error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        client.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;UDS Client closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 启动客户端之前，请确保 uds_server.py 已经在运行</span></span><br><span class="line">    uds_client()</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Golang 示例 (Unix 域套接字)：</strong></p>
<ul>
<li><p><strong>服务器端 (<code>uds_server.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example_go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 清理之前的 socket 文件</span></span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(SOCKET_PATH); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Remove(SOCKET_PATH)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;unix&quot;</span>, SOCKET_PATH)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error listening:&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	fmt.Println(<span class="string">&quot;UDS Server listening on&quot;</span>, SOCKET_PATH)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error accepting:&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Accepted connection from&quot;</span>, conn.RemoteAddr())</span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// fmt.Println(&quot;Error reading:&quot;, err.Error())</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		message := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Println(<span class="string">&quot;Server received:&quot;</span>, message)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> message == <span class="string">&quot;quit&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		response := []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;Server echoed: %s&quot;</span>, message))</span><br><span class="line">		conn.Write(response)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Connection closed for&quot;</span>, conn.RemoteAddr())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端 (<code>uds_client.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example_go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;unix&quot;</span>, SOCKET_PATH)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error connecting:&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	fmt.Println(<span class="string">&quot;UDS Client connected to&quot;</span>, SOCKET_PATH)</span><br><span class="line"></span><br><span class="line">	messages := []<span class="type">string</span>&#123;<span class="string">&quot;Hello Go&quot;</span>, <span class="string">&quot;How are you Go?&quot;</span>, <span class="string">&quot;This is a Go test.&quot;</span>, <span class="string">&quot;quit&quot;</span>&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, msg := <span class="keyword">range</span> messages &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Client sending:&quot;</span>, msg)</span><br><span class="line">		conn.Write([]<span class="type">byte</span>(msg))</span><br><span class="line"></span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(time.Second * <span class="number">2</span>)) <span class="comment">// 设置读取超时</span></span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Client read timeout&quot;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Error reading:&quot;</span>, err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		response := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Println(<span class="string">&quot;Client received:&quot;</span>, response)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;UDS Client closed.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行 Go 示例：</strong></p>
<ol>
<li>在一个终端中运行 <code>go run uds_server.go</code></li>
<li>在另一个终端中运行 <code>go run uds_client.go</code></li>
</ol>
</li>
</ul>
<h3 id="3-6-6-信号-Signals"><a href="#3-6-6-信号-Signals" class="headerlink" title="3.6 6. 信号 (Signals)"></a>3.6 6. 信号 (Signals)</h3><p><strong>定义</strong>：信号是一种非常轻量级的 IPC 机制，用于通知一个进程某个事件的发生。它不能携带大量数据，通常只包含一个信号编号。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>异步通知</strong>：信号的发送是异步的，接收进程可以在任何时候收到并处理信号。</li>
<li><strong>信息量小</strong>：只能传递有限的信息（信号类型）。</li>
<li><strong>常见用途</strong>：终止进程 (SIGTERM, SIGKILL)、中断进程 (SIGINT)、暂停进程 (SIGSTOP, SIGTSTP) 等。</li>
<li><strong>不可靠性</strong>：经典 Unix 信号是不可靠的（可能会丢失或重复），但现代 POSIX 信号提供了可靠性增强。</li>
</ul>
<p><strong>Python 示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signum, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;os.getpid()&#125;</span>: Received signal <span class="subst">&#123;signum&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> signum == signal.SIGUSR1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Custom action for SIGUSR1!&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> signum == signal.SIGTERM:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Gracefully shutting down...&quot;</span>)</span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sender_process</span>(<span class="params">pid</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sender <span class="subst">&#123;os.getpid()&#125;</span>: Sending SIGUSR1 to <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br><span class="line">    os.kill(pid, signal.SIGUSR1) <span class="comment"># 发送自定义信号1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sender <span class="subst">&#123;os.getpid()&#125;</span>: Sending SIGTERM to <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br><span class="line">    os.kill(pid, signal.SIGTERM) <span class="comment"># 发送终止信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiver_process</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Receiver <span class="subst">&#123;os.getpid()&#125;</span>: Waiting for signals...&quot;</span>)</span><br><span class="line">    signal.signal(signal.SIGUSR1, signal_handler) <span class="comment"># 注册SIGUSR1的处理函数</span></span><br><span class="line">    signal.signal(signal.SIGTERM, signal_handler) <span class="comment"># 注册SIGTERM的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保持进程运行，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">100</span>) <span class="comment"># 挂起进程，等待信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_example</span>():</span><br><span class="line">    pid = os.fork()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pid &gt; <span class="number">0</span>: <span class="comment"># 父进程 (作为发送者)</span></span><br><span class="line">        sender_process(pid)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 子进程 (作为接收者)</span></span><br><span class="line">        receiver_process()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Signal Example ---&quot;</span>)</span><br><span class="line">    signal_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-7-7-文件-Files"><a href="#3-7-7-文件-Files" class="headerlink" title="3.7 7. 文件 (Files)"></a>3.7 7. 文件 (Files)</h3><p><strong>定义</strong>：最简单直接的 IPC 方式，一个进程将数据写入文件，另一个进程从该文件读取数据。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>持久性</strong>：数据存储在磁盘上，即使进程终止也不会丢失。</li>
<li><strong>简单易用</strong>：操作和理解相对简单。</li>
<li><strong>性能差</strong>：涉及到磁盘 I&#x2F;O，速度远低于内存中的 IPC 方式。</li>
<li><strong>同步困难</strong>：需要额外的机制来协调读写顺序和文件锁定，以避免竞态条件。</li>
<li><strong>适用场景</strong>：不追求实时性、需要数据持久化、数据量不大的场景。</li>
</ul>
<h2 id="四、IPC-机制的对比与选择"><a href="#四、IPC-机制的对比与选择" class="headerlink" title="四、IPC 机制的对比与选择"></a>四、IPC 机制的对比与选择</h2><p>不同的 IPC 机制有不同的性能、复杂性和适用场景。下表总结了它们的优缺点：</p>
<table>
<thead>
<tr>
<th align="left">特性 &#x2F; 机制</th>
<th align="left">管道 (Pipes)</th>
<th align="left">消息队列 (Message Queues)</th>
<th align="left">共享内存 (Shared Memory)</th>
<th align="left">信号量 (Semaphores)</th>
<th align="left">套接字 (Sockets)</th>
<th align="left">信号 (Signals)</th>
<th align="left">文件 (Files)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>通信方式</strong></td>
<td align="left">字节流</td>
<td align="left">消息 (离散)</td>
<td align="left">直接内存访问</td>
<td align="left">仅同步</td>
<td align="left">字节流 (流式) &#x2F; 数据报 (UDP)</td>
<td align="left">异步通知</td>
<td align="left">字节流 (流式)</td>
</tr>
<tr>
<td align="left"><strong>数据传输量</strong></td>
<td align="left">中等</td>
<td align="left">中等</td>
<td align="left">大 (或任意)</td>
<td align="left">无</td>
<td align="left">中等至大</td>
<td align="left">无 (仅信号类型)</td>
<td align="left">大</td>
</tr>
<tr>
<td align="left"><strong>传输速度</strong></td>
<td align="left">中等</td>
<td align="left">中等</td>
<td align="left"><strong>最快</strong></td>
<td align="left">极快 (同步操作)</td>
<td align="left">中等 (UDS较快, 网络较慢)</td>
<td align="left">极快</td>
<td align="left">最慢</td>
</tr>
<tr>
<td align="left"><strong>同步性</strong></td>
<td align="left">隐式同步 (阻塞读写)</td>
<td align="left">异步 (非阻塞发送接收)</td>
<td align="left"><strong>需要外部同步</strong></td>
<td align="left"><strong>仅用于同步</strong></td>
<td align="left">异步 (非阻塞模式)</td>
<td align="left">异步</td>
<td align="left">需要外部同步</td>
</tr>
<tr>
<td align="left"><strong>亲缘关系</strong></td>
<td align="left">匿名：父子；命名：无</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
</tr>
<tr>
<td align="left"><strong>跨网络</strong></td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left"><strong>是</strong> (网络套接字)</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left">简单</td>
<td align="left">中等</td>
<td align="left">复杂 (需同步)</td>
<td align="left">中等</td>
<td align="left">中等 (服务器&#x2F;客户端模式)</td>
<td align="left">简单</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">Shell管道、日志重定向</td>
<td align="left">任务队列、工作流</td>
<td align="left">大型数据交换、图像处理</td>
<td align="left">资源访问控制</td>
<td align="left">客户端-服务器通信、微服务</td>
<td align="left">进程管理、事件通知</td>
<td align="left">配置、日志、持久化</td>
</tr>
</tbody></table>
<h2 id="五、安全考虑"><a href="#五、安全考虑" class="headerlink" title="五、安全考虑"></a>五、安全考虑</h2><p>在使用 IPC 机制时，安全性是一个不容忽视的方面：</p>
<ol>
<li><strong>数据完整性和机密性</strong>：通过 IPC 传输的数据可能包含敏感信息。需要考虑数据是否会被窃听或篡改。对于跨网络通信，HTTPS&#x2F;SSL&#x2F;TLS 等加密协议是必要的。</li>
<li><strong>权限控制</strong>：<ul>
<li><strong>命名管道和 Unix 域套接字</strong>：它们在文件系统中存在，可以通过文件权限 (rwx) 控制哪些用户或组的进程可以访问。</li>
<li><strong>共享内存</strong>：如果未正确控制访问权限，可能导致任意进程读写共享内存，造成数据破坏。</li>
</ul>
</li>
<li><strong>缓冲区溢出</strong>：在消息传递或共享内存中，如果未对输入数据进行大小检查，可能导致缓冲区溢出漏洞。</li>
<li><strong>拒绝服务 (DoS)</strong>：攻击者可能通过发送大量消息、占用大量共享内存或滥用信号量来耗尽系统资源，导致正常服务无法进行。</li>
<li><strong>竞态条件 (Race Conditions)</strong>：在共享内存或文件通信中，如果不对共享资源的访问进行正确同步，可能导致数据不一致。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>IPC 是现代操作系统中构建复杂、高性能应用程序的基石。每种 IPC 机制都有其独特的优缺点和适用场景。在选择 IPC 机制时，开发者需要综合考虑数据传输量、传输速度、同步需求、进程关系、跨网络需求以及安全等因素。正确地选择和实现 IPC，不仅能提升应用程序的性能和稳定性，还能提高系统的模块化和可维护性。深入理解这些机制的工作原理和限制，是成为一名优秀系统开发者的必备技能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/cecf96486ef4/">https://blog.tbf1211.xx.kg/cecf96486ef4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">传统命令行工具的现代补强与替代方案详解</div></div><div class="info-2"><div class="info-item-1"> 随着技术的发展和用户体验需求的变化，许多经典的 Unix&#x2F;Linux 命令行工具虽然功能强大且稳定，但在交互性、可视化、性能和便捷性方面，逐渐暴露出一些局限性。为了提升命令行操作的效率、可读性和舒适度，社区涌现出大量用 Go、Rust 等现代语言编写的“补强”或“替代”工具。本文将详细介绍一系列旨在现代化命令行体验的工具。  核心思想：并非完全取代经典工具，而是通过提供更丰富的功能、更美观的输出、更快的执行速度和更友好的交互方式，来增强或补充传统命令行工具的能力，以适应现代开发和系统管理的需求。   一、文件查看与内容处理1.1 cat 的补强：bat 传统工具：cat (concatenate files and print on the standard output) 现代补强：bat bat 是 cat 的一个语法高亮、分页和 Git 集成增强版。它不仅能显示文件内容，还能： 语法高亮：对代码文件自动进行语法高亮显示，支持多种编程语言。 行号显示：默认显示行号，方便代码审查和定位。 Git 集成：在显示文件时，会自动显示 Git 变更标记（如新增、修改）。 分...</div></div></div></a><a class="pagination-related" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang sqlc 框架详解</div></div><div class="info-2"><div class="info-item-1"> sqlc 是一个SQL 编译器 (SQL Compiler)，它能够根据用户定义的 SQL 查询和数据库 Schema 自动生成类型安全 (type-safe) 的 Go 代码。与传统的 ORM (Object-Relational Mapping) 工具不同，sqlc 的核心理念是“写 SQL，生成 Go (Write SQL, Get Go)”。开发者专注于编写原生的 SQL 查询，sqlc 则负责将其转换为易于在 Go 应用程序中使用的、无反射、高性能的 API。  核心思想：保持 SQL 源码作为事实的唯一来源，并通过代码生成器将其无缝集成到 Go 代码中，实现类型安全和高效的数据库操作。 它不尝试将 SQL 抽象化，而是将 SQL 语句转换为可直接调用的 Go 函数。    一、为什么选择 sqlc？在 Golang 中进行数据库操作，开发者通常面临几种选择：  直接使用 database/sql 库：最底层、最灵活，但需要手动处理行扫描、错误检查、参数绑定等，代码量大且容易出错。 使用传统 ORM (如 GORM, XORM)：提供了高层次的抽象，通过 Go 结构体...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/4a9afa2dd79a/" title="深入理解同步&#x2F;异步与阻塞&#x2F;非阻塞"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-19</div><div class="info-item-2">深入理解同步&#x2F;异步与阻塞&#x2F;非阻塞</div></div><div class="info-2"><div class="info-item-1"> 在计算机科学和并发编程中，同步&#x2F;异步 (Synchronous&#x2F;Asynchronous) 和 阻塞&#x2F;非阻塞 (Blocking&#x2F;Non-blocking) 是描述程序执行流程和资源访问方式的两个核心概念。它们经常被一起讨论，但实际上是从不同的角度来描述系统行为的。理解这两对概念对于设计高性能、响应式的系统至关重要。  核心思想：  同步&#x2F;异步 描述的是消息通知机制：调用者何时收到被调用者的结果。 阻塞&#x2F;非阻塞 描述的是调用者等待结果时的状态：调用者是否可以继续执行其他任务。     一、同步 (Synchronous) 与 异步 (Asynchronous)同步 (Synchronous) 和 异步 (Asynchronous) 关注的是一个任务的调用者 (Caller) 何时才能获得被调用者 (Callee) 的执行结果或通知。 1.1 同步 (Synchronous)当一个任务是同步的时候，调用者在调用被调用者后，必须等待被调用者完成其全部工作并返回结果后，才能继续执行调用者自己的后续操作。 特点：  顺序执行：...</div></div></div></a><a class="pagination-related" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-07</div><div class="info-item-2">传统命令行工具的现代补强与替代方案详解</div></div><div class="info-2"><div class="info-item-1"> 随着技术的发展和用户体验需求的变化，许多经典的 Unix&#x2F;Linux 命令行工具虽然功能强大且稳定，但在交互性、可视化、性能和便捷性方面，逐渐暴露出一些局限性。为了提升命令行操作的效率、可读性和舒适度，社区涌现出大量用 Go、Rust 等现代语言编写的“补强”或“替代”工具。本文将详细介绍一系列旨在现代化命令行体验的工具。  核心思想：并非完全取代经典工具，而是通过提供更丰富的功能、更美观的输出、更快的执行速度和更友好的交互方式，来增强或补充传统命令行工具的能力，以适应现代开发和系统管理的需求。   一、文件查看与内容处理1.1 cat 的补强：bat 传统工具：cat (concatenate files and print on the standard output) 现代补强：bat bat 是 cat 的一个语法高亮、分页和 Git 集成增强版。它不仅能显示文件内容，还能： 语法高亮：对代码文件自动进行语法高亮显示，支持多种编程语言。 行号显示：默认显示行号，方便代码审查和定位。 Git 集成：在显示文件时，会自动显示 Git 变更标记（如新增、修改）。 分...</div></div></div></a><a class="pagination-related" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-20</div><div class="info-item-2">测试驱动开发 (TDD) 详解</div></div><div class="info-2"><div class="info-item-1"> 测试驱动开发 (Test-Driven Development, TDD) 是一种软件开发方法，它要求开发者在编写任何功能代码之前，先编写测试代码。这个过程遵循一个严格的循环：红-绿-重构 (Red-Green-Refactor)。TDD 的核心思想是通过测试来驱动代码的设计和实现，从而提高代码质量、可维护性和开发效率。  核心思想：先写失败的测试，再写刚刚好通过测试的代码，然后重构代码。    一、TDD 简介与核心原则TDD 是由 Kent Beck 在极限编程 (eXtreme Programming, XP) 中推广的一种实践。它不仅仅是一种测试技术，更是一种强大的设计工具，能够帮助开发者构建出更健壮、更清晰、更易于维护的软件系统。 1.1 TDD 的定义TDD 是一种软件开发流程，其主要特征是在编写实际的功能代码之前，先为即将实现的功能编写自动化测试。这些测试最初会失败（Red），然后开发者编写最少量的代码使其通过（Green），最后对代码进行优化和清理（Refactor），并确保所有测试仍然通过。 1.2 TDD 的核心原则：红-绿-重构 (Red-Green-Re...</div></div></div></a><a class="pagination-related" href="/fa3d796f3333/" title="MessagePack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-09</div><div class="info-item-2">MessagePack 详解</div></div><div class="info-2"><div class="info-item-1"> MessagePack 是一个高效的二进制序列化格式，它允许你在多种语言之间交换数据，就像 JSON 一样。但与 JSON 不同的是，MessagePack 以更紧凑的二进制形式表示数据，这通常使其具有更小的消息大小和更快的编码&#x2F;解码速度。它被设计为一个“像 JSON 但更快更小”的替代品，特别适用于网络协议、数据存储以及低功耗设备等对性能和带宽敏感的场景。  核心思想：将结构化数据（如对象、数组、基本类型）编码成紧凑的二进制流，以实现高效的数据传输和存储。   一、什么是 MessagePack？MessagePack 是一种基于二进制的数据交换格式，其设计目标是高效、紧凑和跨语言兼容。它通过一种优化的二进制表示来序列化各种数据类型，包括整数、浮点数、字符串、二进制数据、数组和映射。其官方网站将其描述为“一个整洁、紧凑的二进制序列化格式”。 与文本格式（如 JSON）相比，MessagePack 的主要优势在于：  更小的消息尺寸：通过减少冗余信息并直接使用二进制表示数据类型，MessagePack 生成的数据通常比同等 JSON 数据小。 更快的处理速度：由于节省...</div></div></div></a><a class="pagination-related" href="/a1d408b2ddbe/" title="Python多进程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="info-item-2">Python多进程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式概述模式构成：  生产者 (Producer)：负责生成数据，并将其放入共享的缓冲区（队列）中。 消费者 (Consumer)：负责从共享的缓冲区（队列）中取出数据进行处理。 缓冲区 (Buffer &#x2F; Queue)：一个共享的数据结构，通常是一个队列，用于存储生产者生产的数据和消费者消费的数据。它充当了生产者和消费者之间的桥梁。  解决的问题：  解耦：生产者和消费者可以独立运行，互不干扰，提高系统的灵活性。 并发：允许多个生产者和多个消费者同时存在，提高处理效率。 削峰填谷：当生产速度快于消费速度时，缓冲区可以存储多余的数据，防止数...</div></div></div></a><a class="pagination-related" href="/38c508ec9ee0/" title="PHP Fibers (协程) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="info-item-2">PHP Fibers (协程) 详解</div></div><div class="info-2"><div class="info-item-1"> Fibers (协程) 是 PHP 8.1 引入的一个重要新特性，它为 PHP 带来了原生的用户空间并发能力。与传统的线程或进程不同，Fibers 允许代码在执行过程中暂停和恢复，而无需使用生成器 (Generators) 或复杂的事件循环回调。这使得开发者能够编写更具可读性和可维护性的异步非阻塞代码，从而更好地应对 I&#x2F;O 密集型任务，如网络请求、数据库查询等。  核心思想：Fibers 是一种轻量级的并发原语，允许 PHP 代码在用户空间中实现非阻塞操作，通过显式地暂停和恢复执行，简化了异步代码的编写。   一、为什么需要 Fibers？在 PHP 8.1 之前，实现异步非阻塞代码通常依赖于以下两种方式：  Callbacks (回调函数)： 优点：简单直接，适用于简单的异步操作。 缺点：容易陷入“回调地狱 (Callback Hell)”，代码可读性和维护性差，错误处理复杂。   Generators (生成器)： 优点：通过 yield 实现了伪协程，可以在一定程度上改善回调地狱，允许代码暂停和恢复。 缺点：生成器本质上是迭代器，其语义更偏向于数据生成。将生成...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-IPC%EF%BC%9F"><span class="toc-text">一、为什么需要 IPC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IPC-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、IPC 的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84-IPC-%E6%9C%BA%E5%88%B6"><span class="toc-text">三、常见的 IPC 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E7%AE%A1%E9%81%93-Pipes"><span class="toc-text">3.1 1. 管道 (Pipes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Message-Queues"><span class="toc-text">3.2 2. 消息队列 (Message Queues)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-Shared-Memory"><span class="toc-text">3.3 3. 共享内存 (Shared Memory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphores"><span class="toc-text">3.4 4. 信号量 (Semaphores)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E5%A5%97%E6%8E%A5%E5%AD%97-Sockets"><span class="toc-text">3.5 5. 套接字 (Sockets)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6-%E4%BF%A1%E5%8F%B7-Signals"><span class="toc-text">3.6 6. 信号 (Signals)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-7-%E6%96%87%E4%BB%B6-Files"><span class="toc-text">3.7 7. 文件 (Files)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81IPC-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-text">四、IPC 机制的对比与选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91"><span class="toc-text">五、安全考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-32.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>