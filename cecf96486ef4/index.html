<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IPC (Inter-Process Communication) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IPC (Inter-Process Communication)，即进程间通信，是指在多任务操作系统中，不同进程之间进行数据交换和同步行为的一种机制。由于每个进程通常拥有独立的内存空间，不能直接访问其他进程的数据，因此 IPC 机制是构建复杂、协作型多进程应用的关键。它使得进程能够共享信息、协调活动，从而实现更强大的功能和更高的系统效率。  核心思想：克服进程间内存隔离的障碍，提供一套规范化的">
<meta property="og:type" content="article">
<meta property="og:title" content="IPC (Inter-Process Communication) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/cecf96486ef4/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="IPC (Inter-Process Communication)，即进程间通信，是指在多任务操作系统中，不同进程之间进行数据交换和同步行为的一种机制。由于每个进程通常拥有独立的内存空间，不能直接访问其他进程的数据，因此 IPC 机制是构建复杂、协作型多进程应用的关键。它使得进程能够共享信息、协调活动，从而实现更强大的功能和更高的系统效率。  核心思想：克服进程间内存隔离的障碍，提供一套规范化的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg">
<meta property="article:published_time" content="2026-01-04T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-24T10:30:01.057Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="异步编程">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="编程技巧">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "IPC (Inter-Process Communication) 详解",
  "url": "https://blog.tbf1211.xx.kg/cecf96486ef4/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-06.jpg",
  "datePublished": "2026-01-04T22:24:00.000Z",
  "dateModified": "2026-02-24T10:30:01.057Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/cecf96486ef4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IPC (Inter-Process Communication) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">551</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-06.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">IPC (Inter-Process Communication) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">IPC (Inter-Process Communication) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>IPC (Inter-Process Communication)</strong>，即<strong>进程间通信</strong>，是指在多任务操作系统中，不同进程之间进行数据交换和同步行为的一种机制。由于每个进程通常拥有独立的内存空间，不能直接访问其他进程的数据，因此 IPC 机制是构建复杂、协作型多进程应用的关键。它使得进程能够共享信息、协调活动，从而实现更强大的功能和更高的系统效率。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>克服进程间内存隔离的障碍，提供一套规范化的方法，让独立运行的进程能够安全、有效地交换数据和同步操作。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-IPC？"><a href="#一、为什么需要-IPC？" class="headerlink" title="一、为什么需要 IPC？"></a>一、为什么需要 IPC？</h2><p>在现代操作系统中，进程是资源分配和调度的基本单位。为了保证系统的稳定性和安全性，操作系统为每个进程分配独立的内存地址空间。这种内存隔离虽然能有效防止一个进程的错误影响其他进程，但也带来了以下问题：</p>
<ol>
<li><strong>信息共享</strong>：进程间需要共享数据或状态。例如，一个数据生产者进程生成数据，一个数据消费者进程处理数据。</li>
<li><strong>模块化</strong>：将一个大型复杂的应用程序拆分成多个独立的、职责单一的进程，每个进程专注于特定任务。这些进程需要相互协作才能完成整体功能。</li>
<li><strong>性能提升</strong>：通过并行处理，将不同的任务分配给不同的进程在多核处理器上同时执行，从而提高计算效率。</li>
<li><strong>事件通知</strong>：一个进程需要通知另一个进程某个事件已经发生。</li>
<li><strong>资源管理</strong>：多个进程需要协调对共享资源的访问，以避免竞态条件和数据不一致。</li>
</ol>
<p>IPC 机制就是为了解决这些问题而生，它提供了多种不同的通信模型，以适应不同的应用场景和性能需求。</p>
<h2 id="二、IPC-的核心概念"><a href="#二、IPC-的核心概念" class="headerlink" title="二、IPC 的核心概念"></a>二、IPC 的核心概念</h2><p>在深入 IPC 机制之前，理解几个相关概念非常重要：</p>
<ol>
<li><strong>进程 (Process)</strong>：程序的一次执行过程，拥有独立的内存地址空间、文件描述符、寄存器等资源。进程是操作系统进行资源分配和调度的基本单位。</li>
<li><strong>线程 (Thread)</strong>：是进程内的执行单元，共享进程的内存地址空间和大部分资源。线程间通信通常比进程间通信更简单（直接访问共享内存），但共享状态也带来了同步的复杂性。本文主要关注进程间通信。</li>
<li><strong>同步 (Synchronization)</strong>：协调多个并发进程或线程的操作，以确保它们按照预期的顺序执行，并正确访问共享资源。常见的同步原语有互斥锁 (Mutex)、信号量 (Semaphore) 等。</li>
<li><strong>并发 (Concurrency) 与 并行 (Parallelism)</strong>：<ul>
<li><strong>并发</strong>：指多个任务在同一时间段内交替执行，宏观上看起来是同时进行，微观上可能在一个核上分时执行。</li>
<li><strong>并行</strong>：指多个任务在同一时刻真正地同时执行，需要多核处理器支持。</li>
</ul>
</li>
</ol>
<h2 id="三、常见的-IPC-机制"><a href="#三、常见的-IPC-机制" class="headerlink" title="三、常见的 IPC 机制"></a>三、常见的 IPC 机制</h2><p>操作系统提供了多种 IPC 机制，每种机制都有其特点和适用场景。</p>
<h3 id="3-1-1-管道-Pipes"><a href="#3-1-1-管道-Pipes" class="headerlink" title="3.1 1. 管道 (Pipes)"></a>3.1 1. 管道 (Pipes)</h3><p><strong>定义</strong>：管道是最早也是最简单的 IPC 形式之一。它提供一个字节流的通信通道，数据以先进先出 (FIFO) 的方式传输。</p>
<p><strong>分类</strong>：</p>
<ul>
<li><p><strong>匿名管道 (Anonymous Pipes)</strong>：</p>
<ul>
<li><strong>特点</strong>：通常用于具有<strong>亲缘关系</strong>的进程（如父子进程或兄弟进程）之间通信。它由操作系统内核维护，没有文件系统中的对应名称。通常是半双工（单向），如果需要双向通信，需要创建两个管道。</li>
<li><strong>工作原理</strong>：父进程创建管道后，<code>fork</code> 出子进程，子进程会继承父进程的文件描述符。父子进程通过读写管道的两端进行通信。</li>
<li><strong>局限性</strong>：生命周期与创建它的进程组绑定，进程终止管道也消失。只能在同一台机器上使用。</li>
</ul>
</li>
<li><p><strong>命名管道 (Named Pipes &#x2F; FIFOs)</strong>：</p>
<ul>
<li><strong>特点</strong>：克服了匿名管道的局限性，允许<strong>无亲缘关系</strong>的进程之间进行通信。它在文件系统中有一个对应的名称（像普通文件一样），可以被任何有权限的进程打开和读写。</li>
<li><strong>工作原理</strong>：一个进程通过文件路径创建命名管道，另一个或多个进程打开该路径进行读写。</li>
<li><strong>局限性</strong>：仍然是半双工，且通常仅限于同一台机器上的进程。</li>
</ul>
</li>
</ul>
<p><strong>Mermaid 图示 (匿名管道)：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[Parent Process] -- Creates Pipe --&gt; B(Pipe)
    A -- forks --&gt; C[Child Process]
    A -- Writes to Write End --&gt; B
    C -- Reads from Read End --&gt; B
  </pre></div>

<p><strong>Python 示例 (匿名管道)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anonymous_pipe_example</span>():</span><br><span class="line">    r, w = os.pipe() <span class="comment"># 创建一个管道，r是读端文件描述符，w是写端文件描述符</span></span><br><span class="line"></span><br><span class="line">    pid = os.fork()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pid &gt; <span class="number">0</span>: <span class="comment"># 父进程</span></span><br><span class="line">        os.close(r) <span class="comment"># 父进程关闭读端</span></span><br><span class="line">        message = <span class="string">&quot;Hello from parent!&quot;</span></span><br><span class="line">        os.write(w, message.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 写入管道</span></span><br><span class="line">        os.close(w) <span class="comment"># 关闭写端</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Parent sent: &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        os.wait() <span class="comment"># 等待子进程结束</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 子进程</span></span><br><span class="line">        os.close(w) <span class="comment"># 子进程关闭写端</span></span><br><span class="line">        data = os.read(r, <span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># 从管道读取数据</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Child received: &#x27;<span class="subst">&#123;data&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        os.close(r) <span class="comment"># 关闭读端</span></span><br><span class="line">        os._exit(<span class="number">0</span>) <span class="comment"># 子进程退出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- Anonymous Pipe Example ---&quot;</span>)</span><br><span class="line">    anonymous_pipe_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-消息队列-Message-Queues"><a href="#3-2-2-消息队列-Message-Queues" class="headerlink" title="3.2 2. 消息队列 (Message Queues)"></a>3.2 2. 消息队列 (Message Queues)</h3><p><strong>定义</strong>：消息队列是存放在内核中的消息链表，允许进程以间接的方式发送和接收离散的消息。每个消息都有一个类型，接收进程可以根据类型选择性地接收消息。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>解耦</strong>：发送者和接收者之间无需直接连接，发送者将消息放入队列即可，接收者可以随时从队列中取出。</li>
<li><strong>异步</strong>：发送消息后，发送者可以立即继续执行，无需等待接收者处理。</li>
<li><strong>存储在内核</strong>：消息在发送后会存储在内核中，直到被接收者取走，保证消息的持久性（在系统重启前）。</li>
<li><strong>消息优先级</strong>：某些实现允许为消息指定优先级。</li>
</ul>
<p><strong>Mermaid 图示：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    P1[Process A] -- Puts Message --&gt; MQ(Message Queue in Kernel)
    P2[Process B] -- Gets Message --&gt; MQ
    MQ -- Stores Messages --&gt; Data[Message 1, Message 2, ...]
  </pre></div>

<p><strong>Python 示例 (使用 <code>multiprocessing.Queue</code>)：</strong></p>
<p><code>multiprocessing.Queue</code> 是 Python <code>multiprocessing</code> 模块提供的高级抽象，它在底层可能使用管道或更复杂的机制实现，但提供了消息队列的语义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sender</span>(<span class="params">queue</span>):</span><br><span class="line">    message = <span class="string">&quot;Data from Sender&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sender: Sending &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    queue.put(message)</span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 模拟工作</span></span><br><span class="line">    queue.put(<span class="string">&quot;STOP&quot;</span>) <span class="comment"># 发送停止信号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sender: Done.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiver</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Receiver: Waiting for messages...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        message = queue.get() <span class="comment"># 从队列获取消息</span></span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;STOP&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Receiver: Received STOP signal. Exiting.&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Receiver: Received &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>) <span class="comment"># 模拟处理消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message_queue_example</span>():</span><br><span class="line">    q = multiprocessing.Queue() <span class="comment"># 创建一个队列</span></span><br><span class="line"></span><br><span class="line">    p_sender = multiprocessing.Process(target=sender, args=(q,))</span><br><span class="line">    p_receiver = multiprocessing.Process(target=receiver, args=(q,))</span><br><span class="line"></span><br><span class="line">    p_sender.start()</span><br><span class="line">    p_receiver.start()</span><br><span class="line"></span><br><span class="line">    p_sender.join()</span><br><span class="line">    p_receiver.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Message Queue Example ---&quot;</span>)</span><br><span class="line">    message_queue_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-共享内存-Shared-Memory"><a href="#3-3-3-共享内存-Shared-Memory" class="headerlink" title="3.3 3. 共享内存 (Shared Memory)"></a>3.3 3. 共享内存 (Shared Memory)</h3><p><strong>定义</strong>：共享内存是最高效的 IPC 方式。它允许两个或多个进程直接访问同一块物理内存区域。一旦内存映射建立，进程可以直接读写该内存，无需通过内核。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>速度最快</strong>：避免了数据在内核空间和用户空间之间的复制，实现了直接访问。</li>
<li><strong>复杂性高</strong>：由于多个进程直接访问同一块内存，必须使用同步机制（如信号量、互斥锁）来避免竞态条件和数据不一致。</li>
<li><strong>数据结构</strong>：开发者需要自行管理共享内存中的数据结构和布局。</li>
</ul>
<p><strong>Mermaid 图示：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[Process A] -- Maps Segment --&gt; SM(Shared Memory Segment)
    B[Process B] -- Maps Segment --&gt; SM
    A -- Reads&#x2F;Writes Data --&gt; SM
    B -- Reads&#x2F;Writes Data --&gt; SM
    A --- S1[Semaphore&#x2F;Mutex]
    B --- S1
    S1 -- Controls Access --&gt; SM
  </pre></div>

<p><strong>Python 示例 (使用 <code>multiprocessing.shared_memory</code>)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> shared_memory</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writer</span>(<span class="params">name, shape, dtype</span>):</span><br><span class="line">    <span class="comment"># 重新连接到已存在的共享内存</span></span><br><span class="line">    shm_b = shared_memory.SharedMemory(name=name)</span><br><span class="line">    <span class="comment"># 创建一个Numpy数组视图</span></span><br><span class="line">    np_array = np.ndarray(shape, dtype=dtype, buffer=shm_b.buf)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Writer: Writing to shared memory...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        np_array[i] = i * <span class="number">10</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Writer: Wrote <span class="subst">&#123;np_array[i]&#125;</span>&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Writer: Done writing.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    shm_b.close() <span class="comment"># 关闭共享内存连接，但不会销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reader</span>(<span class="params">name, shape, dtype</span>):</span><br><span class="line">    <span class="comment"># 重新连接到已存在的共享内存</span></span><br><span class="line">    shm_c = shared_memory.SharedMemory(name=name)</span><br><span class="line">    np_array = np.ndarray(shape, dtype=dtype, buffer=shm_c.buf)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Reader: Reading from shared memory...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Reader: Read <span class="subst">&#123;np_array[i]&#125;</span>&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.7</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Reader: Done reading.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    shm_c.close() <span class="comment"># 关闭共享内存连接，但不会销毁它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shared_memory_example</span>():</span><br><span class="line">    <span class="comment"># 创建一个共享内存块</span></span><br><span class="line">    <span class="comment"># 注意：需要手动管理共享内存的生命周期</span></span><br><span class="line">    a = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]) <span class="comment"># 示例数据</span></span><br><span class="line">    shm = shared_memory.SharedMemory(create=<span class="literal">True</span>, size=a.nbytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过 Numpy 视图将数据写入共享内存</span></span><br><span class="line">    np_array_orig = np.ndarray(a.shape, dtype=a.dtype, buffer=shm.buf)</span><br><span class="line">    np_array_orig[:] = a[:] <span class="comment"># 将初始数据复制到共享内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Shared memory created with name: <span class="subst">&#123;shm.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p_writer = mp.Process(target=writer, args=(shm.name, a.shape, a.dtype))</span><br><span class="line">    p_reader = mp.Process(target=reader, args=(shm.name, a.shape, a.dtype))</span><br><span class="line"></span><br><span class="line">    p_writer.start()</span><br><span class="line">    p_reader.start()</span><br><span class="line"></span><br><span class="line">    p_writer.join()</span><br><span class="line">    p_reader.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在所有进程都完成使用后，解除共享内存的链接和销毁</span></span><br><span class="line">    shm.close()</span><br><span class="line">    shm.unlink() <span class="comment"># 销毁共享内存段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Shared Memory Example ---&quot;</span>)</span><br><span class="line">    shared_memory_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-信号量-Semaphores"><a href="#3-4-4-信号量-Semaphores" class="headerlink" title="3.4 4. 信号量 (Semaphores)"></a>3.4 4. 信号量 (Semaphores)</h3><p><strong>定义</strong>：信号量是用于控制对共享资源访问的同步原语。它本质上是一个计数器，用于管理对资源的并发访问数量。</p>
<p><strong>类型</strong>：</p>
<ul>
<li><strong>二进制信号量 (Binary Semaphore &#x2F; Mutex)</strong>：值只能是 0 或 1，用于实现互斥访问（一次只有一个进程能访问资源）。</li>
<li><strong>计数信号量 (Counting Semaphore)</strong>：值可以大于 1，用于控制对具有多个相同实例的资源（如数据库连接池）的访问。</li>
</ul>
<p><strong>操作</strong>：</p>
<ul>
<li><code>P</code> (Wait&#x2F;Acquire&#x2F;Down)：尝试获取资源。如果信号量值大于 0，则减 1 并继续执行；否则，进程阻塞直到信号量大于 0。</li>
<li><code>V</code> (Signal&#x2F;Release&#x2F;Up)：释放资源。将信号量值加 1。如果有进程在等待该信号量，则唤醒一个进程。</li>
</ul>
<p><strong>Python 示例 (使用 <code>multiprocessing.Semaphore</code>)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_with_semaphore</span>(<span class="params">semaphore, <span class="built_in">id</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>: Trying to acquire resource.&quot;</span>)</span><br><span class="line">    semaphore.acquire() <span class="comment"># P 操作，获取信号量</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>: Acquired resource. Working for 1 second.&quot;</span>)</span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.5</span>, <span class="number">2</span>)) <span class="comment"># 模拟访问资源并工作</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        semaphore.release() <span class="comment"># V 操作，释放信号量</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>: Released resource.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">semaphore_example</span>():</span><br><span class="line">    <span class="comment"># 创建一个计数信号量，初始值为2，表示最多允许2个进程同时访问资源</span></span><br><span class="line">    semaphore = multiprocessing.Semaphore(<span class="number">2</span>)</span><br><span class="line">    processes = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker_with_semaphore, args=(semaphore, i))</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All workers finished.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Semaphore Example ---&quot;</span>)</span><br><span class="line">    semaphore_example()</span><br></pre></td></tr></table></figure>

<p><strong>Go 语言注意事项</strong>：Go 语言的 <code>sync.Mutex</code> 和 <code>sync.WaitGroup</code> 等同步原语主要用于<strong>goroutine (协程)</strong> 之间的同步，它们是在单个进程内部的<strong>线程级</strong>同步。对于<strong>进程间</strong>的信号量，Go 语言标准库没有直接提供跨平台的抽象，通常需要通过 Cgo 调用操作系统的特定 API (如 Linux 的 <code>sysv_sem</code> 或 POSIX 信号量)。</p>
<h3 id="3-5-5-套接字-Sockets"><a href="#3-5-5-套接字-Sockets" class="headerlink" title="3.5 5. 套接字 (Sockets)"></a>3.5 5. 套接字 (Sockets)</h3><p><strong>定义</strong>：套接字是网络通信的基石，但也可以用于同一台机器上的进程间通信。它提供了一个抽象层，允许进程通过标准网络协议（TCP&#x2F;IP、UDP）进行数据交换。</p>
<p><strong>分类</strong>：</p>
<ul>
<li><strong>Unix 域套接字 (Unix Domain Sockets &#x2F; UDS)</strong>：<ul>
<li><strong>特点</strong>：仅限于同一台机器上的进程间通信。它不涉及网络协议栈，直接通过文件系统路径进行通信。效率比网络套接字高，且具有文件系统权限控制。</li>
<li><strong>工作原理</strong>：客户端和服务器进程通过一个文件系统路径（例如 <code>/tmp/my_socket</code>）建立连接。</li>
</ul>
</li>
<li><strong>网络套接字 (Network Sockets)</strong>：<ul>
<li><strong>特点</strong>：可以通过网络在不同主机之间进行通信，也可以在同一主机上进行通信。使用 IP 地址和端口号来识别通信端点。</li>
<li><strong>工作原理</strong>：客户端和服务器进程通过 IP 地址和端口号建立连接。</li>
</ul>
</li>
</ul>
<p><strong>Mermaid 图示 (客户端-服务器模式)：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    C[Client Process] -- Connects to --&gt; S(Server Process)
    S -- Listens on Socket --&gt; Sock(Socket Address)
    C -- Sends Data --&gt; Sock
    S -- Receives Data --&gt; Sock
    Sock -- Binds to --&gt; IP_Port[IP Address:Port &#x2F; Unix Path]
  </pre></div>

<p><strong>Python 示例 (Unix 域套接字)：</strong></p>
<ul>
<li><p><strong>服务器端 (<code>uds_server.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uds_server</span>():</span><br><span class="line">    <span class="comment"># 确保 socket 文件不存在</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(SOCKET_PATH):</span><br><span class="line">        os.remove(SOCKET_PATH)</span><br><span class="line"></span><br><span class="line">    server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line">    server.bind(SOCKET_PATH)</span><br><span class="line">    server.listen(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;UDS Server listening on <span class="subst">&#123;SOCKET_PATH&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Accepted connection from <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        message = data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Server received: &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        conn.sendall(<span class="string">f&quot;Server echoed: <span class="subst">&#123;message&#125;</span>&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br><span class="line">    server.close()</span><br><span class="line">    os.remove(SOCKET_PATH)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;UDS Server closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uds_server()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端 (<code>uds_client.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uds_client</span>():</span><br><span class="line">    client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect(SOCKET_PATH)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;UDS Client connected to <span class="subst">&#123;SOCKET_PATH&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        messages = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;How are you?&quot;</span>, <span class="string">&quot;This is a test.&quot;</span>, <span class="string">&quot;quit&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> msg <span class="keyword">in</span> messages:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Client sending: &#x27;<span class="subst">&#123;msg&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">            client.sendall(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            response = client.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Client received: &#x27;<span class="subst">&#123;response&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Client error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        client.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;UDS Client closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 启动客户端之前，请确保 uds_server.py 已经在运行</span></span><br><span class="line">    uds_client()</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Golang 示例 (Unix 域套接字)：</strong></p>
<ul>
<li><p><strong>服务器端 (<code>uds_server.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example_go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 清理之前的 socket 文件</span></span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(SOCKET_PATH); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Remove(SOCKET_PATH)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;unix&quot;</span>, SOCKET_PATH)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error listening:&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	fmt.Println(<span class="string">&quot;UDS Server listening on&quot;</span>, SOCKET_PATH)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error accepting:&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Accepted connection from&quot;</span>, conn.RemoteAddr())</span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// fmt.Println(&quot;Error reading:&quot;, err.Error())</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		message := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Println(<span class="string">&quot;Server received:&quot;</span>, message)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> message == <span class="string">&quot;quit&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		response := []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;Server echoed: %s&quot;</span>, message))</span><br><span class="line">		conn.Write(response)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Connection closed for&quot;</span>, conn.RemoteAddr())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端 (<code>uds_client.go</code>)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SOCKET_PATH = <span class="string">&quot;/tmp/uds_socket_example_go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;unix&quot;</span>, SOCKET_PATH)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error connecting:&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	fmt.Println(<span class="string">&quot;UDS Client connected to&quot;</span>, SOCKET_PATH)</span><br><span class="line"></span><br><span class="line">	messages := []<span class="type">string</span>&#123;<span class="string">&quot;Hello Go&quot;</span>, <span class="string">&quot;How are you Go?&quot;</span>, <span class="string">&quot;This is a Go test.&quot;</span>, <span class="string">&quot;quit&quot;</span>&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, msg := <span class="keyword">range</span> messages &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Client sending:&quot;</span>, msg)</span><br><span class="line">		conn.Write([]<span class="type">byte</span>(msg))</span><br><span class="line"></span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(time.Second * <span class="number">2</span>)) <span class="comment">// 设置读取超时</span></span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Client read timeout&quot;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;Error reading:&quot;</span>, err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		response := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Println(<span class="string">&quot;Client received:&quot;</span>, response)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;UDS Client closed.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行 Go 示例：</strong></p>
<ol>
<li>在一个终端中运行 <code>go run uds_server.go</code></li>
<li>在另一个终端中运行 <code>go run uds_client.go</code></li>
</ol>
</li>
</ul>
<h3 id="3-6-6-信号-Signals"><a href="#3-6-6-信号-Signals" class="headerlink" title="3.6 6. 信号 (Signals)"></a>3.6 6. 信号 (Signals)</h3><p><strong>定义</strong>：信号是一种非常轻量级的 IPC 机制，用于通知一个进程某个事件的发生。它不能携带大量数据，通常只包含一个信号编号。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>异步通知</strong>：信号的发送是异步的，接收进程可以在任何时候收到并处理信号。</li>
<li><strong>信息量小</strong>：只能传递有限的信息（信号类型）。</li>
<li><strong>常见用途</strong>：终止进程 (SIGTERM, SIGKILL)、中断进程 (SIGINT)、暂停进程 (SIGSTOP, SIGTSTP) 等。</li>
<li><strong>不可靠性</strong>：经典 Unix 信号是不可靠的（可能会丢失或重复），但现代 POSIX 信号提供了可靠性增强。</li>
</ul>
<p><strong>Python 示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signum, frame</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;os.getpid()&#125;</span>: Received signal <span class="subst">&#123;signum&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> signum == signal.SIGUSR1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Custom action for SIGUSR1!&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> signum == signal.SIGTERM:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Gracefully shutting down...&quot;</span>)</span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sender_process</span>(<span class="params">pid</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sender <span class="subst">&#123;os.getpid()&#125;</span>: Sending SIGUSR1 to <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br><span class="line">    os.kill(pid, signal.SIGUSR1) <span class="comment"># 发送自定义信号1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sender <span class="subst">&#123;os.getpid()&#125;</span>: Sending SIGTERM to <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br><span class="line">    os.kill(pid, signal.SIGTERM) <span class="comment"># 发送终止信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiver_process</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Receiver <span class="subst">&#123;os.getpid()&#125;</span>: Waiting for signals...&quot;</span>)</span><br><span class="line">    signal.signal(signal.SIGUSR1, signal_handler) <span class="comment"># 注册SIGUSR1的处理函数</span></span><br><span class="line">    signal.signal(signal.SIGTERM, signal_handler) <span class="comment"># 注册SIGTERM的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保持进程运行，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">100</span>) <span class="comment"># 挂起进程，等待信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_example</span>():</span><br><span class="line">    pid = os.fork()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pid &gt; <span class="number">0</span>: <span class="comment"># 父进程 (作为发送者)</span></span><br><span class="line">        sender_process(pid)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 子进程 (作为接收者)</span></span><br><span class="line">        receiver_process()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- Signal Example ---&quot;</span>)</span><br><span class="line">    signal_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-7-7-文件-Files"><a href="#3-7-7-文件-Files" class="headerlink" title="3.7 7. 文件 (Files)"></a>3.7 7. 文件 (Files)</h3><p><strong>定义</strong>：最简单直接的 IPC 方式，一个进程将数据写入文件，另一个进程从该文件读取数据。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>持久性</strong>：数据存储在磁盘上，即使进程终止也不会丢失。</li>
<li><strong>简单易用</strong>：操作和理解相对简单。</li>
<li><strong>性能差</strong>：涉及到磁盘 I&#x2F;O，速度远低于内存中的 IPC 方式。</li>
<li><strong>同步困难</strong>：需要额外的机制来协调读写顺序和文件锁定，以避免竞态条件。</li>
<li><strong>适用场景</strong>：不追求实时性、需要数据持久化、数据量不大的场景。</li>
</ul>
<h2 id="四、IPC-机制的对比与选择"><a href="#四、IPC-机制的对比与选择" class="headerlink" title="四、IPC 机制的对比与选择"></a>四、IPC 机制的对比与选择</h2><p>不同的 IPC 机制有不同的性能、复杂性和适用场景。下表总结了它们的优缺点：</p>
<table>
<thead>
<tr>
<th align="left">特性 &#x2F; 机制</th>
<th align="left">管道 (Pipes)</th>
<th align="left">消息队列 (Message Queues)</th>
<th align="left">共享内存 (Shared Memory)</th>
<th align="left">信号量 (Semaphores)</th>
<th align="left">套接字 (Sockets)</th>
<th align="left">信号 (Signals)</th>
<th align="left">文件 (Files)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>通信方式</strong></td>
<td align="left">字节流</td>
<td align="left">消息 (离散)</td>
<td align="left">直接内存访问</td>
<td align="left">仅同步</td>
<td align="left">字节流 (流式) &#x2F; 数据报 (UDP)</td>
<td align="left">异步通知</td>
<td align="left">字节流 (流式)</td>
</tr>
<tr>
<td align="left"><strong>数据传输量</strong></td>
<td align="left">中等</td>
<td align="left">中等</td>
<td align="left">大 (或任意)</td>
<td align="left">无</td>
<td align="left">中等至大</td>
<td align="left">无 (仅信号类型)</td>
<td align="left">大</td>
</tr>
<tr>
<td align="left"><strong>传输速度</strong></td>
<td align="left">中等</td>
<td align="left">中等</td>
<td align="left"><strong>最快</strong></td>
<td align="left">极快 (同步操作)</td>
<td align="left">中等 (UDS较快, 网络较慢)</td>
<td align="left">极快</td>
<td align="left">最慢</td>
</tr>
<tr>
<td align="left"><strong>同步性</strong></td>
<td align="left">隐式同步 (阻塞读写)</td>
<td align="left">异步 (非阻塞发送接收)</td>
<td align="left"><strong>需要外部同步</strong></td>
<td align="left"><strong>仅用于同步</strong></td>
<td align="left">异步 (非阻塞模式)</td>
<td align="left">异步</td>
<td align="left">需要外部同步</td>
</tr>
<tr>
<td align="left"><strong>亲缘关系</strong></td>
<td align="left">匿名：父子；命名：无</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
<td align="left">无亲缘关系</td>
</tr>
<tr>
<td align="left"><strong>跨网络</strong></td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left"><strong>是</strong> (网络套接字)</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left">简单</td>
<td align="left">中等</td>
<td align="left">复杂 (需同步)</td>
<td align="left">中等</td>
<td align="left">中等 (服务器&#x2F;客户端模式)</td>
<td align="left">简单</td>
<td align="left">简单</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">Shell管道、日志重定向</td>
<td align="left">任务队列、工作流</td>
<td align="left">大型数据交换、图像处理</td>
<td align="left">资源访问控制</td>
<td align="left">客户端-服务器通信、微服务</td>
<td align="left">进程管理、事件通知</td>
<td align="left">配置、日志、持久化</td>
</tr>
</tbody></table>
<h2 id="五、安全考虑"><a href="#五、安全考虑" class="headerlink" title="五、安全考虑"></a>五、安全考虑</h2><p>在使用 IPC 机制时，安全性是一个不容忽视的方面：</p>
<ol>
<li><strong>数据完整性和机密性</strong>：通过 IPC 传输的数据可能包含敏感信息。需要考虑数据是否会被窃听或篡改。对于跨网络通信，HTTPS&#x2F;SSL&#x2F;TLS 等加密协议是必要的。</li>
<li><strong>权限控制</strong>：<ul>
<li><strong>命名管道和 Unix 域套接字</strong>：它们在文件系统中存在，可以通过文件权限 (rwx) 控制哪些用户或组的进程可以访问。</li>
<li><strong>共享内存</strong>：如果未正确控制访问权限，可能导致任意进程读写共享内存，造成数据破坏。</li>
</ul>
</li>
<li><strong>缓冲区溢出</strong>：在消息传递或共享内存中，如果未对输入数据进行大小检查，可能导致缓冲区溢出漏洞。</li>
<li><strong>拒绝服务 (DoS)</strong>：攻击者可能通过发送大量消息、占用大量共享内存或滥用信号量来耗尽系统资源，导致正常服务无法进行。</li>
<li><strong>竞态条件 (Race Conditions)</strong>：在共享内存或文件通信中，如果不对共享资源的访问进行正确同步，可能导致数据不一致。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>IPC 是现代操作系统中构建复杂、高性能应用程序的基石。每种 IPC 机制都有其独特的优缺点和适用场景。在选择 IPC 机制时，开发者需要综合考虑数据传输量、传输速度、同步需求、进程关系、跨网络需求以及安全等因素。正确地选择和实现 IPC，不仅能提升应用程序的性能和稳定性，还能提高系统的模块化和可维护性。深入理解这些机制的工作原理和限制，是成为一名优秀系统开发者的必备技能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/cecf96486ef4/">https://blog.tbf1211.xx.kg/cecf96486ef4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-06.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">传统命令行工具的现代补强与替代方案详解</div></div><div class="info-2"><div class="info-item-1"> 随着技术的发展和用户体验需求的变化，许多经典的 Unix&#x2F;Linux 命令行工具虽然功能强大且稳定，但在交互性、可视化、性能和便捷性方面，逐渐暴露出一些局限性。为了提升命令行操作的效率、可读性和舒适度，社区涌现出大量用 Go、Rust 等现代语言编写的“补强”或“替代”工具。本文将详细介绍一系列旨在现代化命令行体验的工具。  核心思想：并非完全取代经典工具，而是通过提供更丰富的功能、更美观的输出、更快的执行速度和更友好的交互方式，来增强或补充传统命令行工具的能力，以适应现代开发和系统管理的需求。   一、文件查看与内容处理1.1 cat 的补强：bat 传统工具：cat (concatenate files and print on the standard output) 现代补强：bat bat 是 cat 的一个语法高亮、分页和 Git 集成增强版。它不仅能显示文件内容，还能： 语法高亮：对代码文件自动进行语法高亮显示，支持多种编程语言。 行号显示：默认显示行号，方便代码审查和定位。 Git 集成：在显示文件时，会自动显示 Git 变更标记（如新增、修改）。 分...</div></div></div></a><a class="pagination-related" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang sqlc 框架详解</div></div><div class="info-2"><div class="info-item-1"> sqlc 是一个SQL 编译器 (SQL Compiler)，它能够根据用户定义的 SQL 查询和数据库 Schema 自动生成类型安全 (type-safe) 的 Go 代码。与传统的 ORM (Object-Relational Mapping) 工具不同，sqlc 的核心理念是“写 SQL，生成 Go (Write SQL, Get Go)”。开发者专注于编写原生的 SQL 查询，sqlc 则负责将其转换为易于在 Go 应用程序中使用的、无反射、高性能的 API。  核心思想：保持 SQL 源码作为事实的唯一来源，并通过代码生成器将其无缝集成到 Go 代码中，实现类型安全和高效的数据库操作。 它不尝试将 SQL 抽象化，而是将 SQL 语句转换为可直接调用的 Go 函数。    一、为什么选择 sqlc？在 Golang 中进行数据库操作，开发者通常面临几种选择：  直接使用 database/sql 库：最底层、最灵活，但需要手动处理行扫描、错误检查、参数绑定等，代码量大且容易出错。 使用传统 ORM (如 GORM, XORM)：提供了高层次的抽象，通过 Go 结构体...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/4a9afa2dd79a/" title="深入理解同步&#x2F;异步与阻塞&#x2F;非阻塞"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-19</div><div class="info-item-2">深入理解同步&#x2F;异步与阻塞&#x2F;非阻塞</div></div><div class="info-2"><div class="info-item-1"> 在计算机科学和并发编程中，同步&#x2F;异步 (Synchronous&#x2F;Asynchronous) 和 阻塞&#x2F;非阻塞 (Blocking&#x2F;Non-blocking) 是描述程序执行流程和资源访问方式的两个核心概念。它们经常被一起讨论，但实际上是从不同的角度来描述系统行为的。理解这两对概念对于设计高性能、响应式的系统至关重要。  核心思想：  同步&#x2F;异步 描述的是消息通知机制：调用者何时收到被调用者的结果。 阻塞&#x2F;非阻塞 描述的是调用者等待结果时的状态：调用者是否可以继续执行其他任务。     一、同步 (Synchronous) 与 异步 (Asynchronous)同步 (Synchronous) 和 异步 (Asynchronous) 关注的是一个任务的调用者 (Caller) 何时才能获得被调用者 (Callee) 的执行结果或通知。 1.1 同步 (Synchronous)当一个任务是同步的时候，调用者在调用被调用者后，必须等待被调用者完成其全部工作并返回结果后，才能继续执行调用者自己的后续操作。 特点：  顺序执行：...</div></div></div></a><a class="pagination-related" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-01</div><div class="info-item-2">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</div></div><div class="info-2"><div class="info-item-1"> 在 Golang 中，内置的 map 类型不是并发安全的。当多个 goroutine 同时对 map 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 map，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 sync.Mutex 保护 map、使用 sync.RWMutex 保护 map，以及 Go 1.9 引入的 sync.Map，并对它们的特点、适用场景和性能进行对比分析。  核心问题：Go 内置 map 非并发安全。核心解决方案：  sync.Mutex：最简单粗暴，读写都加排他锁。 sync.RWMutex：读写分离锁，允许多个读操作并行，写操作独占。 sync.Map：专为读多写少、键不冲突或键值对持续增长的场景优化，内置无锁或乐观锁机制。     一、Go 内置 map 的并发问题Go 语言设计者有意将内置 map 设计为非并发安全的，主要出于以下考虑：  性能：为了避免在每次 map 操作时都承担锁的开销，从而在单线...</div></div></div></a><a class="pagination-related" href="/90492206afee/" title="Java BIO、NIO、AIO 对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="info-item-2">Java BIO、NIO、AIO 对比详解</div></div><div class="info-2"><div class="info-item-1"> Java I&#x2F;O (Input&#x2F;Output) 是应用程序与外部设备之间进行数据传输的桥梁。随着并发编程和高性能网络应用的需求日益增长，Java 提供了多种 I&#x2F;O 模型，以适应不同的使用场景。其中，最核心的三种模型是 BIO (Blocking I&#x2F;O)、NIO (Non-blocking I&#x2F;O) 和 AIO (Asynchronous I&#x2F;O)，它们在处理数据流和网络通信方面有着显著的区别。  核心思想：理解 BIO、NIO 和 AIO 的根本差异在于它们对 I&#x2F;O 操作的阻塞特性、线程管理方式 以及 事件通知机制 的处理。这直接影响着应用在并发、吞吐量和资源利用率方面的表现。   一、同步与异步，阻塞与非阻塞在深入探讨 BIO、NIO、AIO 之前，我们首先明确两个基本概念：  同步 (Synchronous) vs 异步 (Asynchronous)：  同步：发起一个 I&#x2F;O 操作后，调用者需要等待操作完成才能继续执行后续任务。 异步：发起一个 I&#x2F;O 操作后，调用者可以立即返...</div></div></div></a><a class="pagination-related" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-20</div><div class="info-item-2">测试驱动开发 (TDD) 详解</div></div><div class="info-2"><div class="info-item-1"> 测试驱动开发 (Test-Driven Development, TDD) 是一种软件开发方法，它要求开发者在编写任何功能代码之前，先编写测试代码。这个过程遵循一个严格的循环：红-绿-重构 (Red-Green-Refactor)。TDD 的核心思想是通过测试来驱动代码的设计和实现，从而提高代码质量、可维护性和开发效率。  核心思想：先写失败的测试，再写刚刚好通过测试的代码，然后重构代码。    一、TDD 简介与核心原则TDD 是由 Kent Beck 在极限编程 (eXtreme Programming, XP) 中推广的一种实践。它不仅仅是一种测试技术，更是一种强大的设计工具，能够帮助开发者构建出更健壮、更清晰、更易于维护的软件系统。 1.1 TDD 的定义TDD 是一种软件开发流程，其主要特征是在编写实际的功能代码之前，先为即将实现的功能编写自动化测试。这些测试最初会失败（Red），然后开发者编写最少量的代码使其通过（Green），最后对代码进行优化和清理（Refactor），并确保所有测试仍然通过。 1.2 TDD 的核心原则：红-绿-重构 (Red-Green-Re...</div></div></div></a><a class="pagination-related" href="/26cdb2447b3d/" title="WebView 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">WebView 详解</div></div><div class="info-2"><div class="info-item-1"> WebView 是一个嵌入式浏览器组件，允许原生移动应用程序 (Native App) 在其 UI 内部显示网页内容。它不是一个完整的 Web 浏览器应用程序，而是一个可以集成到原生应用中的控件，通过它应用可以加载并渲染 HTML、CSS 和 JavaScript 内容，从而将 Web 技术的能力引入原生界面。  核心思想：在原生应用中提供一个轻量级的、可编程的 Web 浏览器环境，实现原生与 Web 内容的无缝融合和交互。   一、什么是 WebView？WebView 本质上是一个没有地址栏、工具栏等浏览器 UI 的浏览器内核。它能够解析并渲染网页，执行 JavaScript，处理 HTTP 请求等，但这些行为都受限于其所在的宿主原生应用。开发者可以通过 WebView 将 HTML5 应用、网页、动态内容或完整的混合应用 (Hybrid App) 集成到原生应用中。 WebView 的主要作用：  在原生应用中展示网页内容，例如新闻文章、用户协议、商品详情页等。 构建混合应用，将部分或全部 UI 通过 Web 技术实现，以提高开发效率和跨平台能力。 实现应用内的授权登录流...</div></div></div></a><a class="pagination-related" href="/88fea7b52158/" title="Gzip 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-30</div><div class="info-item-2">Gzip 详解</div></div><div class="info-2"><div class="info-item-1"> Gzip 是一种广泛使用的数据压缩格式和文件格式，以及基于此格式的软件应用。它主要用于减小文件体积，以便在存储或传输时节省空间和带宽。在Web领域，Gzip压缩是提升网页加载速度、优化用户体验的关键技术之一。  核心概念：Gzip利用了DEFLATE算法对数据进行无损压缩，其优势在于压缩效率高、解压速度快，并被几乎所有现代浏览器和Web服务器广泛支持。    一、Gzip 概述与目的Gzip（GNU zip）最初是作为Unix系统中compress程序的替代品而开发的，旨在提供更高效的压缩算法。它的核心目标是：  减少文件存储空间：对于磁盘上的文件，Gzip可以显著减小其占用的存储空间。 加快数据传输速度：在网络传输中，尤其是Web传输（HTTP&#x2F;HTTPS），通过压缩数据可以减少传输量，从而降低带宽消耗并缩短数据抵达客户端的时间。 节省带宽成本：对于提供大量数据的服务提供商，减少传输数据量直接 translates to 降低带宽费用。  二、Gzip 的工作原理：DEFLATE 算法Gzip 压缩的核心是 DEFLATE 算法，它是一种无损数据压缩算法，结合了两种...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">551</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-IPC%EF%BC%9F"><span class="toc-text">一、为什么需要 IPC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IPC-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、IPC 的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84-IPC-%E6%9C%BA%E5%88%B6"><span class="toc-text">三、常见的 IPC 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E7%AE%A1%E9%81%93-Pipes"><span class="toc-text">3.1 1. 管道 (Pipes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Message-Queues"><span class="toc-text">3.2 2. 消息队列 (Message Queues)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-Shared-Memory"><span class="toc-text">3.3 3. 共享内存 (Shared Memory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphores"><span class="toc-text">3.4 4. 信号量 (Semaphores)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E5%A5%97%E6%8E%A5%E5%AD%97-Sockets"><span class="toc-text">3.5 5. 套接字 (Sockets)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6-%E4%BF%A1%E5%8F%B7-Signals"><span class="toc-text">3.6 6. 信号 (Signals)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-7-%E6%96%87%E4%BB%B6-Files"><span class="toc-text">3.7 7. 文件 (Files)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81IPC-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-text">四、IPC 机制的对比与选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91"><span class="toc-text">五、安全考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-06.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>