<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>HTTP URL 与 IP:端口 的区别详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虽然 http:&#x2F;&#x2F;127.0.0.1:1080 和 127.0.0.1:1080 都指向本地机器上的 1080 端口，但它们在含义、使用上下文和系统处理方式上存在根本区别。前者是一个完整的 URL (Uniform Resource Locator)，明确指定了协议 (Protocol)；而后者仅仅是一个 地址:端口 组合，通常用于网络服务的监听或内部配置，本身不包含协议信息。  核心思想：协">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP URL 与 IP:端口 的区别详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/84980af09d70/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="虽然 http:&#x2F;&#x2F;127.0.0.1:1080 和 127.0.0.1:1080 都指向本地机器上的 1080 端口，但它们在含义、使用上下文和系统处理方式上存在根本区别。前者是一个完整的 URL (Uniform Resource Locator)，明确指定了协议 (Protocol)；而后者仅仅是一个 地址:端口 组合，通常用于网络服务的监听或内部配置，本身不包含协议信息。  核心思想：协">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg">
<meta property="article:published_time" content="2025-08-24T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-26T11:17:13.344Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HTTP URL 与 IP:端口 的区别详解",
  "url": "https://blog.tbf1211.xx.kg/84980af09d70/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg",
  "datePublished": "2025-08-24T22:24:00.000Z",
  "dateModified": "2026-01-26T11:17:13.344Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/84980af09d70/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HTTP URL 与 IP:端口 的区别详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">521</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-10.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">HTTP URL 与 IP:端口 的区别详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">HTTP URL 与 IP:端口 的区别详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-08-24T22:24:00.000Z" title="发表于 2025-08-25 06:24:00">2025-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>虽然 <code>http://127.0.0.1:1080</code> 和 <code>127.0.0.1:1080</code> 都指向本地机器上的 1080 端口，但它们在含义、使用上下文和系统处理方式上存在根本区别。前者是一个完整的 <strong>URL (Uniform Resource Locator)</strong>，明确指定了<strong>协议 (Protocol)</strong>；而后者仅仅是一个 <strong>地址:端口</strong> 组合，通常用于网络服务的监听或内部配置，本身不包含协议信息。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>协议 (<code>http://</code>) 定义了客户端与服务端通信的方式和规则，而 <code>IP:端口</code> 仅仅标识了一个网络端点。在不同上下文中，对 <code>IP:端口</code> 的处理方式会有所不同，例如浏览器会自动补全协议，而网络编程接口通常只接收 <code>IP:端口</code> 来监听。</strong></p>
</div>
<hr>
<h2 id="一、核心概念定义"><a href="#一、核心概念定义" class="headerlink" title="一、核心概念定义"></a>一、核心概念定义</h2><p>在深入探讨两者区别之前，我们先定义几个关键概念：</p>
<h3 id="1-1-IP-地址-Internet-Protocol-Address"><a href="#1-1-IP-地址-Internet-Protocol-Address" class="headerlink" title="1.1 IP 地址 (Internet Protocol Address)"></a>1.1 IP 地址 (Internet Protocol Address)</h3><p><strong>定义</strong>：一个分配给网络上设备的数字标签，用于在计算机网络中标识和定位设备。<code>127.0.0.1</code> 是一个特殊的 IP 地址，称为<strong>回环地址 (Loopback Address)</strong> 或 <strong>本地主机 (localhost)</strong>，它总是指向当前的本机设备。这意味着对 <code>127.0.0.1</code> 的请求不会离开本机网络接口。</p>
<h3 id="1-2-端口-Port"><a href="#1-2-端口-Port" class="headerlink" title="1.2 端口 (Port)"></a>1.2 端口 (Port)</h3><p><strong>定义</strong>：一个 16 位的数字，用于标识一台计算机上的特定应用程序或服务。当数据包到达 IP 地址时，操作系统会根据端口号将其路由到正确的应用程序。常见的端口号有：</p>
<ul>
<li><code>80</code>：HTTP 协议的默认端口。</li>
<li><code>443</code>：HTTPS 协议的默认端口。</li>
<li><code>22</code>：SSH 协议的默认端口。</li>
<li><code>1080</code>：一个常用的 SOCKS 代理端口，也可以被其他任意应用程序使用。</li>
</ul>
<h3 id="1-3-URL-Uniform-Resource-Locator"><a href="#1-3-URL-Uniform-Resource-Locator" class="headerlink" title="1.3 URL (Uniform Resource Locator)"></a>1.3 URL (Uniform Resource Locator)</h3><p><strong>定义</strong>：统一资源定位符，是互联网上资源的地址。一个完整的 URL 通常包含以下部分：<br><code>scheme://host:port/path?query#fragment</code></p>
<ul>
<li><strong>Scheme (协议)</strong>：指定访问资源所需使用的协议（如 <code>http</code>, <code>https</code>, <code>ftp</code>, <code>mailto</code> 等）。</li>
<li><strong>Host (主机)</strong>：可以是域名（如 <code>www.example.com</code>）或 IP 地址（如 <code>127.0.0.1</code>）。</li>
<li><strong>Port (端口)</strong>：可选，如果省略，则使用协议的默认端口（例如 HTTP 默认为 80，HTTPS 默认为 443）。</li>
<li><strong>Path (路径)</strong>：资源在服务器上的具体路径。</li>
<li><strong>Query (查询参数)</strong>：提供额外的参数。</li>
<li><strong>Fragment (片段)</strong>：指向资源内部的特定位置。</li>
</ul>
<h3 id="1-4-HTTP-协议-Hypertext-Transfer-Protocol"><a href="#1-4-HTTP-协议-Hypertext-Transfer-Protocol" class="headerlink" title="1.4 HTTP 协议 (Hypertext Transfer Protocol)"></a>1.4 HTTP 协议 (Hypertext Transfer Protocol)</h3><p><strong>定义</strong>：超文本传输协议，是用于分布式、协作式和超媒体信息系统的应用层协议。它是万维网数据通信的基础。HTTP 规定了客户端（如浏览器）如何向服务器请求资源，以及服务器如何响应这些请求。</p>
<h2 id="二、http-127-0-0-1-1080-与-127-0-0-1-1080-的区别"><a href="#二、http-127-0-0-1-1080-与-127-0-0-1-1080-的区别" class="headerlink" title="二、http://127.0.0.1:1080 与 127.0.0.1:1080 的区别"></a>二、<code>http://127.0.0.1:1080</code> 与 <code>127.0.0.1:1080</code> 的区别</h2><table>
<thead>
<tr>
<th align="left">特征</th>
<th align="left"><code>http://127.0.0.1:1080</code> (带协议)</th>
<th align="left"><code>127.0.0.1:1080</code> (不带协议)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>含义</strong></td>
<td align="left"><strong>完整的 URL</strong>，指定使用 HTTP 协议连接本地机器的 1080 端口。</td>
<td align="left"><strong>IP 地址和端口的组合</strong>，表示一个网络端点。不包含协议信息。</td>
</tr>
<tr>
<td align="left"><strong>协议信息</strong></td>
<td align="left"><strong>显式指定</strong> HTTP 协议。</td>
<td align="left"><strong>不包含</strong>任何协议信息。</td>
</tr>
<tr>
<td align="left"><strong>客户端行为</strong></td>
<td align="left">客户端（如浏览器、HTTP 库）会解析 <code>http://</code>，并根据 HTTP 协议的规则构建请求。</td>
<td align="left">客户端的行为取决于上下文：<br>- <strong>浏览器</strong>: 多数浏览器会自动补全为 <code>http://</code> 或 <code>https://</code> (尝试 HTTPS 失败后回退到 HTTP)。<br>- <strong>非浏览器工具&#x2F;应用</strong>: 仅将其视为 <code>host:port</code> 对，不预设任何应用层协议。</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">- Web 浏览器地址栏 (当需要精确指定 HTTP 协议时)<br>- HTTP&#x2F;HTTPS API 请求<br>- 超链接、重定向 URL<br>- 配置 HTTP 客户端或 Webhook</td>
<td align="left">- 网络编程中服务器的监听地址<br>- 配置网络代理 (如 SOCKS 代理监听)<br>- 命令行工具 (如 <code>telnet</code>, <code>nc</code> 连接)<br>- 数据库连接字符串 (如果协议是数据库特定协议，而非 HTTP)<br>- 内部服务注册与发现</td>
</tr>
<tr>
<td align="left"><strong>默认行为</strong></td>
<td align="left">明确使用 HTTP 协议，即使 1080 端口通常不是 HTTP 默认端口。</td>
<td align="left">行为不确定，完全依赖于使用它的应用程序或工具。</td>
</tr>
</tbody></table>
<h3 id="2-1-浏览器中的处理差异"><a href="#2-1-浏览器中的处理差异" class="headerlink" title="2.1 浏览器中的处理差异"></a>2.1 浏览器中的处理差异</h3><p>当你在浏览器地址栏输入 <code>127.0.0.1:1080</code> 时，浏览器通常会尝试自动补全协议。</p>
<ol>
<li>首先，它可能会尝试 <code>https://127.0.0.1:1080</code>。</li>
<li>如果 HTTPS 连接失败（因为服务器可能没有配置 HTTPS 或证书不匹配），它通常会回退到 <code>http://127.0.0.1:1080</code>。</li>
</ol>
<p>因此，即使你没有显式输入 <code>http://</code>，浏览器也会替你完成这个工作，使得在很多情况下看起来两者效果相同。但实际上，浏览器内部已经将其转换为了一个包含协议的 URL 来处理。</p>
<h2 id="三、实际应用中的区别与示例"><a href="#三、实际应用中的区别与示例" class="headerlink" title="三、实际应用中的区别与示例"></a>三、实际应用中的区别与示例</h2><p>这个区别在网络编程和系统配置中尤为重要。</p>
<h3 id="3-1-客户端请求-需要协议"><a href="#3-1-客户端请求-需要协议" class="headerlink" title="3.1 客户端请求 (需要协议)"></a>3.1 客户端请求 (需要协议)</h3><p>当你作为一个客户端，想要通过特定的应用层协议（如 HTTP）与服务器通信时，你必须提供完整的 URL，包括协议。</p>
<p><strong>Python 示例 (使用 <code>requests</code> 库发送 HTTP 请求)</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：明确指定 HTTP 协议</span></span><br><span class="line">response = requests.get(<span class="string">&quot;http://127.0.0.1:1080/api/data&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Status Code: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Response Body: <span class="subst">&#123;response.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：requests 库无法识别没有协议的地址</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    requests.get(<span class="string">&quot;127.0.0.1:1080/api/data&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.MissingSchema <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># Output: Error: Invalid URL &#x27;127.0.0.1:1080/api/data&#x27;: No scheme supplied.</span></span><br><span class="line"><span class="comment">#         Perhaps you meant http://127.0.0.1:1080/api/data?</span></span><br></pre></td></tr></table></figure>

<p><strong>Golang 示例 (使用 <code>net/http</code> 库发送 HTTP 请求)</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 正确：明确指定 HTTP 协议</span></span><br><span class="line">	resp, err := http.Get(<span class="string">&quot;http://127.0.0.1:1080/api/data&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;HTTP request error: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	body, err := io.ReadAll(resp.Body)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Read response body error: %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Status Code: %d\n&quot;</span>, resp.StatusCode)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Response Body: %s\n&quot;</span>, body)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误：net/http 库无法识别没有协议的地址</span></span><br><span class="line">	<span class="comment">// resp, err = http.Get(&quot;127.0.0.1:1080/api/data&quot;) // 编译错误或运行时错误，Go 不允许这样的隐式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-服务端监听-通常不需要协议"><a href="#3-2-服务端监听-通常不需要协议" class="headerlink" title="3.2 服务端监听 (通常不需要协议)"></a>3.2 服务端监听 (通常不需要协议)</h3><p>当你在编写服务器程序，让它监听某个地址和端口以接收连接时，你通常只提供 <code>IP:端口</code>，因为服务器的任务是监听底层的 TCP&#x2F;UDP 连接，并由其自身的应用层逻辑来处理接收到的数据（例如，解析 HTTP 请求）。</p>
<p><strong>Python 示例 (使用 <code>socket</code> 模块监听)</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确：服务器绑定一个地址和端口</span></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((HOST, PORT))</span><br><span class="line">    s.listen(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Server listening on <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected by <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Received: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line">        conn.sendall(<span class="string">b&quot;Hello from server!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：socket 绑定不需要协议信息</span></span><br><span class="line"><span class="comment"># s.bind((&quot;http://127.0.0.1:1080&quot;, 80)) # 会导致类型错误或地址解析错误</span></span><br></pre></td></tr></table></figure>

<p><strong>Golang 示例 (使用 <code>net</code> 模块监听)</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span> <span class="comment">// 用于处理 HTTP 请求的更高层抽象</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 示例 1: 使用 net 包监听原始 TCP 连接</span></span><br><span class="line">	<span class="comment">// 正确：服务器监听一个地址和端口</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Error listening: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Raw TCP server listening on 127.0.0.1:1080\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			conn, err := listener.Accept()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;Error accepting connection: %v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Accepted connection from %s\n&quot;</span>, conn.RemoteAddr())</span><br><span class="line">			<span class="comment">// 这里可以处理原始 TCP 数据，例如读取字节流</span></span><br><span class="line">			conn.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello from raw TCP server!&quot;</span>))</span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 示例 2: 使用 net/http 包创建 HTTP 服务器</span></span><br><span class="line">	<span class="comment">// 正确：http.ListenAndServe 内部会解析地址并监听 TCP，并用 HTTP 协议处理请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/api/data&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello from HTTP server on 1081!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;HTTP server listening on 127.0.0.1:1081\n&quot;</span>)</span><br><span class="line">	<span class="comment">// 注意：这里 ListenAndServe 的第一个参数是 &quot;IP:端口&quot; 字符串，不含协议。</span></span><br><span class="line">	<span class="comment">// 它内部会处理 TCP 监听和 HTTP 协议解析。</span></span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;127.0.0.1:1081&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误：net.Listen 和 http.ListenAndServe 都不接受带协议的地址</span></span><br><span class="line">	<span class="comment">// net.Listen(&quot;tcp&quot;, &quot;http://127.0.0.1:1080&quot;) // 错误</span></span><br><span class="line">	<span class="comment">// http.ListenAndServe(&quot;http://127.0.0.1:1081&quot;, nil) // 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-代理配置"><a href="#3-3-代理配置" class="headerlink" title="3.3 代理配置"></a>3.3 代理配置</h3><p>在配置代理服务器时，尤其是 SOCKS 代理，通常只提供 <code>IP:端口</code>，因为 SOCKS 协议本身是独立于 HTTP 的传输层协议。</p>
<ul>
<li><strong>SOCKS 代理配置示例</strong>：<code>127.0.0.1:1080</code> (表示代理服务监听在本机的 1080 端口)</li>
<li><strong>HTTP 代理配置示例</strong>：<code>http://127.0.0.1:8080</code> (表示代理服务通过 HTTP 协议提供代理功能)</li>
</ul>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p><code>http://127.0.0.1:1080</code> 是一个<strong>完整的、协议明确的 URL</strong>，它指示客户端使用 HTTP 协议与目标地址和端口进行通信。而 <code>127.0.0.1:1080</code> 仅仅是一个<strong>网络端点的地址和端口组合</strong>，不包含应用层协议信息。</p>
<p>在 Web 浏览器中，两者常常看起来等效，是因为浏览器会自动补全协议。但在网络编程、系统配置和非 HTTP 协议的上下文（如 SOCKS 代理、数据库连接）中，显式或不显式地包含协议是至关重要的，它决定了通信的性质和方式。理解这一区别有助于更准确地配置和开发网络应用程序。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/84980af09d70/">https://blog.tbf1211.xx.kg/84980af09d70/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/1cdd169d9683/" title="Cloudflare免费服务详解：守护与加速你的在线资产"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Cloudflare免费服务详解：守护与加速你的在线资产</div></div><div class="info-2"><div class="info-item-1"> 在今天的互联网世界，网站和应用程序的性能、安全性和可用性至关重要。对于许多个人站长、小型企业和开发者而言，昂贵的基础设施和安全解决方案往往是难以承受的负担。而这正是 Cloudflare 的价值所在。Cloudflare 以其强大的全球网络和创新的技术，提供了一系列业界领先的免费服务，旨在让任何在线资产都能轻松享受到企业级的性能、安全和可靠性。  “Cloudflare 的免费套餐，不仅仅是‘入门级’，它为数百万网站提供了生产环境级别的保护和加速。对于个人站长和中小企业来说，它是构建和维护在线业务不可或缺的免费‘瑞士军刀’。”   一、Cloudflare 免费服务概述Cloudflare 成立于 2009 年，目标是“构建更好的互联网”。它通过在全球部署大量的边缘节点 (Edge Network)，将 CDN、DNS、DDoS 保护、WAF (Web Application Firewall, Web应用防火墙)、SSL&#x2F;TLS 加密等功能集成在一个平台中。其免费服务涵盖了网站运营的多个核心方面：  DNS 管理：全球最快的 DNS 解析服务。 CDN 加速：内容分...</div></div></div></a><a class="pagination-related" href="/5f4f405cbb7a/" title="Scoop (Windows 命令行包管理器) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Scoop (Windows 命令行包管理器) 详解</div></div><div class="info-2"><div class="info-item-1"> Scoop 是 Windows 平台上的一个开源命令行安装程序，它旨在为开发者提供一个简洁、无需管理员权限、便携式的软件管理解决方案。与传统的 Windows 软件安装方式不同，Scoop 不会污染系统 PATH，不依赖 MSI 安装程序，并且默认将软件安装到用户目录而非系统目录。它特别适合于管理开发工具、CLI 应用程序以及其他便携式软件。  核心思想：为 Windows 用户提供一种无需管理员权限、以用户级别安装和管理软件的方式，强调简洁、便携和避免系统污染。   一、为什么选择 Scoop？传统的 Windows 软件安装和管理方式存在以下痛点：  管理员权限 (UAC 提示)：大多数 Windows 软件安装都需要管理员权限，频繁弹出 UAC (User Account Control) 提示，打断工作流。 系统路径污染 (PATH)：许多软件会将自身目录添加到系统 PATH 环境变量中，随着安装的软件增多，PATH 变得冗长且难以管理。 非便携式安装：多数软件通过 MSI 或 EXE 安装程序进行安装，会将文件分散到系统各处，并在注册表中留下大量条目，不易于迁移或彻底...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/c5054902e8b1/" title="iptables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-25</div><div class="info-item-2">iptables 详解</div></div><div class="info-2"><div class="info-item-1"> iptables 是 Linux 系统中一个强大的防火墙工具，它基于 Netfilter 框架。Netfilter 是 Linux 内核中的一个数据包过滤和修改框架，而 iptables 是用于在用户空间配置 Netfilter 规则的命令行工具。通过 iptables，系统管理员可以定义各种规则来过滤、修改、转发或拦截网络数据包，从而实现网络流量控制、端口转发、地址伪装等功能。可以说，iptables 是 Linux 系统网络安全和流量管理的基石。  核心思想：基于规则链对数据包进行匹配和处理。 数据包在网络协议栈中穿行时，会根据定义好的规则链进行检查，并按照链中的规则顺序执行相应的动作。   一、Netfilter 框架与 iptables 关系理解 iptables，首先要了解它与 Netfilter 的关系：  Netfilter：位于 Linux 内核中，是一个用于网络数据包过滤、修改、转发和跟踪的框架。它定义了几个”钩子” (Hooks) 点，当数据包经过这些钩子点时，Netfilter 会检查是否有注册的规则需要处理该数据包。 iptables：是用户空间的命令行...</div></div></div></a><a class="pagination-related" href="/296c75615ac4/" title="L4 负载均衡详解 (Layer 4 Load Balancing Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-13</div><div class="info-item-2">L4 负载均衡详解 (Layer 4 Load Balancing Explained)</div></div><div class="info-2"><div class="info-item-1"> L4 负载均衡 (Layer 4 Load Balancing)，也称为传输层负载均衡，是一种在 OSI 模型第四层（传输层）上进行流量分发的负载均衡技术。它主要根据网络数据包的 IP 地址和端口号信息来决定将请求转发到哪个后端服务器，而不解析应用层数据（如 HTTP 头、URL 或 Cookie）。L4 负载均衡器在建立 TCP 连接之初或接收 UDP 数据包时就做出转发决策。  核心思想：基于连接或数据包的源&#x2F;目的 IP 和端口进行快速、高效的流量转发，实现后端服务器的水平扩展和高可用性。   一、为什么需要 L4 负载均衡？在许多高性能和高并发的应用场景中，L4 负载均衡是实现可扩展性和可靠性的基础组件：  高吞吐量和低延迟：由于 L4 负载均衡器不需要解析应用层协议内容，其处理速度非常快，能够处理极高的并发连接和请求，并保持较低的延迟。这对于对性能要求极高的应用至关重要。 协议无关性：L4 负载均衡不限于 HTTP&#x2F;HTTPS 协议，它可以对任何基于 TCP 或 UDP 的协议（如 SSH、FTP、SMTP、DNS、RTP 以及各种私有协议）进行负载...</div></div></div></a><a class="pagination-related" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-15</div><div class="info-item-2">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</div></div><div class="info-2"><div class="info-item-1"> L7 负载均衡 (Layer 7 Load Balancing)，也被称为应用层负载均衡，是基于 OSI 模型第七层（应用层）信息（如 HTTP&#x2F;HTTPS 请求的 URL、URI、Header、Cookie 或请求方法）来智能分发客户端请求的一种负载均衡技术。与仅基于 IP 地址和端口进行分发的 L4 负载均衡不同，L7 负载均衡能够对应用层数据包的内容进行深度检查和解析，从而实现更精细、更智能的流量分发策略。  核心思想：理解应用层请求的“意图”，并根据这些意图将请求路由到最合适的后端服务器或服务。 它能够对流量进行更深入的控制和优化。   一、为什么需要 L7 负载均衡？随着现代应用程序架构（如微服务、API 网关、无服务器）的日益复杂，以及对性能、安全性和可伸缩性需求的提升，L4 负载均衡的局限性逐渐显现。L7 负载均衡应运而生，主要解决了以下问题：  更细粒度的路由 (Fine-grained Routing)：L4 负载均衡只能基于 IP 和端口分发，无法区分同一端口上的不同应用或 API。L7 能够根据 URL 路径 (/api/users 到用户服务，...</div></div></div></a><a class="pagination-related" href="/e261890c2af2/" title="SSL&#x2F;TLS 终止详解 (SSL&#x2F;TLS Termination Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-01</div><div class="info-item-2">SSL&#x2F;TLS 终止详解 (SSL&#x2F;TLS Termination Explained)</div></div><div class="info-2"><div class="info-item-1"> SSL&#x2F;TLS 终止 (SSL&#x2F;TLS Termination) 是指在客户端和后端服务器之间，由一个中间设备（如负载均衡器、反向代理、API 网关等）负责解密传入的 SSL&#x2F;TLS 加密流量，并在将请求转发到后端服务器之前对其进行处理的过程。同样地，该设备也负责对来自后端服务器的响应进行加密，然后发送给客户端。这个中间设备即充当了 SSL&#x2F;TLS 连接的“终点”。  核心思想：将繁重的 SSL&#x2F;TLS 加密&#x2F;解密计算从后端应用服务器上卸载到专门的设备，以此提高后端服务器的性能、简化证书管理，并实现流量的可见性和控制。   一、为什么需要 SSL&#x2F;TLS 终止？在现代网络架构中，尤其是面对高并发和微服务环境时，SSL&#x2F;TLS 终止变得尤为重要。它解决了直接在应用服务器上处理 SSL&#x2F;&#x2F;TLS 的诸多挑战：  性能优化 (Performance Offloading)：SSL&#x2F;TLS 加密和解密是一个计算密集型操作，涉及复杂的握手过程和密钥交换。将此任务从后端应用服务器卸...</div></div></div></a><a class="pagination-related" href="/a97c16bf3fd0/" title="奇偶检验详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-14</div><div class="info-item-2">奇偶检验详解</div></div><div class="info-2"><div class="info-item-1"> 奇偶检验 (Parity Check) 是一种最简单、最古老的错误检测方法，用于验证数据在传输或存储过程中是否发生了一位或奇数位的错误。它通过在原始数据的基础上添加一个额外的比特位（称为奇偶校验位）来实现。  核心思想： 通过统计数据位中 ‘1’ 的数量是奇数还是偶数，并添加一个校验位来使其总数符合预设的奇偶性，从而在接收端检测数据是否被意外翻转。   一、奇偶检验的基本原理奇偶检验的基本思想是确保一组二进制位中 ‘1’ 的总数（包括校验位）始终是奇数或偶数。 1.1 两种类型根据要求的奇偶性，奇偶检验分为两种：  奇校验 (Odd Parity Check)：  发送方统计数据位中 ‘1’ 的个数。 如果 ‘1’ 的个数为偶数，则奇偶校验位设置为 ‘1’，使包括校验位在内的所有位中 ‘1’ 的总数为奇数。 如果 ‘1’ 的个数为奇数，则奇偶校验位设置为 ‘0’，使包括校验位在内的所有位中 ‘1’ 的总数仍为奇数。 目标：传输的整个数据串（数据位 + 校验位）中 ‘1’ 的个数为奇数。   偶校验 (Even Parity Check)：  发送方统计数据位中 ‘1’ 的个数。...</div></div></div></a><a class="pagination-related" href="/9b793354c088/" title="nftables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-28</div><div class="info-item-2">nftables 详解</div></div><div class="info-2"><div class="info-item-1"> nftables 是 Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在逐步取代传统的 iptables (以及 ip6tables, arptables, ebtables) 工具集，提供一个统一的、高效的、更易于管理和扩展的防火墙解决方案。nftables 引入了一套全新的语法和设计理念，旨在解决 iptables 长期存在的一些问题，例如命令复杂性、重复代码以及 IPv4 和 IPv6 规则管理的独立性等。  核心思想：基于表达式的统一规则集，支持原子性更新，并针对 IPv4&#x2F;IPv6&#x2F;桥接等协议提供统一管理。 它的设计哲学是从指令式规则集转向声明式通用虚拟机指令，使得规则处理更高效、更灵活。   一、为什么需要 nftables？iptables 的局限性虽然 iptables 强大且稳定，但它在设计和使用上存在一些固有的局限性，促使 Netfilter 社区开发 nftables：  语法复杂且碎片化：  iptables (用于 IPv4)、ip6tables (用于 IPv6)、arptables (用于 ARP)、ebtab...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">521</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="toc-text">一、核心概念定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-IP-%E5%9C%B0%E5%9D%80-Internet-Protocol-Address"><span class="toc-text">1.1 IP 地址 (Internet Protocol Address)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%AB%AF%E5%8F%A3-Port"><span class="toc-text">1.2 端口 (Port)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-URL-Uniform-Resource-Locator"><span class="toc-text">1.3 URL (Uniform Resource Locator)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-HTTP-%E5%8D%8F%E8%AE%AE-Hypertext-Transfer-Protocol"><span class="toc-text">1.4 HTTP 协议 (Hypertext Transfer Protocol)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81http-127-0-0-1-1080-%E4%B8%8E-127-0-0-1-1080-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">二、http:&#x2F;&#x2F;127.0.0.1:1080 与 127.0.0.1:1080 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86%E5%B7%AE%E5%BC%82"><span class="toc-text">2.1 浏览器中的处理差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-text">三、实际应用中的区别与示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82-%E9%9C%80%E8%A6%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1 客户端请求 (需要协议)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9B%91%E5%90%AC-%E9%80%9A%E5%B8%B8%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.2 服务端监听 (通常不需要协议)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE"><span class="toc-text">3.3 代理配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-10.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>