<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Next.js Hydration 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在使用 Next.js 等服务器端渲染 (SSR) 或静态站点生成 (SSG) 框架时，Hydration (水合、激活) 是一个核心且至关重要的概念。它指的是在浏览器端，React 应用程序“接管”由服务器预先生成的静态 HTML 内容，使其从纯展示变为可交互的动态过程。理解 Hydration 对于优化 Next.js 应用的性能、解决常见的客户端-服务器不匹配问题以及充分利用 React">
<meta property="og:type" content="article">
<meta property="og:title" content="Next.js Hydration 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/57cc64e71afb/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在使用 Next.js 等服务器端渲染 (SSR) 或静态站点生成 (SSG) 框架时，Hydration (水合、激活) 是一个核心且至关重要的概念。它指的是在浏览器端，React 应用程序“接管”由服务器预先生成的静态 HTML 内容，使其从纯展示变为可交互的动态过程。理解 Hydration 对于优化 Next.js 应用的性能、解决常见的客户端-服务器不匹配问题以及充分利用 React">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg">
<meta property="article:published_time" content="2024-01-31T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-24T02:54:58.280Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="React">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="Next.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Next.js Hydration 详解",
  "url": "https://blog.tbf1211.xx.kg/57cc64e71afb/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg",
  "datePublished": "2024-01-31T22:24:00.000Z",
  "dateModified": "2026-02-24T02:54:58.280Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/57cc64e71afb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Next.js Hydration 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">550</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-14.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Next.js Hydration 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Next.js Hydration 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-01-31T22:24:00.000Z" title="发表于 2024-02-01 06:24:00">2024-02-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://nextjs.org/">Next.js</a> 等服务器端渲染 (SSR) 或静态站点生成 (SSG) 框架时，<strong>Hydration (水合、激活)</strong> 是一个核心且至关重要的概念。它指的是在浏览器端，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://react.dev/">React</a> 应用程序“接管”由服务器预先生成的静态 HTML 内容，使其从纯展示变为可交互的动态过程。理解 Hydration 对于优化 Next.js 应用的性能、解决常见的客户端-服务器不匹配问题以及充分利用 React Server Components (RSC) 的优势至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：将服务器或构建时生成的静态 HTML 页面，“激活”为完全可交互的客户端 React 应用程序。</p>
</div>
<hr>
<h2 id="一、什么是-Hydration？"><a href="#一、什么是-Hydration？" class="headerlink" title="一、什么是 Hydration？"></a>一、什么是 Hydration？</h2><p><strong>Hydration</strong> 是指 React (或Vue、Angular等前端框架) 在浏览器端将<strong>服务器端或构建时预先渲染的纯静态 HTML 内容</strong>，转换成一个<strong>可交互的动态 React 应用程序</strong>的过程。</p>
<p>想象一下这个过程：</p>
<ol>
<li><strong>服务器&#x2F;构建时</strong>：Next.js 在服务器上（对于 SSR）或在构建时（对于 SSG）运行你的 React 组件，生成一个完整的 HTML 字符串。这个 HTML 包含页面内容，但不包含任何事件监听器或 React 的内部状态管理机制，它只是一个视觉上的呈现。</li>
<li><strong>客户端 (浏览器)</strong>：当浏览器接收并解析这个 HTML 后，它会立即渲染出页面内容，用户可以快速看到首屏。与此同时，浏览器会下载对应的 JavaScript bundle（包含 React 运行时和你的组件代码）。</li>
<li><strong>Hydration 阶段</strong>：一旦 JavaScript bundle 加载并执行，React 会在客户端启动，并尝试“识别”它所管理的 HTML 结构。它不会从头开始重新渲染整个页面，而是将虚拟 DOM (Virtual DOM) 与浏览器中已有的真实 DOM 进行<strong>比对 (Reconciliation)</strong>。如果结构匹配，React 就会将事件监听器附加到对应的 DOM 元素上，并初始化组件状态。至此，页面变为完全可交互的客户端应用程序。</li>
</ol>
<p><strong>关键点：</strong></p>
<ul>
<li>Hydration 使得服务器端渲染的页面能够无缝地过渡到客户端应用程序。</li>
<li>它关注于<strong>最小化视觉差异</strong>和<strong>快速实现交互性</strong>。</li>
<li>如果客户端生成的 React 树与服务器发送的 HTML 结构<strong>不匹配</strong>，就会发生 Hydration 错误 (Mismatch Error)。</li>
</ul>
<h2 id="二、Hydration-的工作原理"><a href="#二、Hydration-的工作原理" class="headerlink" title="二、Hydration 的工作原理"></a>二、Hydration 的工作原理</h2><p>Hydration 的过程可以概括为以下步骤：</p>
<ol>
<li><strong>用户请求 (Client Request)</strong>：用户在浏览器中访问一个 Next.js 页面。</li>
<li><strong>服务器渲染 (Server Render)</strong>：Next.js 服务器接收请求，执行页面的 React 组件，生成对应的 HTML 字符串。这个 HTML 包含了页面内容的骨架，但此时它只是一个静态快照。</li>
<li><strong>发送 HTML (Send HTML)</strong>：服务器将生成的 HTML 连同必要的 JavaScript bundle (包含 React 运行时和页面组件的客户端代码) 一起发送到浏览器。</li>
<li><strong>浏览器绘制 (Browser Paint)</strong>：浏览器接收到 HTML 后，立即解析并绘制页面。用户此时可以看到页面的内容，实现了<strong>快速首次内容绘制 (FCP - First Contentful Paint)</strong>。</li>
<li><strong>下载&#x2F;执行 JS (Download&#x2F;Execute JS)</strong>：浏览器同时下载并执行附带的 JavaScript bundle。</li>
<li><strong>React 启动并比对 (React Startup &amp; Reconciliation)</strong>：当 JavaScript 运行后，React 会在客户端“启动”，并开始执行页面的根组件。它会构建出一个虚拟 DOM 树，然后将其与浏览器中已存在的真实 DOM 树进行深度比对。<ul>
<li><strong>比对成功</strong>：如果虚拟 DOM 树与真实 DOM 树的结构完全一致，React 会认为 Hydration 成功。它会跳过重新渲染视图的步骤，直接将所有事件监听器附加到相应的 DOM 元素上，并初始化组件的内部状态。此时，页面变为可交互，实现了<strong>快速交互时间 (TTI - Time To Interactive)</strong>。</li>
<li><strong>比对失败 (Mismatch)</strong>：如果发现两者结构不一致，React 可能会发出警告（在开发模式下），并且为了修复这种差异，可能会在客户端<strong>重新渲染</strong>整个组件树。这会带来额外的性能开销，并可能导致用户界面的“闪烁”或状态丢失。</li>
</ul>
</li>
<li><strong>完全交互 (Fully Interactive)</strong>：事件监听器附加完成后，页面就成了一个完全响应式的 React 客户端应用程序。</li>
</ol>
<h3 id="Hydration-工作流示意图"><a href="#Hydration-工作流示意图" class="headerlink" title="Hydration 工作流示意图"></a>Hydration 工作流示意图</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant User as 用户
    participant Browser as 浏览器
    participant Next.js Server as Next.js 服务器

    User-&gt;&gt;Browser: 1. 请求 Next.js 页面
    Browser-&gt;&gt;Next.js Server: 2. 发送页面请求 (e.g., &#x2F;my-page)
    activate Next.js Server
    Next.js Server--&gt;&gt;Next.js Server: 3. 执行 React 组件，生成 HTML
    Next.js Server-&gt;&gt;Browser: 4. 发送 HTML 响应 &amp; JS Bundle
    deactivate Next.js Server

    Browser--&gt;&gt;Browser: 5. 立即绘制 HTML (快速首屏)
    Browser-&gt;&gt;Browser: 6. 下载并执行 JS Bundle (React 运行时 + 业务代码)
    Browser--&gt;&gt;Browser: 7. **React Hydration (水合)**
    alt Mismatch
        Browser-&gt;&gt;Browser: 7a. 客户端 React 虚拟DOM 与 服务器 HTML DOM **不匹配**
        Browser-&gt;&gt;Browser: 7b. React 警告并强制客户端 **重新渲染**
    else Match
        Browser-&gt;&gt;Browser: 7c. 客户端 React 虚拟DOM 与 服务器 HTML DOM **匹配**
        Browser-&gt;&gt;Browser: 7d. React 附加事件监听器 &amp; 初始化状态
    end
    Browser-&gt;&gt;User: 8. 页面完全可交互 (TTI)
  </pre></div>

<h2 id="三、Next-js-中的-Hydration"><a href="#三、Next-js-中的-Hydration" class="headerlink" title="三、Next.js 中的 Hydration"></a>三、Next.js 中的 Hydration</h2><p>在 Next.js 中，无论是 Pages Router 还是 App Router，Hydration 都是默认行为，用于将 SSR 或 SSG 生成的 HTML 转换为交互式 React 应用。</p>
<ul>
<li><strong>Pages Router (传统)</strong>：<ul>
<li>通过 <code>getServerSideProps</code> 或 <code>getStaticProps</code> 预取数据并生成 HTML。</li>
<li>在客户端，Next.js 会自动对这些页面进行 Hydration。</li>
</ul>
</li>
<li><strong>App Router (Next.js 13+)</strong>：<ul>
<li>默认是 <strong>服务器组件 (Server Components, RSC)</strong>，它们在服务器上渲染，生成的 HTML 不需要 Hydration。</li>
<li>通过 <code>&quot;use client&quot;</code> 指令标记的 <strong>客户端组件 (Client Components)</strong>，它们在服务器上进行预渲染后，在客户端仍需要 Hydration 才能实现交互。</li>
<li>App Router 和 React Suspense 的结合可以实现<strong>选择性 Hydration (Selective Hydration)</strong>，允许 React 优先 Hydrate 那些用户最先与之交互的区域，而不用等待整个页面 JS 加载完成。</li>
</ul>
</li>
</ul>
<h2 id="四、Hydration-的优点"><a href="#四、Hydration-的优点" class="headerlink" title="四、Hydration 的优点"></a>四、Hydration 的优点</h2><ol>
<li><strong>改善用户体验 (FCP &amp; TTI)</strong>：<ul>
<li>用户能够<strong>更快地看到内容 (First Contentful Paint, FCP)</strong>，因为服务器直接发送了完整的 HTML。</li>
<li>避免了客户端渲染 (CSR) 带来的“白屏”问题。</li>
<li>通过 Hydration，内容能够<strong>更快地变得可交互 (Time To Interactive, TTI)</strong>。</li>
</ul>
</li>
<li><strong>SEO 友好</strong>：<ul>
<li>搜索引擎爬虫可以直接抓取到完整的 HTML 内容，这对于页面的索引和排名至关重要。</li>
<li>相比之下，完全依赖客户端 JavaScript 渲染的页面，爬虫可能需要额外的执行 JavaScript 才能获取内容。</li>
</ul>
</li>
<li><strong>性能优势</strong>：<ul>
<li>减少客户端首次渲染的计算量，因为大部分 UI 结构已经由服务器计算生成。</li>
<li>在网络环境不佳时，用户仍然可以访问到页面的基本内容。</li>
</ul>
</li>
</ol>
<h2 id="五、Hydration-的常见问题与性能挑战"><a href="#五、Hydration-的常见问题与性能挑战" class="headerlink" title="五、Hydration 的常见问题与性能挑战"></a>五、Hydration 的常见问题与性能挑战</h2><p>尽管 Hydration 带来了诸多优点，但也伴随着一些挑战，尤其是当服务器和客户端渲染的 HTML 结构不一致时。</p>
<h3 id="5-1-Hydration-不匹配-Mismatch-Errors"><a href="#5-1-Hydration-不匹配-Mismatch-Errors" class="headerlink" title="5.1 Hydration 不匹配 (Mismatch Errors)"></a>5.1 Hydration 不匹配 (Mismatch Errors)</h3><p>这是最常见也最棘手的问题。当客户端 React 尝试 Hydrate 服务器发送的 HTML 时，如果它发现自己渲染出来的虚拟 DOM 结构与服务器 HTML 的实际 DOM 结构不一致，就会产生 Hydration 错误。</p>
<ul>
<li><p><strong>错误表现</strong>：在开发模式下，浏览器控制台会打印 <code>Warning: Prop &#39;...&#39; did not match. Server: &quot;...&quot; Client: &quot;...&quot;</code> 或 <code>Warning: Text content did not match. Server: &quot;...&quot; Client: &quot;...&quot;</code> 等警告。生产环境中，React 会尝试修复（通常是替换整个节点），但可能导致视觉闪烁、数据丢失或不必要的重新渲染。</p>
</li>
<li><p><strong>常见原因</strong>：</p>
<ol>
<li><strong>客户端专属代码</strong>：在服务器端组件中使用了只在浏览器环境中存在的对象或 API，例如 <code>window</code>、<code>localStorage</code>、<code>document</code> 等。<ul>
<li><strong>示例</strong>：<code>const isBrowser = typeof window !== &#39;undefined&#39;;</code> -&gt; 服务器上 <code>false</code>，客户端 <code>true</code>。如果在 JSX 中根据此渲染不同内容，易导致不匹配。</li>
<li><strong>示例</strong>：<code>&lt;p&gt;Current time: &#123;new Date().toLocaleString()&#125;&lt;/p&gt;</code>。因为服务器渲染和客户端 Hydration 时的时区或时间可能不同，导致输出字符串不一致。</li>
</ul>
</li>
<li><strong>浏览器扩展&#x2F;插件</strong>：某些浏览器扩展可能会在 HTML 内容中注入或修改 DOM 结构，导致 React 无法匹配。</li>
<li><strong>不正确的 HTML 结构</strong>：例如，在 <code>div</code> 内部嵌套了 <code>p</code> 标签，而 <code>p</code> 标签内部又直接包含了另一个 <code>div</code> (不合法的 HTML 结构)。 React 可能以不同的方式处理这些无效结构。</li>
<li><strong><code>dangerouslySetInnerHTML</code> 滥用</strong>：如果注入的 HTML 包含复杂或不一致的结构。</li>
<li><strong>随机 ID 或类名</strong>：如果组件在服务器和客户端生成随机 ID 或类名 (例如，没有正确处理 CSS-in-JS 库)，也可能导致不匹配。</li>
</ol>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li><strong>客户端条件渲染</strong>：<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [isClient, setIsClient] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setIsClient</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有在客户端 Hydration 完成后才渲染依赖于客户端环境的内容</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Current Time (Server &amp; Client)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Server Time: &#123;new Date().toLocaleString()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> &#123;/* 可能会不匹配，但通常接受 */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;isClient ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>Client Time: &#123;new Date().toLocaleString()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : <span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading client time...<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>使用 Next.js <code>dynamic()</code> 配合 <code>ssr: false</code></strong>：对于纯客户端组件，可以使用 <code>next/dynamic</code> 实现异步加载且不进行 SSR。<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">&#x27;next/dynamic&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个组件只会在客户端加载和渲染，不会参与 SSR</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NoSSRComponent</span> = <span class="title function_">dynamic</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/NoSSRComponent&#x27;</span>), &#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyPage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Page with No SSR Component<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">NoSSRComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>确保服务器和客户端行为一致</strong>：对于依赖时间、随机数或用户代理等因素的内容，如果必须在服务器和客户端同时渲染，则需要确保其计算逻辑在两者之间保持一致。</li>
<li><strong>检查无效 HTML</strong>：使用浏览器的开发者工具检查 HTML 结构，确保其符合规范。</li>
<li><strong>同步 CSS-in-JS 样式</strong>：确保样式在服务器和客户端生成时保持一致。</li>
</ul>
</li>
</ul>
<h3 id="5-2-性能开销"><a href="#5-2-性能开销" class="headerlink" title="5.2 性能开销"></a>5.2 性能开销</h3><p>Hydration 本身是一个客户端任务，会带来额外的性能开销：</p>
<ol>
<li><strong>JavaScript Bundle 大小</strong>：Hydration 需要下载和执行你的整个应用程序的 JavaScript 代码。如果 JS 文件过大，会增加下载时间。</li>
<li><strong>CPU 开销</strong>：React 需要在客户端执行大量的 JavaScript 来构建虚拟 DOM 树并将其与现有 DOM 进行比对，这会消耗设备的 CPU 资源，尤其是在低端设备上。</li>
<li><strong>阻塞交互</strong>：在 Hydration 完成之前，页面可能看起来已经加载，但用户无法与之交互。这段时间称为<strong>输入延迟 (Input Delay)</strong>，会影响用户体验。</li>
</ol>
<ul>
<li><strong>解决方案</strong>：<ul>
<li><strong>代码分割 (Code Splitting)</strong>：Next.js 默认会对页面进行代码分割，只加载当前页面所需的 JS。对于大组件，可以使用 <code>dynamic()</code> 进行按需加载。</li>
<li><strong>优化 JS Bundle 大小</strong>：精简代码，移除不必要的依赖，进行 Tree Shaking。</li>
<li><strong>选择性 Hydration (App Router)</strong>：利用 React Suspense 及其 concurrent 特性，优先 Hydrate 用户可见或交互区域。</li>
<li><strong>减少客户端 JS 渲染</strong>：利用 App Router 的 <strong>Server Components</strong>，将更多的渲染工作留在服务器端，从而减少发送到客户端的 JavaScript 数量和 Hydration 的工作量。</li>
</ul>
</li>
</ul>
<h3 id="5-3-累积布局偏移-CLS"><a href="#5-3-累积布局偏移-CLS" class="headerlink" title="5.3 累积布局偏移 (CLS)"></a>5.3 累积布局偏移 (CLS)</h3><p>如果服务器渲染的 HTML 和客户端 Hydration 后的布局存在差异（例如，某个元素在 Hydration 后才加载，导致页面内容向下移动），可能会造成累积布局偏移 (CLS)，影响用户体验和 SEO 评分。</p>
<ul>
<li><strong>解决方案</strong>：<ul>
<li><strong>明确尺寸</strong>：给图像、广告或其他动态内容设置明确的 <code>width</code> 和 <code>height</code>，或使用 <code>aspect-ratio</code>。</li>
<li><strong>占位符</strong>：使用骨架屏或占位符，预留出动态内容的渲染空间。</li>
</ul>
</li>
</ul>
<h2 id="六、代码示例：演示-Hydration-Mismatch"><a href="#六、代码示例：演示-Hydration-Mismatch" class="headerlink" title="六、代码示例：演示 Hydration Mismatch"></a>六、代码示例：演示 Hydration Mismatch</h2><p>我们将创建一个简单的 Next.js Pages Router 页面来演示 Hydration Mismatch。</p>
<p><strong>1. 创建一个可能产生不匹配的页面 (<code>pages/mismatch.tsx</code>)</strong></p>
<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/mismatch.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MismatchPage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [isClient, setIsClient] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有在客户端运行时才设置 isClient 为 true</span></span><br><span class="line">    <span class="comment">// 这确保了我们在服务器端和客户端渲染时的行为一致</span></span><br><span class="line">    <span class="title function_">setIsClient</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假设我们希望在客户端显示一个随机数</span></span><br><span class="line">  <span class="comment">// 服务器端会渲染一个不同的随机数 (如果不是在 useEffect 中生成)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误示例：直接在组件顶层生成随机数（会在服务器和客户端都执行，导致不匹配）</span></span><br><span class="line">  <span class="comment">// const randomNumber = Math.random(); </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hydration Mismatch Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Rendered Time (Server &amp; Client):<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> &#123;new Date().toLocaleString()&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/*</span></span><br><span class="line"><span class="language-xml">        上面的 `new Date().toLocaleString()` 很可能导致不匹配，</span></span><br><span class="line"><span class="language-xml">        因为服务器生成 HTML 的时间点和客户端 Hydration 的时间点通常不一样。</span></span><br><span class="line"><span class="language-xml">        在开发模式下会收到警告。</span></span><br><span class="line"><span class="language-xml">      */&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Client-only Content (Incorrectly placed):<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/*</span></span><br><span class="line"><span class="language-xml">          这个 `Math.random()` 也可能导致不匹配，</span></span><br><span class="line"><span class="language-xml">          因为它在服务器端也会执行一次，得到一个值，</span></span><br><span class="line"><span class="language-xml">          然后客户端 Hydration 时再执行一次，得到另一个值。</span></span><br><span class="line"><span class="language-xml">        */&#125;</span></span><br><span class="line"><span class="language-xml">        Random number: &#123;Math.random()&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Fixing Mismatch with Client-side Conditional Rendering<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;isClient ? (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">green</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Correct Client-only Display:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> Random number generated on client: &#123;Math.random()&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ) : (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">orange</span>&#x27; &#125;&#125;&gt;</span>Loading client-only content...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/*</span></span><br><span class="line"><span class="language-xml">        这里的 `isClient` 确保了 `Math.random()` 只有在客户端 Hydration 完成（即 `useEffect` 执行后）才会被渲染。</span></span><br><span class="line"><span class="language-xml">        服务器端只会渲染 &quot;Loading client-only content...&quot;，</span></span><br><span class="line"><span class="language-xml">        客户端 Hydration 时，React 会比对 `Loading...` 和 `Loading...`，然后 `isClient` 变为 `true`，触发更新，</span></span><br><span class="line"><span class="language-xml">        将内容替换为客户端生成的随机数。</span></span><br><span class="line"><span class="language-xml">        这样就避免了 Hydration 时的直接不匹配。</span></span><br><span class="line"><span class="language-xml">      */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟服务器端数据获取 (SSR)</span></span><br><span class="line"><span class="comment">// 如果在这里获取的数据与客户端渲染的数据不一致，也会导致不匹配。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> serverTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server-side rendered at:&#x27;</span>, serverTime);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      serverTime,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行上述代码并观察：</strong></p>
<ol>
<li>启动开发服务器 (<code>npm run dev</code>)。</li>
<li>访问 <code>/mismatch</code> 页面。</li>
<li>打开浏览器开发者工具的控制台。</li>
<li>你会看到类似这样的警告：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Text content did not match. Server: &quot;Rendered Time (Server &amp; Client): 2024/5/18 上午6:24:00&quot; Client: &quot;Rendered Time (Server &amp; Client): 2024/5/18 上午6:24:05&quot;</span><br></pre></td></tr></table></figure>
以及：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Prop `children` did not match. Server: &quot;Random number: 0.123456789&quot; Client: &quot;Random number: 0.987654321&quot;</span><br></pre></td></tr></table></figure>
这些警告表明了服务器和客户端在渲染 <code>&lt;p&gt;</code> 标签内的文本内容时，因为时间和随机数的差异，导致了不匹配。</li>
<li>而“Correct Client-only Display”那部分因为使用了 <code>isClient</code> 状态，首次 Hydration 时服务器和客户端渲染的都是“Loading client-only content…”，所以不会产生不匹配警告。在 Hydration 之后，组件会再次渲染并显示客户端生成的随机数。</li>
</ol>
<h2 id="七、Next-js-App-Router-与-Hydration-的未来"><a href="#七、Next-js-App-Router-与-Hydration-的未来" class="headerlink" title="七、Next.js App Router 与 Hydration 的未来"></a>七、Next.js App Router 与 Hydration 的未来</h2><p>随着 Next.js 13 推出 App Router 和 React Server Components (RSC) 规范，Hydration 的角色也在发生演变：</p>
<ul>
<li><strong>减少 Hydration 范围</strong>：Server Components 在服务器上渲染为纯 HTML 和对应的组件描述。这些 HTML 片段不需要客户端的 React 进行 Hydration，因为它们没有客户端状态或事件监听器。这极大地减少了发送到客户端的 JavaScript 数量和 Hydration 的工作量。</li>
<li><strong>客户端组件 (Client Components) 仍需 Hydration</strong>：只有被标记为 <code>&quot;use client&quot;</code> 的组件才会在服务器上预渲染 HTML，然后在客户端进行 Hydration。</li>
<li><strong>选择性 Hydration (Selective Hydration)</strong>：通过 React Suspense，App Router 可以实现更智能的 Hydration 策略。React 可以对页面中不同的交互区域进行并发 Hydration，而不是等待整个页面 JS 加载。这意味着用户可以更快地与页面的特定部分进行交互，即使其他部分仍在 Hydration 中。</li>
</ul>
<p>这种新的架构致力于将更多的渲染和数据获取工作推向服务器，从而最大限度地减少客户端的 JavaScript 负载和 Hydration 时间，带来更快的 TTFB (Time To First Byte)、FCP 和 TTI。</p>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>Hydration 是 Next.js 等 SSR&#x2F;SSG 框架能够提供现代 Web 应用程序卓越性能和用户体验的关键机制。它解决了在快速内容展示（由服务器渲染）与丰富的用户交互（由客户端 React 提供）之间的矛盾。</p>
<p>开发者需要深入理解 Hydration 的工作原理，特别要警惕并解决 Hydration 不匹配问题，因为它会严重影响应用性能和调试体验。随着 Next.js App Router 和 React Server Components 的发展，开发者可以通过合理地划分 Server Components 和 Client Components，进一步优化 Hydration 过程，构建出更高效、更具响应性的 Web 应用程序。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/57cc64e71afb/">https://blog.tbf1211.xx.kg/57cc64e71afb/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/Next-js/">Next.js</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a><a class="pagination-related" href="/6014745b242a/" title="ARP (Address Resolution Protocol) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ARP (Address Resolution Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> ARP (Address Resolution Protocol)，即地址解析协议，是一个在局域网 (LAN) 内使用的网络层协议，主要用于将IP 地址 (网络层地址)解析为MAC 地址 (数据链路层地址)。在 TCP&#x2F;IP 协议栈中，当一台主机知道目标主机的 IP 地址，但需要知道其在同一物理网络上的 MAC 地址才能进行数据帧的发送时，就会使用 ARP 协议。  核心思想：将逻辑地址 (IP) 映射到物理地址 (MAC)，使得 IP 数据包能够在数据链路层封装成帧并通过物理网络介质传输到正确的目标设备。   一、为什么需要 ARP？在理解 ARP 之前，我们需要明确 IP 地址和 MAC 地址在网络通信中的角色：  IP 地址 (Internet Protocol Address)：工作在 OSI 模型的第三层 (网络层)。它是一个逻辑地址，用于在不同网络之间识别和路由数据包。IP 地址是分层的，包含网络部分和主机部分，使得路由器能够根据网络部分将数据包转发到正确的网络。 MAC 地址 (Media Access Control Address)：工作在 OSI ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/51210e3963c9/" title="Next.js 服务端组件 (RSC) 与客户端组件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="info-item-2">Next.js 服务端组件 (RSC) 与客户端组件详解</div></div><div class="info-2"><div class="info-item-1"> 随着 React 18 引入的 Server Components (RSC) 和 Next.js 13+ App Router 的推出，前端的渲染模式和组件组织方式发生了根本性变化。理解服务端组件 (Server Components) 和客户端组件 (Client Components) 之间的差异、它们的工作原理以及何时使用它们，是掌握现代 Next.js 应用开发的关键。这种分离旨在优化性能、减少客户端 JavaScript 包大小、提升用户体验并简化服务器端数据获取。  核心思想：将组件的渲染工作按需划分到服务器端和客户端，以最大化性能优势、最小化客户端JS负载，并提升开发者体验。服务端组件是默认行为，旨在执行不依赖浏览器API和交互的逻辑；客户端组件则用于处理用户交互和浏览器侧功能。   一、概述：为何需要区分服务端和客户端组件？在传统的 React 应用中，所有组件（即使是那些只显示静态内容的组件）最终都会在客户端（浏览器）执行其渲染逻辑，并参与“水合”（hydration）过程。这意味着：  大 JavaScript 包：所有组件的代码都需要打包并发送到客户端，...</div></div></div></a><a class="pagination-related" href="/3ba66d6aee4f/" title="Next.js 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="info-item-2">Next.js 详解</div></div><div class="info-2"><div class="info-item-1"> Next.js 是一个基于 React 的开源 Web 框架，由 Vercel 公司开发并维护。它为 React 应用程序提供了生产级的特性，如服务器端渲染 (SSR)、静态站点生成 (SSG)、增量静态再生 (ISR)，以及文件系统路由、API 路由、图像优化等。Next.js 旨在提升 React 应用的性能、SEO 友好性、可维护性和开发体验，使开发者能够更高效地构建全栈式的现代 Web 应用程序。  核心思想：在 React 的基础上提供一套完整的生产级解决方案，通过灵活的渲染策略和内置优化，帮助开发者构建高性能、SEO 友好且易于维护的 Web 应用。   一、核心特性与概念Next.js 在 React 的基础上引入了许多强大的特性，极大地简化了 Web 应用的开发过程。 1.1 强大的渲染策略 (Rendering Strategies)Next.js 最引人注目的特性之一是其灵活的渲染策略。这允许开发者根据页面的内容和访问模式选择最合适的渲染方式，以优化性能和用户体验。  客户端渲染 (Client-Side Rendering, CSR)：  定义：类似于传统...</div></div></div></a><a class="pagination-related" href="/af1b623130b7/" title="Node.js package.json 文件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="info-item-2">Node.js package.json 文件详解</div></div><div class="info-2"><div class="info-item-1"> package.json 文件是任何 Node.js 项目的核心。它是一个 JSON 格式的文件，包含了项目的元数据、依赖信息、脚本命令、版本控制等关键配置。它不仅是项目信息的载体，更是 npm (Node Package Manager) 或 yarn 等包管理器与项目交互的桥梁，定义了项目的身份、行为和依赖关系。  核心思想：package.json 是 Node.js 项目的清单文件，它描述了项目的所有关键信息，包括项目名称、版本、作者、许可证、脚本命令以及最重要的依赖关系。它是实现项目自动化、协作开发和依赖管理的基石。   一、为什么需要 package.json？package.json 在 Node.js 生态系统中扮演着至关重要的角色：  项目身份标识：提供项目的名称、版本、描述等基本信息，方便识别和管理。 依赖管理：记录项目所依赖的第三方模块及其版本范围，确保团队成员和部署环境使用相同的依赖，避免”在我机器上能跑”的问题。 脚本自动化：定义可执行的脚本命令（如启动服务器、运行测试、构建项目），简化开发流程和部署操作。 版本控制与发布：指导 npm 将项目发布到 ...</div></div></div></a><a class="pagination-related" href="/9474fb1165cb/" title="React 详解：核心 API 深度解读"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-27</div><div class="info-item-2">React 详解：核心 API 深度解读</div></div><div class="info-2"><div class="info-item-1"> React 是一个用于构建用户界面的 JavaScript 库。它以声明式的方式让开发者可以轻松构建复杂且交互性强的 UI。要真正驾驭 React，深入理解其核心 API 至关重要。这些 API 是构建组件、管理状态、处理副作用、优化性能以及与其他系统交互的基础。本文将对 React 的核心 API 进行深度解读，涵盖从组件定义到高级优化等各个方面。  核心思想：React 核心 API 围绕组件化、声明式UI、单向数据流和性能优化展开，通过 Hooks 极大地简化了函数组件的状态管理和副作用处理，使复杂逻辑更易组织和复用。   一、React 的核心模块与入口React 库被拆分为两个主要模块：react 和 react-dom。  react: 包含构建组件和定义其行为所需的核心 API（如 Component, useState, useEffect, createContext 等）。 react-dom: 提供与 DOM 交互的特定方法（如 render, createRoot 等），用于将 React 组件渲染到浏览器环境。  react-dom 主要 API1. ...</div></div></div></a><a class="pagination-related" href="/ee52e3b6755a/" title="JavaScript async&#x2F;await 原理详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="info-item-2">JavaScript async&#x2F;await 原理详解</div></div><div class="info-2"><div class="info-item-1"> async/await 是 ES2017 (ECMAScript 2017) 引入的 JavaScript 语法糖，旨在以更简洁、更同步的方式编写基于 Promise 的异步代码。它使得异步操作的链式调用和错误处理变得与传统同步代码非常相似，极大地提升了代码的可读性和可维护性。其核心原理是基于 Promise 和 Generator 函数的结合，并在 JavaScript 事件循环 (Event Loop) 的机制下运行。  核心观点：async/await 并非替代 Promise，而是 Promise 的语法糖。它通过将 async 函数编译成一个状态机，利用 await 关键字暂停函数执行，并通过 Promise 的回调机制在异步操作完成后恢复执行，从而在不阻塞主线程的前提下，实现了“同步”书写异步逻辑的体验。    一、为什么需要 async/await？虽然 Promise 解决了传统回调函数（Callback Hell）的嵌套问题，并通过链式调用提供了更好的结构，但复杂的 Promise 链仍然可能导致代码冗长和理解障碍，尤其是在处理多个相互依赖的异步操作时。 Pr...</div></div></div></a><a class="pagination-related" href="/884dd81c798b/" title="Pinia Colada详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="info-item-2">Pinia Colada详解</div></div><div class="info-2"><div class="info-item-1"> Pinia Colada 是一个为 Vue 3 和 Pinia 设计的高级数据管理和持久化工具，旨在简化异步数据获取、缓存、以及状态在浏览器存储中的持久化。它将 Pinia 的核心优势与强大的数据管理策略相结合，帮助开发者构建更健壮、响应更快、用户体验更流畅的 Web 应用。  核心思想：Pinia Colada 致力于将数据获取 (Fetching)、数据缓存 (Caching)、数据持久化 (Persistence) 和 后端状态同步 (Synchronization) 等复杂逻辑封装在易于使用的 Pinia Store 抽象之上。它使得处理异步数据像管理本地状态一样简单，同时提供声明式的 API 来控制数据的生命周期。   一、为什么需要 Pinia Colada？在现代 Web 应用中，处理异步数据（如来自 API 的数据）和管理其生命周期是一个常见的挑战。仅仅依靠 Pinia 的 actions 来 fetch 数据，并不能很好地解决以下问题：  数据重复请求：多个组件可能请求相同的数据，导致不必要的网络开销。 请求加载状态管理：手动维护每个请求的 loading 和...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">550</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Hydration%EF%BC%9F"><span class="toc-text">一、什么是 Hydration？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Hydration-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、Hydration 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hydration-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">Hydration 工作流示意图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Next-js-%E4%B8%AD%E7%9A%84-Hydration"><span class="toc-text">三、Next.js 中的 Hydration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Hydration-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">四、Hydration 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Hydration-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98"><span class="toc-text">五、Hydration 的常见问题与性能挑战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Hydration-%E4%B8%8D%E5%8C%B9%E9%85%8D-Mismatch-Errors"><span class="toc-text">5.1 Hydration 不匹配 (Mismatch Errors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="toc-text">5.2 性能开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%B4%AF%E7%A7%AF%E5%B8%83%E5%B1%80%E5%81%8F%E7%A7%BB-CLS"><span class="toc-text">5.3 累积布局偏移 (CLS)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%BC%94%E7%A4%BA-Hydration-Mismatch"><span class="toc-text">六、代码示例：演示 Hydration Mismatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Next-js-App-Router-%E4%B8%8E-Hydration-%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="toc-text">七、Next.js App Router 与 Hydration 的未来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-14.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>