<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JWT (JSON Web Tokens) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JWT (JSON Web Token) 是一个开放标准 (RFC 7519)，它定义了一种简洁、自包含且安全的方式，用于在各方之间安全地传输信息。这些信息通过数字签名进行验证，可以被信任。JWT 通常用作无状态 (Stateless) 认证机制，替代传统的 Session-Cookie 模式。  核心思想：将用户认证信息和少量授权信息编码进 Token 本身，并通过签名确保其不可篡改。 服务端">
<meta property="og:type" content="article">
<meta property="og:title" content="JWT (JSON Web Tokens) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/b9b684a2ebc6/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="JWT (JSON Web Token) 是一个开放标准 (RFC 7519)，它定义了一种简洁、自包含且安全的方式，用于在各方之间安全地传输信息。这些信息通过数字签名进行验证，可以被信任。JWT 通常用作无状态 (Stateless) 认证机制，替代传统的 Session-Cookie 模式。  核心思想：将用户认证信息和少量授权信息编码进 Token 本身，并通过签名确保其不可篡改。 服务端">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg">
<meta property="article:published_time" content="2023-12-20T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-21T14:52:45.530Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="JWT">
<meta property="article:tag" content="2023">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JWT (JSON Web Tokens) 详解",
  "url": "https://blog.tbf1211.xx.kg/b9b684a2ebc6/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg",
  "datePublished": "2023-12-20T22:24:00.000Z",
  "dateModified": "2025-11-21T14:52:45.530Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/b9b684a2ebc6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JWT (JSON Web Tokens) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">306</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-31.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">JWT (JSON Web Tokens) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JWT (JSON Web Tokens) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-12-20T22:24:00.000Z" title="发表于 2023-12-21 06:24:00">2023-12-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/b9b684a2ebc6/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>JWT (JSON Web Token)</strong> 是一个<strong>开放标准 (RFC 7519)</strong>，它定义了一种简洁、自包含且安全的方式，用于在各方之间安全地传输信息。这些信息通过数字签名进行验证，可以被信任。JWT 通常用作<strong>无状态 (Stateless) 认证机制</strong>，替代传统的 Session-Cookie 模式。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将用户认证信息和少量授权信息编码进 Token 本身，并通过签名确保其不可篡改。</strong> 服务端无需存储 Session 状态，只需验证 Token 即可。</p>
</div>
<hr>
<h2 id="一、为什么需要-JWT？"><a href="#一、为什么需要-JWT？" class="headerlink" title="一、为什么需要 JWT？"></a>一、为什么需要 JWT？</h2><p>传统的基于 Session-Cookie 的认证方式有其局限性：</p>
<ol>
<li><strong>有状态 (Stateful)</strong>：服务端需要存储每个用户的 Session 信息。随着用户量增加，存储和管理 Session 成为负担，特别是分布式部署和微服务架构下，Session 共享和同步变得复杂。</li>
<li><strong>跨域问题</strong>：Cookie 默认是同源策略，跨域请求携带 Cookie 会比较复杂，需要复杂的 CORS (Cross-Origin Resource Sharing) 配置。</li>
<li><strong>移动端不友好</strong>：移动应用通常不依赖 Cookie，需要更灵活的认证方式。</li>
</ol>
<p>JWT 旨在解决这些问题，提供一种<strong>无状态、易于扩展、跨域友好</strong>的认证解决方案：</p>
<ul>
<li><strong>无状态</strong>：服务器不再需要存储 Session 信息。每个请求都自带 Token，服务器只需解析和验证 Token 即可。</li>
<li><strong>可扩展性</strong>：非常适合微服务架构。认证服务生成 JWT，其他微服务无需访问共享存储，只需验证 JWT 即可获取用户信息。</li>
<li><strong>跨域兼容</strong>：JWT 通常通过 HTTP Header (如 <code>Authorization: Bearer &lt;token&gt;</code>) 传输，不受 Cookie 同源策略限制。</li>
<li><strong>安全性</strong>：通过数字签名确保 Token 不可篡改，同时支持加密以保护敏感信息。</li>
<li><strong>信息自包含</strong>：Token 中包含用户相关信息，避免了多次数据库查询。</li>
</ul>
<h2 id="二、JWT-的结构"><a href="#二、JWT-的结构" class="headerlink" title="二、JWT 的结构"></a>二、JWT 的结构</h2><p>一个 JWT 从形式上看，通常是三个部分通过点号 <code>.</code> 分隔的字符串：</p>
<p><code>header.payload.signature</code></p>
<p>例如：<br><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></p>
<h3 id="2-1-1-Header-头部"><a href="#2-1-1-Header-头部" class="headerlink" title="2.1 1. Header (头部)"></a>2.1 1. Header (头部)</h3><p>Header 通常包含两部分信息：</p>
<ul>
<li><code>alg</code>：指定签名的算法，例如 HS256 (HMAC-SHA256)、RS256 (RSA-SHA256)。</li>
<li><code>typ</code>：指定令牌的类型，通常为 “JWT”。</li>
</ul>
<p><strong>示例 (JSON 格式)：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个 JSON 会经过 Base64Url 编码，成为 JWT 的第一部分。</p>
<h3 id="2-2-2-Payload-载荷"><a href="#2-2-2-Payload-载荷" class="headerlink" title="2.2 2. Payload (载荷)"></a>2.2 2. Payload (载荷)</h3><p>Payload 是 JWT 的主体，包含了一组关于实体（通常是用户）和可应用的额外数据的<strong>声明 (Claims)</strong>。声明分为三类：</p>
<ol>
<li><p><strong>注册声明 (Registered Claims)</strong>：预定义的一些声明，强烈建议使用，但不强制。</p>
<ul>
<li><code>iss</code> (Issuer)：签发人</li>
<li><code>exp</code> (Expiration Time)：过期时间戳，JWT 必须在此时间之前失效</li>
<li><code>sub</code> (Subject)：主题，通常是用户ID</li>
<li><code>aud</code> (Audience)：接收 JWT 的方</li>
<li><code>nbf</code> (Not Before)：在此时间之前，JWT 是无效的</li>
<li><code>iat</code> (Issued At)：签发时间戳</li>
<li><code>jti</code> (JWT ID)：JWT 的唯一标识，用于区分不同的 JWT，防止重放攻击</li>
</ul>
</li>
<li><p><strong>公共声明 (Public Claims)</strong>：可以由使用 JWT 的各方自由定义，但为了避免冲突，应该在 IANA JSON Web Token Registry 中注册，或者将其定义为包含防冲突命名空间的 URI。</p>
</li>
<li><p><strong>私有声明 (Private Claims)</strong>：用于在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。例如，可以包含用户的角色、权限等自定义信息。</p>
</li>
</ol>
<p><strong>示例 (JSON 格式)：</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1516242622</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个 JSON 同样会经过 Base64Url 编码，成为 JWT 的第二部分。</p>
<h3 id="2-3-3-Signature-签名"><a href="#2-3-3-Signature-签名" class="headerlink" title="2.3 3. Signature (签名)"></a>2.3 3. Signature (签名)</h3><p>签名部分用于验证 JWT 的完整性，防止数据被篡改。</p>
<p>生成签名的方式：<br>将 Base64Url 编码后的 Header 和 Base64Url 编码后的 Payload 用点号 <code>.</code> 连接起来，然后使用 Header 中指定的算法（例如 HS256）和密钥 (Secret) 对其进行签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><strong>密钥 (Secret)</strong>：这是一个只有签发方和验证方知道的秘密字符串，绝不能泄露。</li>
<li><strong>确保完整性</strong>：一旦签名完成，如果 Header 或 Payload 中的任何数据被修改，签名就会失效，从而使这个 JWT 无效。</li>
<li><strong>不加密 Payload</strong>：请注意，签名只保证数据未被篡改，但 Payload 中的内容是 Base64Url 编码的，<strong>任何人都可以解读</strong>。因此，<strong>不要在 Payload 中存放敏感信息</strong>。如果需要保护敏感信息，则需要对整个 JWT 进行加密 (JWE - JSON Web Encryption)。</li>
</ul>
<h2 id="三、JWT-的认证流程"><a href="#三、JWT-的认证流程" class="headerlink" title="三、JWT 的认证流程"></a>三、JWT 的认证流程</h2><p><strong>一个典型的 JWT 认证流程如下：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant user as 用户
    participant client as 客户端 (前端&#x2F;App)
    participant auth_server as 认证服务器
    participant resource_server as 资源服务器 (API)

    user-&gt;&gt;client: 1. 提供用户名和密码
    client-&gt;&gt;auth_server: 2. 发送登录请求 (用户名, 密码)
    auth_server-&gt;&gt;auth_server: 3. 验证用户名密码，并生成 JWT
    auth_server-&gt;&gt;client: 4. 返回 JWT (包含 Access Token 和 Refresh Token)
    client-&gt;&gt;client: 5. 客户端存储 JWT (如 localStorage&#x2F;Cookie)

    user-&gt;&gt;client: 6. 用户请求受保护资源
    client-&gt;&gt;resource_server: 7. 在请求头部携带 Access Token &lt;br&#x2F;&gt;(e.g., Authorization: Bearer &lt;Access Token&gt;)
    resource_server-&gt;&gt;resource_server: 8. 验证 Access Token (签名, 过期时间, 内容)
    alt Token有效
        resource_server-&gt;&gt;resource_server: 9. 解析 Payload 获取用户身份信息
        resource_server-&gt;&gt;resource_server: 10. 判断用户是否有权限访问资源
        resource_server-&gt;&gt;client: 11. 返回请求的资源数据
    else Token无效或过期
        resource_server-&gt;&gt;client: 11. 返回 401 Unauthorized
    end
  </pre></div>

<p><strong>刷新令牌 (Refresh Token) 流程：</strong></p>
<p>当 Access Token 过期时，客户端可以使用 Refresh Token 获取新的 Access Token。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant client as 客户端
    participant auth_server as 认证服务器 &#x2F; 授权服务器

    client-&gt;&gt;client: 1. Access Token 过期
    client-&gt;&gt;auth_server: 2. 发送刷新请求 (携带 Refresh Token)
    auth_server-&gt;&gt;auth_server: 3. 验证 Refresh Token 有效性
    alt Refresh Token有效
        auth_server-&gt;&gt;auth_server: 4. 生成新的 Access Token (和新的 Refresh Token)
        auth_server-&gt;&gt;client: 5. 返回新的 Access Token (和新的 Refresh Token)
        client-&gt;&gt;client: 6. 客户端更新存储的 Token
    else Refresh Token无效
        auth_server-&gt;&gt;client: 4. 返回 401 Unauthorized (用户需重新登录)
    end
  </pre></div>

<h2 id="四、JWT-的优缺点与适用场景"><a href="#四、JWT-的优缺点与适用场景" class="headerlink" title="四、JWT 的优缺点与适用场景"></a>四、JWT 的优缺点与适用场景</h2><h3 id="4-1-优点："><a href="#4-1-优点：" class="headerlink" title="4.1 优点："></a>4.1 优点：</h3><ol>
<li><strong>无状态 (Stateless)</strong>：服务端无需存储 Session 信息，扩展性好，适用于分布式系统和微服务架构。</li>
<li><strong>易于扩展</strong>：Payload 可以包含自定义信息，方便传递用户角色、权限等。</li>
<li><strong>跨域友好</strong>：通过 Header 传输，不受 Cookie 同源策略限制，方便实现前后端分离。</li>
<li><strong>去中心化</strong>：一旦签发，任何拥有密钥的服务都可以验证，无需与认证服务进行额外的数据库查询或网络请求。</li>
<li><strong>移动端支持</strong>：非常适合移动应用，无需依赖特定平台的存储机制。</li>
</ol>
<h3 id="4-2-缺点："><a href="#4-2-缺点：" class="headerlink" title="4.2 缺点："></a>4.2 缺点：</h3><ol>
<li><strong>Token 一旦签发，无法作废 (Stateless 的副作用)</strong>：即使服务端发现某个用户账户被盗或被禁用，已签发的 Access Token 在有效期内依然有效。解决方案包括：<ul>
<li>缩短 Access Token 有效期。</li>
<li>维护一个 Token 黑名单&#x2F;撤销列表 (Revocation List)。但这将引入状态，部分牺牲了无状态的优势。</li>
</ul>
</li>
<li><strong>Payload 信息泄露风险</strong>：Payload 经过 Base64Url 编码，<strong>未加密</strong>，任何人都可以解码查看。<strong>绝不能存放敏感信息</strong>。</li>
<li><strong>Token 长度问题</strong>：如果 Payload 包含大量信息，Token 会变长，增加网络传输开销。</li>
<li><strong>安全存储</strong>：客户端（尤其是浏览器）如何安全存储 JWT 是一个挑战。<ul>
<li>存储在 <code>localStorage</code>&#x2F;<code>sessionStorage</code> 中容易受到 XSS 攻击。</li>
<li>存储在 <code>HttpOnly</code> 的 <code>Cookie</code> 中可以防范 XSS，但可能面临 CSRF 攻击，且移动端或某些前端框架获取 Token 不便。<strong>通常推荐混合使用：Access Token 存 <code>localStorage</code> (短有效期)，Refresh Token 存 <code>HttpOnly</code> <code>Cookie</code> (长有效期)，并结合 CSRF 防护。</strong></li>
</ul>
</li>
</ol>
<h3 id="4-3-适用场景："><a href="#4-3-适用场景：" class="headerlink" title="4.3 适用场景："></a>4.3 适用场景：</h3><ul>
<li><strong>无状态 API 和微服务架构</strong>：服务端无需存储 Session，易于伸缩和解耦。</li>
<li><strong>移动应用和单页应用 (SPA)</strong>：与传统 Cookie 模式相比，更灵活、更友好。</li>
<li><strong>跨域认证</strong>：天然支持跨域请求。</li>
<li><strong>授权中心</strong>：OAuth 2.0 中，Access Token 可以是 JWT 格式。</li>
</ul>
<h2 id="五、安全性考虑"><a href="#五、安全性考虑" class="headerlink" title="五、安全性考虑"></a>五、安全性考虑</h2><ol>
<li><strong>密钥安全</strong>：用于签名的密钥必须高度保密，且足够复杂。一旦泄露，攻击者可以伪造 JWT。</li>
<li><strong>Access Token 有效期</strong>：设置较短的过期时间，例如 15 分钟到 1 小时。</li>
<li><strong>Refresh Token 机制</strong>：结合 Refresh Token 来获取新的 Access Token，降低 Access Token 泄露的风险。Refresh Token 的有效期可以长一些，但每次使用后最好更换，并应支持随时撤销。</li>
<li><strong>HTTPS&#x2F;SSL</strong>：所有 JWT 相关的通信都<strong>必须</strong>通过 HTTPS 进行，防止令牌在传输过程中被窃听。</li>
<li><strong>Payload 敏感信息</strong>：<strong>绝不在 Payload 中存储敏感用户数据</strong>（如密码、身份证号）。</li>
<li><strong>防止 XSS 攻击</strong>：如果 JWT 存储在 <code>localStorage</code> 中，前端代码需做好 XSS 防范。</li>
<li><strong>防止 CSRF 攻击</strong>：如果 JWT 存储在 <code>Cookie</code> 中，需使用 CSRF Token 等机制进行防护。</li>
<li><strong>JTI (JWT ID)</strong>：使用 <code>jti</code> 声明可以为每个 JWT 提供唯一标识，有助于实现令牌的黑名单或防止重放攻击。</li>
<li><strong>Token 黑名单&#x2F;撤销列表</strong>：对于需要实时作废用户 Token 的场景 (如用户登出、修改密码、系统管理员强制下线)，服务端需要维护一个黑名单，存储已作废的 Token 的 <code>jti</code> 或整个 Token。这会引入状态，但对于某些业务需求是必要的。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>JWT 提供了一种高效、无状态的认证和授权机制，在现代 Web 开发中，特别是前后端分离、微服务、移动应用领域得到了广泛应用。它简化了服务器端的状态管理，提升了系统的扩展性。然而，为了确保安全性，开发者必须深入理解其工作原理，并严格遵循安全存储、签发、验证以及刷新令牌的最佳实践。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/b9b684a2ebc6/">https://blog.tbf1211.xx.kg/b9b684a2ebc6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/JWT/">JWT</a><a class="post-meta__tags" href="/tags/2023/">2023</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f35a31a1b5c1/" title="PHP 各个版本新特性详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">PHP 各个版本新特性详解</div></div><div class="info-2"><div class="info-item-1"> PHP 作为最流行的后端脚本语言之一，自诞生以来便不断演进。从早期的松散特性到现代的强类型、高性能，每一次版本迭代都带来了显著的改进。本文将详细回顾 PHP 7.0 以后，各个主要版本（7.x 和 8.x 系列）引入的新特性、性能提升和废弃功能，帮助开发者理解 PHP 的发展轨迹并更好地进行技术选型和代码迁移。  核心思想：PHP 的演进主线是：提高性能、增强类型系统、简化语法、引入现代编程范式和清理历史遗留问题。   一、PHP 7.0 (2015年) - 性能飞跃的起点PHP 7.0 是一个里程碑式的版本，其最大的亮点是引入了全新的 Zend Engine (Zend Engine 3.0，代号 PHPNG)，带来了惊人的性能提升。 1.1 核心特性与性能提升 Zend Engine 3.0 (PHPNG)：这是 7.0 最大的亮点。与 PHP 5.6 相比，PHP 7.0 在实际应用中实现了 2 倍甚至更高的性能提升，大幅降低了内存消耗。这是通过重写 Zend Engine 的核心，优化了数据结构、Opcodes 处理和垃圾回收机制实现的。 抽象语法树 (Abstract...</div></div></div></a><a class="pagination-related" href="/54ebd0b1bf52/" title="三体 III：死神永生——文明的终极归宿"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">三体 III：死神永生——文明的终极归宿</div></div><div class="info-2"><div class="info-item-1"> 《三体 III：死神永生》 是中国作家刘慈欣创作的长篇科幻小说《三体》系列的第三部，于 2010 年出版。作为系列的终结篇，它将故事的维度从地球文明的存亡提升到整个宇宙文明的演化与归宿。小说以宏大的笔触描绘了人类文明在“黑暗森林”法则下的挣扎、绝望与最终的超脱，探讨了宇宙的终极命运、维度战争以及生命存在的意义。  核心思想：《死神永生》在“黑暗森林”法则的基础上，引入了维度打击、光速飞船、黑域等更高级的宇宙战争形式，展现了人类文明在宇宙尺度上的渺小与脆弱。它通过程心、AA、关一帆等角色的经历，探讨了爱、责任、选择对文明命运的影响，最终将读者带入对宇宙终极归零的哲学思考。   一、承接与时间跨度《三体 III》的故事承接《三体 II：黑暗森林》的结局——罗辑作为“执剑人”维持着地球与三体文明之间的脆弱威慑平衡。然而，这一平衡在小说中被打破。 本部的时间跨度极为宏大，从 21 世纪初一直延伸到宇宙末日，甚至在宇宙重启后的新纪元，跨越了数千万年甚至数十亿年，展现了人类文明在宇宙历史长河中的短暂与微不足道。 二、故事情节概述2.1 执剑人的传承与威慑的失效故事开始于威慑纪元，罗辑作为“...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ab5735004159/" title="无感刷新Token详解：提升用户体验与系统安全的认证策略"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="info-item-2">无感刷新Token详解：提升用户体验与系统安全的认证策略</div></div><div class="info-2"><div class="info-item-1"> 在现代 Web 和移动应用中，基于 Token 的认证方式（如 JWT）已成为主流。它解决了传统 Session-Cookie 认证在分布式系统和跨域场景下的诸多痛点。然而，Token 的有效期问题又带来了新的挑战：如果 Access Token 长期有效，一旦泄露风险巨大；如果短期有效，用户又会频繁因 Token 过期而被迫重新登录，严重影响用户体验。无感刷新 Token (Silent Token Refresh) 正是为了解决这一矛盾而生，它旨在提升安全性、兼顾用户体验，让用户在不感知的情况下，始终保持登录状态。  “无感刷新 Token 的核心思想是：使用一个短期有效的 Access Token 负责日常业务访问，同时使用一个长期有效但受严密保护的 Refresh Token 来在 Access Token 过期时重新获取新的 Access Token，从而实现长期登录且不牺牲安全性的目标。”   一、为什么需要无感刷新 Token？在基于 Token 的认证系统中，通常会涉及到两种 Token：  Access Token (访问令牌)：  用途：用于访问受保护的资源...</div></div></div></a><a class="pagination-related" href="/f6138d30a597/" title="常见网络攻击详解与预防：构建数字安全防线"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">常见网络攻击详解与预防：构建数字安全防线</div></div><div class="info-2"><div class="info-item-1"> 在数字时代，网络攻击已成为无处不在的威胁。从个人数据泄露到企业系统瘫痪，网络攻击的危害日益增长，形式也越来越多样化。理解这些S攻击类型、攻击原理以及如何有效预防它们，是构建强大数字安全防线的基石。本文将详细介绍一些最常见的网络攻击及其相应的防范措施。  “网络安全不是一蹴而就的，而是一个持续不断的过程，需要技术、策略和人的共同努力。”   一、概述：网络攻击的种类与威胁网络攻击通常利用系统、应用或协议的漏洞，试图破坏数据的机密性（Confidentiality）、完整性（Integrity）和可用性（Availability），即所谓的 CIA 三要素。 根据攻击目标和手段，网络攻击可以分为多种类型：  拒绝服务攻击 (DoS&#x2F;DDoS)：破坏系统的可用性。 数据窃取&#x2F;泄露：破坏数据的机密性。 数据篡改：破坏数据的完整性。 恶意程序感染：破坏系统的可控性，窃取数据或进行其他恶意活动。 社会工程学攻击：利用人性的弱点进行欺骗。  接下来，我们将详细解析几种最常见的攻击类型。 二、常见网络攻击详解与预防2.1 拒绝服务攻击 (DoS &#x2F; DDoS)2....</div></div></div></a><a class="pagination-related" href="/964ae22dfd06/" title="渗透测试原理详解：深入了解网络安全攻防"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-16</div><div class="info-item-2">渗透测试原理详解：深入了解网络安全攻防</div></div><div class="info-2"><div class="info-item-1"> 渗透测试（Penetration Testing） 是一种有目的、有计划的模拟攻击行为，旨在评估信息系统、网络、应用程序或组织的安全防护能力。它模拟恶意攻击者可能使用的技术和方法，主动发现系统中的安全漏洞、弱点和配置错误，并评估这些漏洞可能造成的潜在影响。渗透测试的最终目标是帮助组织识别并修复安全缺陷，提高整体的安全韧性，而非破坏或窃取数据。  核心思想：渗透测试像一次“模拟实战演习”，由专业的“红队”（渗透测试人员）扮演“黑客”，通过合法授权的攻击手段，挑战组织的“蓝队”（安全防护系统），从而发现真实世界中可能存在的安全盲点和薄弱环节。   一、为什么需要渗透测试？在当今高度互联的世界中，网络攻击日益频繁且复杂。传统的安全审计、漏洞扫描、代码审查等方法虽然重要，但它们往往局限于静态分析或已知漏洞的检测。渗透测试的价值在于：  主动发现未知漏洞：通过模拟真实攻击者的思维和手法，发现仅靠工具扫描难以识别的逻辑漏洞、业务漏洞和组合漏洞。 验证安全控制的有效性：测试已部署的安全设备（如防火墙、IDS&#x2F;IPS）、安全策略和人员响应机制是否能有效抵御攻击。 评估业务影响：清晰地...</div></div></div></a><a class="pagination-related" href="/9186b4c4e58d/" title="重放攻击 (Replay Attack) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="info-item-2">重放攻击 (Replay Attack) 详解</div></div><div class="info-2"><div class="info-item-1"> 重放攻击 (Replay Attack)，又称回放攻击或重播攻击，是计算机网络安全领域中的一种常见攻击方式。其基本原理是攻击者通过窃听（截获）合法的网络通信数据包，然后将这些截获到的数据包原封不动地重新发送给一个或多个目标系统，以此来欺骗系统或获得未授权的效应。即使攻击者不知道数据包内容的具体含义，也可以通过重放这些合法的数据包来达到攻击目的。  核心思想：攻击者窃取一次成功的会话或请求，并在之后的时间里重复发送这段数据，以冒充合法用户获得同样的权限或发起相同的操作。   一、重放攻击的工作原理重放攻击的步骤通常如下：  窃听 (Eavesdropping)：攻击者使用网络嗅探工具（如 Wireshark）在网络上监听和截获合法用户与服务器之间的通信。这可能包括登录凭证（尽管通常是哈希或加密的）、交易请求、授权令牌等。 截获 (Interception)：攻击者捕获到完整的、有效的通信数据包或消息序列。 重放 (Replay)：在一段时间之后，攻击者将这些截获到的数据包原封不动地重新发送给目标服务器。 欺骗 (Deception)：如果目标服务器没有有效的机制来验证请求的新鲜性...</div></div></div></a><a class="pagination-related" href="/1e63b415b706/" title="AEAD (Authenticated Encryption with Associated Data) 加密方式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-25</div><div class="info-item-2">AEAD (Authenticated Encryption with Associated Data) 加密方式详解</div></div><div class="info-2"><div class="info-item-1"> AEAD (Authenticated Encryption with Associated Data)，即带关联数据的认证加密，是现代密码学中的一个重要概念和加密模式。它不仅仅提供传统加密算法的机密性 (Confidentiality)，还能同时保障数据的完整性 (Integrity) 和真实性 (Authenticity)。此外，AEAD 模式允许对“关联数据”进行认证，这些数据不需要加密，但其完整性也需要被验证。  核心思想：将加密（提供机密性）和消息认证码 (MAC, 提供完整性和真实性) 组合到一个单一的密码操作中，同时允许对非加密数据进行认证。   一、为什么需要 AEAD？在 AEAD 出现之前，密码学中存在两种主要的安全目标：  机密性 (Confidentiality)：通过加密手段（如 AES、ChaCha20）使未经授权的方无法读取数据。 完整性 (Integrity) 和真实性 (Authenticity)：通过消息认证码 (MAC) 或数字签名来确保数据在传输过程中未被篡改，并确认数据确实来自声称的发送方。  传统的加密方式（如 ECB、CBC 模式的...</div></div></div></a><a class="pagination-related" href="/29965d782f2a/" title="Metasploit 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-18</div><div class="info-item-2">Metasploit 框架详解</div></div><div class="info-2"><div class="info-item-1"> Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1 什么是 Metasploit？Metasploit 是由 Rapid7 公司维护的一个著名的开源项目。它是一个漏洞利用框架，旨在协助渗透测试人员识别、利用和验证漏洞。它不仅仅是一个简单的漏洞扫描器，更是一个提供多种工具和方法的集成环境，几乎覆盖了渗透测试的整个生命周期。 1.2 Metasploit 的发展历史 2003年：由 H.D. Moore 发起，最初是一个 Perl 语言的项目。 2004年：发布 2.0 版本，首次引入了模块化架构。 2007年：框架被重写，使用 Ruby 语言，提高了灵活性和可维护性。 209年：Rapid7 收购 Metasploit 项目，并继续其开发...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">306</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-JWT%EF%BC%9F"><span class="toc-text">一、为什么需要 JWT？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JWT-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">二、JWT 的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-Header-%E5%A4%B4%E9%83%A8"><span class="toc-text">2.1 1. Header (头部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-Payload-%E8%BD%BD%E8%8D%B7"><span class="toc-text">2.2 2. Payload (载荷)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-Signature-%E7%AD%BE%E5%90%8D"><span class="toc-text">2.3 3. Signature (签名)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81JWT-%E7%9A%84%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B"><span class="toc-text">三、JWT 的认证流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JWT-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、JWT 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">4.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">4.2 缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">4.3 适用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">五、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"/></a><div class="content"><a class="title" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析">压缩字典树 (Radix Trie/Patricia Trie) 深度解析</a><time datetime="2025-11-17T22:24:00.000Z" title="发表于 2025-11-18 06:24:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c28be5a597e1/" title="Golang 内存对齐详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 内存对齐详解"/></a><div class="content"><a class="title" href="/c28be5a597e1/" title="Golang 内存对齐详解">Golang 内存对齐详解</a><time datetime="2025-11-12T22:24:00.000Z" title="发表于 2025-11-13 06:24:00">2025-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 空结构体 (struct{}) 详解"/></a><div class="content"><a class="title" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解">Golang 空结构体 (struct{}) 详解</a><time datetime="2025-11-10T22:24:00.000Z" title="发表于 2025-11-11 06:24:00">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b100840425a8/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codex 详解与使用技巧：OpenAI 的代码智能模型"/></a><div class="content"><a class="title" href="/b100840425a8/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型">Codex 详解与使用技巧：OpenAI 的代码智能模型</a><time datetime="2025-11-06T22:24:00.000Z" title="发表于 2025-11-07 06:24:00">2025-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Claude Code 详解：Anthropic 的代码智能模型"/></a><div class="content"><a class="title" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型">Claude Code 详解：Anthropic 的代码智能模型</a><time datetime="2025-11-04T22:24:00.000Z" title="发表于 2025-11-05 06:24:00">2025-11-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-31.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>