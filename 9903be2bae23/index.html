<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>常用限流算法的Go语言实现详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="限流 (Rate Limiting) 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。  核心思想：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。   一、为什么">
<meta property="og:type" content="article">
<meta property="og:title" content="常用限流算法的Go语言实现详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/9903be2bae23/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="限流 (Rate Limiting) 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。  核心思想：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。   一、为什么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg">
<meta property="article:published_time" content="2025-10-15T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-19T07:23:07.527Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="限流算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "常用限流算法的Go语言实现详解",
  "url": "https://blog.tbf1211.xx.kg/9903be2bae23/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg",
  "datePublished": "2025-10-15T22:24:00.000Z",
  "dateModified": "2025-12-19T07:23:07.527Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/9903be2bae23/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常用限流算法的Go语言实现详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">397</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">214</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-19.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">常用限流算法的Go语言实现详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">常用限流算法的Go语言实现详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/9903be2bae23/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>限流 (Rate Limiting)</strong> 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。</p>
</div>
<hr>
<h2 id="一、为什么需要限流？"><a href="#一、为什么需要限流？" class="headerlink" title="一、为什么需要限流？"></a>一、为什么需要限流？</h2><ol>
<li><strong>防止系统过载</strong>：当请求量超出系统处理能力时，限流可以拒绝一部分请求，保证剩余请求能够正常响应，而不是所有请求都失败。</li>
<li><strong>避免雪崩效应</strong>：在微服务架构中，一个服务过载可能导致其依赖的服务也跟着过载，最终演变成整个系统的瘫痪。限流可以切断这种连锁反应。</li>
<li><strong>保护下游资源</strong>：数据库、缓存、第三方 API 等资源通常更加脆弱，限流可以保护它们免受过高压力的冲击。</li>
<li><strong>资源公平分配</strong>：对于多租户或多用户系统，限流可以确保每个用户或租户都能获得公平的资源配额。</li>
<li><strong>防止恶意攻击</strong>：例如 DoS&#x2F;DDoS 攻击，通过限制请求速率可以有效缓解攻击对系统的影响。</li>
<li><strong>费用控制</strong>：对于按请求量付费的第三方服务，限流可以有效控制成本。</li>
</ol>
<h2 id="二、常用限流算法"><a href="#二、常用限流算法" class="headerlink" title="二、常用限流算法"></a>二、常用限流算法</h2><p>本节将详细介绍三种最常用的限流算法：<strong>固定窗口计数器</strong>、<strong>滑动窗口计数器</strong>、<strong>漏桶算法</strong> 和 <strong>令牌桶算法</strong>，并提供它们的 Go 语言实现。</p>
<h3 id="2-1-固定窗口计数器-Fixed-Window-Counter"><a href="#2-1-固定窗口计数器-Fixed-Window-Counter" class="headerlink" title="2.1 固定窗口计数器 (Fixed Window Counter)"></a>2.1 固定窗口计数器 (Fixed Window Counter)</h3><h4 id="2-1-1-算法原理"><a href="#2-1-1-算法原理" class="headerlink" title="2.1.1 算法原理"></a>2.1.1 算法原理</h4><p>固定窗口计数器算法是最简单、最容易理解的限流算法。它在一个固定的时间窗口（例如 1 分钟）内统计请求数量。当请求到来时，计数器加一。如果计数器值超过预设的阈值，则拒绝该请求。当时间窗口结束时，计数器清零，开始下一个窗口的计数。</p>
<p><strong>优点</strong>：实现简单，易于理解。<br><strong>缺点</strong>：存在“临界点问题”。在窗口的开始和结束交界处，可能会在短时间内涌入双倍于阈值的请求，导致瞬时流量超过系统承载能力。例如，限流 100 QPS，窗口是 1 秒。在第 0.9 秒时来了 100 个请求，在第 1.1 秒时又来了 100 个请求，那么在 0.9 到 1.1 秒这 0.2 秒内，系统处理了 200 个请求，是阈值的两倍。</p>
<h4 id="2-1-2-Go-语言实现"><a href="#2-1-2-Go-语言实现" class="headerlink" title="2.1.2 Go 语言实现"></a>2.1.2 Go 语言实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FixedWindowLimiter 固定窗口限流器</span></span><br><span class="line"><span class="keyword">type</span> FixedWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	windowSize time.Duration <span class="comment">// 窗口大小</span></span><br><span class="line">	threshold  <span class="type">int</span>           <span class="comment">// 阈值 (窗口内最大请求数)</span></span><br><span class="line">	counter    <span class="type">int</span>           <span class="comment">// 当前窗口内的请求计数</span></span><br><span class="line">	lastReset  time.Time     <span class="comment">// 上次窗口重置时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFixedWindowLimiter 创建一个新的固定窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFixedWindowLimiter</span><span class="params">(windowSize time.Duration, threshold <span class="type">int</span>)</span></span> *FixedWindowLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;FixedWindowLimiter&#123;</span><br><span class="line">		windowSize: windowSize,</span><br><span class="line">		threshold:  threshold,</span><br><span class="line">		counter:    <span class="number">0</span>,</span><br><span class="line">		lastReset:  time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *FixedWindowLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	now := time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前时间超过了上一个窗口的结束，则重置窗口</span></span><br><span class="line">	<span class="keyword">if</span> now.Sub(l.lastReset) &gt;= l.windowSize &#123;</span><br><span class="line">		l.counter = <span class="number">0</span></span><br><span class="line">		l.lastReset = now <span class="comment">// 重置 lastReset 为当前时间，开始新窗口</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前窗口内的请求数是否超过阈值</span></span><br><span class="line">	<span class="keyword">if</span> l.counter &lt; l.threshold &#123;</span><br><span class="line">		l.counter++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	limiter := NewFixedWindowLimiter(time.Second, <span class="number">3</span>) <span class="comment">// 每秒允许 3 个请求</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 固定窗口限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每隔 100 毫秒发出请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒后...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待窗口重置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== 固定窗口限流器测试 ===</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br><span class="line">请求 6 拒绝</span><br><span class="line">请求 7 拒绝</span><br><span class="line">请求 8 拒绝</span><br><span class="line">请求 9 拒绝</span><br><span class="line">请求 10 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒后...</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br></pre></td></tr></table></figure>

<h3 id="2-2-滑动窗口计数器-Sliding-Window-Counter"><a href="#2-2-滑动窗口计数器-Sliding-Window-Counter" class="headerlink" title="2.2 滑动窗口计数器 (Sliding Window Counter)"></a>2.2 滑动窗口计数器 (Sliding Window Counter)</h3><h4 id="2-2-1-算法原理"><a href="#2-2-1-算法原理" class="headerlink" title="2.2.1 算法原理"></a>2.2.1 算法原理</h4><p>滑动窗口计数器算法是固定窗口计数器的改进版，旨在解决临界点问题。它将一个大的时间窗口（如 1 分钟）划分为更多小的时间片（如 10 个 6 秒的窗口）。每个小时间片都有独立的计数器。</p>
<p>当请求到来时，它会落入当前的小时间片。我们计算当前大窗口内的请求总数，这个总数是当前小时间片的计数，加上前面若干个完整小时间片的计数，再加上前一个小时间片中未满部分的请求计数。</p>
<p><strong>更经典的实现方式</strong>：<br>存储每个请求的时间戳在一个队列 (或切片) 中。当新请求到来时，删除所有超过当前时间窗口的旧请求。然后判断剩余请求的数量是否小于阈值。</p>
<p><strong>优点</strong>：解决了固定窗口的临界点问题，平滑了流量。<br><strong>缺点</strong>：实现相对复杂，需要存储请求的时间戳，占用内存。如果请求量非常大，存储和清理时间戳的开销会比较高。</p>
<h4 id="2-2-2-Go-语言实现"><a href="#2-2-2-Go-语言实现" class="headerlink" title="2.2.2 Go 语言实现"></a>2.2.2 Go 语言实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SlidingWindowLimiter 滑动窗口限流器 (基于时间戳队列)</span></span><br><span class="line"><span class="keyword">type</span> SlidingWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	windowSize time.Duration     <span class="comment">// 窗口大小</span></span><br><span class="line">	threshold  <span class="type">int</span>               <span class="comment">// 阈值 (窗口内最大请求数)</span></span><br><span class="line">	timestamps []time.Time       <span class="comment">// 存储请求到达的时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSlidingWindowLimiter 创建一个新的滑动窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlidingWindowLimiter</span><span class="params">(windowSize time.Duration, threshold <span class="type">int</span>)</span></span> *SlidingWindowLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;SlidingWindowLimiter&#123;</span><br><span class="line">		windowSize: windowSize,</span><br><span class="line">		threshold:  threshold,</span><br><span class="line">		timestamps: <span class="built_in">make</span>([]time.Time, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SlidingWindowLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	now := time.Now()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 清理过期的时间戳</span></span><br><span class="line">	<span class="comment">// 遍历并删除所有超出当前时间窗口的旧请求时间戳</span></span><br><span class="line">	<span class="comment">// 因为切片的删除操作效率较低，更高效的方式是使用双向链表或环形队列</span></span><br><span class="line">	<span class="comment">// 这里为简化演示，使用切片</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Two-pointer approach for efficient deletion</span></span><br><span class="line">	idx := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(l.timestamps); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> now.Sub(l.timestamps[i]) &lt; l.windowSize &#123;</span><br><span class="line">			l.timestamps[idx] = l.timestamps[i]</span><br><span class="line">			idx++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	l.timestamps = l.timestamps[:idx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前窗口内的请求数是否超过阈值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l.timestamps) &lt; l.threshold &#123;</span><br><span class="line">		l.timestamps = <span class="built_in">append</span>(l.timestamps, now)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	limiter := NewSlidingWindowLimiter(time.Second, <span class="number">3</span>) <span class="comment">// 每秒允许 3 个请求</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 滑动窗口限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="comment">// 测试临界点效应</span></span><br><span class="line">	<span class="comment">// 在 0.9s 时发满 3 个请求</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在 0.9s 到 1.0s 之间，等待 0.4s (到 0.9s + 0.4s = 1.3s 时)</span></span><br><span class="line">	<span class="comment">// 期望在 1.0s 后，前面 0.1s 的请求才开始过期</span></span><br><span class="line">	time.Sleep(<span class="number">400</span> * time.Millisecond) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时当前窗口的有效请求是 第 1.3s - 1s = 0.3s 之前的所有请求</span></span><br><span class="line">	<span class="comment">// 直到第 0.1s 的请求在 1.1s 时才过期</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 以 100ms 的频率再发 5 个请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">4</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">4</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n等待 1 秒后 (大部分请求已从窗口中移除)...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待窗口中的大部分请求过期</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=== 滑动窗口限流器测试 ===</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br><span class="line">请求 6 拒绝</span><br><span class="line">请求 7 拒绝</span><br><span class="line">请求 8 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒后 (大部分请求已从窗口中移除)...</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br></pre></td></tr></table></figure>
<p>可以看到，在高频请求下，滑动窗口能更平滑地拒绝请求，避免固定窗口的瞬时流量峰值问题。</p>
<h3 id="2-3-漏桶算法-Leaky-Bucket"><a href="#2-3-漏桶算法-Leaky-Bucket" class="headerlink" title="2.3 漏桶算法 (Leaky Bucket)"></a>2.3 漏桶算法 (Leaky Bucket)</h3><h4 id="2-3-1-算法原理"><a href="#2-3-1-算法原理" class="headerlink" title="2.3.1 算法原理"></a>2.3.1 算法原理</h4><p>漏桶算法的核心思想是：所有的请求都会先进入一个“桶”中，桶的容量有限。请求以恒定的速率从桶中流出（被处理）。<br>如果请求到达时桶是满的，那么该请求会被丢弃（拒绝）。</p>
<p><strong>优点</strong>：能够平滑突发流量，使输出速率保持恒定。<br><strong>缺点</strong>：无法有效地处理突发流量。即使系统具备处理短时突发的能力，漏桶算法也会将请求均匀化处理，可能导致资源利用率不足。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[请求流入] --&gt; B[漏桶]
    B -- 容量满 --&gt; C{丢弃请求}
    B -- 固定速率流出 --&gt; D[请求处理]
  </pre></div>

<h4 id="2-3-2-Go-语言实现"><a href="#2-3-2-Go-语言实现" class="headerlink" title="2.3.2 Go 语言实现"></a>2.3.2 Go 语言实现</h4><p>漏桶算法通常使用一个固定大小的缓冲队列和 Goroutine 来模拟漏出过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeakyBucketLimiter 漏桶限流器</span></span><br><span class="line"><span class="keyword">type</span> LeakyBucketLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity      <span class="type">int</span>           <span class="comment">// 桶的容量</span></span><br><span class="line">	rate          time.Duration <span class="comment">// 请求流出速率 (每 rate 时间单位流出一个请求)</span></span><br><span class="line">	bucket        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 模拟桶的通道</span></span><br><span class="line">	closeChan     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 用于关闭漏桶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLeakyBucketLimiter 创建一个新的漏桶限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeakyBucketLimiter</span><span class="params">(capacity <span class="type">int</span>, rate time.Duration)</span></span> *LeakyBucketLimiter &#123;</span><br><span class="line">	limiter := &amp;LeakyBucketLimiter&#123;</span><br><span class="line">		capacity:  capacity,</span><br><span class="line">		rate:      rate,</span><br><span class="line">		bucket:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity), <span class="comment">// 缓冲通道模拟桶</span></span><br><span class="line">		closeChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> limiter.leak() <span class="comment">// 启动漏出 Goroutine</span></span><br><span class="line">	<span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak 模拟请求从桶中漏出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> leak() &#123;</span><br><span class="line">	ticker := time.NewTicker(l.rate) <span class="comment">// 设置漏出速率</span></span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C: <span class="comment">// 定时从桶中取出一个请求</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-l.bucket: <span class="comment">// 尝试从桶中“漏出”一个请求</span></span><br><span class="line">				<span class="comment">// 请求被成功漏出，可以进行处理</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 桶为空，没有请求可漏出</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-l.closeChan:</span><br><span class="line">			fmt.Println(<span class="string">&quot;漏桶已关闭.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 尝试将请求放入桶中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> l.bucket &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// 尝试将请求放入桶中</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 成功放入，允许通过</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// 桶已满，无法放入</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 拒绝请求</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭漏桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> Close() &#123;</span><br><span class="line">	<span class="built_in">close</span>(l.closeChan)</span><br><span class="line">	<span class="built_in">close</span>(l.bucket)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 容量 3，每 200 毫秒处理一个请求 (即 5 QPS)</span></span><br><span class="line">	limiter := NewLeakyBucketLimiter(<span class="number">3</span>, <span class="number">200</span> * time.Millisecond) </span><br><span class="line">	<span class="keyword">defer</span> limiter.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 漏桶限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 每 50ms 发一个请求 (即 20 QPS 突发流量)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (进入桶)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (桶已满)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待一段时间，看桶中请求是否漏出...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) </span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n再次测试漏桶...&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 以 100ms 频率发请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (进入桶)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (桶已满)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=== 漏桶限流器测试 ===</span><br><span class="line">请求 1 允许通过 (进入桶)</span><br><span class="line">请求 2 允许通过 (进入桶)</span><br><span class="line">请求 3 允许通过 (进入桶)</span><br><span class="line">请求 4 拒绝 (桶已满)</span><br><span class="line">请求 5 拒绝 (桶已满)</span><br><span class="line">请求 6 拒绝 (桶已满)</span><br><span class="line">... (直到请求 15 都是拒绝)</span><br><span class="line"></span><br><span class="line">等待一段时间，看桶中请求是否漏出... (此处 Goroutine 在后台持续漏出请求)</span><br><span class="line"></span><br><span class="line">再次测试漏桶...</span><br><span class="line">请求 1 允许通过 (进入桶)</span><br><span class="line">请求 2 允许通过 (进入桶)</span><br><span class="line">请求 3 允许通过 (进入桶)</span><br><span class="line">请求 4 拒绝 (桶已满)</span><br><span class="line">请求 5 拒绝 (桶已满)</span><br></pre></td></tr></table></figure>
<p>可以看到，在突发流量下，漏桶很快就满了，后续请求都被拒绝。但桶内的请求仍然以恒定速率处理。</p>
<h3 id="2-4-令牌桶算法-Token-Bucket"><a href="#2-4-令牌桶算法-Token-Bucket" class="headerlink" title="2.4 令牌桶算法 (Token Bucket)"></a>2.4 令牌桶算法 (Token Bucket)</h3><h4 id="2-4-1-算法原理"><a href="#2-4-1-算法原理" class="headerlink" title="2.4.1 算法原理"></a>2.4.1 算法原理</h4><p>令牌桶算法是目前最常用且最灵活的限流算法之一。它的工作原理是：</p>
<ol>
<li>一个固定容量的“令牌桶”会以恒定的速率往里添加令牌。</li>
<li>每个请求到来时，需要从桶中获取一个令牌。</li>
<li>如果桶中有足够的令牌，请求就可以通过，并消耗一个令牌。</li>
<li>如果桶中没有令牌，请求可以选择等待令牌的生成，或者直接被拒绝。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>允许一定程度的突发流量</strong>：桶的容量决定了可以累积的最大令牌数，也就是允许通过的最大突发请求数。</li>
<li><strong>输出速率可控</strong>：令牌生成速率控制了长期来看的平均处理速率。</li>
<li><strong>实现灵活</strong>：可以很容易地调整桶容量和生成速率。</li>
</ul>
<p><strong>缺点</strong>：实现比计数器复杂，但比漏桶更灵活。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;令牌生成器 (固定速率)&quot;] --&gt; B[令牌桶]
    B -- 含有令牌 --&gt; C[请求通过]
    D[请求到达] --&gt; B
    B -- 无令牌 --&gt; E{请求等待&#x2F;拒绝}
  </pre></div>

<h4 id="2-4-2-Go-语言实现"><a href="#2-4-2-Go-语言实现" class="headerlink" title="2.4.2 Go 语言实现"></a>2.4.2 Go 语言实现</h4><p>Go 语言标准库 <code>golang.org/x/time/rate</code> 包提供了高度优化和生产可用的令牌桶限流器。这里我们先实现一个简化版的，再介绍标准库的使用。</p>
<p><strong>简化版实现</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TokenBucketLimiter 令牌桶限流器</span></span><br><span class="line"><span class="keyword">type</span> TokenBucketLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	capacity    <span class="type">int</span>           <span class="comment">// 桶的容量 (最多能存多少令牌)</span></span><br><span class="line">	tokens      <span class="type">int</span>           <span class="comment">// 当前桶中令牌数量</span></span><br><span class="line">	rate        time.Duration <span class="comment">// 令牌生成速率 (每 rate 时间单位生成一个令牌)</span></span><br><span class="line">	lastRefill  time.Time     <span class="comment">// 上次补充令牌的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTokenBucketLimiter 创建一个新的令牌桶限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTokenBucketLimiter</span><span class="params">(capacity <span class="type">int</span>, rate time.Duration)</span></span> *TokenBucketLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TokenBucketLimiter&#123;</span><br><span class="line">		capacity:    capacity,</span><br><span class="line">		tokens:      capacity, <span class="comment">// 初始时桶是满的</span></span><br><span class="line">		rate:        rate,</span><br><span class="line">		lastRefill:  time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// refill 补充令牌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TokenBucketLimiter)</span></span> refill() &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 计算距离上次补充令牌过去了多少个“rate”时间单位</span></span><br><span class="line">	duration := now.Sub(l.lastRefill)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// numberOfTokensToAdd = 过去的时间 / 每生成一个令牌的时间</span></span><br><span class="line">	tokensToAdd := <span class="type">int</span>(duration / l.rate) </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> tokensToAdd &gt; <span class="number">0</span> &#123;</span><br><span class="line">		l.tokens += tokensToAdd</span><br><span class="line">		<span class="keyword">if</span> l.tokens &gt; l.capacity &#123;</span><br><span class="line">			l.tokens = l.capacity <span class="comment">// 令牌数不能超过容量</span></span><br><span class="line">		&#125;</span><br><span class="line">		l.lastRefill = now <span class="comment">// 更新上次补充时间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TokenBucketLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	l.refill() <span class="comment">// 每次请求前先补充令牌</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l.tokens &gt;= <span class="number">1</span> &#123;</span><br><span class="line">		l.tokens--</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 容量 5 个令牌，每 200ms 生成 1 个令牌 (即 5 QPS 的平均速率)</span></span><br><span class="line">	limiter := NewTokenBucketLimiter(<span class="number">5</span>, <span class="number">200</span> * time.Millisecond) </span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 令牌桶限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 每 50ms 发一个请求 (即 20 QPS 突发流量)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (消耗令牌)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (无可用令牌)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒钟，桶中应补充 5 个令牌...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待令牌重新生成</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每 100ms 发一个请求 (即 10 QPS)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (消耗令牌)\n&quot;</span>, i+<span class="number">16</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (无可用令牌)\n&quot;</span>, i+<span class="number">16</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">=== 令牌桶限流器测试 ===</span><br><span class="line">请求 1 允许通过 (消耗令牌)</span><br><span class="line">请求 2 允许通过 (消耗令牌)</span><br><span class="line">请求 3 允许通过 (消耗令牌)</span><br><span class="line">请求 4 允许通过 (消耗令牌)</span><br><span class="line">请求 5 允许通过 (消耗令牌)</span><br><span class="line">请求 6 拒绝 (无可用令牌)</span><br><span class="line">请求 7 拒绝 (无可用令牌)</span><br><span class="line">请求 8 拒绝 (无可用令牌)</span><br><span class="line">请求 9 拒绝 (无可用令牌)</span><br><span class="line">请求 10 拒绝 (无可用令牌)</span><br><span class="line">请求 11 拒绝 (无可用令牌)</span><br><span class="line">请求 12 拒绝 (无可用令牌)</span><br><span class="line">请求 13 拒绝 (无可用令牌)</span><br><span class="line">请求 14 拒绝 (无可用令牌)</span><br><span class="line">请求 15 拒绝 (无可用令牌)</span><br><span class="line"></span><br><span class="line">等待 1 秒钟，桶中应补充 5 个令牌...</span><br><span class="line">请求 16 允许通过 (消耗令牌)</span><br><span class="line">请求 17 允许通过 (消耗令牌)</span><br><span class="line">请求 18 允许通过 (消耗令牌)</span><br><span class="line">请求 19 允许通过 (消耗令牌)</span><br><span class="line">请求 20 允许通过 (消耗令牌)</span><br><span class="line">请求 21 拒绝 (无可用令牌)</span><br><span class="line">请求 22 拒绝 (无可用令牌)</span><br><span class="line">请求 23 拒绝 (无可用令牌)</span><br><span class="line">请求 24 拒绝 (无可用令牌)</span><br><span class="line">请求 25 拒绝 (无可用令牌)</span><br></pre></td></tr></table></figure>
<p>可以看到，在突发流量下，令牌桶允许了前 5 个请求通过（容量为 5），超出容量的请求则被拒绝。等待一段时间后，桶中再次有了令牌，又能够处理请求。这说明它能有效缓冲突发流量。</p>
<p><strong>使用 <code>golang.org/x/time/rate</code> 标准库</strong></p>
<p>Go 语言官方提供了 <code>golang.org/x/time/rate</code> 包，它实现了令牌桶算法，并且经过了高度优化，是生产环境的首选。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/time/rate&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// r: 每秒允许生成的令牌数 (rate.Limit 类型，float64)</span></span><br><span class="line">	<span class="comment">// b: 桶的容量 (int)</span></span><br><span class="line">	<span class="comment">// limiter := rate.NewLimiter(rate.Every(time.Second/3), 3) // 每 333ms 产生一个令牌，桶容量为 3，即 3 QPS</span></span><br><span class="line">	limiter := rate.NewLimiter(rate.Limit(<span class="number">3</span>), <span class="number">5</span>) <span class="comment">// 每秒生成 3 个令牌，桶容量为 5</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 标准库 rate.Limiter 测试 ===&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow 方法是非阻塞的，只检查是否允许通过</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Allow (非阻塞) ---&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每 100ms 一个请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Allow 请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Allow 请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒，桶中应补充令牌...&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second) <span class="comment">// 等待令牌重新生成</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait 方法是阻塞的，会等待直到有令牌可用或上下文过期</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Wait (阻塞) ---&quot;</span>)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second) <span class="comment">// 最多等待 2 秒</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		<span class="comment">// WaitN(ctx, n) 等待 n 个令牌。如果桶中没有 n 个令牌，它会阻塞直到有足够的令牌。</span></span><br><span class="line">		err := limiter.WaitN(ctx, <span class="number">1</span>) <span class="comment">// 等待 1 个令牌</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Wait 请求 %d 失败: %v (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, err, time.Since(start))</span><br><span class="line">			<span class="comment">// 如果上下文超时，后续请求也会失败</span></span><br><span class="line">			<span class="comment">// 可以选择 return 或 break</span></span><br><span class="line">			<span class="keyword">break</span> </span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Wait 请求 %d 允许通过 (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, time.Since(start))</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟处理时间</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Burst (容量) 测试 ---&quot;</span>)</span><br><span class="line">	<span class="comment">// 初始桶容量为 5，平均速率 3 QPS</span></span><br><span class="line">	<span class="comment">// 预期前 5 个请求立即通过，之后以 3 QPS 通过 (或等待)</span></span><br><span class="line">	limiter2 := rate.NewLimiter(rate.Limit(<span class="number">3</span>), <span class="number">5</span>) </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		<span class="comment">// Wait() 等待一个令牌</span></span><br><span class="line">		err := limiter2.Wait(context.Background()) </span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Burst 请求 %d 失败: %v (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, err, time.Since(start))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Burst 请求 %d 允许通过 (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, time.Since(start))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">=== 标准库 rate.Limiter 测试 ===</span><br><span class="line"></span><br><span class="line">--- Allow (非阻塞) ---</span><br><span class="line">Allow 请求 1 允许通过</span><br><span class="line">Allow 请求 2 允许通过</span><br><span class="line">Allow 请求 3 允许通过</span><br><span class="line">Allow 请求 4 允许通过</span><br><span class="line">Allow 请求 5 允许通过</span><br><span class="line">Allow 请求 6 拒绝</span><br><span class="line">Allow 请求 7 拒绝</span><br><span class="line">Allow 请求 8 拒绝</span><br><span class="line">Allow 请求 9 拒绝</span><br><span class="line">Allow 请求 10 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒，桶中应补充令牌...</span><br><span class="line"></span><br><span class="line">--- Wait (阻塞) ---</span><br><span class="line">Wait 请求 1 允许通过 (耗时 53.792µs)</span><br><span class="line">Wait 请求 2 允许通过 (耗时 333.399625ms)</span><br><span class="line">Wait 请求 3 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 4 允许通过 (耗时 333.35925ms)</span><br><span class="line">Wait 请求 5 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 6 允许通过 (耗时 333.359209ms)</span><br><span class="line">Wait 请求 7 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 8 失败: context deadline exceeded (耗时 333.359167ms)</span><br><span class="line">Wait 请求 9 失败: context deadline exceeded (耗时 0s)</span><br><span class="line">Wait 请求 10 失败: context deadline exceeded (耗时 0s)</span><br><span class="line"></span><br><span class="line">--- Burst (容量) 测试 ---</span><br><span class="line">Burst 请求 1 允许通过 (耗时 12.042µs)</span><br><span class="line">Burst 请求 2 允许通过 (耗时 6.417µs)</span><br><span class="line">Burst 请求 3 允许通过 (耗时 5.75µs)</span><br><span class="line">Burst 请求 4 允许通过 (耗时 6.042µs)</span><br><span class="line">Burst 请求 5 允许通过 (耗时 6.166µs)</span><br><span class="line">Burst 请求 6 允许通过 (耗时 333.359209ms)</span><br><span class="line">Burst 请求 7 允许通过 (耗时 333.359209ms)</span><br><span class="line">Burst 请求 8 允许通过 (耗时 333.359208ms)</span><br><span class="line">Burst 请求 9 允许通过 (耗时 333.359208ms)</span><br><span class="line">Burst 请求 10 允许通过 (耗时 333.359209ms)</span><br></pre></td></tr></table></figure>
<p>通过 <code>rate.Limiter</code> 的 <code>Allow()</code> 和 <code>Wait()</code> 方法，我们可以灵活地选择非阻塞或阻塞式的限流策略。<code>Wait()</code> 尤其适用于需要平滑输出速率的场景，因为它会主动等待直到服务容量允许。</p>
<h2 id="三、限流算法的选择与实践"><a href="#三、限流算法的选择与实践" class="headerlink" title="三、限流算法的选择与实践"></a>三、限流算法的选择与实践</h2><h4 id="3-1-选择哪个算法？"><a href="#3-1-选择哪个算法？" class="headerlink" title="3.1 选择哪个算法？"></a>3.1 选择哪个算法？</h4><ul>
<li><strong>固定窗口计数器</strong>：实现最简单，但有临界点问题，不推荐用于精确限流。</li>
<li><strong>滑动窗口计数器</strong>：解决了固定窗口的临界点问题，比固定窗口更平滑，但内存开销较大。适用于对平滑度要求较高，但请求量不是特别巨大的场景。</li>
<li><strong>漏桶算法</strong>：强制平滑输出速率，适合需要严格控制下游服务压力的场景，不适合处理突发流量。</li>
<li><strong>令牌桶算法</strong>：最常用和最灵活的算法。它既能控制平均速率，又允许一定程度的突发流量，能更好地利用系统资源。Go 语言的 <code>rate.Limiter</code> 是生产环境的理想选择。</li>
</ul>
<h4 id="3-2-实践中的考虑"><a href="#3-2-实践中的考虑" class="headerlink" title="3.2 实践中的考虑"></a>3.2 实践中的考虑</h4><ol>
<li><strong>限流粒度</strong>：<ul>
<li><strong>接口级别</strong>：通常对每个 API 接口进行限流。</li>
<li><strong>用户级别</strong>：限制每个用户的请求速率，防止单个用户滥用。</li>
<li><strong>服务级别</strong>：限制整个服务对外请求的总量。</li>
<li><strong>IP 级别</strong>：根据客户端 IP 进行限流，防止特定 IP 的攻击。</li>
</ul>
</li>
<li><strong>分布式限流</strong>：<br>上述实现都是单机限流。在分布式系统中，需要借助外部存储（如 Redis）来同步多个限流器的状态。<ul>
<li><strong>基于 Redis 的计数器</strong>：利用 Redis 的 <code>INCR</code> 和 <code>EXPIRE</code> 命令实现固定&#x2F;滑动窗口计数器。</li>
<li><strong>基于 Redis Sorted Set 的滑动窗口</strong>：将请求时间戳存入 Sorted Set，通过 <code>ZREMRANGEBYSCORE</code> 移除过期时间戳，<code>ZCARD</code> 获取总数。</li>
<li><strong>基于 Redis 的令牌桶(Redisssemphore)</strong>：利用 <code>SETNX</code> 和 <code>EXPIRE</code> 实现简单的令牌桶。也有更复杂的基于 Lua 脚本的实现，保证原子性。</li>
</ul>
</li>
<li><strong>熔断 (Circuit Breaker) 与降级 (Degradation)</strong>：限流是预防手段，而熔断和降级是系统在出现问题后的恢复手段。它们通常需要配合使用，共同提高系统的韧性。</li>
<li><strong>动态配置</strong>：生产环境中的限流参数（阈值、窗口大小等）最好能够动态调整，无需重启服务。</li>
<li><strong>监控与告警</strong>：对限流器的拒绝率、通过率等指标进行监控，并设置告警，及时发现和处理问题。</li>
</ol>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>限流是构建高可用、高并发系统的基石。根据不同的业务场景和对流量平滑性、突发处理能力的要求，可以选择合适的限流算法。在 Go 语言中，对于单机限流，<code>golang.org/x/time/rate</code> 包提供的令牌桶算法是功能最强大、最推荐的解决方案。对于分布式限流，则需要结合 Redis 等外部存储来实现。理解并正确应用这些限流策略，能够有效保护系统资源，提升服务的稳定性和用户体验。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/9903be2bae23/">https://blog.tbf1211.xx.kg/9903be2bae23/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">限流算法</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-19.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7601ab41dda6/" title="Go语言并发与并行详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go语言并发与并行详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言（Golang） 被设计为一门天然支持并发的语言，其并发模型是基于 CSP (Communicating Sequential Processes) 理论的实现。Go 语言通过轻量级的 Goroutine (协程) 和原生的 Channel (管道) 机制，极大地简化了并发编程的复杂性，使得开发者能够更容易地编写出高并发、高性能的应用程序。  核心思想：不要通过共享内存来通信；相反，通过通信来共享内存。 这是 Go 并发哲学中的核心原则。   一、并发 (Concurrency) 与并行 (Parallelism)在深入 Go 语言的并发机制之前，理解并发与并行的区别至关重要。 1.1 并发 (Concurrency) 定义：并发是指系统能够同时处理多个任务的能力。这些任务不一定在同一时刻运行，它们可能在单个 CPU 核心上通过时间片轮转的方式快速切换执行，给人一种“同时进行”的错觉。 特性： 处理多个任务：关注如何设计程序来处理事件流，即使只有一个处理器。 任务切换：通过快速切换执行上下文来模拟同时执行。 目的：提高程序的吞吐量和响应速度。   类比：一个厨师可以在...</div></div></div></a><a class="pagination-related" href="/c1c3c8b5b003/" title="LangChain Model I/O 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LangChain Model I/O 详解</div></div><div class="info-2"><div class="info-item-1"> LangChain Model I&#x2F;O 是 LangChain 框架的核心组成部分之一，它提供了一套标准化的接口和工具，用于与各种大型语言模型 (LLMs) 和聊天模型 (Chat Models) 进行交互，并对其输入和输出进行有效的管理和结构化。这是构建任何基于 LLM 的应用程序的基础。  核心思想：将与 LLM 的“对话”分解为可管理、可组合的组件：输入 (Prompt Templates)、模型调用 (LLM&#x2F;Chat Models) 和输出处理 (Output Parsers)。   一、为什么 Model I&#x2F;O 至关重要？在没有 LangChain Model I&#x2F;O 的情况下，直接与 LLM 交互通常意味着：  手动拼接 Prompt: 需要手动构建复杂的字符串，其中包含指令、上下文、示例和用户输入。这既繁琐又容易出错。 硬编码模型调用: 每次更换模型或供应商时，都需要修改底层代码。 非结构化的输出: LLM 的原始输出通常是自由文本，需要编写复杂的字符串解析逻辑来提取所需信息。 缺乏可复用性: 不同应用场景下的 Prom...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cdecf00b2f41/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">GoLang Wails 框架详解：用 Web 技术构建桌面应用</div></div><div class="info-2"><div class="info-item-1"> Wails 是一个允许您使用 Go 和 Web 技术构建桌面应用程序的框架。它结合了 Go 语言的强大后端能力与现代 Web 界面的灵活性，帮助开发者快捷地创建轻量级、原生感强的跨平台桌面应用。  传统的桌面应用开发通常需要学习特定的 GUI 框架（如 Qt, Electron, WPF&#x2F;WinForms 等），这对于 Web 开发者来说学习曲线陡峭。Electron 虽然解决了 Web 技术栈的问题，但其应用体积庞大、内存占用高，且集成了 Node.js 运行时，额外增加了依赖。Wails 则提供了一种优雅的解决方案：它使用原生 WebView 渲染界面，后端逻辑全部由 Go 语言编写，实现了轻量级、高性能和原生体验的桌面应用。   一、Wails 简介与核心优势Wails 的核心理念是：用 Go 语言编写应用后端（业务逻辑），用 Web 前端技术（HTML, CSS, JavaScript）构建应用界面（UI）。它将 Go 程序和基于 Webview 的前端巧妙地结合在一起，实现两者之间的双向通信。 Wails 的核心优势：  原生 Webview 渲染：不捆绑 ...</div></div></div></a><a class="pagination-related" href="/2565d3c3db01/" title="Go语言embed包详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">Go语言embed包详解</div></div><div class="info-2"><div class="info-item-1"> Go 标准库从 Go 1.16 版本开始引入了 embed 1 包。这个包提供了一种简单、声明式的方式，允许开发者将静态文件（如 HTML 模板、CSS、JavaScript、图片、配置文件等）直接嵌入到 Go 可执行文件中。这意味着你可以通过一个独立的二进制文件分发所有应用程序所需的资源，而无需额外管理外部文件，极大地简化了部署和分发过程。  核心思想：将应用程序的外部资源（静态文件）编译进最终的二进制文件，实现“单一二进制文件”的发布和部署，消除外部文件依赖带来的复杂性。   一、为什么需要 embed 包？在 embed 包之前，Go 语言应用程序处理静态资源通常有以下几种方式：  外部文件：将静态文件与可执行文件放在一起分发。这会带来：  部署复杂性：需要确保文件结构正确，并处理文件丢失或路径错误的问题。 文件篡改风险：外部文件容易被修改，可能影响程序的行为或安全性。 分发不便：每次更新都需要同步可执行文件和所有相关资源文件。   go:embed 第三方库：许多第三方库（如 go-bindata, packr）实现了文件嵌入功能。这些库虽然有效，但通常需要一些额外的构...</div></div></div></a><a class="pagination-related" href="/98c39f8e2307/" title="Go 语言协程设计与调度原理"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-05</div><div class="info-item-2">Go 语言协程设计与调度原理</div></div><div class="info-2"><div class="info-item-1"> Goroutine 是 Go 语言并发编程的核心原语。它不是操作系统线程，而是 Go 运行时 (Runtime) 管理的轻量级协程 (coroutine)。Go 语言设计了一套独特的调度模型，能够高效地将数百万个 Goroutine 调度到有限的操作系统线程上运行，从而实现高并发和高性能。  核心思想：Go 运行时（Runtime）扮演着操作系统内核的角色，它负责 Go 应用程序内部的 Goroutine 调度，以最低的成本实现高度并发。   一、为什么 Go 要设计 Goroutine 而非直接使用线程？传统的操作系统线程，虽然也能实现并发，但在高性能和大规模并发场景下存在一些挑战：  资源开销大： 内存：操作系统线程栈空间通常较大（MB 级别），即便其中大部分未被使用，也会占用大量内存。创建数万个线程会导致巨大的内存消耗。 CPU：线程创建、销毁和上下文切换的开销相对较大，因为这涉及到内核态的参与，需要保存和恢复更多的寄存器、内存页表等信息。   调度开销大：操作系统线程的调度由内核完成，其调度算法通常是通用的，难以针对特定应用场景进行优化，且用户态程序无法感知和影响线程调...</div></div></div></a><a class="pagination-related" href="/325e0377afd7/" title="Golang 内存逃逸详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-24</div><div class="info-item-2">Golang 内存逃逸详解</div></div><div class="info-2"><div class="info-item-1"> 内存逃逸 (Memory Escape) 是 Go 语言编译器在编译时进行的一项静态分析。它的核心目的是确定程序中变量的内存分配位置：是分配在栈 (Stack) 上，还是分配在堆 (Heap) 上。通过精确地判断变量的生命周期和作用域，编译器能够做出最优化选择，从而有效降低垃圾回收 (GC) 的压力，提升程序性能。  核心思想：如果一个变量的生命周期超出了其声明函数的作用域，它就必须被分配在堆上；否则，如果其生命周期仅限于函数内部，优先分配在栈上。   一、内存分配基础：栈与堆在深入理解内存逃逸之前，我们首先需要了解程序中两种基本的内存分配区域：栈和堆。 1.1 栈 (Stack) 特性： LIFO (Last-In, First-Out) 结构。 由编译器自动管理，分配和回收速度极快。 内存是连续的。 分配与释放成本低：只需移动栈指针即可。 线程&#x2F;Goroutine 私有：每个 Goroutine 都有自己的栈。   用途： 存储局部变量。 存储函数参数。 存储函数返回值。 存储函数调用栈帧。   生命周期：与函数调用栈帧一致，函数执行完毕后，栈上的内存会被自动回收...</div></div></div></a><a class="pagination-related" href="/6b2d6f99090f/" title="Go 语言 Casbin 授权库详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-21</div><div class="info-item-2">Go 语言 Casbin 授权库详解</div></div><div class="info-2"><div class="info-item-1"> Casbin 是一个强大且高效的开源访问控制库，它支持多种访问控制模型，例如 ACL (Access Control List)、RBAC (Role-Based Access Control)、ABAC (Attribute-Based Access Control) 等。Casbin 的设计理念是“授权逻辑与业务逻辑分离”，它将授权策略存储在外部配置中，并通过统一的 API 进行管理和验证。Go 语言版本的 github.com/casbin/casbin/v2 是其最活跃和功能最完善的实现之一。  核心思想：提供一个通用的访问控制框架，通过独立的模型配置 (Model) 和策略数据 (Policy) 来定义和管理应用程序的授权规则，使授权逻辑与核心业务代码解耦，实现高度的灵活性和可维护性。   一、为什么需要 Casbin？传统授权方式的局限性在构建应用程序时，授权 (Authorization) 是一个不可或缺的安全组件，它决定了谁 (Subject) 可以对什么资源 (Object) 执行什么操作 (Action)。传统的授权方式可能面临以下挑战：  逻辑分散：授权规...</div></div></div></a><a class="pagination-related" href="/7601ab41dda6/" title="Go语言并发与并行详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">Go语言并发与并行详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言（Golang） 被设计为一门天然支持并发的语言，其并发模型是基于 CSP (Communicating Sequential Processes) 理论的实现。Go 语言通过轻量级的 Goroutine (协程) 和原生的 Channel (管道) 机制，极大地简化了并发编程的复杂性，使得开发者能够更容易地编写出高并发、高性能的应用程序。  核心思想：不要通过共享内存来通信；相反，通过通信来共享内存。 这是 Go 并发哲学中的核心原则。   一、并发 (Concurrency) 与并行 (Parallelism)在深入 Go 语言的并发机制之前，理解并发与并行的区别至关重要。 1.1 并发 (Concurrency) 定义：并发是指系统能够同时处理多个任务的能力。这些任务不一定在同一时刻运行，它们可能在单个 CPU 核心上通过时间片轮转的方式快速切换执行，给人一种“同时进行”的错觉。 特性： 处理多个任务：关注如何设计程序来处理事件流，即使只有一个处理器。 任务切换：通过快速切换执行上下文来模拟同时执行。 目的：提高程序的吞吐量和响应速度。   类比：一个厨师可以在...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">397</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">214</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-text">一、为什么需要限流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-text">二、常用限流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8-Fixed-Window-Counter"><span class="toc-text">2.1 固定窗口计数器 (Fixed Window Counter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.1.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.1.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8-Sliding-Window-Counter"><span class="toc-text">2.2 滑动窗口计数器 (Sliding Window Counter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.2.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95-Leaky-Bucket"><span class="toc-text">2.3 漏桶算法 (Leaky Bucket)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.3.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95-Token-Bucket"><span class="toc-text">2.4 令牌桶算法 (Token Bucket)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.4.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4.2 Go 语言实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-text">三、限流算法的选择与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">3.1 选择哪个算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-text">3.2 实践中的考虑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能体 (Agent) 详解：深入 LangChain 开发实践"/></a><div class="content"><a class="title" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践">智能体 (Agent) 详解：深入 LangChain 开发实践</a><time datetime="2025-12-10T22:24:00.000Z" title="发表于 2025-12-11 06:24:00">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go Jaeger 深度解析：分布式追踪实践"/></a><div class="content"><a class="title" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践">Go Jaeger 深度解析：分布式追踪实践</a><time datetime="2025-12-04T22:24:00.000Z" title="发表于 2025-12-05 06:24:00">2025-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/15920229f914/" title="Supabase 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supabase 深度解析"/></a><div class="content"><a class="title" href="/15920229f914/" title="Supabase 深度解析">Supabase 深度解析</a><time datetime="2025-12-02T22:24:00.000Z" title="发表于 2025-12-03 06:24:00">2025-12-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-19.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}&path=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews) {
            pagePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors) {
            siteUV.textContent = typeof data.visitors.value !== 'undefined' ? data.visitors.value : data.visitors
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews) {
            sitePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>