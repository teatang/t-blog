<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>常用限流算法的Go语言实现详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="限流 (Rate Limiting) 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。  核心思想：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。   一、为什么">
<meta property="og:type" content="article">
<meta property="og:title" content="常用限流算法的Go语言实现详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/9903be2bae23/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="限流 (Rate Limiting) 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。  核心思想：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。   一、为什么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg">
<meta property="article:published_time" content="2025-10-15T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-17T08:09:09.120Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="限流算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "常用限流算法的Go语言实现详解",
  "url": "https://blog.tbf1211.xx.kg/9903be2bae23/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg",
  "datePublished": "2025-10-15T22:24:00.000Z",
  "dateModified": "2026-01-17T08:09:09.120Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/9903be2bae23/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常用限流算法的Go语言实现详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-26.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">常用限流算法的Go语言实现详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">常用限流算法的Go语言实现详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>限流 (Rate Limiting)</strong> 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。</p>
</div>
<hr>
<h2 id="一、为什么需要限流？"><a href="#一、为什么需要限流？" class="headerlink" title="一、为什么需要限流？"></a>一、为什么需要限流？</h2><ol>
<li><strong>防止系统过载</strong>：当请求量超出系统处理能力时，限流可以拒绝一部分请求，保证剩余请求能够正常响应，而不是所有请求都失败。</li>
<li><strong>避免雪崩效应</strong>：在微服务架构中，一个服务过载可能导致其依赖的服务也跟着过载，最终演变成整个系统的瘫痪。限流可以切断这种连锁反应。</li>
<li><strong>保护下游资源</strong>：数据库、缓存、第三方 API 等资源通常更加脆弱，限流可以保护它们免受过高压力的冲击。</li>
<li><strong>资源公平分配</strong>：对于多租户或多用户系统，限流可以确保每个用户或租户都能获得公平的资源配额。</li>
<li><strong>防止恶意攻击</strong>：例如 DoS&#x2F;DDoS 攻击，通过限制请求速率可以有效缓解攻击对系统的影响。</li>
<li><strong>费用控制</strong>：对于按请求量付费的第三方服务，限流可以有效控制成本。</li>
</ol>
<h2 id="二、常用限流算法"><a href="#二、常用限流算法" class="headerlink" title="二、常用限流算法"></a>二、常用限流算法</h2><p>本节将详细介绍三种最常用的限流算法：<strong>固定窗口计数器</strong>、<strong>滑动窗口计数器</strong>、<strong>漏桶算法</strong> 和 <strong>令牌桶算法</strong>，并提供它们的 Go 语言实现。</p>
<h3 id="2-1-固定窗口计数器-Fixed-Window-Counter"><a href="#2-1-固定窗口计数器-Fixed-Window-Counter" class="headerlink" title="2.1 固定窗口计数器 (Fixed Window Counter)"></a>2.1 固定窗口计数器 (Fixed Window Counter)</h3><h4 id="2-1-1-算法原理"><a href="#2-1-1-算法原理" class="headerlink" title="2.1.1 算法原理"></a>2.1.1 算法原理</h4><p>固定窗口计数器算法是最简单、最容易理解的限流算法。它在一个固定的时间窗口（例如 1 分钟）内统计请求数量。当请求到来时，计数器加一。如果计数器值超过预设的阈值，则拒绝该请求。当时间窗口结束时，计数器清零，开始下一个窗口的计数。</p>
<p><strong>优点</strong>：实现简单，易于理解。<br><strong>缺点</strong>：存在“临界点问题”。在窗口的开始和结束交界处，可能会在短时间内涌入双倍于阈值的请求，导致瞬时流量超过系统承载能力。例如，限流 100 QPS，窗口是 1 秒。在第 0.9 秒时来了 100 个请求，在第 1.1 秒时又来了 100 个请求，那么在 0.9 到 1.1 秒这 0.2 秒内，系统处理了 200 个请求，是阈值的两倍。</p>
<h4 id="2-1-2-Go-语言实现"><a href="#2-1-2-Go-语言实现" class="headerlink" title="2.1.2 Go 语言实现"></a>2.1.2 Go 语言实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FixedWindowLimiter 固定窗口限流器</span></span><br><span class="line"><span class="keyword">type</span> FixedWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	windowSize time.Duration <span class="comment">// 窗口大小</span></span><br><span class="line">	threshold  <span class="type">int</span>           <span class="comment">// 阈值 (窗口内最大请求数)</span></span><br><span class="line">	counter    <span class="type">int</span>           <span class="comment">// 当前窗口内的请求计数</span></span><br><span class="line">	lastReset  time.Time     <span class="comment">// 上次窗口重置时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFixedWindowLimiter 创建一个新的固定窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFixedWindowLimiter</span><span class="params">(windowSize time.Duration, threshold <span class="type">int</span>)</span></span> *FixedWindowLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;FixedWindowLimiter&#123;</span><br><span class="line">		windowSize: windowSize,</span><br><span class="line">		threshold:  threshold,</span><br><span class="line">		counter:    <span class="number">0</span>,</span><br><span class="line">		lastReset:  time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *FixedWindowLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	now := time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前时间超过了上一个窗口的结束，则重置窗口</span></span><br><span class="line">	<span class="keyword">if</span> now.Sub(l.lastReset) &gt;= l.windowSize &#123;</span><br><span class="line">		l.counter = <span class="number">0</span></span><br><span class="line">		l.lastReset = now <span class="comment">// 重置 lastReset 为当前时间，开始新窗口</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前窗口内的请求数是否超过阈值</span></span><br><span class="line">	<span class="keyword">if</span> l.counter &lt; l.threshold &#123;</span><br><span class="line">		l.counter++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	limiter := NewFixedWindowLimiter(time.Second, <span class="number">3</span>) <span class="comment">// 每秒允许 3 个请求</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 固定窗口限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每隔 100 毫秒发出请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒后...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待窗口重置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== 固定窗口限流器测试 ===</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br><span class="line">请求 6 拒绝</span><br><span class="line">请求 7 拒绝</span><br><span class="line">请求 8 拒绝</span><br><span class="line">请求 9 拒绝</span><br><span class="line">请求 10 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒后...</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br></pre></td></tr></table></figure>

<h3 id="2-2-滑动窗口计数器-Sliding-Window-Counter"><a href="#2-2-滑动窗口计数器-Sliding-Window-Counter" class="headerlink" title="2.2 滑动窗口计数器 (Sliding Window Counter)"></a>2.2 滑动窗口计数器 (Sliding Window Counter)</h3><h4 id="2-2-1-算法原理"><a href="#2-2-1-算法原理" class="headerlink" title="2.2.1 算法原理"></a>2.2.1 算法原理</h4><p>滑动窗口计数器算法是固定窗口计数器的改进版，旨在解决临界点问题。它将一个大的时间窗口（如 1 分钟）划分为更多小的时间片（如 10 个 6 秒的窗口）。每个小时间片都有独立的计数器。</p>
<p>当请求到来时，它会落入当前的小时间片。我们计算当前大窗口内的请求总数，这个总数是当前小时间片的计数，加上前面若干个完整小时间片的计数，再加上前一个小时间片中未满部分的请求计数。</p>
<p><strong>更经典的实现方式</strong>：<br>存储每个请求的时间戳在一个队列 (或切片) 中。当新请求到来时，删除所有超过当前时间窗口的旧请求。然后判断剩余请求的数量是否小于阈值。</p>
<p><strong>优点</strong>：解决了固定窗口的临界点问题，平滑了流量。<br><strong>缺点</strong>：实现相对复杂，需要存储请求的时间戳，占用内存。如果请求量非常大，存储和清理时间戳的开销会比较高。</p>
<h4 id="2-2-2-Go-语言实现"><a href="#2-2-2-Go-语言实现" class="headerlink" title="2.2.2 Go 语言实现"></a>2.2.2 Go 语言实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SlidingWindowLimiter 滑动窗口限流器 (基于时间戳队列)</span></span><br><span class="line"><span class="keyword">type</span> SlidingWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	windowSize time.Duration     <span class="comment">// 窗口大小</span></span><br><span class="line">	threshold  <span class="type">int</span>               <span class="comment">// 阈值 (窗口内最大请求数)</span></span><br><span class="line">	timestamps []time.Time       <span class="comment">// 存储请求到达的时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSlidingWindowLimiter 创建一个新的滑动窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlidingWindowLimiter</span><span class="params">(windowSize time.Duration, threshold <span class="type">int</span>)</span></span> *SlidingWindowLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;SlidingWindowLimiter&#123;</span><br><span class="line">		windowSize: windowSize,</span><br><span class="line">		threshold:  threshold,</span><br><span class="line">		timestamps: <span class="built_in">make</span>([]time.Time, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SlidingWindowLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	now := time.Now()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 清理过期的时间戳</span></span><br><span class="line">	<span class="comment">// 遍历并删除所有超出当前时间窗口的旧请求时间戳</span></span><br><span class="line">	<span class="comment">// 因为切片的删除操作效率较低，更高效的方式是使用双向链表或环形队列</span></span><br><span class="line">	<span class="comment">// 这里为简化演示，使用切片</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Two-pointer approach for efficient deletion</span></span><br><span class="line">	idx := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(l.timestamps); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> now.Sub(l.timestamps[i]) &lt; l.windowSize &#123;</span><br><span class="line">			l.timestamps[idx] = l.timestamps[i]</span><br><span class="line">			idx++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	l.timestamps = l.timestamps[:idx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前窗口内的请求数是否超过阈值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l.timestamps) &lt; l.threshold &#123;</span><br><span class="line">		l.timestamps = <span class="built_in">append</span>(l.timestamps, now)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	limiter := NewSlidingWindowLimiter(time.Second, <span class="number">3</span>) <span class="comment">// 每秒允许 3 个请求</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 滑动窗口限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="comment">// 测试临界点效应</span></span><br><span class="line">	<span class="comment">// 在 0.9s 时发满 3 个请求</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在 0.9s 到 1.0s 之间，等待 0.4s (到 0.9s + 0.4s = 1.3s 时)</span></span><br><span class="line">	<span class="comment">// 期望在 1.0s 后，前面 0.1s 的请求才开始过期</span></span><br><span class="line">	time.Sleep(<span class="number">400</span> * time.Millisecond) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时当前窗口的有效请求是 第 1.3s - 1s = 0.3s 之前的所有请求</span></span><br><span class="line">	<span class="comment">// 直到第 0.1s 的请求在 1.1s 时才过期</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 以 100ms 的频率再发 5 个请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">4</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">4</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n等待 1 秒后 (大部分请求已从窗口中移除)...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待窗口中的大部分请求过期</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=== 滑动窗口限流器测试 ===</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br><span class="line">请求 6 拒绝</span><br><span class="line">请求 7 拒绝</span><br><span class="line">请求 8 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒后 (大部分请求已从窗口中移除)...</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br></pre></td></tr></table></figure>
<p>可以看到，在高频请求下，滑动窗口能更平滑地拒绝请求，避免固定窗口的瞬时流量峰值问题。</p>
<h3 id="2-3-漏桶算法-Leaky-Bucket"><a href="#2-3-漏桶算法-Leaky-Bucket" class="headerlink" title="2.3 漏桶算法 (Leaky Bucket)"></a>2.3 漏桶算法 (Leaky Bucket)</h3><h4 id="2-3-1-算法原理"><a href="#2-3-1-算法原理" class="headerlink" title="2.3.1 算法原理"></a>2.3.1 算法原理</h4><p>漏桶算法的核心思想是：所有的请求都会先进入一个“桶”中，桶的容量有限。请求以恒定的速率从桶中流出（被处理）。<br>如果请求到达时桶是满的，那么该请求会被丢弃（拒绝）。</p>
<p><strong>优点</strong>：能够平滑突发流量，使输出速率保持恒定。<br><strong>缺点</strong>：无法有效地处理突发流量。即使系统具备处理短时突发的能力，漏桶算法也会将请求均匀化处理，可能导致资源利用率不足。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[请求流入] --&gt; B[漏桶]
    B -- 容量满 --&gt; C{丢弃请求}
    B -- 固定速率流出 --&gt; D[请求处理]
  </pre></div>

<h4 id="2-3-2-Go-语言实现"><a href="#2-3-2-Go-语言实现" class="headerlink" title="2.3.2 Go 语言实现"></a>2.3.2 Go 语言实现</h4><p>漏桶算法通常使用一个固定大小的缓冲队列和 Goroutine 来模拟漏出过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeakyBucketLimiter 漏桶限流器</span></span><br><span class="line"><span class="keyword">type</span> LeakyBucketLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity      <span class="type">int</span>           <span class="comment">// 桶的容量</span></span><br><span class="line">	rate          time.Duration <span class="comment">// 请求流出速率 (每 rate 时间单位流出一个请求)</span></span><br><span class="line">	bucket        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 模拟桶的通道</span></span><br><span class="line">	closeChan     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 用于关闭漏桶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLeakyBucketLimiter 创建一个新的漏桶限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeakyBucketLimiter</span><span class="params">(capacity <span class="type">int</span>, rate time.Duration)</span></span> *LeakyBucketLimiter &#123;</span><br><span class="line">	limiter := &amp;LeakyBucketLimiter&#123;</span><br><span class="line">		capacity:  capacity,</span><br><span class="line">		rate:      rate,</span><br><span class="line">		bucket:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity), <span class="comment">// 缓冲通道模拟桶</span></span><br><span class="line">		closeChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> limiter.leak() <span class="comment">// 启动漏出 Goroutine</span></span><br><span class="line">	<span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak 模拟请求从桶中漏出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> leak() &#123;</span><br><span class="line">	ticker := time.NewTicker(l.rate) <span class="comment">// 设置漏出速率</span></span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C: <span class="comment">// 定时从桶中取出一个请求</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-l.bucket: <span class="comment">// 尝试从桶中“漏出”一个请求</span></span><br><span class="line">				<span class="comment">// 请求被成功漏出，可以进行处理</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 桶为空，没有请求可漏出</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-l.closeChan:</span><br><span class="line">			fmt.Println(<span class="string">&quot;漏桶已关闭.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 尝试将请求放入桶中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> l.bucket &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// 尝试将请求放入桶中</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 成功放入，允许通过</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// 桶已满，无法放入</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 拒绝请求</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭漏桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> Close() &#123;</span><br><span class="line">	<span class="built_in">close</span>(l.closeChan)</span><br><span class="line">	<span class="built_in">close</span>(l.bucket)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 容量 3，每 200 毫秒处理一个请求 (即 5 QPS)</span></span><br><span class="line">	limiter := NewLeakyBucketLimiter(<span class="number">3</span>, <span class="number">200</span> * time.Millisecond) </span><br><span class="line">	<span class="keyword">defer</span> limiter.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 漏桶限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 每 50ms 发一个请求 (即 20 QPS 突发流量)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (进入桶)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (桶已满)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待一段时间，看桶中请求是否漏出...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) </span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n再次测试漏桶...&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 以 100ms 频率发请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (进入桶)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (桶已满)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=== 漏桶限流器测试 ===</span><br><span class="line">请求 1 允许通过 (进入桶)</span><br><span class="line">请求 2 允许通过 (进入桶)</span><br><span class="line">请求 3 允许通过 (进入桶)</span><br><span class="line">请求 4 拒绝 (桶已满)</span><br><span class="line">请求 5 拒绝 (桶已满)</span><br><span class="line">请求 6 拒绝 (桶已满)</span><br><span class="line">... (直到请求 15 都是拒绝)</span><br><span class="line"></span><br><span class="line">等待一段时间，看桶中请求是否漏出... (此处 Goroutine 在后台持续漏出请求)</span><br><span class="line"></span><br><span class="line">再次测试漏桶...</span><br><span class="line">请求 1 允许通过 (进入桶)</span><br><span class="line">请求 2 允许通过 (进入桶)</span><br><span class="line">请求 3 允许通过 (进入桶)</span><br><span class="line">请求 4 拒绝 (桶已满)</span><br><span class="line">请求 5 拒绝 (桶已满)</span><br></pre></td></tr></table></figure>
<p>可以看到，在突发流量下，漏桶很快就满了，后续请求都被拒绝。但桶内的请求仍然以恒定速率处理。</p>
<h3 id="2-4-令牌桶算法-Token-Bucket"><a href="#2-4-令牌桶算法-Token-Bucket" class="headerlink" title="2.4 令牌桶算法 (Token Bucket)"></a>2.4 令牌桶算法 (Token Bucket)</h3><h4 id="2-4-1-算法原理"><a href="#2-4-1-算法原理" class="headerlink" title="2.4.1 算法原理"></a>2.4.1 算法原理</h4><p>令牌桶算法是目前最常用且最灵活的限流算法之一。它的工作原理是：</p>
<ol>
<li>一个固定容量的“令牌桶”会以恒定的速率往里添加令牌。</li>
<li>每个请求到来时，需要从桶中获取一个令牌。</li>
<li>如果桶中有足够的令牌，请求就可以通过，并消耗一个令牌。</li>
<li>如果桶中没有令牌，请求可以选择等待令牌的生成，或者直接被拒绝。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>允许一定程度的突发流量</strong>：桶的容量决定了可以累积的最大令牌数，也就是允许通过的最大突发请求数。</li>
<li><strong>输出速率可控</strong>：令牌生成速率控制了长期来看的平均处理速率。</li>
<li><strong>实现灵活</strong>：可以很容易地调整桶容量和生成速率。</li>
</ul>
<p><strong>缺点</strong>：实现比计数器复杂，但比漏桶更灵活。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;令牌生成器 (固定速率)&quot;] --&gt; B[令牌桶]
    B -- 含有令牌 --&gt; C[请求通过]
    D[请求到达] --&gt; B
    B -- 无令牌 --&gt; E{请求等待&#x2F;拒绝}
  </pre></div>

<h4 id="2-4-2-Go-语言实现"><a href="#2-4-2-Go-语言实现" class="headerlink" title="2.4.2 Go 语言实现"></a>2.4.2 Go 语言实现</h4><p>Go 语言标准库 <code>golang.org/x/time/rate</code> 包提供了高度优化和生产可用的令牌桶限流器。这里我们先实现一个简化版的，再介绍标准库的使用。</p>
<p><strong>简化版实现</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TokenBucketLimiter 令牌桶限流器</span></span><br><span class="line"><span class="keyword">type</span> TokenBucketLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	capacity    <span class="type">int</span>           <span class="comment">// 桶的容量 (最多能存多少令牌)</span></span><br><span class="line">	tokens      <span class="type">int</span>           <span class="comment">// 当前桶中令牌数量</span></span><br><span class="line">	rate        time.Duration <span class="comment">// 令牌生成速率 (每 rate 时间单位生成一个令牌)</span></span><br><span class="line">	lastRefill  time.Time     <span class="comment">// 上次补充令牌的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTokenBucketLimiter 创建一个新的令牌桶限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTokenBucketLimiter</span><span class="params">(capacity <span class="type">int</span>, rate time.Duration)</span></span> *TokenBucketLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TokenBucketLimiter&#123;</span><br><span class="line">		capacity:    capacity,</span><br><span class="line">		tokens:      capacity, <span class="comment">// 初始时桶是满的</span></span><br><span class="line">		rate:        rate,</span><br><span class="line">		lastRefill:  time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// refill 补充令牌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TokenBucketLimiter)</span></span> refill() &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 计算距离上次补充令牌过去了多少个“rate”时间单位</span></span><br><span class="line">	duration := now.Sub(l.lastRefill)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// numberOfTokensToAdd = 过去的时间 / 每生成一个令牌的时间</span></span><br><span class="line">	tokensToAdd := <span class="type">int</span>(duration / l.rate) </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> tokensToAdd &gt; <span class="number">0</span> &#123;</span><br><span class="line">		l.tokens += tokensToAdd</span><br><span class="line">		<span class="keyword">if</span> l.tokens &gt; l.capacity &#123;</span><br><span class="line">			l.tokens = l.capacity <span class="comment">// 令牌数不能超过容量</span></span><br><span class="line">		&#125;</span><br><span class="line">		l.lastRefill = now <span class="comment">// 更新上次补充时间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TokenBucketLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	l.refill() <span class="comment">// 每次请求前先补充令牌</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l.tokens &gt;= <span class="number">1</span> &#123;</span><br><span class="line">		l.tokens--</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 容量 5 个令牌，每 200ms 生成 1 个令牌 (即 5 QPS 的平均速率)</span></span><br><span class="line">	limiter := NewTokenBucketLimiter(<span class="number">5</span>, <span class="number">200</span> * time.Millisecond) </span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 令牌桶限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 每 50ms 发一个请求 (即 20 QPS 突发流量)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (消耗令牌)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (无可用令牌)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒钟，桶中应补充 5 个令牌...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待令牌重新生成</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每 100ms 发一个请求 (即 10 QPS)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (消耗令牌)\n&quot;</span>, i+<span class="number">16</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (无可用令牌)\n&quot;</span>, i+<span class="number">16</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">=== 令牌桶限流器测试 ===</span><br><span class="line">请求 1 允许通过 (消耗令牌)</span><br><span class="line">请求 2 允许通过 (消耗令牌)</span><br><span class="line">请求 3 允许通过 (消耗令牌)</span><br><span class="line">请求 4 允许通过 (消耗令牌)</span><br><span class="line">请求 5 允许通过 (消耗令牌)</span><br><span class="line">请求 6 拒绝 (无可用令牌)</span><br><span class="line">请求 7 拒绝 (无可用令牌)</span><br><span class="line">请求 8 拒绝 (无可用令牌)</span><br><span class="line">请求 9 拒绝 (无可用令牌)</span><br><span class="line">请求 10 拒绝 (无可用令牌)</span><br><span class="line">请求 11 拒绝 (无可用令牌)</span><br><span class="line">请求 12 拒绝 (无可用令牌)</span><br><span class="line">请求 13 拒绝 (无可用令牌)</span><br><span class="line">请求 14 拒绝 (无可用令牌)</span><br><span class="line">请求 15 拒绝 (无可用令牌)</span><br><span class="line"></span><br><span class="line">等待 1 秒钟，桶中应补充 5 个令牌...</span><br><span class="line">请求 16 允许通过 (消耗令牌)</span><br><span class="line">请求 17 允许通过 (消耗令牌)</span><br><span class="line">请求 18 允许通过 (消耗令牌)</span><br><span class="line">请求 19 允许通过 (消耗令牌)</span><br><span class="line">请求 20 允许通过 (消耗令牌)</span><br><span class="line">请求 21 拒绝 (无可用令牌)</span><br><span class="line">请求 22 拒绝 (无可用令牌)</span><br><span class="line">请求 23 拒绝 (无可用令牌)</span><br><span class="line">请求 24 拒绝 (无可用令牌)</span><br><span class="line">请求 25 拒绝 (无可用令牌)</span><br></pre></td></tr></table></figure>
<p>可以看到，在突发流量下，令牌桶允许了前 5 个请求通过（容量为 5），超出容量的请求则被拒绝。等待一段时间后，桶中再次有了令牌，又能够处理请求。这说明它能有效缓冲突发流量。</p>
<p><strong>使用 <code>golang.org/x/time/rate</code> 标准库</strong></p>
<p>Go 语言官方提供了 <code>golang.org/x/time/rate</code> 包，它实现了令牌桶算法，并且经过了高度优化，是生产环境的首选。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/time/rate&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// r: 每秒允许生成的令牌数 (rate.Limit 类型，float64)</span></span><br><span class="line">	<span class="comment">// b: 桶的容量 (int)</span></span><br><span class="line">	<span class="comment">// limiter := rate.NewLimiter(rate.Every(time.Second/3), 3) // 每 333ms 产生一个令牌，桶容量为 3，即 3 QPS</span></span><br><span class="line">	limiter := rate.NewLimiter(rate.Limit(<span class="number">3</span>), <span class="number">5</span>) <span class="comment">// 每秒生成 3 个令牌，桶容量为 5</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 标准库 rate.Limiter 测试 ===&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow 方法是非阻塞的，只检查是否允许通过</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Allow (非阻塞) ---&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每 100ms 一个请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Allow 请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Allow 请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒，桶中应补充令牌...&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second) <span class="comment">// 等待令牌重新生成</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait 方法是阻塞的，会等待直到有令牌可用或上下文过期</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Wait (阻塞) ---&quot;</span>)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second) <span class="comment">// 最多等待 2 秒</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		<span class="comment">// WaitN(ctx, n) 等待 n 个令牌。如果桶中没有 n 个令牌，它会阻塞直到有足够的令牌。</span></span><br><span class="line">		err := limiter.WaitN(ctx, <span class="number">1</span>) <span class="comment">// 等待 1 个令牌</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Wait 请求 %d 失败: %v (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, err, time.Since(start))</span><br><span class="line">			<span class="comment">// 如果上下文超时，后续请求也会失败</span></span><br><span class="line">			<span class="comment">// 可以选择 return 或 break</span></span><br><span class="line">			<span class="keyword">break</span> </span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Wait 请求 %d 允许通过 (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, time.Since(start))</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟处理时间</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Burst (容量) 测试 ---&quot;</span>)</span><br><span class="line">	<span class="comment">// 初始桶容量为 5，平均速率 3 QPS</span></span><br><span class="line">	<span class="comment">// 预期前 5 个请求立即通过，之后以 3 QPS 通过 (或等待)</span></span><br><span class="line">	limiter2 := rate.NewLimiter(rate.Limit(<span class="number">3</span>), <span class="number">5</span>) </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		<span class="comment">// Wait() 等待一个令牌</span></span><br><span class="line">		err := limiter2.Wait(context.Background()) </span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Burst 请求 %d 失败: %v (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, err, time.Since(start))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Burst 请求 %d 允许通过 (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, time.Since(start))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">=== 标准库 rate.Limiter 测试 ===</span><br><span class="line"></span><br><span class="line">--- Allow (非阻塞) ---</span><br><span class="line">Allow 请求 1 允许通过</span><br><span class="line">Allow 请求 2 允许通过</span><br><span class="line">Allow 请求 3 允许通过</span><br><span class="line">Allow 请求 4 允许通过</span><br><span class="line">Allow 请求 5 允许通过</span><br><span class="line">Allow 请求 6 拒绝</span><br><span class="line">Allow 请求 7 拒绝</span><br><span class="line">Allow 请求 8 拒绝</span><br><span class="line">Allow 请求 9 拒绝</span><br><span class="line">Allow 请求 10 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒，桶中应补充令牌...</span><br><span class="line"></span><br><span class="line">--- Wait (阻塞) ---</span><br><span class="line">Wait 请求 1 允许通过 (耗时 53.792µs)</span><br><span class="line">Wait 请求 2 允许通过 (耗时 333.399625ms)</span><br><span class="line">Wait 请求 3 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 4 允许通过 (耗时 333.35925ms)</span><br><span class="line">Wait 请求 5 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 6 允许通过 (耗时 333.359209ms)</span><br><span class="line">Wait 请求 7 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 8 失败: context deadline exceeded (耗时 333.359167ms)</span><br><span class="line">Wait 请求 9 失败: context deadline exceeded (耗时 0s)</span><br><span class="line">Wait 请求 10 失败: context deadline exceeded (耗时 0s)</span><br><span class="line"></span><br><span class="line">--- Burst (容量) 测试 ---</span><br><span class="line">Burst 请求 1 允许通过 (耗时 12.042µs)</span><br><span class="line">Burst 请求 2 允许通过 (耗时 6.417µs)</span><br><span class="line">Burst 请求 3 允许通过 (耗时 5.75µs)</span><br><span class="line">Burst 请求 4 允许通过 (耗时 6.042µs)</span><br><span class="line">Burst 请求 5 允许通过 (耗时 6.166µs)</span><br><span class="line">Burst 请求 6 允许通过 (耗时 333.359209ms)</span><br><span class="line">Burst 请求 7 允许通过 (耗时 333.359209ms)</span><br><span class="line">Burst 请求 8 允许通过 (耗时 333.359208ms)</span><br><span class="line">Burst 请求 9 允许通过 (耗时 333.359208ms)</span><br><span class="line">Burst 请求 10 允许通过 (耗时 333.359209ms)</span><br></pre></td></tr></table></figure>
<p>通过 <code>rate.Limiter</code> 的 <code>Allow()</code> 和 <code>Wait()</code> 方法，我们可以灵活地选择非阻塞或阻塞式的限流策略。<code>Wait()</code> 尤其适用于需要平滑输出速率的场景，因为它会主动等待直到服务容量允许。</p>
<h2 id="三、限流算法的选择与实践"><a href="#三、限流算法的选择与实践" class="headerlink" title="三、限流算法的选择与实践"></a>三、限流算法的选择与实践</h2><h4 id="3-1-选择哪个算法？"><a href="#3-1-选择哪个算法？" class="headerlink" title="3.1 选择哪个算法？"></a>3.1 选择哪个算法？</h4><ul>
<li><strong>固定窗口计数器</strong>：实现最简单，但有临界点问题，不推荐用于精确限流。</li>
<li><strong>滑动窗口计数器</strong>：解决了固定窗口的临界点问题，比固定窗口更平滑，但内存开销较大。适用于对平滑度要求较高，但请求量不是特别巨大的场景。</li>
<li><strong>漏桶算法</strong>：强制平滑输出速率，适合需要严格控制下游服务压力的场景，不适合处理突发流量。</li>
<li><strong>令牌桶算法</strong>：最常用和最灵活的算法。它既能控制平均速率，又允许一定程度的突发流量，能更好地利用系统资源。Go 语言的 <code>rate.Limiter</code> 是生产环境的理想选择。</li>
</ul>
<h4 id="3-2-实践中的考虑"><a href="#3-2-实践中的考虑" class="headerlink" title="3.2 实践中的考虑"></a>3.2 实践中的考虑</h4><ol>
<li><strong>限流粒度</strong>：<ul>
<li><strong>接口级别</strong>：通常对每个 API 接口进行限流。</li>
<li><strong>用户级别</strong>：限制每个用户的请求速率，防止单个用户滥用。</li>
<li><strong>服务级别</strong>：限制整个服务对外请求的总量。</li>
<li><strong>IP 级别</strong>：根据客户端 IP 进行限流，防止特定 IP 的攻击。</li>
</ul>
</li>
<li><strong>分布式限流</strong>：<br>上述实现都是单机限流。在分布式系统中，需要借助外部存储（如 Redis）来同步多个限流器的状态。<ul>
<li><strong>基于 Redis 的计数器</strong>：利用 Redis 的 <code>INCR</code> 和 <code>EXPIRE</code> 命令实现固定&#x2F;滑动窗口计数器。</li>
<li><strong>基于 Redis Sorted Set 的滑动窗口</strong>：将请求时间戳存入 Sorted Set，通过 <code>ZREMRANGEBYSCORE</code> 移除过期时间戳，<code>ZCARD</code> 获取总数。</li>
<li><strong>基于 Redis 的令牌桶(Redisssemphore)</strong>：利用 <code>SETNX</code> 和 <code>EXPIRE</code> 实现简单的令牌桶。也有更复杂的基于 Lua 脚本的实现，保证原子性。</li>
</ul>
</li>
<li><strong>熔断 (Circuit Breaker) 与降级 (Degradation)</strong>：限流是预防手段，而熔断和降级是系统在出现问题后的恢复手段。它们通常需要配合使用，共同提高系统的韧性。</li>
<li><strong>动态配置</strong>：生产环境中的限流参数（阈值、窗口大小等）最好能够动态调整，无需重启服务。</li>
<li><strong>监控与告警</strong>：对限流器的拒绝率、通过率等指标进行监控，并设置告警，及时发现和处理问题。</li>
</ol>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>限流是构建高可用、高并发系统的基石。根据不同的业务场景和对流量平滑性、突发处理能力的要求，可以选择合适的限流算法。在 Go 语言中，对于单机限流，<code>golang.org/x/time/rate</code> 包提供的令牌桶算法是功能最强大、最推荐的解决方案。对于分布式限流，则需要结合 Redis 等外部存储来实现。理解并正确应用这些限流策略，能够有效保护系统资源，提升服务的稳定性和用户体验。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/9903be2bae23/">https://blog.tbf1211.xx.kg/9903be2bae23/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">限流算法</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-26.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7601ab41dda6/" title="Go语言并发与并行详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go语言并发与并行详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言（Golang） 被设计为一门天然支持并发的语言，其并发模型是基于 CSP (Communicating Sequential Processes) 理论的实现。Go 语言通过轻量级的 Goroutine (协程) 和原生的 Channel (管道) 机制，极大地简化了并发编程的复杂性，使得开发者能够更容易地编写出高并发、高性能的应用程序。  核心思想：不要通过共享内存来通信；相反，通过通信来共享内存。 这是 Go 并发哲学中的核心原则。   一、并发 (Concurrency) 与并行 (Parallelism)在深入 Go 语言的并发机制之前，理解并发与并行的区别至关重要。 1.1 并发 (Concurrency) 定义：并发是指系统能够同时处理多个任务的能力。这些任务不一定在同一时刻运行，它们可能在单个 CPU 核心上通过时间片轮转的方式快速切换执行，给人一种“同时进行”的错觉。 特性： 处理多个任务：关注如何设计程序来处理事件流，即使只有一个处理器。 任务切换：通过快速切换执行上下文来模拟同时执行。 目的：提高程序的吞吐量和响应速度。   类比：一个厨师可以在...</div></div></div></a><a class="pagination-related" href="/c1c3c8b5b003/" title="LangChain Model I/O 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LangChain Model I/O 详解</div></div><div class="info-2"><div class="info-item-1"> LangChain Model I&#x2F;O 是 LangChain 框架的核心组成部分之一，它提供了一套标准化的接口和工具，用于与各种大型语言模型 (LLMs) 和聊天模型 (Chat Models) 进行交互，并对其输入和输出进行有效的管理和结构化。这是构建任何基于 LLM 的应用程序的基础。  核心思想：将与 LLM 的“对话”分解为可管理、可组合的组件：输入 (Prompt Templates)、模型调用 (LLM&#x2F;Chat Models) 和输出处理 (Output Parsers)。   一、为什么 Model I&#x2F;O 至关重要？在没有 LangChain Model I&#x2F;O 的情况下，直接与 LLM 交互通常意味着：  手动拼接 Prompt: 需要手动构建复杂的字符串，其中包含指令、上下文、示例和用户输入。这既繁琐又容易出错。 硬编码模型调用: 每次更换模型或供应商时，都需要修改底层代码。 非结构化的输出: LLM 的原始输出通常是自由文本，需要编写复杂的字符串解析逻辑来提取所需信息。 缺乏可复用性: 不同应用场景下的 Prom...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/8f9f1342d7a2/" title="Golang 如何等待多个 Goroutine"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">Golang 如何等待多个 Goroutine</div></div><div class="info-2"><div class="info-item-1"> Goroutine 是 Go 语言轻量级并发的核心，它使得在程序中同时运行多个任务变得简单高效。然而，当启动多个 Goroutine 后，主程序或管理 Goroutine 常常需要知道这些并发任务何时完成，或者需要等待它们全部完成后再继续执行。这种“等待 Goroutine 完成”的机制是并发编程中至关重要的一环，确保了程序的正确性、资源的有序释放以及结果的汇总。  核心思想：管理 Goroutine 的生命周期是并发编程的关键。Go 提供了 sync.WaitGroup、Channels 以及 context.Context 结合 errgroup.Group 等多种机制，以适应不同复杂度和需求的 Goroutine 等待场景。   一、为什么需要等待 Goroutine？在 Go 语言中，main 函数的 Goroutine 启动后，即使它退出了，其他未完成的 Goroutine 也会继续运行。但通常情况下，我们希望：  确保任务完成：等待所有子 Goroutine 完成计算、I&#x2F;O 操作或数据处理，以避免数据丢失或不完整。 结果汇总：在所有 Goroutine ...</div></div></div></a><a class="pagination-related" href="/f200f6bfe5fa/" title="Golang 特殊注释 (Special Comments) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">Golang 特殊注释 (Special Comments) 详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，除了我们日常用于解释代码逻辑的普通注释 // 和 /* */ 之外，还存在一些具有特殊含义的注释。这些特殊注释通常以 //go: 或 // + 开头，它们并不是为程序员阅读而生，而是作为指令直接与 Go 工具链（编译器、链接器、go generate 等）交互，用于控制编译行为、生成代码、导入 C 代码，或者提供额外的信息。  核心思想：特殊注释是 Go 工具链的“命令”，用于扩展 Go 语言的能力，例如嵌入文件、生成代码、与 C 语言交互或进行性能优化。   一、Go 特殊注释的分类与作用Go 的特殊注释大致可以分为几类：  编译器指令 (Build Constraints)：控制哪些文件或代码块在特定条件下编译。 代码生成指令 (go generate)：标记需要执行特定外部工具来生成代码的位置。 cgo 指令：用于 Go 和 C&#x2F;C++ 代码之间的互操作。 embed 指令：将静态文件嵌入到 Go 二进制文件中 (Go 1.16+)。 运行时或工具指令：用于性能分析、内存管理等内部或高级用途。  接下来的章节将详细介绍这些特殊注释。 二、//g...</div></div></div></a><a class="pagination-related" href="/f71cbfee727d/" title="Go 语言 Cron 任务调度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-19</div><div class="info-item-2">Go 语言 Cron 任务调度详解</div></div><div class="info-2"><div class="info-item-1"> Cron 是一种广泛应用于 Unix-like 操作系统中的时间任务调度工具。在 Go 语言中，为了方便地实现类似的功能，开发者通常会借助第三方库。其中，github.com/robfig/cron/v3 是一个功能强大、广泛采用且维护良好的 Go 语言 Cron 库，它提供了一个灵活、可靠的方式来定义和执行周期性任务。  核心思想：将遵循标准 Cron 表达式的任务调度逻辑封装在一个 Go 协程安全 (Goroutine-safe) 的调度器中，允许开发者以声明式的方式定义定时任务，并自动在指定时间触发执行。   一、为什么需要 Cron 任务调度？在软件开发中，许多场景需要定时执行特定的任务，例如：  数据同步与备份：每天凌晨备份数据库，或每小时同步一次外部数据源。 报告生成：每周、每月自动生成业务报表。 清理任务：定期清理过期缓存、日志文件或无效用户数据。 监控与告警：每隔几分钟检查系统状态或服务健康状况。 批量处理：在业务低峰期处理大量离线数据。  手动触发或简单的 time.Sleep 循环无法有效管理这些任务：  time.Sleep 难以处理复杂的时间规则（如“每...</div></div></div></a><a class="pagination-related" href="/87ed4967ce21/" title="Golang Goroutine 同步方法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-12</div><div class="info-item-2">Golang Goroutine 同步方法详解</div></div><div class="info-2"><div class="info-item-1"> Goroutine 是 Go 语言并发编程的核心，它是一种轻量级的执行单元，由 Go 运行时调度。然而，当多个 Goroutine 并发执行并访问共享资源时，如果不加以适当的控制，就可能导致数据竞争 (Data Race)、死锁 (Deadlock) 或其他难以调试的并发问题。因此，Goroutine 同步是编写健壮、高效 Go 并发程序的关键。  核心思想：Go 语言推崇通过通信来共享内存，而不是通过共享内存来通信 (Don’t communicate by sharing memory; share memory by communicating)。这体现在其核心的同步机制——Channel 上。然而，Go 也提供了传统的共享内存同步原语，如 Mutex，以应对不同的并发场景。   一、为什么需要 Goroutine 同步？当多个 Goroutine 同时访问和修改同一块内存区域（共享资源）时，操作的顺序变得不确定。这可能导致：  数据竞争 (Data Race)：当至少两个 Goroutine 并发访问同一个内存位置，并且至少有一个是写操作，且没有同步机制来协调这些访问时...</div></div></div></a><a class="pagination-related" href="/98c39f8e2307/" title="Go 语言协程设计与调度原理"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-05</div><div class="info-item-2">Go 语言协程设计与调度原理</div></div><div class="info-2"><div class="info-item-1"> Go 语言以其强大的并发特性而闻名，其核心是轻量级协程 (Goroutine) 和高效的调度器。理解 Goroutine 的设计理念以及 Go 运行时如何调度这些协程，对于编写高性能、高并发的 Go 应用程序至关重要。本文将深入探讨 Go 语言协程的设计哲学，并详细解析其背后支撑的 GMP 调度模型。  核心概念：  Goroutine：Go 语言的轻量级并发单元，用户态线程。 GMP 模型：Go 语言运行时调度 Goroutine 的核心模型，由 G (Goroutine)、M (Machine&#x2F;Thread)、P (Processor) 三要素组成。     一、Go 语言协程 (Goroutine) 的设计哲学传统的并发编程通常基于操作系统线程。虽然线程提供了并发能力，但它们也带来了不小的开销：  创建&#x2F;销毁开销大：创建和销毁线程需要向操作系统内核申请资源，涉及系统调用，开销较大。 上下文切换开销大：线程的上下文切换由操作系统内核完成，需要保存和恢复大量的寄存器信息，开销较大。 内存消耗大：每个线程通常需要 MB 级别的栈空间，大量线程会导致内存消耗巨...</div></div></div></a><a class="pagination-related" href="/fca8ac3162ce/" title="Viper (Go 配置库) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-27</div><div class="info-item-2">Viper (Go 配置库) 深度解析</div></div><div class="info-2"><div class="info-item-1"> Viper 是 Go 语言中一个完整的配置解决方案，它旨在简化应用程序的配置管理。Viper 能够处理来自不同源（如配置文件、环境变量、命令行参数、远程配置系统等）的配置数据，并提供一致的 API 供应用程序读取和操作。其主要目标是使配置变得灵活、可维护，并减少应用程序对特定配置源的依赖。  核心思想：提供一个统一的接口来从多种配置源（文件、环境变量、命令行等）加载、合并和管理应用程序配置。   一、为什么需要配置管理及 Viper 的优势1.1 应用程序配置的挑战在现代应用程序开发中，配置管理是一个核心且常见的挑战：  多环境配置：开发、测试、生产环境的配置参数（如数据库连接、API 密钥、服务地址）通常不同。 多配置源：配置可能来源于文件（JSON, YAML, TOML等）、环境变量、命令行参数、远程配置服务（Consul, Etcd）等。 配置优先级：当多个配置源定义了相同的键时，需要明确的优先级规则。 配置热加载：某些场景下，需要在不重启应用的情况下更新配置。 类型安全：从配置源读取的字符串需要正确地解析为 Go 应用程序中的对应数据类型。 代码侵入性：希望配置逻辑尽...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-text">一、为什么需要限流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-text">二、常用限流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8-Fixed-Window-Counter"><span class="toc-text">2.1 固定窗口计数器 (Fixed Window Counter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.1.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.1.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8-Sliding-Window-Counter"><span class="toc-text">2.2 滑动窗口计数器 (Sliding Window Counter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.2.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95-Leaky-Bucket"><span class="toc-text">2.3 漏桶算法 (Leaky Bucket)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.3.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95-Token-Bucket"><span class="toc-text">2.4 令牌桶算法 (Token Bucket)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.4.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4.2 Go 语言实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-text">三、限流算法的选择与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">3.1 选择哪个算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-text">3.2 实践中的考虑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-26.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>