<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Terraform 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Terraform 是由 HashiCorp 公司开发的一款开源基础设施即代码 (Infrastructure as Code, IaC) 工具。它允许用户通过声明式配置文件来定义、预置和管理云服务及其他基础设施资源，从而实现基础设施的自动化部署、版本控制和可重复性。  利用 Terraform，可以将基础设施（例如虚拟机、存储、网络、数据库等）编码为配置文件，然后通过统一的流程对这些基础设施进">
<meta property="og:type" content="article">
<meta property="og:title" content="Terraform 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/1d2a942bda1e/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Terraform 是由 HashiCorp 公司开发的一款开源基础设施即代码 (Infrastructure as Code, IaC) 工具。它允许用户通过声明式配置文件来定义、预置和管理云服务及其他基础设施资源，从而实现基础设施的自动化部署、版本控制和可重复性。  利用 Terraform，可以将基础设施（例如虚拟机、存储、网络、数据库等）编码为配置文件，然后通过统一的流程对这些基础设施进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg">
<meta property="article:published_time" content="2026-01-19T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-26T10:04:41.133Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="云服务">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Terraform 详解",
  "url": "https://blog.tbf1211.xx.kg/1d2a942bda1e/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg",
  "datePublished": "2026-01-19T22:24:00.000Z",
  "dateModified": "2026-02-26T10:04:41.133Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/1d2a942bda1e/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Terraform 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">562</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-31.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Terraform 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Terraform 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Terraform</strong> 是由 HashiCorp 公司开发的一款开源<strong>基础设施即代码 (Infrastructure as Code, IaC)</strong> 工具。它允许用户通过声明式配置文件来定义、预置和管理云服务及其他基础设施资源，从而实现基础设施的自动化部署、版本控制和可重复性。</p>
</blockquote>
<div class="note info flat"><p>利用 Terraform，可以将基础设施（例如虚拟机、存储、网络、数据库等）编码为配置文件，然后通过统一的流程对这些基础设施进行部署、更新和销毁。这不仅提高了效率，减少了手动操作带来的错误，还使基础设施的变更可追踪、可审计，极大地改善了团队协作和运维能力。</p>
</div>
<hr>
<h2 id="一、为什么需要-Terraform？"><a href="#一、为什么需要-Terraform？" class="headerlink" title="一、为什么需要 Terraform？"></a>一、为什么需要 Terraform？</h2><p>传统的IT基础设施管理通常涉及大量的人工操作，例如通过云服务提供商的控制台手动创建和配置资源。这种方式存在诸多问题：</p>
<ol>
<li><strong>效率低下且易出错</strong>：手动操作费时费力，且难以保证一致性，容易因人为失误导致配置漂移。</li>
<li><strong>缺乏版本控制</strong>：基础设施的配置无法像应用代码一样进行版本管理，难以追踪历史变更和进行回滚。</li>
<li><strong>环境不一致</strong>：在开发、测试和生产环境之间保持配置一致性成为难题。</li>
<li><strong>难以扩展</strong>：面对大规模的基础设施部署和快速变化的需求时，手动管理模式无法应对。</li>
<li><strong>协作困难</strong>：团队成员难以就基础设施配置进行有效协作和共享。</li>
</ol>
<p>Terraform 通过以下方式解决了这些问题：</p>
<ul>
<li><strong>自动化和标准化</strong>：通过代码定义基础设施，实现自动化部署和一致性配置。</li>
<li><strong>版本控制</strong>：基础设施配置可以存储在 Git 等版本控制系统中，实现变更追踪、审计和回滚。</li>
<li><strong>可重复性</strong>：通过相同的配置文件，可以在任何时候、任何地方重复部署出相同的环境。</li>
<li><strong>多云支持</strong>：支持AWS、Azure、GCP以及其他众多服务提供商，实现跨云基础设施管理。</li>
<li><strong>协作友好</strong>：团队成员可以共享、审查和协作基础设施代码。</li>
</ul>
<h2 id="二、Terraform-核心概念"><a href="#二、Terraform-核心概念" class="headerlink" title="二、Terraform 核心概念"></a>二、Terraform 核心概念</h2><p>在使用 Terraform 之前，理解其核心概念至关重要。</p>
<h3 id="2-1-基础设施即代码-IaC"><a href="#2-1-基础设施即代码-IaC" class="headerlink" title="2.1 基础设施即代码 (IaC)"></a>2.1 基础设施即代码 (IaC)</h3><p>这是一个将基础设施配置和管理视作软件代码的原则。通过 IaC，你可以使用代码和自动化工具来定义、配置、部署和管理基础设施，而不是手动操作。IaC 的关键在于其声明性和自动化特性。</p>
<h3 id="2-2-声明式与命令式"><a href="#2-2-声明式与命令式" class="headerlink" title="2.2 声明式与命令式"></a>2.2 声明式与命令式</h3><ul>
<li><strong>声明式 (Declarative)</strong>：Terraform 采取声明式方式。用户只需描述期望的基础设施的最终状态，Terraform 会负责找出如何从当前状态达到目标状态，并执行必要的变更。例如，你声明需要一个S3存储桶，Terraform 会检查是否已存在，如果不存在则创建，如果存在则确保其配置符合声明。</li>
<li><strong>命令式 (Imperative)</strong>：命令式工具（如 Ansible、Chef 等配置管理工具）则要求用户提供一系列具体的步骤或指令，来达到期望的状态。例如，一步步指导如何安装软件、配置服务。</li>
</ul>
<p>Terraform 主要用于<strong>资源编排 (Orchestration)</strong>，即管理资源的生命周期，而配置管理工具更多用于<strong>资源配置 (Configuration Management)</strong>，即管理资源内部的软件和配置。</p>
<h3 id="2-3-Provider-提供程序"><a href="#2-3-Provider-提供程序" class="headerlink" title="2.3 Provider (提供程序)"></a>2.3 Provider (提供程序)</h3><p><strong>Provider</strong> 是 Terraform 与各类云服务（如 AWS、Azure、GCP）或其他服务（如 Kubernetes、Docker、Vault）的 API 交互的插件。每个 Provider 都负责理解其对应的服务 API，并将其公开为 Terraform 可以管理的一组资源。</p>
<p><strong>示例：AWS Provider 配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    aws = &#123;</span><br><span class="line">      source  = &quot;hashicorp/aws&quot;</span><br><span class="line">      version = &quot;~&gt; 5.0&quot; # 指定AWS Provider的版本范围</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider &quot;aws&quot; &#123;</span><br><span class="line">  region = &quot;us-east-1&quot; # 定义AWS区域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Resource-资源"><a href="#2-4-Resource-资源" class="headerlink" title="2.4 Resource (资源)"></a>2.4 Resource (资源)</h3><p><strong>Resource</strong> 是 Terraform 管理的最小基础架构单元。它代表了云平台或服务中的一个具体组件，例如一台虚拟机、一个S3存储桶、一个VPC网络或一个数据库实例。每个 <code>resource</code> 块都包含两个字符串参数：资源类型（例如 <code>aws_instance</code>）和本地名称（例如 <code>web_server</code>），以及一个配置块，用于定义该资源的属性。</p>
<p><strong>示例：AWS S3 桶资源</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_s3_bucket&quot; &quot;my_application_bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;my-unique-application-bucket-12345&quot; # 桶名称必须全局唯一</span><br><span class="line">  acl    = &quot;private&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Environment = &quot;Development&quot;</span><br><span class="line">    Project     = &quot;TerraformGuide&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Data-Source-数据源"><a href="#2-5-Data-Source-数据源" class="headerlink" title="2.5 Data Source (数据源)"></a>2.5 Data Source (数据源)</h3><p><strong>Data Source</strong> 用于查询现有基础设施的信息，而不是创建新资源。这对于获取由其他方式创建的资源信息，或从远端检索特定配置数据非常有用。</p>
<p><strong>示例：查询现有 VPC 信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data &quot;aws_vpc&quot; &quot;selected&quot; &#123;</span><br><span class="line">  filter &#123;</span><br><span class="line">    name   = &quot;tag:Name&quot;</span><br><span class="line">    values = [&quot;my-existing-vpc&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;vpc_id&quot; &#123;</span><br><span class="line">  description = &quot;The ID of the existing VPC&quot;</span><br><span class="line">  value       = data.aws_vpc.selected.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-Module-模块"><a href="#2-6-Module-模块" class="headerlink" title="2.6 Module (模块)"></a>2.6 Module (模块)</h3><p><strong>Module</strong> 是一组 Terraform 配置文件的容器，用于封装和重用基础设施代码。每个 Terraform 配置本身就是一个模块（称为根模块），但你可以定义和使用子模块来组织配置、提高可重用性和管理复杂性。模块可以从本地路径、Terraform Registry、Git 仓库等多种来源加载。</p>
<h3 id="2-7-State-状态-文件"><a href="#2-7-State-状态-文件" class="headerlink" title="2.7 State (状态) 文件"></a>2.7 State (状态) 文件</h3><p><strong>State</strong> 文件（<code>terraform.tfstate</code>）是 Terraform 的核心。它记录了 Terraform 管理的所有资源及其在真实世界中的实际配置和状态。</p>
<ul>
<li><strong>映射真实资源</strong>：State 文件将您的 Terraform 配置与实际部署的云资源进行映射。</li>
<li><strong>性能优化</strong>：Terraform 使用 State 文件来判断哪些资源需要创建、更新或销毁，从而优化 <code>plan</code> 和 <code>apply</code> 的执行效率。</li>
<li><strong>管理元数据</strong>：除了资源属性，State 文件还存储了如资源依赖关系、Provider 版本等元数据。</li>
</ul>
<p><strong>重要性</strong>：State 文件是 Terraform 正确运行的基石，必须妥善管理。它可能包含敏感信息，且其损坏或丢失会导致 Terraform 无法正确管理基础设施。</p>
<h2 id="三、Terraform-工作流程"><a href="#三、Terraform-工作流程" class="headerlink" title="三、Terraform 工作流程"></a>三、Terraform 工作流程</h2><p>Terraform 的标准工作流程通常遵循以下步骤：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;编写 Terraform 配置 (.tf)&quot;] --&gt; B{terraform init};
    B -- 首次或配置变更 --&gt; C{下载 Provider, 初始化后端};
    C --&gt; D[terraform validate];
    D -- 配置语法检查 --&gt; E[terraform plan];
    E -- 审查执行计划, 确认变更 --&gt; F{准备执行};
    F -- 接受计划 --&gt; G[terraform apply];
    G -- 实际创建&#x2F;更新资源 --&gt; H[更新 Terraform State 文件];
    H -- 基础设施不再需要 --&gt; I[terraform destroy];
    I --&gt; J[删除基础设施, 更新 State];
    J -- finish --&gt; K{完成};
  </pre></div>

<h3 id="3-1-terraform-init"><a href="#3-1-terraform-init" class="headerlink" title="3.1 terraform init"></a>3.1 <code>terraform init</code></h3><p>初始化工作目录。它会执行以下操作：</p>
<ul>
<li><strong>下载 Provider 插件</strong>：根据配置中 <code>required_providers</code> 块定义的 Provider，下载并安装相应的插件。</li>
<li><strong>配置后端 (Backend)</strong>：根据配置中的 <code>backend</code> 块，初始化 State 存储的后端。</li>
<li><strong>子模块下载</strong>：如果使用了远程子模块，<code>init</code> 会下载它们。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform init</span><br></pre></td></tr></table></figure>

<h3 id="3-2-terraform-validate"><a href="#3-2-terraform-validate" class="headerlink" title="3.2 terraform validate"></a>3.2 <code>terraform validate</code></h3><p>验证配置文件的语法和内部一致性。它会在不连接任何远程服务的情况下，检查配置是否有效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform validate</span><br></pre></td></tr></table></figure>

<h3 id="3-3-terraform-plan"><a href="#3-3-terraform-plan" class="headerlink" title="3.3 terraform plan"></a>3.3 <code>terraform plan</code></h3><p>生成并显示一个执行计划。这个计划详细说明了 Terraform 将要执行的操作（创建、修改或销毁哪些资源），而不会实际执行这些操作。这是在 <code>apply</code> 之前进行审查和确认变更的关键步骤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure>
<p>如果你想保存这个计划以便后续精确执行，可以使用 <code>-out</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan -out <span class="string">&quot;my_plan.tfplan&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-terraform-apply"><a href="#3-4-terraform-apply" class="headerlink" title="3.4 terraform apply"></a>3.4 <code>terraform apply</code></h3><p>执行 <code>plan</code> 生成的或自动生成的执行计划，以创建、更新或销毁基础设施。在执行前，Terraform 会再次显示计划并请求用户确认。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure>
<p>如果之前保存了计划文件，可以直接应用它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply <span class="string">&quot;my_plan.tfplan&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-terraform-destroy"><a href="#3-5-terraform-destroy" class="headerlink" title="3.5 terraform destroy"></a>3.5 <code>terraform destroy</code></h3><p>用于销毁 Terraform 当前管理的所有资源。在使用此命令时需要格外小心，因为它会永久删除基础设施。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure>

<h2 id="四、Terraform-State-管理"><a href="#四、Terraform-State-管理" class="headerlink" title="四、Terraform State 管理"></a>四、Terraform State 管理</h2><p>State 文件是 Terraform 工作的基础，其管理至关重要。</p>
<h3 id="4-1-本地状态与远程状态"><a href="#4-1-本地状态与远程状态" class="headerlink" title="4.1 本地状态与远程状态"></a>4.1 本地状态与远程状态</h3><ul>
<li><p><strong>本地状态 (Local State)</strong>：默认情况下，<code>terraform.tfstate</code> 文件存储在执行 Terraform 命令的本地目录中。这适用于个人开发或小型项目，但在团队协作或自动化场景下，不推荐使用，因为容易出现状态不同步的问题。</p>
</li>
<li><p><strong>远程状态 (Remote State)</strong>：为了更好地支持团队协作和自动化，Terraform 提供了远程状态后端。它将 <code>tfstate</code> 文件存储在远程存储服务中，例如：</p>
<ul>
<li><strong>AWS S3</strong></li>
<li><strong>Azure Storage Blob</strong></li>
<li><strong>Google Cloud Storage (GCS)</strong></li>
<li><strong>HashiCorp Consul</strong></li>
<li><strong>Terraform Cloud&#x2F;Enterprise</strong></li>
</ul>
</li>
</ul>
<p>通过远程状态，所有团队成员都可以访问和更新最新的基础设施状态。</p>
<p><strong>远程状态配置示例 (AWS S3)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  backend &quot;s3&quot; &#123;</span><br><span class="line">    bucket         = &quot;my-terraform-state-bucket&quot;</span><br><span class="line">    key            = &quot;path/to/my/project/terraform.tfstate&quot;</span><br><span class="line">    region         = &quot;us-east-1&quot;</span><br><span class="line">    encrypt        = true  # 启用服务端加密</span><br><span class="line">    dynamodb_table = &quot;terraform-state-locking&quot; # 用于状态锁</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-状态锁定-State-Locking"><a href="#4-2-状态锁定-State-Locking" class="headerlink" title="4.2 状态锁定 (State Locking)"></a>4.2 状态锁定 (State Locking)</h3><p>当我们使用远程后端时，尤其是在团队协作环境中，防止多个用户同时对状态文件进行写操作至关重要。<strong>状态锁定</strong>机制可以确保在任何给定时间只有一个操作可以修改状态文件。</p>
<p>大多数远程后端（如 S3 + DynamoDB，Azure Blob + Storage Leases）都提供了内置的状态锁定功能。在配置远程后端时，应当启用并配置状态锁定。</p>
<h3 id="4-3-敏感数据处理"><a href="#4-3-敏感数据处理" class="headerlink" title="4.3 敏感数据处理"></a>4.3 敏感数据处理</h3><p>State 文件可能包含敏感信息，如数据库密码、API 密钥等。</p>
<ul>
<li><strong>最佳实践</strong>：不要在 Terraform 配置的输出或 State 文件中直接存储敏感数据。</li>
<li><strong>使用 Secret Manager</strong>：将敏感信息存储在专门的密钥管理服务中（如 AWS Secrets Manager, Azure Key Vault, HashiCorp Vault），并在 Terraform 中通过数据源动态引用它们。</li>
<li><strong>State 文件加密</strong>：始终为存储在远程后端的 State 文件启用服务端加密。</li>
</ul>
<h2 id="五、Terraform-模块-Modules"><a href="#五、Terraform-模块-Modules" class="headerlink" title="五、Terraform 模块 (Modules)"></a>五、Terraform 模块 (Modules)</h2><p>模块是 Terraform 的一项强大功能，用于在不同的项目或相同项目的不同部分之间共享和重用 Terraform 配置。</p>
<h3 id="5-1-为什么使用模块？"><a href="#5-1-为什么使用模块？" class="headerlink" title="5.1 为什么使用模块？"></a>5.1 为什么使用模块？</h3><ul>
<li><strong>组织和封装</strong>：将相关的资源组合在一起，形成逻辑单元，提高代码的可读性和可维护性。</li>
<li><strong>重用性</strong>：避免重复编写相同的配置，通过模块化可以快速部署标准化的基础设施模式。</li>
<li><strong>一致性</strong>：强制执行基础设施的最佳实践和标准。</li>
<li><strong>团队协作</strong>：允许不同的团队专注于其特定的基础设施组件。</li>
</ul>
<h3 id="5-2-模块结构"><a href="#5-2-模块结构" class="headerlink" title="5.2 模块结构"></a>5.2 模块结构</h3><p>一个模块是一个包含 Terraform 配置文件的目录。根模块是执行 <code>terraform apply</code> 命令所在的目录。任何其他目录都可以被视为子模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">├── outputs.tf</span><br><span class="line">├── modules/</span><br><span class="line">│   ├── vpc/</span><br><span class="line">│   │   ├── main.tf</span><br><span class="line">│   │   ├── variables.tf</span><br><span class="line">│   │   └── outputs.tf</span><br><span class="line">│   └── ec2-instance/</span><br><span class="line">│       ├── main.tf</span><br><span class="line">│       ├── variables.tf</span><br><span class="line">│       └── outputs.tf</span><br><span class="line">└── provider.tf</span><br></pre></td></tr></table></figure>

<h3 id="5-3-使用模块"><a href="#5-3-使用模块" class="headerlink" title="5.3 使用模块"></a>5.3 使用模块</h3><p>在 Terraform 配置中，使用 <code>module</code> 块来调用一个模块。</p>
<p><strong>示例：调用 VPC 模块</strong></p>
<p>假设我们有一个定义了 Vpc 和子网的模块在 <code>./modules/vpc</code> 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># main.tf (根模块)</span><br><span class="line"></span><br><span class="line">module &quot;application_vpc&quot; &#123;</span><br><span class="line">  source = &quot;./modules/vpc&quot; # 引用本地模块路径</span><br><span class="line"></span><br><span class="line">  # 将变量传递给模块</span><br><span class="line">  vpc_cidr       = &quot;10.0.0.0/16&quot;</span><br><span class="line">  public_subnets = [&quot;10.0.1.0/24&quot;, &quot;10.0.2.0/24&quot;]</span><br><span class="line">  private_subnets = [&quot;10.0.11.0/24&quot;, &quot;10.0.12.0/24&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 引用 VPC 模块的输出</span><br><span class="line">output &quot;vpc_id&quot; &#123;</span><br><span class="line">  value = module.application_vpc.vpc_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>./modules/vpc/main.tf</code> 模块的内部示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># modules/vpc/main.tf</span><br><span class="line">resource &quot;aws_vpc&quot; &quot;main&quot; &#123;</span><br><span class="line">  cidr_block = var.vpc_cidr</span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;AppVPC&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_subnet&quot; &quot;public&quot; &#123;</span><br><span class="line">  count             = length(var.public_subnets)</span><br><span class="line">  vpc_id            = aws_vpc.main.id</span><br><span class="line">  cidr_block        = var.public_subnets[count.index]</span><br><span class="line">  availability_zone = data.aws_availability_zones.available.names[count.index] # 动态获取可用区</span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;PublicSubnet-$&#123;count.index&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 其他资源如私有子网、路由表等</span><br></pre></td></tr></table></figure>

<p><strong><code>./modules/vpc/variables.tf</code> 模块的内部示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># modules/vpc/variables.tf</span><br><span class="line">variable &quot;vpc_cidr&quot; &#123;</span><br><span class="line">  description = &quot;CIDR block for the VPC&quot;</span><br><span class="line">  type        = string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;public_subnets&quot; &#123;</span><br><span class="line">  description = &quot;List of public subnet CIDRs&quot;</span><br><span class="line">  type        = list(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variable &quot;private_subnets&quot; &#123;</span><br><span class="line">  description = &quot;List of private subnet CIDRs&quot;</span><br><span class="line">  type        = list(string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>./modules/vpc/outputs.tf</code> 模块的内部示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># modules/vpc/outputs.tf</span><br><span class="line">output &quot;vpc_id&quot; &#123;</span><br><span class="line">  description = &quot;The ID of the created VPC&quot;</span><br><span class="line">  value       = aws_vpc.main.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &quot;public_subnet_ids&quot; &#123;</span><br><span class="line">  description = &quot;List of public subnet IDs&quot;</span><br><span class="line">  value       = aws_subnet.public.*.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、Terraform-高级概念"><a href="#六、Terraform-高级概念" class="headerlink" title="六、Terraform 高级概念"></a>六、Terraform 高级概念</h2><h3 id="6-1-Workspaces-工作区"><a href="#6-1-Workspaces-工作区" class="headerlink" title="6.1 Workspaces (工作区)"></a>6.1 Workspaces (工作区)</h3><p>Terraform Workspaces 允许你使用同一套 Terraform 配置来管理多个独立的状态。这对于管理不同环境（如开发、测试、生产）的基础设施非常有用。</p>
<ul>
<li><code>terraform workspace new [name]</code>：创建一个新的工作区。</li>
<li><code>terraform workspace select [name]</code>：切换到指定工作区。</li>
<li><code>terraform workspace list</code>：列出所有工作区。</li>
</ul>
<p>每个工作区都有自己的 State 文件，它们是相互隔离的。</p>
<h3 id="6-2-Outputs-输出"><a href="#6-2-Outputs-输出" class="headerlink" title="6.2 Outputs (输出)"></a>6.2 Outputs (输出)</h3><p>Outputs 用于从 Terraform 配置中导出某些值，供外部访问或在其他配置中使用（例如，父模块获取子模块的输出）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output &quot;bucket_endpoint&quot; &#123;</span><br><span class="line">  description = &quot;The endpoint URL for the S3 bucket&quot;</span><br><span class="line">  value       = aws_s3_bucket.my_application_bucket.bucket_regional_domain_name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Variables-变量"><a href="#6-3-Variables-变量" class="headerlink" title="6.3 Variables (变量)"></a>6.3 Variables (变量)</h3><p>Variables 允许你将配置参数化，从而提高配置的灵活性和重用性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">variable &quot;instance_type&quot; &#123;</span><br><span class="line">  description = &quot;The EC2 instance type&quot;</span><br><span class="line">  type        = string</span><br><span class="line">  default     = &quot;t2.micro&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;web&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-0abcdef1234567890&quot;</span><br><span class="line">  instance_type = var.instance_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量可以通过命令行（<code>-var</code> 参数）、环境变量（<code>TF_VAR_</code> 前缀）、文件（<code>*.tfvars</code> 或 <code>*.tfvars.json</code>）等方式赋值。</p>
<h3 id="6-4-Provisioners-配置器"><a href="#6-4-Provisioners-配置器" class="headerlink" title="6.4 Provisioners (配置器)"></a>6.4 Provisioners (配置器)</h3><p>Provisioners 允许你在资源创建或销毁后，在本地或远程机器上执行脚本。它们通常用于执行 bootstrapping、配置管理或清理任务。<br>然而，Provisioners 并不是 Terraform 的核心 IaC 能力，它在配置过程中引入了命令式逻辑，增加了复杂性。<strong>通常建议将配置管理任务交由专门的工具（如 Ansible、Chef、SaltStack、Puppet）处理，或利用云平台自带的初始化脚本 (如 Cloud-init, User Data)</strong>。</p>
<h2 id="七、Terraform-的优缺点与适用场景"><a href="#七、Terraform-的优缺点与适用场景" class="headerlink" title="七、Terraform 的优缺点与适用场景"></a>七、Terraform 的优缺点与适用场景</h2><h3 id="7-1-优点"><a href="#7-1-优点" class="headerlink" title="7.1 优点"></a>7.1 优点</h3><ol>
<li><strong>多云支持</strong>：通过统一的语言和工具管理跨云基础设施。</li>
<li><strong>声明式配置</strong>：易于理解期望状态，Terraform 负责实现。</li>
<li><strong>Idempotence (幂等性)</strong>：每次运行相同的配置，结果都是一致的，不会重复创建或修改已存在且符合声明的资源。</li>
<li><strong>版本控制</strong>：基础设施配置可版本化，支持审计、回滚和协作。</li>
<li><strong>模块化和重用</strong>：通过模块提高配置的重用性和可维护性。</li>
<li><strong>执行计划</strong>：<code>terraform plan</code> 提供了清晰的变更预览，降低了误操作风险。</li>
<li><strong>社区和生态系统</strong>：庞大的社区和丰富的 Provider 生态系统。</li>
</ol>
<h3 id="7-2-缺点"><a href="#7-2-缺点" class="headerlink" title="7.2 缺点"></a>7.2 缺点</h3><ol>
<li><strong>状态管理复杂性</strong>：State 文件的管理（尤其是在分布式团队中）需要谨慎处理，状态锁、远程后端、敏感数据保护都是挑战。</li>
<li><strong>无法撤销已应用的变更</strong>：如果你手动修改了云资源，Terraform 下次 <code>plan</code> 可能会发现“漂移”并计划将其改回配置描述的状态，但它无法“撤销”一个历史的 <code>apply</code> 操作。</li>
<li><strong>学习曲线</strong>：HCL 语法和 Terraform 概念对于初学者有一定学习门槛。</li>
<li><strong>实时状态更新</strong>：Terraform 的 <code>plan</code> 和 <code>apply</code> 操作虽然基于 State 文件，但也会与云端 API 交互获取实时状态。如果云资源频繁手动更改，可能导致状态漂移，需要定期 <code>refresh</code>。</li>
</ol>
<h3 id="7-3-适用场景"><a href="#7-3-适用场景" class="headerlink" title="7.3 适用场景"></a>7.3 适用场景</h3><ul>
<li><strong>多云或混合云环境</strong>：一致性管理AWS、Azure、GCP等基础设施。</li>
<li><strong>微服务架构</strong>：自动化部署和管理服务的依赖基础设施。</li>
<li><strong>开发&#x2F;测试&#x2F;生产环境管理</strong>：快速、一致地部署和销毁多个环境。</li>
<li><strong>灾难恢复</strong>：通过代码快速重建整个基础设施栈。</li>
<li><strong>持续集成&#x2F;持续部署 (CI&#x2F;CD)</strong>：将基础设施部署集成到自动化管道中。</li>
</ul>
<h2 id="八、安全性考虑"><a href="#八、安全性考虑" class="headerlink" title="八、安全性考虑"></a>八、安全性考虑</h2><p>在使用 Terraform 管理基础设施时，安全性是一个不容忽视的方面。</p>
<ol>
<li><strong>认证与授权</strong>：Terraform 需要凭证来通过 Provider 访问云服务 API。应遵循最小权限原则，为 Terraform 配置的用户或服务主体提供仅够其执行所需操作的权限。</li>
<li><strong>敏感数据保护</strong>：<ul>
<li><strong>不要将敏感信息硬编码到 TF 文件中</strong>。</li>
<li><strong>利用环境变量、Vault 等秘钥管理服务或云服务自身的 Secret Manager</strong> 来传递敏感数据。</li>
<li><strong>确保 State 文件加密</strong>，并存储在安全的远程后端中。</li>
</ul>
</li>
<li><strong>State 文件访问控制</strong>：对存储 State 文件的后端进行严格的访问控制。只允许授权的用户或服务访问和修改。</li>
<li><strong>Provider 版本锁定</strong>：使用 <code>required_providers</code> 块锁定 Provider 版本，避免因 Provider 升级带来的意外行为或安全漏洞。</li>
<li><strong>代码审查</strong>：对 Terraform 配置进行代码审查，以发现潜在的安全漏洞、错误配置或不符合最佳实践的部分。</li>
<li><strong><code>terraform plan</code> 审查</strong>：在执行 <code>apply</code> 之前，仔细审查 <code>plan</code> 的输出，确认所有变更都符合预期，没有意外的资源创建、修改或销毁。</li>
<li><strong>Workspaces 隔离</strong>：使用 Workspaces 隔离不同环境（Dev&#x2F;Prod）的 State 文件和资源，防止跨环境误操作。</li>
</ol>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>Terraform 已经成为管理现代云基础设施的行业标准工具之一。它将基础设施的创建、更新和销毁过程编码化，并引入版本控制和自动化，极大地提高了管理的效率、可控性和可重复性。通过深入理解其核心概念、工作流程和最佳实践，无论是个人开发者还是大型企业，都能有效利用 Terraform 构建和管理复杂、可靠的云基础设施。然而，正确处理状态管理、敏感数据以及遵循安全原则是成功使用 Terraform 的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/1d2a942bda1e/">https://blog.tbf1211.xx.kg/1d2a942bda1e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git 核心对象：Commit, Tree, Blob 详解</div></div><div class="info-2"><div class="info-item-1"> Git 作为一个分布式版本控制系统，其强大的能力和高效的存储机制离不开其底层对象模型。理解 Git 的核心对象——Commit (提交)、Tree (树) 和 Blob (二进制大对象)，是深入理解 Git 工作原理的关键。这些对象共同构成了 Git 存储库的骨架，以内容寻址 (Content-Addressable) 的方式，确保了版本历史的完整性和数据的不可篡改性。  Git 的宗旨是：一次只存储数据，而不是差异。 每个版本都是一个完整的快照，而非基于前一个版本的增量。这通过其核心对象模型高效实现。   一、Git 对象模型概述Git 存储库的核心是一个键值对数据库，其中“键”是内容的 SHA-1 校验和，而“值”则是 Git 对象。这些对象存储在 .git/objects 目录下。当 Git 添加或修改文件时，它不会直接存储文件的差异，而是将文件的完整内容作为对象存储起来，并根据其内容计算出一个唯一的 SHA-1 值作为标识符。 Git 对象主要分为四种类型，其中最核心的是 Blob、Tree 和 Commit：  Blob (Binary Large Object)：存...</div></div></div></a><a class="pagination-related" href="/26cdb2447b3d/" title="WebView 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">WebView 详解</div></div><div class="info-2"><div class="info-item-1"> WebView 是一个嵌入式浏览器组件，允许原生移动应用程序 (Native App) 在其 UI 内部显示网页内容。它不是一个完整的 Web 浏览器应用程序，而是一个可以集成到原生应用中的控件，通过它应用可以加载并渲染 HTML、CSS 和 JavaScript 内容，从而将 Web 技术的能力引入原生界面。  核心思想：在原生应用中提供一个轻量级的、可编程的 Web 浏览器环境，实现原生与 Web 内容的无缝融合和交互。   一、什么是 WebView？WebView 本质上是一个没有地址栏、工具栏等浏览器 UI 的浏览器内核。它能够解析并渲染网页，执行 JavaScript，处理 HTTP 请求等，但这些行为都受限于其所在的宿主原生应用。开发者可以通过 WebView 将 HTML5 应用、网页、动态内容或完整的混合应用 (Hybrid App) 集成到原生应用中。 WebView 的主要作用：  在原生应用中展示网页内容，例如新闻文章、用户协议、商品详情页等。 构建混合应用，将部分或全部 UI 通过 Web 技术实现，以提高开发效率和跨平台能力。 实现应用内的授权登录流...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-07</div><div class="info-item-2">传统命令行工具的现代补强与替代方案详解</div></div><div class="info-2"><div class="info-item-1"> 随着技术的发展和用户体验需求的变化，许多经典的 Unix&#x2F;Linux 命令行工具虽然功能强大且稳定，但在交互性、可视化、性能和便捷性方面，逐渐暴露出一些局限性。为了提升命令行操作的效率、可读性和舒适度，社区涌现出大量用 Go、Rust 等现代语言编写的“补强”或“替代”工具。本文将详细介绍一系列旨在现代化命令行体验的工具。  核心思想：并非完全取代经典工具，而是通过提供更丰富的功能、更美观的输出、更快的执行速度和更友好的交互方式，来增强或补充传统命令行工具的能力，以适应现代开发和系统管理的需求。   一、文件查看与内容处理1.1 cat 的补强：bat 传统工具：cat (concatenate files and print on the standard output) 现代补强：bat bat 是 cat 的一个语法高亮、分页和 Git 集成增强版。它不仅能显示文件内容，还能： 语法高亮：对代码文件自动进行语法高亮显示，支持多种编程语言。 行号显示：默认显示行号，方便代码审查和定位。 Git 集成：在显示文件时，会自动显示 Git 变更标记（如新增、修改）。 分...</div></div></div></a><a class="pagination-related" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-22</div><div class="info-item-2">Git 核心对象：Commit, Tree, Blob 详解</div></div><div class="info-2"><div class="info-item-1"> Git 作为一个分布式版本控制系统，其强大的能力和高效的存储机制离不开其底层对象模型。理解 Git 的核心对象——Commit (提交)、Tree (树) 和 Blob (二进制大对象)，是深入理解 Git 工作原理的关键。这些对象共同构成了 Git 存储库的骨架，以内容寻址 (Content-Addressable) 的方式，确保了版本历史的完整性和数据的不可篡改性。  Git 的宗旨是：一次只存储数据，而不是差异。 每个版本都是一个完整的快照，而非基于前一个版本的增量。这通过其核心对象模型高效实现。   一、Git 对象模型概述Git 存储库的核心是一个键值对数据库，其中“键”是内容的 SHA-1 校验和，而“值”则是 Git 对象。这些对象存储在 .git/objects 目录下。当 Git 添加或修改文件时，它不会直接存储文件的差异，而是将文件的完整内容作为对象存储起来，并根据其内容计算出一个唯一的 SHA-1 值作为标识符。 Git 对象主要分为四种类型，其中最核心的是 Blob、Tree 和 Commit：  Blob (Binary Large Object)：存...</div></div></div></a><a class="pagination-related" href="/d89aa974f51f/" title="ESP32 Arduino 舵机详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="info-item-2">ESP32 Arduino 舵机详解</div></div><div class="info-2"><div class="info-item-1"> 舵机 (Servo Motor) 是一种集成了直流电机、减速齿轮组、电位器和控制电路的微型直流电机。它能够精确地控制输出轴的角度位置，通常在 0 到 180 度之间旋转（标准舵机），或者实现连续旋转（连续旋转舵机）。在机器人、航模、自动化控制等领域，舵机因其小巧、控制简单、定位精确而广受欢迎。  核心思想：通过调整 PWM (脉冲宽度调制) 信号的脉冲宽度来控制舵机的角度。ESP32 凭借其强大的 LEDC (LED Controller) 模块，能够轻松、精确地驱动多个舵机。   一、舵机工作原理舵机通过接收一个PWM (脉冲宽度调制) 信号来确定其旋转角度。  供电：舵机通常需要 5V 的电源供电。请注意，单个舵机在工作时可能会消耗数百毫安的电流，多个舵机同时工作时电流需求会更大，因此需要一个外部电源为舵机供电，而不是直接由 ESP32 的 3.3V 或 5V 引脚供电（除非是微型舵机且数量极少）。 控制信号：舵机的控制线接收一个周期为 20 毫秒（即 50 Hz）的 PWM 信号。 脉冲宽度决定角度： 1.5 毫秒的脉冲宽度通常对应舵机的中心位置 (90 度)。 1 毫秒...</div></div></div></a><a class="pagination-related" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-01</div><div class="info-item-2">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</div></div><div class="info-2"><div class="info-item-1"> 在 Golang 中，内置的 map 类型不是并发安全的。当多个 goroutine 同时对 map 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 map，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 sync.Mutex 保护 map、使用 sync.RWMutex 保护 map，以及 Go 1.9 引入的 sync.Map，并对它们的特点、适用场景和性能进行对比分析。  核心问题：Go 内置 map 非并发安全。核心解决方案：  sync.Mutex：最简单粗暴，读写都加排他锁。 sync.RWMutex：读写分离锁，允许多个读操作并行，写操作独占。 sync.Map：专为读多写少、键不冲突或键值对持续增长的场景优化，内置无锁或乐观锁机制。     一、Go 内置 map 的并发问题Go 语言设计者有意将内置 map 设计为非并发安全的，主要出于以下考虑：  性能：为了避免在每次 map 操作时都承担锁的开销，从而在单线...</div></div></div></a><a class="pagination-related" href="/15920229f914/" title="Supabase 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-03</div><div class="info-item-2">Supabase 深度解析</div></div><div class="info-2"><div class="info-item-1"> Supabase 是一个开源的 Firebase 替代品，它提供了一整套后端即服务 (BaaS) 工具，旨在帮助开发者更快地构建应用。Its core philosophical difference from Firebase lies in its foundation: Supabase is built entirely around PostgreSQL作为其核心数据存储，并围绕 PostgreSQL 提供了认证、实时订阅、存储和边缘函数等一系列服务。这使得开发者可以使用熟悉的 SQL 语言来管理数据和定义业务逻辑，同时享受现代化 BaaS 服务的便利。  核心思想：以强大的开源关系型数据库 PostgreSQL 为中心，提供一套集成且可扩展的 BaaS 服务，实现从数据库到 API、认证、实时功能的无缝连接。    一、为什么需要 Supabase？传统上，构建一个功能完善的应用程序需要开发者处理大量的后端基础设施工作，包括：  数据库管理：选择、设置、维护数据库，编写 CRUD API。 用户认证和授权：实现用户注册、登录、密码重置、JWT 管理、权限控制。 实时...</div></div></div></a><a class="pagination-related" href="/30f43e04d28e/" title="中断机制详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="info-item-2">中断机制详解</div></div><div class="info-2"><div class="info-item-1"> 中断 (Interrupt) 是指当 CPU 在执行程序时，由于发生了某个事件（如 I&#x2F;O 完成、硬件故障、定时器溢出、程序错误等），导致 CPU 暂停当前程序的执行，转而去处理该事件，处理完毕后，再回到原程序继续执行的过程。中断是实现多任务、设备管理、错误处理等操作系统核心功能的基础。  核心思想：打破 CPU 顺序执行指令的模式，允许外部或内部事件暂时接管 CPU 控制权，提高系统效率和响应性。   一、为什么需要中断？在没有中断的早期计算机系统中，CPU 必须通过轮询 (Polling) 的方式来检查外部设备的状态。例如，CPU 需要不断地询问键盘是否有按键按下，或者打印机是否完成打印。这种方式存在明显的问题：  效率低下：CPU 大部分时间都在等待慢速设备，造成宝贵的计算资源浪费。 实时性差：如果 CPU 在执行一个耗时任务，无法及时响应其他设备的请求。 编程复杂：程序员需要手动编写大量轮询代码，增加了开发难度。  中断机制旨在解决这些问题，提供一种更高效、更灵活的事件处理方式：  提高 CPU 利用率：当设备忙碌或等待事件时，CPU 可以执行其他任务，而不是...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">562</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Terraform%EF%BC%9F"><span class="toc-text">一、为什么需要 Terraform？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Terraform-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Terraform 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%8D%B3%E4%BB%A3%E7%A0%81-IaC"><span class="toc-text">2.1 基础设施即代码 (IaC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%BC%8F"><span class="toc-text">2.2 声明式与命令式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Provider-%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.3 Provider (提供程序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Resource-%E8%B5%84%E6%BA%90"><span class="toc-text">2.4 Resource (资源)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Data-Source-%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">2.5 Data Source (数据源)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Module-%E6%A8%A1%E5%9D%97"><span class="toc-text">2.6 Module (模块)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-State-%E7%8A%B6%E6%80%81-%E6%96%87%E4%BB%B6"><span class="toc-text">2.7 State (状态) 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Terraform-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">三、Terraform 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-terraform-init"><span class="toc-text">3.1 terraform init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-terraform-validate"><span class="toc-text">3.2 terraform validate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-terraform-plan"><span class="toc-text">3.3 terraform plan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-terraform-apply"><span class="toc-text">3.4 terraform apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-terraform-destroy"><span class="toc-text">3.5 terraform destroy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Terraform-State-%E7%AE%A1%E7%90%86"><span class="toc-text">四、Terraform State 管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%9C%AC%E5%9C%B0%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BF%9C%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">4.1 本地状态与远程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%8A%B6%E6%80%81%E9%94%81%E5%AE%9A-State-Locking"><span class="toc-text">4.2 状态锁定 (State Locking)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-text">4.3 敏感数据处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Terraform-%E6%A8%A1%E5%9D%97-Modules"><span class="toc-text">五、Terraform 模块 (Modules)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="toc-text">5.1 为什么使用模块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><span class="toc-text">5.2 模块结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">5.3 使用模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Terraform-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5"><span class="toc-text">六、Terraform 高级概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Workspaces-%E5%B7%A5%E4%BD%9C%E5%8C%BA"><span class="toc-text">6.1 Workspaces (工作区)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Outputs-%E8%BE%93%E5%87%BA"><span class="toc-text">6.2 Outputs (输出)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Variables-%E5%8F%98%E9%87%8F"><span class="toc-text">6.3 Variables (变量)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Provisioners-%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-text">6.4 Provisioners (配置器)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Terraform-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">七、Terraform 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BC%98%E7%82%B9"><span class="toc-text">7.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">7.2 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">7.3 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">八、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">九、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0d177e0002e6/" title="程序错误处理详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序错误处理详解"/></a><div class="content"><a class="title" href="/0d177e0002e6/" title="程序错误处理详解">程序错误处理详解</a><time datetime="2026-02-13T22:24:00.000Z" title="发表于 2026-02-14 06:24:00">2026-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/a90dd53e3ba4/" title="Protocol Buffers 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Protocol Buffers 详解"/></a><div class="content"><a class="title" href="/a90dd53e3ba4/" title="Protocol Buffers 详解">Protocol Buffers 详解</a><time datetime="2026-02-11T22:24:00.000Z" title="发表于 2026-02-12 06:24:00">2026-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/28d59ad3e642/" title="Apache Avro 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Apache Avro 详解"/></a><div class="content"><a class="title" href="/28d59ad3e642/" title="Apache Avro 详解">Apache Avro 详解</a><time datetime="2026-02-09T22:24:00.000Z" title="发表于 2026-02-10 06:24:00">2026-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e3b0c5d197a/" title="Web Components 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Components 详解"/></a><div class="content"><a class="title" href="/4e3b0c5d197a/" title="Web Components 详解">Web Components 详解</a><time datetime="2026-02-07T22:24:00.000Z" title="发表于 2026-02-08 06:24:00">2026-02-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-31.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>