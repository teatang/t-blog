<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSH (Secure Shell) 协议详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SSH (Secure Shell) 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。  核心思想：通过在不可信网络上建立加密通道，保障客户端与服">
<meta property="og:type" content="article">
<meta property="og:title" content="SSH (Secure Shell) 协议详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/33c4660f6509/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="SSH (Secure Shell) 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。  核心思想：通过在不可信网络上建立加密通道，保障客户端与服">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg">
<meta property="article:published_time" content="2023-04-06T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-30T10:06:00.785Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSH (Secure Shell) 协议详解",
  "url": "https://blog.tbf1211.xx.kg/33c4660f6509/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg",
  "datePublished": "2023-04-06T22:24:00.000Z",
  "dateModified": "2026-01-30T10:06:00.785Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/33c4660f6509/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSH (Secure Shell) 协议详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-13.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">SSH (Secure Shell) 协议详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SSH (Secure Shell) 协议详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-04-06T22:24:00.000Z" title="发表于 2023-04-07 06:24:00">2023-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>SSH (Secure Shell)</strong> 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>通过在不可信网络上建立加密通道，保障客户端与服务器之间通信的机密性、完整性和认证性。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-SSH？"><a href="#一、为什么需要-SSH？" class="headerlink" title="一、为什么需要 SSH？"></a>一、为什么需要 SSH？</h2><p>在 SSH 出现之前，远程管理和文件传输主要依赖 Telnet、RSH (Remote Shell)、FTP (File Transfer Protocol) 等协议。这些协议存在严重的安全缺陷：</p>
<ul>
<li><strong>明文传输</strong>：用户名、密码和所有数据在网络中以明文形式传输，极易被窃听。</li>
<li><strong>缺乏认证</strong>：无法有效验证远程主机的身份，容易遭受中间人攻击 (Man-in-the-Middle, MITM)。</li>
</ul>
<p>SSH 的设计目标就是解决这些问题，提供一个安全的替代方案：</p>
<ul>
<li><strong>数据加密</strong>：所有传输数据（包括登录凭证和操作命令）都经过加密，防止窃听。</li>
<li><strong>强大的认证</strong>：不仅能够验证用户身份，还能验证远程主机的身份，防止欺骗。</li>
<li><strong>通信完整性</strong>：确保数据在传输过程中不被篡改。</li>
<li><strong>多种功能集成</strong>：除了远程命令行操作，还支持安全文件传输 (SCP, SFTP) 和端口转发。</li>
</ul>
<p>SSH 协议通常运行在 <strong>TCP 协议的 22 端口</strong>。</p>
<h2 id="二、SSH-协议概述与架构"><a href="#二、SSH-协议概述与架构" class="headerlink" title="二、SSH 协议概述与架构"></a>二、SSH 协议概述与架构</h2><p>SSH 协议是一个客户端-服务器架构，由客户端发起连接，服务器端负责响应和处理请求。SSH 协议栈可以分为三个主要层次：</p>
<ol>
<li><p><strong>传输层协议 (The Transport Layer Protocol)</strong>：</p>
<ul>
<li>提供服务器认证、数据机密性、数据完整性。</li>
<li>处理加密算法协商、密钥交换和数据加密解密。</li>
<li>通常使用 <strong>Diffie-Hellman 密钥交换算法</strong> 来协商对称加密密钥。</li>
<li>运行在 TCP 22 端口之上。</li>
</ul>
</li>
<li><p><strong>用户认证协议 (The User Authentication Protocol)</strong>：</p>
<ul>
<li>处理客户端用户向服务器的认证过程。</li>
<li>支持多种认证方法，最常见的是<strong>密码认证</strong>和<strong>公钥认证</strong>。</li>
</ul>
</li>
<li><p><strong>连接协议 (The Connection Protocol)</strong>：</p>
<ul>
<li>将加密后的传输通道复用为多个逻辑通道，例如：<ul>
<li><strong>Shell 会话</strong>：提供交互式命令行。</li>
<li><strong>端口转发</strong>：安全地转发 TCP 连接。</li>
<li><strong>X11 转发</strong>：安全地传输 X Window System 会话。</li>
<li><strong>文件传输</strong>：SCP (Secure Copy Protocol) 和 SFTP (SSH File Transfer Protocol)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="三、核心机制：加密与认证"><a href="#三、核心机制：加密与认证" class="headerlink" title="三、核心机制：加密与认证"></a>三、核心机制：加密与认证</h2><h3 id="3-1-加密机制"><a href="#3-1-加密机制" class="headerlink" title="3.1 加密机制"></a>3.1 加密机制</h3><p>SSH 使用多种加密技术来确保通信安全：</p>
<ol>
<li><p><strong>非对称加密 (Public-Key Cryptography)</strong>：</p>
<ul>
<li>主要用于<strong>密钥交换</strong>和<strong>服务器认证</strong>。</li>
<li>客户端和服务器在连接建立初期交换公钥，通过 Diffie-Hellman 算法协商出会话密钥。</li>
<li>服务器的公钥用于向客户端证明其身份（客户端会将其与本地 <code>known_hosts</code> 文件中的记录进行比对）。</li>
</ul>
</li>
<li><p><strong>对称加密 (Symmetric-Key Cryptography)</strong>：</p>
<ul>
<li>用于<strong>加密实际的数据传输</strong>。</li>
<li>在密钥交换阶段协商出的会话密钥只在当前连接中有效，连接结束后销毁。</li>
<li>常用算法：AES (Advanced Encryption Standard)、3DES 等。</li>
</ul>
</li>
<li><p><strong>哈希算法 (Hashing Algorithms)</strong>：</p>
<ul>
<li>用于<strong>数据完整性检查</strong>，防止数据在传输过程中被篡改。</li>
<li>常用算法：HMAC-SHA256、HMAC-MD5 等。</li>
</ul>
</li>
</ol>
<h3 id="3-2-认证机制"><a href="#3-2-认证机制" class="headerlink" title="3.2 认证机制"></a>3.2 认证机制</h3><p>SSH 提供两种主要的用户认证方式：</p>
<ol>
<li><p><strong>密码认证 (Password Authentication)</strong>：</p>
<ul>
<li>用户提供用户名和密码，服务器通过 <code>/etc/passwd</code> 或其他认证机制（如 PAM）进行验证。</li>
<li>虽然密码本身会加密传输，但在存在弱密码的情况下仍易受暴力破解攻击。</li>
</ul>
</li>
<li><p><strong>公钥认证 (Public Key Authentication)</strong>：</p>
<ul>
<li>更安全、推荐的认证方式，依赖于<strong>密钥对</strong>（公钥和私钥）。</li>
<li>用户在本地生成一对密钥：<strong>私钥 (Private Key)</strong> 保存在客户端，<strong>公钥 (Public Key)</strong> 上传到服务器的指定位置 (<code>~/.ssh/authorized_keys</code> 文件)。</li>
<li>认证流程：<ol>
<li>客户端向服务器发送连接请求，并声明使用公钥认证。</li>
<li>服务器根据客户端提供的用户名，在 <code>authorized_keys</code> 中查找对应的客户端公钥。</li>
<li>服务器生成一个随机字符串，并使用该公钥对其进行加密，然后发送给客户端。</li>
<li>客户端使用本地存储的私钥解密收到的字符串，并将解密后的结果重新发送给服务器。</li>
<li>服务器验证收到的解密结果是否与原始字符串一致。如果一致，则认证成功。</li>
</ol>
</li>
<li>私钥通常可以设置密码保护 (passphrase)，提供额外的安全层。</li>
</ul>
</li>
</ol>
<h2 id="四、SSH-连接过程详解"><a href="#四、SSH-连接过程详解" class="headerlink" title="四、SSH 连接过程详解"></a>四、SSH 连接过程详解</h2><p>一个典型的 SSH 连接过程如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as SSH 客户端
    participant Server as SSH 服务器

    Client-&gt;&gt;Server: 1. 建立 TCP 连接 (默认端口 22)
    Server-&gt;&gt;Client: 2. Server 发送协议版本字符串
    Client-&gt;&gt;Server: 3. Client 发送协议版本字符串
    Client-&gt;&gt;Server: 4. 协商加密算法和会话密钥 (Diffie-Hellman)
    Server-&gt;&gt;Client: 5. Server 发送自己的公钥 (Host Key)
    Client-&gt;&gt;Client: 6. 验证 Server 公钥 (检查 known_hosts)
    alt Server 公钥未经确认或不匹配
        Client-&gt;&gt;Client: 警告用户，可能存在 MITM 攻击
        Client--xServer: 连接中断 (或用户选择继续)
    end
    Client-&gt;&gt;Server: 7. 用户认证开始 (密码或公钥)
    alt 密码认证
        Client-&gt;&gt;Server: 发送用户名和加密后的密码
        Server-&gt;&gt;Server: 验证用户密码
    else 公钥认证
        Client-&gt;&gt;Server: 发送用户名和公钥认证请求
        Server-&gt;&gt;Server: (a) 查找用户 ~&#x2F;.ssh&#x2F;authorized_keys 中的公钥
        Server-&gt;&gt;Client: (b) 使用对应公钥加密一个随机字符串
        Client-&gt;&gt;Client: (c) 使用本地私钥解密字符串
        Client-&gt;&gt;Server: (d) 发送解密后的字符串
        Server-&gt;&gt;Server: (e) 验证字符串是否匹配
    end
    alt 认证成功
        Server--&gt;&gt;Client: 8. 认证成功
        Client-&gt;&gt;Server: 9. 请求开启一个 Shell 会话或端口转发等
        Server--&gt;&gt;Client: 10. 开启安全会话
    else 认证失败
        Server--xClient: 8. 认证失败，连接中断
    end
  </pre></div>

<h3 id="4-1-主机认证-known-hosts"><a href="#4-1-主机认证-known-hosts" class="headerlink" title="4.1 主机认证 (known_hosts)"></a>4.1 主机认证 (<code>known_hosts</code>)</h3><p>在客户端首次连接到一台新的 SSH 服务器时，服务器会将其公钥（Host Key）发送给客户端。客户端会将此公钥指纹与用户确认后存储在 <code>~/.ssh/known_hosts</code> 文件中。<br>下次连接时，客户端会检查服务器的 Host Key 是否与 <code>known_hosts</code> 中存储的记录匹配。如果 Host Key 发生变化，客户端会发出警告，提示可能存在中间人攻击。</p>
<h2 id="五、SSH-常用功能与命令"><a href="#五、SSH-常用功能与命令" class="headerlink" title="五、SSH 常用功能与命令"></a>五、SSH 常用功能与命令</h2><h3 id="5-1-远程登录"><a href="#5-1-远程登录" class="headerlink" title="5.1 远程登录"></a>5.1 远程登录</h3><p>最基本的用途是远程登录到服务器执行命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录到 example.com 服务器，使用当前用户名</span></span><br><span class="line">ssh example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录到 example.com 服务器，使用用户名为 &quot;admin&quot;</span></span><br><span class="line">ssh admin@example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录后直接执行命令，然后退出</span></span><br><span class="line">ssh admin@example.com <span class="string">&quot;ls -l /var/log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口登录 (如果SSH服务器不在默认的22端口)</span></span><br><span class="line">ssh -p 2222 admin@example.com</span><br></pre></td></tr></table></figure>

<h3 id="5-2-文件传输-SCP-SFTP"><a href="#5-2-文件传输-SCP-SFTP" class="headerlink" title="5.2 文件传输 (SCP &#x2F; SFTP)"></a>5.2 文件传输 (SCP &#x2F; SFTP)</h3><ol>
<li><p><strong>SCP (Secure Copy Protocol)</strong>：用于在本地和远程主机之间复制文件或目录。</p>
<ul>
<li><strong>从本地复制到远程：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /path/to/local/file user@remote_host:/path/to/remote/directory</span><br><span class="line">scp -r /path/to/local/dir user@remote_host:/path/to/remote/directory <span class="comment"># -r 递归复制目录</span></span><br></pre></td></tr></table></figure></li>
<li><strong>从远程复制到本地：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user@remote_host:/path/to/remote/file /path/to/local/directory</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>SFTP (SSH File Transfer Protocol)</strong>：提供更交互式的文件传输体验，类似于 FTP，但基于 SSH。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sftp user@remote_host</span><br><span class="line"><span class="comment"># 进入SFTP shell后可以使用 ls, cd, get, put 等命令</span></span><br><span class="line">sftp&gt; <span class="built_in">ls</span></span><br><span class="line">sftp&gt; get remote_file.txt</span><br><span class="line">sftp&gt; put local_file.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-3-端口转发-Port-Forwarding-Tunneling"><a href="#5-3-端口转发-Port-Forwarding-Tunneling" class="headerlink" title="5.3 端口转发 (Port Forwarding &#x2F; Tunneling)"></a>5.3 端口转发 (Port Forwarding &#x2F; Tunneling)</h3><p>SSH 端口转发允许通过加密的 SSH 信道转发网络端口，从而安全地访问内部网络资源或绕过防火墙。</p>
<ol>
<li><p><strong>本地端口转发 (Local Port Forwarding, <code>-L</code>)</strong>：<br>将<strong>本地机器</strong>的一个端口的数据转发到<strong>远程机器</strong>的某个端口。<br>场景：访问位于远程内网的服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L [local_port]:[destination_host]:[destination_port] [user@]ssh_server</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong> 将本地 <code>8080</code> 端口的流量转发到 <code>ssh_server</code> 机器上的 <code>internal_db_server</code> 的 <code>3306</code> 端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 8080:internal_db_server:3306 user@ssh_server</span><br><span class="line"><span class="comment"># 此时，访问本地 localhost:8080 就像访问 internal_db_server:3306 一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>远程端口转发 (Remote Port Forwarding, <code>-R</code>)</strong>：<br>将<strong>远程机器</strong>的一个端口的数据转发到<strong>本地机器</strong>的某个端口。<br>场景：让外部网络通过 SSH 服务器访问本地内网的服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R [remote_port]:[destination_host]:[destination_port] [user@]ssh_server</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong> 将 <code>ssh_server</code> 机器的 <code>80</code> 端口的流量转发到本地机器的 <code>localhost:80</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 80:localhost:80 user@ssh_server</span><br><span class="line"><span class="comment"># 此时，ssh_server 上的用户访问 ssh_server:80 就像访问本地机器的 localhost:80 一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态端口转发 (Dynamic Port Forwarding, <code>-D</code>)</strong>：<br>将本地机器变为一个 SOCKS 代理服务器。所有通过这个 SOCKS 代理的流量都会通过 SSH 连接进行转发。<br>场景：构建一个安全的 SOCKS 代理，用于浏览网页或访问任意服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D [local_port] [user@]ssh_server</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong> 在本地 <code>1080</code> 端口创建一个 SOCKS 代理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 1080 user@ssh_server</span><br><span class="line"><span class="comment"># 配置浏览器或应用程序使用 localhost:1080 作为 SOCKS 代理</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-4-SSH-配置-ssh-config"><a href="#5-4-SSH-配置-ssh-config" class="headerlink" title="5.4 SSH 配置 (~/.ssh/config)"></a>5.4 SSH 配置 (<code>~/.ssh/config</code>)</h3><p>使用 <code>~/.ssh/config</code> 文件可以为不同的主机定义个性化的 SSH 连接参数，简化命令输入，提高效率。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.ssh/config 示例</span></span><br><span class="line">Host myserver</span><br><span class="line">    HostName example.com</span><br><span class="line">    User admin</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_myserver</span><br><span class="line">    ForwardAgent yes</span><br><span class="line">    LocalForward 8080 internal_service.local:80</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">    ServerAliveInterval 60</span><br><span class="line">    ServerAliveCountMax 3</span><br></pre></td></tr></table></figure>

<h3 id="5-5-SSH-代理-ssh-agent-ssh-add"><a href="#5-5-SSH-代理-ssh-agent-ssh-add" class="headerlink" title="5.5 SSH 代理 (ssh-agent, ssh-add)"></a>5.5 SSH 代理 (<code>ssh-agent</code>, <code>ssh-add</code>)</h3><p><code>ssh-agent</code> 是一个在后台运行的程序，它保存私钥，无需在每次使用私钥时都输入密码。<br><code>ssh-add</code> 用于将私钥添加到 <code>ssh-agent</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span> <span class="comment"># 启动 ssh-agent</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa  <span class="comment"># 将私钥添加到 agent</span></span><br><span class="line"><span class="comment"># 此时，只需输入一次私钥密码，后续使用该私钥的 SSH 连接将不再需要密码</span></span><br></pre></td></tr></table></figure>

<h2 id="六、安全性考虑与最佳实践"><a href="#六、安全性考虑与最佳实践" class="headerlink" title="六、安全性考虑与最佳实践"></a>六、安全性考虑与最佳实践</h2><ol>
<li><strong>禁用密码认证 (Password Authentication)</strong>：如果可能，禁用服务器上的密码认证，只允许公钥认证。<ul>
<li>在 <code>/etc/ssh/sshd_config</code> 中设置 <code>PasswordAuthentication no</code>。</li>
</ul>
</li>
<li><strong>使用强密码保护私钥</strong>：为私钥设置一个复杂且独特的密码 (passphrase)。</li>
<li><strong>保护私钥文件</strong>：私钥文件权限必须严格控制 (<code>chmod 400 ~/.ssh/id_rsa</code>)，确保只有所有者可读。绝不共享私钥。</li>
<li><strong>禁用 Root 用户直接登录</strong>：通过普通用户登录，再使用 <code>sudo</code> 提权。<ul>
<li>在 <code>/etc/ssh/sshd_config</code> 中设置 <code>PermitRootLogin no</code>。</li>
</ul>
</li>
<li><strong>修改默认 SSH 端口</strong>：将 SSH 端口从默认的 22 更改为其他非常用端口，可以减少针对 22 端口的扫描和自动化攻击。<ul>
<li>在 <code>/etc/ssh/sshd_config</code> 中设置 <code>Port [新端口号]</code>。</li>
</ul>
</li>
<li><strong>限制 SSH 访问 IP</strong>：通过防火墙 (<code>ufw</code>, <code>firewalld</code>) 或 <code>sshd_config</code> 中的 <code>AllowUsers</code>, <code>AllowGroups</code>, <code>AllowIPs</code> 等指令限制可访问 SSH 的源 IP 地址。</li>
<li><strong>定期更新系统和 SSH 版本</strong>：及时安装安全补丁，以防止已知漏洞被利用。</li>
<li><strong>启用两步认证 (Two-Factor Authentication, 2FA)</strong>：结合 Google Authenticator 等工具，为 SSH 登录增加一层安全保护。</li>
<li><strong>使用 SSH Agent Forwarding</strong>：当需要从一台跳板机连接到内网其他服务器时，可以通过 Agent Forwarding 安全地使用本地私钥进行认证，避免将私钥复制到跳板机。在 <code>~/.ssh/config</code> 中设置 <code>ForwardAgent yes</code>。</li>
<li><strong>限制 <code>authorized_keys</code> 文件的权限</strong>：<code>~/.ssh</code> 目录权限应为 <code>700</code>，<code>authorized_keys</code> 文件权限应为 <code>600</code>。</li>
</ol>
<h2 id="七、代码示例：在-Python-中使用-Paramiko-库进行-SSH-连接"><a href="#七、代码示例：在-Python-中使用-Paramiko-库进行-SSH-连接" class="headerlink" title="七、代码示例：在 Python 中使用 Paramiko 库进行 SSH 连接"></a>七、代码示例：在 Python 中使用 Paramiko 库进行 SSH 连接</h2><p><code>Paramiko</code> 是一个 Python 实现的 SSHv2 协议库，可以用于客户端和服务器端 SSH 功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_command_execution</span>(<span class="params">hostname, username, private_key_path, command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过 SSH 连接到远程主机并执行命令。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        hostname (str): 远程主机名或IP地址。</span></span><br><span class="line"><span class="string">        username (str): 登录用户名。</span></span><br><span class="line"><span class="string">        private_key_path (str): 私钥文件的路径。</span></span><br><span class="line"><span class="string">        command (str): 要执行的命令。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建一个SSH客户端实例</span></span><br><span class="line">        client = paramiko.SSHClient()</span><br><span class="line">        <span class="comment"># 自动添加新主机的指纹（注意：在生产环境中应手动验证指纹）</span></span><br><span class="line">        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载私钥</span></span><br><span class="line">        private_key = paramiko.RSAKey.from_private_key_file(private_key_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接到远程主机</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connecting to <span class="subst">&#123;username&#125;</span>@<span class="subst">&#123;hostname&#125;</span> using key: <span class="subst">&#123;private_key_path&#125;</span>...&quot;</span>)</span><br><span class="line">        client.connect(hostname=hostname, username=username, pkey=private_key)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection successful.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行命令</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Executing command: &#x27;<span class="subst">&#123;command&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        stdin, stdout, stderr = client.exec_command(command)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印命令输出</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n--- STDOUT ---&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> stdout:</span><br><span class="line">            <span class="built_in">print</span>(line.strip())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n--- STDERR ---&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> stderr:</span><br><span class="line">            <span class="built_in">print</span>(line.strip())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取退出码</span></span><br><span class="line">        exit_code = stdout.channel.recv_exit_status()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\nCommand exited with code: <span class="subst">&#123;exit_code&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> paramiko.AuthenticationException:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Authentication failed. Check your username, password, or private key.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> paramiko.SSHException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SSH error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> client:</span><br><span class="line">            client.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;SSH connection closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    REMOTE_HOST = <span class="string">&quot;your_server_ip_or_hostname&quot;</span> <span class="comment"># 替换为你的服务器IP或主机名</span></span><br><span class="line">    REMOTE_USER = <span class="string">&quot;your_username&quot;</span>             <span class="comment"># 替换为你的用户名</span></span><br><span class="line">    PRIVATE_KEY = os.path.expanduser(<span class="string">&quot;~/.ssh/id_rsa&quot;</span>) <span class="comment"># 替换为你的私钥路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请确保你的私钥文件存在且权限正确 (chmod 400 ~/.ssh/id_rsa)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(PRIVATE_KEY):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: Private key file not found at <span class="subst">&#123;PRIVATE_KEY&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please generate an SSH key pair or specify the correct path.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 测试执行一个简单命令</span></span><br><span class="line">        ssh_command_execution(REMOTE_HOST, REMOTE_USER, PRIVATE_KEY, <span class="string">&quot;hostname &amp;&amp; uptime&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 测试执行另一个命令</span></span><br><span class="line">        <span class="comment"># ssh_command_execution(REMOTE_HOST, REMOTE_USER, PRIVATE_KEY, &quot;ls -l /tmp&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>SSH 协议是现代远程管理和网络安全基石。它通过强大的加密和认证机制，为在不安全网络上传输敏感数据和执行远程操作提供了可靠的保障。理解 SSH 的工作原理、其多样的功能（远程登录、文件传输、端口转发）以及实施安全最佳实践，对于任何系统管理员或开发者都是至关重要的。正确配置和使用 SSH 不仅能提高工作效率，更能大幅提升系统安全性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/33c4660f6509/">https://blog.tbf1211.xx.kg/33c4660f6509/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/59d0e10ae2fa/" title="HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私</div></div><div class="info-2"><div class="info-item-1"> HTTPS (Hypertext Transfer Protocol Secure)，即超文本传输安全协议，是在 HTTP 协议的基础上，通过添加 SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security) 协议层来提供安全性的网络协议。它确保了客户端（通常是浏览器）和服务器之间的数据传输加密、完整且经过认证，从而保护用户的隐私和数据的安全。  核心思想：在不安全的互联网上，为 HTTP 通信提供加密、身份认证和数据完整性保护，使得网站能够安全可靠地传输信息。   一、为什么需要 HTTPS？传统的 HTTP 协议是一种明文传输协议，其数据的传输是透明的，没有任何加密。这导致了多重重要的安全隐患：  数据窃听 (Eavesdropping &#x2F; Sniffing)：  任何网络中间节点（如 Wi-Fi 热点、路由器、ISP）都可以截获并读取用户与网站之间传输的所有数据，包括敏感信息如用户名、密码、银行卡号、邮件内容等。 例如，您在一个非 HTTPS 网站登录，您的用户名和密码在网络中就是明文传输，攻...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/a148e5499a60/" title="IPSec (Internet Protocol Security) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-13</div><div class="info-item-2">IPSec (Internet Protocol Security) 详解</div></div><div class="info-2"><div class="info-item-1"> IPSec (Internet Protocol Security) 是一套在 IP 层 (网络层) 提供安全服务的协议族。它不依赖于任何特定的应用程序，而是通过加密和认证 IP 数据包在网络中安全传输。IPSec 广泛应用于构建 VPN (Virtual Private Network - 虚拟专用网络)，为远程用户、分支机构和云资源提供安全的、端到端的通信。它提供了数据完整性、数据源认证、防重放保护以及数据机密性等关键安全服务。  核心思想：IPSec 通过在网络层透明地加密和认证 IP 数据包，为 IP 通信提供端到端的安全保障，是构建安全 VPN 和保护 IP 流量的核心技术。   一、IPSec 概述1.1 什么是 IPSec？IPSec 是由 IETF (Internet Engineering Task Force) 定义的一整套开放标准的协议族，它工作在 OSI 模型的网络层 (Layer 3)。其核心目标是为 IP 通信提供高级安全功能，而无需修改应用程序。 1.2 为什么需要 IPSec？传统的 IP 协议本身无法提供数据的机密性、完整性或认证。数据在公共网...</div></div></div></a><a class="pagination-related" href="/22aa4c322dbd/" title="TLS (传输层安全协议) 深度详解：网络通信的守护者"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="info-item-2">TLS (传输层安全协议) 深度详解：网络通信的守护者</div></div><div class="info-2"><div class="info-item-1"> TLS (Transport Layer Security)，即传输层安全性协议，是用于在计算机网络上提供端到端安全通信的加密协议。它是 SSL (Secure Sockets Layer) 协议的继任者，两者常被混用，但技术上，现代网络浏览器及服务器都已使用 TLS 协议。TLS 主要提供数据隐私、数据完整性以及通信双方的身份认证，是互联网上最广泛使用的安全协议，例如 HTTPS (HTTP over TLS)、SMTPS、LDAPS 等都依赖于 TLS。  核心思想：在不可信的网络上，通过加密、认证和完整性校验，建立一个可信的加密通信通道。   一、为什么需要 TLS？互联网的早期（例如纯 HTTP 时代），数据在传输过程中是明文的。这意味着：  窃听 (Eavesdropping)：任何中间人（如 ISP、路由器管理员、恶意攻击者）都可以截获并读取传输中的数据，包括用户密码、银行卡信息、私人消息等。 篡改 (Tampering)：中间人不仅可以读取数据，还可以修改数据，例如在网页中植入恶意代码，或者更改用户提交的表单内容。 身份伪装 (Impersonation)：客户端...</div></div></div></a><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a><a class="pagination-related" href="/378a51590e55/" title="HTTP&#x2F;1.1 协议深度详解：Web 通信的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="info-item-2">HTTP&#x2F;1.1 协议深度详解：Web 通信的基石</div></div><div class="info-2"><div class="info-item-1"> HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。  核心思想：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于请求-响应模型，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。   一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：  短连接 (Short Connection)：HTTP&#x2F;1.0 默认每个请求&#x2F;响应...</div></div></div></a><a class="pagination-related" href="/6479020306f5/" title="HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="info-item-2">HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;3 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 QUIC (Quick UDP Internet Connections) 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全性及在复杂网络环境下的韧性，从而彻底改变 Web 资源的传输方式。  核心思想：HTTP&#x2F;3 运行在 QUIC 协议之上，而 QUIC 又运行在 UDP 协议之上。通过在传输层而非应用层引入多路复用、内置 TLS 1.3 加密、连接迁移等特性，HTTP&#x2F;3 提供了一个比 HTTP&#x2F;2 更快、更稳定、更安全的 Web 体验，尤其在移动网络和有损网络环境下表现突出。   一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景HTTP&#x2F;2 作为 HTTP&#x2F;1.1 的继任者，通过头部压缩、多路复用和服务器推送等机制，显著提升了...</div></div></div></a><a class="pagination-related" href="/59d0e10ae2fa/" title="HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-05</div><div class="info-item-2">HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私</div></div><div class="info-2"><div class="info-item-1"> HTTPS (Hypertext Transfer Protocol Secure)，即超文本传输安全协议，是在 HTTP 协议的基础上，通过添加 SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security) 协议层来提供安全性的网络协议。它确保了客户端（通常是浏览器）和服务器之间的数据传输加密、完整且经过认证，从而保护用户的隐私和数据的安全。  核心思想：在不安全的互联网上，为 HTTP 通信提供加密、身份认证和数据完整性保护，使得网站能够安全可靠地传输信息。   一、为什么需要 HTTPS？传统的 HTTP 协议是一种明文传输协议，其数据的传输是透明的，没有任何加密。这导致了多重重要的安全隐患：  数据窃听 (Eavesdropping &#x2F; Sniffing)：  任何网络中间节点（如 Wi-Fi 热点、路由器、ISP）都可以截获并读取用户与网站之间传输的所有数据，包括敏感信息如用户名、密码、银行卡号、邮件内容等。 例如，您在一个非 HTTPS 网站登录，您的用户名和密码在网络中就是明文传输，攻...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-SSH%EF%BC%9F"><span class="toc-text">一、为什么需要 SSH？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SSH-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%9E%B6%E6%9E%84"><span class="toc-text">二、SSH 协议概述与架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81"><span class="toc-text">三、核心机制：加密与认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6"><span class="toc-text">3.1 加密机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-text">3.2 认证机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SSH-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">四、SSH 连接过程详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%BB%E6%9C%BA%E8%AE%A4%E8%AF%81-known-hosts"><span class="toc-text">4.1 主机认证 (known_hosts)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81SSH-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%91%BD%E4%BB%A4"><span class="toc-text">五、SSH 常用功能与命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95"><span class="toc-text">5.1 远程登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93-SCP-SFTP"><span class="toc-text">5.2 文件传输 (SCP &#x2F; SFTP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91-Port-Forwarding-Tunneling"><span class="toc-text">5.3 端口转发 (Port Forwarding &#x2F; Tunneling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-SSH-%E9%85%8D%E7%BD%AE-ssh-config"><span class="toc-text">5.4 SSH 配置 (~&#x2F;.ssh&#x2F;config)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-SSH-%E4%BB%A3%E7%90%86-ssh-agent-ssh-add"><span class="toc-text">5.5 SSH 代理 (ssh-agent, ssh-add)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">六、安全性考虑与最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9C%A8-Python-%E4%B8%AD%E4%BD%BF%E7%94%A8-Paramiko-%E5%BA%93%E8%BF%9B%E8%A1%8C-SSH-%E8%BF%9E%E6%8E%A5"><span class="toc-text">七、代码示例：在 Python 中使用 Paramiko 库进行 SSH 连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-13.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>