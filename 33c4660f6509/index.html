<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSH (Secure Shell) 协议详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SSH (Secure Shell) 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。  核心思想：通过在不可信网络上建立加密通道，保障客户端与服">
<meta property="og:type" content="article">
<meta property="og:title" content="SSH (Secure Shell) 协议详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/33c4660f6509/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="SSH (Secure Shell) 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。  核心思想：通过在不可信网络上建立加密通道，保障客户端与服">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg">
<meta property="article:published_time" content="2023-04-06T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-21T09:51:21.359Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSH (Secure Shell) 协议详解",
  "url": "https://blog.tbf1211.xx.kg/33c4660f6509/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg",
  "datePublished": "2023-04-06T22:24:00.000Z",
  "dateModified": "2026-01-21T09:51:21.359Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/33c4660f6509/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSH (Secure Shell) 协议详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">512</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-28.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">SSH (Secure Shell) 协议详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SSH (Secure Shell) 协议详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-04-06T22:24:00.000Z" title="发表于 2023-04-07 06:24:00">2023-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>SSH (Secure Shell)</strong> 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>通过在不可信网络上建立加密通道，保障客户端与服务器之间通信的机密性、完整性和认证性。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-SSH？"><a href="#一、为什么需要-SSH？" class="headerlink" title="一、为什么需要 SSH？"></a>一、为什么需要 SSH？</h2><p>在 SSH 出现之前，远程管理和文件传输主要依赖 Telnet、RSH (Remote Shell)、FTP (File Transfer Protocol) 等协议。这些协议存在严重的安全缺陷：</p>
<ul>
<li><strong>明文传输</strong>：用户名、密码和所有数据在网络中以明文形式传输，极易被窃听。</li>
<li><strong>缺乏认证</strong>：无法有效验证远程主机的身份，容易遭受中间人攻击 (Man-in-the-Middle, MITM)。</li>
</ul>
<p>SSH 的设计目标就是解决这些问题，提供一个安全的替代方案：</p>
<ul>
<li><strong>数据加密</strong>：所有传输数据（包括登录凭证和操作命令）都经过加密，防止窃听。</li>
<li><strong>强大的认证</strong>：不仅能够验证用户身份，还能验证远程主机的身份，防止欺骗。</li>
<li><strong>通信完整性</strong>：确保数据在传输过程中不被篡改。</li>
<li><strong>多种功能集成</strong>：除了远程命令行操作，还支持安全文件传输 (SCP, SFTP) 和端口转发。</li>
</ul>
<p>SSH 协议通常运行在 <strong>TCP 协议的 22 端口</strong>。</p>
<h2 id="二、SSH-协议概述与架构"><a href="#二、SSH-协议概述与架构" class="headerlink" title="二、SSH 协议概述与架构"></a>二、SSH 协议概述与架构</h2><p>SSH 协议是一个客户端-服务器架构，由客户端发起连接，服务器端负责响应和处理请求。SSH 协议栈可以分为三个主要层次：</p>
<ol>
<li><p><strong>传输层协议 (The Transport Layer Protocol)</strong>：</p>
<ul>
<li>提供服务器认证、数据机密性、数据完整性。</li>
<li>处理加密算法协商、密钥交换和数据加密解密。</li>
<li>通常使用 <strong>Diffie-Hellman 密钥交换算法</strong> 来协商对称加密密钥。</li>
<li>运行在 TCP 22 端口之上。</li>
</ul>
</li>
<li><p><strong>用户认证协议 (The User Authentication Protocol)</strong>：</p>
<ul>
<li>处理客户端用户向服务器的认证过程。</li>
<li>支持多种认证方法，最常见的是<strong>密码认证</strong>和<strong>公钥认证</strong>。</li>
</ul>
</li>
<li><p><strong>连接协议 (The Connection Protocol)</strong>：</p>
<ul>
<li>将加密后的传输通道复用为多个逻辑通道，例如：<ul>
<li><strong>Shell 会话</strong>：提供交互式命令行。</li>
<li><strong>端口转发</strong>：安全地转发 TCP 连接。</li>
<li><strong>X11 转发</strong>：安全地传输 X Window System 会话。</li>
<li><strong>文件传输</strong>：SCP (Secure Copy Protocol) 和 SFTP (SSH File Transfer Protocol)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="三、核心机制：加密与认证"><a href="#三、核心机制：加密与认证" class="headerlink" title="三、核心机制：加密与认证"></a>三、核心机制：加密与认证</h2><h3 id="3-1-加密机制"><a href="#3-1-加密机制" class="headerlink" title="3.1 加密机制"></a>3.1 加密机制</h3><p>SSH 使用多种加密技术来确保通信安全：</p>
<ol>
<li><p><strong>非对称加密 (Public-Key Cryptography)</strong>：</p>
<ul>
<li>主要用于<strong>密钥交换</strong>和<strong>服务器认证</strong>。</li>
<li>客户端和服务器在连接建立初期交换公钥，通过 Diffie-Hellman 算法协商出会话密钥。</li>
<li>服务器的公钥用于向客户端证明其身份（客户端会将其与本地 <code>known_hosts</code> 文件中的记录进行比对）。</li>
</ul>
</li>
<li><p><strong>对称加密 (Symmetric-Key Cryptography)</strong>：</p>
<ul>
<li>用于<strong>加密实际的数据传输</strong>。</li>
<li>在密钥交换阶段协商出的会话密钥只在当前连接中有效，连接结束后销毁。</li>
<li>常用算法：AES (Advanced Encryption Standard)、3DES 等。</li>
</ul>
</li>
<li><p><strong>哈希算法 (Hashing Algorithms)</strong>：</p>
<ul>
<li>用于<strong>数据完整性检查</strong>，防止数据在传输过程中被篡改。</li>
<li>常用算法：HMAC-SHA256、HMAC-MD5 等。</li>
</ul>
</li>
</ol>
<h3 id="3-2-认证机制"><a href="#3-2-认证机制" class="headerlink" title="3.2 认证机制"></a>3.2 认证机制</h3><p>SSH 提供两种主要的用户认证方式：</p>
<ol>
<li><p><strong>密码认证 (Password Authentication)</strong>：</p>
<ul>
<li>用户提供用户名和密码，服务器通过 <code>/etc/passwd</code> 或其他认证机制（如 PAM）进行验证。</li>
<li>虽然密码本身会加密传输，但在存在弱密码的情况下仍易受暴力破解攻击。</li>
</ul>
</li>
<li><p><strong>公钥认证 (Public Key Authentication)</strong>：</p>
<ul>
<li>更安全、推荐的认证方式，依赖于<strong>密钥对</strong>（公钥和私钥）。</li>
<li>用户在本地生成一对密钥：<strong>私钥 (Private Key)</strong> 保存在客户端，<strong>公钥 (Public Key)</strong> 上传到服务器的指定位置 (<code>~/.ssh/authorized_keys</code> 文件)。</li>
<li>认证流程：<ol>
<li>客户端向服务器发送连接请求，并声明使用公钥认证。</li>
<li>服务器根据客户端提供的用户名，在 <code>authorized_keys</code> 中查找对应的客户端公钥。</li>
<li>服务器生成一个随机字符串，并使用该公钥对其进行加密，然后发送给客户端。</li>
<li>客户端使用本地存储的私钥解密收到的字符串，并将解密后的结果重新发送给服务器。</li>
<li>服务器验证收到的解密结果是否与原始字符串一致。如果一致，则认证成功。</li>
</ol>
</li>
<li>私钥通常可以设置密码保护 (passphrase)，提供额外的安全层。</li>
</ul>
</li>
</ol>
<h2 id="四、SSH-连接过程详解"><a href="#四、SSH-连接过程详解" class="headerlink" title="四、SSH 连接过程详解"></a>四、SSH 连接过程详解</h2><p>一个典型的 SSH 连接过程如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as SSH 客户端
    participant Server as SSH 服务器

    Client-&gt;&gt;Server: 1. 建立 TCP 连接 (默认端口 22)
    Server-&gt;&gt;Client: 2. Server 发送协议版本字符串
    Client-&gt;&gt;Server: 3. Client 发送协议版本字符串
    Client-&gt;&gt;Server: 4. 协商加密算法和会话密钥 (Diffie-Hellman)
    Server-&gt;&gt;Client: 5. Server 发送自己的公钥 (Host Key)
    Client-&gt;&gt;Client: 6. 验证 Server 公钥 (检查 known_hosts)
    alt Server 公钥未经确认或不匹配
        Client-&gt;&gt;Client: 警告用户，可能存在 MITM 攻击
        Client--xServer: 连接中断 (或用户选择继续)
    end
    Client-&gt;&gt;Server: 7. 用户认证开始 (密码或公钥)
    alt 密码认证
        Client-&gt;&gt;Server: 发送用户名和加密后的密码
        Server-&gt;&gt;Server: 验证用户密码
    else 公钥认证
        Client-&gt;&gt;Server: 发送用户名和公钥认证请求
        Server-&gt;&gt;Server: (a) 查找用户 ~&#x2F;.ssh&#x2F;authorized_keys 中的公钥
        Server-&gt;&gt;Client: (b) 使用对应公钥加密一个随机字符串
        Client-&gt;&gt;Client: (c) 使用本地私钥解密字符串
        Client-&gt;&gt;Server: (d) 发送解密后的字符串
        Server-&gt;&gt;Server: (e) 验证字符串是否匹配
    end
    alt 认证成功
        Server--&gt;&gt;Client: 8. 认证成功
        Client-&gt;&gt;Server: 9. 请求开启一个 Shell 会话或端口转发等
        Server--&gt;&gt;Client: 10. 开启安全会话
    else 认证失败
        Server--xClient: 8. 认证失败，连接中断
    end
  </pre></div>

<h3 id="4-1-主机认证-known-hosts"><a href="#4-1-主机认证-known-hosts" class="headerlink" title="4.1 主机认证 (known_hosts)"></a>4.1 主机认证 (<code>known_hosts</code>)</h3><p>在客户端首次连接到一台新的 SSH 服务器时，服务器会将其公钥（Host Key）发送给客户端。客户端会将此公钥指纹与用户确认后存储在 <code>~/.ssh/known_hosts</code> 文件中。<br>下次连接时，客户端会检查服务器的 Host Key 是否与 <code>known_hosts</code> 中存储的记录匹配。如果 Host Key 发生变化，客户端会发出警告，提示可能存在中间人攻击。</p>
<h2 id="五、SSH-常用功能与命令"><a href="#五、SSH-常用功能与命令" class="headerlink" title="五、SSH 常用功能与命令"></a>五、SSH 常用功能与命令</h2><h3 id="5-1-远程登录"><a href="#5-1-远程登录" class="headerlink" title="5.1 远程登录"></a>5.1 远程登录</h3><p>最基本的用途是远程登录到服务器执行命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录到 example.com 服务器，使用当前用户名</span></span><br><span class="line">ssh example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录到 example.com 服务器，使用用户名为 &quot;admin&quot;</span></span><br><span class="line">ssh admin@example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录后直接执行命令，然后退出</span></span><br><span class="line">ssh admin@example.com <span class="string">&quot;ls -l /var/log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定端口登录 (如果SSH服务器不在默认的22端口)</span></span><br><span class="line">ssh -p 2222 admin@example.com</span><br></pre></td></tr></table></figure>

<h3 id="5-2-文件传输-SCP-SFTP"><a href="#5-2-文件传输-SCP-SFTP" class="headerlink" title="5.2 文件传输 (SCP &#x2F; SFTP)"></a>5.2 文件传输 (SCP &#x2F; SFTP)</h3><ol>
<li><p><strong>SCP (Secure Copy Protocol)</strong>：用于在本地和远程主机之间复制文件或目录。</p>
<ul>
<li><strong>从本地复制到远程：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /path/to/local/file user@remote_host:/path/to/remote/directory</span><br><span class="line">scp -r /path/to/local/dir user@remote_host:/path/to/remote/directory <span class="comment"># -r 递归复制目录</span></span><br></pre></td></tr></table></figure></li>
<li><strong>从远程复制到本地：</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user@remote_host:/path/to/remote/file /path/to/local/directory</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>SFTP (SSH File Transfer Protocol)</strong>：提供更交互式的文件传输体验，类似于 FTP，但基于 SSH。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sftp user@remote_host</span><br><span class="line"><span class="comment"># 进入SFTP shell后可以使用 ls, cd, get, put 等命令</span></span><br><span class="line">sftp&gt; <span class="built_in">ls</span></span><br><span class="line">sftp&gt; get remote_file.txt</span><br><span class="line">sftp&gt; put local_file.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-3-端口转发-Port-Forwarding-Tunneling"><a href="#5-3-端口转发-Port-Forwarding-Tunneling" class="headerlink" title="5.3 端口转发 (Port Forwarding &#x2F; Tunneling)"></a>5.3 端口转发 (Port Forwarding &#x2F; Tunneling)</h3><p>SSH 端口转发允许通过加密的 SSH 信道转发网络端口，从而安全地访问内部网络资源或绕过防火墙。</p>
<ol>
<li><p><strong>本地端口转发 (Local Port Forwarding, <code>-L</code>)</strong>：<br>将<strong>本地机器</strong>的一个端口的数据转发到<strong>远程机器</strong>的某个端口。<br>场景：访问位于远程内网的服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L [local_port]:[destination_host]:[destination_port] [user@]ssh_server</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong> 将本地 <code>8080</code> 端口的流量转发到 <code>ssh_server</code> 机器上的 <code>internal_db_server</code> 的 <code>3306</code> 端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 8080:internal_db_server:3306 user@ssh_server</span><br><span class="line"><span class="comment"># 此时，访问本地 localhost:8080 就像访问 internal_db_server:3306 一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>远程端口转发 (Remote Port Forwarding, <code>-R</code>)</strong>：<br>将<strong>远程机器</strong>的一个端口的数据转发到<strong>本地机器</strong>的某个端口。<br>场景：让外部网络通过 SSH 服务器访问本地内网的服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R [remote_port]:[destination_host]:[destination_port] [user@]ssh_server</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong> 将 <code>ssh_server</code> 机器的 <code>80</code> 端口的流量转发到本地机器的 <code>localhost:80</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 80:localhost:80 user@ssh_server</span><br><span class="line"><span class="comment"># 此时，ssh_server 上的用户访问 ssh_server:80 就像访问本地机器的 localhost:80 一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态端口转发 (Dynamic Port Forwarding, <code>-D</code>)</strong>：<br>将本地机器变为一个 SOCKS 代理服务器。所有通过这个 SOCKS 代理的流量都会通过 SSH 连接进行转发。<br>场景：构建一个安全的 SOCKS 代理，用于浏览网页或访问任意服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D [local_port] [user@]ssh_server</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong> 在本地 <code>1080</code> 端口创建一个 SOCKS 代理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 1080 user@ssh_server</span><br><span class="line"><span class="comment"># 配置浏览器或应用程序使用 localhost:1080 作为 SOCKS 代理</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-4-SSH-配置-ssh-config"><a href="#5-4-SSH-配置-ssh-config" class="headerlink" title="5.4 SSH 配置 (~/.ssh/config)"></a>5.4 SSH 配置 (<code>~/.ssh/config</code>)</h3><p>使用 <code>~/.ssh/config</code> 文件可以为不同的主机定义个性化的 SSH 连接参数，简化命令输入，提高效率。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.ssh/config 示例</span></span><br><span class="line">Host myserver</span><br><span class="line">    HostName example.com</span><br><span class="line">    User admin</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_myserver</span><br><span class="line">    ForwardAgent yes</span><br><span class="line">    LocalForward 8080 internal_service.local:80</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">    ServerAliveInterval 60</span><br><span class="line">    ServerAliveCountMax 3</span><br></pre></td></tr></table></figure>

<h3 id="5-5-SSH-代理-ssh-agent-ssh-add"><a href="#5-5-SSH-代理-ssh-agent-ssh-add" class="headerlink" title="5.5 SSH 代理 (ssh-agent, ssh-add)"></a>5.5 SSH 代理 (<code>ssh-agent</code>, <code>ssh-add</code>)</h3><p><code>ssh-agent</code> 是一个在后台运行的程序，它保存私钥，无需在每次使用私钥时都输入密码。<br><code>ssh-add</code> 用于将私钥添加到 <code>ssh-agent</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span> <span class="comment"># 启动 ssh-agent</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa  <span class="comment"># 将私钥添加到 agent</span></span><br><span class="line"><span class="comment"># 此时，只需输入一次私钥密码，后续使用该私钥的 SSH 连接将不再需要密码</span></span><br></pre></td></tr></table></figure>

<h2 id="六、安全性考虑与最佳实践"><a href="#六、安全性考虑与最佳实践" class="headerlink" title="六、安全性考虑与最佳实践"></a>六、安全性考虑与最佳实践</h2><ol>
<li><strong>禁用密码认证 (Password Authentication)</strong>：如果可能，禁用服务器上的密码认证，只允许公钥认证。<ul>
<li>在 <code>/etc/ssh/sshd_config</code> 中设置 <code>PasswordAuthentication no</code>。</li>
</ul>
</li>
<li><strong>使用强密码保护私钥</strong>：为私钥设置一个复杂且独特的密码 (passphrase)。</li>
<li><strong>保护私钥文件</strong>：私钥文件权限必须严格控制 (<code>chmod 400 ~/.ssh/id_rsa</code>)，确保只有所有者可读。绝不共享私钥。</li>
<li><strong>禁用 Root 用户直接登录</strong>：通过普通用户登录，再使用 <code>sudo</code> 提权。<ul>
<li>在 <code>/etc/ssh/sshd_config</code> 中设置 <code>PermitRootLogin no</code>。</li>
</ul>
</li>
<li><strong>修改默认 SSH 端口</strong>：将 SSH 端口从默认的 22 更改为其他非常用端口，可以减少针对 22 端口的扫描和自动化攻击。<ul>
<li>在 <code>/etc/ssh/sshd_config</code> 中设置 <code>Port [新端口号]</code>。</li>
</ul>
</li>
<li><strong>限制 SSH 访问 IP</strong>：通过防火墙 (<code>ufw</code>, <code>firewalld</code>) 或 <code>sshd_config</code> 中的 <code>AllowUsers</code>, <code>AllowGroups</code>, <code>AllowIPs</code> 等指令限制可访问 SSH 的源 IP 地址。</li>
<li><strong>定期更新系统和 SSH 版本</strong>：及时安装安全补丁，以防止已知漏洞被利用。</li>
<li><strong>启用两步认证 (Two-Factor Authentication, 2FA)</strong>：结合 Google Authenticator 等工具，为 SSH 登录增加一层安全保护。</li>
<li><strong>使用 SSH Agent Forwarding</strong>：当需要从一台跳板机连接到内网其他服务器时，可以通过 Agent Forwarding 安全地使用本地私钥进行认证，避免将私钥复制到跳板机。在 <code>~/.ssh/config</code> 中设置 <code>ForwardAgent yes</code>。</li>
<li><strong>限制 <code>authorized_keys</code> 文件的权限</strong>：<code>~/.ssh</code> 目录权限应为 <code>700</code>，<code>authorized_keys</code> 文件权限应为 <code>600</code>。</li>
</ol>
<h2 id="七、代码示例：在-Python-中使用-Paramiko-库进行-SSH-连接"><a href="#七、代码示例：在-Python-中使用-Paramiko-库进行-SSH-连接" class="headerlink" title="七、代码示例：在 Python 中使用 Paramiko 库进行 SSH 连接"></a>七、代码示例：在 Python 中使用 Paramiko 库进行 SSH 连接</h2><p><code>Paramiko</code> 是一个 Python 实现的 SSHv2 协议库，可以用于客户端和服务器端 SSH 功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh_command_execution</span>(<span class="params">hostname, username, private_key_path, command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通过 SSH 连接到远程主机并执行命令。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        hostname (str): 远程主机名或IP地址。</span></span><br><span class="line"><span class="string">        username (str): 登录用户名。</span></span><br><span class="line"><span class="string">        private_key_path (str): 私钥文件的路径。</span></span><br><span class="line"><span class="string">        command (str): 要执行的命令。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建一个SSH客户端实例</span></span><br><span class="line">        client = paramiko.SSHClient()</span><br><span class="line">        <span class="comment"># 自动添加新主机的指纹（注意：在生产环境中应手动验证指纹）</span></span><br><span class="line">        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载私钥</span></span><br><span class="line">        private_key = paramiko.RSAKey.from_private_key_file(private_key_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接到远程主机</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connecting to <span class="subst">&#123;username&#125;</span>@<span class="subst">&#123;hostname&#125;</span> using key: <span class="subst">&#123;private_key_path&#125;</span>...&quot;</span>)</span><br><span class="line">        client.connect(hostname=hostname, username=username, pkey=private_key)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection successful.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行命令</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Executing command: &#x27;<span class="subst">&#123;command&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        stdin, stdout, stderr = client.exec_command(command)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印命令输出</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n--- STDOUT ---&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> stdout:</span><br><span class="line">            <span class="built_in">print</span>(line.strip())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n--- STDERR ---&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> stderr:</span><br><span class="line">            <span class="built_in">print</span>(line.strip())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取退出码</span></span><br><span class="line">        exit_code = stdout.channel.recv_exit_status()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\nCommand exited with code: <span class="subst">&#123;exit_code&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> paramiko.AuthenticationException:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Authentication failed. Check your username, password, or private key.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> paramiko.SSHException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SSH error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> client:</span><br><span class="line">            client.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;SSH connection closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    REMOTE_HOST = <span class="string">&quot;your_server_ip_or_hostname&quot;</span> <span class="comment"># 替换为你的服务器IP或主机名</span></span><br><span class="line">    REMOTE_USER = <span class="string">&quot;your_username&quot;</span>             <span class="comment"># 替换为你的用户名</span></span><br><span class="line">    PRIVATE_KEY = os.path.expanduser(<span class="string">&quot;~/.ssh/id_rsa&quot;</span>) <span class="comment"># 替换为你的私钥路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请确保你的私钥文件存在且权限正确 (chmod 400 ~/.ssh/id_rsa)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(PRIVATE_KEY):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: Private key file not found at <span class="subst">&#123;PRIVATE_KEY&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Please generate an SSH key pair or specify the correct path.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 测试执行一个简单命令</span></span><br><span class="line">        ssh_command_execution(REMOTE_HOST, REMOTE_USER, PRIVATE_KEY, <span class="string">&quot;hostname &amp;&amp; uptime&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 测试执行另一个命令</span></span><br><span class="line">        <span class="comment"># ssh_command_execution(REMOTE_HOST, REMOTE_USER, PRIVATE_KEY, &quot;ls -l /tmp&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>SSH 协议是现代远程管理和网络安全基石。它通过强大的加密和认证机制，为在不安全网络上传输敏感数据和执行远程操作提供了可靠的保障。理解 SSH 的工作原理、其多样的功能（远程登录、文件传输、端口转发）以及实施安全最佳实践，对于任何系统管理员或开发者都是至关重要的。正确配置和使用 SSH 不仅能提高工作效率，更能大幅提升系统安全性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/33c4660f6509/">https://blog.tbf1211.xx.kg/33c4660f6509/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/59d0e10ae2fa/" title="HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私</div></div><div class="info-2"><div class="info-item-1"> HTTPS (Hypertext Transfer Protocol Secure)，即超文本传输安全协议，是在 HTTP 协议的基础上，通过添加 SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security) 协议层来提供安全性的网络协议。它确保了客户端（通常是浏览器）和服务器之间的数据传输加密、完整且经过认证，从而保护用户的隐私和数据的安全。  核心思想：在不安全的互联网上，为 HTTP 通信提供加密、身份认证和数据完整性保护，使得网站能够安全可靠地传输信息。   一、为什么需要 HTTPS？传统的 HTTP 协议是一种明文传输协议，其数据的传输是透明的，没有任何加密。这导致了多重重要的安全隐患：  数据窃听 (Eavesdropping &#x2F; Sniffing)：  任何网络中间节点（如 Wi-Fi 热点、路由器、ISP）都可以截获并读取用户与网站之间传输的所有数据，包括敏感信息如用户名、密码、银行卡号、邮件内容等。 例如，您在一个非 HTTPS 网站登录，您的用户名和密码在网络中就是明文传输，攻...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/c5be75f3ed25/" title="WebSocket 详解：实现全双工实时通信"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="info-item-2">WebSocket 详解：实现全双工实时通信</div></div><div class="info-2"><div class="info-item-1"> WebSocket 是一种在单个 TCP 连接上进行全双工（Full-Duplex）通信的网络协议。它在 Web 浏览器和服务器之间提供了一个持久化的连接，允许双方在任何时候发送消息，而无需像传统的 HTTP 请求那样需要先发送请求再接收响应。WebSocket 解决了传统 Web 应用中实现实时通信的诸多难题，是构建实时 Web 应用的关键技术之一。  核心思想：从 HTTP 协议“握手”后，将底层 TCP 连接“升级”为 WebSocket 连接，实现客户端与服务器之间长时间、双向、无阻塞的消息传输，从而大幅降低通信开销，提升实时应用的性能。   一、为什么需要 WebSocket？传统 HTTP 的局限性在 WebSocket 出现之前，Web 应用程序要实现实时通信，如聊天室、股票行情、在线游戏、推送通知等，面临着传统 HTTP 协议的固有局限性：  半双工 (Half-Duplex) 通信：HTTP 协议是单向请求-响应模型。客户端发送请求，服务器返回响应。服务器无法主动向客户端发送消息，除非客户端先发起请求。 效率低下： 频繁连接建立与断开：每个 HTTP 请求都需...</div></div></div></a><a class="pagination-related" href="/5d5f7c78ff8d/" title="五层因特网协议栈深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-14</div><div class="info-item-2">五层因特网协议栈深度详解</div></div><div class="info-2"><div class="info-item-1"> 五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。  核心思想：将互联网的通信过程划分为五个逻辑层级，自顶向下依次为应用层、传输层、网络层、数据链路层和物理层，每层负责不同的通信职责，协同工作以实现全球互联。   一、为什么选择五层协议栈？尽管 OSI 七层模型提供了非常详细的理论分层，但由于其设计时在标准制定上花费了大量时间，并且部分层次划分在实际实现中显得过于细致，导致其未能大规模落地。相反，TCP&#x2F;IP 协议族在互联网的早期发展中迅速崛起并成为事实标准。五层协议栈结合了二者的优点：  实用性：它直接反映了 TCP&#x2F;IP 协议族栈的工作方式，是互联网实际运行的写照。 简洁性：相比 OSI 七层模型，它将 OSI 的...</div></div></div></a><a class="pagination-related" href="/22aa4c322dbd/" title="TLS (传输层安全协议) 深度详解：网络通信的守护者"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="info-item-2">TLS (传输层安全协议) 深度详解：网络通信的守护者</div></div><div class="info-2"><div class="info-item-1"> TLS (Transport Layer Security)，即传输层安全性协议，是用于在计算机网络上提供端到端安全通信的加密协议。它是 SSL (Secure Sockets Layer) 协议的继任者，两者常被混用，但技术上，现代网络浏览器及服务器都已使用 TLS 协议。TLS 主要提供数据隐私、数据完整性以及通信双方的身份认证，是互联网上最广泛使用的安全协议，例如 HTTPS (HTTP over TLS)、SMTPS、LDAPS 等都依赖于 TLS。  核心思想：在不可信的网络上，通过加密、认证和完整性校验，建立一个可信的加密通信通道。   一、为什么需要 TLS？互联网的早期（例如纯 HTTP 时代），数据在传输过程中是明文的。这意味着：  窃听 (Eavesdropping)：任何中间人（如 ISP、路由器管理员、恶意攻击者）都可以截获并读取传输中的数据，包括用户密码、银行卡信息、私人消息等。 篡改 (Tampering)：中间人不仅可以读取数据，还可以修改数据，例如在网页中植入恶意代码，或者更改用户提交的表单内容。 身份伪装 (Impersonation)：客户端...</div></div></div></a><a class="pagination-related" href="/8fad93ea4f62/" title="ALPN (Application-Layer Protocol Negotiation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="info-item-2">ALPN (Application-Layer Protocol Negotiation) 详解</div></div><div class="info-2"><div class="info-item-1"> ALPN (Application-Layer Protocol Negotiation)，即应用层协议协商，是 TLS (传输层安全) 协议的一个扩展，允许客户端和服务器在进行 TLS 握手时，协商决定在加密连接上使用哪个应用层协议。它在 RFC 7301 中被定义。ALPN 的出现，极大地简化了现代网络协议的部署和使用，尤其是对于 HTTP&#x2F;2 和未来的 QUIC 等协议。  核心思想：ALPN 将应用层协议的选择过程集成到 TLS 握手阶段，使得在建立加密连接的同时，也完成了应用层协议的确定，避免了额外的往返延迟，并允许在同一端口上运行多种应用层协议。   一、为什么需要 ALPN？在 ALPN 出现之前，协商应用层协议通常面临以下挑战：  端口绑定：传统的做法是为不同的应用层协议使用不同的端口。例如，HTTP 使用 80 端口，HTTPS 使用 443 端口，FTP 使用 21 端口。当引入新的协议（如 HTTP&#x2F;2 或 SPDY）时，如果想与现有协议共存，就必须使用新的端口，这会增加防火墙配置、负载均衡设置的复杂性，并且用户可能需要记住非标准的端口...</div></div></div></a><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a><a class="pagination-related" href="/65edca489ee4/" title="DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="info-item-2">DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS over TLS (DoT) 和 DNS over HTTPS (DoH) 是旨在增强 DNS (Domain Name System) 查询和响应隐私性 (Privacy) 与安全性 (Security) 的两种协议。它们通过对 DNS 流量进行加密，防止网络中间方（如 ISP、政府机构或恶意攻击者）窥探用户的域名解析请求或篡改 DNS 响应，从而解决了传统 DNS 协议固有的安全和隐私缺陷。  核心思想：将明文传输的 DNS 查询封装到加密的传输层安全 (TLS) 或超文本传输安全 (HTTPS) 连接中，以保护用户隐私、防止 DNS 劫持和对抗网络审查。   一、传统 DNS 的隐私与安全痛点传统的 DNS 协议通常通过 UDP (User Datagram Protocol) 或 TCP (Transmission Control Protocol) 的 53 号端口进行通信。这种通信方式存在以下固有的安全和隐私缺陷：  明文传输 (Plaintext Transmission)：DNS 查询和响应在网络上以明文形式传输。  隐私泄露：任何能够嗅探网络流量的中间...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">512</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-SSH%EF%BC%9F"><span class="toc-text">一、为什么需要 SSH？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SSH-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%9E%B6%E6%9E%84"><span class="toc-text">二、SSH 协议概述与架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81"><span class="toc-text">三、核心机制：加密与认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6"><span class="toc-text">3.1 加密机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-text">3.2 认证机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SSH-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">四、SSH 连接过程详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%BB%E6%9C%BA%E8%AE%A4%E8%AF%81-known-hosts"><span class="toc-text">4.1 主机认证 (known_hosts)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81SSH-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%91%BD%E4%BB%A4"><span class="toc-text">五、SSH 常用功能与命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95"><span class="toc-text">5.1 远程登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93-SCP-SFTP"><span class="toc-text">5.2 文件传输 (SCP &#x2F; SFTP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91-Port-Forwarding-Tunneling"><span class="toc-text">5.3 端口转发 (Port Forwarding &#x2F; Tunneling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-SSH-%E9%85%8D%E7%BD%AE-ssh-config"><span class="toc-text">5.4 SSH 配置 (~&#x2F;.ssh&#x2F;config)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-SSH-%E4%BB%A3%E7%90%86-ssh-agent-ssh-add"><span class="toc-text">5.5 SSH 代理 (ssh-agent, ssh-add)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">六、安全性考虑与最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9C%A8-Python-%E4%B8%AD%E4%BD%BF%E7%94%A8-Paramiko-%E5%BA%93%E8%BF%9B%E8%A1%8C-SSH-%E8%BF%9E%E6%8E%A5"><span class="toc-text">七、代码示例：在 Python 中使用 Paramiko 库进行 SSH 连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-28.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>