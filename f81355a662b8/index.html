<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ECMAScript ShadowRealm 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ShadowRealm 是一个 ECMAScript 提案（目前处于 Stage 3 阶段），旨在为 JavaScript 提供一种新的代码隔离机制。它允许在当前 Realm 中创建一个与主 Realm 具有分离的全局对象 (global object) 和 内置对象 (intrinsic objects) 集合的“影子 Realm”。通过 ShadowRealm，开发者可以在一个安全的、受控的">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript ShadowRealm 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/f81355a662b8/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="ShadowRealm 是一个 ECMAScript 提案（目前处于 Stage 3 阶段），旨在为 JavaScript 提供一种新的代码隔离机制。它允许在当前 Realm 中创建一个与主 Realm 具有分离的全局对象 (global object) 和 内置对象 (intrinsic objects) 集合的“影子 Realm”。通过 ShadowRealm，开发者可以在一个安全的、受控的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg">
<meta property="article:published_time" content="2026-02-01T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-06T09:33:58.511Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Web技术">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ECMAScript ShadowRealm 详解",
  "url": "https://blog.tbf1211.xx.kg/f81355a662b8/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg",
  "datePublished": "2026-02-01T22:24:00.000Z",
  "dateModified": "2026-02-06T09:33:58.511Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/f81355a662b8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ECMAScript ShadowRealm 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">546</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">ECMAScript ShadowRealm 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ECMAScript ShadowRealm 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/Web%E6%8A%80%E6%9C%AF/">Web技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>ShadowRealm</strong> 是一个 ECMAScript 提案（目前处于 Stage 3 阶段），旨在为 JavaScript 提供一种<strong>新的代码隔离机制</strong>。它允许在当前 Realm 中创建一个与主 Realm 具有分离的全局对象 (global object) 和 内置对象 (intrinsic objects) 集合的“影子 Realm”。通过 ShadowRealm，开发者可以在一个安全的、受控的环境中执行不受信任的代码或隔离不同的应用程序组件，提供类似于 iframe 但在 JS 层面更细粒度的沙箱能力。</p>
</blockquote>
<div class="note info flat"><p>核心思想：ShadowRealm 创建了一个<strong>轻量级的 JavaScript 执行环境沙箱</strong>。它提供了一套独立的全局对象和内置对象，但共享相同的事件循环 (event loop) 和微任务队列 (microtask queue)。这种隔离有助于提高代码安全性、隔离第三方库、避免全局污染，并为模块化和可插拔架构提供更强大的支持。</p>
</div>
<hr>
<h2 id="一、为什么需要-ShadowRealm？"><a href="#一、为什么需要-ShadowRealm？" class="headerlink" title="一、为什么需要 ShadowRealm？"></a>一、为什么需要 ShadowRealm？</h2><p>在 JavaScript 生态系统中，代码隔离一直是一个重要的需求，尤其是在以下场景中：</p>
<ol>
<li><p><strong>运行不受信任的代码 (Sandboxing Untrusted Code)</strong>：</p>
<ul>
<li>例如，用户自定义脚本、插件代码或者从未知来源获取的代码。</li>
<li><code>eval()</code> 虽然可以执行代码，但它在当前 Realm 中执行，容易造成全局污染和安全漏洞。</li>
<li><code>Web Workers</code> 提供了进程级别的隔离，但它们有独立的全局对象、独立的事件循环，并不能直接访问主线程的 DOM，且通信开销较大。</li>
<li><code>iframe</code> 提供了强大的隔离能力，包括 DOM 和 JS 环境，但其创建和通信开销更大，且访问 DOM 仍然是一个安全挑战。</li>
</ul>
</li>
<li><p><strong>避免全局污染</strong>：</p>
<ul>
<li>许多第三方库和框架可能会在全局对象上添加属性或修改内置对象，从而引发冲突（例如，两个库定义了同名的全局变量或修改了原型的行为）。</li>
<li>ShadowRealm 可以为每个库提供一个独立的全局环境，防止它们相互影响。</li>
</ul>
</li>
<li><p><strong>模块化和插件系统</strong>：</p>
<ul>
<li>在构建大型应用或插件系统时，需要确保每个模块或插件都在独立的环境中运行，防止意外的副作用。</li>
<li>这有助于实现更健壮和可维护的架构。</li>
</ul>
</li>
<li><p><strong>服务器端渲染 (SSR) 和同构应用</strong>：</p>
<ul>
<li>在 Node.js 环境下，可能需要在一个请求的生命周期内解析和执行多个前端组件的代码，同时确保每个组件的执行环境都是干净且独立的。</li>
</ul>
</li>
</ol>
<p>当前的解决方案（如 <code>eval()</code>、<code>Web Workers</code>、<code>iframe</code>）各有优缺点，而 ShadowRealm 旨在提供一个更轻量、更灵活、更 JavaScript 原生的沙箱机制。</p>
<h2 id="二、ShadowRealm-的核心概念与特性"><a href="#二、ShadowRealm-的核心概念与特性" class="headerlink" title="二、ShadowRealm 的核心概念与特性"></a>二、ShadowRealm 的核心概念与特性</h2><h3 id="2-1-Realm-领域"><a href="#2-1-Realm-领域" class="headerlink" title="2.1 Realm (领域)"></a>2.1 Realm (领域)</h3><p>在 ECMAScript 规范中，“Realm” 是一个核心概念。它表示一个独立的 JavaScript 执行环境，包含：</p>
<ul>
<li>一个<strong>全局对象 (Global Object)</strong>，例如在浏览器中是 <code>window</code> 或 <code>self</code>，在 Node.js 中是 <code>global</code>。</li>
<li>一套<strong>全局环境绑定 (Global Environment Bindings)</strong>，包括全局变量、函数和声明。</li>
<li>一套<strong>内置对象 (Intrinsic Objects)</strong> 集合，例如 <code>Object</code>, <code>Array</code>, <code>Function</code>, <code>Promise</code> 等以及它们的 <code>prototype</code>。</li>
<li><strong>私有 Symbol 注册表 (Symbol Registry)</strong>。</li>
</ul>
<p>每个 Realm 都有自己独立的全局状态，这意味着在一个 Realm 中对 <code>Object.prototype</code> 进行修改不会影响到另一个 Realm 中的 <code>Object.prototype</code>。<code>iframe</code> 和 <code>Web Workers</code> 都会创建新的 Realm。</p>
<h3 id="2-2-ShadowRealm-的特点"><a href="#2-2-ShadowRealm-的特点" class="headerlink" title="2.2 ShadowRealm 的特点"></a>2.2 ShadowRealm 的特点</h3><p>ShadowRealm 提案提供了一个新的内置类 <code>ShadowRealm</code>，其实例代表一个新的 Realm。</p>
<ol>
<li><p><strong>独立的全局对象和内置对象</strong>：</p>
<ul>
<li>每个 <code>ShadowRealm</code> 实例都拥有自己独立的全局对象（类似于 <code>window</code> 或 <code>global</code>）和一套独立的内置对象（如 <code>Object</code>、<code>Array</code>、<code>Function</code> 等及其原型）。</li>
<li>这意味着在 ShadowRealm 中对全局对象或内置对象原型所做的修改，不会影响到创建它的主 Realm。例如，<code>shadowRealm.evaluate(&#39;Object.prototype.foo = 1;&#39;)</code> 不会影响主 Realm 的 <code>Object.prototype</code>。</li>
</ul>
</li>
<li><p><strong>共享事件循环和微任务队列</strong>：</p>
<ul>
<li>虽然 ShadowRealm 有独立的全局环境，但它与创建它的主 Realm <strong>共享同一个事件循环 (Event Loop)</strong> 和 <strong>微任务队列 (Microtask Queue)</strong>。</li>
<li>这意味着 ShadowRealm 中的异步操作（如 <code>Promise</code>、<code>setTimeout</code>）会与主 Realm 的异步操作交错执行，它们的任务和回调会进入同一个队列。</li>
</ul>
</li>
<li><p><strong>通信通过函数调用</strong>：</p>
<ul>
<li><strong>Proxy-based 机制</strong>：ShadowRealm 不允许直接访问其内部的 JavaScript 值（对象、函数、类等），也无法直接从其内部访问外部 Realm 的值。</li>
<li>所有的通信都必须通过“导入” (importValue) 和“导出” (exportValue) 函数来完成。这些函数<strong>只能传递原始值</strong> (primitives) 和 <strong>Callable Objects</strong> (函数、方法、被 <code>Proxy</code> 包裹的函数)。</li>
<li>当一个函数从一个 Realm 传递到另一个 Realm 时，它会以 <strong>Callable Proxy</strong> 的形式呈现。这个 Proxy 在目标 Realm 中被调用时，会转发调用回原始 Realm 中的实际函数。</li>
<li>这种机制确保了隔离性，防止一个 Realm 的代码直接操纵另一个 Realm 的内部状态。</li>
</ul>
</li>
<li><p><strong>动态模块导入</strong>：</p>
<ul>
<li>ShadowRealm 支持动态模块导入 (<code>import()</code>)，这意味着可以在 ShadowRealm 中加载和执行 ESM 模块。</li>
</ul>
</li>
</ol>
<h2 id="三、ShadowRealm-API-概览"><a href="#三、ShadowRealm-API-概览" class="headerlink" title="三、ShadowRealm API 概览"></a>三、ShadowRealm API 概览</h2><p><code>ShadowRealm</code> 类是核心，它提供了以下主要方法：</p>
<ol>
<li><p><code>new ShadowRealm()</code>：</p>
<ul>
<li>创建一个新的 ShadowRealm 实例。</li>
</ul>
</li>
<li><p><code>shadowRealm.evaluate(sourceText)</code>：</p>
<ul>
<li>在 ShadowRealm 中执行一段 JavaScript 字符串 <code>sourceText</code>。</li>
<li><code>sourceText</code> 必须是有效且可解析的 JavaScript 代码。</li>
<li>返回一个 <code>Promise</code>，resolved 的值是 <code>sourceText</code> 执行的返回值（如果是非原始值，会被包装成 Callable Proxy）。</li>
</ul>
</li>
<li><p><code>shadowRealm.importValue(specifier, bindingName)</code>：</p>
<ul>
<li>在 ShadowRealm 中导入一个指定模块 (<code>specifier</code>) 的特定导出 <code>bindingName</code>。</li>
<li><code>specifier</code> 是模块的路径字符串。</li>
<li><code>bindingName</code> 是模块导出的名称字符串。</li>
<li>返回一个 <code>Promise</code>，resolved 的值是导入的模块绑定。如果导入的是函数，则会是一个 Callable Proxy。</li>
</ul>
</li>
<li><p><code>shadowRealm.spawn(callback)</code> (提案早期，已废弃或修改):</p>
<ul>
<li>早期提案提供的函数，用于在 ShadowRealm 中执行一个回调函数。该方法在后续版本中已被 <code>evaluate</code> 和 <code>importValue</code> 取代或重构，更强调清晰的通信模型。</li>
</ul>
</li>
</ol>
<h3 id="示例：基本使用"><a href="#示例：基本使用" class="headerlink" title="示例：基本使用"></a>示例：基本使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主 Realm (Outer Realm)</span></span><br><span class="line"><span class="keyword">const</span> realm = <span class="keyword">new</span> <span class="title class_">ShadowRealm</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 在 ShadowRealm 中执行代码</span></span><br><span class="line"><span class="keyword">let</span> resultPromise1 = realm.<span class="title function_">evaluate</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  // ShadowRealm 内的全局对象和内置对象是独立的</span></span><br><span class="line"><span class="string">  const message = &#x27;Hello from ShadowRealm!&#x27;;</span></span><br><span class="line"><span class="string">  Object.prototype.shadowProp = &#x27;shadow&#x27;; // 污染 ShadowRealm 的 Object.prototype</span></span><br><span class="line"><span class="string">  message + &#x27; &#x27; + (typeof window); // 在 Node.js 环境下 typeof window 会是 &quot;undefined&quot;，这里仅为示意</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line">resultPromise1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Evaluate result:&#x27;</span>, value); <span class="comment">// Output: Evaluate result: Hello from ShadowRealm! undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证主 Realm 的 Object.prototype 未被污染</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Main Realm Object.prototype.shadowProp:&#x27;</span>, <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shadowProp</span>); <span class="comment">// Output: Main Realm Object.prototype.shadowProp: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过函数进行通信</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">outerFunction</span> = (<span class="params">arg</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Outer function called with:&#x27;</span>, arg);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Response from Outer&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将外部函数传递到 ShadowRealm</span></span><br><span class="line"><span class="comment">// outerFunction 会在 ShadowRealm 中成为一个 Callable Proxy</span></span><br><span class="line">realm.<span class="title function_">evaluate</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  const proxiedOuterFunction = arguments[0]; // evaluate 的参数可以是 ArgumentList</span></span><br><span class="line"><span class="string">  console.log(&#x27;Proxied outer function type:&#x27;, typeof proxiedOuterFunction); // Output: function</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  proxiedOuterFunction(&#x27;Message from ShadowRealm&#x27;).then(res =&gt; &#123;</span></span><br><span class="line"><span class="string">    console.log(&#x27;Received response from Outer:&#x27;, res); // Output: Received response from Outer: Response from Outer</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">`</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// &#x27;arguments&#x27; 接收 evaluate 的额外参数</span></span><br><span class="line">  <span class="comment">// 注意：arguments[0] 是一个实际的参数数组，外层会将函数作为第一个元素传递</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Evaluation error:&quot;</span>, err);</span><br><span class="line">&#125;, [outerFunction]); <span class="comment">// 这里将 outerFunction 作为参数传递给 evaluate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 导入和导出模块</span></span><br><span class="line"><span class="comment">// 假设有一个名为 &#x27;my-module.js&#x27; 的文件在 ShadowRealm 的加载器可见路径中</span></span><br><span class="line"><span class="comment">// my-module.js</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  export function greet(name) &#123;</span></span><br><span class="line"><span class="comment">    return `Hello, $&#123;name&#125; from module in ShadowRealm!`;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  export const answer = 42;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主 Realm 中导入 ShadowRealm 内部模块的导出</span></span><br><span class="line">realm.<span class="title function_">importValue</span>(<span class="string">&#x27;./my-module.js&#x27;</span>, <span class="string">&#x27;greet&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">shadowGreet</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Type of shadowGreet:&#x27;</span>, <span class="keyword">typeof</span> shadowGreet); <span class="comment">// Output: Type of shadowGreet: function (Callable Proxy)</span></span><br><span class="line">  <span class="title function_">shadowGreet</span>(<span class="string">&#x27;World&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">greeting</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Imported greet function result:&#x27;</span>, greeting); <span class="comment">// Output: Imported greet function result: Hello, World from module in ShadowRealm!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">realm.<span class="title function_">importValue</span>(<span class="string">&#x27;./my-module.js&#x27;</span>, <span class="string">&#x27;answer&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">shadowAnswer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Imported answer:&#x27;</span>, shadowAnswer); <span class="comment">// Output: Imported answer: 42 (原始值直接传递)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. (可选) 从 ShadowRealm 导出函数 (需要 ShadowRealm 内的代码主动导出)</span></span><br><span class="line"><span class="comment">// 例如，在 ShadowRealm 内部可以这样定义并暴露函数:</span></span><br><span class="line">realm.<span class="title function_">evaluate</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  export function runInShadowRealm(data) &#123;</span></span><br><span class="line"><span class="string">    console.log(&#x27;Running in ShadowRealm with data:&#x27;, data);</span></span><br><span class="line"><span class="string">    return &#x27;ShadowRealm processed: &#x27; + data;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 此时，ShadowRealm 内部定义了一个导出函数 `runInShadowRealm`</span></span><br><span class="line">  <span class="comment">// 我们可以从外部再导入它</span></span><br><span class="line">  realm.<span class="title function_">importValue</span>(<span class="literal">null</span> <span class="comment">/* special for current realm */</span>, <span class="string">&#x27;runInShadowRealm&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">shadowFunc</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">shadowFunc</span>(<span class="string">&#x27;some data&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result from ShadowRealm exported function:&#x27;</span>, res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Main Realm continues...&#x27;</span>); <span class="comment">// 事件循环共享，这里会立即执行</span></span><br></pre></td></tr></table></figure>

<h2 id="四、ShadowRealm-与其他隔离机制的对比"><a href="#四、ShadowRealm-与其他隔离机制的对比" class="headerlink" title="四、ShadowRealm 与其他隔离机制的对比"></a>四、ShadowRealm 与其他隔离机制的对比</h2><table>
<thead>
<tr>
<th align="left">特性 &#x2F; 机制</th>
<th align="left">eval()</th>
<th align="left">Web Workers</th>
<th align="left">iframe</th>
<th align="left">ShadowRealm</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>隔离级别</strong></td>
<td align="left">无隔离 (与主 Realm 共享所有状态)</td>
<td align="left">进程级隔离 (独立线程)</td>
<td align="left">进程级（或类似）隔离</td>
<td align="left"><strong>Realm 级隔离</strong> (独立全局和内置对象，共享事件循环)</td>
</tr>
<tr>
<td align="left"><strong>全局对象</strong></td>
<td align="left">共享</td>
<td align="left">独立</td>
<td align="left">独立</td>
<td align="left">独立</td>
</tr>
<tr>
<td align="left"><strong>内置对象</strong></td>
<td align="left">共享</td>
<td align="left">独立</td>
<td align="left">独立</td>
<td align="left">独立</td>
</tr>
<tr>
<td align="left"><strong>事件循环</strong></td>
<td align="left">共享</td>
<td align="left">独立</td>
<td align="left">独立</td>
<td align="left"><strong>共享</strong></td>
</tr>
<tr>
<td align="left"><strong>DOM 访问</strong></td>
<td align="left">可直接访问</td>
<td align="left">不可直接访问</td>
<td align="left">可直接访问（沙箱限制）</td>
<td align="left">不可直接访问 (仅共享事件循环)</td>
</tr>
<tr>
<td align="left"><strong>通信方式</strong></td>
<td align="left">直接访问</td>
<td align="left">postMessage</td>
<td align="left">postMessage &#x2F; 跨域通信</td>
<td align="left"><strong>Callable Proxy &amp; 原始值</strong></td>
</tr>
<tr>
<td align="left"><strong>资源开销</strong></td>
<td align="left">最小</td>
<td align="left">较大 (新 OS 线程)</td>
<td align="left">较大 (新文档，DOM)</td>
<td align="left">轻量级 (仅 JS 运行时环境)</td>
</tr>
<tr>
<td align="left"><strong>同步&#x2F;异步执行</strong></td>
<td align="left">同步执行</td>
<td align="left">异步执行</td>
<td align="left">异步执行</td>
<td align="left"><code>evaluate</code> 和 <code>importValue</code> 返回 <code>Promise</code> (异步)</td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left">动态代码执行、代码生成</td>
<td align="left">耗时计算、后台任务</td>
<td align="left">UI 隔离、沙箱、跨域请求</td>
<td align="left"><strong>JS 层面的沙箱、插件系统、模块化隔离、避免全局污染</strong></td>
</tr>
</tbody></table>
<h2 id="五、潜在应用场景"><a href="#五、潜在应用场景" class="headerlink" title="五、潜在应用场景"></a>五、潜在应用场景</h2><ol>
<li><p><strong>沙箱执行第三方库&#x2F;插件</strong>：</p>
<ul>
<li>隔离来自第三方插件的代码，防止它们污染主应用环境，即使插件修改了 <code>Array.prototype</code> 也不会影响主应用。</li>
<li>允许应用程序在运行时加载和卸载插件，而不会留下副作用。</li>
</ul>
</li>
<li><p><strong>Web组件与微前端</strong>：</p>
<ul>
<li>为每个 Web 组件或微前端提供独立的 JavaScript 运行时环境，确保它们之间的隔离，同时能够共享同一事件循环响应用户交互，避免僵死状态。</li>
</ul>
</li>
<li><p><strong>SSR 中的隔离执行</strong>：</p>
<ul>
<li>在 Node.js 环境中，为每个用户请求或每个组件的 SSR 渲染提供一个新的 ShadowRealm，以确保渲染逻辑的隔离性和状态的清洁性。</li>
</ul>
</li>
<li><p><strong>安全敏感型应用</strong>：</p>
<ul>
<li>运行由用户上传的脚本，例如代码编辑器中的预览功能，或者游戏中的自定义逻辑脚本。</li>
</ul>
</li>
<li><p><strong>避免模块内部状态干扰</strong>：</p>
<ul>
<li>一些模块库可能设计为单例模式，但实际应用中可能需要多次实例化且互不干扰，ShadowRealm 可以强制实现隔离。</li>
</ul>
</li>
</ol>
<h2 id="六、发展现状与展望"><a href="#六、发展现状与展望" class="headerlink" title="六、发展现状与展望"></a>六、发展现状与展望</h2><ul>
<li><strong>当前阶段</strong>：ShadowRealm 提案目前处于 ECMAScript 规范的 <strong>Stage 3</strong> 阶段，这意味着其语法和语义已经相对稳定，并正在等待更广泛的实现和反馈。</li>
<li><strong>浏览器实现</strong>：在 Chrome 和 Firefox 中已有一些实验性实现和标志。</li>
<li><strong>WebAssembly System Interface (WASI) 对齐</strong>：ShadowRealm 与 WebAssembly Component Model 的隔离概念有相似之处，两者可以协同工作，为更安全的跨语言模块化提供基础。</li>
</ul>
<p>虽然 ShadowRealm 提供强大的 JavaScript 代码隔离功能，但它<strong>不提供操作系统级别的隔离</strong>，<strong>也不能阻止恶意代码消耗 CPU 或内存资源</strong>（除非对其执行环境进行进一步的资源限制，但这超出了 ShadowRealm 本身的功能）。对于处理真正不受信任且可能具有恶意行为的代码，可能仍需要 <code>iframe</code> 与 <code>sandbox</code> 属性结合或服务器端沙箱机制。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>ECMAScript ShadowRealm 提案旨在为 JavaScript 开发者提供一个原生、轻量且强大的代码隔离工具。通过创建具有独立全局对象和内置对象，但共享事件循环的执行环境，它解决了传统隔离机制在性能、易用性或隔离粒度上的不足。ShadowRealm 的出现有望极大地提升 JavaScript 应用的安全性、模块化和可维护性，为构建更健壮、更灵活的现代Web应用程序和服务器端应用提供新的可能性。它的推广和普及，将为前端架构、插件系统和沙箱实践带来深远影响。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/f81355a662b8/">https://blog.tbf1211.xx.kg/f81355a662b8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web%E6%8A%80%E6%9C%AF/">Web技术</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/10349b09ff78/" title="Signal Protocol 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Signal Protocol 详解</div></div><div class="info-2"><div class="info-item-1"> Signal Protocol（前身为 TextSecure Protocol）是一个现代的、开源的、密码学加强的端到端加密 (End-to-End Encryption, E2EE) 协议，旨在为异步和同步即时通讯应用提供消息的机密性、完整性、认证性和不可抵赖性。它由 Open Whisper Systems（现为 Signal Foundation 和 Signal Messenger LLC）开发，最初用于 Signal 应用，现已被WhatsApp、Facebook Messenger（在“秘密对话”模式下）、Google Messages（在 RCS 聊天中）等主流通讯应用广泛采用，成为业界公认的E2EE黄金标准之一。  核心思想：Signal Protocol 通过巧妙结合双棘轮算法 (Double Ratchet Algorithm)、预密钥 (Pre-keys) 和 扩展的 Diffie-Hellman 密钥交换 (X3DH)，实现了前向保密性 (Forward Secrecy) 和 未来保密性&#x2F;后向保密性 (Future Secrecy&#x2F;P...</div></div></div></a><a class="pagination-related" href="/88fea7b52158/" title="Gzip 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Gzip 详解</div></div><div class="info-2"><div class="info-item-1"> Gzip 是一种广泛使用的数据压缩格式和文件格式，以及基于此格式的软件应用。它主要用于减小文件体积，以便在存储或传输时节省空间和带宽。在Web领域，Gzip压缩是提升网页加载速度、优化用户体验的关键技术之一。  核心概念：Gzip利用了DEFLATE算法对数据进行无损压缩，其优势在于压缩效率高、解压速度快，并被几乎所有现代浏览器和Web服务器广泛支持。    一、Gzip 概述与目的Gzip（GNU zip）最初是作为Unix系统中compress程序的替代品而开发的，旨在提供更高效的压缩算法。它的核心目标是：  减少文件存储空间：对于磁盘上的文件，Gzip可以显著减小其占用的存储空间。 加快数据传输速度：在网络传输中，尤其是Web传输（HTTP&#x2F;HTTPS），通过压缩数据可以减少传输量，从而降低带宽消耗并缩短数据抵达客户端的时间。 节省带宽成本：对于提供大量数据的服务提供商，减少传输数据量直接 translates to 降低带宽费用。  二、Gzip 的工作原理：DEFLATE 算法Gzip 压缩的核心是 DEFLATE 算法，它是一种无损数据压缩算法，结合了两种...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/88fea7b52158/" title="Gzip 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-30</div><div class="info-item-2">Gzip 详解</div></div><div class="info-2"><div class="info-item-1"> Gzip 是一种广泛使用的数据压缩格式和文件格式，以及基于此格式的软件应用。它主要用于减小文件体积，以便在存储或传输时节省空间和带宽。在Web领域，Gzip压缩是提升网页加载速度、优化用户体验的关键技术之一。  核心概念：Gzip利用了DEFLATE算法对数据进行无损压缩，其优势在于压缩效率高、解压速度快，并被几乎所有现代浏览器和Web服务器广泛支持。    一、Gzip 概述与目的Gzip（GNU zip）最初是作为Unix系统中compress程序的替代品而开发的，旨在提供更高效的压缩算法。它的核心目标是：  减少文件存储空间：对于磁盘上的文件，Gzip可以显著减小其占用的存储空间。 加快数据传输速度：在网络传输中，尤其是Web传输（HTTP&#x2F;HTTPS），通过压缩数据可以减少传输量，从而降低带宽消耗并缩短数据抵达客户端的时间。 节省带宽成本：对于提供大量数据的服务提供商，减少传输数据量直接 translates to 降低带宽费用。  二、Gzip 的工作原理：DEFLATE 算法Gzip 压缩的核心是 DEFLATE 算法，它是一种无损数据压缩算法，结合了两种...</div></div></div></a><a class="pagination-related" href="/40c57ff5cb61/" title="Pug(前Jade)模板引擎详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="info-item-2">Pug(前Jade)模板引擎详解</div></div><div class="info-2"><div class="info-item-1"> Pug（发音 &#x2F;pʌɡ&#x2F;），前身为 Jade，是一个高性能的 Node.js 模板引擎。它以其简洁、富有表现力的语法而闻名，旨在让 HTML 编写变得更加高效和愉快。Pug 摒弃了传统 HTML 的尖括号和闭合标签，转而使用缩进和基于文本的语法，这使得模板文件更小、更易读、也更不易出错。  核心思想：Pug 通过简洁的缩进语法替代冗长的 HTML 标签，提供强大的动态数据渲染、代码重用和条件逻辑功能。   一、Pug 简介1.1 什么是模板引擎？模板引擎是一种将数据填充到预定义模板中以生成最终输出（通常是 HTML 字符串）的工具。它将页面的结构（模板）与数据分离，使得前端开发更加模块化和可维护。 1.2 Pug 的特点 独特语法：使用缩进表示嵌套关系，无需关闭标签。 简洁明了：代码量显著少于对应的 HTML。 强大功能：支持变量、循环、条件判断、Mixin（类似于函数或组件）、包含（文件复用）、布局继承等高级特性。 编译到 HTML：Pug 模板最终会被编译成标准的 HTML。 Node.js 支持：作为 Node.js 的模板引擎，Pug 完美集成于 E...</div></div></div></a><a class="pagination-related" href="/b519dd676c66/" title="PWA (Progressive Web Apps) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-05</div><div class="info-item-2">PWA (Progressive Web Apps) 深度解析</div></div><div class="info-2"><div class="info-item-1"> PWA (Progressive Web Apps - 渐进式 Web 应用) 是一种利用现代 Web 技术，将 Web 应用提升至接近原生应用体验的新方法。它旨在结合 Web 的广阔可达性与原生应用的丰富功能，为用户提供可靠 (Reliable)、快速 (Fast)、沉浸式 (Engaging) 的体验。PWA 不仅仅是一种技术，更是一套开发理念和最佳实践。  核心思想：PWA 的目标是让 Web 应用具备类似原生应用的体验和功能，同时保留 Web 的优点（无需安装、易于发现、跨平台）。这主要通过 Service Worker 实现离线能力和性能优化，通过 Web App Manifest 实现安装和应用体验，以及通过 HTTPS 确保安全性来达成。   一、为什么需要 PWA？(Web 与原生应用的融合)传统 Web 应用和原生移动应用各有优缺点：  传统 Web 应用 (网站)： 优点：无需安装、易于发现、跨平台、更新灵活、共享方便。 缺点：依赖网络、加载慢、无离线功能、无法添加到主屏幕、无法发送推送通知、用户体验与原生应用有差距。   原生移动应用： 优点：性能好、可离...</div></div></div></a><a class="pagination-related" href="/469d3e424114/" title="IndexedDB 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-25</div><div class="info-item-2">IndexedDB 深度解析</div></div><div class="info-2"><div class="info-item-1"> IndexedDB 是一种基于浏览器的高性能、非关系型 (NoSQL) 数据库，允许在客户端存储大量结构化数据。它提供了一个强大的 API，用于在用户的浏览器中创建和管理数据库，支持事务、索引和异步操作，是构建离线应用 (Offline First) 和 PWA (Progressive Web Apps) 的核心技术之一。  核心思想：IndexedDB 提供了一个强大的、异步的、事务性的客户端数据存储方案，专为存储大量结构化数据而设计。它通过键值对的形式存储 JavaScript 对象，并支持索引来高效查询数据。   一、为什么需要 IndexedDB？(与其它客户端存储的对比)在 Web 开发中，有多种客户端存储技术，但它们各有优缺点，IndexedDB 旨在解决其中一些局限性。  localStorage 和 sessionStorage： 优点：API 简单，同步操作。 缺点： 存储容量小：通常只有 5MB 左右。 仅支持字符串：只能存储字符串，复杂数据需要手动序列化&#x2F;反序列化 (JSON.stringify&#x2F;parse)。 无索引：无法进行高效查...</div></div></div></a><a class="pagination-related" href="/e04a0bc3926c/" title="BFCache (Back-Forward Cache) 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-06</div><div class="info-item-2">BFCache (Back-Forward Cache) 深度详解</div></div><div class="info-2"><div class="info-item-1"> 在 Web 性能优化领域，用户感知的加载速度至关重要。除了常规的网络和渲染优化外，浏览器还有一种强大的特性可以显著提升用户体验，尤其是在用户进行前进&#x2F;后退导航时的加载速度——这就是 BFCache (Back-Forward Cache)，即“往返缓存”或“后退&#x2F;前进缓存”。BFCache 允许浏览器将整个页面（包括 DOM 状态、JavaScript 堆以及当前页面的状态）存储在内存中，以便用户在通过浏览器后退 (Back) 或前进 (Forward) 按钮导航时，能够瞬间恢复到离开时的状态，而无需重新加载页面。  核心思想：BFCache 是一种浏览器优化策略，它将用户离开的整个页面状态（而非仅仅是资源）存储在内存中，以便用户通过“后退&#x2F;前进”按钮再次访问时能够实现即时页面恢复，极大地提升了导航体验。   一、什么是 BFCache？BFCache 是一种用于瞬时页面加载的浏览器缓存机制，其核心思想是：当用户从一个页面 A 导航到页面 B，如果用户随后点击了浏览器的“后退”按钮返回页面 A，浏览器不会重新发送网络请求、重新解析 DOM、重新执行...</div></div></div></a><a class="pagination-related" href="/946675bf7dca/" title="WebAssembly(Wasm)详解：浏览器中的下一代高性能计算"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="info-item-2">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</div></div><div class="info-2"><div class="info-item-1"> WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在现代Web浏览器中执行接近原生性能代码的方法。它被设计为一个可移植、体积小、加载快且与Web兼容的编译目标。Wasm 不仅限于浏览器环境，通过 WASI (WebAssembly System Interface) 等标准，它也能在服务器、物联网设备等非浏览器环境中高效运行。  核心思想：为各种编程语言（如 C&#x2F;C++、Rust、Go、Python 等）提供一个高性能、安全的编译目标，使其代码能在Web或其他沙盒环境中以接近原生速度运行。    一、为什么需要 WebAssembly？在 WebAssembly 出现之前，JavaScript 是 Web 平台唯一的编程语言。尽管 JavaScript 及其引擎（如 V8）在性能方面取得了巨大进步，但仍然存在一些固有局限性：  性能瓶颈：对于计算密集型任务（如图形处理、视频编码&#x2F;解码、科学计算、大型游戏），JavaScript 的动态类型、垃圾回收机制以及解释&#x2F;JIT编译特性，使其难以达到原生代码的性能水平。 语言选择受限：开...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">546</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ShadowRealm%EF%BC%9F"><span class="toc-text">一、为什么需要 ShadowRealm？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ShadowRealm-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="toc-text">二、ShadowRealm 的核心概念与特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Realm-%E9%A2%86%E5%9F%9F"><span class="toc-text">2.1 Realm (领域)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-ShadowRealm-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.2 ShadowRealm 的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ShadowRealm-API-%E6%A6%82%E8%A7%88"><span class="toc-text">三、ShadowRealm API 概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">示例：基本使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ShadowRealm-%E4%B8%8E%E5%85%B6%E4%BB%96%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">四、ShadowRealm 与其他隔离机制的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%BD%9C%E5%9C%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、潜在应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-text">六、发展现状与展望</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-21.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>