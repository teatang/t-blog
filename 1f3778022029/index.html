<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Rust Tauri 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Tauri 是一个用 Rust 编写的开源框架，旨在帮助开发者使用前端 Web 技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能且安全的原生跨平台桌面应用程序。它被视为 Electron 的轻量级、高性能替代方案，特别强调捆包体积小、内存占用低和增强的安全性。  核心思想：将">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust Tauri 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/1f3778022029/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Tauri 是一个用 Rust 编写的开源框架，旨在帮助开发者使用前端 Web 技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能且安全的原生跨平台桌面应用程序。它被视为 Electron 的轻量级、高性能替代方案，特别强调捆包体积小、内存占用低和增强的安全性。  核心思想：将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-30.jpg">
<meta property="article:published_time" content="2025-09-15T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-05T09:12:04.367Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="桌面开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-30.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Rust Tauri 详解",
  "url": "https://blog.tbf1211.xx.kg/1f3778022029/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-30.jpg",
  "datePublished": "2025-09-15T22:24:00.000Z",
  "dateModified": "2026-01-05T09:12:04.367Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/1f3778022029/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rust Tauri 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">466</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-30.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Rust Tauri 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Rust Tauri 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-09-15T22:24:00.000Z" title="发表于 2025-09-16 06:24:00">2025-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/">桌面开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Tauri</strong> 是一个用 Rust 编写的开源框架，旨在帮助开发者使用前端 Web 技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能且安全的原生跨平台桌面应用程序。它被视为 Electron 的轻量级、高性能替代方案，特别强调捆包体积小、内存占用低和增强的安全性。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将现代 Web 前端技术与 Rust 编写的原生后端结合，通过操作系统的 WebView 渲染 UI，实现性能与安全并重的桌面应用开发。</strong></p>
</div>

<hr>
<h2 id="一、为什么选择-Tauri？"><a href="#一、为什么选择-Tauri？" class="headerlink" title="一、为什么选择 Tauri？"></a>一、为什么选择 Tauri？</h2><p>传统的 Web 技术构建桌面应用主要依赖于像 Electron 这样的框架。Electron 的优势在于能够直接复用 Web 生态，但其劣势也显而易见：</p>
<ol>
<li><strong>捆包体积大</strong>：Electron 应用会捆绑 Chromium 浏览器和 Node.js 运行时，导致应用体积通常较大（数十MB到数百MB）。</li>
<li><strong>内存占用高</strong>：Chromium 和 Node.js 运行时都会消耗大量内存，使得 Electron 应用的内存占用普遍较高。</li>
<li><strong>性能开销</strong>：运行完整的浏览器引擎需要额外的CPU和内存资源。</li>
<li><strong>安全顾虑</strong>：将一个完整的浏览器引擎嵌入应用中，可能带来一些潜在的安全风险，需要额外的配置和防护。</li>
</ol>
<p>Tauri 旨在解决这些问题，提供一种更优的桌面应用开发体验：</p>
<ul>
<li><strong>极小的捆包体积</strong>：Tauri 应用不捆绑 Chromium，而是利用操作系统自带的 WebView 控件（如 Windows 上的 WebView2&#x2F;EdgeHTML、macOS 上的 WKWebView、Linux 上的 WebKitGTK&#x2F;WebView2）。这意味着最终应用体积可以小到几MB。</li>
<li><strong>低内存占用</strong>：由于使用系统 WebView，内存占用大幅降低，更接近原生应用。</li>
<li><strong>高性能</strong>：后端使用 Rust 编写，可以利用 Rust 的原生性能优势处理计算密集型任务，并通过 FFI (Foreign Function Interface) 调用系统 API，提升响应速度。</li>
<li><strong>增强的安全性</strong>：Tauri 的安全架构设计严谨，强调默认安全。它通过 Content Security Policy (CSP)、Scope API、进程间通信 (IPC) 的白名单机制等提供多层安全防护。</li>
<li><strong>跨平台</strong>：一套代码库可以构建 Windows、macOS 和 Linux 平台上的应用。</li>
<li><strong>Web 技术栈</strong>：前端开发者可以继续使用熟悉的 HTML、CSS、JavaScript 和各种前端框架。</li>
</ul>
<h2 id="二、Tauri-的核心架构与概念"><a href="#二、Tauri-的核心架构与概念" class="headerlink" title="二、Tauri 的核心架构与概念"></a>二、Tauri 的核心架构与概念</h2><p>Tauri 的架构可以概括为前端 Web 界面与 Rust 后端逻辑的结合：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    A[&quot;用户界面 (UI)HTML&#x2F;CSS&#x2F;JS&lt;br&gt;(React, Vue等)&quot;] --&gt; B[Tauri IPC Bridge]
    B --&gt; C[&quot;Rust Core (Backend)&lt;br&gt;系统API, 文件系统, 网络等&quot;]
    C --&gt; D[操作系统原生物件&lt;br&gt;窗口, 菜单, 通知]
    C --&gt; E[系统级能力文件读写, &lt;br&gt;网络请求, 数据库操作]
    F[&quot;操作系统 WebView 控件&lt;br&gt;(Windows: WebView2, &lt;br&gt;macOS: WKWebView, &lt;br&gt;Linux: WebKitGTK)&quot;] --&gt; A
  
    subgraph Tauri 应用
        A -- 渲染 --&gt; F
        A -- 调用 --&gt; B
        B -- 驱动 --&gt; C
        C -- 控制 --&gt; D
        C -- 访问 --&gt; E
    end
  </pre></div>

<h3 id="2-1-WebView-前端渲染"><a href="#2-1-WebView-前端渲染" class="headerlink" title="2.1 WebView (前端渲染)"></a>2.1 WebView (前端渲染)</h3><ul>
<li><strong>定义</strong>：Tauri 不像 Electron 那样内置一个 Chromium 引擎，而是使用操作系统提供的 Web 内容渲染组件。</li>
<li><strong>优势</strong>：<ul>
<li><strong>减小体积</strong>：无需打包浏览器引擎，显著降低了应用最终的体积。</li>
<li><strong>共享资源</strong>：通常可以利用系统已安装的浏览器组件，减少重复占用。</li>
<li><strong>更接近原生</strong>：WebView 的行为和外观有时能更好地与系统主题集成。</li>
</ul>
</li>
<li><strong>跨平台差异</strong>：<ul>
<li><strong>Windows</strong>：优先使用 WebView2 (基于 Edge Chromium)，如果不可用则回退到 EdgeHTML (IE 的 MSHTML 引擎)。</li>
<li><strong>macOS</strong>：使用 WKWebView (基于 Safari 的 WebKit)。</li>
<li><strong>Linux</strong>：通常使用 WebKitGTK 或 WebView2。</li>
</ul>
</li>
<li><strong>与 Web 交互</strong>：前端 Web 代码运行在 WebView 中，通过 JavaScript 调用 Tauri 提供的 IPC (Inter-Process Communication) Bridge 与 Rust 后端通信。</li>
</ul>
<h3 id="2-2-Rust-Core-后端逻辑"><a href="#2-2-Rust-Core-后端逻辑" class="headerlink" title="2.2 Rust Core (后端逻辑)"></a>2.2 Rust Core (后端逻辑)</h3><ul>
<li><strong>定义</strong>：Tauri 的核心逻辑全部由 Rust 编写，负责处理文件系统操作、网络请求、调用操作系统原生 API、应用生命周期管理、系统托盘、菜单、通知等。</li>
<li><strong>优势</strong>：<ul>
<li><strong>性能</strong>：Rust 提供了接近原生的性能，对于需要高性能计算或复杂系统交互的任务非常理想。</li>
<li><strong>安全性</strong>：Rust 的内存安全特性（所有权系统）可以有效避免许多常见的内存错误和安全漏洞。</li>
<li><strong>跨平台能力</strong>：Rust 优秀的跨平台支持使得后端代码可以轻松编译到不同的操作系统。</li>
</ul>
</li>
<li><strong>API 接口</strong>：Tauri 提供了一套 Rust API，用于在后端实现业务逻辑，并通过 IPC 机制暴露给前端。</li>
</ul>
<h3 id="2-3-IPC-Inter-Process-Communication"><a href="#2-3-IPC-Inter-Process-Communication" class="headerlink" title="2.3 IPC (Inter-Process Communication)"></a>2.3 IPC (Inter-Process Communication)</h3><ul>
<li><strong>定义</strong>：IPC 是前端 WebView 中的 JavaScript 代码与后端 Rust 代码进行通信的桥梁。</li>
<li><strong>工作原理</strong>：<ul>
<li><strong>前端调用后端 (Command)</strong>：JavaScript 通过 <code>window.__TAURI__.invoke()</code> 函数调用 Rust 后端定义的 <code>command</code> 函数。这些 <code>command</code> 函数是 Rust 后端暴露给前端的异步函数。</li>
<li><strong>后端发送事件到前端 (Event)</strong>：Rust 后端可以通过 <code>emit</code> API 向前端发送自定义事件，JavaScript 可以在前端监听这些事件。</li>
</ul>
</li>
<li><strong>安全性</strong>：Tauri 的 IPC 机制是高度安全的。默认情况下，只有在 <code>tauri.conf.json</code> 中明确声明为 <code>allow</code> 的 API 才能被前端调用。开发者还可以通过 <code>scope</code> 属性限制文件系统访问等操作的范围。</li>
</ul>
<h3 id="2-4-Tauri-CLI-Command-Line-Interface"><a href="#2-4-Tauri-CLI-Command-Line-Interface" class="headerlink" title="2.4 Tauri CLI (Command Line Interface)"></a>2.4 Tauri CLI (Command Line Interface)</h3><ul>
<li><strong>定义</strong>：Tauri CLI 是一个强大的命令行工具，用于创建、开发、构建 Tauri 项目。</li>
<li><strong>功能</strong>：<ul>
<li><code>tauri init</code>：初始化 Tauri 项目。</li>
<li><code>tauri dev</code>：开发模式运行应用，支持热重载。</li>
<li><code>tauri build</code>：构建生产环境的应用，生成安装包（<code>.msi</code>, <code>.deb</code>, <code>.dmg</code> 等）。</li>
<li><code>tauri plugin</code>：管理 Tauri 插件。</li>
</ul>
</li>
</ul>
<h3 id="2-5-配置文件-tauri-conf-json"><a href="#2-5-配置文件-tauri-conf-json" class="headerlink" title="2.5 配置文件 (tauri.conf.json)"></a>2.5 配置文件 (<code>tauri.conf.json</code>)</h3><ul>
<li><strong>定义</strong>：Tauri 项目的核心配置文件，定义了应用的元数据、构建选项、安全策略、IPC 允许列表等。</li>
<li><strong>关键配置项</strong>：<ul>
<li><code>package</code>：应用名称、版本等。</li>
<li><code>build</code>：前端构建命令、分发目录等。</li>
<li><code>tauri</code>：<ul>
<li><code>allowlist</code>：最重要的安全配置，指定前端可以调用哪些后端 API（如 <code>fs</code>, <code>shell</code>, <code>dialog</code> 等）。</li>
<li><code>security</code>：CSP (Content Security Policy) 设置，进一步增强 WebView 的安全性。</li>
<li><code>windows</code>：配置应用窗口属性（标题、大小、是否可调整大小等）。</li>
<li><code>bundle</code>：配置打包选项，如图标、安装器类型等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、Tauri-的开发流程"><a href="#三、Tauri-的开发流程" class="headerlink" title="三、Tauri 的开发流程"></a>三、Tauri 的开发流程</h2><h3 id="3-1-准备环境"><a href="#3-1-准备环境" class="headerlink" title="3.1 准备环境"></a>3.1 准备环境</h3><ol>
<li><strong>Rust 工具链</strong>：安装 Rustup，然后安装 Rust 编译器和 Cargo 包管理器。</li>
<li><strong>Node.js 和 npm&#x2F;yarn</strong>：用于前端项目管理。</li>
<li><strong>系统 WebView 依赖</strong>：<ul>
<li><strong>Windows</strong>：需要安装 WebView2 Runtime（如果系统没有）。</li>
<li><strong>Linux</strong>：需要安装 <code>webkit2gtk</code> 或 <code>webkitgtk</code> 等依赖。</li>
<li><strong>macOS</strong>：通常无需额外安装。</li>
</ul>
</li>
<li><strong>Tauri CLI</strong>：<code>npm install -g @tauri-apps/cli</code> 或 <code>cargo install tauri-cli</code>。</li>
</ol>
<h3 id="3-2-创建项目"><a href="#3-2-创建项目" class="headerlink" title="3.2 创建项目"></a>3.2 创建项目</h3><p>使用 Tauri CLI 初始化一个新项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx create-tauri-app my-tauri-app</span><br><span class="line"><span class="comment"># 按照提示选择前端框架 (React, Vue, Svelte等) 和包管理器 (npm, yarn, pnpm)</span></span><br></pre></td></tr></table></figure>

<p>项目结构示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my-tauri-app/</span><br><span class="line">├── src-tauri/             # Rust 后端代码和配置</span><br><span class="line">│   ├── Cargo.toml         # Rust 项目配置文件</span><br><span class="line">│   ├── src/               # Rust 源代码</span><br><span class="line">│   │   ├── main.rs        # 应用入口点</span><br><span class="line">│   │   └── commands.rs    # 后端命令定义</span><br><span class="line">│   └── tauri.conf.json    # Tauri 核心配置文件</span><br><span class="line">├── src/                   # 前端 Web 代码 (例如 Vue/React 项目)</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── main.js/ts</span><br><span class="line">│   └── components/</span><br><span class="line">├── package.json           # 前端项目配置文件</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure>

<h3 id="3-3-编写前端代码"><a href="#3-3-编写前端代码" class="headerlink" title="3.3 编写前端代码"></a>3.3 编写前端代码</h3><p>在 <code>src/</code> 目录下像往常一样编写你的 Web 应用。<br><strong>示例 (前端调用后端命令):</strong><br><code>src/App.vue</code> (Vue 示例)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello Tauri!&lt;/h1&gt;</span><br><span class="line">    &lt;input v-model=&quot;name&quot; placeholder=&quot;Enter your name&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">    &lt;p v-if=&quot;greeting&quot;&gt;&#123;&#123; greeting &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; invoke &#125; from &#x27;@tauri-apps/api/tauri&#x27;; // 导入 Tauri IPC API</span><br><span class="line"></span><br><span class="line">const name = ref(&#x27;&#x27;);</span><br><span class="line">const greeting = ref(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">async function greet() &#123;</span><br><span class="line">  if (name.value) &#123;</span><br><span class="line">    // 调用 Rust 后端的 &#x27;greet&#x27; 命令</span><br><span class="line">    greeting.value = await invoke(&#x27;greet&#x27;, &#123; name: name.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-编写后端代码-Rust"><a href="#3-4-编写后端代码-Rust" class="headerlink" title="3.4 编写后端代码 (Rust)"></a>3.4 编写后端代码 (Rust)</h3><p>在 <code>src-tauri/src/main.rs</code> 或其他 Rust 文件中定义命令。<br><strong>示例 (Rust 后端命令):</strong><br><code>src-tauri/src/main.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 Tauri 的宏和类型</span></span><br><span class="line"><span class="meta">#[tauri::command]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Hello, &#123;&#125;! You&#x27;ve been greeted from Rust!&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    tauri::Builder::<span class="title function_ invoke__">default</span>()</span><br><span class="line">        .<span class="title function_ invoke__">invoke_handler</span>(tauri::generate_handler![greet]) <span class="comment">// 注册 greet 命令</span></span><br><span class="line">        .<span class="title function_ invoke__">run</span>(tauri::generate_context!())</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;error while running tauri application&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-运行与构建"><a href="#3-5-运行与构建" class="headerlink" title="3.5 运行与构建"></a>3.5 运行与构建</h3><ul>
<li><strong>开发模式</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run tauri dev <span class="comment"># 或 yarn tauri dev</span></span><br></pre></td></tr></table></figure>
这会启动你的前端开发服务器，并在一个 Tauri 窗口中加载它。支持热重载。</li>
<li><strong>构建生产版本</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run tauri build <span class="comment"># 或 yarn tauri build</span></span><br></pre></td></tr></table></figure>
这会编译你的 Rust 后端，打包前端资源，并生成针对当前操作系统架构的原生应用安装包或可执行文件。</li>
</ul>
<h2 id="四、Tauri-的优势与局限性对比"><a href="#四、Tauri-的优势与局限性对比" class="headerlink" title="四、Tauri 的优势与局限性对比"></a>四、Tauri 的优势与局限性对比</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Tauri</th>
<th align="left">Electron</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>捆包体积</strong></td>
<td align="left">极小 (几MB)</td>
<td align="left">较大 (数十到数百MB)</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">低，接近原生应用</td>
<td align="left">高，因为包含完整 Chromium 和 Node.js 运行时</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">后端 Rust 接近原生性能，前端 WebView 性能好</td>
<td align="left">前端 JavaScript 性能受限，整体性能开销大</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">默认安全，严格的 IPC 权限控制，CSP 支持</td>
<td align="left">需要额外配置才能确保安全，潜在风险点较多</td>
</tr>
<tr>
<td align="left"><strong>技术栈</strong></td>
<td align="left">前端 Web + 后端 Rust</td>
<td align="left">前端 Web + 后端 Node.js</td>
</tr>
<tr>
<td align="left"><strong>打包组件</strong></td>
<td align="left">操作系统原生 WebView</td>
<td align="left">内置 Chromium 和 Node.js</td>
</tr>
<tr>
<td align="left"><strong>上手难度</strong></td>
<td align="left">前端熟悉者需要学习 Rust 基础和 Tauri API</td>
<td align="left">前端熟悉者更容易上手，Node.js 学习曲线较低</td>
</tr>
<tr>
<td align="left"><strong>生态系统</strong></td>
<td align="left">相对年轻，社区和插件仍在发展中</td>
<td align="left">庞大成熟，丰富的第三方库和工具</td>
</tr>
<tr>
<td align="left"><strong>Web API 支持</strong></td>
<td align="left">依赖系统 WebView，可能存在旧版兼容性问题</td>
<td align="left">Chromium 内置，支持最新的 Web API 和特性</td>
</tr>
</tbody></table>
<h2 id="五、安全性考虑"><a href="#五、安全性考虑" class="headerlink" title="五、安全性考虑"></a>五、安全性考虑</h2><p>Tauri 在设计上将安全性放在了非常重要的位置：</p>
<ul>
<li><strong>最小权限原则</strong>：默认情况下，Tauri 不允许前端 WebView 访问任何系统 API。所有与系统交互的命令都必须在 <code>tauri.conf.json</code> 的 <code>allowlist</code> 中显式启用。</li>
<li><strong>Content Security Policy (CSP)</strong>：开发者可以通过 <code>tauri.conf.json</code> 配置 WebView 的 CSP，严格限制 WebView 可以加载的资源和执行的脚本，有效防范 XSS 攻击。</li>
<li><strong>Scope API</strong>：对于文件系统等敏感操作，Tauri 允许你进一步限制访问范围（例如，只允许读取特定目录）。</li>
<li><strong>进程隔离</strong>：将前端 WebView 和后端 Rust 逻辑分离，即使前端被攻破，攻击者也难以直接访问后端或系统资源。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Tauri 是一个令人兴奋的桌面应用开发框架，它通过利用 Rust 的原生性能和安全性，以及操作系统自带的 WebView 控件，成功地在 Web 技术与原生应用之间找到了一个更优雅的平衡点。对于追求应用体积小、内存占用低和高性能的开发者来说，Tauri 是一个极具吸引力的 Electron 替代方案。</p>
<p>虽然学习 Rust 可能会带来一定的门槛，且其生态系统相对年轻，但 Tauri 提供的巨大优势，使得其在构建企业级应用、性能敏感型工具、或者简单、美观的个人工具时，成为一个非常值得投资和深入研究的框架。随着 Tauri 社区的不断壮大和功能的日益完善，它有望在跨平台桌面应用开发领域扮演越来越重要的角色。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/1f3778022029/">https://blog.tbf1211.xx.kg/1f3778022029/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Rust/">Rust</a><a class="post-meta__tags" href="/tags/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/">桌面开发</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-30.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/cdecf00b2f41/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">GoLang Wails 框架详解：用 Web 技术构建桌面应用</div></div><div class="info-2"><div class="info-item-1"> Wails 是一个 Go 语言编写的框架，用于使用 Go 语言的强大后端能力和熟悉的 Web 前端技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能、原生的跨平台桌面应用程序。它与 Tauri 类似，都是 Electron 的替代品，但 Wails 的核心优势在于其后端是 Go 语言，这对于 Go 开发者来说更具亲和力。  核心思想：将现代 Web 前端技术与 Go 语言编写的原生后端无缝结合，通过操作系统的 WebView 渲染 UI，实现高性能、低资源消耗且易于 Go 开发者上手的桌面应用开发。    一、为什么选择 Wails？与 Electron 相比，Wails 提供了一系列优势，特别吸引 Go 语言开发者：  极小的捆包体积：Wails 应用同样不捆绑 Chromium 或 Node.js 运行时。它利用操作系统自带的 WebView 控件（如 Windows 上的 WebView2&#x2F;EdgeHTML、macOS 上的 WKWebView...</div></div></div></a><a class="pagination-related" href="/0f7967cd7bd6/" title="Flutter 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Flutter 详解</div></div><div class="info-2"><div class="info-item-1"> Flutter 是 Google 于 2018 年推出的一个开源 UI 软件开发工具包 (SDK)。它允许开发者使用一套代码库，构建高性能、高保真、美观的原生编译应用，可以在移动 (iOS, Android)、Web、桌面 (Windows, macOS, Linux) 甚至嵌入式设备上运行。Flutter 的核心优势在于其“Everything is a Widget”的理念和独特的渲染引擎，旨在提供卓越的开发体验和像素级的 UI 控制能力。  核心思想： Flutter 通过自绘渲染引擎 (Skia) 完全绕过原生 UI 组件，直接在屏幕上绘制像素，从而实现高度一致的 UI 和动画，同时利用 Dart 语言的 AOT 编译提供接近原生的性能。   一、为什么选择 Flutter？随着移动和跨平台开发的兴起，开发者面临着在不同平台间代码复用和一致性体验的挑战。Flutter 旨在解决这些问题，提供以下核心优势：  真正的跨平台能力 (A Single Codebase for All Platforms)：  一套代码库，覆盖多平台：可以构建原生编译的 iOS、Android...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cdecf00b2f41/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">GoLang Wails 框架详解：用 Web 技术构建桌面应用</div></div><div class="info-2"><div class="info-item-1"> Wails 是一个 Go 语言编写的框架，用于使用 Go 语言的强大后端能力和熟悉的 Web 前端技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能、原生的跨平台桌面应用程序。它与 Tauri 类似，都是 Electron 的替代品，但 Wails 的核心优势在于其后端是 Go 语言，这对于 Go 开发者来说更具亲和力。  核心思想：将现代 Web 前端技术与 Go 语言编写的原生后端无缝结合，通过操作系统的 WebView 渲染 UI，实现高性能、低资源消耗且易于 Go 开发者上手的桌面应用开发。    一、为什么选择 Wails？与 Electron 相比，Wails 提供了一系列优势，特别吸引 Go 语言开发者：  极小的捆包体积：Wails 应用同样不捆绑 Chromium 或 Node.js 运行时。它利用操作系统自带的 WebView 控件（如 Windows 上的 WebView2&#x2F;EdgeHTML、macOS 上的 WKWebView...</div></div></div></a><a class="pagination-related" href="/e208a03b114e/" title="JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)</div></div><div class="info-2"><div class="info-item-1"> JavaScript，正式名称为 ECMAScript (ES)，自 1997 年标准化以来，一直在不断发展。尤其是从 ES6 (ES2015) 开始，它进入了一个快速迭代的时代，每年都会发布一个新版本，引入大量的新特性、语法糖和标准库改进。理解这些新特性对于现代 JavaScript 开发者至关重要，它能帮助我们编写更简洁、更强大、更符合未来趋势的代码。  核心思想： ECMAScript 的版本迭代致力于提升开发效率、代码可读性、执行性能，并引入现代编程范式（如异步编程、模块化），同时保持向后兼容性。   一、早期版本：奠定基础 (ES1 - ES5)早期版本的 ECMAScript 奠定了 JavaScript 的基本语法和核心功能，但发展速度相对较慢。 1.1 ES1 (1997) - ES3 (1999) 基本语法：变量声明 (var)、函数、条件语句、循环、基本数据类型（字符串、数字、布尔、null、undefined）。 对象和数组：字面量创建、属性访问。 原型继承：基于原型的继承机制。 函数作用域：变量作用域规则。 try...catch：错误处理。 eval(...</div></div></div></a><a class="pagination-related" href="/1ae20d2726d8/" title="MiniRTC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-29</div><div class="info-item-2">MiniRTC 详解</div></div><div class="info-2"><div class="info-item-1"> MiniRTC 是一个概念性框架，旨在简化实时通信 (Real-Time Communication, RTC) 的复杂性，通过关注核心原理和最小化实现，帮助开发者理解 RTC 的工作机制，或在特定受控环境下构建轻量级的实时交互系统。它通常指的是对 WebRTC 等复杂框架的简化实现或教学模型，而非一个特定的标准或库。  核心思想：剥离 WebRTC 等标准 RTC 框架的复杂性，专注于信令交换、点对点连接建立和数据&#x2F;媒体传输的核心流程，以便于学习和在特定场景下进行定制化开发。   一、为什么需要 MiniRTC？WebRTC (Web Real-Time Communication) 是一个强大的开放标准，提供了在浏览器和移动应用之间进行实时语音、视频和数据通信的能力。然而，WebRTC 本身非常复杂，涉及众多协议、API 和技术细节，例如：  复杂的 API 和配置：WebRTC 提供了丰富的 API，但正确使用它们并进行各种配置（如编解码器、网络条件适应性）需要深入理解。 网络穿透 (NAT Traversal)：这是 RTC 最具挑战性的部分之一，需要依靠 S...</div></div></div></a><a class="pagination-related" href="/902d004f5ccc/" title="浏览器指纹 (Browser Fingerprinting) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">浏览器指纹 (Browser Fingerprinting) 详解</div></div><div class="info-2"><div class="info-item-1"> 浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是浏览器指纹？浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。 这个“指纹”的强大之处在于其持久性和隐蔽性，用户很难通过常规手段进行清除或规避。 二、浏览器指纹的工作原理网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括： 1. HTTP 请求头信息 (HTT...</div></div></div></a><a class="pagination-related" href="/914c30a1659f/" title="Three.js 进阶教程：从核心概念到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-14</div><div class="info-item-2">Three.js 进阶教程：从核心概念到高级应用</div></div><div class="info-2"><div class="info-item-1"> Three.js 不仅仅是一个库，它是一个通往 3D 世界的大门。通过它，我们可以在 Web 浏览器中构建出令人惊叹的交互式体验。本教程将带你超越入门，深入了解 Three.js 的核心组件、工作原理以及一些高级技巧，助你构建更复杂、更酷炫的 3D 应用。  “深入 Three.js，你将发现 Web 前端的无限可能性。”   一、Three.js 核心工作流回顾与进阶在入门教程中，我们介绍了 Three.js 的“四大件”：场景 (Scene)、相机 (Camera)、渲染器 (Renderer) 和物体 (Object &#x3D; Geometry + Material)。它们是构建任何 Three.js 应用的基础。 1.1 渲染管线概览     graph TD     A[JavaScript Code （Three.js）] --&gt; B(初始化: Scene, Camera, Renderer);     B --&gt; C(创建 Mesh: Geometry + Material);     C --&gt; D(添加 Lights);     C --...</div></div></div></a><a class="pagination-related" href="/f200f6bfe5fa/" title="Golang 特殊注释 (Special Comments) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">Golang 特殊注释 (Special Comments) 详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，除了我们日常用于解释代码逻辑的普通注释 // 和 /* */ 之外，还存在一些具有特殊含义的注释。这些特殊注释通常以 //go: 或 // + 开头，它们并不是为程序员阅读而生，而是作为指令直接与 Go 工具链（编译器、链接器、go generate 等）交互，用于控制编译行为、生成代码、导入 C 代码，或者提供额外的信息。  核心思想：特殊注释是 Go 工具链的“命令”，用于扩展 Go 语言的能力，例如嵌入文件、生成代码、与 C 语言交互或进行性能优化。   一、Go 特殊注释的分类与作用Go 的特殊注释大致可以分为几类：  编译器指令 (Build Constraints)：控制哪些文件或代码块在特定条件下编译。 代码生成指令 (go generate)：标记需要执行特定外部工具来生成代码的位置。 cgo 指令：用于 Go 和 C&#x2F;C++ 代码之间的互操作。 embed 指令：将静态文件嵌入到 Go 二进制文件中 (Go 1.16+)。 运行时或工具指令：用于性能分析、内存管理等内部或高级用途。  接下来的章节将详细介绍这些特殊注释。 二、//g...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">466</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-Tauri%EF%BC%9F"><span class="toc-text">一、为什么选择 Tauri？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Tauri-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Tauri 的核心架构与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-WebView-%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">2.1 WebView (前端渲染)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Rust-Core-%E5%90%8E%E7%AB%AF%E9%80%BB%E8%BE%91"><span class="toc-text">2.2 Rust Core (后端逻辑)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-IPC-Inter-Process-Communication"><span class="toc-text">2.3 IPC (Inter-Process Communication)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Tauri-CLI-Command-Line-Interface"><span class="toc-text">2.4 Tauri CLI (Command Line Interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-tauri-conf-json"><span class="toc-text">2.5 配置文件 (tauri.conf.json)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Tauri-%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">三、Tauri 的开发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83"><span class="toc-text">3.1 准备环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">3.2 创建项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E5%86%99%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">3.3 编写前端代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BC%96%E5%86%99%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81-Rust"><span class="toc-text">3.4 编写后端代码 (Rust)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%BF%90%E8%A1%8C%E4%B8%8E%E6%9E%84%E5%BB%BA"><span class="toc-text">3.5 运行与构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Tauri-%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7%E5%AF%B9%E6%AF%94"><span class="toc-text">四、Tauri 的优势与局限性对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">五、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-30.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>