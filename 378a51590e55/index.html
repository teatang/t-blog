<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>HTTP/1.1 协议深度详解：Web 通信的基石 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP&#x2F;1.1 协议深度详解：Web 通信的基石">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/378a51590e55/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg">
<meta property="article:published_time" content="2023-03-22T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-28T09:11:10.441Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HTTP/1.1 协议深度详解：Web 通信的基石",
  "url": "https://blog.tbf1211.xx.kg/378a51590e55/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg",
  "datePublished": "2023-03-22T22:24:00.000Z",
  "dateModified": "2026-01-28T09:11:10.441Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/378a51590e55/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HTTP/1.1 协议深度详解：Web 通信的基石',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">527</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">HTTP/1.1 协议深度详解：Web 通信的基石</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">HTTP/1.1 协议深度详解：Web 通信的基石</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-22T22:24:00.000Z" title="发表于 2023-03-23 06:24:00">2023-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>HTTP (HyperText Transfer Protocol - 超文本传输协议)</strong> 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。<strong>HTTP&#x2F;1.1</strong> 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于<strong>请求-响应模型</strong>，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。</p>
</div>
<hr>
<h2 id="一、HTTP-1-0-到-HTTP-1-1-的演进：解决痛点"><a href="#一、HTTP-1-0-到-HTTP-1-1-的演进：解决痛点" class="headerlink" title="一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点"></a>一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点</h2><p>HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：</p>
<ol>
<li><strong>短连接 (Short Connection)</strong>：HTTP&#x2F;1.0 默认每个请求&#x2F;响应事务都需要建立一个新的 TCP 连接。这意味着：<ul>
<li>每次请求都有 TCP 三次握手和四次挥手的开销。</li>
<li>对于包含大量小资源的网页（如图片、CSS、JS 文件），会建立和关闭很多次连接，造成严重延迟。</li>
<li>TCP 连接的慢启动机制无法有效发挥作用，因为每次新建连接都会重置。</li>
</ul>
</li>
<li><strong>无状态性 (Statelessness)</strong>：虽然 HTTP 本身是无状态的，但 HTTP&#x2F;1.0 缺乏有效的机制来维护会话状态，如 Cookie。</li>
<li><strong>不支持虚拟主机</strong>：HTTP&#x2F;1.0 在请求头中没有 <code>Host</code> 字段，导致一个 IP 地址只能对应一个域名，无法在同一个服务器上托管多个网站。</li>
<li><strong>带宽浪费</strong>：缺乏有效的缓存策略和断点续传机制。</li>
</ol>
<p><strong>HTTP&#x2F;1.1 于 1999 年发布，旨在解决这些问题，带来了以下关键改进：</strong></p>
<ol>
<li><strong>持久连接 (Persistent Connections)</strong>：默认开启，允许在同一个 TCP 连接上发送多个 HTTP 请求和接收多个响应。</li>
<li><strong>请求管线化 (Pipelining)</strong>：在持久连接的基础上，允许客户端在收到前一个响应之前，就发送下一个请求。</li>
<li><strong>缓存控制 (Cache Control)</strong>：引入了更精细和强大的缓存机制 (<code>Cache-Control</code>、<code>ETag</code> 等)。</li>
<li><strong>范围请求 (Range Requests)</strong>：支持断点续传，允许客户端只请求资源的某个部分。</li>
<li><strong>Host 头</strong>：强制要求请求头包含 <code>Host</code> 字段，支持虚拟主机。</li>
<li><strong>错误通知</strong>：增加了更丰富的状态码。</li>
</ol>
<h2 id="二、HTTP-1-1-的基本特性"><a href="#二、HTTP-1-1-的基本特性" class="headerlink" title="二、HTTP&#x2F;1.1 的基本特性"></a>二、HTTP&#x2F;1.1 的基本特性</h2><h3 id="2-1-1-请求-响应模型"><a href="#2-1-1-请求-响应模型" class="headerlink" title="2.1 1. 请求-响应模型"></a>2.1 1. 请求-响应模型</h3><p>HTTP&#x2F;1.1 遵循经典的请求-响应模型。客户端发送请求报文，服务器发送响应报文。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant C as 客户端 (浏览器)
    participant S as 服务器 (Web Server)

    activate C
    C-&gt;&gt;S: 1. 建立 TCP 连接 (如果不是持久连接或首次)
    activate S
    C-&gt;&gt;S: 2. 发送 HTTP 请求报文
    activate S
    S--&gt;&gt;C: 3. 发送 HTTP 响应报文
    deactivate S
    C-&gt;&gt;S: 4. 关闭 TCP 连接 (如果不是持久连接)
    deactivate C
  </pre></div>

<p>一次 HTTP 事务包含请求和响应两个部分，每个部分都由三部分构成：<strong>起始行、头部字段集、空行、实体主体</strong>。</p>
<h3 id="2-2-2-无状态性与-Cookie"><a href="#2-2-2-无状态性与-Cookie" class="headerlink" title="2.2 2. 无状态性与 Cookie"></a>2.2 2. 无状态性与 Cookie</h3><p>HTTP&#x2F;1.1 协议本身是无状态的，即服务器不会保存客户端以前的请求信息，每个请求都是独立的。</p>
<p>然而，为了在无状态的 HTTP 上实现有状态的会话管理（如用户登录状态、购物车），引入了 <strong>Cookie</strong> 机制：</p>
<ul>
<li>服务器通过 <code>Set-Cookie</code> 响应头向客户端发送 Cookie。</li>
<li>客户端将 Cookie 存储起来，并在后续请求中通过 <code>Cookie</code> 请求头自动发送回服务器。</li>
<li>服务器根据 Cookie 识别客户端并维护会话状态。</li>
</ul>
<h3 id="2-3-3-头部字段-Headers"><a href="#2-3-3-头部字段-Headers" class="headerlink" title="2.3 3. 头部字段 (Headers)"></a>2.3 3. 头部字段 (Headers)</h3><p>HTTP 头部字段是请求和响应的关键元数据，它们提供了关于报文、请求&#x2F;响应的附加信息，如内容类型、编码、缓存策略、认证信息等。</p>
<p><strong>常见请求头示例：</strong></p>
<ul>
<li><code>Host</code>: <code>www.example.com</code> (必须，指定目标服务器的域名)</li>
<li><code>User-Agent</code>: <code>Mozilla/5.0 ...</code> (客户端浏览器和操作系统信息)</li>
<li><code>Accept</code>: <code>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code> (客户端能接受的媒体类型)</li>
<li><code>Accept-Encoding</code>: <code>gzip, deflate, br</code> (客户端能接受的内容编码)</li>
<li><code>Accept-Language</code>: <code>zh-CN,zh;q=0.9,en;q=0.8</code> (客户端能接受的语言)</li>
<li><code>Connection</code>: <code>keep-alive</code> (控制持久连接，HTTP&#x2F;1.1 默认 <code>keep-alive</code>)</li>
<li><code>Content-Length</code>: <code>1024</code> (请求体长度)</li>
<li><code>Content-Type</code>: <code>application/json</code> (请求体的媒体类型)</li>
<li><code>Cookie</code>: <code>sessionid=abc123; user=john</code> (客户端发送的 Cookie)</li>
<li><code>Authorization</code>: <code>Bearer &lt;token&gt;</code> (认证凭证)</li>
<li><code>If-Modified-Since</code>: <code>Fri, 26 Jul 2024 10:00:00 GMT</code> (条件请求，用于缓存验证)</li>
<li><code>If-None-Match</code>: <code>&quot;&lt;etag&gt;&quot;</code> (条件请求，用于缓存验证)</li>
</ul>
<p><strong>常见响应头示例：</strong></p>
<ul>
<li><code>Server</code>: <code>Apache/2.4.6 (CentOS)</code> (服务器软件信息)</li>
<li><code>Content-Type</code>: <code>text/html; charset=utf-8</code> (响应体媒体类型和字符集)</li>
<li><code>Content-Length</code>: <code>2048</code> (响应体长度)</li>
<li><code>Connection</code>: <code>keep-alive</code> (控制持久连接)</li>
<li><code>Cache-Control</code>: <code>max-age=3600, public</code> (缓存指令)</li>
<li><code>Expires</code>: <code>Fri, 26 Jul 2025 10:00:00 GMT</code> (缓存过期时间)</li>
<li><code>Last-Modified</code>: <code>Fri, 26 Jul 2024 10:00:00 GMT</code> (资源最后修改时间)</li>
<li><code>ETag</code>: <code>&quot;&lt;etag_hash&gt;&quot;</code> (资源实体标签，用于缓存验证)</li>
<li><code>Vary</code>: <code>Accept-Encoding</code> (指示响应会因请求头的不同而不同)</li>
<li><code>Set-Cookie</code>: <code>sessionid=xyz456; Path=/; HttpOnly</code> (服务器设置 Cookie)</li>
<li><code>Location</code>: <code>http://www.example.com/new-resource</code> (重定向目标 URL)</li>
</ul>
<h3 id="2-4-4-状态码-Status-Codes"><a href="#2-4-4-状态码-Status-Codes" class="headerlink" title="2.4 4. 状态码 (Status Codes)"></a>2.4 4. 状态码 (Status Codes)</h3><p>HTTP 状态码是服务器对请求的反馈，一个三位数字，用来告诉客户端请求是成功、失败还是有其他情况需要处理。</p>
<ul>
<li><strong>1xx (信息)</strong>：请求已被接收，继续处理。<ul>
<li><code>100 Continue</code>：客户端应继续其请求。</li>
<li><code>101 Switching Protocols</code>：服务器已理解并接受客户端的 Upgrade 请求，并将切换到新的协议（如 WebSocket 握手）。</li>
</ul>
</li>
<li><strong>2xx (成功)</strong>：请求已成功被接收、理解、接受。<ul>
<li><code>200 OK</code>：请求成功，响应头和响应体中包含所请求的资源。</li>
<li><code>201 Created</code>：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。</li>
<li><code>204 No Content</code>：服务器成功处理了请求，但没有返回任何内容（如 DELETE 请求）。</li>
<li><code>206 Partial Content</code>：服务器已成功处理了部分 GET 请求（用于断点续传或多线程下载）。</li>
</ul>
</li>
<li><strong>3xx (重定向)</strong>：需要进一步操作以完成请求。<ul>
<li><code>301 Moved Permanently</code>：资源已被永久移动到新位置。</li>
<li><code>302 Found</code>：资源临时移动到新位置。</li>
<li><code>304 Not Modified</code>：自上次请求以来资源未被修改，客户端可使用缓存副本。</li>
</ul>
</li>
<li><strong>4xx (客户端错误)</strong>：请求包含语法错误或无法完成请求。<ul>
<li><code>400 Bad Request</code>：服务器无法理解客户端的请求，因为请求报文有语法错误。</li>
<li><code>401 Unauthorized</code>：请求需要用户验证。</li>
<li><code>403 Forbidden</code>：服务器理解请求，但拒绝执行（通常是权限问题）。</li>
<li><code>404 Not Found</code>：服务器找不到请求的资源。</li>
<li><code>405 Method Not Allowed</code>：请求方法不被服务器支持。</li>
<li><code>408 Request Timeout</code>：客户端没有在时限内发送完整的请求。</li>
<li><code>409 Conflict</code>：由于和资源当前的冲突而不能完成该请求。</li>
<li><code>413 Payload Too Large</code>：请求体太大。</li>
<li><code>415 Unsupported Media Type</code>：服务器无法处理请求附带的媒体格式。</li>
</ul>
</li>
<li><strong>5xx (服务器错误)</strong>：服务器未能实现请求。<ul>
<li><code>500 Internal Server Error</code>：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。</li>
<li><code>502 Bad Gateway</code>：服务器作为网关或代理，从上游服务器收到无效响应。</li>
<li><code>503 Service Unavailable</code>：服务器目前无法响应请求，通常由于超载或停机维护。</li>
<li><code>504 Gateway Timeout</code>：服务器作为网关或代理，没有及时从上游服务器收到响应。</li>
</ul>
</li>
</ul>
<h2 id="三、HTTP-1-1-的核心新特性"><a href="#三、HTTP-1-1-的核心新特性" class="headerlink" title="三、HTTP&#x2F;1.1 的核心新特性"></a>三、HTTP&#x2F;1.1 的核心新特性</h2><h3 id="3-1-1-持久连接-Persistent-Connections"><a href="#3-1-1-持久连接-Persistent-Connections" class="headerlink" title="3.1 1. 持久连接 (Persistent Connections)"></a>3.1 1. 持久连接 (Persistent Connections)</h3><ul>
<li><strong>HTTP&#x2F;1.0 默认短连接</strong>：每个请求创建一个新的 TCP 连接，传输数据后立即关闭。</li>
<li><strong>HTTP&#x2F;1.1 默认持久连接</strong>：引入 <code>keep-alive</code> 机制（虽然现在 <code>Connection: keep-alive</code> 头通常可以省略，因为它已是默认行为），允许在同一个 TCP 连接上发送和接收多个请求和响应。</li>
<li><strong>优势</strong>：<ol>
<li><strong>减少 TCP 连接建立开销</strong>：避免了多次 TCP 三次握手和四次挥手。</li>
<li><strong>TCP 慢启动</strong>：一旦 TCP 连接建立并进入稳定状态，可以避免慢启动带来的延迟。</li>
<li><strong>节省带宽</strong>：减少了连接管理相关的报文传输。</li>
</ol>
</li>
<li><strong>配置</strong>：服务器可以通过 <code>Keep-Alive</code> 响应头指定连接保持时间或最大请求数。</li>
</ul>
<h3 id="3-2-2-请求管线化-Pipelining"><a href="#3-2-2-请求管线化-Pipelining" class="headerlink" title="3.2 2. 请求管线化 (Pipelining)"></a>3.2 2. 请求管线化 (Pipelining)</h3><ul>
<li>在持久连接的基础上，允许客户端在收到上一个请求的响应之前，就发送下一个请求。</li>
<li><strong>工作方式</strong>：客户端连续发送多个请求，服务器收到后会按顺序处理这些请求，并按顺序返回响应。</li>
<li><strong>优势</strong>：提高了请求的并行度，减少了客户端的等待时间。</li>
<li><strong>局限性 (队头阻塞 - Head-of-Line Blocking)</strong>：<ul>
<li>服务器必须按请求的顺序发送响应。如果第一个请求处理时间很长，后面的请求即使处理完了，也必须等待它先发送响应。</li>
<li>由于这些限制和实现的复杂性，以及后续 HTTP&#x2F;2 的出现，<strong>现代浏览器通常默认不开启 HTTP&#x2F;1.1 的请求管线化。</strong></li>
</ul>
</li>
</ul>
<h3 id="3-3-3-缓存控制-Cache-Control"><a href="#3-3-3-缓存控制-Cache-Control" class="headerlink" title="3.3 3. 缓存控制 (Cache Control)"></a>3.3 3. 缓存控制 (Cache Control)</h3><p>HTTP&#x2F;1.1 提供了强大而精细的缓存控制机制，避免重复下载相同的资源，显著提高了 Web 性能。</p>
<ul>
<li><strong>强缓存</strong>：当命中时，浏览器直接使用本地缓存，不与服务器通信。<ul>
<li><code>Cache-Control</code> 响应头：<ul>
<li><code>max-age=&lt;seconds&gt;</code>：缓存的最大新鲜时间。</li>
<li><code>no-cache</code>：每次都向服务器验证缓存的有效性。</li>
<li><code>no-store</code>：不缓存任何内容。</li>
<li><code>public</code>：可以被任何缓存（包括代理服务器）缓存。</li>
<li><code>private</code>：只能被客户端浏览器缓存。</li>
</ul>
</li>
<li><code>Expires</code> 响应头：指定缓存的绝对过期时间 (HTTP&#x2F;1.0 产物，优先级低于 <code>Cache-Control</code>)。</li>
</ul>
</li>
<li><strong>协商缓存</strong>：强缓存过期或未命中的情况下，浏览器带着缓存标识向服务器询问资源是否改变，如果未改变，服务器返回 304 状态码，浏览器使用本地缓存。<ul>
<li><code>Last-Modified</code> &#x2F; <code>If-Modified-Since</code>：<ul>
<li>服务器通过 <code>Last-Modified</code> 响应头告诉资源最后修改时间。</li>
<li>客户端在下次请求时，通过 <code>If-Modified-Since</code> 请求头携带此时间，服务器比对。</li>
</ul>
</li>
<li><code>ETag</code> &#x2F; <code>If-None-Match</code>：<ul>
<li>服务器通过 <code>ETag</code> 响应头提供资源的唯一标识符（通常是内容的哈希值）。</li>
<li>客户端在下次请求时，通过 <code>If-None-Match</code> 请求头携带此 ETag，服务器比对。<strong><code>ETag</code> 优先级高于 <code>Last-Modified</code>。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-4-范围请求-Range-Requests"><a href="#3-4-4-范围请求-Range-Requests" class="headerlink" title="3.4 4. 范围请求 (Range Requests)"></a>3.4 4. 范围请求 (Range Requests)</h3><p>允许客户端只请求资源的特定一部分，而不是整个资源。</p>
<ul>
<li>客户端通过 <code>Range</code> 请求头指定请求的字节范围，例如 <code>Range: bytes=0-1023</code>。</li>
<li>服务器如果支持，会返回 <code>206 Partial Content</code> 状态码，并在 <code>Content-Range</code> 响应头中指定返回的范围，响应体中只包含请求的部分数据。</li>
<li><strong>应用场景</strong>：断点续传、多线程下载、音视频流媒体（按需加载）。</li>
</ul>
<h3 id="3-5-5-Host-头"><a href="#3-5-5-Host-头" class="headerlink" title="3.5 5. Host 头"></a>3.5 5. Host 头</h3><p>HTTP&#x2F;1.1 <strong>强制</strong>要求客户端在请求中包含 <code>Host</code> 头，指定请求的目标域名。</p>
<ul>
<li><strong>作用</strong>：使得可以在同一台服务器（同一个 IP 地址）上托管多个域名不同的网站（虚拟主机）。服务器根据 <code>Host</code> 头来区分不同的站点，从而将请求路由到正确的应用程序。</li>
</ul>
<h3 id="3-6-6-更多的状态码和请求方法"><a href="#3-6-6-更多的状态码和请求方法" class="headerlink" title="3.6 6. 更多的状态码和请求方法"></a>3.6 6. 更多的状态码和请求方法</h3><p>HTTP&#x2F;1.1 引入了更多细致的状态码，如 <code>100 Continue</code>、<code>206 Partial Content</code>、<code>409 Conflict</code>、<code>410 Gone</code> 等，以及 <code>OPTIONS</code>、<code>PUT</code>、<code>DELETE</code> 等请求方法，使得 HTTP API 设计更加灵活和语义化。</p>
<h2 id="四、HTTP-1-1-的优缺点"><a href="#四、HTTP-1-1-的优缺点" class="headerlink" title="四、HTTP&#x2F;1.1 的优缺点"></a>四、HTTP&#x2F;1.1 的优缺点</h2><h3 id="4-1-优点："><a href="#4-1-优点：" class="headerlink" title="4.1 优点："></a>4.1 优点：</h3><ul>
<li><strong>广泛兼容性</strong>：作为 Web 的核心协议，拥有几乎无处不在的兼容性。</li>
<li><strong>相对高效</strong>：通过持久连接和缓存机制，在一定程度上解决了 HTTP&#x2F;1.0 的性能问题。</li>
<li><strong>简单易用</strong>：协议结构相对简单，易于理解和实现。</li>
<li><strong>功能丰富</strong>：支持虚拟主机、断点续传、更精细的缓存控制等。</li>
</ul>
<h3 id="4-2-缺点："><a href="#4-2-缺点：" class="headerlink" title="4.2 缺点："></a>4.2 缺点：</h3><ul>
<li><strong>队头阻塞 (Head-of-Line Blocking)</strong>：尽管有管线化，但由于服务器必须按序响应，如果前一个请求响应慢，会阻塞后续请求的响应。</li>
<li><strong>单个 TCP 连接的限制</strong>：虽然持久连接减少了连接开销，但单个 TCP 连接在同一时间只能处理一个请求-响应对（即使管线化，也只是请求可以并发，响应仍是串行），为了提高并行度，浏览器通常会为同一个域名建立 6-8 个 TCP 连接。</li>
<li><strong>冗余头部</strong>：即使是持久连接，每次请求和响应仍携带完整的 HTTP 头部信息，这尤其对于小资源的频繁请求会造成带宽浪费。</li>
<li><strong>强制明文</strong>：HTTP 协议本身不提供加密，需要通过 HTTPS (HTTP over TLS&#x2F;SSL) 来实现安全传输。</li>
<li><strong>不支持服务器推送</strong>：服务器无法主动向客户端推送数据，需要客户端发起拉取。</li>
</ul>
<h2 id="五、HTTP-1-1-与后续版本的关系"><a href="#五、HTTP-1-1-与后续版本的关系" class="headerlink" title="五、HTTP&#x2F;1.1 与后续版本的关系"></a>五、HTTP&#x2F;1.1 与后续版本的关系</h2><ul>
<li><strong>HTTP&#x2F;2</strong>：于 2015 年发布，旨在解决 HTTP&#x2F;1.1 的队头阻塞、头部冗余和不支持服务器推送等问题。它引入了二进制分帧、多路复用、头部压缩、服务器推送等新特性，大幅提升了性能。</li>
<li><strong>HTTP&#x2F;3</strong>：于 2022 年发布，基于 QUIC 传输协议而非 TCP，进一步解决了传输层的队头阻塞问题，并在加密、连接迁移等方面有显著优势。</li>
</ul>
<p>尽管 HTTP&#x2F;2 和 HTTP&#x2F;3 提供了更优越的性能，但 HTTP&#x2F;1.1 仍是 Web 的基础协议。大部分的 Web 服务器和客户端仍然支持并广泛使用 HTTP&#x2F;1.1，并且许多高级协议（如 WebSocket 的握手）也依然利用了 HTTP&#x2F;1.1 的机制。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>HTTP&#x2F;1.1 作为一个成熟且强大的协议，是现代 Web 的基石，其引入的持久连接、缓存控制、Host 头等特性极大地推动了互联网的发展。理解 HTTP&#x2F;1.1 的工作原理、报文结构和核心特性，对于每一个 Web 开发者和网络工程师都至关重要。虽然更高版本的 HTTP 协议不断涌现，但 HTTP&#x2F;1.1 仍然以其坚实的基础和广泛的兼容性，在今天的网络世界中发挥着不可替代的作用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/378a51590e55/">https://blog.tbf1211.xx.kg/378a51590e55/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/a8d205bac226/" title="HTTP/2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTTP/2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a><a class="pagination-related" href="/10b74b4460f9/" title="Python 异步编程详解：从并发到协程"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python 异步编程详解：从并发到协程</div></div><div class="info-2"><div class="info-item-1"> Python 异步编程 是一种处理并发任务的编程范式，它允许程序在等待某些操作（如 I&#x2F;O 操作、网络请求、数据库查询）完成时，切换到执行其他任务，从而提高程序的吞吐量和响应速度。与传统的多线程&#x2F;多进程并发模型不同，异步编程通常使用协程 (Coroutines) 和事件循环 (Event Loop) 来实现，避免了线程&#x2F;进程切换的开销，也绕开了 Python 的全局解释器锁 (GIL) 对 CPU 密集型任务的限制（尽管异步编程主要适用于 I&#x2F;O 密集型任务）。  核心思想：异步编程通过在等待 I&#x2F;O 完成时“暂停”当前任务，并“切换”到其他可执行任务，从而在单线程内实现并发和最大化 I&#x2F;O 利用率。   一、为什么需要异步编程？传统的 Python 程序（同步阻塞式）在执行 I&#x2F;O 操作时会阻塞整个程序，直到 I&#x2F;O 完成。例如，一个 Web 服务器在处理一个耗时的网络请求时，就无法处理其他用户的请求，导致性能低下。 1.1 同步阻塞 (Synchronous Blocking)123456789...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6479020306f5/" title="HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="info-item-2">HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;3 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 QUIC (Quick UDP Internet Connections) 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全性及在复杂网络环境下的韧性，从而彻底改变 Web 资源的传输方式。  核心思想：HTTP&#x2F;3 运行在 QUIC 协议之上，而 QUIC 又运行在 UDP 协议之上。通过在传输层而非应用层引入多路复用、内置 TLS 1.3 加密、连接迁移等特性，HTTP&#x2F;3 提供了一个比 HTTP&#x2F;2 更快、更稳定、更安全的 Web 体验，尤其在移动网络和有损网络环境下表现突出。   一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景HTTP&#x2F;2 作为 HTTP&#x2F;1.1 的继任者，通过头部压缩、多路复用和服务器推送等机制，显著提升了...</div></div></div></a><a class="pagination-related" href="/a8d205bac226/" title="HTTP&#x2F;2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="info-item-2">HTTP&#x2F;2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a><a class="pagination-related" href="/abf64f03363d/" title="HTTP Upgrade 请求详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="info-item-2">HTTP Upgrade 请求详解</div></div><div class="info-2"><div class="info-item-1"> HTTP Upgrade 请求 是一种特殊的 HTTP&#x2F;1.1 机制，允许客户端和服务器在已经建立的 TCP 连接上，将当前协议从 HTTP&#x2F;1.1 切换到另一个不同的、更高级别的协议。最常见的应用场景是将 HTTP 连接升级到 WebSocket 协议，从而实现全双工、低延迟的持久连接。  核心思想：Upgrade 请求是 HTTP&#x2F;1.1 中用于协议协商的机制，允许在一个已有的 TCP 连接上，在客户端和服务器都同意的情况下，从 HTTP 切换到其他协议，避免了重新建立连接的开销，并开启更强大的通信模式。   一、为什么需要 HTTP Upgrade？HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 都是无状态的请求-响应协议。对于每个请求，客户端发送请求，服务器发送响应，然后连接可以关闭（非持久连接）或保持一段时间用于后续的 HTTP 请求（持久连接，Keep-Alive）。 这种请求-响应模式对于传统的 Web 页面浏览非常高效。然而，随着 Web 应用复杂度的增加，许多场景需要更高级的通信模式：  实时通信：聊天应用、在线游戏、...</div></div></div></a><a class="pagination-related" href="/bfc3178a0093/" title="FRP (Fast Reverse Proxy) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="info-item-2">FRP (Fast Reverse Proxy) 详解</div></div><div class="info-2"><div class="info-item-1"> FRP (Fast Reverse Proxy) 是一个高性能的内网穿透和反向代理工具，它允许您将位于内网（局域网）中的服务（如 Web 服务器、SSH、数据库等）通过一台具有公网 IP 的服务器暴露给公网用户访问。在当前 IPv4 地址资源日益紧张，许多家庭和小型办公室难以获取公网 IP 的背景下，FRP 提供了便捷、高效的解决方案。  核心思想：FRP 通过在公网服务器上运行一个 frps (服务端) 和在内网机器上运行一个 frpc (客户端) 来建立连接。内网流量经由 frpc 转发到 frps，再由 frps 转发到公网用户，实现内网服务的公网访问。   一、为什么需要 FRP？在许多场景下，我们需要从外部网络访问位于内网的服务，但常常面临以下问题：  没有公网 IP：大多数家庭宽带用户和一些小型企业用户不再拥有独立的公网 IPv4 地址。他们处于运营商的 NAT (Network Address Translation) 之后，无法直接从外部访问内网设备。 端口转发困难：即使有公网 IP，也可能需要手动在路由器上配置端口转发规则，这对于不熟悉网络配置的用户来说可能比...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/425bf08190fa/" title="TLS Encrypted Client Hello (ECH) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="info-item-2">TLS Encrypted Client Hello (ECH) 详解</div></div><div class="info-2"><div class="info-item-1"> TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。  核心思想：在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。   一、为什么需要 ECH？SNI 的隐私痛点在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：明文 SNI (Server Name Indication)。 1.1 SNI 的作用SNI 是 TLS 协议的一个扩展，用于解决虚拟主机 (Virtual Hosting) 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 example.com 和 another.c...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">527</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP-1-0-%E5%88%B0-HTTP-1-1-%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9A%E8%A7%A3%E5%86%B3%E7%97%9B%E7%82%B9"><span class="toc-text">一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81HTTP-1-1-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">二、HTTP&#x2F;1.1 的基本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.1 1. 请求-响应模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7%E4%B8%8E-Cookie"><span class="toc-text">2.2 2. 无状态性与 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5-Headers"><span class="toc-text">2.3 3. 头部字段 (Headers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E7%8A%B6%E6%80%81%E7%A0%81-Status-Codes"><span class="toc-text">2.4 4. 状态码 (Status Codes)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP-1-1-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">三、HTTP&#x2F;1.1 的核心新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5-Persistent-Connections"><span class="toc-text">3.1 1. 持久连接 (Persistent Connections)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E7%AE%A1%E7%BA%BF%E5%8C%96-Pipelining"><span class="toc-text">3.2 2. 请求管线化 (Pipelining)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6-Cache-Control"><span class="toc-text">3.3 3. 缓存控制 (Cache Control)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82-Range-Requests"><span class="toc-text">3.4 4. 范围请求 (Range Requests)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-Host-%E5%A4%B4"><span class="toc-text">3.5 5. Host 头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6-%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">3.6 6. 更多的状态码和请求方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81HTTP-1-1-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">四、HTTP&#x2F;1.1 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">4.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">4.2 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81HTTP-1-1-%E4%B8%8E%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">五、HTTP&#x2F;1.1 与后续版本的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>