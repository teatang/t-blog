<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Next.js 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Next.js 是一个基于 React 的开源 Web 框架，由 Vercel 公司开发并维护。它为 React 应用程序提供了生产级的特性，如服务器端渲染 (SSR)、静态站点生成 (SSG)、增量静态再生 (ISR)，以及文件系统路由、API 路由、图像优化等。Next.js 旨在提升 React 应用的性能、SEO 友好性、可维护性和开发体验，使开发者能够更高效地构建全栈式的现代 Web">
<meta property="og:type" content="article">
<meta property="og:title" content="Next.js 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/3ba66d6aee4f/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Next.js 是一个基于 React 的开源 Web 框架，由 Vercel 公司开发并维护。它为 React 应用程序提供了生产级的特性，如服务器端渲染 (SSR)、静态站点生成 (SSG)、增量静态再生 (ISR)，以及文件系统路由、API 路由、图像优化等。Next.js 旨在提升 React 应用的性能、SEO 友好性、可维护性和开发体验，使开发者能够更高效地构建全栈式的现代 Web">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2024-01-14T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-25T10:07:56.048Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="React">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="Next.js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Next.js 详解",
  "url": "https://blog.tbf1211.xx.kg/3ba66d6aee4f/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2024-01-14T22:24:00.000Z",
  "dateModified": "2026-02-25T10:07:56.048Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/3ba66d6aee4f/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Next.js 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">555</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Next.js 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Next.js 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-01-14T22:24:00.000Z" title="发表于 2024-01-15 06:24:00">2024-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Next.js</strong> 是一个基于 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://react.dev/">React</a> 的开源 <strong>Web 框架</strong>，由 Vercel 公司开发并维护。它为 React 应用程序提供了<strong>生产级</strong>的特性，如<strong>服务器端渲染 (SSR)</strong>、<strong>静态站点生成 (SSG)</strong>、<strong>增量静态再生 (ISR)</strong>，以及<strong>文件系统路由</strong>、<strong>API 路由</strong>、<strong>图像优化</strong>等。Next.js 旨在提升 React 应用的性能、SEO 友好性、可维护性和开发体验，使开发者能够更高效地构建全栈式的现代 Web 应用程序。</p>
</blockquote>
<div class="note info flat"><p>核心思想：在 React 的基础上提供一套完整的生产级解决方案，通过灵活的渲染策略和内置优化，帮助开发者构建高性能、SEO 友好且易于维护的 Web 应用。</p>
</div>
<hr>
<h2 id="一、核心特性与概念"><a href="#一、核心特性与概念" class="headerlink" title="一、核心特性与概念"></a>一、核心特性与概念</h2><p>Next.js 在 React 的基础上引入了许多强大的特性，极大地简化了 Web 应用的开发过程。</p>
<h3 id="1-1-强大的渲染策略-Rendering-Strategies"><a href="#1-1-强大的渲染策略-Rendering-Strategies" class="headerlink" title="1.1 强大的渲染策略 (Rendering Strategies)"></a>1.1 强大的渲染策略 (Rendering Strategies)</h3><p>Next.js 最引人注目的特性之一是其灵活的渲染策略。这允许开发者根据页面的内容和访问模式选择最合适的渲染方式，以优化性能和用户体验。</p>
<ul>
<li><p><strong>客户端渲染 (Client-Side Rendering, CSR)</strong>：</p>
<ul>
<li><strong>定义</strong>：类似于传统的 React 应用，浏览器下载 JavaScript 文件后，在客户端执行 JavaScript 代码来构建和渲染页面内容。</li>
<li><strong>特点</strong>：初始加载可能较慢，不利于 SEO（搜索引擎可能无法抓取 JS 渲染的内容）。适合数据频繁变动、用户登录后的私有页面。</li>
<li><strong>实现</strong>：在 React 组件中使用 <code>useEffect</code> 或 <code>useState</code> 钩子在组件挂载后获取数据。在 App Router 中，默认组件是服务器组件，需通过 <code>&quot;use client&quot;</code> 指令标记为客户端组件。</li>
</ul>
</li>
<li><p><strong>服务器端渲染 (Server-Side Rendering, SSR)</strong>：</p>
<ul>
<li><strong>定义</strong>：在每个用户请求到来时，Next.js 服务器都会在服务器端执行 React 组件，生成完整的 HTML 页面，然后将 HTML 发送到客户端。客户端接收到 HTML 页面后，React 客户端代码会将其“激活” (Hydration)，使其具备交互性。</li>
<li><strong>特点</strong>：首屏加载速度快，对 SEO 友好（能被搜索引擎完整抓取）。但每次请求都需要服务器生成 HTML，可能增加服务器负载。</li>
<li><strong>实现 (Pages Router)</strong>：在页面组件中导出异步函数 <code>getServerSideProps</code>。</li>
<li><strong>实现 (App Router)</strong>：默认所有组件都是服务器组件 (Server Components)，在组件内部直接使用 <code>await fetch()</code> 或其他异步逻辑即可。</li>
</ul>
</li>
<li><p><strong>静态站点生成 (Static Site Generation, SSG)</strong>：</p>
<ul>
<li><strong>定义</strong>：在<strong>构建时 (build time)</strong> 预先生成所有页面的 HTML 文件。这些静态 HTML 文件可以直接部署到 CDN (内容分发网络) 上，当用户请求页面时，CDN 直接返回预生成的 HTML。</li>
<li><strong>特点</strong>：访问速度极快，CDN 全球分发，服务器零负载，部署成本低，对 SEO 友好。适用于内容不经常更新的页面（如博客文章、产品详情页）。</li>
<li><strong>实现 (Pages Router)</strong>：在页面组件中导出异步函数 <code>getStaticProps</code> 和可选的 <code>getStaticPaths</code> (用于动态路由)。</li>
<li><strong>实现 (App Router)</strong>：通过在服务器组件中直接使用 <code>fetch()</code>，并配合 <code>revalidate</code> 选项（或在 <code>fetch</code> 选项中设置缓存行为）来实现静态数据获取。</li>
</ul>
</li>
<li><p><strong>增量静态再生 (Incremental Static Regeneration, ISR)</strong>：</p>
<ul>
<li><strong>定义</strong>：SSG 的增强。允许在应用部署后，按需（即当页面被访问时）在<strong>后台重新生成</strong>静态页面。当用户请求过期页面时，会先返回旧的静态页面（若有），同时触发后台重新生成新页面，下次请求时返回新页面。</li>
<li><strong>特点</strong>：结合了 SSG 的高性能和 SSR 的内容新鲜度。无需重新部署整个应用即可更新静态内容。</li>
<li><strong>实现 (Pages Router)</strong>：在 <code>getStaticProps</code> 返回的对象中添加 <code>revalidate</code> 属性，指定重新生成的时间间隔。</li>
<li><strong>实现 (App Router)</strong>：在 <code>fetch()</code> 调用中设置 <code>next: &#123; revalidate: &lt;seconds&gt; &#125;</code> 选项。</li>
</ul>
</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[User Request] --&gt; B{Next.js Server};
    subgraph Rendering Decisions
        B -- First Request &#x2F; Dynamic Data --&gt; C[SSR: Render on Server]
        B -- Static Data &#x2F; Build-Time --&gt; D[SSG: Serve Pre-built Static HTML]
        B -- Content Stale &#x2F; ISR --&gt; E[ISR: Serve Old&#x2F;Revalidate in Background]
        B -- Purely Interactive --&gt; F[CSR: Send JS, Render on Client]
    end
    C --&gt; G(Full HTML Page);
    D --&gt; G;
    E --&gt; G;
    F --&gt; H(Empty HTML + JS Bundle);
    G --&gt; I[Browser: Hydration&#x2F;Display]
    H --&gt; J[Browser: Execute JS, Fetch Data, Render Content];
  </pre></div>

<h3 id="1-2-文件系统路由-File-System-Routing"><a href="#1-2-文件系统路由-File-System-Routing" class="headerlink" title="1.2 文件系统路由 (File-System Routing)"></a>1.2 文件系统路由 (File-System Routing)</h3><p>Next.js 采用<strong>基于文件系统的路由</strong>，极大地简化了页面和 API 端点的创建。</p>
<ul>
<li><p><strong>Pages Router (旧版，但仍广泛使用)</strong>：在项目的 <code>pages</code> 目录下创建 <code>.js</code>, <code>.jsx</code>, <code>.ts</code>, <code>.tsx</code> 文件，即可自动生成对应的路由。</p>
<ul>
<li><code>pages/index.js</code> -&gt; <code>/</code></li>
<li><code>pages/about.js</code> -&gt; <code>/about</code></li>
<li><code>pages/blog/[slug].js</code> -&gt; <code>/blog/my-first-post</code> (动态路由)</li>
<li><code>pages/dashboard/[...params].js</code> -&gt; <code>/dashboard/settings/profile</code> (捕获所有路由)</li>
</ul>
</li>
<li><p><strong>App Router (Next.js 13+ 推出的推荐方式)</strong>：在项目的 <code>app</code> 目录下创建目录结构，内部的 <code>page.js</code> 或 <code>page.tsx</code> 文件代表路由段。</p>
<ul>
<li><code>app/page.tsx</code> -&gt; <code>/</code></li>
<li><code>app/about/page.tsx</code> -&gt; <code>/about</code></li>
<li><code>app/blog/[slug]/page.tsx</code> -&gt; <code>/blog/my-first-post</code> (动态路由)</li>
<li><code>app/dashboard/[[...params]]/page.tsx</code> -&gt; <code>/dashboard</code>, <code>/dashboard/settings</code>, <code>/dashboard/settings/profile</code> (可选捕获所有路由)</li>
<li>还支持 <code>layout.tsx</code> (布局), <code>loading.tsx</code> (加载状态), <code>error.tsx</code> (错误边界), <code>template.tsx</code> (模板) 等特殊文件。</li>
</ul>
</li>
</ul>
<h3 id="1-3-API-路由-API-Routes"><a href="#1-3-API-路由-API-Routes" class="headerlink" title="1.3 API 路由 (API Routes)"></a>1.3 API 路由 (API Routes)</h3><p>Next.js 允许在同一个项目中创建后端 API 端点，而无需搭建单独的后端服务器。</p>
<ul>
<li><strong>Pages Router</strong>：在 <code>pages/api</code> 目录下创建文件，例如 <code>pages/api/hello.js</code>。</li>
<li><strong>App Router</strong>：在 <code>app</code> 路由段中创建 <code>route.ts</code> 或 <code>route.js</code> 文件，例如 <code>app/api/users/route.ts</code>。</li>
<li><strong>特点</strong>：可以使用 Node.js 环境的所有能力，处理 HTTP 请求 (GET, POST, PUT, DELETE)，与数据库交互，处理认证等。</li>
</ul>
<h3 id="1-4-图像优化-Image-Optimization"><a href="#1-4-图像优化-Image-Optimization" class="headerlink" title="1.4 图像优化 (Image Optimization)"></a>1.4 图像优化 (Image Optimization)</h3><p>Next.js 通过内置的 <code>&lt;Image&gt;</code> 组件自动优化图片，极大地提升了网页加载性能。</p>
<ul>
<li><strong>自动优化</strong>：根据设备尺寸按需加载图片，支持 WebP 等现代格式，自动进行尺寸调整和压缩。</li>
<li><strong>懒加载</strong>：图片只有进入视口时才加载，减少初始加载时间。</li>
<li><strong>布局移位防止</strong>：使用占位符，防止图片加载时页面内容跳动，优化用户体验。</li>
</ul>
<h3 id="1-5-样式与-CSS-支持-Styling-and-CSS-Support"><a href="#1-5-样式与-CSS-支持-Styling-and-CSS-Support" class="headerlink" title="1.5 样式与 CSS 支持 (Styling and CSS Support)"></a>1.5 样式与 CSS 支持 (Styling and CSS Support)</h3><p>Next.js 对多种样式方案提供了良好支持：</p>
<ul>
<li><strong>CSS Modules</strong>: 默认支持，为每个组件生成局部作用域的 CSS 类名，避免样式冲突。</li>
<li><strong>Styled-JSX</strong>: 内置支持，允许在 React 组件内部编写带作用域的 CSS。</li>
<li><strong>Sass&#x2F;Less</strong>: 通过安装相应的 loader 支持预处理器。</li>
<li><strong>Tailwind CSS</strong>: 广泛使用的原子化 CSS 框架，与 Next.js 集成良好。</li>
<li><strong>Global CSS</strong>: 可以通过 <code>pages/_app.js</code> (Pages Router) 或 <code>app/layout.tsx</code> (App Router) 引入全局 CSS。</li>
</ul>
<h3 id="1-6-数据获取-Data-Fetching"><a href="#1-6-数据获取-Data-Fetching" class="headerlink" title="1.6 数据获取 (Data Fetching)"></a>1.6 数据获取 (Data Fetching)</h3><p>除了渲染策略中提到的数据获取方式，Next.js App Router 引入了更强大的数据获取范式：</p>
<ul>
<li><strong>服务器组件中的 <code>fetch()</code></strong>: 在 App Router 中，默认的 Server Components 可以直接使用原生的 <code>fetch()</code> API 进行数据获取。Next.js 会自动优化这些 <code>fetch</code> 请求，进行缓存、去重，并支持 <code>async/await</code>。</li>
<li><strong><code>revalidate</code> 选项</strong>: 无论是 Pages Router (在 <code>getStaticProps</code> 返回) 还是 App Router (在 <code>fetch</code> 选项中)，都可以通过设置 <code>revalidate</code> 参数来实现 ISR。</li>
</ul>
<h3 id="1-7-中间件-Middleware"><a href="#1-7-中间件-Middleware" class="headerlink" title="1.7 中间件 (Middleware)"></a>1.7 中间件 (Middleware)</h3><p>Next.js 允许开发者在请求完成之前执行代码，从而重写、重定向或修改请求头。</p>
<ul>
<li><strong>定义</strong>：在 <code>middleware.ts</code> 或 <code>middleware.js</code> 文件中定义，拦截所有传入请求。</li>
<li><strong>用途</strong>：处理用户认证、国际化、A&#x2F;B 测试、机器人检测等，非常灵活。</li>
</ul>
<h2 id="二、App-Router-vs-Pages-Router"><a href="#二、App-Router-vs-Pages-Router" class="headerlink" title="二、App Router vs. Pages Router"></a>二、App Router vs. Pages Router</h2><p>Next.js 13+ 推出了全新的 <strong>App Router</strong>，它代表了 Next.js 及 React 生态的未来方向。理解其与传统 <strong>Pages Router</strong> 的区别至关重要。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Pages Router</th>
<th align="left">App Router (Next.js 13+)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>文件结构</strong></td>
<td align="left"><code>pages/</code> 目录，每个文件代表一个路由</td>
<td align="left"><code>app/</code> 目录，每个目录段代表一个路由，内部的 <code>page.tsx</code> 代表路由的 UI</td>
</tr>
<tr>
<td align="left"><strong>组件类型</strong></td>
<td align="left">默认是客户端组件，可在 <code>getServerSideProps</code> 或 <code>getStaticProps</code> 中获取数据</td>
<td align="left">默认是 <strong>服务器组件 (Server Components, RSC)</strong>，通过 <code>&quot;use client&quot;</code> 标记客户端组件</td>
</tr>
<tr>
<td align="left"><strong>数据获取</strong></td>
<td align="left"><code>getServerSideProps</code>, <code>getStaticProps</code>, <code>getStaticPaths</code>, <code>useEffect</code> + <code>fetch</code></td>
<td align="left">服务器组件中直接 <code>await fetch()</code>，自动缓存和去重；客户端组件中 <code>useEffect</code> + <code>fetch</code></td>
</tr>
<tr>
<td align="left"><strong>API 路由</strong></td>
<td align="left"><code>pages/api/</code> 目录下创建文件</td>
<td align="left"><code>app/</code> 路由段中创建 <code>route.ts</code> 文件</td>
</tr>
<tr>
<td align="left"><strong>布局管理</strong></td>
<td align="left"><code>pages/_app.js</code> (全局) 和组件内手动布局</td>
<td align="left">统一的 <code>layout.tsx</code> (嵌套布局、共享状态)，<code>template.tsx</code>, <code>loading.tsx</code>, <code>error.tsx</code> 等特殊文件</td>
</tr>
<tr>
<td align="left"><strong>流式传输</strong></td>
<td align="left">不支持</td>
<td align="left">通过 React Suspense 支持流式传输，分块发送 UI，提升用户感知性能</td>
</tr>
<tr>
<td align="left"><strong>路由模式</strong></td>
<td align="left">基于文件，相对简单</td>
<td align="left">基于文件夹，支持更复杂的布局和路由结构，支持并行路由和拦截路由</td>
</tr>
<tr>
<td align="left"><strong>优点</strong></td>
<td align="left">教程多，社区成熟，许多现有项目仍使用</td>
<td align="left"><strong>性能更优</strong> (更少 JS 发送到客户端)，<strong>更好的开发体验</strong> (无需繁琐的数据获取函数)，<strong>更灵活</strong> (RSC)，<strong>可伸缩性强</strong></td>
</tr>
<tr>
<td align="left"><strong>缺点</strong></td>
<td align="left">通常发送更多 JS 到客户端，数据获取模式分散</td>
<td align="left">新范式，学习曲线陡峭，生态系统仍在发展，部分库兼容性问题</td>
</tr>
</tbody></table>
<p><strong>推荐</strong>：对于新项目，强烈建议使用 App Router。它代表了 React 和 Next.js 的未来方向，能够带来更优的性能和更一致的开发体验。对于现有 Pages Router 项目，可以根据需求逐步迁移。</p>
<h2 id="三、代码示例"><a href="#三、代码示例" class="headerlink" title="三、代码示例"></a>三、代码示例</h2><p>为了演示 Next.js 的核心特性，我们将分别展示 Pages Router 和 App Router 的一些典型代码片段。</p>
<h3 id="3-1-Pages-Router-Legacy-示例"><a href="#3-1-Pages-Router-Legacy-示例" class="headerlink" title="3.1 Pages Router (Legacy) 示例"></a>3.1 Pages Router (Legacy) 示例</h3><p><strong>1. 静态页面 with <code>getStaticProps</code> (SSG)</strong><br><code>pages/posts/[id].tsx</code></p>
<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/posts/[id].tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetStaticProps</span>, <span class="title class_">GetStaticPaths</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">content</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PostProps</span> &#123;</span><br><span class="line">  <span class="attr">post</span>: <span class="title class_">Post</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">PostDetail</span>(<span class="params">&#123; post &#125;: <span class="title class_">PostProps</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!post) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading or Post not found...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;post.content&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构建时生成所有可能的 ID 路径</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticPaths</span>: <span class="title class_">GetStaticPaths</span> = <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 模拟从 API 获取所有文章的 ID</span></span><br><span class="line">  <span class="keyword">const</span> posts = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;First Post&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;...&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Second Post&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;...&#x27;</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> paths = posts.<span class="title function_">map</span>(<span class="function">(<span class="params">post</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">id</span>: post.<span class="property">id</span> &#125;,</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: <span class="literal">false</span> &#125;; <span class="comment">// fallback: false 意味着不会生成未定义的路径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构建时获取每个 ID 对应的文章数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getStaticProps</span>: <span class="title class_">GetStaticProps</span>&lt;<span class="title class_">PostProps</span>&gt; = <span class="title function_">async</span> (&#123; params &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> id = params?.<span class="property">id</span> <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 模拟从数据库或 API 获取特定 ID 的文章</span></span><br><span class="line">  <span class="keyword">const</span> post = &#123;</span><br><span class="line">    <span class="attr">id</span>: id,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">`Post <span class="subst">$&#123;id&#125;</span> Title`</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">`This is the content for post number <span class="subst">$&#123;id&#125;</span>.`</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123; post &#125;,</span><br><span class="line">    <span class="comment">// revalidate: 60 // 可选：每 60 秒尝试在后台重新生成一次页面 (ISR)</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 服务器渲染页面 with <code>getServerSideProps</code> (SSR)</strong><br><code>pages/ssr-example.tsx</code></p>
<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/ssr-example.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">GetServerSideProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ServerDataProps</span> &#123;</span><br><span class="line">  <span class="attr">timestamp</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">userAgent</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">SSRExample</span>(<span class="params">&#123; timestamp, userAgent &#125;: <span class="title class_">ServerDataProps</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Server-Side Rendered Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Data fetched on server for each request:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Timestamp: &#123;timestamp&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>User-Agent: &#123;userAgent&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次请求时在服务器端获取数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">getServerSideProps</span>: <span class="title class_">GetServerSideProps</span>&lt;<span class="title class_">ServerDataProps</span>&gt; = <span class="title function_">async</span> (context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> userAgent = context.<span class="property">req</span>.<span class="property">headers</span>[<span class="string">&#x27;user-agent&#x27;</span>] || <span class="string">&#x27;Unknown&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> timestamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里可以进行数据库查询、API 调用等服务器端操作</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      timestamp,</span><br><span class="line">      userAgent,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>3. API 路由</strong><br><code>pages/api/getTime.ts</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/api/getTime.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"><span class="attr">req</span>: <span class="title class_">NextApiRequest</span>, <span class="attr">res</span>: <span class="title class_">NextApiResponse</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">method</span> === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123; <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>() &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Allow&#x27;</span>, [<span class="string">&#x27;GET&#x27;</span>]);</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">405</span>).<span class="title function_">end</span>(<span class="string">`Method <span class="subst">$&#123;req.method&#125;</span> Not Allowed`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-App-Router-推荐-示例"><a href="#3-2-App-Router-推荐-示例" class="headerlink" title="3.2 App Router (推荐) 示例"></a>3.2 App Router (推荐) 示例</h3><p><strong>1. 默认服务器组件 (Server Component) 页面 &#x2F; 数据获取</strong><br><code>app/page.tsx</code></p>
<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/page.tsx</span></span><br><span class="line"><span class="comment">// 这是一个服务器组件 (默认)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getFortune</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 直接在服务器组件中进行数据获取，Next.js 会自动优化 (缓存/去重)</span></span><br><span class="line">  <span class="comment">// 默认为 SSG 行为（如果不是动态参数且不设置 revalidate）</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.kanye.rest/&#x27;</span>, &#123; <span class="attr">next</span>: &#123; <span class="attr">revalidate</span>: <span class="number">3600</span> &#125; &#125;); <span class="comment">// ISR: 每小时重新验证</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data.<span class="property">quote</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fortune = <span class="keyword">await</span> <span class="title function_">getFortune</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to Next.js App Router!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s a quote from Kanye West:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontStyle:</span> &#x27;<span class="attr">italic</span>&#x27;, <span class="attr">borderLeft:</span> &#x27;<span class="attr">3px</span> <span class="attr">solid</span> #<span class="attr">ccc</span>&#x27;, <span class="attr">paddingLeft:</span> &#x27;<span class="attr">10px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &quot;&#123;fortune&#125;&quot;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This page is rendered on the server.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* <span class="tag">&lt;<span class="name">ClientCounter</span> /&gt;</span> // 这里可以引入客户端组件 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 客户端组件 (Client Component)</strong><br><code>app/client-counter.tsx</code></p>
<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/client-counter.tsx</span></span><br><span class="line"><span class="string">&#x27;use client&#x27;</span>; <span class="comment">// 明确声明这是一个客户端组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ClientCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border:</span> &#x27;<span class="attr">1px</span> <span class="attr">solid</span> #<span class="attr">eee</span>&#x27;, <span class="attr">padding:</span> &#x27;<span class="attr">15px</span>&#x27;, <span class="attr">marginTop:</span> &#x27;<span class="attr">20px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Client Component Example<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. API 路由 (<code>route.ts</code>)</strong><br><code>app/api/hello/route.ts</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/api/hello/route.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextRequest</span>, <span class="title class_">NextResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next/server&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">GET</span>(<span class="params"><span class="attr">request</span>: <span class="title class_">NextRequest</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; searchParams &#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>);</span><br><span class="line">  <span class="keyword">const</span> name = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) || <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NextResponse</span>.<span class="title function_">json</span>(&#123; <span class="attr">message</span>: <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">POST</span>(<span class="params"><span class="attr">request</span>: <span class="title class_">NextRequest</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> request.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NextResponse</span>.<span class="title function_">json</span>(&#123; <span class="attr">received</span>: data, <span class="attr">status</span>: <span class="string">&#x27;success&#x27;</span> &#125;, &#123; <span class="attr">status</span>: <span class="number">201</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 中间件 (Middleware)</strong><br><code>middleware.ts</code> (在项目根目录或 <code>src</code> 目录下)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// middleware.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">NextRequest</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next/server&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">middleware</span>(<span class="params"><span class="attr">request</span>: <span class="title class_">NextRequest</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isAuthenticated = request.<span class="property">cookies</span>.<span class="title function_">has</span>(<span class="string">&#x27;auth-token&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 示例：保护 /dashboard 路由</span></span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">nextUrl</span>.<span class="property">pathname</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;/dashboard&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAuthenticated) &#123;</span><br><span class="line">      <span class="comment">// 如果未认证，重定向到登录页</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">NextResponse</span>.<span class="title function_">redirect</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;/login&#x27;</span>, request.<span class="property">url</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 示例：重写 /legacy 路由到 /new-route</span></span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">nextUrl</span>.<span class="property">pathname</span> === <span class="string">&#x27;/legacy&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">NextResponse</span>.<span class="title function_">rewrite</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;/new-route&#x27;</span>, request.<span class="property">url</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NextResponse</span>.<span class="title function_">next</span>(); <span class="comment">// 继续请求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置中间件匹配的路径</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">matcher</span>: [<span class="string">&#x27;/dashboard/:path*&#x27;</span>, <span class="string">&#x27;/legacy&#x27;</span>], <span class="comment">// 匹配 /dashboard 及所有子路径，以及 /legacy 路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四、Next-js-的优点"><a href="#四、Next-js-的优点" class="headerlink" title="四、Next.js 的优点"></a>四、Next.js 的优点</h2><ol>
<li><strong>卓越性能</strong>：通过 SSR&#x2F;SSG&#x2F;ISR 等多种渲染方式，有效减少首屏加载时间，结合图像优化、代码分割等，提供极速的用户体验。</li>
<li><strong>SEO 友好</strong>：SSR 和 SSG 生成的 HTML 内容对搜索引擎爬虫非常友好，有利于网站在搜索结果中的排名。</li>
<li><strong>开发者体验 (DX)</strong>：<ul>
<li><strong>文件系统路由</strong>：直观且易于维护。</li>
<li><strong>快速刷新 (Fast Refresh)</strong>：开发过程中代码改动后，页面能够快速更新，保持应用状态。</li>
<li><strong>内置工具</strong>：包括 Babel、Webpack (Vite 支持正在实验中) 配置，开箱即用。</li>
</ul>
</li>
<li><strong>全栈能力</strong>：通过 API 路由，开发者可以在同一个 Next.js 项目中构建前端和后端 API，简化了全栈开发的复杂性。</li>
<li><strong>可伸缩性与灵活性</strong>：渲染策略的灵活性使得 Next.js 能够适应各种规模和类型的项目。App Router 引入的服务器组件进一步提升了状态管理和数据获取的可伸缩性。</li>
<li><strong>强大的社区与生态系统</strong>：作为最受欢迎的 React 框架之一，拥有庞大活跃的社区，丰富的插件和完善的文档。</li>
<li><strong>未来前端趋势</strong>：App Router 和 React Server Components (RSC) 代表了 React 的发展方向，Next.js 是率先将其落地并实践的框架。</li>
</ol>
<h2 id="五、Next-js-的缺点与考虑"><a href="#五、Next-js-的缺点与考虑" class="headerlink" title="五、Next.js 的缺点与考虑"></a>五、Next.js 的缺点与考虑</h2><ol>
<li><strong>学习曲线</strong>：对于没有 React 经验的开发者，需要同时学习 React 和 Next.js 的框架概念。尤其是 App Router 和 Server Components 的新范式，可能需要时间适应。</li>
<li><strong>服务器成本</strong>：虽然 SSG 可以降低成本，但 SSR 或 ISR 功能的应用需要运行 Node.js 服务器，相较于纯静态网站可能会增加部署和维护成本。</li>
<li><strong>框架意见 (Opinionated)</strong>：Next.js 提供了一套推荐的开发模式和规范，可能对某些需要高度定制化构建工具或工作流的项目造成一定限制。</li>
<li><strong>打包体积 (Bundle Size)</strong>：尽管 Next.js 有很多优化，但其运行时代码和必要的 hydrate 脚本依然会增加初始 JS 包的体积，在极端轻量级场景下可能不如纯静态 HTML 或其他微型框架。</li>
<li><strong>数据中心地域性</strong>：对于需要严格数据主权或本地化部署的场景，如果利用 Vercel 等平台，其全球 CDN 和边缘计算优势可能无法完全发挥。</li>
</ol>
<h2 id="六、适用场景"><a href="#六、适用场景" class="headerlink" title="六、适用场景"></a>六、适用场景</h2><p>Next.js 适用于以下多种项目类型：</p>
<ul>
<li><strong>内容管理系统 (CMS) 驱动的网站</strong>：如博客、新闻站点、文档网站，通过 SSG&#x2F;ISR 可以实现高性能和 SEO 友好的内容展示。</li>
<li><strong>电商网站</strong>：产品列表、详情页等对 SEO 和首屏性能要求极高的场景，SSR&#x2F;SSG 结合 CSR 实现复杂交互。</li>
<li><strong>营销网站与企业官网</strong>：需要快速加载、良好 SEO 的品牌展示型网站。</li>
<li><strong>仪表盘或管理后台</strong>：通过 SSR 预渲染骨架，结合 CSR 实现丰富的交互逻辑。</li>
<li><strong>个人项目与小型 SaaS 产品</strong>：利用其全栈能力快速原型开发和部署。</li>
<li><strong>任何需要高性能和 SEO 的 React 应用</strong>。</li>
</ul>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Next.js 凭借其多样的渲染策略、内置优化、文件系统路由和全栈能力，已成为构建现代高性能 React 应用的首选框架。从早期的 Pages Router 到引入 React Server Components 的 App Router，Next.js 始终走在前端技术发展的前沿，致力于提高 Web 应用的性能、开发效率和用户体验。虽然学习新概念可能需要投入时间，但其带来的收益（尤其是性能和可维护性）通常是值得的。对于任何寻求构建高性能、SEO 友好且具有良好可伸缩性的 React Web 应用程序的开发者或团队来说，Next.js 都是一个极其强大的工具。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/3ba66d6aee4f/">https://blog.tbf1211.xx.kg/3ba66d6aee4f/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/Next-js/">Next.js</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ab5735004159/" title="无感刷新Token详解：提升用户体验与系统安全的认证策略"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">无感刷新Token详解：提升用户体验与系统安全的认证策略</div></div><div class="info-2"><div class="info-item-1"> 在现代 Web 和移动应用中，基于 Token 的认证方式（如 JWT）已成为主流。它解决了传统 Session-Cookie 认证在分布式系统和跨域场景下的诸多痛点。然而，Token 的有效期问题又带来了新的挑战：如果 Access Token 长期有效，一旦泄露风险巨大；如果短期有效，用户又会频繁因 Token 过期而被迫重新登录，严重影响用户体验。无感刷新 Token (Silent Token Refresh) 正是为了解决这一矛盾而生，它旨在提升安全性、兼顾用户体验，让用户在不感知的情况下，始终保持登录状态。  “无感刷新 Token 的核心思想是：使用一个短期有效的 Access Token 负责日常业务访问，同时使用一个长期有效但受严密保护的 Refresh Token 来在 Access Token 过期时重新获取新的 Access Token，从而实现长期登录且不牺牲安全性的目标。”   一、为什么需要无感刷新 Token？在基于 Token 的认证系统中，通常会涉及到两种 Token：  Access Token (访问令牌)：  用途：用于访问受保护的资源...</div></div></div></a><a class="pagination-related" href="/6842deb76626/" title="AWS Lambda与Serverless详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">AWS Lambda与Serverless详解</div></div><div class="info-2"><div class="info-item-1"> AWS Lambda 是亚马逊网络服务 (Amazon Web Services, AWS) 提供的核心 Serverless 计算服务，也是函数即服务 (Function-as-a-Service, FaaS) 的开创者和领导者。它允许开发者运行代码，而无需配置或管理服务器。开发者只需上传代码，Lambda 会自动处理运行代码所需的一切，包括容量预置、扩展、打补丁和维护。  核心思想：AWS Lambda 是 AWS Serverless 生态的核心，它将代码作为“函数”运行在无服务器环境中，由各种 AWS 事件触发，按需执行，自动伸缩，并按实际使用量计费。   一、AWS Lambda 概览AWS Lambda 于 2014 年推出，彻底改变了云计算的开发和部署模式。它让开发者能够将后端逻辑解耦为一系列独立、短生命周期的函数，从而极大地简化了运维。 1.1 Lambda 的核心概念 函数 (Function)：这是 Lambda 中的基本部署单元，包含你的代码和相关配置（如运行时、内存、超时时间、环境变量）。 事件 (Event)：触发 Lambda 函数执行的任何操作。事...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/57cc64e71afb/" title="Next.js Hydration 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="info-item-2">Next.js Hydration 详解</div></div><div class="info-2"><div class="info-item-1"> 在使用 Next.js 等服务器端渲染 (SSR) 或静态站点生成 (SSG) 框架时，Hydration (水合、激活) 是一个核心且至关重要的概念。它指的是在浏览器端，React 应用程序“接管”由服务器预先生成的静态 HTML 内容，使其从纯展示变为可交互的动态过程。理解 Hydration 对于优化 Next.js 应用的性能、解决常见的客户端-服务器不匹配问题以及充分利用 React Server Components (RSC) 的优势至关重要。  核心思想：将服务器或构建时生成的静态 HTML 页面，“激活”为完全可交互的客户端 React 应用程序。   一、什么是 Hydration？Hydration 是指 React (或Vue、Angular等前端框架) 在浏览器端将服务器端或构建时预先渲染的纯静态 HTML 内容，转换成一个可交互的动态 React 应用程序的过程。 想象一下这个过程：  服务器&#x2F;构建时：Next.js 在服务器上（对于 SSR）或在构建时（对于 SSG）运行你的 React 组件，生成一个完整的 HTML 字符串。这个 HT...</div></div></div></a><a class="pagination-related" href="/51210e3963c9/" title="Next.js 服务端组件 (RSC) 与客户端组件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-28</div><div class="info-item-2">Next.js 服务端组件 (RSC) 与客户端组件详解</div></div><div class="info-2"><div class="info-item-1"> 随着 React 18 引入的 Server Components (RSC) 和 Next.js 13+ App Router 的推出，前端的渲染模式和组件组织方式发生了根本性变化。理解服务端组件 (Server Components) 和客户端组件 (Client Components) 之间的差异、它们的工作原理以及何时使用它们，是掌握现代 Next.js 应用开发的关键。这种分离旨在优化性能、减少客户端 JavaScript 包大小、提升用户体验并简化服务器端数据获取。  核心思想：将组件的渲染工作按需划分到服务器端和客户端，以最大化性能优势、最小化客户端JS负载，并提升开发者体验。服务端组件是默认行为，旨在执行不依赖浏览器API和交互的逻辑；客户端组件则用于处理用户交互和浏览器侧功能。   一、概述：为何需要区分服务端和客户端组件？在传统的 React 应用中，所有组件（即使是那些只显示静态内容的组件）最终都会在客户端（浏览器）执行其渲染逻辑，并参与“水合”（hydration）过程。这意味着：  大 JavaScript 包：所有组件的代码都需要打包并发送到客户端，...</div></div></div></a><a class="pagination-related" href="/af1b623130b7/" title="Node.js package.json 文件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-28</div><div class="info-item-2">Node.js package.json 文件详解</div></div><div class="info-2"><div class="info-item-1"> package.json 文件是任何 Node.js 项目的核心。它是一个 JSON 格式的文件，包含了项目的元数据、依赖信息、脚本命令、版本控制等关键配置。它不仅是项目信息的载体，更是 npm (Node Package Manager) 或 yarn 等包管理器与项目交互的桥梁，定义了项目的身份、行为和依赖关系。  核心思想：package.json 是 Node.js 项目的清单文件，它描述了项目的所有关键信息，包括项目名称、版本、作者、许可证、脚本命令以及最重要的依赖关系。它是实现项目自动化、协作开发和依赖管理的基石。   一、为什么需要 package.json？package.json 在 Node.js 生态系统中扮演着至关重要的角色：  项目身份标识：提供项目的名称、版本、描述等基本信息，方便识别和管理。 依赖管理：记录项目所依赖的第三方模块及其版本范围，确保团队成员和部署环境使用相同的依赖，避免”在我机器上能跑”的问题。 脚本自动化：定义可执行的脚本命令（如启动服务器、运行测试、构建项目），简化开发流程和部署操作。 版本控制与发布：指导 npm 将项目发布到 ...</div></div></div></a><a class="pagination-related" href="/3d96d3f0f7cf/" title="JSX 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-01</div><div class="info-item-2">JSX 深度解析</div></div><div class="info-2"><div class="info-item-1"> JSX (JavaScript XML) 是一种 JavaScript 的语法扩展 (Syntactical Sugar)，它允许我们在 JavaScript 代码中书写与 XML 或 HTML 结构类似的标记。JSX 主要由 Facebook (现 Meta) 为 React 框架 引入，但它本身并不是 React 运行时的一部分，也不是浏览器原生支持的特性。它的核心作用是将声明式的 UI 结构融入到 JavaScript 逻辑中，使得组件的结构、属性和逻辑能够紧密结合，提升开发体验和代码可读性。  核心思想：在 JavaScript 中直观地描述 UI 结构，通过构建工具将其转换为标准的 JavaScript 函数调用，实现声明式编程。   一、为什么需要 JSX？在 React 诞生之前，或者在使用纯 JavaScript 手动构建 UI 时，通常需要通过 document.createElement() 或 React.createElement() 等函数来创建 DOM 元素或组件实例。这种命令式的创建方式在 UI 结构复杂时会导致代码冗长、难以阅读和维护： 传统创建...</div></div></div></a><a class="pagination-related" href="/039944c379a6/" title="GraphQL 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-31</div><div class="info-item-2">GraphQL 详解</div></div><div class="info-2"><div class="info-item-1"> GraphQL 是一种由 Facebook 于 2012 年开发并在 2015 年公开发布的 API 查询语言 (Query Language for APIs) 和 运行时 (Runtime)。它为客户端提供了精确指定所需数据结构的能力，并通过一个单一的、强类型定义的模式来描述数据。相较于传统的 RESTful API，GraphQL 旨在更高效、灵活地获取数据，尤其适用于复杂的数据模型和快速迭代的前端应用。  核心思想：由客户端决定需要什么数据，服务端根据客户端的请求精确地返回所需数据，不多也不少，从而解决传统 REST API 中常见的 过请求 (Over-fetching) 和 欠请求 (Under-fetching) 问题。   一、为什么需要 GraphQL？对 REST API 的挑战传统的 RESTful API 在构建可伸缩和高效率的现代应用时面临一些挑战：  过请求 (Over-fetching)：客户端经常获取到比实际需要更多的数据。例如，当只需要用户的姓名和邮箱时，一个 GET /users/&#123;id&#125; 接口可能返回用户的所有字段，包括...</div></div></div></a><a class="pagination-related" href="/00697282f2b9/" title="如何判断用户是否离开了当前页面"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-08</div><div class="info-item-2">如何判断用户是否离开了当前页面</div></div><div class="info-2"><div class="info-item-1"> 在前端开发中，有时我们需要在用户离开当前页面之前执行一些操作，例如保存用户未保存的数据、发送统计日志、弹出确认提示或清理资源。判断用户是否离开页面是一个常见的需求，但实现起来可能会有一些细微之处。本文将详细探讨几种在不同场景下判断用户离开页面的方法，并讨论它们的优缺点及适用场景。  核心思想：利用浏览器提供的事件监听器 (如 beforeunload, unload, pagehide, visibilitychange) 来监测页面生命周期状态，从而判断用户是刷新、关闭、切换标签页还是导航到其他页面。   一、页面生命周期事件概览在浏览器环境中，用户离开页面的行为会触发一系列的页面生命周期事件。理解这些事件是正确判断用户离开页面的基础。    事件名称 描述 触发时机 是否可取消 主要用途    beforeunload 在页面即将卸载之前触发，可以阻止页面卸载并显示确认弹窗。 用户尝试关闭、刷新、后退、导航到新页面等。浏览器主动调用 window.onbeforeunload = func。 是 (返回字符串或 event.returnValue) 提示用户保存未保存的数据...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">555</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text">一、核心特性与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%B8%B2%E6%9F%93%E7%AD%96%E7%95%A5-Rendering-Strategies"><span class="toc-text">1.1 强大的渲染策略 (Rendering Strategies)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B7%AF%E7%94%B1-File-System-Routing"><span class="toc-text">1.2 文件系统路由 (File-System Routing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-API-%E8%B7%AF%E7%94%B1-API-Routes"><span class="toc-text">1.3 API 路由 (API Routes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96-Image-Optimization"><span class="toc-text">1.4 图像优化 (Image Optimization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%A0%B7%E5%BC%8F%E4%B8%8E-CSS-%E6%94%AF%E6%8C%81-Styling-and-CSS-Support"><span class="toc-text">1.5 样式与 CSS 支持 (Styling and CSS Support)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96-Data-Fetching"><span class="toc-text">1.6 数据获取 (Data Fetching)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E4%B8%AD%E9%97%B4%E4%BB%B6-Middleware"><span class="toc-text">1.7 中间件 (Middleware)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81App-Router-vs-Pages-Router"><span class="toc-text">二、App Router vs. Pages Router</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">三、代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Pages-Router-Legacy-%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.1 Pages Router (Legacy) 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-App-Router-%E6%8E%A8%E8%8D%90-%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.2 App Router (推荐) 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Next-js-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">四、Next.js 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Next-js-%E7%9A%84%E7%BC%BA%E7%82%B9%E4%B8%8E%E8%80%83%E8%99%91"><span class="toc-text">五、Next.js 的缺点与考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">六、适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e3b0c5d197a/" title="Web Components 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Components 详解"/></a><div class="content"><a class="title" href="/4e3b0c5d197a/" title="Web Components 详解">Web Components 详解</a><time datetime="2026-02-07T22:24:00.000Z" title="发表于 2026-02-08 06:24:00">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>