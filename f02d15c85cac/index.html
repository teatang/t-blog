<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Server-Sent Events (SSE) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Server-Sent Events (SSE) 是一种 HTML5 规范，允许服务器通过持久的 HTTP 连接，以文本流 (text-stream) 的形式向客户端推送事件。它提供了一种高效、简单的方式来实现服务器到客户端的单向实时通信，特别适用于需要从服务器端持续获取数据更新的场景，如实时数据流、通知推送等。  核心思想：SSE 利用标准的 HTTP&#x2F;1.1 协议，通过一个持久的">
<meta property="og:type" content="article">
<meta property="og:title" content="Server-Sent Events (SSE) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/f02d15c85cac/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Server-Sent Events (SSE) 是一种 HTML5 规范，允许服务器通过持久的 HTTP 连接，以文本流 (text-stream) 的形式向客户端推送事件。它提供了一种高效、简单的方式来实现服务器到客户端的单向实时通信，特别适用于需要从服务器端持续获取数据更新的场景，如实时数据流、通知推送等。  核心思想：SSE 利用标准的 HTTP&#x2F;1.1 协议，通过一个持久的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-20.jpg">
<meta property="article:published_time" content="2023-04-14T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-09T10:11:24.606Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Web技术">
<meta property="article:tag" content="前端技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-20.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Server-Sent Events (SSE) 详解",
  "url": "https://blog.tbf1211.xx.kg/f02d15c85cac/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-20.jpg",
  "datePublished": "2023-04-14T22:24:00.000Z",
  "dateModified": "2025-12-09T10:11:24.606Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/f02d15c85cac/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Server-Sent Events (SSE) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">367</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">211</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">75</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-20.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Server-Sent Events (SSE) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Server-Sent Events (SSE) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-04-14T22:24:00.000Z" title="发表于 2023-04-15 06:24:00">2023-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/Web%E6%8A%80%E6%9C%AF/">Web技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/f02d15c85cac/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Server-Sent Events (SSE)</strong> 是一种 HTML5 规范，允许服务器通过持久的 HTTP 连接，以文本流 (text-stream) 的形式向客户端推送事件。它提供了一种高效、简单的方式来实现服务器到客户端的<strong>单向实时通信</strong>，特别适用于需要从服务器端持续获取数据更新的场景，如实时数据流、通知推送等。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>SSE 利用标准的 HTTP&#x2F;1.1 协议，通过一个持久的 GET 请求建立连接，服务器端持续向客户端发送带有特定格式的数据流，客户端通过 <code>EventSource</code> API 监听并处理这些事件。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-SSE？-实时通信的演进"><a href="#一、为什么需要-SSE？-实时通信的演进" class="headerlink" title="一、为什么需要 SSE？(实时通信的演进)"></a>一、为什么需要 SSE？(实时通信的演进)</h2><p>在 Web 应用中，实现服务器向客户端的实时数据推送一直是开发者面临的挑战。随着技术的发展，出现了多种解决方案，SSE 是其中一种重要的选择。</p>
<h3 id="1-1-传统轮询-Polling"><a href="#1-1-传统轮询-Polling" class="headerlink" title="1.1 传统轮询 (Polling)"></a>1.1 传统轮询 (Polling)</h3><ul>
<li><strong>定义</strong>：客户端定期（如每隔几秒）向服务器发送 HTTP 请求，询问是否有新的数据。</li>
<li><strong>优点</strong>：实现简单，兼容性好。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>效率低下</strong>：大多数请求可能是无效的（无新数据），造成大量不必要的 HTTP 请求和服务器资源浪费。</li>
<li><strong>延迟高</strong>：数据的实时性取决于轮询间隔，间隔越长延迟越高。</li>
</ul>
</li>
</ul>
<h3 id="1-2-长轮询-Long-Polling"><a href="#1-2-长轮询-Long-Polling" class="headerlink" title="1.2 长轮询 (Long Polling)"></a>1.2 长轮询 (Long Polling)</h3><ul>
<li><strong>定义</strong>：客户端发送 HTTP 请求后，服务器会保持连接打开，直到有新数据可用或达到超时时间。一旦有数据，服务器立即响应并关闭连接，客户端收到数据后会立即发起新的请求。</li>
<li><strong>优点</strong>：比传统轮询更高效，延迟较低。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>复杂性增加</strong>：服务器需要维护大量挂起的连接。</li>
<li><strong>仍然是请求-响应模式</strong>：本质上仍然是客户端发起请求，服务器响应，没有真正实现服务器主动推送。</li>
<li><strong>资源消耗</strong>：每个连接都需要服务器资源，尤其在大量并发下。</li>
</ul>
</li>
</ul>
<h3 id="1-3-WebSocket-的挑战"><a href="#1-3-WebSocket-的挑战" class="headerlink" title="1.3 WebSocket 的挑战"></a>1.3 WebSocket 的挑战</h3><ul>
<li><strong>定义</strong>：WebSocket 是一种全双工通信协议，它在单个 TCP 连接上提供双向通信通道。</li>
<li><strong>优点</strong>：真正实现了双向实时通信，效率高，延迟低。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>协议升级</strong>：需要从 HTTP 协议升级，不能直接复用 HTTP&#x2F;1.1 的全部特性。</li>
<li><strong>实现复杂</strong>：相对于 SSE，客户端和服务器端实现 WebSocket 的代码通常更复杂。</li>
<li><strong>开销</strong>：对于只需要服务器单向推送的场景，WebSocket 的双向能力可能是一种不必要的开销。</li>
</ul>
</li>
</ul>
<h3 id="1-4-SSE-的定位"><a href="#1-4-SSE-的定位" class="headerlink" title="1.4 SSE 的定位"></a>1.4 SSE 的定位</h3><p>针对只需要服务器向客户端单向推送数据的场景，SSE 提供了一个优雅且轻量级的解决方案：它基于标准的 HTTP&#x2F;1.1 协议，避免了 WebSocket 的复杂性，同时解决了传统轮询和长轮询的效率和延迟问题。</p>
<h2 id="二、SSE-核心概念与工作原理"><a href="#二、SSE-核心概念与工作原理" class="headerlink" title="二、SSE 核心概念与工作原理"></a>二、SSE 核心概念与工作原理</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Server-Sent Events (SSE)</strong> 允许服务器通过一个持久的 HTTP 连接向客户端推送事件。这个连接在服务器端被保持打开状态，当有新事件发生时，服务器将事件数据以文本流的形式写入响应体，客户端则通过 <code>EventSource</code> 对象接收这些事件。</p>
<h3 id="2-2-MIME-类型"><a href="#2-2-MIME-类型" class="headerlink" title="2.2 MIME 类型"></a>2.2 MIME 类型</h3><p>SSE 连接使用特定的 MIME 类型：<code>Content-Type: text/event-stream</code>。这是浏览器识别 SSE 流的关键。</p>
<h3 id="2-3-数据格式"><a href="#2-3-数据格式" class="headerlink" title="2.3 数据格式"></a>2.3 数据格式</h3><p>SSE 的数据流是 UTF-8 编码的文本，由一系列事件组成。每个事件由一个或多个字段（field）组成，以换行符 (<code>\n</code>) 结束，事件之间用两个换行符 (<code>\n\n</code>) 分隔。<br>SSE 规范定义了四种标准字段：</p>
<ul>
<li><p><strong><code>data:</code></strong>：事件数据。可以有多行 <code>data</code> 字段，它们会被连接成一个字符串，以 <code>\n</code> 分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data: 第一行数据</span><br><span class="line">data: 第二行数据</span><br></pre></td></tr></table></figure>
<p>客户端接收到的数据将是 “第一行数据\n第二行数据”。</p>
</li>
<li><p><strong><code>event:</code></strong>：事件类型。允许客户端对不同类型的事件使用不同的事件监听器。如果省略，默认事件类型为 <code>message</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event: stockUpdate</span><br><span class="line">data: &#123;&quot;symbol&quot;: &quot;GOOG&quot;, &quot;price&quot;: 1500&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>id:</code></strong>：事件 ID。用于在连接断开后，客户端自动重连时告知服务器从哪个 ID 开始发送事件，防止数据丢失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id: 123</span><br><span class="line">data: 新闻标题</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>retry:</code></strong>：重连间隔时间 (毫秒)。如果连接断开，客户端会等待此时间后再尝试重连。如果省略，浏览器通常默认为 3 秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">retry: 5000</span><br><span class="line">data: Ping</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>完整事件示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">event: userOnline</span><br><span class="line">id: 1001</span><br><span class="line">data: &#123;&quot;userId&quot;: &quot;alice&quot;, &quot;status&quot;: &quot;online&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: userOffline</span><br><span class="line">id: 1002</span><br><span class="line">data: &#123;&quot;userId&quot;: &quot;bob&quot;, &quot;status&quot;: &quot;offline&quot;&#125;</span><br><span class="line"></span><br><span class="line">data: 这是默认事件类型的消息</span><br><span class="line">data: 消息内容分多行</span><br><span class="line">id: 1003</span><br><span class="line"></span><br><span class="line">retry: 10000</span><br><span class="line">data: 这是一个带有重连时间的事件</span><br></pre></td></tr></table></figure>

<h3 id="2-4-连接生命周期"><a href="#2-4-连接生命周期" class="headerlink" title="2.4 连接生命周期"></a>2.4 连接生命周期</h3><ol>
<li><strong>建立连接</strong>：客户端通过 <code>new EventSource(url)</code> 发起一个 HTTP GET 请求，并设置 <code>Accept: text/event-stream</code>。</li>
<li><strong>服务器响应</strong>：服务器返回 <code>HTTP 200 OK</code>，并设置 <code>Content-Type: text/event-stream</code>、<code>Cache-Control: no-cache</code> 和 <code>Connection: keep-alive</code> 等响应头。</li>
<li><strong>数据推送</strong>：服务器保持连接打开，并在有新数据时，将格式化的事件数据写入响应体并刷新 (flush) 缓冲区。</li>
<li><strong>连接断开与重连</strong>：<ul>
<li>如果连接因网络问题、服务器关闭或客户端调用 <code>EventSource.close()</code> 而断开，客户端会尝试自动重连。</li>
<li>重连时，如果上次接收到的事件有 <code>id</code> 字段，浏览器会在请求头中携带 <code>Last-Event-ID</code>，服务器可以利用此信息从断点处恢复数据流。</li>
<li>重连间隔由 <code>retry</code> 字段控制。</li>
</ul>
</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: HTTP GET Request (Accept: text&#x2F;event-stream)
    Server--&gt;&gt;Client: HTTP 200 OK (Content-Type: text&#x2F;event-stream)
    loop Event Stream
        Server-&gt;&gt;Client: Send Event (id:1, event:stock, data:{&quot;GOOG&quot;:1500})
        Server-&gt;&gt;Client: Send Event (id:2, data:heartbeat)
    end
    alt Connection Lost (Network&#x2F;Server&#x2F;Client.close())
        Server--x Client: Connection closed
        Client-&gt;&gt;Server: (After &#39;retry&#39; time) HTTP GET Request (Last-Event-ID: 2)
        Server--&gt;&gt;Client: Resume event stream from ID 2
    end
  </pre></div>

<h2 id="三、客户端实现-JavaScript"><a href="#三、客户端实现-JavaScript" class="headerlink" title="三、客户端实现 (JavaScript)"></a>三、客户端实现 (JavaScript)</h2><p>客户端通过 <code>EventSource</code> API 接收和处理 SSE 事件。</p>
<h3 id="3-1-EventSource-API"><a href="#3-1-EventSource-API" class="headerlink" title="3.1 EventSource API"></a>3.1 <code>EventSource</code> API</h3><p>创建一个 <code>EventSource</code> 对象，并传入 SSE 服务的 URL：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;/events&#x27;</span>); <span class="comment">// 替换为你的 SSE 服务地址</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-事件监听"><a href="#3-2-事件监听" class="headerlink" title="3.2 事件监听"></a>3.2 事件监听</h3><p><code>EventSource</code> 对象提供了以下事件监听器：</p>
<ul>
<li><strong><code>onopen</code></strong>：连接成功建立时触发。</li>
<li><strong><code>onmessage</code></strong>：当服务器发送没有 <code>event</code> 字段的事件（默认 <code>message</code> 类型）时触发。<code>event.data</code> 包含数据内容。</li>
<li><strong><code>onerror</code></strong>：连接发生错误时触发，可能是网络错误、CORS 错误等。</li>
<li><strong>自定义事件监听</strong>：通过 <code>addEventListener()</code> 方法监听服务器发送的带有特定 <code>event</code> 字段的事件。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换为你的 SSE 服务地址</span></span><br><span class="line"><span class="keyword">const</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;/api/sse/stream&#x27;</span>); </span><br><span class="line"></span><br><span class="line">eventSource.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SSE 连接已建立。&quot;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eventSource.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理默认事件类型 (event: message) 的数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到默认消息:&quot;</span>, event.<span class="property">data</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;messageArea&#x27;</span>).<span class="property">innerHTML</span> += <span class="string">`&lt;p&gt;默认消息: <span class="subst">$&#123;data.content&#125;</span> (<span class="subst">$&#123;data.timestamp&#125;</span>)&lt;/p&gt;`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eventSource.<span class="title function_">addEventListener</span>(<span class="string">&#x27;chatMessage&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 event: chatMessage 类型的事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到聊天消息:&quot;</span>, event.<span class="property">data</span>, <span class="string">&quot;ID:&quot;</span>, event.<span class="property">lastEventId</span>);</span><br><span class="line">    <span class="keyword">const</span> chat = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;messageArea&#x27;</span>).<span class="property">innerHTML</span> += <span class="string">`&lt;p style=&quot;color: blue;&quot;&gt;Chat: <span class="subst">$&#123;chat.user&#125;</span>: <span class="subst">$&#123;chat.message&#125;</span> (<span class="subst">$&#123;chat.timestamp&#125;</span>)&lt;/p&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventSource.<span class="title function_">addEventListener</span>(<span class="string">&#x27;statusUpdate&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 event: statusUpdate 类型的事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到状态更新:&quot;</span>, event.<span class="property">data</span>);</span><br><span class="line">    <span class="keyword">const</span> status = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;messageArea&#x27;</span>).<span class="property">innerHTML</span> += <span class="string">`&lt;p style=&quot;color: green;&quot;&gt;Status: <span class="subst">$&#123;status.user&#125;</span> is now <span class="subst">$&#123;status.status&#125;</span> (<span class="subst">$&#123;status.timestamp&#125;</span>)&lt;/p&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventSource.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;SSE 连接发生错误:&quot;</span>, error);</span><br><span class="line">    <span class="comment">// 可以在这里处理错误，例如显示用户提示或尝试重新连接 (浏览器会自动尝试)</span></span><br><span class="line">    <span class="keyword">if</span> (eventSource.<span class="property">readyState</span> === <span class="title class_">EventSource</span>.<span class="property">CLOSED</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SSE 连接已关闭，浏览器将尝试重连...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端也可以主动关闭连接</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;closeButton&#x27;</span>).<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    eventSource.<span class="title function_">close</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SSE 连接已手动关闭。&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配合上述 JavaScript 示例的 HTML 结构 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE 客户端示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: sans-serif; <span class="attribute">margin</span>: <span class="number">20px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#messageArea</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">min-height</span>: <span class="number">200px</span>; <span class="attribute">margin-top</span>: <span class="number">20px</span>; <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123; <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>SSE 客户端<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>打开浏览器的开发者工具控制台，查看 SSE 事件。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;closeButton&quot;</span>&gt;</span>关闭 SSE 连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messageArea&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>等待服务器消息...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;client.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- 假设上述 JS 代码在 client.js 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-自动重连"><a href="#3-3-自动重连" class="headerlink" title="3.3 自动重连"></a>3.3 自动重连</h3><p>浏览器内置了自动重连机制。当连接断开时，浏览器会等待 <code>retry</code> 字段指定的时间（或默认 3 秒）后，自动发起新的 HTTP GET 请求尝试重连。如果服务器响应的事件包含 <code>id</code> 字段，浏览器会在重连请求的 <code>Last-Event-ID</code> HTTP 头中带上最后接收到的 <code>id</code>，方便服务器从断点处恢复推送。</p>
<h2 id="四、服务器端实现-Go-语言"><a href="#四、服务器端实现-Go-语言" class="headerlink" title="四、服务器端实现 (Go 语言)"></a>四、服务器端实现 (Go 语言)</h2><p>服务器端需要设置正确的响应头，并按照 SSE 规范格式化数据流，然后持续写入响应体。</p>
<p><strong>示例代码 (Go 使用 Gin 框架)</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 简单的路由用于提供 HTML 页面</span></span><br><span class="line">	router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.Data(http.StatusOK, <span class="string">&quot;text/html&quot;</span>, []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">			&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">			&lt;html lang=&quot;zh-CN&quot;&gt;</span></span><br><span class="line"><span class="string">			&lt;head&gt;</span></span><br><span class="line"><span class="string">				&lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">				&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">				&lt;title&gt;SSE 客户端示例&lt;/title&gt;</span></span><br><span class="line"><span class="string">				&lt;style&gt;</span></span><br><span class="line"><span class="string">					body &#123; font-family: sans-serif; margin: 20px; &#125;</span></span><br><span class="line"><span class="string">					#messageArea &#123; border: 1px solid #ccc; padding: 10px; min-height: 200px; margin-top: 20px; background-color: #f9f9f9; &#125;</span></span><br><span class="line"><span class="string">					p &#123; margin: 5px 0; &#125;</span></span><br><span class="line"><span class="string">				&lt;/style&gt;</span></span><br><span class="line"><span class="string">			&lt;/head&gt;</span></span><br><span class="line"><span class="string">			&lt;body&gt;</span></span><br><span class="line"><span class="string">				&lt;h1&gt;SSE 客户端&lt;/h1&gt;</span></span><br><span class="line"><span class="string">				&lt;p&gt;打开浏览器的开发者工具控制台，查看 SSE 事件。&lt;/p&gt;</span></span><br><span class="line"><span class="string">				&lt;button id=&quot;closeButton&quot;&gt;关闭 SSE 连接&lt;/button&gt;</span></span><br><span class="line"><span class="string">				&lt;div id=&quot;messageArea&quot;&gt;</span></span><br><span class="line"><span class="string">					&lt;p&gt;等待服务器消息...&lt;/p&gt;</span></span><br><span class="line"><span class="string">				&lt;/div&gt;</span></span><br><span class="line"><span class="string">				&lt;script&gt;</span></span><br><span class="line"><span class="string">					const eventSource = new EventSource(&#x27;/api/sse/stream&#x27;); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					eventSource.onopen = function(event) &#123;</span></span><br><span class="line"><span class="string">						console.log(&quot;SSE 连接已建立。&quot;, event);</span></span><br><span class="line"><span class="string">					&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					eventSource.onmessage = function(event) &#123;</span></span><br><span class="line"><span class="string">						console.log(&quot;收到默认消息:&quot;, event.data);</span></span><br><span class="line"><span class="string">						const data = JSON.parse(event.data);</span></span><br><span class="line"><span class="string">						document.getElementById(&#x27;messageArea&#x27;).innerHTML += `</span>&lt;p&gt;默认消息: $&#123;data.content&#125; ($&#123;data.timestamp&#125;)&lt;/p&gt;<span class="string">`;</span></span><br><span class="line"><span class="string">					&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					eventSource.addEventListener(&#x27;chatMessage&#x27;, function(event) &#123;</span></span><br><span class="line"><span class="string">						console.log(&quot;收到聊天消息:&quot;, event.data, &quot;ID:&quot;, event.lastEventId);</span></span><br><span class="line"><span class="string">						const chat = JSON.parse(event.data);</span></span><br><span class="line"><span class="string">						document.getElementById(&#x27;messageArea&#x27;).innerHTML += `</span>&lt;p style=<span class="string">&quot;color: blue;&quot;</span>&gt;Chat: $&#123;chat.user&#125;: $&#123;chat.message&#125; ($&#123;chat.timestamp&#125;)&lt;/p&gt;<span class="string">`;</span></span><br><span class="line"><span class="string">					&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					eventSource.addEventListener(&#x27;statusUpdate&#x27;, function(event) &#123;</span></span><br><span class="line"><span class="string">						console.log(&quot;收到状态更新:&quot;, event.data);</span></span><br><span class="line"><span class="string">						const status = JSON.parse(event.data);</span></span><br><span class="line"><span class="string">						document.getElementById(&#x27;messageArea&#x27;).innerHTML += `</span>&lt;p style=<span class="string">&quot;color: green;&quot;</span>&gt;Status: $&#123;status.user&#125; is now $&#123;status.status&#125; ($&#123;status.timestamp&#125;)&lt;/p&gt;<span class="string">`;</span></span><br><span class="line"><span class="string">					&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					eventSource.onerror = function(error) &#123;</span></span><br><span class="line"><span class="string">						console.error(&quot;SSE 连接发生错误:&quot;, error);</span></span><br><span class="line"><span class="string">						if (eventSource.readyState === EventSource.CLOSED) &#123;</span></span><br><span class="line"><span class="string">							console.log(&quot;SSE 连接已关闭，浏览器将尝试重连...&quot;);</span></span><br><span class="line"><span class="string">						&#125;</span></span><br><span class="line"><span class="string">					&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">					document.getElementById(&#x27;closeButton&#x27;).onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="string">						eventSource.close();</span></span><br><span class="line"><span class="string">						console.log(&quot;SSE 连接已手动关闭。&quot;);</span></span><br><span class="line"><span class="string">					&#125;;</span></span><br><span class="line"><span class="string">				&lt;/script&gt;</span></span><br><span class="line"><span class="string">			&lt;/body&gt;</span></span><br><span class="line"><span class="string">			&lt;/html&gt;</span></span><br><span class="line"><span class="string">		`</span>))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SSE 事件流处理器</span></span><br><span class="line">	router.GET(<span class="string">&quot;/api/sse/stream&quot;</span>, sseStreamHandler)</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;SSE Server started on :8080&quot;</span>)</span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sseStreamHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 设置响应头</span></span><br><span class="line">	c.Header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/event-stream&quot;</span>)</span><br><span class="line">	c.Header(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>)</span><br><span class="line">	c.Header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line">	c.Header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;identity&quot;</span>) <span class="comment">// 某些代理可能需要此头</span></span><br><span class="line">	<span class="comment">// CORS 允许所有源（根据实际需求调整）</span></span><br><span class="line">	c.Header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取客户端上次接收的事件 ID，用于重连后的数据恢复</span></span><br><span class="line">	lastEventID := c.GetHeader(<span class="string">&quot;Last-Event-ID&quot;</span>)</span><br><span class="line">	log.Printf(<span class="string">&quot;Client connected, Last-Event-ID: %s&quot;</span>, lastEventID)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Gin 的 Context.Writer 接口获取低层级的 http.ResponseWriter</span></span><br><span class="line">	<span class="comment">// 并断言其为 http.Flusher 接口，以便能够刷新缓冲区</span></span><br><span class="line">	flusher, ok := c.Writer.(http.Flusher)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		c.String(http.StatusInternalServerError, <span class="string">&quot;Streaming unsupported!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 发送 initial `retry` field (可选，但推荐)</span></span><br><span class="line">	<span class="comment">// 客户端在连接断开后会等待 5 秒重连</span></span><br><span class="line">	fmt.Fprintf(c.Writer, <span class="string">&quot;retry: 5000\n\n&quot;</span>) </span><br><span class="line">	flusher.Flush() <span class="comment">// 立即发送头部和 retry 配置</span></span><br><span class="line"></span><br><span class="line">	clientGone := c.Request.Context().Done() <span class="comment">// 监听客户端是否断开连接</span></span><br><span class="line"></span><br><span class="line">	eventID := <span class="number">0</span> <span class="comment">// 模拟事件 ID</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-clientGone:</span><br><span class="line">			log.Printf(<span class="string">&quot;Client disconnected, ID: %s&quot;</span>, lastEventID)</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// 客户端断开连接，终止推送</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			eventID++ <span class="comment">// 递增事件 ID</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 模拟发送不同类型的事件</span></span><br><span class="line">			currentTime := time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 默认事件 (event: message)</span></span><br><span class="line">			msg := fmt.Sprintf(<span class="string">`&#123;&quot;id&quot;: %d, &quot;content&quot;: &quot;Hello from server!&quot;, &quot;timestamp&quot;: &quot;%s&quot;&#125;`</span>, eventID, currentTime)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;id: %d\n&quot;</span>, eventID)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;data: %s\n\n&quot;</span>, msg)</span><br><span class="line">			flusher.Flush() <span class="comment">// 刷新缓冲区，确保数据立即发送</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 模拟发送 chatMessage 事件</span></span><br><span class="line">			eventID++</span><br><span class="line">			chatMsg := fmt.Sprintf(<span class="string">`&#123;&quot;id&quot;: %d, &quot;user&quot;: &quot;Alice&quot;, &quot;message&quot;: &quot;What&#x27;s up?&quot;, &quot;timestamp&quot;: &quot;%s&quot;&#125;`</span>, eventID, currentTime)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;id: %d\n&quot;</span>, eventID)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;event: chatMessage\n&quot;</span>)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;data: %s\n\n&quot;</span>, chatMsg)</span><br><span class="line">			flusher.Flush()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 模拟发送 statusUpdate 事件</span></span><br><span class="line">			eventID++</span><br><span class="line">			statusMsg := fmt.Sprintf(<span class="string">`&#123;&quot;id&quot;: %d, &quot;user&quot;: &quot;Bob&quot;, &quot;status&quot;: &quot;active&quot;, &quot;timestamp&quot;: &quot;%s&quot;&#125;`</span>, eventID, currentTime)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;id: %d\n&quot;</span>, eventID)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;event: statusUpdate\n&quot;</span>)</span><br><span class="line">			fmt.Fprintf(c.Writer, <span class="string">&quot;data: %s\n\n&quot;</span>, statusMsg)</span><br><span class="line">			flusher.Flush()</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 可以添加一个空心跳事件来保持连接活跃，防止某些代理关闭空闲连接</span></span><br><span class="line">			<span class="comment">// fmt.Fprintf(c.Writer, &quot;:keep-alive\n\n&quot;) // 这是注释形式的心跳</span></span><br><span class="line">			<span class="comment">// flusher.Flush()</span></span><br><span class="line"></span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 每 2 秒发送一次数据</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行 Go 服务器</strong>：</p>
<ol>
<li>确保 Go 环境已安装 Gin (<code>go get -u github.com/gin-gonic/gin</code>)。</li>
<li>将上述 Go 代码保存为 <code>main.go</code>。</li>
<li>在终端运行 <code>go run main.go</code>。</li>
<li>在浏览器中访问 <code>http://localhost:8080</code> 即可看到客户端页面并接收 SSE 事件。</li>
</ol>
<h2 id="五、SSE-的优缺点与适用场景"><a href="#五、SSE-的优缺点与适用场景" class="headerlink" title="五、SSE 的优缺点与适用场景"></a>五、SSE 的优缺点与适用场景</h2><h3 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h3><ul>
<li><strong>单向通信简单高效</strong>：专为服务器推送到客户端设计，实现简单，资源消耗相对较低。</li>
<li><strong>基于标准 HTTP&#x2F;1.1</strong>：复用现有 HTTP 基础设施（代理、防火墙），无需特殊协议或端口。</li>
<li><strong>自动重连机制</strong>：浏览器内置支持自动重连，并可通过 <code>Last-Event-ID</code> 恢复事件流，简化客户端代码。</li>
<li><strong>API 简单易用</strong>：客户端 <code>EventSource</code> API 直观易懂，上手快。</li>
<li><strong>可传递不同类型事件</strong>：通过 <code>event:</code> 字段，客户端可以针对不同类型的消息注册不同的处理函数。</li>
<li><strong>无需 WebSocket 的复杂性</strong>：避免了 WebSocket 握手和帧协议的开销，对于纯推送场景更轻量。</li>
</ul>
<h3 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h3><ul>
<li><strong>单向通信</strong>：无法通过同一通道将数据从客户端发送到服务器。如果需要双向通信，仍需结合其他 HTTP 请求或使用 WebSocket。</li>
<li><strong>仅支持 UTF-8 文本</strong>：只能传输文本数据，二进制数据需要进行编码（如 Base64），增加数据量。</li>
<li><strong>浏览器连接限制</strong>：大多数浏览器对同一域名的 SSE 连接数有限制（例如 Chrome 默认 6 个）。这可能在高并发场景下成为瓶颈。</li>
<li><strong>HTTP&#x2F;1.1 队头阻塞</strong>：由于基于 HTTP&#x2F;1.1，可能存在队头阻塞问题（虽然在 HTTP&#x2F;2 中有所缓解）。</li>
<li><strong>不适用于高并发短连接</strong>：维护大量长连接仍会消耗服务器资源，但在需要持续推送的场景下，其效率远高于轮询。</li>
</ul>
<h3 id="5-3-适用场景"><a href="#5-3-适用场景" class="headerlink" title="5.3 适用场景"></a>5.3 适用场景</h3><ul>
<li><strong>实时数据流</strong>：股票行情、加密货币价格、体育赛事比分、天气更新。</li>
<li><strong>新闻和社交媒体动态</strong>：实时新闻推送、社交媒体时间线更新。</li>
<li><strong>通知中心</strong>：系统通知、聊天应用消息提醒（如果聊天本身是基于 WebSocket，SSE 可用于通知）。</li>
<li><strong>长时任务进度更新</strong>：后台任务（如文件转换、数据导入导出）的实时进度反馈。</li>
<li><strong>服务器日志实时展示</strong>：将服务器日志实时推送到前端监控界面。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Server-Sent Events (SSE) 是 Web 实时通信领域的一个强大工具，它以其基于 HTTP 的简洁性和内置的重连机制，在需要服务器单向推送数据的场景中表现出色。虽然它不具备 WebSocket 的双向通信能力，但对于许多应用而言，这种单向流的效率和易用性足以满足需求。理解 SSE 的工作原理、数据格式以及如何在客户端和服务器端实现它，能帮助开发者构建响应迅速、用户体验良好的实时 Web 应用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/f02d15c85cac/">https://blog.tbf1211.xx.kg/f02d15c85cac/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Web%E6%8A%80%E6%9C%AF/">Web技术</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-20.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7cdd9f5b33c9/" title="前端项目工程化详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">前端项目工程化详解</div></div><div class="info-2"><div class="info-item-1"> 随着前端应用的复杂度日益增加，单纯依靠人工管理和协作已经无法满足高效、高质量开发的需求。前端工程化应运而生，它旨在通过将软件工程的思想和方法引入前端开发，构建一套系统化、标准化、自动化、体系化的解决方案，以提高开发效率、保障代码质量、降低维护成本。  前端工程化的核心思想是：以自动化取代人力，以工具取代重复劳动，以规范约束散漫。   一、什么是前端工程化？前端工程化是构建、管理和维护前端项目的实践和工具集。它涵盖了从项目初始化、开发、构建、测试到部署的整个生命周期，目标是提升团队协作效率、统一代码风格、保证项目质量、优化产物性能以及实现快速迭代。 它不仅仅是使用几个构建工具，更是一种体系化的思维方式和工作流。 二、为什么需要前端工程化？在没有工程化的时代，前端开发面临诸多挑战：  开发效率低下：手动重复任务（如文件合并、压缩），环境搭建复杂。 代码质量参差不齐：缺乏统一的代码规范和质量检查机制，导致 Bug 增多，难以维护。 团队协作困难：不同成员的代码风格差异大，冲突频繁，交接成本高。 项目性能不佳：缺乏自动化优化手段（如图片压缩、按需加载），页面加载慢。 部署上线复杂：手动...</div></div></div></a><a class="pagination-related" href="/8fad93ea4f62/" title="ALPN (Application-Layer Protocol Negotiation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ALPN (Application-Layer Protocol Negotiation) 详解</div></div><div class="info-2"><div class="info-item-1"> ALPN (Application-Layer Protocol Negotiation)，即应用层协议协商，是 TLS (传输层安全) 协议的一个扩展，允许客户端和服务器在进行 TLS 握手时，协商决定在加密连接上使用哪个应用层协议。它在 RFC 7301 中被定义。ALPN 的出现，极大地简化了现代网络协议的部署和使用，尤其是对于 HTTP&#x2F;2 和未来的 QUIC 等协议。  核心思想：ALPN 将应用层协议的选择过程集成到 TLS 握手阶段，使得在建立加密连接的同时，也完成了应用层协议的确定，避免了额外的往返延迟，并允许在同一端口上运行多种应用层协议。   一、为什么需要 ALPN？在 ALPN 出现之前，协商应用层协议通常面临以下挑战：  端口绑定：传统的做法是为不同的应用层协议使用不同的端口。例如，HTTP 使用 80 端口，HTTPS 使用 443 端口，FTP 使用 21 端口。当引入新的协议（如 HTTP&#x2F;2 或 SPDY）时，如果想与现有协议共存，就必须使用新的端口，这会增加防火墙配置、负载均衡设置的复杂性，并且用户可能需要记住非标准的端口...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/40c57ff5cb61/" title="Pug(前Jade)模板引擎详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="info-item-2">Pug(前Jade)模板引擎详解</div></div><div class="info-2"><div class="info-item-1"> Pug（发音 &#x2F;pʌɡ&#x2F;），前身为 Jade，是一个高性能的 Node.js 模板引擎。它以其简洁、富有表现力的语法而闻名，旨在让 HTML 编写变得更加高效和愉快。Pug 摒弃了传统 HTML 的尖括号和闭合标签，转而使用缩进和基于文本的语法，这使得模板文件更小、更易读、也更不易出错。  核心思想：Pug 通过简洁的缩进语法替代冗长的 HTML 标签，提供强大的动态数据渲染、代码重用和条件逻辑功能。   一、Pug 简介1.1 什么是模板引擎？模板引擎是一种将数据填充到预定义模板中以生成最终输出（通常是 HTML 字符串）的工具。它将页面的结构（模板）与数据分离，使得前端开发更加模块化和可维护。 1.2 Pug 的特点 独特语法：使用缩进表示嵌套关系，无需关闭标签。 简洁明了：代码量显著少于对应的 HTML。 强大功能：支持变量、循环、条件判断、Mixin（类似于函数或组件）、包含（文件复用）、布局继承等高级特性。 编译到 HTML：Pug 模板最终会被编译成标准的 HTML。 Node.js 支持：作为 Node.js 的模板引擎，Pug 完美集成于 E...</div></div></div></a><a class="pagination-related" href="/0c202b3d53be/" title="前端文件下载的各种方式的详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-19</div><div class="info-item-2">前端文件下载的各种方式的详解</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，文件下载是一个常见且重要的功能。无论是下载用户生成的数据、报告、图片，还是静态资源，前端开发者都需要掌握多种实现文件下载的方法。本文将详细探讨前端实现文件下载的各种技术，包括 HTML 原生方式、JavaScript 编程方式以及涉及服务器端配合的场景。  核心思想：前端文件下载的核心在于如何将文件数据（无论是服务器传输的还是客户端生成的）转化为可供浏览器识别并触发下载操作的格式（如 Blob 对象或直接的 URL），并通过特定的机制（如 &lt;a&gt; 标签的 download 属性或服务器响应头）来提示浏览器进行下载而非直接显示。   一、文件下载的基础概念在深入具体方法之前，我们先理解文件下载的一些基本概念：  下载 vs. 显示：浏览器在处理文件时，会根据 Content-Type 和 Content-Disposition 等 HTTP 响应头来决定是下载文件（保存到本地）还是在浏览器中直接显示（如图片、PDF）。 文件来源： 服务器端文件：文件存储在服务器上，前端通过 URL 请求获取。 客户端生成文件：文件内容由前端 JavaScript ...</div></div></div></a><a class="pagination-related" href="/234c44d5851b/" title="HTML5 单页面应用 (SPA) 路由实现详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="info-item-2">HTML5 单页面应用 (SPA) 路由实现详解</div></div><div class="info-2"><div class="info-item-1"> 单页面应用 (Single Page Application, SPA) 是一种 Web 应用程序模型，它通过动态重写当前页面而非从服务器加载整个新页面来实现与用户的交互。这种模式极大地提升了用户体验，使其更接近桌面应用。SPA 的核心技术之一是客户端路由 (Client-Side Routing)，它允许应用程序在不进行整页刷新的情况下，根据 URL 路径的变化渲染不同的视图。  核心思想：HTML5 History API 允许 Web 应用程序在客户端直接操纵浏览器会话历史记录，从而实现 URL 的无刷新更新和状态管理，这是现代 SPA 路由的基础。   一、传统页面跳转与 SPA 路由的区别在深入探讨 SPA 路由之前，我们首先理解传统多页面应用 (Multi-Page Application, MPA) 的页面跳转机制及其与 SPA 的根本不同：  传统 MPA 页面跳转：  用户点击链接或提交表单。 浏览器向服务器发送 HTTP 请求，请求新的 HTML 页面。 服务器响应并发送完整的 HTML 文档。 浏览器销毁当前页面，加载并渲染新的 HTML 文档。   特点...</div></div></div></a><a class="pagination-related" href="/23aa2938b836/" title="跨域问题详解及解决方案"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="info-item-2">跨域问题详解及解决方案</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，“跨域” (Cross-Origin) 是一个非常常见且令人困扰的问题。它源于浏览器的一项重要安全策略：同源策略 (Same-Origin Policy)。理解同源策略以及如何安全有效地解决跨域问题，是每个 Web 开发者必备的知识。  核心思想：同源策略是浏览器的一项安全机制，它限制了来自一个源的文档或脚本与来自另一个源的资源进行交互。当请求的目标源与当前页面的源不一致时，就发生了跨域。解决跨域问题的关键是让服务器端或中间代理明确允许跨域请求。    一、什么是同源策略 (Same-Origin Policy)？同源策略 是浏览器为了保护用户隐私和数据安全而制定的一项基本安全功能。它限制了一个 HMTL 文档中加载的脚本如何与来自不同源的资源进行交互。 1.1 “源”的定义如果两个 URL 的协议 (Protocol)、域名 (Domain) 和端口 (Port) 都相同，则称它们是“同源”的。只要其中任何一个不同，就被认为是“跨源”或“不同源”。    URL A URL B 结果 原因    http://example.com/a.html http...</div></div></div></a><a class="pagination-related" href="/469d3e424114/" title="IndexedDB 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-25</div><div class="info-item-2">IndexedDB 深度解析</div></div><div class="info-2"><div class="info-item-1"> IndexedDB 是一种基于浏览器的高性能、非关系型 (NoSQL) 数据库，允许在客户端存储大量结构化数据。它提供了一个强大的 API，用于在用户的浏览器中创建和管理数据库，支持事务、索引和异步操作，是构建离线应用 (Offline First) 和 PWA (Progressive Web Apps) 的核心技术之一。  核心思想：IndexedDB 提供了一个强大的、异步的、事务性的客户端数据存储方案，专为存储大量结构化数据而设计。它通过键值对的形式存储 JavaScript 对象，并支持索引来高效查询数据。   一、为什么需要 IndexedDB？(与其它客户端存储的对比)在 Web 开发中，有多种客户端存储技术，但它们各有优缺点，IndexedDB 旨在解决其中一些局限性。  localStorage 和 sessionStorage： 优点：API 简单，同步操作。 缺点： 存储容量小：通常只有 5MB 左右。 仅支持字符串：只能存储字符串，复杂数据需要手动序列化&#x2F;反序列化 (JSON.stringify&#x2F;parse)。 无索引：无法进行高效查...</div></div></div></a><a class="pagination-related" href="/b519dd676c66/" title="PWA (Progressive Web Apps) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-05</div><div class="info-item-2">PWA (Progressive Web Apps) 深度解析</div></div><div class="info-2"><div class="info-item-1"> PWA (Progressive Web Apps - 渐进式 Web 应用) 是一种利用现代 Web 技术，将 Web 应用提升至接近原生应用体验的新方法。它旨在结合 Web 的广阔可达性与原生应用的丰富功能，为用户提供可靠 (Reliable)、快速 (Fast)、沉浸式 (Engaging) 的体验。PWA 不仅仅是一种技术，更是一套开发理念和最佳实践。  核心思想：PWA 的目标是让 Web 应用具备类似原生应用的体验和功能，同时保留 Web 的优点（无需安装、易于发现、跨平台）。这主要通过 Service Worker 实现离线能力和性能优化，通过 Web App Manifest 实现安装和应用体验，以及通过 HTTPS 确保安全性来达成。   一、为什么需要 PWA？(Web 与原生应用的融合)传统 Web 应用和原生移动应用各有优缺点：  传统 Web 应用 (网站)： 优点：无需安装、易于发现、跨平台、更新灵活、共享方便。 缺点：依赖网络、加载慢、无离线功能、无法添加到主屏幕、无法发送推送通知、用户体验与原生应用有差距。   原生移动应用： 优点：性能好、可离...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">367</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">211</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">75</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-SSE%EF%BC%9F-%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-text">一、为什么需要 SSE？(实时通信的演进)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%A0%E7%BB%9F%E8%BD%AE%E8%AF%A2-Polling"><span class="toc-text">1.1 传统轮询 (Polling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%95%BF%E8%BD%AE%E8%AF%A2-Long-Polling"><span class="toc-text">1.2 长轮询 (Long Polling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-WebSocket-%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">1.3 WebSocket 的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-SSE-%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-text">1.4 SSE 的定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SSE-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、SSE 核心概念与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-MIME-%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.2 MIME 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.3 数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%BF%9E%E6%8E%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.4 连接生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0-JavaScript"><span class="toc-text">三、客户端实现 (JavaScript)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-EventSource-API"><span class="toc-text">3.1 EventSource API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">3.2 事件监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%87%AA%E5%8A%A8%E9%87%8D%E8%BF%9E"><span class="toc-text">3.3 自动重连</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0-Go-%E8%AF%AD%E8%A8%80"><span class="toc-text">四、服务器端实现 (Go 语言)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81SSE-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、SSE 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BC%98%E7%82%B9"><span class="toc-text">5.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">5.2 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5.3 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go Jaeger 深度解析：分布式追踪实践"/></a><div class="content"><a class="title" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践">Go Jaeger 深度解析：分布式追踪实践</a><time datetime="2025-12-04T22:24:00.000Z" title="发表于 2025-12-05 06:24:00">2025-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/15920229f914/" title="Supabase 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supabase 深度解析"/></a><div class="content"><a class="title" href="/15920229f914/" title="Supabase 深度解析">Supabase 深度解析</a><time datetime="2025-12-02T22:24:00.000Z" title="发表于 2025-12-03 06:24:00">2025-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1ae20d2726d8/" title="MiniRTC 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MiniRTC 详解"/></a><div class="content"><a class="title" href="/1ae20d2726d8/" title="MiniRTC 详解">MiniRTC 详解</a><time datetime="2025-11-28T22:24:00.000Z" title="发表于 2025-11-29 06:24:00">2025-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/be24ef88e59a/" title="WebRTC 技术详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebRTC 技术详解"/></a><div class="content"><a class="title" href="/be24ef88e59a/" title="WebRTC 技术详解">WebRTC 技术详解</a><time datetime="2025-11-27T22:24:00.000Z" title="发表于 2025-11-28 06:24:00">2025-11-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-20.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>