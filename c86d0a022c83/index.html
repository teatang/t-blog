<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>React入门教程：快速构建交互式用户界面 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="React (通常称为 React.js 或 ReactJS) 是一个用于构建用户界面的 JavaScript 库，由 Facebook (现为 Meta) 创建和维护。它允许开发者声明式地创建复杂的、交互式的 UI，其核心思想是组件化和响应式更新。React 专注于视图层，与传统 MVC 模式中的 V (View) 相对应。  核心思想：“声明式地”构建组件化的 UI。开发者描述 UI 在给定">
<meta property="og:type" content="article">
<meta property="og:title" content="React入门教程：快速构建交互式用户界面">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/c86d0a022c83/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="React (通常称为 React.js 或 ReactJS) 是一个用于构建用户界面的 JavaScript 库，由 Facebook (现为 Meta) 创建和维护。它允许开发者声明式地创建复杂的、交互式的 UI，其核心思想是组件化和响应式更新。React 专注于视图层，与传统 MVC 模式中的 V (View) 相对应。  核心思想：“声明式地”构建组件化的 UI。开发者描述 UI 在给定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg">
<meta property="article:published_time" content="2023-02-28T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-22T03:54:40.759Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="TypeScript">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "React入门教程：快速构建交互式用户界面",
  "url": "https://blog.tbf1211.xx.kg/c86d0a022c83/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg",
  "datePublished": "2023-02-28T22:24:00.000Z",
  "dateModified": "2025-12-22T03:54:40.759Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/c86d0a022c83/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'React入门教程：快速构建交互式用户界面',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">415</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">217</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-10.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">React入门教程：快速构建交互式用户界面</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">React入门教程：快速构建交互式用户界面</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-28T22:24:00.000Z" title="发表于 2023-03-01 06:24:00">2023-03-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/c86d0a022c83/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>React</strong> (通常称为 React.js 或 ReactJS) 是一个用于构建用户界面的 <strong>JavaScript 库</strong>，由 Facebook (现为 Meta) 创建和维护。它允许开发者声明式地创建复杂的、交互式的 UI，其核心思想是组件化和响应式更新。React 专注于视图层，与传统 MVC 模式中的 V (View) 相对应。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>“声明式地”构建组件化的 UI。开发者描述 UI 在给定状态下的样子，React 负责高效地更新 DOM 以匹配该状态。</strong></p>
</div>
<hr>
<blockquote>
<p><strong>重要提示</strong>: React 主要使用 TypeScript 或 JavaScript (JSX) 进行开发。本文档中的所有代码示例都将使用 <strong>TypeScript (TSX)</strong> 语言，以满足类型安全的需求。</p>
</blockquote>
<h2 id="一、为什么需要-React？"><a href="#一、为什么需要-React？" class="headerlink" title="一、为什么需要 React？"></a>一、为什么需要 React？</h2><p>在现代 Web 开发中，构建复杂的用户界面面临诸多挑战：</p>
<ol>
<li><strong>DOM 操作的复杂性与性能瓶颈</strong>：直接操作 DOM 繁琐且容易出错，尤其是在数据频繁变化时，手动优化 DOM 更新的性能极其困难。</li>
<li><strong>代码组织与复用性</strong>：随着应用规模的增长，UI 代码变得难以管理，组件之间的逻辑耦合高，复用性差。</li>
<li><strong>状态管理难题</strong>：UI 状态分散在各处，数据流向不明确，导致调试困难，应用行为不可预测。</li>
<li><strong>可维护性与可扩展性</strong>：传统开发方式下，修改现有功能或添加新功能往往会引入新的 bug。</li>
</ol>
<p>React 通过引入一系列创新概念，旨在解决这些问题：</p>
<ul>
<li><strong>声明式 UI (Declarative UI)</strong>：开发者只需描述 UI 在特定状态下应该呈现的样子，React 会自动处理更新 DOM 的复杂性。这使得代码更易于理解和调试。</li>
<li><strong>组件化 (Component-Based)</strong>：将 UI 拆分成独立、可复用的小块（组件），每个组件管理自己的状态和逻辑。这提高了代码的组织性、可维护性和复用性。</li>
<li><strong>虚拟 DOM (Virtual DOM)</strong>：React 在内存中维护一个轻量级的 DOM 树副本。当组件状态改变时，React 会先比较新旧虚拟 DOM 的差异（<code>diff</code> 算法），然后只将必要的最小更改批量更新到真实 DOM，从而极大地优化了性能。</li>
<li><strong>单向数据流 (Unidirectional Data Flow)</strong>：父组件通过 <code>props</code> 向子组件传递数据。状态通常在组件内部管理，或通过状态管理库进行集中管理，数据流向清晰，易于追踪。</li>
<li><strong>JSX (JavaScript XML)</strong>：一种 JavaScript 语法扩展，允许在 JavaScript 代码中直接编写类似 HTML 的结构。在 TypeScript 中，它被称为 TSX，并支持类型检查。这使得 UI 逻辑和视图定义紧密结合，提高了可读性。</li>
</ul>
<h2 id="二、React-的核心概念"><a href="#二、React-的核心概念" class="headerlink" title="二、React 的核心概念"></a>二、React 的核心概念</h2><p>理解 React 的核心概念对于高效使用它至关重要。</p>
<ol>
<li><p><strong>Component (组件)</strong>:</p>
<ul>
<li><strong>定义</strong>：React 应用的基石。一个组件是一个独立的、可复用的 UI 单元，可以是函数组件 (推荐) 或类组件。</li>
<li><strong>作用</strong>：封装 UI 及其逻辑，管理自身状态和生命周期。</li>
</ul>
</li>
<li><p><strong>JSX &#x2F; TSX (JavaScript&#x2F;TypeScript XML)</strong>:</p>
<ul>
<li><strong>定义</strong>：一种 JavaScript&#x2F;TypeScript 语法扩展，允许在 JavaScript&#x2F;TypeScript 代码中书写类似 HTML 的结构。它会被 Babel 或 TypeScript 编译器编译成 <code>React.createElement()</code> 调用。</li>
<li><strong>作用</strong>：将 UI 声明与 JavaScript&#x2F;TypeScript 逻辑紧密结合，提高代码可读性。</li>
</ul>
</li>
<li><p><strong>State (状态)</strong>:</p>
<ul>
<li><strong>定义</strong>：组件内部管理的数据，当状态改变时，组件会重新渲染。函数组件使用 <code>useState</code> Hook 来管理状态。</li>
<li><strong>作用</strong>：驱动组件的动态行为和 UI 更新。</li>
</ul>
</li>
<li><p><strong>Props (属性)</strong>:</p>
<ul>
<li><strong>定义</strong>：父组件向子组件传递数据的机制。Props 是只读的，子组件不应直接修改接收到的 Props。</li>
<li><strong>作用</strong>：实现组件间的数据通信和配置。</li>
</ul>
</li>
<li><p><strong>Virtual DOM (虚拟 DOM)</strong>:</p>
<ul>
<li><strong>定义</strong>：一个轻量级的 JavaScript 对象树，是真实 DOM 的内存表示。</li>
<li><strong>作用</strong>：React 在状态改变时先更新虚拟 DOM，然后通过 <code>diff</code> 算法计算出最小的 DOM 变更，最后高效地更新真实 DOM，从而提升性能。</li>
</ul>
</li>
<li><p><strong>Lifecycle (生命周期)</strong>:</p>
<ul>
<li><strong>定义</strong>：组件从创建、挂载到 DOM、更新、直到卸载的整个过程。函数组件使用 <code>useEffect</code> Hook 来处理副作用和模拟生命周期行为。</li>
<li><strong>作用</strong>：在组件特定阶段执行副作用操作，如数据请求、订阅事件、清理资源等。</li>
</ul>
</li>
<li><p><strong>Hooks (钩子)</strong>:</p>
<ul>
<li><strong>定义</strong>：函数组件中使用的特殊函数，允许你在不编写类的情况下使用 state 和其他 React 特性（如生命周期方法）。</li>
<li><strong>作用</strong>：管理状态 (<code>useState</code>)、处理副作用 (<code>useEffect</code>)、共享逻辑 (<code>custom Hooks</code>) 等，是现代 React 开发的核心。</li>
</ul>
</li>
</ol>
<h2 id="三、React-架构与工作流程"><a href="#三、React-架构与工作流程" class="headerlink" title="三、React 架构与工作流程"></a>三、React 架构与工作流程</h2><p>React 的核心是组件化和响应式更新。</p>
<h3 id="3-1-架构图"><a href="#3-1-架构图" class="headerlink" title="3.1 架构图"></a>3.1 架构图</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph React Application
        RootComponent[Root Component]
        RootComponent --&gt; ChildComponentA[Child Component A]
        RootComponent --&gt; ChildComponentB[Child Component B]
        ChildComponentA --&gt; GrandchildComponent1[Grandchild 1]
    end

    subgraph Data Flow &amp; Rendering
        UserAction[用户交互 &#x2F; 数据变化]
        UserAction --&gt; StateUpdate[&quot;组件状态更新 (useState)&quot;]
        StateUpdate --&gt; Re-render[&quot;组件重新渲染 (TSX)&quot;]
        Re-render --&gt; VirtualDOM[生成新的 Virtual DOM 树]
        VirtualDOM --&gt; Diffing[&quot;Diffing 算法 (比较新旧 Virtual DOM)&quot;]
        Diffing --&gt; Reconciliation[&quot;协调过程 (计算最小 DOM 变更)&quot;]
        Reconciliation --&gt; RealDOM[更新真实 DOM]
        RealDOM --&gt; BrowserDisplay[浏览器显示更新后的 UI]
    end

    Style[CSS &#x2F; Styling] --- RootComponent
    Data[&quot;Data (e.g., API calls, Context)&quot;] --- RootComponent
    Props[&quot;Props (Data from Parent)&quot;] --- ChildComponentA
    Props --- ChildComponentB
    State[&quot;State (Internal Data)&quot;] --- ChildComponentA
  </pre></div>

<h3 id="3-2-工作流程-从状态到-UI"><a href="#3-2-工作流程-从状态到-UI" class="headerlink" title="3.2 工作流程 (从状态到 UI)"></a>3.2 工作流程 (从状态到 UI)</h3><p>一个典型的 React 组件渲染和更新流程如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant User as 用户
    participant App as React 应用
    participant Component as React 组件
    participant VirtualDOM as 虚拟 DOM
    participant RealDOM as 真实 DOM
    participant Browser as 浏览器

    User-&gt;&gt;Component: 1. 初始加载 &#x2F; 用户交互 (e.g., Click Button)
    Component-&gt;&gt;Component: 2. 状态更新 (useState) &#x2F; Props 接收新值
    Component-&gt;&gt;App: 3. 通知 React 重新渲染
    App-&gt;&gt;Component: 4. 调用组件的 render 函数 (或函数组件体)
    Component-&gt;&gt;VirtualDOM: 5. 生成新的 Virtual DOM 树 (TSX 编译结果)
    VirtualDOM-&gt;&gt;VirtualDOM: 6. Diffing 算法 (比较新旧 Virtual DOM 树)
    VirtualDOM-&gt;&gt;RealDOM: 7. Reconciliation (计算出最小的 DOM 操作)
    RealDOM-&gt;&gt;Browser: 8. 执行最小的 DOM 更新
    Browser--&gt;&gt;User: 9. 显示更新后的 UI
  </pre></div>

<h2 id="四、React-入门与基本用法"><a href="#四、React-入门与基本用法" class="headerlink" title="四、React 入门与基本用法"></a>四、React 入门与基本用法</h2><h3 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h3><p>创建新的 React 应用最简单的方式是使用 Vite 或 Create React App。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Vite (推荐，更快)</span></span><br><span class="line">npm create vite@latest my-react-app -- --template react-ts <span class="comment"># 使用 TypeScript 模板</span></span><br><span class="line"><span class="built_in">cd</span> my-react-app</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Create React App (传统)</span></span><br><span class="line">npx create-react-app my-react-app --template typescript <span class="comment"># 使用 TypeScript 模板</span></span><br><span class="line"><span class="built_in">cd</span> my-react-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<h3 id="4-2-最小示例：函数组件与-State"><a href="#4-2-最小示例：函数组件与-State" class="headerlink" title="4.2 最小示例：函数组件与 State"></a>4.2 最小示例：函数组件与 State</h3><p>这是一个简单的 React 组件，展示了函数组件、TSX 和 <code>useState</code> Hook。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>; <span class="comment">// 引入样式文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123; <span class="comment">// 明确指定组件的返回类型为 JSX.Element</span></span><br><span class="line">  <span class="comment">// 使用 useState Hook 声明一个状态变量 `count` 及其更新函数 `setCount`</span></span><br><span class="line">  <span class="comment">// 明确指定 count 的类型为 number</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>); <span class="comment">// 初始值为 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义事件处理函数</span></span><br><span class="line">  <span class="keyword">const</span> increment = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123; <span class="comment">// 明确指定函数的返回类型为 void</span></span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>); <span class="comment">// 使用函数式更新，确保拿到最新状态</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decrement = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount - <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件返回 TSX，描述 UI 结构</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;counter-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Simple Counter<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Current Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> &#123;/* 在 TSX 中嵌入 TypeScript 表达式 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;decrement&#125;</span>&gt;</span>Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出组件以便在其他地方使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.tsx (或 src/index.tsx)</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Counter</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>; <span class="comment">// 导入你的 Counter 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保根元素存在</span></span><br><span class="line"><span class="keyword">if</span> (rootElement) &#123;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(rootElement).<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span> &#123;/* 渲染你的 Counter 组件 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>,</span><br><span class="line">  );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Root element with ID &quot;root&quot; not found.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/App.css */</span></span><br><span class="line"><span class="selector-class">.counter-container</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.counter-container</span> <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.counter-container</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、React-常用接口-Hooks-详解-TypeScript-版"><a href="#五、React-常用接口-Hooks-详解-TypeScript-版" class="headerlink" title="五、React 常用接口 (Hooks) 详解 (TypeScript 版)"></a>五、React 常用接口 (Hooks) 详解 (TypeScript 版)</h2><p>React 的 Hooks API 是现代函数组件开发的核心，通过 TypeScript 使用时能够提供强大的类型安全保障。</p>
<h3 id="5-1-useState"><a href="#5-1-useState" class="headerlink" title="5.1 useState"></a>5.1 <code>useState</code></h3><ul>
<li><strong>作用</strong>：在函数组件中添加 React 状态。</li>
<li><strong>用法</strong>：<code>const [state, setState] = useState&lt;Type&gt;(initialState);</code><ul>
<li><code>state</code>：当前状态的值。</li>
<li><code>setState</code>：更新状态的函数。</li>
<li><code>initialState</code>：状态的初始值（可以是值或一个返回值的函数）。</li>
<li><code>&lt;Type&gt;</code>：泛型参数，明确指定状态的类型。</li>
</ul>
</li>
<li><strong>示例</strong>：见上方的 <code>Counter</code> 组件。<ul>
<li><code>const [count, setCount] = useState&lt;number&gt;(0);</code></li>
<li><code>const [user, setUser] = useState&lt;User | null&gt;(null);</code></li>
</ul>
</li>
</ul>
<h3 id="5-2-useEffect"><a href="#5-2-useEffect" class="headerlink" title="5.2 useEffect"></a>5.2 <code>useEffect</code></h3><ul>
<li><strong>作用</strong>：在函数组件中处理副作用 (side effects)，如数据获取、订阅、手动改变 DOM、定时器等。它在组件渲染后执行。</li>
<li><strong>用法</strong>：<code>useEffect(() =&gt; &#123; /* 副作用代码 */ return () =&gt; &#123; /* 清理函数 */ &#125;; &#125;, [dependencies]);</code><ul>
<li>第一个参数是一个函数，包含副作用逻辑。</li>
<li>返回的函数是可选的清理函数，会在组件卸载或下次副作用执行前运行。</li>
<li>第二个参数是一个依赖项数组：<ul>
<li>空数组 <code>[]</code>：副作用只在组件挂载时运行一次，并在卸载时清理。</li>
<li>省略依赖项：副作用在每次渲染后都运行（应避免，除非你明确需要）。</li>
<li>包含变量：副作用在这些变量改变时运行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>示例</strong>：数据获取、事件监听、定时器。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 User 数据的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">phone</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义组件 Props 的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DataFetcherProps</span> &#123;</span><br><span class="line">  <span class="attr">userId</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DataFetcher</span>(<span class="params">&#123; userId &#125;: <span class="title class_">DataFetcherProps</span></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState&lt;<span class="title class_">User</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>); <span class="comment">// 类型为 User 或 null</span></span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState&lt;<span class="title class_">Error</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>); <span class="comment">// 类型为 Error 或 null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// useEffect 用于数据获取副作用</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">true</span>); <span class="comment">// 开始加载，重置加载状态</span></span><br><span class="line">    <span class="title function_">setError</span>(<span class="literal">null</span>);    <span class="comment">// 重置错误状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="title function_">async</span> (): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://jsonplaceholder.typicode.com/users/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">result</span>: <span class="title class_">User</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>(); <span class="comment">// 明确指定返回类型</span></span><br><span class="line">        <span class="title function_">setData</span>(result);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 确保 err 是 Error 类型</span></span><br><span class="line">        <span class="title function_">setError</span>(err <span class="keyword">instanceof</span> <span class="title class_">Error</span> ? err : <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="title class_">String</span>(err)));</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">fetchData</span>(); <span class="comment">// 使用 void 操作符忽略 Promise 的返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理函数（可选）：如果组件在数据获取完成前卸载，可以取消请求等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&quot;Cleaning up data fetcher for userId:&quot;, userId);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [userId]); <span class="comment">// 依赖项数组：当 userId 改变时，重新运行副作用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading user data...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!data) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>No data found.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User Details (ID: &#123;userId&#125;)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;data.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Email: &#123;data.email&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Phone: &#123;data.phone&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 App 组件中使用 (示例)</span></span><br><span class="line"><span class="comment">// function App(): JSX.Element &#123;</span></span><br><span class="line"><span class="comment">//   const [currentUserId, setCurrentUserId] = useState&lt;number&gt;(1);</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div style=&#123;&#123; textAlign: &#x27;center&#x27;, marginTop: &#x27;50px&#x27; &#125;&#125;&gt;</span></span><br><span class="line"><span class="comment">//       &lt;button onClick=&#123;() =&gt; setCurrentUserId(prev =&gt; prev === 10 ? 1 : prev + 1)&#125;&gt;</span></span><br><span class="line"><span class="comment">//         Next User (Current: &#123;currentUserId&#125;)</span></span><br><span class="line"><span class="comment">//       &lt;/button&gt;</span></span><br><span class="line"><span class="comment">//       &lt;DataFetcher userId=&#123;currentUserId&#125; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   );</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// export default App;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-useContext"><a href="#5-3-useContext" class="headerlink" title="5.3 useContext"></a>5.3 <code>useContext</code></h3><ul>
<li><strong>作用</strong>：在组件树中共享数据，避免逐层传递 <code>props</code> (prop drilling)。</li>
<li><strong>用法</strong>：<code>const value = useContext(MyContext);</code><ul>
<li>首先需要通过 <code>React.createContext&lt;Type | null&gt;(null)</code> 创建一个 Context 对象，并明确其类型。</li>
<li>在父组件中使用 <code>MyContext.Provider</code> 包裹子组件，并提供 <code>value</code>。</li>
<li>在任意后代组件中使用 <code>useContext(MyContext)</code> 消费该值。</li>
</ul>
</li>
<li><strong>示例</strong>：主题切换、用户认证信息。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; createContext, useContext, useState, <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义 Context 值的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ThemeContextType</span> &#123;</span><br><span class="line">  <span class="attr">theme</span>: <span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span>;</span><br><span class="line">  <span class="attr">toggleTheme</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 Context</span></span><br><span class="line"><span class="comment">// 初始值为 null，并在 Provider 中提供实际值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = createContext&lt;<span class="title class_">ThemeContextType</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义提供者组件的 Props</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ThemeProviderProps</span> &#123;</span><br><span class="line">  <span class="attr">children</span>: <span class="title class_">ReactNode</span>; <span class="comment">// children 属性的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提供者组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ThemeProvider</span>(<span class="params">&#123; children &#125;: <span class="title class_">ThemeProviderProps</span></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState&lt;<span class="string">&#x27;light&#x27;</span> | <span class="string">&#x27;dark&#x27;</span>&gt;(<span class="string">&#x27;light&#x27;</span>); <span class="comment">// 默认主题</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleTheme = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setTheme</span>(<span class="function"><span class="params">prevTheme</span> =&gt;</span> (prevTheme === <span class="string">&#x27;light&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// contextValue 的类型会根据 ThemeContextType 自动推断</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">contextValue</span>: <span class="title class_">ThemeContextType</span> = &#123; theme, toggleTheme &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125; &#123;/* 渲染所有子组件 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 消费者组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ThemeButton</span>(<span class="params"></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 useContext 消费 Context 中的值</span></span><br><span class="line">  <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保 context 不为 null (通常在 Provider 内部使用时是安全的)</span></span><br><span class="line">  <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;ThemeButton must be used within a ThemeProvider&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; theme, toggleTheme &#125; = context;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onClick</span>=<span class="string">&#123;toggleTheme&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">background:</span> <span class="attr">theme</span> === <span class="string">&#x27;light&#x27;</span> ? &#x27;#<span class="attr">eee</span>&#x27; <span class="attr">:</span> &#x27;#<span class="attr">333</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">color:</span> <span class="attr">theme</span> === <span class="string">&#x27;light&#x27;</span> ? &#x27;#<span class="attr">333</span>&#x27; <span class="attr">:</span> &#x27;#<span class="attr">eee</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">border:</span> `<span class="attr">1px</span> <span class="attr">solid</span> $&#123;<span class="attr">theme</span> === <span class="string">&#x27;light&#x27;</span> ? &#x27;#<span class="attr">333</span>&#x27; <span class="attr">:</span> &#x27;#<span class="attr">eee</span>&#x27;&#125;`,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">padding:</span> &#x27;<span class="attr">10px</span> <span class="attr">20px</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">cursor:</span> &#x27;<span class="attr">pointer</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      Current Theme: &#123;theme&#125; (Click to toggle)</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 App 组件中使用 (示例)</span></span><br><span class="line"><span class="comment">// function AppWithTheme(): JSX.Element &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;ThemeProvider&gt;</span></span><br><span class="line"><span class="comment">//       &lt;div style=&#123;&#123; padding: &#x27;20px&#x27;, textAlign: &#x27;center&#x27; &#125;&#125;&gt;</span></span><br><span class="line"><span class="comment">//         &lt;h1&gt;Context API Example&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">//         &lt;ThemeButton /&gt;</span></span><br><span class="line"><span class="comment">//         &lt;p&gt;This paragraph&#x27;s style could also adapt to the theme.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//       &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/ThemeProvider&gt;</span></span><br><span class="line"><span class="comment">//   );</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// export default AppWithTheme;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-useReducer"><a href="#5-4-useReducer" class="headerlink" title="5.4 useReducer"></a>5.4 <code>useReducer</code></h3><ul>
<li><strong>作用</strong>：<code>useState</code> 的替代方案，用于管理更复杂的组件状态逻辑，特别是当状态更新依赖于前一个状态或包含多个子值时。它受 Redux 启发。</li>
<li><strong>用法</strong>：<code>const [state, dispatch] = useReducer&lt;Reducer&lt;State, Action&gt;&gt;(reducer, initialState);</code><ul>
<li><code>reducer</code>：一个函数 <code>(state: State, action: Action) =&gt; State</code>，根据当前状态和动作计算新状态。</li>
<li><code>initialState</code>：状态的初始值。</li>
<li><code>state</code>：当前状态。</li>
<li><code>dispatch</code>：用于触发状态更新的函数，接受一个 <code>action</code> 对象作为参数。</li>
<li><code>&lt;Reducer&lt;State, Action&gt;&gt;</code>：泛型参数，明确指定 reducer 的类型，包括状态和动作的类型。</li>
</ul>
</li>
<li><strong>示例</strong>：购物车、复杂表单。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义 State 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CounterState</span> &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义 Action 接口</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CounterAction</span> =</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">&#x27;reset&#x27;</span>; <span class="attr">payload</span>: <span class="built_in">number</span> &#125;; <span class="comment">// payload 可以传递额外数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义 reducer 函数</span></span><br><span class="line"><span class="comment">// (state, action) =&gt; newState</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">counterReducer</span>(<span class="params"><span class="attr">state</span>: <span class="title class_">CounterState</span>, <span class="attr">action</span>: <span class="title class_">CounterAction</span></span>): <span class="title class_">CounterState</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.<span class="property">payload</span> &#125;; <span class="comment">// payload 可以传递额外数据</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="comment">// 在 TypeScript 中，确保所有 action 类型都已处理</span></span><br><span class="line">      <span class="comment">// const exhaustiveCheck: never = action;</span></span><br><span class="line">      <span class="comment">// return exhaustiveCheck;</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unknown action type&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ComplexCounter</span>(<span class="params"></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="comment">// 4. 使用 useReducer Hook</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(counterReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;); <span class="comment">// 初始状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27;, <span class="attr">marginTop:</span> &#x27;<span class="attr">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Complex Counter (useReducer)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;Decrement<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;reset&#x27;, payload: 0 &#125;)&#125;&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ComplexCounter</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-useRef"><a href="#5-5-useRef" class="headerlink" title="5.5 useRef"></a>5.5 <code>useRef</code></h3><ul>
<li><strong>作用</strong>：在组件的整个生命周期内保存一个可变的值，且当这个值改变时不会触发组件重新渲染。常用于直接访问 DOM 元素或存储任何可变引用。</li>
<li><strong>用法</strong>：<code>const refContainer = useRef&lt;Type | null&gt;(initialValue);</code><ul>
<li><code>refContainer.current</code>：实际可变的值。</li>
<li><code>&lt;Type&gt;</code>：泛型参数，指定 <code>current</code> 属性的类型。通常是 <code>HTMLElement</code> 或其子类型，如 <code>HTMLInputElement</code>。</li>
</ul>
</li>
<li><strong>示例</strong>：获取输入框焦点、存储计时器 ID。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FocusInput</span>(<span class="params"></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个 ref 来存储对 input 元素的引用</span></span><br><span class="line">  <span class="comment">// 明确指定 ref 的类型为 HTMLInputElement 或 null (初始值)</span></span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef&lt;<span class="title class_">HTMLInputElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onButtonClick = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` 属性指向挂载到 DOM 上的实际 DOM 节点</span></span><br><span class="line">    <span class="comment">// 检查 inputEl.current 是否存在，以确保 DOM 节点已挂载</span></span><br><span class="line">    <span class="keyword">if</span> (inputEl.<span class="property">current</span>) &#123;</span><br><span class="line">      inputEl.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27;, <span class="attr">marginTop:</span> &#x27;<span class="attr">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>useRef Example: Focus Input<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputEl&#125;</span> /&gt;</span> &#123;/* 将 ref 绑定到 input 元素 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FocusInput</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-useCallback-和-useMemo"><a href="#5-6-useCallback-和-useMemo" class="headerlink" title="5.6 useCallback 和 useMemo"></a>5.6 <code>useCallback</code> 和 <code>useMemo</code></h3><ul>
<li><strong>作用</strong>：性能优化 Hooks。<ul>
<li><code>useCallback</code>：缓存函数。当依赖项未改变时，返回一个记忆化的回调函数，避免子组件不必要的重新渲染。</li>
<li><code>useMemo</code>：缓存计算结果。当依赖项未改变时，返回一个记忆化的值，避免重复执行昂贵的计算。</li>
</ul>
</li>
<li><strong>用法</strong>：<ul>
<li><code>const memoizedCallback = useCallback&lt;(...args: any[]) =&gt; any&gt;(() =&gt; &#123; /* do something */ &#125;, [dependencies]);</code></li>
<li><code>const memoizedValue = useMemo&lt;Type&gt;(() =&gt; computeExpensiveValue(a, b), [a, b]);</code></li>
<li>在 TypeScript 中，<code>useCallback</code> 的函数类型通常可以从上下文推断，但对于复杂函数可以明确指定。<code>useMemo</code> 的返回类型也常能推断。</li>
</ul>
</li>
<li><strong>示例</strong>：传递给子组件的事件处理函数、复杂数据处理。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback, useMemo, memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子组件 Props 的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ChildComponentProps</span> &#123;</span><br><span class="line">  <span class="attr">onIncrement</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是一个性能敏感的子组件，使用 React.memo 进行浅比较优化</span></span><br><span class="line"><span class="comment">// memo 会确保只有当 props 改变时才重新渲染此组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ChildComponent</span> = <span class="title function_">memo</span>((&#123; onIncrement, value &#125;: <span class="title class_">ChildComponentProps</span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ChildComponent rendered&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Value from parent (memoized): &#123;value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onIncrement&#125;</span>&gt;</span>Increment Value<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParentComponent</span>(<span class="params"></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [otherState, setOtherState] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// useMemo 缓存一个昂贵的计算结果</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">expensiveValue</span>: <span class="built_in">number</span> = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Calculating expensive value...&#x27;</span>);</span><br><span class="line">    <span class="comment">// 模拟一个昂贵的计算</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count * <span class="number">2</span> + sum; <span class="comment">// 依赖于 count</span></span><br><span class="line">  &#125;, [count]); <span class="comment">// 只有当 count 改变时才重新计算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// useCallback 缓存一个函数</span></span><br><span class="line">  <span class="comment">// 明确指定函数类型 for clarity</span></span><br><span class="line">  <span class="keyword">const</span> handleIncrement = useCallback&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt;(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount + <span class="number">1</span>);</span><br><span class="line">  &#125;, []); <span class="comment">// 空依赖数组表示这个函数在组件的整个生命周期中都是同一个引用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27;, <span class="attr">marginTop:</span> &#x27;<span class="attr">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Performance Hooks Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Parent Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Other State: &#123;otherState&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setOtherState(prev =&gt; prev + 1)&#125;&gt;Update Other State (Parent Re-renders)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 即使 ParentComponent 重新渲染，ChildComponent 也不会因为 onIncrement 引用不变而重新渲染 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">onIncrement</span>=<span class="string">&#123;handleIncrement&#125;</span> <span class="attr">value</span>=<span class="string">&#123;expensiveValue&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ParentComponent</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-自定义-Hooks-Custom-Hooks"><a href="#5-7-自定义-Hooks-Custom-Hooks" class="headerlink" title="5.7 自定义 Hooks (Custom Hooks)"></a>5.7 自定义 Hooks (Custom Hooks)</h3><ul>
<li><strong>作用</strong>：将组件逻辑（包括状态和副作用）提取到可重用的函数中，从而在不同组件之间共享状态逻辑，提高代码复用性和可读性。</li>
<li><strong>用法</strong>：以 <code>use</code> 开头的 TypeScript 函数，可以在内部调用其他 Hooks。</li>
<li><strong>示例</strong>：<code>useLocalStorage</code> (本地存储操作), <code>useWindowSize</code> (窗口大小监听)。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义自定义 Hook 的返回类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WindowSize</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义一个自定义 Hook</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useWindowSize</span>(<span class="params"></span>): <span class="title class_">WindowSize</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [windowSize, setWindowSize] = useState&lt;<span class="title class_">WindowSize</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="variable language_">window</span>.<span class="property">innerHeight</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleResize = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setWindowSize</span>(&#123;</span><br><span class="line">        <span class="attr">width</span>: <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="variable language_">window</span>.<span class="property">innerHeight</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理函数：移除事件监听器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []); <span class="comment">// 空依赖数组，只在组件挂载和卸载时执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> windowSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在组件中使用自定义 Hook</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WindowSizeDisplay</span>(<span class="params"></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; width, height &#125; = <span class="title function_">useWindowSize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27;, <span class="attr">marginTop:</span> &#x27;<span class="attr">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Custom Hook: useWindowSize<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Window Width: &#123;width&#125;px<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Window Height: &#123;height&#125;px<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">WindowSizeDisplay</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六、React-的优缺点与适用场景"><a href="#六、React-的优缺点与适用场景" class="headerlink" title="六、React 的优缺点与适用场景"></a>六、React 的优缺点与适用场景</h2><h3 id="6-1-优点："><a href="#6-1-优点：" class="headerlink" title="6.1 优点："></a>6.1 优点：</h3><ol>
<li><strong>声明式 UI</strong>：代码更易读、易写，且更易于理解。</li>
<li><strong>组件化</strong>：提高代码复用性、模块化和可维护性。</li>
<li><strong>虚拟 DOM 与性能优化</strong>：高效地更新真实 DOM，带来流畅的用户体验。</li>
<li><strong>单向数据流</strong>：数据流向清晰，易于调试和预测。</li>
<li><strong>Hooks 简化逻辑</strong>：在函数组件中管理状态和副作用，提高代码可读性和组织性。</li>
<li><strong>TypeScript 支持</strong>：与 TypeScript 完美结合，提供强大的类型安全保障，减少运行时错误。</li>
<li><strong>生态系统庞大</strong>：拥有活跃的社区、丰富的第三方库和工具 (如 Redux, React Router, Next.js)。</li>
<li><strong>跨平台能力</strong>：通过 React Native 可开发移动应用，通过 Electron 可开发桌面应用。</li>
</ol>
<h3 id="6-2-缺点："><a href="#6-2-缺点：" class="headerlink" title="6.2 缺点："></a>6.2 缺点：</h3><ol>
<li><strong>学习曲线</strong>：对于初学者来说，React 的概念 (TSX, Virtual DOM, Hooks, 状态管理) 可能需要一定时间来掌握。</li>
<li><strong>生态系统复杂</strong>：虽然生态庞大是优势，但也意味着选择多，可能导致“选择困难症”，且不同的库之间可能存在版本兼容问题。</li>
<li><strong>仅关注视图层</strong>：React 本身只关注 UI 渲染，不提供路由、状态管理、HTTP 请求等开箱即用的解决方案，需要结合其他库使用。</li>
<li><strong>构建工具的依赖</strong>：通常需要 Webpack、Babel、Vite 等构建工具来处理 TSX 和 ES6+ 语法。</li>
</ol>
<h3 id="6-3-适用场景："><a href="#6-3-适用场景：" class="headerlink" title="6.3 适用场景："></a>6.3 适用场景：</h3><ul>
<li><strong>构建复杂、交互式的单页应用 (SPA)</strong>：例如仪表盘、管理系统、社交媒体应用。</li>
<li><strong>组件库和设计系统</strong>：其组件化特性非常适合构建可复用的 UI 组件。</li>
<li><strong>需要高性能 UI 更新的场景</strong>：通过虚拟 DOM 确保渲染效率。</li>
<li><strong>团队偏好 JavaScript&#x2F;TypeScript 技术栈的项目</strong>。</li>
<li><strong>结合框架 (如 Next.js) 开发全栈或服务器端渲染 (SSR) 应用</strong>。</li>
</ul>
<h2 id="七、安全性考虑"><a href="#七、安全性考虑" class="headerlink" title="七、安全性考虑"></a>七、安全性考虑</h2><p>开发 React 应用程序时，安全性是至关重要的。虽然 React 本身在防止某些常见 Web 漏洞方面提供了一定帮助，但开发者仍需遵循最佳实践。</p>
<ol>
<li><strong>XSS (Cross-Site Scripting) 防护</strong>：<ul>
<li><strong>自动转义</strong>：React 的 TSX 会默认对渲染的内容进行字符串转义，这有效地防止了大部分 XSS 攻击。例如：<code>&lt;div&gt;&#123;userControlledContent&#125;&lt;/div&gt;</code> 会将 <code>&lt;script&gt;</code> 标签转义为 <code>&amp;lt;script&amp;gt;</code>。</li>
<li><strong><code>dangerouslySetInnerHTML</code></strong>：避免使用 <code>dangerouslySetInnerHTML</code> 属性，除非你完全信任要插入的 HTML 内容。如果必须使用，请确保内容已通过服务器端或严格的客户端清理。</li>
<li><strong>URL 审查</strong>：对于 <code>&lt;a&gt;</code> 标签的 <code>href</code> 或 <code>&lt;img&gt;</code> 的 <code>src</code> 等属性，如果其值来自用户输入，应进行严格的 URL 审查，防止 <code>javascript:</code> 伪协议攻击。</li>
</ul>
</li>
<li><strong>State 和 Props 的敏感数据</strong>：<ul>
<li><strong>避免在客户端存储敏感信息</strong>：不要在 React 组件的状态或 Props 中直接存储用户的密码、信用卡号等高度敏感信息。</li>
<li><strong>HTTP-only Cookie</strong>：对于认证令牌等敏感数据，优先使用 <code>HttpOnly</code> 属性的 Cookie，使其无法通过 JavaScript 访问，从而降低 XSS 攻击的风险。</li>
</ul>
</li>
<li><strong>CSRF (Cross-Site Request Forgery) 防护</strong>：<ul>
<li>React 本身不提供 CSRF 防护，这通常由后端框架处理。确保你的后端使用 CSRF Token 或 <code>SameSite=Lax/Strict</code> Cookie 策略来防范。</li>
</ul>
</li>
<li><strong>API 请求安全</strong>：<ul>
<li><strong>HTTPS</strong>：所有与后端 API 的通信都必须通过 HTTPS 进行，以加密传输数据，防止中间人攻击。</li>
<li><strong>认证与授权</strong>：在后端严格执行用户认证和授权，确保用户只能访问他们有权访问的数据和功能。</li>
<li><strong>CORS 配置</strong>：正确配置后端 API 的 CORS (Cross-Origin Resource Sharing) 策略，仅允许受信任的源访问。</li>
</ul>
</li>
<li><strong>依赖项安全</strong>：<ul>
<li><strong>定期更新</strong>：使用 <code>npm audit</code> 或 <code>yarn audit</code> 定期检查项目依赖项的漏洞，并及时更新。</li>
<li><strong>谨慎引入</strong>：只引入来自可信来源的第三方库，并检查其文档和社区活跃度。</li>
</ul>
</li>
<li><strong>代码分割与懒加载</strong>：<ul>
<li>虽然主要用于性能优化，但代码分割也可以限制攻击面。恶意代码如果只存在于应用的某个特定部分，可以限制其影响范围。</li>
</ul>
</li>
<li><strong>环境变量</strong>：<ul>
<li>避免在客户端 React 代码中暴露敏感的 API Key 或其他秘密信息。客户端构建工具（如 Vite, Create React App）会区分客户端和服务端环境变量，确保敏感信息只在构建时可用或只在服务器端使用。</li>
</ul>
</li>
</ol>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>React 已经成为现代前端开发的主流选择，以其声明式、组件化和高效的更新机制，极大地简化了复杂用户界面的构建。结合 TypeScript 的强大类型系统，React 应用的健壮性和可维护性得到了进一步提升。掌握其核心概念（组件、状态、属性、虚拟 DOM）和常用 Hooks（<code>useState</code>、<code>useEffect</code>、<code>useContext</code>、<code>useReducer</code>、<code>useRef</code>、性能 Hooks、自定义 Hooks），是成为一名高效 React 开发者的关键。虽然它有学习曲线和生态系统选择的挑战，但其强大的生产力工具和活跃的社区使其成为构建高性能、可维护 Web 应用的卓越选择。在开发过程中，始终牢记安全性最佳实践，可以确保你的 React 应用既强大又安全。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/c86d0a022c83/">https://blog.tbf1211.xx.kg/c86d0a022c83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/268e70ade46c/" title="英语国际音标（IPA）详解：发音原理与学习实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">英语国际音标（IPA）详解：发音原理与学习实践</div></div><div class="info-2"><div class="info-item-1"> 掌握英语音标是学习地道英语发音的基石。音标提供了一种精确、统一的方式来表示语言中的每一个音素，它超越了单词拼写的限制，帮助学习者纠正发音、提高听力理解并培养语感。本文将详细解析英语国际音标（IPA）的构成、发音原理，并通过分类汇总和实践技巧，旨在帮助学习者系统地掌握英语发音的奥秘。  核心思想：英语音标（特指国际音标 IPA）是发音学习的标准化工具，通过掌握元音和辅音的发音部位与发音方式，结合重音、语调和连读等语音现象的学习与实践，能够系统、准确地习得英语发音。    一、什么是英语音标？为什么要学习它？1.1 音标的定义与种类音标 是一种记录语音的符号系统，它能够准确地表示人类语言中的每一个音素。在英语学习中，最常用的是：  国际音标 (IPA - International Phonetic Alphabet)：这是全球语音学界通用的、最全面的音标系统，旨在精确记录所有人类语言的音素。它也是英语学习中最推荐学习的音标体系。 KK 音标 (Kenyon &amp; Knott)：主要用于标注美式英语发音，在美国的字典和英语教学中较为常见。 DJ 音标 (Daniel Jone...</div></div></div></a><a class="pagination-related" href="/1b5035114ad1/" title="Python Requests库详解：HTTP请求的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python Requests库详解：HTTP请求的艺术</div></div><div class="info-2"><div class="info-item-1"> requests 库 是 Python 生态系统中最流行、最强大、也是最优雅的 HTTP 客户端库之一。它简化了复杂的 HTTP 请求操作，让开发者能够以极少量的代码发送各种类型的 HTTP 请求，并轻松处理响应。与 Python 内置的 urllib 模块相比，requests 提供了更友好、更直观的 API，被誉为“面向人类的 HTTP 服务”。  核心思想：requests 封装了底层 HTTP 协议的复杂性，提供简洁的 API，让开发者专注于业务逻辑而非网络通信的细节。   一、为什么选择 Requests？在 Python 中进行 HTTP 请求有多种方式，例如内置的 urllib 模块。但 requests 库之所以广受欢迎，主要得益于以下优势：  友好的 API：设计直观，易学易用，代码可读性高。 功能强大：支持几乎所有 HTTP 功能，包括 GET, POST, PUT, DELETE 等方法，以及请求头、数据、文件上传、Cookie、身份认证、代理、SSL 验证等。 自动处理：自动处理 URL 编码、重定向、会话管理等常见任务。 JSON 支持：内置 JSON...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/632440febbdb/" title="TypeScript React 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="info-item-2">TypeScript React 详解</div></div><div class="info-2"><div class="info-item-1"> TypeScript + React 是现代前端开发中最强大的组合之一。TypeScript 为 React 应用带来了强大的类型系统，显著提高了代码质量、可维护性和开发效率。它在开发阶段就能捕获许多常见的错误，并提供出色的编辑器支持，使得构建大型、复杂的 React 应用变得更加可靠和愉快。  “Adding TypeScript to your React project can feel like adding a safety net. It catches bugs early, improves code readability, and makes refactoring a breeze, especially as your application grows.”   一、为什么在 React 中使用 TypeScript？React 本身是 JavaScript 库。虽然 JavaScript 灵活性高，但对于大型项目或多人协作，缺乏类型检查可能导致以下问题：  难以发现的运行时错误: 许多类型相关的错误（例如，将一个字符串传递给期望数字的组件属性）只会在运...</div></div></div></a><a class="pagination-related" href="/9474fb1165cb/" title="React 详解：核心 API 深度解读"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-27</div><div class="info-item-2">React 详解：核心 API 深度解读</div></div><div class="info-2"><div class="info-item-1"> React 是一个用于构建用户界面的 JavaScript 库。它以声明式的方式让开发者可以轻松构建复杂且交互性强的 UI。要真正驾驭 React，深入理解其核心 API 至关重要。这些 API 是构建组件、管理状态、处理副作用、优化性能以及与其他系统交互的基础。本文将对 React 的核心 API 进行深度解读，涵盖从组件定义到高级优化等各个方面。  核心思想：React 核心 API 围绕组件化、声明式UI、单向数据流和性能优化展开，通过 Hooks 极大地简化了函数组件的状态管理和副作用处理，使复杂逻辑更易组织和复用。   一、React 的核心模块与入口React 库被拆分为两个主要模块：react 和 react-dom。  react: 包含构建组件和定义其行为所需的核心 API（如 Component, useState, useEffect, createContext 等）。 react-dom: 提供与 DOM 交互的特定方法（如 render, createRoot 等），用于将 React 组件渲染到浏览器环境。  react-dom 主要 API1. ...</div></div></div></a><a class="pagination-related" href="/7cdd9f5b33c9/" title="前端项目工程化详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="info-item-2">前端项目工程化详解</div></div><div class="info-2"><div class="info-item-1"> 随着前端应用的复杂度日益增加，单纯依靠人工管理和协作已经无法满足高效、高质量开发的需求。前端工程化应运而生，它旨在通过将软件工程的思想和方法引入前端开发，构建一套系统化、标准化、自动化、体系化的解决方案，以提高开发效率、保障代码质量、降低维护成本。  前端工程化的核心思想是：以自动化取代人力，以工具取代重复劳动，以规范约束散漫。   一、什么是前端工程化？前端工程化是构建、管理和维护前端项目的实践和工具集。它涵盖了从项目初始化、开发、构建、测试到部署的整个生命周期，目标是提升团队协作效率、统一代码风格、保证项目质量、优化产物性能以及实现快速迭代。 它不仅仅是使用几个构建工具，更是一种体系化的思维方式和工作流。 二、为什么需要前端工程化？在没有工程化的时代，前端开发面临诸多挑战：  开发效率低下：手动重复任务（如文件合并、压缩），环境搭建复杂。 代码质量参差不齐：缺乏统一的代码规范和质量检查机制，导致 Bug 增多，难以维护。 团队协作困难：不同成员的代码风格差异大，冲突频繁，交接成本高。 项目性能不佳：缺乏自动化优化手段（如图片压缩、按需加载），页面加载慢。 部署上线复杂：手动...</div></div></div></a><a class="pagination-related" href="/ecbfce34b2dd/" title="基于TypeScript封装Axios成通用工具类"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-01</div><div class="info-item-2">基于TypeScript封装Axios成通用工具类</div></div><div class="info-2"><div class="info-item-1"> Axios 是一款基于 Promise 的 HTTP 客户端，可用于浏览器和 Node.js 环境。它提供了丰富的功能，如请求&#x2F;响应拦截器、取消请求、自动转换 JSON 等，使其成为前端和后端 HTTP 请求的流行选择。然而，在大型项目中直接使用裸露的 Axios 实例往往不够高效和灵活。通过 TypeScript 封装 Axios 成通用工具类，我们可以实现：统一的请求配置、自动的错误处理、请求&#x2F;响应的标准化、方便的业务逻辑扩展，以及通过 TypeScript 带来的类型安全和代码智能提示，从而提升开发效率和代码质量。  核心思想：将 Axios 的强大功能（如拦截器、配置）整合到一个类型安全的 TypeScript 类中，提供一个统一、可配置、易用的 HTTP 请求接口，并处理常见的业务场景，从而提升项目的可维护性和开发体验。    一、为什么需要封装 Axios？直接使用 Axios 发送请求虽然简单，但在实际项目中会遇到以下问题：  重复配置：每个请求都可能需要设置 baseURL、timeout、headers 等，导致大量重复代码。 错误处理不统...</div></div></div></a><a class="pagination-related" href="/c8105d5c8d5e/" title="Electron 开发详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-04</div><div class="info-item-2">Electron 开发详解</div></div><div class="info-2"><div class="info-item-1"> Electron (原名 Atom Shell) 是一个由 GitHub 开发的开源框架，它允许你使用 Web 技术 (HTML, CSS, JavaScript) 来构建跨平台的桌面应用程序。通过将 Chromium 渲染引擎和 Node.js 运行时集成到一个单一的项目中，Electron 使得前端开发者只需掌握一套技术栈，就能创建出功能强大、拥有原生外观和感觉的桌面应用，并能够访问操作系统底层功能。  核心思想：借助 Chromium (渲染视图) 和 Node.js (处理操作系统交互) 的能力，Electron 让 Web 技术栈能够构建全功能的跨平台桌面应用。   一、Electron 简介与优势1.1 什么是 Electron？Electron 可以被简单理解为一个微型浏览器套壳，它包含了：  Chromium：提供渲染用户界面的能力，这意味着你可以使用 HTML、CSS 和 JavaScript 来构建应用的 UI。 Node.js：提供访问操作系统底层 API 的能力，例如文件系统、网络、进程管理等。 原生 API 集成：Electron 提供了一套 API，...</div></div></div></a><a class="pagination-related" href="/f3d77a2d04c2/" title="TypeScript高级类型"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-26</div><div class="info-item-2">TypeScript高级类型</div></div><div class="info-2"><div class="info-item-1"> TypeScript 高级类型 提供了强大的工具，允许开发者以更灵活、更精确的方式定义和操作类型。这些高级类型不仅增强了代码的类型安全性，还提升了开发体验，使得复杂的数据结构和业务逻辑能够更清晰地表达和维护。掌握 TypeScript 的这些高级特性，是成为一名高效 TypeScript 开发者的关键。  核心思想：高级类型允许我们基于现有类型进行转换、组合、提取，以及根据不同条件生成新类型，从而构建出更健壮、更具表达力的类型系统。   一、联合类型 (Union Types)联合类型表示一个值可以是多种类型中的任意一种。使用 | 符号连接不同的类型。 1.1 定义与使用1234567891011121314// 定义一个联合类型，表示一个变量可以是 string 或 numbertype StringOrNumber = string | number;let id: StringOrNumber;id = &quot;123&quot;; // OKid = 123;   // OK// id = true; // Error: Type &#x27;boolean&#x2...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">415</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">217</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-React%EF%BC%9F"><span class="toc-text">一、为什么需要 React？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81React-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、React 的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81React-%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">三、React 架构与工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-text">3.1 架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E4%BB%8E%E7%8A%B6%E6%80%81%E5%88%B0-UI"><span class="toc-text">3.2 工作流程 (从状态到 UI)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81React-%E5%85%A5%E9%97%A8%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">四、React 入门与基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%89%E8%A3%85"><span class="toc-text">4.1 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9C%80%E5%B0%8F%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%8E-State"><span class="toc-text">4.2 最小示例：函数组件与 State</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81React-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3-Hooks-%E8%AF%A6%E8%A7%A3-TypeScript-%E7%89%88"><span class="toc-text">五、React 常用接口 (Hooks) 详解 (TypeScript 版)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-useState"><span class="toc-text">5.1 useState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-useEffect"><span class="toc-text">5.2 useEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-useContext"><span class="toc-text">5.3 useContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-useReducer"><span class="toc-text">5.4 useReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-useRef"><span class="toc-text">5.5 useRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-useCallback-%E5%92%8C-useMemo"><span class="toc-text">5.6 useCallback 和 useMemo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E8%87%AA%E5%AE%9A%E4%B9%89-Hooks-Custom-Hooks"><span class="toc-text">5.7 自定义 Hooks (Custom Hooks)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81React-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">六、React 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">6.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">6.2 缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">6.3 适用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">七、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能体 (Agent) 详解：深入 LangChain 开发实践"/></a><div class="content"><a class="title" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践">智能体 (Agent) 详解：深入 LangChain 开发实践</a><time datetime="2025-12-10T22:24:00.000Z" title="发表于 2025-12-11 06:24:00">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go Jaeger 深度解析：分布式追踪实践"/></a><div class="content"><a class="title" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践">Go Jaeger 深度解析：分布式追踪实践</a><time datetime="2025-12-04T22:24:00.000Z" title="发表于 2025-12-05 06:24:00">2025-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/15920229f914/" title="Supabase 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supabase 深度解析"/></a><div class="content"><a class="title" href="/15920229f914/" title="Supabase 深度解析">Supabase 深度解析</a><time datetime="2025-12-02T22:24:00.000Z" title="发表于 2025-12-03 06:24:00">2025-12-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-10.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}&path=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews) {
            pagePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors) {
            siteUV.textContent = typeof data.visitors.value !== 'undefined' ? data.visitors.value : data.visitors
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews) {
            sitePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>