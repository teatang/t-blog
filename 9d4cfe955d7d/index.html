<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机随机数生成原理详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机科学和工程领域，随机数扮演着极其重要的角色，从游戏娱乐到科学模拟，从数据加密到安全协议，几乎处处都需要随机数的支持。然而，计算机本质上是确定性机器，要生成“真正”的随机数并非易事。因此，理解计算机如何生成随机数及其背后的原理变得尤为关键。  随机数是指在一定范围内无法预测，且每个数值出现的概率相等的一组数。在计算机中，我们通常将随机数分为两大类：伪随机数 (Pseudo-Random Nu">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机随机数生成原理详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/9d4cfe955d7d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在计算机科学和工程领域，随机数扮演着极其重要的角色，从游戏娱乐到科学模拟，从数据加密到安全协议，几乎处处都需要随机数的支持。然而，计算机本质上是确定性机器，要生成“真正”的随机数并非易事。因此，理解计算机如何生成随机数及其背后的原理变得尤为关键。  随机数是指在一定范围内无法预测，且每个数值出现的概率相等的一组数。在计算机中，我们通常将随机数分为两大类：伪随机数 (Pseudo-Random Nu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg">
<meta property="article:published_time" content="2024-02-24T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-28T09:37:21.855Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="分布式系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机随机数生成原理详解",
  "url": "https://blog.tbf1211.xx.kg/9d4cfe955d7d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg",
  "datePublished": "2024-02-24T22:24:00.000Z",
  "dateModified": "2026-02-28T09:37:21.855Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/9d4cfe955d7d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机随机数生成原理详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-09.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机随机数生成原理详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">计算机随机数生成原理详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-02-24T22:24:00.000Z" title="发表于 2024-02-25 06:24:00">2024-02-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>在计算机科学和工程领域，随机数扮演着极其重要的角色，从游戏娱乐到科学模拟，从数据加密到安全协议，几乎处处都需要随机数的支持。然而，计算机本质上是确定性机器，要生成“真正”的随机数并非易事。因此，理解计算机如何生成随机数及其背后的原理变得尤为关键。</p>
<blockquote>
<p><strong>随机数</strong>是指在一定范围内无法预测，且每个数值出现的概率相等的一组数。在计算机中，我们通常将随机数分为两大类：<strong>伪随机数 (Pseudo-Random Number)</strong> 和 <strong>真随机数 (True Random Number)</strong>。</p>
</blockquote>
<div class="note info flat"><p>核心概念：随机数并非“无序”，而是指其<strong>不可预测性</strong>和<strong>统计均匀性</strong>。</p>
</div>

<hr>
<h2 id="一、伪随机数生成器-PRNG"><a href="#一、伪随机数生成器-PRNG" class="headerlink" title="一、伪随机数生成器 (PRNG)"></a>一、伪随机数生成器 (PRNG)</h2><p><strong>伪随机数生成器 (Pseudo-Random Number Generator, PRNG)</strong> 是一种算法，它通过一个初始的“种子”(seed) 值，生成一个看似随机的数值序列。这个序列在统计学上表现出随机的特性，但实际上是完全确定性的，即可重现的。</p>
<h3 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h3><p>PRNG 的核心思想是<strong>确定性算法</strong>。给定相同的初始种子，PRNG 总是会生成相同的随机数序列。其工作流程通常如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TB
    %% --- 输入层 ---
    Start([&lt;b&gt;SEED&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;初始种子&#x2F;熵]) --&gt; Init[注入初始状态]

    %% --- 核心引擎层 ---
    subgraph Engine [&quot;PRNG Logic Engine (生成器内核)&quot;]
        direction TB
        
        State[(&quot;&lt;b&gt;Internal State&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;$S_n$&quot;)]
        
        subgraph Transition [&quot;Transition Logic (状态转移)&quot;]
            FuncF[[&quot;&lt;b&gt;Next-State Function&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;$S_{n+1} &#x3D; f(S_n)$&quot;]]
        end

        subgraph Extraction [&quot;Output Logic (结果提取)&quot;]
            FuncG[[&quot;&lt;b&gt;Output Function&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;$R_n &#x3D; g(S_n)$&quot;]]
        end
    end

    %% --- 逻辑流 ---
    Init --&gt; State
    State --&gt; FuncF
    FuncF -- &quot;更新&quot; --&gt; State
    
    State --&gt; FuncG

    %% --- 输出层 ---
    FuncG --&gt; Output[&quot;&lt;b&gt;Random Sequence&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;$R_1, R_2, R_3, ...$&quot;]

    %% --- 黑暗模式样式优化 ---
    style Start fill:#bc8cff,color:#000,font-weight:bold
    style State fill:#1f6feb,color:#fff,stroke:#79c0ff,stroke-width:2px
    
    %% 函数节点使用蓝绿色（代表数学计算）
    style FuncF fill:#238636,color:#fff,stroke:none
    style FuncG fill:#018786,color:#fff,stroke:none
    
    %% 输出使用金黄色（代表产出的果实）
    style Output fill:#d29922,color:#000,font-weight:bold,stroke:#f1e05a

    %% 连线美化
    linkStyle 3 stroke:#bc8cff,stroke-width:2px,stroke-dasharray: 5 5
  </pre></div>

<ol>
<li><strong>种子 (Seed)</strong>：这是一个初始值，用于启动 PRNG 的内部状态。如果种子相同，生成的序列就相同。</li>
<li><strong>内部状态 (Internal State)</strong>：PRNG 维护的一个内部变量或一组变量，其值每次生成随机数后都会更新。</li>
<li><strong>转换函数 (Transformation Function)</strong>：这是一个数学函数，它接收当前的内部状态，并计算出下一个内部状态和下一个伪随机数。</li>
</ol>
<h3 id="1-2-伪随机数的关键特性"><a href="#1-2-伪随机数的关键特性" class="headerlink" title="1.2 伪随机数的关键特性"></a>1.2 伪随机数的关键特性</h3><ul>
<li><strong>确定性</strong>：给定相同的种子，总是生成相同的序列。</li>
<li><strong>周期性</strong>：所有 PRNG 都会在序列重复之前达到一个周期。一个好的 PRNG 应该有足够长的周期，以满足应用需求。</li>
<li><strong>统计随机性</strong>：生成的序列应该通过各种统计测试，表现出均匀分布、独立性等随机特性。</li>
<li><strong>速度快</strong>：通常是纯软件实现，计算效率高。</li>
</ul>
<h3 id="1-3-常见-PRNG-算法"><a href="#1-3-常见-PRNG-算法" class="headerlink" title="1.3 常见 PRNG 算法"></a>1.3 常见 PRNG 算法</h3><h4 id="1-3-1-线性同余生成器-Linear-Congruential-Generator-LCG"><a href="#1-3-1-线性同余生成器-Linear-Congruential-Generator-LCG" class="headerlink" title="1.3.1 线性同余生成器 (Linear Congruential Generator, LCG)"></a>1.3.1 线性同余生成器 (Linear Congruential Generator, LCG)</h4><p>LCG 是最早且最简单的 PRNG 算法之一，广泛用于非加密场景。它的公式如下：</p>
<p>$$X_{n+1} &#x3D; (aX_n + c) \pmod m$$</p>
<p>其中：</p>
<ul>
<li>$X_0$ 是初始种子 (seed)。</li>
<li>$X_n$ 是当前生成的伪随机数。</li>
<li>$X_{n+1}$ 是下一个伪随机数。</li>
<li>$a$ 是乘数 (multiplier)。</li>
<li>$c$ 是增量 (increment)。</li>
<li>$m$ 是模数 (modulus)。</li>
</ul>
<p>这些参数 $a, c, m$ 的选择至关重要，它们决定了 LCG 的周期和统计特性。</p>
<p><strong>Python 示例 (简化版 LCG)</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LCG</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, a, c, m</span>):</span><br><span class="line">        <span class="variable language_">self</span>.current_state = seed</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.c = c</span><br><span class="line">        <span class="variable language_">self</span>.m = m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.current_state = (<span class="variable language_">self</span>.a * <span class="variable language_">self</span>.current_state + <span class="variable language_">self</span>.c) % <span class="variable language_">self</span>.m</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.current_state</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">seed = <span class="number">12345</span></span><br><span class="line"><span class="comment"># 参数来自 C 语言标准库中的 rand() 函数</span></span><br><span class="line"><span class="comment"># a = 1103515245, c = 12345, m = 2^31</span></span><br><span class="line">lcg = LCG(seed, a=<span class="number">1103515245</span>, c=<span class="number">12345</span>, m=<span class="number">2</span>**<span class="number">31</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Generated numbers:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(lcg.<span class="built_in">next</span>())</span><br></pre></td></tr></table></figure>

<p><strong>LCG 的局限性</strong>：</p>
<ul>
<li>周期相对较短，可能无法满足高容量需求。</li>
<li>低位比特的随机性通常很差。</li>
<li>如果攻击者知道几个连续的输出，就很容易推导出 $a, c, m$ 和当前状态，从而预测未来的序列。</li>
</ul>
<h4 id="1-3-2-线性反馈移位寄存器-Linear-Feedback-Shift-Register-LFSR"><a href="#1-3-2-线性反馈移位寄存器-Linear-Feedback-Shift-Register-LFSR" class="headerlink" title="1.3.2 线性反馈移位寄存器 (Linear Feedback Shift Register, LFSR)"></a>1.3.2 线性反馈移位寄存器 (Linear Feedback Shift Register, LFSR)</h4><p>LFSR 是一种基于移位寄存器和异或操作的伪随机数生成器。它通常用于硬件实现，因其高速和低成本特性。其生成的序列被称为 M-序列，具有良好的统计特性，但在密码学中直接使用需要谨慎，因其线性结构易受攻击。</p>
<h4 id="1-3-3-梅森旋转算法-Mersenne-Twister"><a href="#1-3-3-梅森旋转算法-Mersenne-Twister" class="headerlink" title="1.3.3 梅森旋转算法 (Mersenne Twister)"></a>1.3.3 梅森旋转算法 (Mersenne Twister)</h4><p>梅森旋转算法 (MT19937) 是目前最广泛使用的 PRNG 之一，例如 Python 的 <code>random</code> 模块、PHP、Ruby、MATLAB 等都将其作为默认的 PRNG。</p>
<p><strong>主要优点</strong>：</p>
<ul>
<li><strong>周期极长</strong>：$2^{19937}-1$，这使得在实际应用中几乎不可能遇到重复序列。</li>
<li><strong>均匀分布</strong>：在多维空间中也具有良好的均匀分布特性。</li>
<li><strong>速度快</strong>：计算效率高。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>不具有加密安全性</strong>：如果知道其内部状态，可以完全预测未来的序列。因此，它不适用于需要高安全性的加密场景。</li>
</ul>
<h3 id="1-4-PRNG-的应用场景"><a href="#1-4-PRNG-的应用场景" class="headerlink" title="1.4 PRNG 的应用场景"></a>1.4 PRNG 的应用场景</h3><ul>
<li><strong>游戏开发</strong>：角色行为、事件触发、地图生成等。</li>
<li><strong>科学模拟</strong>：蒙特卡洛模拟、物理仿真、统计抽样等。</li>
<li><strong>测试数据生成</strong>：为软件测试提供随机输入。</li>
<li><strong>非安全哈希函数</strong>：一些简单的哈希算法内部可能使用 PRNG 的思想。</li>
</ul>
<h2 id="二、真随机数生成器-TRNG"><a href="#二、真随机数生成器-TRNG" class="headerlink" title="二、真随机数生成器 (TRNG)"></a>二、真随机数生成器 (TRNG)</h2><p><strong>真随机数生成器 (True Random Number Generator, TRNG)</strong>，也称为硬件随机数生成器 (Hardware Random Number Generator, HRNG)，利用物理世界中不可预测的随机事件来生成随机数。</p>
<h3 id="2-1-工作原理"><a href="#2-1-工作原理" class="headerlink" title="2.1 工作原理"></a>2.1 工作原理</h3><p>TRNG 的核心在于利用<strong>物理熵源 (Physical Entropy Source)</strong>。这些物理过程本质上是不可预测和不可重现的。TRNG 的工作流程通常如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    %% --- 物理采集层 ---
    subgraph EntropySource [&quot;1. Physical Entropy (物理熵源)&quot;]
        direction TB
        Source1((&quot;🔥 Thermal Noise &lt;br&#x2F;&gt; (热噪声)&quot;))
        Source2((&quot;🖱️ Human Input &lt;br&#x2F;&gt; (鼠标&#x2F;键盘)&quot;))
        Source3((&quot;🌌 Quantum Decay &lt;br&#x2F;&gt; (放射性衰变)&quot;))
    end

    %% --- 数字化层 ---
    subgraph Digitization [&quot;2. Digitization (量化与采集)&quot;]
        direction TB
        ADC[[&quot;&lt;b&gt;Transducer &#x2F; ADC&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;采样与模数转换&quot;]]
        RawBits[(&quot;Raw Bitstream&lt;br&#x2F;&gt;(带有偏差的原始序列)&quot;)]
    end

    %% --- 处理与监测层 ---
    subgraph Conditioning [&quot;3. Post-Processing (去偏与提取)&quot;]
        direction TB
        Health{&quot;🛡️ Health Test&lt;br&#x2F;&gt;(NIST SP 800-90B)&quot;}
        Whitening[[&quot;&lt;b&gt;Whitening Algorithm&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(XOR &#x2F; SHA-256 &#x2F; Von Neumann)&quot;]]
    end

    %% --- 逻辑连接 ---
    Source1 &amp; Source2 &amp; Source3 --&gt; ADC
    ADC --&gt; RawBits
    RawBits --&gt; Health
    
    Health -- &quot;Pass&quot; --&gt; Whitening
    Health -- &quot;Fail (Alarm)&quot; --&gt; Fail([Discard &amp; Halt])

    Whitening &#x3D;&#x3D;&gt; Output[&quot;✨ &lt;b&gt;High-Quality TRNG&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(真随机数输出)&quot;]

    %% --- 黑暗模式样式优化 ---
    %% 熵源：紫色（代表混沌与未知）
    style Source1 fill:#bf5af2,color:#fff,stroke:none
    style Source2 fill:#bf5af2,color:#fff,stroke:none
    style Source3 fill:#bf5af2,color:#fff,stroke:none
    
    %% 采集：蓝色（代表电子处理）
    style ADC fill:#0a84ff,color:#fff,stroke-width:2px
    style RawBits fill:#0a84ff,color:#fff,stroke:none
    
    %% 后处理：绿色（代表合格与安全）
    style Whitening fill:#30d158
  </pre></div>

<ol>
<li><strong>物理熵源</strong>：这是产生随机性的根源，例如：<ul>
<li><strong>热噪声</strong>：电子设备（如电阻、二极管）中电子的不规则热运动产生的噪声。</li>
<li><strong>大气噪声</strong>：来自无线电波、宇宙射线等自然现象产生的噪声。</li>
<li><strong>放射性衰变</strong>：原子核衰变的时间是不可预测的。</li>
<li><strong>实时事件</strong>：用户输入（键盘按键时间间隔、鼠标移动）、磁盘I&#x2F;O时间、网络数据包到达时间、风扇转速、处理器内部不稳定震荡等。</li>
</ul>
</li>
<li><strong>原始数据采集</strong>：将物理现象转化为电信号，并进行模数转换 (ADC) 和数字化，得到原始的二进制数据。</li>
<li><strong>熵提取 &#x2F; 后处理</strong>：原始数据可能包含偏差（某些位更可能为0或1）或相关性。熵提取算法（如密码学哈希函数、von Neumann extractor等）用于消除这些偏差，并“白化” (whiten) 数据，从而提高随机质量和不可预测性。这个过程通常也称为<strong>熵池 (Entropy Pool)</strong>。</li>
</ol>
<h3 id="2-2-真随机数的关键特性"><a href="#2-2-真随机数的关键特性" class="headerlink" title="2.2 真随机数的关键特性"></a>2.2 真随机数的关键特性</h3><ul>
<li><strong>不可预测性</strong>：这是 TRNG 最重要的特性。即使知道当前的输出和生成机制，也无法预测下一个输出。</li>
<li><strong>非确定性</strong>：每次生成的序列都是独一无二的，无法重现。</li>
<li><strong>依赖硬件</strong>：需要特定的物理硬件来捕获熵源。</li>
<li><strong>速度慢</strong>：相较于 PRNG，从物理熵源采集和处理数据通常速度较慢。</li>
<li><strong>成本较高</strong>：通常需要专门的硬件电路。</li>
</ul>
<h3 id="2-3-TRNG-的应用场景"><a href="#2-3-TRNG-的应用场景" class="headerlink" title="2.3 TRNG 的应用场景"></a>2.3 TRNG 的应用场景</h3><ul>
<li><strong>密码学</strong>：生成加密密钥、一次性密码本 (OTP)、初始化向量 (IV)、数字签名中的随机数等。</li>
<li><strong>安全协议</strong>：TLS&#x2F;SSL 握手中的随机数，挑战应答协议。</li>
<li><strong>彩票抽奖系统</strong>：需要绝对公正和不可预测的结果。</li>
<li><strong>区块链</strong>：挖矿、随机数选择等。</li>
</ul>
<h2 id="三、操作系统中的随机数机制"><a href="#三、操作系统中的随机数机制" class="headerlink" title="三、操作系统中的随机数机制"></a>三、操作系统中的随机数机制</h2><p>现代操作系统（如 Linux）提供了接口来访问高质量的随机数，通常结合了 PRNG 和 TRNG 的优点。</p>
<h3 id="3-1-Linux-dev-random-和-dev-urandom"><a href="#3-1-Linux-dev-random-和-dev-urandom" class="headerlink" title="3.1 Linux /dev/random 和 /dev/urandom"></a>3.1 Linux <code>/dev/random</code> 和 <code>/dev/urandom</code></h3><p>Linux 内核维护一个<strong>熵池</strong>，收集来自各种硬件事件的随机性（如键盘输入时间、鼠标移动、磁盘I&#x2F;O、网络活动等）。</p>
<ul>
<li><p><strong><code>/dev/random</code></strong>：</p>
<ul>
<li><strong>阻塞性</strong>：当熵池中的可用熵量不足时，<code>/dev/random</code> 会<strong>阻塞</strong>，直到收集到足够的新的熵。</li>
<li><strong>用途</strong>：理论上提供最高质量的真随机数，适用于生成长期加密密钥等对随机性要求极高的场景。</li>
<li><strong>缺点</strong>：可能导致系统性能下降，因为读取操作可能会长时间等待。</li>
</ul>
</li>
<li><p><strong><code>/dev/urandom</code></strong>：</p>
<ul>
<li><strong>非阻塞性</strong>：即使熵池中的熵量不足，<code>/dev/urandom</code> 也<strong>不会阻塞</strong>。它会利用熵池中已有的熵，结合一个强大密码学安全的 PRNG (CSPRNG) 来生成伪随机数。</li>
<li><strong>用途</strong>：适用于大多数需要随即数的场景，包括会话密钥、TLS&#x2F;SSL 随机数等。</li>
<li><strong>缺点</strong>：在系统刚启动时，熵池可能为空，此时 <code>/dev/urandom</code> 生成的随机数质量可能较低（因为都是基于初始少量熵种子生成的伪随机数），但在系统运行一段时间后，熵池会被补充，其输出的随机数质量通常足以满足密码学需求。</li>
</ul>
</li>
</ul>
<p><strong>建议</strong>：在大多数实际应用中，包括加密应用，<strong>推荐使用 <code>/dev/urandom</code></strong>，因为它不会阻塞系统，且其安全性足以满足绝大多数需求。只有在极少数对系统启动阶段随机性有超高要求的场景下才考虑 <code>/dev/random</code>。</p>
<h2 id="四、加密安全伪随机数生成器-CSPRNG"><a href="#四、加密安全伪随机数生成器-CSPRNG" class="headerlink" title="四、加密安全伪随机数生成器 (CSPRNG)"></a>四、加密安全伪随机数生成器 (CSPRNG)</h2><p>由于 TRNG 速度慢且依赖硬件，而纯 PRNG 不具备加密安全性，因此在实际的密码学应用中，我们通常使用 <strong>加密安全伪随机数生成器 (Cryptographically Secure Pseudo-Random Number Generator, CSPRNG)</strong>。</p>
<h3 id="4-1-工作原理"><a href="#4-1-工作原理" class="headerlink" title="4.1 工作原理"></a>4.1 工作原理</h3><p>CSPRNG 是一个特殊的 PRNG，其设计目标是满足严格的密码学安全要求。它通常结合了 TRNG 的熵源和复杂精密的 PRNG 算法。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TB
    %% --- 采集层 ---
    subgraph Harvesting [&quot;1. Entropy Harvesting&quot;]
        TRNG([&quot;🎲 Hardware&lt;br&#x2F;&gt;TRNG &#x2F; HRNG&quot;])
        OS([&quot;🌀 OS Entropy&lt;br&#x2F;&gt;(Noise&#x2F;Interrupts)&quot;])
    end

    %% --- 累积层 ---
    subgraph Accumulation [&quot;2. Entropy Accumulation&quot;]
        Pool[(&quot;&lt;b&gt;Entropy Pool&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(Mixing &amp; Hashing)&quot;)]
    end

    %% --- 核心引擎层 ---
    subgraph DRBG [&quot;3. CSPRNG Engine&quot;]
        direction TB
        State[&quot;&lt;b&gt;Internal State&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(Key, Counter, V)&quot;]
        Crypto[&quot;🛡️ &lt;b&gt;Crypto Core&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(AES &#x2F; ChaCha)&quot;]
        
        State --&gt; Crypto
        Crypto -- &quot;Update&lt;br&#x2F;&gt;State&quot; --&gt; State
    end

    %% --- 逻辑流 ---
    TRNG &amp; OS --&gt; Pool
    Pool -- &quot;Reseed&quot; --&gt; State

    %% 输出
    Crypto &#x3D;&#x3D;&gt; Output[&quot;✨ &lt;b&gt;CSPRNG Output&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(Secure Bits)&quot;]

    %% 反馈与抗性
    Output -.-&gt;|Backtracking&lt;br&#x2F;&gt;Resistance| State

    %% --- 样式美化 ---
    style TRNG fill:#bc8cff,color:#000,stroke:none
    style OS fill:#bc8cff,color:#000,stroke:none
    style Pool fill:#1f6feb,color:#fff,stroke:#79c0ff,stroke-width:2px
    style State fill:#388bfd,color:#fff,stroke:none
    style Crypto fill:#d29922,color:#000,font-weight:bold,stroke:#f1e05a
    style Output fill:#3fb950,color:#000,font-weight:bold
    
    %% 连线颜色手动微调
    linkStyle 4 stroke:#f1e05a,stroke-width:2px,stroke-dasharray: 5 5
  </pre></div>

<ol>
<li><strong>初始种子</strong>：CSPRNG 必须使用高质量的真随机数作为初始种子。</li>
<li><strong>复杂算法</strong>：CSPRNG 使用复杂的数学和密码学算法（如分组密码的计数器模式、哈希函数等）来生成伪随机数。</li>
<li><strong>定期重播种 (Reseeding)</strong>：CSPRNG 会定期从熵池中获取新的真随机熵来更新其内部状态，以提高安全性，防止长时间运行后可能的预测性。</li>
</ol>
<h3 id="4-2-CSPRNG-的安全要求"><a href="#4-2-CSPRNG-的安全要求" class="headerlink" title="4.2 CSPRNG 的安全要求"></a>4.2 CSPRNG 的安全要求</h3><ul>
<li><strong>前向安全 (Forward Secrecy)</strong>：即使攻击者知道了 CSPRNG 某个时刻的内部状态，也无法推导出其之前生成的随机数序列。</li>
<li><strong>后向安全 (Backward Secrecy)</strong>：即使攻击者知道了 CSPRNG 某个时刻的内部状态，也无法推导出其之后生成的随机数序列（除非攻击者能够持续获取未来用于重播种的熵）。</li>
<li><strong>不可预测性</strong>：通过任何多项式时间算法都无法区分其输出和真正的随机序列。</li>
<li><strong>统计均匀性</strong>：通过所有已知的统计测试。</li>
</ul>
<h3 id="4-3-常见的-CSPRNG-算法"><a href="#4-3-常见的-CSPRNG-算法" class="headerlink" title="4.3 常见的 CSPRNG 算法"></a>4.3 常见的 CSPRNG 算法</h3><ul>
<li><strong>AES-CTR DRBG</strong>：基于 AES 分组密码的计数器模式，被 NIST 推荐。</li>
<li><strong>Fortuna</strong>：由 Bruce Schneier 和 Niels Ferguson 设计，强调持续收集熵和多重熵源。</li>
<li><strong>Yarrow</strong>：类似于 Fortuna，也是一个基于散列函数的构造。</li>
<li><strong>Blum Blum Shub (BBS)</strong>：具有可证明的安全性，但速度非常慢，不适合实际应用，主要用于理论研究。</li>
</ul>
<h3 id="4-4-Python-中的-CSPRNG"><a href="#4-4-Python-中的-CSPRNG" class="headerlink" title="4.4 Python 中的 CSPRNG"></a>4.4 Python 中的 CSPRNG</h3><p>Python 的 <code>os.urandom()</code> 函数是用来生成加密安全随机数的接口。它通常会依赖于操作系统提供的 CSPRNG（如 Linux 的 <code>/dev/urandom</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成高质量的随机字节串</span></span><br><span class="line">random_bytes = os.urandom(<span class="number">16</span>) <span class="comment"># 生成16个随机字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Random bytes:&quot;</span>, random_bytes.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机整数 (需要进一步处理)</span></span><br><span class="line"><span class="comment"># 例如，生成一个 0 到 99 之间的随机整数</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">random_int = struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>, os.urandom(<span class="number">4</span>))[<span class="number">0</span>] % <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Random integer (0-99):&quot;</span>, random_int)</span><br></pre></td></tr></table></figure>

<h2 id="五、随机数质量评估"><a href="#五、随机数质量评估" class="headerlink" title="五、随机数质量评估"></a>五、随机数质量评估</h2><p>评估随机数生成器质量的主要指标包括：</p>
<ol>
<li><strong>周期 (Period)</strong>：序列重复之前的长度，越长越好。</li>
<li><strong>均匀性 (Uniformity)</strong>：序列中各个值出现的频率应大致相等。</li>
<li><strong>独立性 (Independence)</strong>：序列中的每个数都应独立于之前的数，没有可察觉的相关性。</li>
<li><strong>不可预测性 (Unpredictability)</strong>：这是最高级别的要求，尤其对于密码学应用，意味着无法从已知的序列中推断出未来的数。</li>
</ol>
<p><strong>统计测试</strong>：有专门的统计测试套件来评估随机数的质量，例如：</p>
<ul>
<li><strong>Diehard Tests</strong> (George Marsaglia)</li>
<li><strong>NIST SP 800-22</strong> (National Institute of Standards and Technology)</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>计算机随机数生成是一个复杂而重要的领域。理解 PRNG、TRNG 和 CSPRNG 的区别及其工作原理至关重要。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">伪随机数生成器 (PRNG)</th>
<th align="left">真随机数生成器 (TRNG)</th>
<th align="left">加密安全伪随机数生成器 (CSPRNG)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>随机源</strong></td>
<td align="left">确定性算法 + 种子</td>
<td align="left">物理熵源 (热噪声, 用户行为)</td>
<td align="left">复杂算法 + 初始真随机熵 + 定期重播种</td>
</tr>
<tr>
<td align="left"><strong>可预测性</strong></td>
<td align="left"><strong>可预测</strong> (知道种子和算法)</td>
<td align="left"><strong>不可预测</strong></td>
<td align="left"><strong>设计上不可预测</strong> (即使部分状态泄露)</td>
</tr>
<tr>
<td align="left"><strong>可重现性</strong></td>
<td align="left"><strong>可重现</strong> (相同种子)</td>
<td align="left"><strong>不可重现</strong></td>
<td align="left"><strong>无法重现</strong> (除非知道完整历史熵)</td>
</tr>
<tr>
<td align="left"><strong>速度</strong></td>
<td align="left"><strong>快</strong></td>
<td align="left"><strong>慢</strong></td>
<td align="left"><strong>相对较快</strong> (比TRNG快，比PRNG稍慢)</td>
</tr>
<tr>
<td align="left"><strong>依赖硬件</strong></td>
<td align="left">无</td>
<td align="left"><strong>有</strong></td>
<td align="left">主要依赖软件，但需要硬件熵源</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>无加密安全性</strong></td>
<td align="left"><strong>高</strong></td>
<td align="left"><strong>非常高</strong></td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">游戏，模拟，非敏感数据</td>
<td align="left">密钥生成，数字签名，启动熵</td>
<td align="left">绝大多数密码学应用，安全协议</td>
</tr>
</tbody></table>
<p>在实际应用中，务必根据对随机数质量和安全性的需求，选择合适的随机数生成器。对于所有涉及安全或加密的场景，<strong>始终使用 CSPRNG</strong>，并通过操作系统提供的安全接口（如 <code>os.urandom()</code>）来获取。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/9d4cfe955d7d/">https://blog.tbf1211.xx.kg/9d4cfe955d7d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-09.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/884dd81c798b/" title="Pinia Colada详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Pinia Colada详解</div></div><div class="info-2"><div class="info-item-1"> Pinia Colada 是一个为 Vue 3 和 Pinia 设计的高级数据管理和持久化工具，旨在简化异步数据获取、缓存、以及状态在浏览器存储中的持久化。它将 Pinia 的核心优势与强大的数据管理策略相结合，帮助开发者构建更健壮、响应更快、用户体验更流畅的 Web 应用。  核心思想：Pinia Colada 致力于将数据获取 (Fetching)、数据缓存 (Caching)、数据持久化 (Persistence) 和 后端状态同步 (Synchronization) 等复杂逻辑封装在易于使用的 Pinia Store 抽象之上。它使得处理异步数据像管理本地状态一样简单，同时提供声明式的 API 来控制数据的生命周期。   一、为什么需要 Pinia Colada？在现代 Web 应用中，处理异步数据（如来自 API 的数据）和管理其生命周期是一个常见的挑战。仅仅依靠 Pinia 的 actions 来 fetch 数据，并不能很好地解决以下问题：  数据重复请求：多个组件可能请求相同的数据，导致不必要的网络开销。 请求加载状态管理：手动维护每个请求的 loading 和...</div></div></div></a><a class="pagination-related" href="/dd818a0507ce/" title="UUID (Universally Unique Identifier) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UUID (Universally Unique Identifier) 详解</div></div><div class="info-2"><div class="info-item-1"> UUID (Universally Unique Identifier)，即通用唯一标识符，是一个由 128 位数字组成的标识符，用于在计算机系统中保证局部或全局的唯一性。它也被称为 GUID (Globally Unique Identifier)，特别是在微软的实现中。UUID 的设计目标是在不依赖中央协调机构的情况下，使得分布式系统中的每个实体都能拥有一个足够唯一的标识符，从而避免冲突。  核心思想：UUID 是一种 128 位的数字，通过特定的算法生成，旨在在分布式环境中提供极高的唯一性，无需中央协调。    一、为什么需要 UUID？在现代分布式系统、微服务架构和大型数据库应用中，生成唯一标识符是一个常见而关键的需求。传统的自增 ID（如数据库主键）存在以下问题：  中心化瓶颈： 需要一个中心化的数据库来管理和生成 ID，成为系统的单点故障或性能瓶颈。 分布式冲突： 在多个服务或节点独立生成 ID 时，容易发生冲突。 可预测性： 连续的自增 ID 容易被预测，可能带来安全风险。 数据迁移和合并： 合并来自不同数据库的数据时，自增 ID 可能会重复。  UUID 提供了...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/b8edc2276249/" title="雪花算法 (Snowflake Algorithm) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-19</div><div class="info-item-2">雪花算法 (Snowflake Algorithm) 详解</div></div><div class="info-2"><div class="info-item-1"> 雪花算法 (Snowflake Algorithm) 是 Twitter 公司开源的一种分布式唯一 ID 生成算法。它旨在解决在分布式系统中生成全局唯一、递增（但非严格递增）且高性能 ID 的需求。其生成的 ID 是一个 64 位的整数，具有时间有序性，并且不依赖于数据库，易于扩展。  核心思想：将 64 位的 Long 型 ID 拆分为多个字段，分别存储时间戳、数据中心 ID、机器 ID 和序列号，通过位运算拼接以保证全局唯一性和大致的时间有序性。   一、为什么需要雪花算法？在分布式系统中，传统的单点自增 ID 方案面临巨大挑战：  唯一性问题：不同的数据库实例或服务节点可能生成相同的 ID。 性能瓶颈：为了保证唯一性，可能需要引入中心化的 ID 生成服务或数据库锁，成为系统瓶颈。 可用性问题：中心化服务一旦宕机，整个系统的 ID 生成将受影响。  虽然 UUID 能够保证全局唯一性，但它存在一些缺点：  存储和传输效率低：128 位，比 64 位 ID 更占用空间，索引性能较差。 无序性：UUID 是无序的，插入数据库时会导致 B+ 树索引频繁分裂和重建，影响数据库性能。...</div></div></div></a><a class="pagination-related" href="/dd818a0507ce/" title="UUID (Universally Unique Identifier) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-24</div><div class="info-item-2">UUID (Universally Unique Identifier) 详解</div></div><div class="info-2"><div class="info-item-1"> UUID (Universally Unique Identifier)，即通用唯一标识符，是一个由 128 位数字组成的标识符，用于在计算机系统中保证局部或全局的唯一性。它也被称为 GUID (Globally Unique Identifier)，特别是在微软的实现中。UUID 的设计目标是在不依赖中央协调机构的情况下，使得分布式系统中的每个实体都能拥有一个足够唯一的标识符，从而避免冲突。  核心思想：UUID 是一种 128 位的数字，通过特定的算法生成，旨在在分布式环境中提供极高的唯一性，无需中央协调。    一、为什么需要 UUID？在现代分布式系统、微服务架构和大型数据库应用中，生成唯一标识符是一个常见而关键的需求。传统的自增 ID（如数据库主键）存在以下问题：  中心化瓶颈： 需要一个中心化的数据库来管理和生成 ID，成为系统的单点故障或性能瓶颈。 分布式冲突： 在多个服务或节点独立生成 ID 时，容易发生冲突。 可预测性： 连续的自增 ID 容易被预测，可能带来安全风险。 数据迁移和合并： 合并来自不同数据库的数据时，自增 ID 可能会重复。  UUID 提供了...</div></div></div></a><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/9186b4c4e58d/" title="重放攻击 (Replay Attack) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="info-item-2">重放攻击 (Replay Attack) 详解</div></div><div class="info-2"><div class="info-item-1"> 重放攻击 (Replay Attack)，又称回放攻击或重播攻击，是计算机网络安全领域中的一种常见攻击方式。其基本原理是攻击者通过窃听（截获）合法的网络通信数据包，然后将这些截获到的数据包原封不动地重新发送给一个或多个目标系统，以此来欺骗系统或获得未授权的效应。即使攻击者不知道数据包内容的具体含义，也可以通过重放这些合法的数据包来达到攻击目的。  核心思想：攻击者窃取一次成功的会话或请求，并在之后的时间里重复发送这段数据，以冒充合法用户获得同样的权限或发起相同的操作。   一、重放攻击的工作原理重放攻击的步骤通常如下：  窃听 (Eavesdropping)：攻击者使用网络嗅探工具（如 Wireshark）在网络上监听和截获合法用户与服务器之间的通信。这可能包括登录凭证（尽管通常是哈希或加密的）、交易请求、授权令牌等。 截获 (Interception)：攻击者捕获到完整的、有效的通信数据包或消息序列。 重放 (Replay)：在一段时间之后，攻击者将这些截获到的数据包原封不动地重新发送给目标服务器。 欺骗 (Deception)：如果目标服务器没有有效的机制来验证请求的新鲜性...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a><a class="pagination-related" href="/6014745b242a/" title="ARP (Address Resolution Protocol) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-31</div><div class="info-item-2">ARP (Address Resolution Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> ARP (Address Resolution Protocol)，即地址解析协议，是一个在局域网 (LAN) 内使用的网络层协议，主要用于将IP 地址 (网络层地址)解析为MAC 地址 (数据链路层地址)。在 TCP&#x2F;IP 协议栈中，当一台主机知道目标主机的 IP 地址，但需要知道其在同一物理网络上的 MAC 地址才能进行数据帧的发送时，就会使用 ARP 协议。  核心思想：将逻辑地址 (IP) 映射到物理地址 (MAC)，使得 IP 数据包能够在数据链路层封装成帧并通过物理网络介质传输到正确的目标设备。   一、为什么需要 ARP？在理解 ARP 之前，我们需要明确 IP 地址和 MAC 地址在网络通信中的角色：  IP 地址 (Internet Protocol Address)：工作在 OSI 模型的第三层 (网络层)。它是一个逻辑地址，用于在不同网络之间识别和路由数据包。IP 地址是分层的，包含网络部分和主机部分，使得路由器能够根据网络部分将数据包转发到正确的网络。 MAC 地址 (Media Access Control Address)：工作在 OSI ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8-PRNG"><span class="toc-text">一、伪随机数生成器 (PRNG)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.1 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-text">1.2 伪随机数的关键特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%B8%B8%E8%A7%81-PRNG-%E7%AE%97%E6%B3%95"><span class="toc-text">1.3 常见 PRNG 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E7%94%9F%E6%88%90%E5%99%A8-Linear-Congruential-Generator-LCG"><span class="toc-text">1.3.1 线性同余生成器 (Linear Congruential Generator, LCG)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8-Linear-Feedback-Shift-Register-LFSR"><span class="toc-text">1.3.2 线性反馈移位寄存器 (Linear Feedback Shift Register, LFSR)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95-Mersenne-Twister"><span class="toc-text">1.3.3 梅森旋转算法 (Mersenne Twister)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-PRNG-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1.4 PRNG 的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8-TRNG"><span class="toc-text">二、真随机数生成器 (TRNG)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.1 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-text">2.2 真随机数的关键特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-TRNG-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.3 TRNG 的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">三、操作系统中的随机数机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Linux-dev-random-%E5%92%8C-dev-urandom"><span class="toc-text">3.1 Linux &#x2F;dev&#x2F;random 和 &#x2F;dev&#x2F;urandom</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8A%A0%E5%AF%86%E5%AE%89%E5%85%A8%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8-CSPRNG"><span class="toc-text">四、加密安全伪随机数生成器 (CSPRNG)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-CSPRNG-%E7%9A%84%E5%AE%89%E5%85%A8%E8%A6%81%E6%B1%82"><span class="toc-text">4.2 CSPRNG 的安全要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%B8%B8%E8%A7%81%E7%9A%84-CSPRNG-%E7%AE%97%E6%B3%95"><span class="toc-text">4.3 常见的 CSPRNG 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Python-%E4%B8%AD%E7%9A%84-CSPRNG"><span class="toc-text">4.4 Python 中的 CSPRNG</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%9A%8F%E6%9C%BA%E6%95%B0%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BC%B0"><span class="toc-text">五、随机数质量评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d819fc26cbc7/" title="共识算法详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="共识算法详解"/></a><div class="content"><a class="title" href="/d819fc26cbc7/" title="共识算法详解">共识算法详解</a><time datetime="2026-02-19T22:24:00.000Z" title="发表于 2026-02-20 06:24:00">2026-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1c5cbb334a2a/" title="计算机中熵的详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机中熵的详解"/></a><div class="content"><a class="title" href="/1c5cbb334a2a/" title="计算机中熵的详解">计算机中熵的详解</a><time datetime="2026-02-17T22:24:00.000Z" title="发表于 2026-02-18 06:24:00">2026-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/9ed85cc18e8a/" title="CSP并发模型详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSP并发模型详解"/></a><div class="content"><a class="title" href="/9ed85cc18e8a/" title="CSP并发模型详解">CSP并发模型详解</a><time datetime="2026-02-15T22:24:00.000Z" title="发表于 2026-02-16 06:24:00">2026-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0d177e0002e6/" title="程序错误处理详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序错误处理详解"/></a><div class="content"><a class="title" href="/0d177e0002e6/" title="程序错误处理详解">程序错误处理详解</a><time datetime="2026-02-13T22:24:00.000Z" title="发表于 2026-02-14 06:24:00">2026-02-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-09.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.1.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>