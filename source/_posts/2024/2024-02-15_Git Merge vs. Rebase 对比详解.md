---
title: Git Merge vs. Rebase 对比详解
date: 2024-02-15 06:24:00
tags:
  - 2024
  - 开发工具
  - Git
categories:
  - 开发工具
  - Git
---

> 在 Git 版本控制系统中，`git merge` 和 `git rebase` 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。

{% note info %}
核心思想：`git merge` 通过创建**新的合并提交**来集成更改，保留了所有分支的历史；`git rebase` 通过**重写提交历史**将一个分支的提交应用到另一个分支的顶部，从而创建线性的历史记录。
{% endnote %}
------

## 一、Git Merge (合并)

### 1.1 定义

**`git merge`** 命令用于将来自一个或多个分支的独立开发历史合并到当前分支。它通过创建一个**新的合并提交 (merge commit)** 来实现这一点，这个合并提交的父提交指向两个被合并分支的最新提交。这意味着 `git merge` 会保留所有分支的原始提交历史，并显式地记录合并发生的时间和地点。

### 1.2 工作原理

当执行 `git merge <branch_name>` 时：

1.  Git 找到当前分支 (`HEAD`) 和 `<branch_name>` 之间最新的共同祖先 (common ancestor)。
2.  它将 `<branch_name>` 上的更改应用到当前分支，并尝试将它们合并。
3.  如果两个分支的历史已经分叉（即在共同祖先之后都有各自的提交），并且存在冲突，你需要手动解决冲突。
4.  解决冲突后，Git 会创建一个新的合并提交，这个提交有两个父提交：一个是当前分支的最新提交，另一个是 `<branch_name>` 的最新提交。

**两种主要合并方式：**

*   **快进合并 (Fast-Forward Merge)**：如果当前分支的最新提交是另一个分支的直接祖先，Git 会直接将当前分支的指针向前移动到另一个分支的最新提交，不创建新的合并提交。这种情况只发生在合并分支没有在共同祖先之后有任何新的提交时。
    {% mermaid %}
    gitGraph
        commit id: "C1"
        commit id: "C2"
        branch feature
        checkout feature
        commit id: "F1"
        commit id: "F2"
        checkout main
        merge feature
    {% endmermaid %}
    *上述图示中，如果main分支只有C1、C2，feature分支有F1、F2，且main是feature的直接祖先，则merge feature后，main会直接指向F2，形成一条直线。*

*   **三方合并 (Three-Way Merge)**：当两个分支的历史已经分叉时，Git 会创建一个新的合并提交。这是最常见的合并方式，也是 `git merge` 的核心特性。
    {% mermaid %}
    gitGraph
        commit id: "A"
        commit id: "B"
        branch feature
        checkout feature
        commit id: "C"
        checkout main
        commit id: "D"
        merge feature
        commit id: "M"
    {% endmermaid %}
    上图中，`A` 是共同祖先，`D` 是 `main` 的最新提交，`C` 是 `feature` 的最新提交，`M` 是合并提交。

### 1.3 优点

*   **非破坏性**：`git merge` 不会改写任何现有的提交历史。它保留了所有分支的原始历史记录，是一个安全的操作。
*   **可追溯性**：合并提交明确地指出了两个分支何时、何地以及如何被集成。这使得追溯项目的历史、理解分支的生命周期变得容易。
*   **记录分支历史**：通过合并提交，你可以清楚地看到每个分支的开发路径，以及它们是如何汇聚在一起的。

### 1.4 缺点

*   **历史记录复杂**：如果频繁地进行合并，项目的提交历史可能会变得非常复杂和混乱，充斥着大量的合并提交，形成“钻石”形状的非线性历史。
*   **可读性降低**：复杂的历史记录可能会使 `git log` 输出难以阅读和理解，尤其是在处理大型项目或长期存在的分支时。

### 1.5 适用场景

*   **公共分支集成**：将功能分支合并到长期存在的公共分支（如 `develop` 或 `main`）时，通常使用 `merge` 来保留完整的历史记录。
*   **发布分支合并**：`release` 分支完成后，合并到 `main` 和 `develop` 时，应使用 `merge`。
*   **需要保留完整历史记录的场景**：例如，审计日志或需要清晰展示所有分支演变路径的项目。
*   **团队协作中已共享的分支**：在团队中共享的功能分支上，通常建议使用 `merge`，因为 `rebase` 会改写历史，给其他协作者带来麻烦。

## 二、Git Rebase (变基)

### 2.1 定义

**`git rebase`** 命令用于将一系列提交从一个分支移动或复制到另一个分支的顶部。它的核心思想是**重写提交历史**，使得提交看起来就像是在目标分支上顺序进行的，从而创建出一条线性的历史记录。

### 2.2 工作原理

当执行 `git rebase <base_branch>` 命令时，Git 会执行以下操作：

1.  Git 找到当前分支 (`HEAD`) 和 `<base_branch>` 之间最新的共同祖先。
2.  它将当前分支上，从共同祖先到当前分支 `HEAD` 的所有提交**暂时存储**起来（这些是当前分支独有的提交）。
3.  然后，它会将当前分支的 `HEAD` 移动到 `<base_branch>` 的最新提交上。
4.  最后，Git 会将之前存储的那些提交**逐个重新应用 (re-apply)** 到新的 `HEAD` 上。

*重要的是，在重新应用提交时，Git 会为这些提交生成**新的提交哈希 (commit hash)**。* 这就是为什么 `rebase` 会**重写历史**的原因。

**`git rebase` 示例：**

{% mermaid %}
gitGraph
    commit id: "A"
    commit id: "B"
    branch feature
    checkout feature
    commit id: "C"
    checkout main
    commit id: "D"
    checkout feature
    commit id: "C'"
    checkout main
    merge feature
    commit id: "E"
{% endmermaid %}
上图中，`A` 是共同祖先，`D` 是 `main` 的最新提交，`C` 是 `feature` 的最新提交。`rebase` 后，`feature` 分支的 `C` 提交被重新应用为 `C'`，历史记录变得线性。最终 `main` 合并 `feature` 只需要快进合并（`E` 即 `C'`）。

### 2.3 优点

*   **清晰、线性的历史记录**：`rebase` 消除了合并提交，使得项目的提交历史看起来像一条直线，非常整洁和易于阅读。
*   **简化合并**：在 `rebase` 之后，将功能分支合并回 `main` 或 `develop` 通常可以通过**快进合并 (fast-forward merge)** 完成，避免了额外的合并提交。
*   **更容易查找 Bug**：线性的历史记录和更少的合并提交使得使用 `git bisect` 等工具查找引入 Bug 的提交变得更加容易。
*   **提交优化**：配合 `git rebase -i` (交互式变基)，可以在合并前清理、修改、压缩或重新排序提交，优化提交历史。

### 2.4 缺点

*   **破坏性**：`git rebase` 会改写提交历史。被 `rebase` 的提交会获得新的提交哈希，这会使得 Git 认为它们是全新的提交。
*   **团队协作风险**：**这是 `rebase` 最大的风险。** 如果你 `rebase` 了一个已经被推送到远程仓库并且其他团队成员正在其基础上进行开发的分支，那么当其他人尝试与远程仓库同步时，将会遇到历史冲突（因为他们的本地历史与远程历史不匹配），导致复杂的问题。
    *   **黄金法则：** **"不要对已经推送到公共仓库的提交进行 rebase。"**
*   **操作复杂性**：相比 `merge`，`rebase` 在解决冲突或处理复杂场景时可能需要更深入的 Git 理解。

### 2.5 适用场景

*   **清理个人功能分支**：在将个人开发的功能分支推送到远程或合并到公共分支之前，使用 `rebase` 将其变基到最新的 `develop` 或 `main` 分支上，以保持一个干净、线性的提交历史。
*   **私有分支工作流**：如果你在一个私有的、未共享的分支上工作，并且希望保持提交历史整洁，`rebase` 是一个好选择。
*   **准备 Pull Request (PR) 或 Merge Request (MR)**：在提交 PR/MR 之前，将你的功能分支 `rebase` 到目标分支的最新状态，可以使你的 PR/MR 看起来更整洁，更容易审查和合并。
*   **修改提交历史**：通过 `git rebase -i` 可以对提交进行修改、合并、删除等操作，用于优化提交历史。

## 三、Merge vs. Rebase 核心对比

下表总结了 `git merge` 和 `git rebase` 的主要区别：

| 特性       | Git Merge (合并)                          | Git Rebase (变基)                             |
| :--------- | :---------------------------------------- | :-------------------------------------------- |
| **历史记录** | 非线性，保留所有分支的原始历史，有合并提交。 | 线性，通过重写历史消除合并提交。            |
| **提交类型** | 创建新的合并提交。                        | 重新应用现有提交，生成新的提交哈希。        |
| **安全性** | 非破坏性，非常安全。                      | 破坏性，会改写提交历史，在公共分支上危险。  |
| **冲突处理** | 在创建合并提交时一次性解决所有冲突。      | 在重新应用每个冲突提交时，逐个解决冲突。    |
| **易用性** | 相对简单，适合新手。                      | 相对复杂，需要更深入的理解，可能造成困惑。  |
| **适用场景** | 公共分支集成、需要保留完整历史的项目、已共享的分支。 | 清理个人功能分支、优化提交历史、使 PR 更简洁。 |
| **何时避免** | 几乎没有需要避免的场景，除非追求极致线性历史。 | **绝不能**对已经推送到公共仓库的提交进行 rebase。 |

## 四、最佳实践与建议

1.  **坚持“黄金法则”：** **永远不要 `rebase` 已经推送到远程仓库并与其他团队成员共享的分支上的提交。** 如果你这样做了，你将改写历史，导致其他协作者在与远程同步时遇到冲突。为了修复这些问题，他们将不得不回滚或强制推送，这会带来混乱和数据丢失的风险。
2.  **在功能分支上使用 `rebase`：**
    *   在将你的本地功能分支合并到 `develop` 或 `main` 之前，你可以将其 `rebase` 到目标分支的最新版本。这会使你的功能分支看起来像是从最新的 `develop`/`main` 开始的，从而实现快进合并，保持主分支的整洁。
    *   这个操作应该在你**本地的功能分支**上进行，并且在**推送到远程之前**完成。
    *   示例：
        ```bash
        git checkout feature-branch
        git pull origin feature-branch # 确保本地 feature-branch 最新
        git rebase develop # 将 feature-branch 变基到 develop
        # 如果有冲突，解决冲突后执行 `git add .` 和 `git rebase --continue`
        git push origin feature-branch --force-with-lease # 变基后需要强制推送 (仅限个人未共享分支)
        ```
3.  **在公共分支上使用 `merge`：**
    *   对于 `develop`、`main` 或 `main` 等公共分支，通常建议使用 `merge`。这保留了所有历史记录，包括功能分支何时何地被集成。
    *   考虑使用 `git merge --no-ff`：即使可以进行快进合并，`--no-ff` 选项也会强制创建一个合并提交。这能显式记录合并事件，即使历史记录是线性的，也能清晰地看到功能的集成点。
    *   示例 (将 feature 合并到 develop)：
        ```bash
        git checkout develop
        git pull origin develop # 确保本地 develop 最新
        git merge --no-ff feature-branch
        git push origin develop
        ```
4.  **根据团队协议选择：** 最终，选择 `merge` 还是 `rebase` 很大程度上取决于团队的工作流偏好。重要的是团队成员之间达成共识，并严格遵守统一的实践。
5.  **交互式变基 (`git rebase -i`)：** 这是一种强大的工具，可以在将提交合并到主线之前，清理和优化你的提交历史（如合并多个小提交、修改提交信息、删除不需要的提交）。这应该只在你的**本地非共享分支**上进行。

## 五、总结

`git merge` 和 `git rebase` 各有其优势和劣势。`merge` 是非破坏性的，保留了完整的项目历史，但可能导致复杂的提交图。`rebase` 创建了干净、线性的历史记录，但会重写历史，在处理已共享的分支时存在风险。

理解它们的工作原理和适用场景，并遵循“不在公共分支上 `rebase`”的黄金法则，是高效利用 Git 进行版本控制的关键。在实际项目中，往往会结合使用这两种策略：在个人功能开发阶段，可以利用 `rebase` 保持提交历史的整洁；在将功能集成到公共分支时，则倾向于使用 `merge` 来保留完整的集成记录。