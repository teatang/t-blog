---
title: 如何判断用户是否离开了当前页面
date: 2024-07-08 06:24:00
tags: 
    - 2024
    - 前端技术
    - JavaScript
categories: 
    - 前端技术
    - JavaScript
---
> 在前端开发中，有时我们需要在用户离开当前页面之前执行一些操作，例如保存用户未保存的数据、发送统计日志、弹出确认提示或清理资源。判断用户是否离开页面是一个常见的需求，但实现起来可能会有一些细微之处。本文将详细探讨几种在不同场景下判断用户离开页面的方法，并讨论它们的优缺点及适用场景。

{% note info %}
核心思想：**利用浏览器提供的事件监听器 (如 `beforeunload`, `unload`, `pagehide`, `visibilitychange`) 来监测页面生命周期状态，从而判断用户是刷新、关闭、切换标签页还是导航到其他页面。**
{% endnote %}
---

## 一、页面生命周期事件概览

在浏览器环境中，用户离开页面的行为会触发一系列的页面生命周期事件。理解这些事件是正确判断用户离开页面的基础。

| 事件名称         | 描述                                                              | 触发时机                                                         | 是否可取消          | 主要用途                                                 |
| :--------------- | :---------------------------------------------------------------- | :--------------------------------------------------------------- | :------------------ | :------------------------------------------------------- |
| `beforeunload`   | 在页面即将卸载之前触发，可以阻止页面卸载并显示确认弹窗。              | 用户尝试关闭、刷新、后退、导航到新页面等。浏览器主动调用 `window.onbeforeunload = func`。 | 是 (返回字符串或 `event.returnValue`) | 提示用户保存未保存的数据，防止意外离开。                 |
| `unload`         | 在文档或其子资源被卸载时触发，页面已不再可见。                       | 页面即将被完全卸载。                                             | 否                  | 发送最终的统计数据、清理资源 (同步操作)。                  |
| `pagehide`       | 在页面即将隐藏或被缓存时触发。对于 BFCache 友好的页面会先于 `unload` 触发。 | 页面导航、关闭，或被浏览器前进/后退缓存 (BFCache)。                  | 否                  | 发送最终数据 (推荐异步)，清理资源。                      |
| `visibilitychange` | 当页面的可见状态发生变化时触发 (例如切换到后台标签页或最小化)。       | 用户切换标签页、最小化浏览器、切换应用等。                         | 否                  | 记录用户专注时间，暂停/播放媒体，节省资源。              |
| `blur`           | 当窗口或页面失去焦点时触发。                                         | 用户切换到其他应用、其他标签页，或点击页面外部。                   | 否                  | 记录用户离开页面的瞬间（但不一定是卸载）。               |
| `focus`          | 当窗口或页面获得焦点时触发。                                         | 用户切换回当前应用、当前标签页，或点击页面内部。                   | 否                  | 与 `blur` 配合判断用户是否活跃。                         |

## 二、使用 `beforeunload` 事件 (推荐用于阻止离开)

`beforeunload` 事件在页面即将被卸载时触发。它的一个独特之处在于，你可以通过返回一个字符串或者设置 `event.returnValue` 来**阻止**页面卸载，并向用户显示一个确认弹窗，询问用户是否真的要离开。

```javascript
// JavaScript 代码
window.addEventListener('beforeunload', (event) => {
    // 假设你有未保存的数据
    const hasUnsavedChanges = true; // 替换为你的实际判断逻辑

    if (hasUnsavedChanges) {
        // 大多数现代浏览器会忽略自定义字符串，并显示默认提示。
        // 但为了兼容旧浏览器和最佳实践，仍建议返回字符串。
        const confirmationMessage = '您有未保存的更改，确定要离开吗？';
        event.returnValue = confirmationMessage; // 标准方式
        return confirmationMessage;              // 某些浏览器兼容
    }
    // 如果没有未保存的更改，不返回任何值或返回 undefined
    // 页面会正常卸载
});
```

**优点：**
*   **可阻止页面离开**：这是唯一一个可以在用户离开页面前提供确认提示并阻止操作的事件。
*   **兼容性好**：现代浏览器和旧版浏览器都支持。

**缺点：**
*   **用户体验**：弹窗可能打断用户流程，应谨慎使用。
*   **安全性**：某些浏览器为了防止恶意网站滥用此功能（例如通过循环弹窗劫持浏览器），会限制或忽略自定义的提示字符串，只显示浏览器内置的统一提示。
*   **事件触发时机晚**：在页面资源即将被清理时触发，不适合发送大量数据或执行复杂异步操作。

**适用场景：**
*   表单数据未保存。
*   在线编辑器、在线聊天等需要防止用户数据丢失的场景。

## 三、使用 `unload` 事件 (不推荐用于发送数据)

`unload` 事件在页面完全卸载时触发，此时页面内容已不可见。

```javascript
// JavaScript 代码
window.addEventListener('unload', (event) => {
    // 在这里执行清理或日志发送操作
    // 警告：这里的代码必须是同步且执行速度极快，
    // 否则浏览器可能会停止执行或发生意外行为。
    console.log('页面正在卸载，发送最终统计数据...');
    // 尽量避免异步操作，如 fetch 或 XMLHttpRequest
    // 因为它们可能在页面关闭前无法完成。

    // 示例：发送一个同步的 HTTP 请求 (不安全且不推荐)
    // var xhr = new XMLHttpRequest();
    // xhr.open('POST', '/log-exit', false); // false 表示同步请求
    // xhr.send('userId=' + currentUserId);
});
```

**优点：**
*   在页面卸载的最后阶段触发，适合进行最后的清理工作。

**缺点：**
*   **不可阻止页面离开**。
*   在 `unload` 事件中执行异步操作非常不可靠，因为浏览器可能会在异步操作完成之前就关闭页面。
*   事件执行时间非常短，长时间的同步操作可能会导致浏览器卡死或警告。
*   可能受**浏览器缓存 (BFCache)** 影响：如果浏览器将页面放入 BFCache，`unload` 事件可能不会触发。

**适用场景：**
*   在不关心数据是否发送成功，只做“尽力而为”的最后记录时（例如通过 `navigator.sendBeacon`）。
*   同步清理一些简单的内存资源。

## 四、使用 `pagehide` 和 `pageshow` 事件 (推荐用于 BFCache 友好)

`pagehide` 和 `pageshow` 事件专门用于处理浏览器缓存 (BFCache) 的场景。BFCache 是一种浏览器优化技术，可以将页面完全快照并存储在内存中，当用户通过前进/后退按钮再次访问该页面时，可以立即从缓存中恢复，大大加快页面加载速度。

*   `pagehide`：当用户导航离开页面时触发。如果页面被放入 BFCache，它会在 `unload` 之前触发。如果页面不被放入 BFCache（直接销毁），它也会触发，并且紧接着会触发 `unload`。
*   `pageshow`：当页面被加载或从 BFCache 中恢复时触发。

```javascript
window.addEventListener('pagehide', (event) => {
    // event.persisted 为 true 表示页面进入了 BFCache
    // event.persisted 为 false 表示页面即将被销毁
    if (event.persisted) {
        console.log('页面进入了 BFCache，用户可能只是暂时离开了。');
        // 暂停资源，如视频播放、WebSocket连接等，但不销毁
    } else {
        console.log('页面即将被销毁，执行最终清理和数据发送。');
        // 使用 sendBeacon 发送日志，它在页面卸载时是可靠的
        navigator.sendBeacon('/log-exit', JSON.stringify({ userId: 'user123', status: 'exit' }));
        // 或者清理一些计时器等
    }
});

window.addEventListener('pageshow', (event) => {
    if (event.persisted) {
        console.log('页面从 BFCache 恢复了！');
        // 恢复之前暂停的资源，如视频播放
    } else {
        console.log('页面首次加载。');
    }
});
```

**`navigator.sendBeacon()` 的重要性：**

`navigator.sendBeacon()` 是一个专门用于在页面卸载期间发送少量 HTTP 数据的 API。它以异步且非阻塞的方式发送数据，并且浏览器会保证数据在页面关闭之前发送成功 (即便页面已经卸载)。这比 `XMLHttpRequest` 的同步请求更安全、更可靠。

```javascript
// 推荐在 pagehide (event.persisted 为 false 时) 或 unload 中使用
window.addEventListener('pagehide', (event) => {
    if (!event.persisted) {
        const data = {
            timestamp: new Date().toISOString(),
            action: 'page_exit',
            url: window.location.href
        };
        // sendBeacon 会在后台尝试发送数据，不影响页面卸载
        navigator.sendBeacon('/api/log-exit', JSON.stringify(data));
        console.log('通过 sendBeacon 发送页面离开日志。');
    }
});
```

**优点：**
*   `pagehide` 对 BFCache 更友好，可以区分页面是进入缓存还是被销毁。
*   `navigator.sendBeacon()` 提供了一种可靠的异步数据发送机制，适用于在页面卸载时发送统计数据或状态。

**缺点：**
*   需要考虑 `event.persisted` 的判断逻辑。
*   无法阻止页面离开。

**适用场景：**
*   发送用户行为统计、日志。
*   管理页面资源（如暂停/恢复视频、WebSocket 连接）。
*   需要对 BFCache 行为进行精细控制的场景。

## 五、使用 `visibilitychange` 事件 (推荐用于页面活跃度判断)

`visibilitychange` 事件在文档可见性状态发生变化时触发。文档的可见状态可以是 `visible` (页面在前景标签页中)、`hidden` (页面在后台标签页、被最小化或系统锁屏)，或者 `prerender` (页面在后台预渲染，用户尚未看到)。

```javascript
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // 页面变为不可见（例如切换到其他标签页或最小化）
        console.log('页面变为不可见。');
        // 暂停视频、停止动画、保存草稿（非关键数据）
    } else {
        // 页面变为可见（例如切换回当前标签页）
        console.log('页面变为可见。');
        // 恢复视频、重新加载数据、显示通知
    }
    // 获取当前可见状态
    console.log('当前可见状态:', document.visibilityState);
});
```

**优点：**
*   **不涉及页面卸载**：当用户只是切换标签页、最小化应用程序时，`visibilitychange` 会触发，而 `beforeunload`/`unload`/`pagehide` 不会。
*   **高频率触发**：响应用户对页面的注意力变化非常及时。

**缺点：**
*   无法判断页面是否真的被关闭或导航。
*   无法阻止页面离开。

**适用场景：**
*   跟踪用户在页面上的专注时间。
*   根据页面的可见状态暂停或恢复媒体播放。
*   在页面切换到后台时保存草稿。
*   在页面切换到后台时停止一些不必要的后台轮询。

## 六、一些额外的技巧和注意事项

### 6.1 结合 `blur` 和 `focus` 事件

`blur` 和 `focus` 事件分别在窗口或页面失去焦点和获得焦点时触发。它们提供了一种更细粒度的方式来跟踪用户是否离开了当前浏览器窗口，但不一定是卸载了页面。

```javascript
window.addEventListener('blur', () => {
    console.log('窗口失去焦点。');
    // 用户可能切换到另一个应用或另一个浏览器窗口
});

window.addEventListener('focus', () => {
    console.log('窗口获得焦点。');
    // 用户可能切换回当前浏览器窗口，但不一定是当前标签页
});
```
结合 `visibilitychange` 可以更精确地判断用户是否离开了当前页面的**标签页**。

### 6.2 移动端浏览器兼容性

在移动端浏览器（尤其是 iOS Safari）上，页面可能会被暂停 (Frozen) 而不是卸载。BFCache 机制尤为常见。因此，`pagehide` 事件在移动端更为重要。

### 6.3 异步操作的挑战

在页面即将卸载的事件 (如 `beforeunload`, `unload`, `pagehide`) 中，执行异步操作（如 `fetch`, `XMLHttpRequest`）是非常危险的，因为浏览器可能在异步操作完成前就强制关闭页面。
*   **推荐方案**：使用 `navigator.sendBeacon()` 发送少量统计数据。
*   **次优方案**：如果必须发送 POST 请求，可以尝试使用同步的 `XMLHttpRequest`（设置为 `false`），但这会阻塞页面卸载，可能导致页面卡顿或用户体验差，并且在现代浏览器中可能已经受限或不被推荐，甚至在某些情况下会抛出警告。

```python
# Python Flask 后端示例
from flask import Flask, request

app = Flask(__name__)

@app.route('/api/log-exit', methods=['POST'])
def log_exit():
    data = request.json # sendBeacon 默认 Content-Type: application/x-www-form-urlencoded
                        # 如果需要解析 JSON，前端 sendBeacon 参数可以是 Blob(JSON.stringify(data), { type: 'application/json' })
    if data:
        print(f"Received exit log from user: {data.get('user_id')} at {data.get('timestamp')}")
        # 这里可以将日志写入文件或数据库
        return {'status': 'success'}, 200
    return {'status': 'error'}, 400

if __name__ == '__main__':
    app.run(debug=True)
```

### 6.4 示例代码 (TypeScript)

```typescript
type PageExitReason = 'close_tab' | 'refresh' | 'navigate' | 'bfcache' | 'unknown';

interface ExitLogData {
    timestamp: string;
    reason: PageExitReason;
    userId: string;
    url: string;
    unsavedChanges: boolean;
}

class PageTracker {
    private hasUnsavedChanges: boolean = false;
    private userId: string = 'guest'; // Example user ID

    constructor() {
        this.initEventListeners();
        this.userId = this.getUserIdFromSession(); // Replace with actual user ID retrieval
    }

    private getUserIdFromSession(): string {
        // In a real application, retrieve user ID from session, cookie, or JWT
        return Math.random().toString(36).substring(7); // Random ID for demo
    }

    public setUnsavedChanges(status: boolean): void {
        this.hasUnsavedChanges = status;
    }

    private initEventListeners(): void {
        window.addEventListener('beforeunload', this.handleBeforeUnload);
        window.addEventListener('pagehide', this.handlePageHide);
        document.addEventListener('visibilitychange', this.handleVisibilityChange);
        window.addEventListener('unload', this.handleUnload); // For older browsers or specific needs, but less reliable.
    }

    private handleBeforeUnload = (event: BeforeUnloadEvent): string | undefined => {
        if (this.hasUnsavedChanges) {
            const confirmationMessage = '您有未保存的更改，确定要离开吗？';
            event.returnValue = confirmationMessage;
            return confirmationMessage;
        }
        return undefined;
    };

    private handlePageHide = (event: PageTransitionEvent): void => {
        let reason: PageExitReason;
        if (event.persisted) {
            reason = 'bfcache';
            console.log('Page entered BFCache. Pause operations.');
            // Pause any real-time operations, save temporary state
        } else {
            // Page is definitely being unloaded (closing, navigating away, refresh)
            console.log('Page is being unloaded. Send final logs.');
            // Attempt to send exit log using sendBeacon
            reason = this.detectExitReason(); 
            this.sendExitLog(reason);
            // Clean up timers, event listeners that are no longer needed
            this.cleanupResources();
        }
    };

    private handleUnload = (event: Event): void => {
        console.log('Unload event triggered. (Fallback or legacy logging)');
        // This is primarily for browsers that don't support pagehide well or if sendBeacon fails.
        // Try to send a log, but it's highly unreliable for async operations.
        // this.sendExitLog(this.detectExitReason());
    };

    private handleVisibilityChange = (): void => {
        if (document.hidden) {
            console.log('Page became hidden. User left tab/minimized browser.');
            // Potentially save draft, pause video, stop API polling
        } else {
            console.log('Page became visible. User returned to tab.');
            // Resume operations, check for updates
        }
    };

    // This is a heuristic and might not be perfectly accurate as there's no direct API for this distinction.
    private detectExitReason(): PageExitReason {
        // Can be refined with more advanced heuristics or server-side checks.
        // For simplicity, we assume if beforeunload was triggered with unsaved changes, it's a "normal" close/nav.
        // Otherwise, it's a refresh or direct navigation.
        return this.hasUnsavedChanges ? 'navigate' : 'refresh'; 
    }

    private sendExitLog(reason: PageExitReason): void {
        const logData: ExitLogData = {
            timestamp: new Date().toISOString(),
            reason: reason,
            userId: this.userId,
            url: window.location.href,
            unsavedChanges: this.hasUnsavedChanges
        };

        const success = navigator.sendBeacon('/api/log-exit', JSON.stringify(logData));
        if (success) {
            console.log('Exit log sent successfully via sendBeacon.');
        } else {
            console.warn('Failed to queue exit log via sendBeacon. Browser might not support it.');
            // Fallback for older browsers: may use sync XHR, but it's not recommended.
            // this.sendSyncXHR('/api/log-exit', JSON.stringify(logData));
        }
    }

    // Example cleanup
    private cleanupResources(): void {
        // Clear any timeouts/intervals
        // Disconnect WebSockets
        console.log('Resources cleaned up.');
    }
}

// Usage example
const pageTracker = new PageTracker();

// Simulate user making changes
setTimeout(() => {
    pageTracker.setUnsavedChanges(true);
    console.log('Simulating unsaved changes.');
}, 5000);

// Simulate saving changes
setTimeout(() => {
    pageTracker.setUnsavedChanges(false);
    console.log('Simulating changes saved.');
}, 10000);
```

## 七、总结

判断用户是否离开了当前页面涉及到对浏览器页面生命周期事件的深入理解。
*   如果需要**阻止用户离开**并弹出确认提示，使用 `beforeunload`。
*   如果需要**在页面卸载时发送数据**或执行清理，优先考虑 `pagehide` (结合 `event.persisted`) 和 `navigator.sendBeacon()`。避免在 `unload` 中执行复杂的异步操作。
*   如果需要**跟踪用户在页面的活跃度**或在页面切换到后台时调整行为，使用 `visibilitychange`。

在实际开发中，通常会结合这些事件来构建一个健壮的页面离开检测机制，以确保用户体验、数据完整性和资源管理。同时，要时刻关注浏览器的兼容性和具体实现细节，因为它们可能会随时间而变化。