---
title: Node.js Buffer 类详解
date: 2024-03-05 06:24:00
tags:
  - 2024
  - 前端技术
  - Node.js
  - JavaScript
categories:
  - 前端技术
  - Node.js
---
> **Node.js Buffer** 类是用于处理**二进制数据流**的全局对象。在 Node.js 中，Buffer 实例是原始二进制数据的容器，类似于整数数组，但它对应着 V8 引擎堆外（off-heap）的内存区域。这意味着 Buffer 的内存分配独立于 V8 的垃圾回收机制，使其在处理大量或频繁的二进制数据时，具有更高的效率和性能。

{% note info %}
核心思想：**弥补 JavaScript 原生对二进制数据处理能力的不足，提供高效、直接操作原始字节的能力。** 在文件I/O、网络通信、数据压缩/加密等场景中不可或缺。
{% endnote %}
------

## 一、为什么需要 Buffer？

JavaScript 语言最初设计用于处理字符串和数字，对二进制数据流的处理能力有限。然而，在服务器端开发中，经常需要与底层系统进行交互，例如：

*   **文件 I/O**：读取或写入文件时，数据通常以二进制形式存在。
*   **网络通信**：TCP 流、HTTP 请求/响应体等都涉及原始字节流。
*   **数据编解码**：处理图像、音频、视频、加密数据等，都需要直接操作字节。
*   **数据库交互**：某些数据库驱动在传输数据时会使用二进制格式。

Node.js 的 `Buffer` 类正是为了弥补这一不足，它提供了一种方式来存储和操作固定大小的原始字节序列。

## 二、Buffer 的核心特性

1.  **二进制数据容器**：Buffer 实例存储的是一系列原始字节（0到255之间的整数）。
2.  **固定大小**：一旦 Buffer 实例被创建，其大小就不能再调整。
3.  **V8 堆外内存**：Buffer 的内存分配在 V8 引擎的堆外，这意味着它不会直接受到 JavaScript 垃圾回收器的管理，从而减少了垃圾回收的频率和开销，提高了性能。
4.  **类似数组**：Buffer 实例可以通过索引（`buf[0]`）来访问和修改单个字节，其行为与整数数组非常相似。

## 三、Buffer 的创建

创建 Buffer 实例有多种方法，根据不同的使用场景选择。

### 3.1 `Buffer.from()`：从现有数据创建

这是最常用的创建 Buffer 的方法，它可以从字符串、数组、`ArrayBuffer` 或另一个 `Buffer` 创建。

#### 3.1.1 从字符串创建

可以指定字符编码（默认 `utf8`）。

```javascript
// 示例：从字符串创建 Buffer
const buf1 = Buffer.from('Hello Node.js!');
console.log('buf1:', buf1); // <Buffer 48 65 6c 6c 6f 20 4e 6f 64 65 2e 6a 73 21>
console.log('buf1.toString():', buf1.toString()); // Hello Node.js!

const buf2 = Buffer.from('你好世界', 'utf8');
console.log('buf2:', buf2); // <Buffer e4 bd a0 e5 a5 bd e4 b896 e7 95 8c>
console.log('buf2.toString():', buf2.toString()); // 你好世界

const buf3 = Buffer.from('你好世界', 'base64'); // base64编码的字符串
console.log('buf3:', buf3); // <Buffer 89 cb b6 cf c8 cb bc c8 e1 ec 89>
console.log('buf3.toString():', buf3.toString('base64')); // 5L2g5aW95L2g5aW9
```

#### 3.1.2 从数组创建

可以从一个包含字节值（0-255）的数组创建。

```javascript
// 示例：从字节数组创建 Buffer
const buf4 = Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]); // [104, 101, 108, 108, 111]
console.log('buf4:', buf4); // <Buffer 68 65 6c 6c 6f>
console.log('buf4.toString():', buf4.toString()); // hello
```

#### 3.1.3 从 ArrayBuffer 或 TypedArray 创建

```javascript
// 示例：从 ArrayBuffer 创建 Buffer
const ab = new ArrayBuffer(10);
const dv = new DataView(ab);
dv.setUint8(0, 0xFF);
dv.setUint8(1, 0xAA);

const buf5 = Buffer.from(ab);
console.log('buf5:', buf5); // <Buffer ff aa 00 00 00 00 00 00 00 00>

// 从 Uint8Array 创建 Buffer (底层共享同一 ArrayBuffer 内存)
const uint8 = new Uint8Array([1, 2, 3]);
const buf6 = Buffer.from(uint8);
console.log('buf6:', buf6); // <Buffer 01 02 03>
// 注意：如果修改了uint8，buf6也会跟着变，因为它们共享底层ArrayBuffer
uint8[0] = 99;
console.log('buf6 after uint8 change:', buf6); // <Buffer 63 02 03>
```

#### 3.1.4 从另一个 Buffer 创建

```javascript
// 示例：从另一个 Buffer 创建 (默认是复制数据)
const buf7 = Buffer.from(buf1); // 复制 buf1 的内容
console.log('buf7:', buf7); // <Buffer 48 65 6c 6c 6f 20 4e 6f 64 65 2e 6a 73 21>
// 如果修改 buf1，buf7 不会变
buf1[0] = 0x41; // 'A'
console.log('buf1 after change:', buf1.toString()); // Aello Node.js!
console.log('buf7 after buf1 change:', buf7.toString()); // Hello Node.js!
```

### 3.2 `Buffer.alloc(size[, fill[, encoding]])`：分配指定大小的 Buffer

分配一个指定大小的 Buffer，并用 `fill` 值（默认是 `0`）填充。这是一种安全可靠的创建方式，因为内存总是被初始化。

```javascript
// 示例：分配 10 字节的 Buffer，并用 0 填充
const buf8 = Buffer.alloc(10);
console.log('buf8:', buf8); // <Buffer 00 00 00 00 00 00 00 00 00 00>

// 示例：分配 10 字节的 Buffer，并用 1 填充
const buf9 = Buffer.alloc(10, 1);
console.log('buf9:', buf9); // <Buffer 01 01 01 01 01 01 01 01 01 01>

// 示例：分配 10 字节的 Buffer，并用指定字符串填充
const buf10 = Buffer.alloc(10, 'a');
console.log('buf10:', buf10); // <Buffer 61 61 61 61 61 61 61 61 61 61> (ascii 'a' 是 0x61)
```

### 3.3 `Buffer.allocUnsafe(size)`：分配未初始化内存的 Buffer

分配一个指定大小的 Buffer，但**不会进行初始化**。这意味着新创建的 Buffer 可能包含旧的、敏感的内存数据。
尽管它速度更快，但在没有填充或覆盖的情况下，可能导致数据泄露。因此，**除非非常确定会立即覆盖所有内存，否则应避免使用此方法。**

```javascript
// 示例：分配 10 字节的未初始化 Buffer
const buf11 = Buffer.allocUnsafe(10);
console.log('buf11:', buf11); // 可能包含随机的旧数据，例如 <Buffer d0 59 05 00 00 00 00 00 20 00>
// 在使用前务必将其填充
buf11.fill(0);
console.log('buf11 filled:', buf11); // <Buffer 00 00 00 00 00 00 00 00 00 00>
```

### 3.4 `Buffer.byteLength(string[, encoding])`：获取字符串的字节长度

此方法计算一个字符串在指定编码下的字节长度，而不是字符长度。

```javascript
// 示例：获取字符串的字节长度
const str1 = 'Hello';
const str2 = '你好';

console.log('byteLength of "Hello" (utf8):', Buffer.byteLength(str1, 'utf8')); // 5
console.log('byteLength of "你好" (utf8):', Buffer.byteLength(str2, 'utf8')); // 6 (每个汉字3字节)
console.log('byteLength of "你好" (ascii):', Buffer.byteLength(str2, 'ascii')); // 2 (ascii无法表示汉字，通常会截断或替换)
```

## 四、Buffer 的读写操作

### 4.1 通过索引访问字节

Buffer 实例的行为类似于 JavaScript 数组，可以通过 `buf[index]` 直接访问或修改单个字节。字节值范围是 0-255。

```javascript
const buf = Buffer.from('hello');

console.log('buf[0]:', buf[0]); // 104 (ASCII 'h')
buf[0] = 0x41; // 修改第一个字节为 0x41 (ASCII 'A')
console.log('buf.toString():', buf.toString()); // Aello
console.log('buf[0] after change:', buf[0]); // 65 (ASCII 'A')
```

### 4.2 读写不同数据类型

Buffer 提供了多种方法来读写不同大小和字节序（Endianness）的整数、浮点数。
**字节序**：
*   **大端序 (Big-Endian, BE)**：最高有效字节存储在最低内存地址。例如，`0x12345678` 存储为 `12 34 56 78`。
*   **小端序 (Little-Endian, LE)**：最低有效字节存储在最低内存地址。例如，`0x12345678` 存储为 `78 56 34 12`。

#### 4.2.1 整数读写

*   `buf.readUInt8(offset)` / `buf.writeUInt8(value, offset)`
*   `buf.readInt8(offset)` / `buf.writeInt8(value, offset)`
*   `buf.readUInt16LE(offset)` / `buf.writeUInt16LE(value, offset)` (16位无符号小端序)
*   `buf.readUInt16BE(offset)` / `buf.writeUInt16BE(value, offset)` (16位无符号大端序)
*   类似地，还有 `UInt32`, `Int16`, `Int32`, `IntBE`, `IntLE` 等方法。

```javascript
const buffer = Buffer.alloc(4); // 分配 4 字节

// 写入一个 16 位无符号整数 (小端序)
buffer.writeUInt16LE(0xABCD, 0); // 0xCD 0xAB 0x00 0x00
console.log('buffer after writeUInt16LE:', buffer); // <Buffer cd ab 00 00>
console.log('readUInt16LE at 0:', buffer.readUInt16LE(0)); // 43981 (0xABCD)

// 写入一个 16 位无符号整数 (大端序)
buffer.writeUInt16BE(0xABCD, 2); // 0xCD 0xAB 0xAB 0xCD
console.log('buffer after writeUInt16BE:', buffer); // <Buffer cd ab ab cd>
console.log('readUInt16BE at 2:', buffer.readUInt16BE(2)); // 43981 (0xABCD)

// 写入一个 8 位带符号整数
buffer.writeInt8(-128, 0); // 0x80
console.log('buffer after writeInt8:', buffer); // <Buffer 80 ab ab cd>
console.log('readInt8 at 0:', buffer.readInt8(0)); // -128
```

#### 4.2.2 浮点数读写

*   `buf.readFloatLE(offset)` / `buf.writeFloatLE(value, offset)`
*   `buf.readFloatBE(offset)` / `buf.writeFloatBE(value, offset)`
*   `buf.readDoubleLE(offset)` / `buf.writeDoubleLE(value, offset)`
*   `buf.readDoubleBE(offset)` / `buf.writeDoubleBE(value, offset)`

```javascript
const floatBuffer = Buffer.alloc(4);
floatBuffer.writeFloatBE(3.14159, 0);
console.log('floatBuffer:', floatBuffer); // <Buffer 40 49 0f da>
console.log('readFloatBE:', floatBuffer.readFloatBE(0)); // 3.141590118408203
```

### 4.3 `buf.toString([encoding[, start[, end]]])`：将 Buffer 转换为字符串

将 Buffer 中的字节解码为字符串。可以指定编码、起始位置和结束位置。

```javascript
const buf = Buffer.from([0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0xe4, 0xbd, 0xa0, 0xe5, 0xa5, 0xbd]);

console.log(buf.toString('ascii')); // Hello ??
console.log(buf.toString('utf8'));  // Hello 你好
console.log(buf.toString('utf8', 0, 5)); // Hello
console.log(buf.toString('utf8', 6)); // 你好
```

### 4.4 `buf.toJSON()`：转换为 JSON 对象

返回一个 JSON 对象，其中包含 `type: 'Buffer'` 和 `data` 数组（字节的十进制表示）。这在序列化 Buffer 时很有用。

```javascript
const buf = Buffer.from('test');
console.log(buf.toJSON()); // { type: 'Buffer', data: [ 116, 101, 115, 116 ] }
```

## 五、Buffer 的操作方法

### 5.1 `Buffer.concat(list[, totalLength])`：连接多个 Buffer

将一个 Buffer 数组连接成一个新的 Buffer。

```javascript
const buf1 = Buffer.from('hello');
const buf2 = Buffer.from(' ');
const buf3 = Buffer.from('world');

const combined = Buffer.concat([buf1, buf2, buf3]);
console.log('combined:', combined.toString()); // hello world

// 指定总长度可以提高效率，避免内部重复计算
const combinedWithSize = Buffer.concat([buf1, buf2, buf3], buf1.length + buf2.length + buf3.length);
console.log('combinedWithSize:', combinedWithSize.toString()); // hello world
```

### 5.2 `buf.slice([start[, end]])`：截取 Buffer

创建一个新的 Buffer，它引用原始 Buffer 的同一块内存区域。**这意味着修改 slice 会影响原始 Buffer，反之亦然。**

```javascript
const buf = Buffer.from('abcdefg');
const slice1 = buf.slice(0, 3); // 'abc'
const slice2 = buf.slice(3);    // 'defg'

console.log('buf:', buf.toString());       // abcdefg
console.log('slice1:', slice1.toString()); // abc
console.log('slice2:', slice2.toString()); // defg

// 修改 slice1 会影响原始 buf
slice1[0] = 0x41; // 'A'
console.log('buf after slice1 change:', buf.toString());       // Abcdefg
console.log('slice1 after slice1 change:', slice1.toString()); // Abc

// 要创建独立副本，应使用 `Buffer.from(buf.slice())` 或 `buf.copy()`
const independentCopy = Buffer.from(buf.slice(0, 3));
independentCopy[0] = 0x5a; // 'Z'
console.log('buf after independentCopy change:', buf.toString()); // Abcdefg
console.log('independentCopy:', independentCopy.toString());      // Zbc
```

### 5.3 `buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])`：复制数据

将 `buf` 的数据复制到 `target` Buffer。

```javascript
const sourceBuf = Buffer.from('hello');
const targetBuf = Buffer.alloc(10); // 目标 Buffer 至少需要足够大

sourceBuf.copy(targetBuf, 0); // 从 sourceBuf 复制到 targetBuf 的开头
console.log('targetBuf after copy:', targetBuf.toString()); // hello\u0000\u0000\u0000\u0000\u0000

const anotherSource = Buffer.from('world');
anotherSource.copy(targetBuf, 5, 0, 5); // 从 anotherSource 复制到 targetBuf 的索引 5 开始的位置
console.log('targetBuf after second copy:', targetBuf.toString()); // helloworld
```

### 5.4 `buf.fill(value[, offset[, end]][, encoding])`：填充 Buffer

用指定的 `value` 填充 Buffer。

```javascript
const buf = Buffer.alloc(5);
buf.fill(0xFF);
console.log('buf filled with FF:', buf); // <Buffer ff ff ff ff ff>

buf.fill('a', 1, 4); // 从索引 1 到索引 4 (不包含) 填充 'a'
console.log('buf partially filled with a:', buf); // <Buffer ff 61 61 61 ff> (ascii 'a' 是 0x61)
console.log('buf partially filled with a toString:', buf.toString()); // ÿaaaÿ
```

### 5.5 `Buffer.compare(buf1, buf2)`：比较两个 Buffer

按字节比较两个 Buffer，返回 `0` (相等)、`1` (buf1 > buf2) 或 `-1` (buf1 < buf2)。

```javascript
const bufA = Buffer.from('abc');
const bufB = Buffer.from('abd');
const bufC = Buffer.from('abc');

console.log('compare bufA and bufB:', Buffer.compare(bufA, bufB)); // -1
console.log('compare bufB and bufA:', Buffer.compare(bufB, bufA)); // 1
console.log('compare bufA and bufC:', Buffer.compare(bufA, bufC)); // 0
```

### 5.6 `buf.equals(otherBuffer)`：检查 Buffer 是否相等

检查两个 Buffer 是否包含相同的字节序列。

```javascript
const bufA = Buffer.from('abc');
const bufC = Buffer.from('abc');
const bufD = Buffer.from('abcd');

console.log('bufA equals bufC:', bufA.equals(bufC)); // true
console.log('bufA equals bufD:', bufA.equals(bufD)); // false
```

### 5.7 `buf.indexOf(value[, byteOffset][, encoding])`：查找子 Buffer 或字节

查找指定的 `value` (可以是字节、字符串或另一个 Buffer) 在当前 Buffer 中的第一次出现的位置。

```javascript
const buf = Buffer.from('this is a test');
console.log('indexOf "is":', buf.indexOf('is'));    // 2
console.log('indexOf "is" from offset 3:', buf.indexOf('is', 3)); // 5
console.log('indexOf "notfound":', buf.indexOf('notfound')); // -1
console.log('indexOf 0x20 (space):', buf.indexOf(0x20)); // 4
```

## 六、Buffer 与其他类型互操作

Buffer 在 Node.js 生态系统中扮演着核心角色，与许多其他类型和模块协同工作。

### 6.1 与字符串

如前所述，`Buffer.from(string, encoding)` 和 `buf.toString(encoding)` 是字符串与 Buffer 之间转换的主要方式。
**重要提示：** 确保在转换时使用相同的编码，以避免乱码问题。

### 6.2 与 `ArrayBuffer` / `TypedArray`

Buffer 是 `Uint8Array` 的子类，因此它与 Web 标准的 `ArrayBuffer` 和 `TypedArray` 兼容。

*   **`buf.buffer`** 属性可以获取 Buffer 内部引用的底层 `ArrayBuffer`。
*   `Buffer.from(arrayBuffer[, byteOffset[, length]])` 可以从一个 `ArrayBuffer` 创建一个 Buffer。

```javascript
const ab = new ArrayBuffer(8);
const view = new Uint8Array(ab);
view[0] = 0x01;
view[1] = 0x02;

// 从 ArrayBuffer 创建 Buffer，与 ArrayBuffer 共享内存
const buf = Buffer.from(ab);
console.log('buf from ArrayBuffer:', buf); // <Buffer 01 02 00 00 00 00 00 00>

// 修改 Buffer 会影响底层的 ArrayBuffer
buf[2] = 0x03;
console.log('view after buf change:', view); // Uint8Array [ 1, 2, 3, 0, 0, 0, 0, 0 ]

// 从 Buffer 获取 ArrayBuffer
const bufWithData = Buffer.from([10, 20, 30]);
const underlyingAb = bufWithData.buffer;
console.log('underlying ArrayBuffer:', underlyingAb); // ArrayBuffer { byteLength: 3 }
```

### 6.3 与 Node.js Stream

在 Node.js 中，所有的 I/O 操作（如文件读写、网络请求）都基于 Stream。Stream 处理的数据块通常是 Buffer 实例。

*   `fs.createReadStream()` 读取文件时，会发出 `data` 事件，其回调参数就是 Buffer。
*   `response.write()` 或 `socket.write()` 写入数据时，可以传入 Buffer。

```javascript
// 示例 (概念性，需实际文件)
const fs = require('fs');

// 读取文件，数据以 Buffer 形式传入
const readStream = fs.createReadStream('example.txt');
readStream.on('data', (chunk) => {
    console.log('Received chunk (Buffer):', chunk);
    console.log('Chunk as string:', chunk.toString('utf8'));
});
readStream.on('end', () => {
    console.log('Finished reading file.');
});

// 写入文件，可以写入 Buffer
const writeStream = fs.createWriteStream('output.txt');
const dataToWrite = Buffer.from('Hello from Buffer!');
writeStream.write(dataToWrite);
writeStream.end();
```

## 七、安全性考虑

1.  **`Buffer.allocUnsafe()` 的风险**：如前所述，使用 `Buffer.allocUnsafe()` 分配的内存可能包含敏感的旧数据。如果这些数据未被立即覆盖就暴露给外部，可能导致信息泄露。**务必谨慎使用，并确保在暴露前完全初始化。**
2.  **缓冲区溢出**：在进行 Buffer 读写操作时（例如 `buf.write()` 或 `buf.copy()`），需要确保目标 Buffer 有足够的空间，且读写操作不会超出 Buffer 的边界，否则可能导致应用程序崩溃或不可预测的行为。
3.  **编码问题**：在 Buffer 与字符串之间转换时，始终明确指定编码，并确保源数据和目标编码匹配，以避免乱码或数据损坏。
4.  **防止外部访问敏感数据**：如果 Buffer 包含敏感信息，确保这些 Buffer 不会被意外地 `toString()` 或以其他方式暴露给不可信的外部。

## 八、性能优势与使用场景

### 8.1 性能优势

*   **直接内存操作**：Buffer 允许 JavaScript 直接操作原始字节，避免了在字符串和二进制数据之间来回转换的开销。
*   **V8 堆外内存**：由于 Buffer 数据存储在 V8 堆外，它不受垃圾回收器的直接管理，减少了 GC 暂停时间，尤其在处理大型二进制数据时性能优势显著。
*   **固定大小**：固定大小的特性使得内存管理更加高效。

### 8.2 典型使用场景

*   **文件系统操作**：读取文件内容 (`fs.readFile`)，文件写入 (`fs.writeFile`)。
    ```javascript
    const fs = require('fs');
    fs.readFile('image.png', (err, data) => {
        if (err) throw err;
        console.log('Image data as Buffer:', data);
        // data 是一个 Buffer 实例，可以进一步处理或传输
    });
    ```
*   **网络通信**：处理 TCP/UDP 数据包，HTTP 请求体和响应体。例如，解析自定义二进制协议或上传/下载文件。
    ```javascript
    // 在 HTTP 请求中处理文件上传 (multipart/form-data)
    // const http = require('http');
    // http.createServer((req, res) => {
    //     if (req.method === 'POST' && req.url === '/upload') {
    //         const chunks = [];
    //         req.on('data', (chunk) => {
    //             chunks.push(chunk); // chunk 是 Buffer 实例
    //         });
    //         req.on('end', () => {
    //             const fullBuffer = Buffer.concat(chunks);
    //             // 解析 fullBuffer 来提取上传的文件
    //             res.end('File uploaded (processed as Buffer)');
    //         });
    //     }
    // }).listen(3000);
    ```
*   **数据编解码**：图像处理库（如 `sharp`）、音频处理、视频流处理、压缩/解压缩数据。
*   **加密和解密**：使用 `crypto` 模块进行哈希、对称或非对称加密时，输入和输出通常是 Buffer。
    ```javascript
    const crypto = require('crypto');
    const secret = 'my_secret_key';
    const text = 'Hello Node.js!';
    const hmac = crypto.createHmac('sha256', secret);

    hmac.update(text); // 可以传入字符串或 Buffer
    const digest = hmac.digest('hex'); // 输出十六进制字符串，或传入 'buffer' 输出 Buffer
    console.log('HMAC digest:', digest);
    ```
*   **数据库驱动**：处理数据库返回的二进制数据类型（如 BLOB）。

## 九、总结

`Node.js Buffer` 类是 Node.js 处理二进制数据的基石。它提供了一种高效、灵活的方式来操作原始字节，弥补了 JavaScript 语言在此方面的不足。无论是文件 I/O、网络通信、数据加解密还是与其他系统进行二进制数据交互，`Buffer` 都扮演着至关重要的角色。理解 `Buffer` 的工作原理、创建方式、读写方法以及其与其他数据类型的互操作性，对于 Node.js 开发者来说至关重要，能帮助构建更高效、更稳定的应用程序。在使用 `Buffer.allocUnsafe()` 时，务必注意安全性，避免潜在的数据泄露风险。