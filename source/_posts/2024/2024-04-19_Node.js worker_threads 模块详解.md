---
title: Node.js worker_threads 模块详解
date: 2024-04-19 06:24:00
tags:
  - 2024
  - 前端技术
  - Node.js
  - JavaScript
  - 并发编程
categories:
  - 前端技术
  - Node.js
---
> **Node.js 的 `worker_threads` 模块** 允许开发者在 Node.js 应用程序中创建真正的多线程。传统上，Node.js 是单线程的，其事件循环处理 I/O 密集型任务非常高效，但在面对 CPU 密集型任务时，单线程模型会导致事件循环阻塞，从而影响应用程序的响应性。`worker_threads` 模块正是为了解决这一痛点而引入的，它使得 Node.js 能够更好地利用多核 CPU 资源，执行并行计算，而不会阻塞主事件循环。

{% note info %}
核心思想：**将 CPU 密集型任务从主线程卸载到独立的 Worker 线程中执行，从而防止主事件循环被阻塞，保持应用程序的响应性和吞吐量。** 每个 Worker 线程拥有独立的 V8 实例、事件循环和内存空间，通过消息传递进行通信。
{% endnote %}
------

## 一、为什么需要 `worker_threads`？

Node.js 以其非阻塞 I/O 模型而闻名，这得益于其单线程的事件循环。对于网络请求、文件读写等 I/O 密集型操作，Node.js 可以通过异步回调或 Promise 迅速处理大量并发请求。然而，这种模型在处理以下情况时会遇到瓶颈：

1.  **CPU 密集型任务**：例如复杂的数学计算、数据加密/解密、图片或视频处理、大量数据转换等。这些任务会长时间占用 CPU，并阻塞主线程的事件循环。
    *   **问题**：当主线程被 CPU 密集型任务阻塞时，所有新的传入请求（如 HTTP 请求）都将等待，导致应用程序无响应，用户体验下降。

2.  **长时间运行的任务**：任何耗时较长的同步操作都会对事件循环造成压力。

在 `worker_threads` 模块出现之前，Node.js 解决 CPU 密集型任务的常见方案是使用 `child_process` 模块创建子进程。虽然子进程也能实现并行，但它们之间通信开销较大，且每个子进程都有独立的 Node.js 运行时和内存空间，资源消耗相对较高。

`worker_threads` 模块提供了更轻量级的线程模型，它解决了 `child_process` 的一些局限性，使得 Node.js 能够：

*   **更好地利用多核 CPU**：将 CPU 密集型任务分发到多个 Worker 线程并行执行。
*   **保持主线程的响应性**：确保主事件循环不被阻塞，即使在执行耗时计算时也能继续处理 I/O 和其他请求。
*   **更高效的通信**：线程间的消息传递比进程间通信更高效。
*   **支持共享内存**：通过 `SharedArrayBuffer` 实现线程间内存共享，进一步优化性能（但需谨慎处理）。

## 二、`worker_threads` 模块的核心概念

### 2.1 主线程 (Main Thread)

启动 Node.js 应用程序的原始线程。它负责处理大部分 I/O 操作和事件循环，并可以创建和管理 Worker 线程。

### 2.2 Worker 线程 (Worker Thread)

由主线程创建的独立执行线程。每个 Worker 线程：

*   拥有自己的 V8 实例（独立的内存堆）。
*   拥有自己的事件循环。
*   运行一个独立的 JavaScript 脚本文件。
*   无法直接访问主线程的全局变量或内存，必须通过消息传递进行通信。

### 2.3 消息传递 (Message Passing)

主线程和 Worker 线程之间通信的主要方式。它们通过发送和接收消息来交换数据。

*   **`postMessage(value[, transferList])`**: 用于向另一个线程发送数据。
*   **`on('message', callback)`**: 用于监听接收到的消息。

### 2.4 共享内存 (Shared Memory)

虽然 Worker 线程默认不共享内存，但可以通过 `SharedArrayBuffer` 对象实现真正的共享内存。当一个 `SharedArrayBuffer` 实例被传递给 Worker 线程时，主线程和 Worker 线程都指向同一个底层的内存块。这需要使用 `Atomics` API 来进行同步操作，以避免竞态条件。

### 2.5 `Worker` 类

在主线程中用于创建和管理 Worker 线程的构造函数。

*   `new Worker(filename[, options])`: 创建一个新的 Worker 线程，`filename` 是 Worker 线程将执行的脚本路径。
*   `workerData`: `options` 中的一个属性，用于在 Worker 线程启动时传递初始数据。

### 2.6 `parentPort`

在 Worker 线程中，`parentPort` 是一个 `MessagePort` 实例，用于与创建它的主线程进行通信。它提供了 `postMessage()` 和 `on('message', callback)` 方法。

### 2.7 `isMainThread`

一个布尔值，用于判断当前代码是否运行在主线程中。在 Worker 线程中为 `false`，在主线程中为 `true`。

## 三、`worker_threads` 工作原理架构

`worker_threads` 模块允许 Node.js 进程内部创建多个 V8 引擎实例，每个实例都在一个独立的线程中运行。这些线程共享操作系统级别的进程资源（如文件描述符），但拥有独立的 JavaScript 运行时环境和内存空间。

{% mermaid %}
graph LR
    A[Node.js Main Process] -- Fork Worker Thread --> B{Worker Thread 1}
    A -- Fork Worker Thread --> C{Worker Thread 2}
    A -- Fork Worker Thread --> D{Worker Thread N}

    subgraph Node.js Main Thread
        A_EventLoop[Event Loop]
        A_V8[V8 Instance]
        A_Heap[Memory Heap]
        A_JS[Your Main JavaScript Code]
        A_NodeAPI["Node.js APIs <br>(e.g., File I/O, Network)"]
        A_EventLoop -- Manages I/O & Queues --> A_NodeAPI
        A_JS -- Creates/Manages Workers --> A
        A_JS -- Sends/Receives Messages --> A_MessagePort(MessagePort)
    end

    subgraph Worker Thread 1
        B_EventLoop[Event Loop]
        B_V8[V8 Instance]
        B_Heap[Memory Heap]
        B_JS[Your Worker <br>JavaScript Code]
        B_NodeAPI[Subset of Node.js APIs]
        B_JS -- Sends/Receives Messages --> B_MessagePort(MessagePort)
    end

    subgraph Worker Thread 2
        C_EventLoop[Event Loop]
        C_V8[V8 Instance]
        C_Heap[Memory Heap]
        C_JS[Your Worker <br>JavaScript Code]
        C_NodeAPI[Subset of Node.js APIs]
        C_JS -- Sends/Receives Messages --> C_MessagePort(MessagePort)
    end

    A_MessagePort -- Message Passing --> B_MessagePort
    B_MessagePort -- Message Passing --> A_MessagePort
    A_MessagePort -- Message Passing --> C_MessagePort
    C_MessagePort -- Message Passing --> A_MessagePort
{% endmermaid %}

## 四、基本使用示例

我们以一个计算一个大数是否为素数的 CPU 密集型任务为例。

### 4.1 Worker 线程脚本 (`worker.js`)

```javascript
// worker.js
const { parentPort, workerData } = require('worker_threads');

/**
 * 检查一个数字是否为素数
 * 这是一个 CPU 密集型任务
 * @param {number} num
 * @returns {boolean}
 */
function isPrime(num) {
  if (num <= 1) return false;
  if (num <= 3) return true;
  if (num % 2 === 0 || num % 3 === 0) return false;
  for (let i = 5; i * i <= num; i = i + 6) {
    if (num % i === 0 || num % (i + 2) === 0) return false;
  }
  return true;
}

// 接收主线程发送的初始数据 (workerData)
const numberToCheck = workerData.number;
const startTime = Date.now();

// 执行 CPU 密集型任务
const result = isPrime(numberToCheck);
const endTime = Date.now();

// 将结果和耗时发送回主线程
parentPort.postMessage({
  number: numberToCheck,
  isPrime: result,
  timeTaken: `${endTime - startTime}ms`
});

// 监听主线程可能发来的额外消息
parentPort.on('message', (message) => {
  if (message.type === 'check_another') {
    const anotherNumber = message.number;
    const anotherStartTime = Date.now();
    const anotherResult = isPrime(anotherNumber);
    const anotherEndTime = Date.now();
    parentPort.postMessage({
      type: 'another_check_result',
      number: anotherNumber,
      isPrime: anotherResult,
      timeTaken: `${anotherEndTime - anotherStartTime}ms`
    });
  }
});

```

### 4.2 主线程脚本 (`main.js`)

```javascript
// main.js
const { Worker, isMainThread, parentPort } = require('worker_threads');

if (isMainThread) {
  console.log('--- Running in Main Thread ---');

  const numbersToProcess = [
    123456789123456789n, // 一个很大的合数
    982451653,           // 一个很大的素数
    982451654,           // 一个很大的合数
    17,                  // 小素数
    123456789123456787n  // 另一个大素数 (注意这里使用了 BigInt)
  ];

  const workers = [];

  // 创建并启动多个 Worker 线程
  numbersToProcess.forEach((num, index) => {
    // 创建一个 Worker 实例，并传递初始数据
    const worker = new Worker('./worker.js', {
      workerData: { number: num }
    });
    workers.push(worker);

    // 监听 Worker 线程发送的消息
    worker.on('message', (message) => {
      if (message.type === 'another_check_result') {
        console.log(`Worker ${index + 1} (another check): Number ${message.number} is prime: ${message.isPrime}, took ${message.timeTaken}`);
      } else {
        console.log(`Worker ${index + 1}: Number ${message.number} is prime: ${message.isPrime}, took ${message.timeTaken}`);
      }

      // 如果所有工作都完成了，可以终止 Worker
      // worker.terminate(); // 根据需求决定是否立即终止
    });

    // 监听 Worker 线程的错误
    worker.on('error', (err) => {
      console.error(`Worker ${index + 1} encountered an error:`, err);
    });

    // 监听 Worker 线程退出
    worker.on('exit', (code) => {
      if (code !== 0) {
        console.error(`Worker ${index + 1} stopped with exit code ${code}`);
      } else {
        console.log(`Worker ${index + 1} exited normally.`);
      }
      // 从列表中移除已退出的 worker
      const idx = workers.indexOf(worker);
      if (idx > -1) {
        workers.splice(idx, 1);
      }
      if (workers.length === 0) {
        console.log('All workers have finished and exited.');
      }
    });
  });

  // 在所有 Worker 都开始工作后，主线程可以继续执行其他任务
  console.log('Main thread continues to run...');

  // 示例：主线程稍后向某个 Worker 发送新的任务
  setTimeout(() => {
    if (workers[0]) {
      console.log('Main thread sending new task to Worker 1...');
      workers[0].postMessage({ type: 'check_another', number: 1234567891 });
    }
  }, 2000);

} else {
  // 这段代码不会在 worker.js 中执行，因为 worker.js 被直接作为脚本传递给 Worker 构造函数
  // 但如果 worker.js 内部也检查 isMainThread，它会发现自己不是主线程
  console.log('--- Running in Worker Thread (This message should not appear if worker.js is directly used) ---');
  // 这里的代码只会在 worker.js 自身被直接作为 Node.js 脚本运行时执行
  // 在 worker_threads 场景下，是 parentPort 来处理通信
}
```

### 运行方式

保存上述两个文件，然后在终端中运行 `main.js`：

```bash
node main.js
```

**观察结果**：你会发现主线程的 `Main thread continues to run...` 消息会立即打印出来，而 Worker 线程的计算结果则会异步地陆续返回，证明了主线程并未被计算任务阻塞。

## 五、高级用法与注意事项

### 5.1 `SharedArrayBuffer` 与 `Atomics`

*   **`SharedArrayBuffer`**：用于创建可被多个 Worker 线程共享的原始二进制数据缓冲区。
*   **`Atomics`**：提供了一组静态方法，用于在 `SharedArrayBuffer` 上执行原子操作。这些操作是不可中断的，确保了在多线程环境下数据的完整性和同步性，防止竞态条件。
*   **使用场景**：当多个 Worker 线程需要频繁读写同一块内存时，`SharedArrayBuffer` 可以显著减少消息传递的开销，提高性能。但它也带来了多线程编程的复杂性，需要开发者自行处理同步问题。

### 5.2 错误处理与生命周期

*   **`worker.on('error', callback)`**: 捕获 Worker 线程内部未捕获的异常。
*   **`worker.on('exit', callback)`**: 在 Worker 线程退出时触发，无论正常退出还是因错误退出。`code` 参数为退出码（0 表示成功）。
*   **`worker.terminate()`**: 手动终止 Worker 线程。这会发送一个 `SIGTERM` 信号，强制 Worker 退出。如果 Worker 正在执行 CPU 密集型任务，这可能不是立即的。

### 5.3 Worker Pool (工作池)

频繁地创建和销毁 Worker 线程会带来一定的性能开销。对于需要处理大量短期 CPU 密集型任务的场景，推荐使用 Worker Pool：

1.  **预先创建固定数量的 Worker 线程**。
2.  **维护一个任务队列**。
3.  **当有新任务到来时，从池中取出一个空闲 Worker 进行处理**。
4.  **Worker 完成任务后，将其返回到池中，等待下一个任务**。

这可以有效地复用 Worker 线程，减少创建和销毁的开销，并限制并发 Worker 的数量，避免系统资源耗尽。

### 5.4 何时不使用 `worker_threads`

*   **I/O 密集型任务**：Node.js 的事件循环本身就非常擅长处理 I/O 密集型任务。将它们放入 Worker 线程通常不会带来性能提升，反而可能增加线程间通信的开销和复杂性。
*   **少量或简单的 CPU 任务**：对于耗时极短的 CPU 任务，创建 Worker 的开销可能大于直接在主线程执行的开销。
*   **对简单代码的过度设计**：引入多线程会增加代码的复杂性、调试难度和潜在的竞态条件。只在真正需要时使用。

## 六、`worker_threads` 与 `child_process` 对比

| 特性           | `child_process` (子进程)                             | `worker_threads` (工作线程)                               |
| :------------- | :--------------------------------------------------- | :-------------------------------------------------------- |
| **执行单元**   | 操作系统进程 (Operating System Process)              | 进程内的线程 (Thread within a Process)                      |
| **资源消耗**   | 较高 (独立的 Node.js 运行时、内存空间、文件描述符等) | 较低 (共享部分进程资源，独立 V8 实例和堆)                 |
| **启动速度**   | 较慢                                                 | 较快                                                      |
| **通信方式**   | IPC (Inter-Process Communication)，如管道、TCP 套接字、消息队列等 | 消息传递 (`postMessage()`)，通过 `MessagePort` 对象；可选 `SharedArrayBuffer` |
| **内存共享**   | 默认不共享，只能通过 IPC 传递数据                    | 默认不共享，但可通过 `SharedArrayBuffer` 实现真正的内存共享 (需 `Atomics` 同步) |
| **适用场景**   | 外部命令执行、长时运行的 I/O 密集型任务、独立的微服务、需要较高隔离度的任务 | CPU 密集型任务、并行计算、需要保持主线程响应性、计算密集型数据处理 |
| **错误隔离**   | 进程级别隔离，一个子进程崩溃不会影响主进程           | 线程级别隔离，但由于在同一进程内，可能对整个进程稳定性有影响 (如内存泄漏) |

## 七、总结

`worker_threads` 模块是 Node.js 解决 CPU 密集型任务阻塞主线程问题的强大工具。它通过引入多线程并行执行能力，使得 Node.js 应用程序能够更好地利用多核 CPU 资源，保持出色的响应性。然而，多线程编程引入了新的复杂性，如数据同步、竞态条件和错误处理。开发者在使用 `worker_threads` 时应权衡其带来的性能优势和额外的开发维护成本，并遵循最佳实践，例如使用 Worker Pool 管理线程，以及在必要时才使用 `SharedArrayBuffer`。正确使用 `worker_threads` 可以显著提升 Node.js 应用在特定场景下的性能和用户体验。