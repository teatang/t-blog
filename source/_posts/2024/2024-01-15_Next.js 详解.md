---
title: Next.js 详解
date: 2024-01-15 06:24:00
tags:
  - 2024
  - Next.js
  - React
  - 前端技术
categories:
  - 前端技术
  - React
---

> **Next.js** 是一个基于 [React](https://react.dev/) 的开源 **Web 框架**，由 Vercel 公司开发并维护。它为 React 应用程序提供了**生产级**的特性，如**服务器端渲染 (SSR)**、**静态站点生成 (SSG)**、**增量静态再生 (ISR)**，以及**文件系统路由**、**API 路由**、**图像优化**等。Next.js 旨在提升 React 应用的性能、SEO 友好性、可维护性和开发体验，使开发者能够更高效地构建全栈式的现代 Web 应用程序。

{% note info %}
核心思想：在 React 的基础上提供一套完整的生产级解决方案，通过灵活的渲染策略和内置优化，帮助开发者构建高性能、SEO 友好且易于维护的 Web 应用。
{% endnote %}
------

## 一、核心特性与概念

Next.js 在 React 的基础上引入了许多强大的特性，极大地简化了 Web 应用的开发过程。

### 1.1 强大的渲染策略 (Rendering Strategies)

Next.js 最引人注目的特性之一是其灵活的渲染策略。这允许开发者根据页面的内容和访问模式选择最合适的渲染方式，以优化性能和用户体验。

*   **客户端渲染 (Client-Side Rendering, CSR)**：
    *   **定义**：类似于传统的 React 应用，浏览器下载 JavaScript 文件后，在客户端执行 JavaScript 代码来构建和渲染页面内容。
    *   **特点**：初始加载可能较慢，不利于 SEO（搜索引擎可能无法抓取 JS 渲染的内容）。适合数据频繁变动、用户登录后的私有页面。
    *   **实现**：在 React 组件中使用 `useEffect` 或 `useState` 钩子在组件挂载后获取数据。在 App Router 中，默认组件是服务器组件，需通过 `"use client"` 指令标记为客户端组件。

*   **服务器端渲染 (Server-Side Rendering, SSR)**：
    *   **定义**：在每个用户请求到来时，Next.js 服务器都会在服务器端执行 React 组件，生成完整的 HTML 页面，然后将 HTML 发送到客户端。客户端接收到 HTML 页面后，React 客户端代码会将其“激活” (Hydration)，使其具备交互性。
    *   **特点**：首屏加载速度快，对 SEO 友好（能被搜索引擎完整抓取）。但每次请求都需要服务器生成 HTML，可能增加服务器负载。
    *   **实现 (Pages Router)**：在页面组件中导出异步函数 `getServerSideProps`。
    *   **实现 (App Router)**：默认所有组件都是服务器组件 (Server Components)，在组件内部直接使用 `await fetch()` 或其他异步逻辑即可。

*   **静态站点生成 (Static Site Generation, SSG)**：
    *   **定义**：在**构建时 (build time)** 预先生成所有页面的 HTML 文件。这些静态 HTML 文件可以直接部署到 CDN (内容分发网络) 上，当用户请求页面时，CDN 直接返回预生成的 HTML。
    *   **特点**：访问速度极快，CDN 全球分发，服务器零负载，部署成本低，对 SEO 友好。适用于内容不经常更新的页面（如博客文章、产品详情页）。
    *   **实现 (Pages Router)**：在页面组件中导出异步函数 `getStaticProps` 和可选的 `getStaticPaths` (用于动态路由)。
    *   **实现 (App Router)**：通过在服务器组件中直接使用 `fetch()`，并配合 `revalidate` 选项（或在 `fetch` 选项中设置缓存行为）来实现静态数据获取。

*   **增量静态再生 (Incremental Static Regeneration, ISR)**：
    *   **定义**：SSG 的增强。允许在应用部署后，按需（即当页面被访问时）在**后台重新生成**静态页面。当用户请求过期页面时，会先返回旧的静态页面（若有），同时触发后台重新生成新页面，下次请求时返回新页面。
    *   **特点**：结合了 SSG 的高性能和 SSR 的内容新鲜度。无需重新部署整个应用即可更新静态内容。
    *   **实现 (Pages Router)**：在 `getStaticProps` 返回的对象中添加 `revalidate` 属性，指定重新生成的时间间隔。
    *   **实现 (App Router)**：在 `fetch()` 调用中设置 `next: { revalidate: <seconds> }` 选项。

{% mermaid %}
graph TD
    A[User Request] --> B{Next.js Server};
    subgraph Rendering Decisions
        B -- First Request / Dynamic Data --> C[SSR: Render on Server]
        B -- Static Data / Build-Time --> D[SSG: Serve Pre-built Static HTML]
        B -- Content Stale / ISR --> E[ISR: Serve Old/Revalidate in Background]
        B -- Purely Interactive --> F[CSR: Send JS, Render on Client]
    end
    C --> G(Full HTML Page);
    D --> G;
    E --> G;
    F --> H(Empty HTML + JS Bundle);
    G --> I[Browser: Hydration/Display]
    H --> J[Browser: Execute JS, Fetch Data, Render Content];
{% endmermaid %}

### 1.2 文件系统路由 (File-System Routing)

Next.js 采用**基于文件系统的路由**，极大地简化了页面和 API 端点的创建。

*   **Pages Router (旧版，但仍广泛使用)**：在项目的 `pages` 目录下创建 `.js`, `.jsx`, `.ts`, `.tsx` 文件，即可自动生成对应的路由。
    *   `pages/index.js` -> `/`
    *   `pages/about.js` -> `/about`
    *   `pages/blog/[slug].js` -> `/blog/my-first-post` (动态路由)
    *   `pages/dashboard/[...params].js` -> `/dashboard/settings/profile` (捕获所有路由)

*   **App Router (Next.js 13+ 推出的推荐方式)**：在项目的 `app` 目录下创建目录结构，内部的 `page.js` 或 `page.tsx` 文件代表路由段。
    *   `app/page.tsx` -> `/`
    *   `app/about/page.tsx` -> `/about`
    *   `app/blog/[slug]/page.tsx` -> `/blog/my-first-post` (动态路由)
    *   `app/dashboard/[[...params]]/page.tsx` -> `/dashboard`, `/dashboard/settings`, `/dashboard/settings/profile` (可选捕获所有路由)
    *   还支持 `layout.tsx` (布局), `loading.tsx` (加载状态), `error.tsx` (错误边界), `template.tsx` (模板) 等特殊文件。

### 1.3 API 路由 (API Routes)

Next.js 允许在同一个项目中创建后端 API 端点，而无需搭建单独的后端服务器。

*   **Pages Router**：在 `pages/api` 目录下创建文件，例如 `pages/api/hello.js`。
*   **App Router**：在 `app` 路由段中创建 `route.ts` 或 `route.js` 文件，例如 `app/api/users/route.ts`。
*   **特点**：可以使用 Node.js 环境的所有能力，处理 HTTP 请求 (GET, POST, PUT, DELETE)，与数据库交互，处理认证等。

### 1.4 图像优化 (Image Optimization)

Next.js 通过内置的 `<Image>` 组件自动优化图片，极大地提升了网页加载性能。

*   **自动优化**：根据设备尺寸按需加载图片，支持 WebP 等现代格式，自动进行尺寸调整和压缩。
*   **懒加载**：图片只有进入视口时才加载，减少初始加载时间。
*   **布局移位防止**：使用占位符，防止图片加载时页面内容跳动，优化用户体验。

### 1.5 样式与 CSS 支持 (Styling and CSS Support)

Next.js 对多种样式方案提供了良好支持：

*   **CSS Modules**: 默认支持，为每个组件生成局部作用域的 CSS 类名，避免样式冲突。
*   **Styled-JSX**: 内置支持，允许在 React 组件内部编写带作用域的 CSS。
*   **Sass/Less**: 通过安装相应的 loader 支持预处理器。
*   **Tailwind CSS**: 广泛使用的原子化 CSS 框架，与 Next.js 集成良好。
*   **Global CSS**: 可以通过 `pages/_app.js` (Pages Router) 或 `app/layout.tsx` (App Router) 引入全局 CSS。

### 1.6 数据获取 (Data Fetching)

除了渲染策略中提到的数据获取方式，Next.js App Router 引入了更强大的数据获取范式：

*   **服务器组件中的 `fetch()`**: 在 App Router 中，默认的 Server Components 可以直接使用原生的 `fetch()` API 进行数据获取。Next.js 会自动优化这些 `fetch` 请求，进行缓存、去重，并支持 `async/await`。
*   **`revalidate` 选项**: 无论是 Pages Router (在 `getStaticProps` 返回) 还是 App Router (在 `fetch` 选项中)，都可以通过设置 `revalidate` 参数来实现 ISR。

### 1.7 中间件 (Middleware)

Next.js 允许开发者在请求完成之前执行代码，从而重写、重定向或修改请求头。

*   **定义**：在 `middleware.ts` 或 `middleware.js` 文件中定义，拦截所有传入请求。
*   **用途**：处理用户认证、国际化、A/B 测试、机器人检测等，非常灵活。

## 二、App Router vs. Pages Router

Next.js 13+ 推出了全新的 **App Router**，它代表了 Next.js 及 React 生态的未来方向。理解其与传统 **Pages Router** 的区别至关重要。

| 特性         | Pages Router                                       | App Router (Next.js 13+)                                                                    |
| :----------- | :------------------------------------------------- | :------------------------------------------------------------------------------------------ |
| **文件结构** | `pages/` 目录，每个文件代表一个路由                | `app/` 目录，每个目录段代表一个路由，内部的 `page.tsx` 代表路由的 UI                     |
| **组件类型** | 默认是客户端组件，可在 `getServerSideProps` 或 `getStaticProps` 中获取数据 | 默认是 **服务器组件 (Server Components, RSC)**，通过 `"use client"` 标记客户端组件        |
| **数据获取** | `getServerSideProps`, `getStaticProps`, `getStaticPaths`, `useEffect` + `fetch` | 服务器组件中直接 `await fetch()`，自动缓存和去重；客户端组件中 `useEffect` + `fetch`     |
| **API 路由** | `pages/api/` 目录下创建文件                        | `app/` 路由段中创建 `route.ts` 文件                                                         |
| **布局管理** | `pages/_app.js` (全局) 和组件内手动布局             | 统一的 `layout.tsx` (嵌套布局、共享状态)，`template.tsx`, `loading.tsx`, `error.tsx` 等特殊文件 |
| **流式传输** | 不支持                                             | 通过 React Suspense 支持流式传输，分块发送 UI，提升用户感知性能                             |
| **路由模式** | 基于文件，相对简单                                 | 基于文件夹，支持更复杂的布局和路由结构，支持并行路由和拦截路由                              |
| **优点**     | 教程多，社区成熟，许多现有项目仍使用               | **性能更优** (更少 JS 发送到客户端)，**更好的开发体验** (无需繁琐的数据获取函数)，**更灵活** (RSC)，**可伸缩性强** |
| **缺点**     | 通常发送更多 JS 到客户端，数据获取模式分散          | 新范式，学习曲线陡峭，生态系统仍在发展，部分库兼容性问题                                   |

**推荐**：对于新项目，强烈建议使用 App Router。它代表了 React 和 Next.js 的未来方向，能够带来更优的性能和更一致的开发体验。对于现有 Pages Router 项目，可以根据需求逐步迁移。

## 三、代码示例

为了演示 Next.js 的核心特性，我们将分别展示 Pages Router 和 App Router 的一些典型代码片段。

### 3.1 Pages Router (Legacy) 示例

**1. 静态页面 with `getStaticProps` (SSG)**
`pages/posts/[id].tsx`
```typescript jsx
// pages/posts/[id].tsx
import { GetStaticProps, GetStaticPaths } from 'next';

interface Post {
  id: string;
  title: string;
  content: string;
}

interface PostProps {
  post: Post;
}

export default function PostDetail({ post }: PostProps) {
  if (!post) {
    return <div>Loading or Post not found...</div>;
  }
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </div>
  );
}

// 在构建时生成所有可能的 ID 路径
export const getStaticPaths: GetStaticPaths = async () => {
  // 模拟从 API 获取所有文章的 ID
  const posts = [
    { id: '1', title: 'First Post', content: '...' },
    { id: '2', title: 'Second Post', content: '...' },
  ];
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }));

  return { paths, fallback: false }; // fallback: false 意味着不会生成未定义的路径
};

// 在构建时获取每个 ID 对应的文章数据
export const getStaticProps: GetStaticProps<PostProps> = async ({ params }) => {
  const id = params?.id as string;
  // 模拟从数据库或 API 获取特定 ID 的文章
  const post = {
    id: id,
    title: `Post ${id} Title`,
    content: `This is the content for post number ${id}.`,
  };

  return {
    props: { post },
    // revalidate: 60 // 可选：每 60 秒尝试在后台重新生成一次页面 (ISR)
  };
};
```

**2. 服务器渲染页面 with `getServerSideProps` (SSR)**
`pages/ssr-example.tsx`
```typescript jsx
// pages/ssr-example.tsx
import { GetServerSideProps } from 'next';

interface ServerDataProps {
  timestamp: string;
  userAgent: string;
}

export default function SSRExample({ timestamp, userAgent }: ServerDataProps) {
  return (
    <div>
      <h1>Server-Side Rendered Page</h1>
      <p>Data fetched on server for each request:</p>
      <p>Timestamp: {timestamp}</p>
      <p>User-Agent: {userAgent}</p>
    </div>
  );
}

// 在每次请求时在服务器端获取数据
export const getServerSideProps: GetServerSideProps<ServerDataProps> = async (context) => {
  const userAgent = context.req.headers['user-agent'] || 'Unknown';
  const timestamp = new Date().toLocaleString();

  // 这里可以进行数据库查询、API 调用等服务器端操作
  return {
    props: {
      timestamp,
      userAgent,
    },
  };
};
```

**3. API 路由**
`pages/api/getTime.ts`
```typescript
// pages/api/getTime.ts
import { NextApiRequest, NextApiResponse } from 'next';

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'GET') {
    res.status(200).json({ time: new Date().toISOString() });
  } else {
    res.setHeader('Allow', ['GET']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
```

### 3.2 App Router (推荐) 示例

**1. 默认服务器组件 (Server Component) 页面 / 数据获取**
`app/page.tsx`
```typescript jsx
// app/page.tsx
// 这是一个服务器组件 (默认)
async function getFortune() {
  // 直接在服务器组件中进行数据获取，Next.js 会自动优化 (缓存/去重)
  // 默认为 SSG 行为（如果不是动态参数且不设置 revalidate）
  const res = await fetch('https://api.kanye.rest/', { next: { revalidate: 3600 } }); // ISR: 每小时重新验证
  const data = await res.json();
  return data.quote;
}

export default async function HomePage() {
  const fortune = await getFortune();

  return (
    <div>
      <h1>Welcome to Next.js App Router!</h1>
      <p>Here's a quote from Kanye West:</p>
      <blockquote style={{ fontStyle: 'italic', borderLeft: '3px solid #ccc', paddingLeft: '10px' }}>
        "{fortune}"
      </blockquote>
      <p>This page is rendered on the server.</p>
      {/* <ClientCounter /> // 这里可以引入客户端组件 */}
    </div>
  );
}
```

**2. 客户端组件 (Client Component)**
`app/client-counter.tsx`
```typescript jsx
// app/client-counter.tsx
'use client'; // 明确声明这是一个客户端组件

import { useState } from 'react';

export default function ClientCounter() {
  const [count, setCount] = useState(0);

  return (
    <div style={{ border: '1px solid #eee', padding: '15px', marginTop: '20px' }}>
      <h2>Client Component Example</h2>
      <p>You clicked {count} times.</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**3. API 路由 (`route.ts`)**
`app/api/hello/route.ts`
```typescript
// app/api/hello/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const name = searchParams.get('name') || 'world';

  return NextResponse.json({ message: `Hello, ${name}!` });
}

export async function POST(request: NextRequest) {
  const data = await request.json();
  return NextResponse.json({ received: data, status: 'success' }, { status: 201 });
}
```

**4. 中间件 (Middleware)**
`middleware.ts` (在项目根目录或 `src` 目录下)
```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const isAuthenticated = request.cookies.has('auth-token'); 

  // 示例：保护 /dashboard 路由
  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    if (!isAuthenticated) {
      // 如果未认证，重定向到登录页
      return NextResponse.redirect(new URL('/login', request.url));
    }
  }

  // 示例：重写 /legacy 路由到 /new-route
  if (request.nextUrl.pathname === '/legacy') {
    return NextResponse.rewrite(new URL('/new-route', request.url));
  }

  return NextResponse.next(); // 继续请求
}

// 配置中间件匹配的路径
export const config = {
  matcher: ['/dashboard/:path*', '/legacy'], // 匹配 /dashboard 及所有子路径，以及 /legacy 路径
};
```

## 四、Next.js 的优点

1.  **卓越性能**：通过 SSR/SSG/ISR 等多种渲染方式，有效减少首屏加载时间，结合图像优化、代码分割等，提供极速的用户体验。
2.  **SEO 友好**：SSR 和 SSG 生成的 HTML 内容对搜索引擎爬虫非常友好，有利于网站在搜索结果中的排名。
3.  **开发者体验 (DX)**：
    *   **文件系统路由**：直观且易于维护。
    *   **快速刷新 (Fast Refresh)**：开发过程中代码改动后，页面能够快速更新，保持应用状态。
    *   **内置工具**：包括 Babel、Webpack (Vite 支持正在实验中) 配置，开箱即用。
4.  **全栈能力**：通过 API 路由，开发者可以在同一个 Next.js 项目中构建前端和后端 API，简化了全栈开发的复杂性。
5.  **可伸缩性与灵活性**：渲染策略的灵活性使得 Next.js 能够适应各种规模和类型的项目。App Router 引入的服务器组件进一步提升了状态管理和数据获取的可伸缩性。
6.  **强大的社区与生态系统**：作为最受欢迎的 React 框架之一，拥有庞大活跃的社区，丰富的插件和完善的文档。
7.  **未来前端趋势**：App Router 和 React Server Components (RSC) 代表了 React 的发展方向，Next.js 是率先将其落地并实践的框架。

## 五、Next.js 的缺点与考虑

1.  **学习曲线**：对于没有 React 经验的开发者，需要同时学习 React 和 Next.js 的框架概念。尤其是 App Router 和 Server Components 的新范式，可能需要时间适应。
2.  **服务器成本**：虽然 SSG 可以降低成本，但 SSR 或 ISR 功能的应用需要运行 Node.js 服务器，相较于纯静态网站可能会增加部署和维护成本。
3.  **框架意见 (Opinionated)**：Next.js 提供了一套推荐的开发模式和规范，可能对某些需要高度定制化构建工具或工作流的项目造成一定限制。
4.  **打包体积 (Bundle Size)**：尽管 Next.js 有很多优化，但其运行时代码和必要的 hydrate 脚本依然会增加初始 JS 包的体积，在极端轻量级场景下可能不如纯静态 HTML 或其他微型框架。
5.  **数据中心地域性**：对于需要严格数据主权或本地化部署的场景，如果利用 Vercel 等平台，其全球 CDN 和边缘计算优势可能无法完全发挥。

## 六、适用场景

Next.js 适用于以下多种项目类型：

*   **内容管理系统 (CMS) 驱动的网站**：如博客、新闻站点、文档网站，通过 SSG/ISR 可以实现高性能和 SEO 友好的内容展示。
*   **电商网站**：产品列表、详情页等对 SEO 和首屏性能要求极高的场景，SSR/SSG 结合 CSR 实现复杂交互。
*   **营销网站与企业官网**：需要快速加载、良好 SEO 的品牌展示型网站。
*   **仪表盘或管理后台**：通过 SSR 预渲染骨架，结合 CSR 实现丰富的交互逻辑。
*   **个人项目与小型 SaaS 产品**：利用其全栈能力快速原型开发和部署。
*   **任何需要高性能和 SEO 的 React 应用**。

## 七、总结

Next.js 凭借其多样的渲染策略、内置优化、文件系统路由和全栈能力，已成为构建现代高性能 React 应用的首选框架。从早期的 Pages Router 到引入 React Server Components 的 App Router，Next.js 始终走在前端技术发展的前沿，致力于提高 Web 应用的性能、开发效率和用户体验。虽然学习新概念可能需要投入时间，但其带来的收益（尤其是性能和可维护性）通常是值得的。对于任何寻求构建高性能、SEO 友好且具有良好可伸缩性的 React Web 应用程序的开发者或团队来说，Next.js 都是一个极其强大的工具。