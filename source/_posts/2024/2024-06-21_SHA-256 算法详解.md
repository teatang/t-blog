---
title: SHA-256 算法详解
date: 2024-06-21 06:24:00
tags:
  - 2024
  - 哈希算法
  - 加密算法
  - 计算机网络
categories:
  - 计算机网络
  - 加密算法
mathjax: true
---
> **SHA-256 (Secure Hash Algorithm 256-bit)** 是密码学哈希函数家族 SHA-2 (Secure Hash Algorithm 2) 的成员。它是一个单向 (One-way) 函数，能够接收任意长度的输入数据，并生成一个固定长度为 256 位的（32 字节）哈希值（或称为“消息摘要”）。SHA-256 广泛应用于数字签名、证书验证、数据完整性检查、区块链技术（如比特币）等领域，是目前最受信任和广泛部署的哈希算法之一。

{% note info %}
核心思想：SHA-256 通过将输入消息进行填充、分块、迭代压缩，最终生成一个固定长度的 256 位哈希值。其设计利用了一系列复杂的位运算（逻辑运算、循环移位），以确保哈希值的**单向性、抗碰撞性、抗原像攻击和抗第二原像攻击**，从而提供数据的完整性和身份验证。
{% endnote %}
------

## 一、加密哈希函数的基本特性

在深入 SHA-256 之前，理解一个安全的加密哈希函数应具备的关键特性至关重要：

*   **确定性 (Deterministic)**：相同的输入消息总是产生相同的哈希值。
*   **计算效率 (Computational Efficiency)**：对于任意输入消息，计算其哈希值是高效的。
*   **抗原像性 / 单向性 (Preimage Resistance / One-Way)**：给定一个哈希值，从计算上不可能找到原始输入消息。
*   **抗第二原像性 (Second Preimage Resistance)**：给定一个输入消息和它的哈希值，从计算上不可能找到另一个不同的输入消息，使其产生相同的哈希值。
*   **抗碰撞性 (Collision Resistance)**：从计算上不可能找到任意两个不同的输入消息，使其产生相同的哈希值。

SHA-256 被设计为满足上述所有特性，尤其是在抗碰撞性方面远超 MD5 和 SHA-1。

## 二、SHA-256 算法原理

SHA-256 算法基于 **Merkle-Damgård 结构**，它将输入消息分割成固定大小的块，并对每个块进行迭代处理。整个过程可以概括为以下几个主要步骤：

### 2.1 填充 (Padding)

首先，原始消息需要进行填充，使其长度（以位为单位）在模 512 之后余 448。也就是说，填充后的消息长度应为 $512n - 64$ 位，其中 $n$ 是某个正整数。
填充过程如下：
1.  在消息末尾添加一个 `1` 位。
2.  接着添加尽可能多的 `0` 位，直到消息的长度满足 $length \equiv 448 \pmod{512}$。
    *   即使消息长度已经满足此条件，也需要进行一轮完整的填充（添加一个 `1` 和 511 个 `0`）。

### 2.2 附加长度 (Appending Length)

在填充完毕的消息之后，附加 64 位的原始消息长度（以位为单位）。这个 64 位长度值以大端序 (big-endian) 形式附加。
经过填充和附加长度后，消息的总长度将是 512 位的整数倍。这些 512 位的块将是算法处理的基本单位。

### 2.3 初始化哈希值 (Initialize Hash Values - IVs)

SHA-256 使用 8 个 32 位的初始哈希值 (Initial Hash Values, IVs) $H_0$ 到 $H_7$。这些值是根据前 8 个素数（2, 3, 5, 7, 11, 13, 17, 19）的平方根的小数部分取前 32 位得到的。
这些常量以十六进制表示为：

*   $H_0 = \text{0x6a09e667}$
*   $H_1 = \text{0xbb67ae85}$
*   $H_2 = \text{0x3c6ef372}$
*   $H_3 = \text{0xa54ff53a}$
*   $H_4 = \text{0x510e527f}$
*   $H_5 = \text{0x9b05688c}$
*   $H_6 = \text{0x1f83d9ab}$
*   $H_7 = \text{0x5be0cd19}$

### 2.4 消息处理循环 (Message Processing Loop)

将经过填充和附加长度处理后的消息划分为 N 个 512 位的消息块 $M^{(1)}, M^{(2)}, \dots, M^{(N)}$。算法依次处理每个块。
对于每个 512 位的消息块 $M^{(i)}$，都通过一个**压缩函数 (Compression Function)** 进行处理。压缩函数接收当前的 512 位消息块和前一个块产生的 256 位哈希值（即当前的 $H_0, \dots, H_7$），并输出一个新的 256 位哈希值。

压缩函数的核心步骤如下：

#### 2.4.1 消息扩展 (Message Schedule)

将输入的 512 位消息块 $M^{(i)}$ 分解成 16 个 32 位的字 $W_0, W_1, \dots, W_{15}$。然后，将这 16 个字扩展成 64 个 32 位的字 $W_0, W_1, \dots, W_{63}$。
对于 $t$ 从 16 到 63：
$$
W_t = \sigma_1(W_{t-2}) + W_{t-7} + \sigma_0(W_{t-15}) + W_{t-16}
$$
其中，`+` 表示模 $2^{32}$ 的加法。
两个辅助函数 $\sigma_0$ 和 $\sigma_1$ 定义为：
$$
\sigma_0(x) = \text{ROTR}^7(x) \oplus \text{ROTR}^{18}(x) \oplus \text{SHR}^3(x) \\
\sigma_1(x) = \text{ROTR}^{17}(x) \oplus \text{ROTR}^{19}(x) \oplus \text{SHR}^{10}(x)
$$
*   `ROTR^n(x)`：表示将 32 位字 $x$ 循环右移 $n$ 位。
*   `SHR^n(x)`：表示将 32 位字 $x$ 逻辑右移 $n$ 位。
*   `$\oplus$`：表示按位异或。

#### 2.4.2 压缩函数主循环 (64 轮)

每个消息块的处理包含 64 轮迭代。每轮迭代都会更新 8 个 32 位的**工作变量 (working variables)** $a, b, c, d, e, f, g, h$。
初始时，这些工作变量被赋值为当前的哈希值：$a=H_0, b=H_1, \dots, h=H_7$。

在每一轮 $t$ (从 0 到 63) 中，执行以下操作：
1.  **轮常数 ($K_t$)**：SHA-256 定义了 64 个 32 位常数 $K_0, K_1, \dots, K_{63}$。这些常数是根据前 64 个素数的立方根的小数部分取前 32 位得到的。
2.  **逻辑函数**：
    *   **选择函数 (Ch)**: $Ch(x, y, z) = (x \land y) \oplus (\neg x \land z)$
    *   **多数函数 (Maj)**: $Maj(x, y, z) = (x \land y) \oplus (x \land z) \oplus (y \land z)$
    *   **大写Sigma函数 ($\Sigma_0, \Sigma_1$)**:
        *   $\Sigma_0(x) = \text{ROTR}^2(x) \oplus \text{ROTR}^{13}(x) \oplus \text{ROTR}^{22}(x)$
        *   $\Sigma_1(x) = \text{ROTR}^6(x) \oplus \text{ROTR}^{11}(x) \oplus \text{ROTR}^{25}(x)$
3.  **计算两个临时变量 `temp1` 和 `temp2`**:
    $$
    temp1 = h + \Sigma_1(e) + Ch(e,f,g) + K_t + W_t \\
    temp2 = \Sigma_0(a) + Maj(a,b,c)
    $$
    所有加法都是模 $2^{32}$ 的加法。
4.  **更新工作变量**:
    $$
    h = g \\
    g = f \\
    f = e \\
    e = d + temp1 \\
    d = c \\
    c = b \\
    b = a \\
    a = temp1 + temp2
    $$
这个循环重复 64 次。

**SHA-256 压缩函数单轮示意图 (简化)：**

{% mermaid %}
graph TD
    subgraph Inputs for Round t
        A(a) -- Current A --> A_Sigma0("Σ0(a)")
        B(b)
        C(c)
        D(d)
        E(e) -- Current E --> E_Sigma1("Σ1(e)")
        F(f)
        G(g)
        H(h)
        Kt[Kt]
        Wt[Wt]
    end

    A_Sigma0 --> Maj["Maj(a,b,c)"]
    B --> Maj
    C --> Maj

    E_Sigma1 --> Ch["Ch(e,f,g)"]
    F --> Ch
    G --> Ch

    temp1_calc("h + Σ1(e) + Ch(e,f,g) + Kt + Wt")
    temp2_calc("Σ0(a) + Maj(a,b,c)")

    H --> temp1_calc
    E_Sigma1 --> temp1_calc
    Ch --> temp1_calc
    Kt --> temp1_calc
    Wt --> temp1_calc

    A_Sigma0 --> temp2_calc
    Maj --> temp2_calc

    temp1_calc --> next_e[e = d + temp1]
    temp1_calc --> next_a[a = temp1 + temp2]
    temp2_calc --> next_a

    D --> next_e
  
    A --> next_b[b = a]
    B --> next_c[c = b]
    C --> next_d[d = c]
    E --> next_f[f = e]
    F --> next_g[g = f]
    G --> next_h[h = g]

    next_a --> OutputA[New a]
    next_b --> OutputB[New b]
    next_c --> OutputC[New c]
    next_d --> OutputD[New d]
    next_e --> OutputE[New e]
    next_f --> OutputF[New f]
    next_g --> OutputG[New g]
    next_h --> OutputH[New h]

    OutputA & OutputB & OutputC & OutputD & OutputE & OutputF & OutputG & OutputH --> Z{Update A-H for next round}
{% endmermaid %}

#### 2.4.3 更新哈希值

在对当前 512 位消息块的 64 轮处理完成后，将初始的工作变量 $a, b, \dots, h$ (即本轮开始时的 $H_0, \dots, H_7$) 与本轮结束后的工作变量进行模 $2^{32}$ 的加法，更新哈希值：
$$
H_0 = H_0 + a \\
H_1 = H_1 + b \\
\dots \\
H_7 = H_7 + h
$$
这个更新后的 256 位哈希值将作为下一个消息块处理的输入。

### 2.5 输出 (Output)

当所有 512 位的消息块都处理完毕后，最终的 8 个 32 位哈希值 $H_0, H_1, \dots, H_7$ 按大端序连接起来，就构成了最终的 256 位（32 字节）SHA-256 消息摘要。

## 三、SHA-256 的安全性与应用

*   **安全性**：SHA-256 被认为是安全的加密哈希函数，目前尚未发现任何实际可行的碰撞攻击或原像攻击。其设计复杂度、大哈希值长度和位操作的结合，使其在计算上抵抗各种已知密码分析攻击。
*   **应用**：
    *   **数字签名**：广泛用于 TLS/SSL 证书、代码签名、文件签名，确保数据来源的真实性和完整性。
    *   **密码存储**：用于存储用户密码的哈希值。为了增强安全性，通常会结合**盐值 (Salt)** 和密钥派生函数 (KDF)，如 PBKDF2、scrypt 或 Argon2，来抵御彩虹表攻击和暴力破解。
    *   **数据完整性校验**：通过比较文件或数据的 SHA-256 哈希值来验证其在传输或存储过程中是否被篡改。
    *   **区块链和加密货币**：比特币的核心工作量证明 (Proof of Work) 机制就严重依赖 SHA-256 算法。
    *   **伪随机数生成器**：可以作为构建安全伪随机数生成器的组件。

## 四、Go 语言实现示例

Go 语言的 `crypto/sha256` 包提供了 SHA-256 算法的标准实现。

```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
)

// calculateSHA256String 计算给定字符串的 SHA-256 哈希值，并返回 64 位十六进制字符串
func calculateSHA256String(input string) string {
	hasher := sha256.New()           // 创建一个新的 SHA-256 哈希器
	hasher.Write([]byte(input))      // 将输入字符串写入哈希器
	return hex.EncodeToString(hasher.Sum(nil)) // 计算哈希值并转换为十六进制字符串
}

// calculateSHA256File 计算给定文件的 SHA-256 哈希值
func calculateSHA256File(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", fmt.Errorf("打开文件失败: %w", err)
	}
	defer file.Close() // 确保文件在函数结束时关闭

	hasher := sha256.New()
	// 将文件内容复制到哈希器中进行计算
	if _, err := io.Copy(hasher, file); err != nil {
		return "", fmt.Errorf("读取文件内容失败: %w", err)
	}

	return hex.EncodeToString(hasher.Sum(nil)), nil
}

func main() {
	// 1. 计算字符串的 SHA-256 值
	fmt.Println("--- 计算字符串 SHA-256 ---")
	message1 := "Hello, SHA-256!"
	hash1 := calculateSHA256String(message1)
	fmt.Printf("消息: \"%s\"\nSHA-256: %s (长度: %d 字节)\n", message1, hash1, len(hash1)/2)

	message2 := "hello, sha-256!" // 哪怕一个字符或大小写不同，哈希值也完全不同
	hash2 := calculateSHA256String(message2)
	fmt.Printf("消息: \"%s\"\nSHA-256: %s (长度: %d 字节)\n", message2, hash2, len(hash2)/2)

	// 2. 演示 SHA-256 的确定性
	fmt.Println("\n--- 确定性演示 ---")
	message3 := "Go语言SHA-256示例"
	hash3a := calculateSHA256String(message3)
	hash3b := calculateSHA256String(message3)
	fmt.Printf("消息: \"%s\"\n第一次SHA-256: %s\n第二次SHA-256: %s\n", message3, hash3a, hash3b)
	if hash3a == hash3b {
		fmt.Println("✅ 相同输入产生相同输出。")
	}

	// 3. 计算文件的 SHA-256 值 (需要先创建一个测试文件)
	fmt.Println("\n--- 计算文件 SHA-256 ---")
	testFileName := "sha256_testfile.txt"
	fileContent := "这是一个测试文件的内容，用于计算SHA-256哈希值。\n" +
		"您可以修改这个文件，然后再次运行程序，观察MD5值的变化。"
	
	err := os.WriteFile(testFileName, []byte(fileContent), 0644) // 0644 是文件权限
	if err != nil {
		log.Fatalf("创建测试文件失败: %v", err)
	}
	fmt.Printf("已创建测试文件: %s\n", testFileName)

	fileSHA256, err := calculateSHA256File(testFileName)
	if err != nil {
		log.Fatalf("计算文件 SHA-256 失败: %v", err)
	}
	fmt.Printf("文件 \"%s\" 的 SHA-256: %s\n", testFileName, fileSHA256)

	// 4. (可选) 演示文件修改会导致 SHA-256 改变
	fmt.Println("\n--- 演示文件修改 (雪崩效应) ---")
	modifiedContent := fileContent + "\n末尾添加了一行内容，观察哈希值的剧烈变化。"
	err = os.WriteFile(testFileName, []byte(modifiedContent), 0644)
	if err != nil {
		log.Fatalf("修改测试文件失败: %v", err)
	}
	fmt.Printf("已修改测试文件: %s\n", testFileName)

	modifiedFileSHA256, err := calculateSHA256File(testFileName)
	if err != nil {
		log.Fatalf("计算修改后文件 SHA-256 失败: %v", err)
	}
	fmt.Printf("修改后文件 \"%s\" 的 SHA-256: %s\n", testFileName, modifiedFileSHA256)
	if fileSHA256 != modifiedFileSHA256 {
		fmt.Println("✅ SHA-256 值发生变化，证明数据被修改 (体现了雪崩效应)。")
	} else {
		fmt.Println("❌ SHA-256 值未变化，但文件内容已修改 (这不可能发生，除非是碰撞攻击)。")
	}

	// 清理测试文件 (可选)
	// os.Remove(testFileName)
}
```

## 五、总结

SHA-256 算法以其 256 位的固定输出长度、强大的抗碰撞性和抗原像性，成为了现代密码学中不可或缺的工具。尽管其内部结构比 MD5 或 SHA-1 更为复杂，但这些复杂性正是其安全性的保证。在需要数据完整性验证、数字签名、密码存储以及区块链等对安全性要求极高的应用中，SHA-256 是一个可靠且广泛推荐的选择。理解其基本原理和正确使用方式，对于构建安全的数字系统至关重要。