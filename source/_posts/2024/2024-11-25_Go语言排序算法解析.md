---
title: Go语言排序算法解析
date: 2024-11-25 06:24:00
tags: 
    - 2025
    - Golang
    - 算法
categories:
    - Golang
    - 算法
---
# Go 语言实现经典排序算法解析

{% note info %}
本文档旨在详细解析在 Go 语言中实现经典的五种排序算法：**快速排序**、**归并排序**、**插入排序**、**选择排序**和**堆排序**。我们将深入探讨每种算法的原理、时间复杂度、空间复杂度，并提供清晰的 Go 语言代码实现示例。
{% endnote %}

---

## 1. 引言

排序算法是计算机科学中最基础也是最重要的算法之一。它们用于将一组数据按照特定顺序（升序或降序）进行排列。理解并掌握不同排序算法的原理及实现，对于优化程序性能、解决实际问题至关重要。

在 Go 语言中，数组和切片 (`[]int`) 是常见的排序数据结构。我们将在接下来的章节中，针对这五种经典算法，给出易于理解和实践的 Go 语言实现。

---

## 2. 快速排序 (Quick Sort)

### 原理

快速排序是一种分而治之的排序算法。其基本思想是：

1.  **选择基准 (Pivot) 元素：** 从数组中选择一个元素作为“基准”（通常是第一个、最后一个或中间元素，或随机选择）。
2.  **分区 (Partition)：** 重新排列数组，将所有比基准值小的元素放在基准的左边，所有比基准值大的元素放在基准的右边。基准值现在处于其最终的排序位置。
3.  **递归排序：** 递归地对基准值左边和右边的子数组进行快速排序。

这个过程重复进行，直到所有子数组的长度为 0 或 1，此时数组完全有序。

### 时间复杂度

*   **平均情况：** `O(n log n)`
*   **最坏情况：** `O(n^2)` (当数组已经有序或逆序，且选择的基准不当时发生)
*   **最好情况：** `O(n log n)`

### 空间复杂度

*   **平均情况：** `O(log n)` (由递归栈深度决定)
*   **最坏情况：** `O(n)` (当每次分区都非常不平衡时)

### Go 语言实现

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

// QuickSort 对整数切片进行快速排序
func QuickSort(arr []int) {
	quickSortHelper(arr, 0, len(arr)-1)
}

// quickSortHelper 是快速排序的递归辅助函数
func quickSortHelper(arr []int, low, high int) {
	if low < high {
		// 分区操作，并返回基准元素的最终位置
		pivotIndex := partition(arr, low, high)

		// 递归对基准左右两边的子数组进行排序
		quickSortHelper(arr, low, pivotIndex-1)
		quickSortHelper(arr, pivotIndex+1, high)
	}
}

// partition 实现了分区操作
func partition(arr []int, low, high int) int {
	// 可以选择不同的基准策略，这里简单选择最后一个元素作为基准
	// 也可以随机选择基准，避免最坏情况
	rand.Seed(time.Now().UnixNano())
	pivotIndex := low + rand.Intn(high-low+1) // 随机选择基准
	arr[pivotIndex], arr[high] = arr[high], arr[pivotIndex] // 将随机选择的基准与最后一个元素交换

	pivot := arr[high] // 选择最后一个元素作为基准
	i := low - 1       // i 指向小于基准的元素的右边界

	for j := low; j < high; j++ {
		// 如果当前元素小于基准，将其交换到基准的左边
		if arr[j] < pivot {
			i++
			arr[i], arr[j] = arr[j], arr[i]
		}
	}
	// 将基准元素放到正确的位置 (i+1)
	arr[i+1], arr[high] = arr[high], arr[i+1]
	return i + 1 // 返回基准元素的最终索引
}

/*
func main() {
	arr := []int{10, 7, 8, 9, 1, 5, 23, 12, 11, 2}
	fmt.Println("原始数组:", arr)
	QuickSort(arr)
	fmt.Println("快速排序后:", arr) // [1 2 5 7 8 9 10 11 12 23]
}
*/
```

---

## 3. 归并排序 (Merge Sort)

### 原理

归并排序也是一种分而治之的算法。其基本思想是：

1.  **分解 (Divide)：** 将待排序的数组分解成两个大致相等的子数组。
2.  **解决 (Conquer)：** 递归地对这两个子数组进行归并排序。
3.  **合并 (Combine)：** 将两个已经排序的子数组合并成一个最终排序的数组。

这个过程不断分解，直到子数组只包含一个元素（一个元素被认为是自然的有序）。然后从下而上，逐层合并这些有序的子数组。

### 时间复杂度

*   **平均情况：** `O(n log n)`
*   **最坏情况：** `O(n log n)`
*   **最好情况：** `O(n log n)`

### 空间复杂度

*   **`O(n)`** (合并操作需要一个额外的辅助数组)

### Go 语言实现

```go
package main

// MergeSort 对整数切片进行归并排序
func MergeSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr // 递归基：数组长度为0或1时，已经有序
	}

	mid := len(arr) / 2
	left := MergeSort(arr[:mid])  // 递归排序左半部分
	right := MergeSort(arr[mid:]) // 递归排序右半部分

	return merge(left, right) // 合并两个有序的子数组
}

// merge 合并两个已经排序的整数切片
func merge(left, right []int) []int {
	result := make([]int, 0, len(left)+len(right))
	i, j := 0, 0

	// 比较左右两个切片的元素，依次放入结果切片
	for i < len(left) && j < len(right) {
		if left[i] < right[j] {
			result = append(result, left[i])
			i++
		} else {
			result = append(result, right[j])
			j++
		}
	}

	// 将剩余的元素添加到结果切片
	result = append(result, left[i:]...)
	result = append(result, right[j:]...)

	return result
}

/*
func main() {
	arr := []int{38, 27, 43, 3, 9, 82, 10}
	fmt.Println("原始数组:", arr)
	sortedArr := MergeSort(arr)
	fmt.Println("归并排序后:", sortedArr) // [3 9 10 27 38 43 82]
}
*/
```

---

## 4. 插入排序 (Insertion Sort)

### 原理

插入排序的工作方式类似于我们整理扑克牌。对于未排序数据中的每一个元素，它都会插入到已排序部分的相应位置上。

1.  假设数组的第一个元素已经排序。
2.  从第二个元素开始，遍历数组。
3.  对于当前元素，将其与前面已排序部分的元素逐一比较（从右向左）。
4.  如果当前元素小于已排序部分的某个元素，则将该已排序元素向右移动一位，为当前元素腾出位置。
5.  重复步骤 4，直到找到当前元素的正确位置或达到已排序部分的开头。
6.  将当前元素插入到正确的位置。

### 时间复杂度

*   **平均情况：** `O(n^2)`
*   **最坏情况：** `O(n^2)` (当数组完全逆序时)
*   **最好情况：** `O(n)` (当数组已经有序时，只需比较一次)

### 空间复杂度

*   **`O(1)`** (原地排序，只需要常数额外的空间)

### Go 语言实现

```go
package main

// InsertionSort 对整数切片进行插入排序
func InsertionSort(arr []int) {
	n := len(arr)
	for i := 1; i < n; i++ {
		key := arr[i] // 待插入的元素
		j := i - 1    // 已排序部分的最后一个元素的索引

		// 将比 key 大的元素向右移动
		for j >= 0 && arr[j] > key {
			arr[j+1] = arr[j]
			j--
		}
		// 找到正确位置，插入 key
		arr[j+1] = key
	}
}

/*
func main() {
	arr := []int{12, 11, 13, 5, 6}
	fmt.Println("原始数组:", arr)
	InsertionSort(arr)
	fmt.Println("插入排序后:", arr) // [5 6 11 12 13]
}
*/
```

---

## 5. 选择排序 (Selection Sort)

### 原理

选择排序是一种简单直观的排序算法。其基本思想是：

1.  **查找最小值：** 在未排序部分中找到最小（或最大）的元素。
2.  **放置到位：** 将找到的最小值与未排序部分的第一个元素进行交换。
3.  **重复：** 重复上述步骤，直到整个数组排序完成。

每次遍历都会确定一个元素在最终排序数组中的位置。

### 时间复杂度

*   **平均情况：** `O(n^2)`
*   **最坏情况：** `O(n^2)`
*   **最好情况：** `O(n^2)`

### 空间复杂度

*   **`O(1)`** (原地排序，只需要常数额外的空间)

### Go 语言实现

```go
package main

// SelectionSort 对整数切片进行选择排序
func SelectionSort(arr []int) {
	n := len(arr)
	for i := 0; i < n-1; i++ { // 外层循环遍历未排序部分的起始位置
		minIndex := i // 假设当前元素是最小的

		// 内层循环寻找未排序部分中的最小值
		for j := i + 1; j < n; j++ {
			if arr[j] < arr[minIndex] {
				minIndex = j
			}
		}

		// 将找到的最小值与当前未排序部分的第一个元素交换
		// 这样，minIndex 处的元素就确定了其最终位置
		arr[i], arr[minIndex] = arr[minIndex], arr[i]
	}
}

/*
func main() {
	arr := []int{64, 25, 12, 22, 11}
	fmt.Println("原始数组:", arr)
	SelectionSort(arr)
	fmt.Println("选择排序后:", arr) // [11 12 22 25 64]
}
*/
```

---

## 6. 堆排序 (Heap Sort)

### 原理

堆排序是一种基于比较的排序算法，它利用了二叉堆（Binary Heap）的数据结构特性。二叉堆可以被看作一个完全二叉树，并满足堆的性质：

*   **最大堆（Max Heap）：** 任何一个父节点的值都大于或等于其子节点的值。
*   **最小堆（Min Heap）：** 任何一个父节点的值都小于或等于其子节点的值。

堆排序的基本步骤：

1.  **构建最大堆：** 将待排序数组构建成一个最大堆。这意味着最大的元素总是在根节点（数组的第一个元素）。
2.  **抽取最大值并重建堆：**
    *   将堆顶元素（当前最大值）与堆的最后一个元素交换。
    *   将数组的有效长度减一，将刚交换到末尾的元素从堆中“删除”。
    *   对新的堆进行 **堆化 (Heapify)** 操作，恢复堆的性质（将新的堆顶元素下沉到正确位置）。
3.  **重复：** 重复步骤 2，直到堆中只有一个元素。此时，数组已经有序。

### 时间复杂度

*   **平均情况：** `O(n log n)`
*   **最坏情况：** `O(n log n)`
*   **最好情况：** `O(n log n)`

### 空间复杂度

*   **`O(1)`** (原地排序，只需要常数额外的空间)

### Go 语言实现

```go
package main

// HeapSort 对整数切片进行堆排序
func HeapSort(arr []int) {
	n := len(arr)

	// 1. 构建最大堆 (从最后一个非叶子节点开始，向上堆化)
	// 最后一个非叶子节点索引为 n/2 - 1
	for i := n/2 - 1; i >= 0; i-- {
		heapify(arr, n, i)
	}

	// 2. 逐个将最大元素 (堆顶) 放到数组末尾，并重新堆化
	for i := n - 1; i > 0; i-- {
		// 将当前堆顶 (最大元素) 与堆的最后一个元素交换
		arr[0], arr[i] = arr[i], arr[0]

		// 对剩余的 n-1 个元素进行堆化，使其恢复最大堆性质
		// 此时，堆的大小为 i
		heapify(arr, i, 0)
	}
}

// heapify 维护最大堆的性质，确保以 i 为根的子树是最大堆
// n 是堆的有效大小
func heapify(arr []int, n, i int) {
	largest := i       // 假定根节点是最大的
	left := 2*i + 1    // 左子节点
	right := 2*i + 2   // 右子节点

	// 如果左子节点存在且大于当前 largest
	if left < n && arr[left] > arr[largest] {
		largest = left
	}

	// 如果右子节点存在且大于当前 largest
	if right < n && arr[right] > arr[largest] {
		largest = right
	}

	// 如果 largest 不是根节点，说明最大值在子节点中
	if largest != i {
		arr[i], arr[largest] = arr[largest], arr[i] // 交换
		heapify(arr, n, largest)                    // 递归堆化被交换的子树
	}
}

/*
func main() {
	arr := []int{12, 11, 13, 5, 6, 7}
	fmt.Println("原始数组:", arr)
	HeapSort(arr)
	fmt.Println("堆排序后:", arr) // [5 6 7 11 12 13]
}
*/
```

---

## 7. 总结与比较

| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 | 特点 |
| :------- | :------------- | :------------- | :------------- | :--------- | :----- | :--- |
| **快速排序** | `O(n log n)`   | `O(n^2)`       | `O(n log n)`   | `O(log n)` | 不稳定 | 递归、分治、原地排序，平均性能最佳。 |
| **归并排序** | `O(n log n)`   | `O(n log n)`   | `O(n log n)`   | `O(n)`     | 稳定   | 递归、分治，保证 `O(n log n)` 性能，但需要额外空间。 |
| **插入排序** | `O(n^2)`       | `O(n^2)`       | `O(n)`         | `O(1)`     | 稳定   | 对于部分有序的数组效率高，小规模数据表现良好。 |
| **选择排序** | `O(n^2)`       | `O(n^2)`       | `O(n^2)`       | `O(1)`     | 不稳定 | 简单直观，但性能总是 `O(n^2)`，交换次数少于冒泡排序。 |
| **堆排序** | `O(n log n)`   | `O(n log n)`   | `O(n log n)`   | `O(1)`     | 不稳定 | 利用堆结构，原地排序，性能稳定。 |

**稳定性**：指如果数组中有两个相同的元素，排序后它们的相对位置是否保持不变。

在实际开发中，Go 语言标准库中的 `sort` 包提供了高效的通用排序函数（例如 `sort.Ints`, `sort.Slice`），它们通常基于**内省排序 (IntroSort)** 或 **混合排序**（结合了快速排序、堆排序和插入排序的优点），以在各种输入情况下提供最佳性能。了解这些基础算法有助于理解 `sort` 包的工作原理，并能在特定场景下根据需求定制或优化排序逻辑。
