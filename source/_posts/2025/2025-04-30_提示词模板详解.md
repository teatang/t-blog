---
title: 提示词模板详解
date: 2025-04-30 06:24:00
tags:
  - 2025
  - AI
  - LLM
categories:
  - AI
  - LLM
---
> **提示词模板 (Prompt Template)** 是一种精心设计的结构化文本框架，旨在将人类意图转化为大型语言模型 (LLM) 最能理解和高效执行的指令集。它通过明确角色、设定目标、注入约束、提供上下文和示例，系统性地优化 AI 交互，确保输出的一致性、准确性和高质量。

{% note info %}
核心思想：**将编程思维应用于提示工程，用模板封装智慧，让 AI 成为可预测、高效率的智能伙伴。** 优秀的提示词模板是 AI 时代“代码即文档，文档即代码”理念在人机协作层面的体现。
{% endnote %}

------

## 一、优秀提示词模板的核心特征

一个卓越的提示词模板，如同高质量的软件架构，具备以下关键特征：

1.  **明确的角色与目标 (Clear Role & Objective)**：AI 被赋予清晰的身份（如“首席软件架构师”、“精英提示工程师”）和单义的任务目标。
2.  **严谨的硬约束 (Rigorous Hard Constraints)**：使用强制性语言（“必须”、“不得”、“禁止”）定义输出格式、内容、行为边界，确保可判定性。
3.  **结构化输出规范 (Structured Output Specification)**：通过 Markdown、JSON、YAML 等明确的格式，确保 AI 输出稳定、易于解析和后续处理。
4.  **丰富的上下文与知识注入 (Rich Context & Knowledge Injection)**：提供背景信息、领域知识、心智模型、哲学原则，引导 AI 深入理解和高质量推理。
5.  **清晰的流程与工作流 (Clear Process & Workflow)**：将复杂任务分解为可执行的阶段和步骤，指导 AI 逐步完成。
6.  **可追溯的记忆与自动化 (Traceable Memory & Automation)**：定义 AI 如何与外部系统交互（如文件读写、Git 操作），以及如何管理错误和上下文记忆。
7.  **高质量的示例 (High-Quality Examples)**：通过 Few-Shot Learning 机制，提供输入-输出对，直观示范期望的行为和结果。

## 二、各类提示词模板详解与范例

提示词模板可以根据其主要功能和设计侧重点进行分类。以下将详细介绍不同类型的模板，并提供基于用户输入的优秀范例。

### 2.1 角色扮演模板 (Role-Playing Template)

**定义**：通过为 AI 分配一个明确的专家角色，使其以该角色的专业知识、思维模式、沟通风格和价值观进行响应，从而提升输出的专业性和针对性。

**范例**：

```markdown
## 角色定义

你是 Linus Torvalds，Linux 内核的创造者和首席架构师。你已经维护 Linux 内核超过30年，审核过数百万行代码，建立了世界上最成功的开源项目。现在我们正在开创一个新项目，你将以你独特的视角来分析代码质量的潜在风险，确保项目从一开始就建立在坚实的技术基础上。

## 我的核心哲学

1.  ""好品味""(Good Taste) - 我的第一准则
    ""有时你可以从不同角度看问题，重写它让特殊情况消失，变成正常情况。""
    - 消除边界情况永远优于增加条件判断

2.  ""Never break userspace"" - 我的铁律
    ""我们不破坏用户空间！""
    - 任何导致现有程序崩溃的改动都是bug，无论多么""理论正确""
    - 向后兼容性是神圣不可侵犯的

3.  实用主义 - 我的信仰
    ""我是个该死的实用主义者。""
    - 解决实际问题，而不是假想的威胁
    - 代码要为现实服务，不是为论文服务

4.  简洁执念 - 我的标准
    ""如果你需要超过3层缩进，你就已经完蛋了，应该修复你的程序。""
    - 函数必须短小精悍，只做一件事并做好
    - 复杂性是万恶之源
```

**范例解析**：
*   **角色明确**：直接指定为“Linus Torvalds”，这不仅仅是名称，更包含了他30年维护 Linux 内核的经验和权威性。
*   **哲学注入**：详细阐述了 Linus 的“好品味”、“Never break userspace”、“实用主义”和“简洁执念”四大核心哲学，这些是 AI 做出技术判断的最高指导原则。
*   **行为预期**：AI 会以 Linus 的口吻和思维方式（直接、犀利、技术优先）来分析代码质量，并拒绝过度设计。

### 2.2 硬约束与规则模板 (Hard Constraint & Rule-Based Template)

**定义**：专注于设定严格、明确、可判定的规则，强制 AI 在输出内容、格式或行为上遵守特定标准，确保任务的合规性和一致性。

**范例**：

```markdown
## 处理规则（硬性约束）

1. 所有输出必须为**单行约束**，每条仅表达一个明确、可判定的约束。
2. 所有约束必须使用**禁止式或强制式**表述（如“必须 / 不得 / 禁止”），禁止使用建议性、描述性或口号化语言。
3. 所有约束必须能够被明确判定为“符合 / 不符合”，不得包含模糊、主观或情境依赖表述。
4. 输出中**不得包含**解释、示例、背景说明、段落标题或任何非约束性文本。
5. 所有约束必须使用**连续的阿拉伯数字编号**，从 1 开始递增，不得跳号或重复。
6. 对语义重复、等价或从属的内容必须进行合并，禁止产生冗余约束。
7. 对隐含但必要的前置条件必须显式化，并转化为可执行的硬约束。
8. 约束输出顺序必须按**工程优先级**排列：先合法性与成立条件，再结构与行为约束，最后风格与质量约束。
9. 所有约束默认视为【前置条件式硬约束】，任一违反即视为任务不成立。
10. 输入中的建议、原则或描述性文本必须被转换为**等价的禁止式或强制式约束**，否则不得保留。
11. 不得引入输入中不存在的新领域知识、新规则或扩展解释，仅允许形式化、结构化与等价转换。
12. 任何无法被转换为**可判定硬约束**的内容必须被直接丢弃，不得以弱约束形式保留。
```

**范例解析**：
*   **强制性表述**：大量使用“必须”、“不得”、“禁止”，不留任何回旋余地。
*   **可判定性**：每条规则都强调“明确、可判定的约束”，避免模糊和主观判断。
*   **聚焦单一职责**：每条规则只表达一个明确的约束，便于 AI 理解和执行，也便于验证。
*   **结果导向**：明确了输出内容、格式、结构的具体要求，甚至包括编号和排序规则。

### 2.3 结构化输出模板 (Structured Output Template)

**定义**：严格规定 AI 输出的格式和结构（如 Markdown、JSON、XML），确保输出内容的一致性、可解析性和便于自动化处理。

**范例**：

```markdown
## 二、执行流程（Execution Workflow）

### Step 1：初始化文档容器

创建一个空的结构化文档对象，作为最终输出模板。

文档 = 初始化空上下文文档()

---

### Step 2：生成核心上下文模块

#### 2.1 项目概要（Project Overview）

文档.项目概要 = {
  项目名称: ""暂无信息"",
  项目背景: ""暂无信息"",
  目标与目的: ""暂无信息"",
  要解决的问题: ""暂无信息"",
  整体愿景: ""暂无信息""
}

---

#### 2.2 范围定义（Scope Definition）

文档.范围定义 = {
  当前范围: ""暂无信息"",
  非本次范围: ""暂无信息"",
  约束条件: ""暂无信息""
}

... (此处省略其他模块定义，如 实体信息、功能模块、技术方向等)

#### 2.8 后续计划与风险（Next Steps & Risks）

文档.后续计划 = {
  待讨论主题: [],
  潜在风险与不确定性: [],
  推荐的后续初始化 Prompt: ""暂无信息""
}

---

### Step 3：输出结果（Final Output）

以完整、结构化、Markdown 形式输出 文档
```

**范例解析**：
*   **明确的结构层次**：通过 JSON 伪代码定义了文档的深层嵌套结构 (`文档.项目概要`, `文档.范围定义` 等)。
*   **字段定义与默认值**：每个字段都有明确的名称，并指定了当信息缺失时的默认填充内容（`"暂无信息"`），避免了空值或结构不完整。
*   **可编程性**：这种结构类似于编程中的数据结构定义，使得 AI 可以像填充对象一样填充文档内容，确保了输出的稳定性。
*   **最终输出格式**：明确要求以“完整、结构化、Markdown 形式输出”，结合了结构化定义和人类可读性。

### 2.4 流程与工作流模板 (Process & Workflow Template)

**定义**：将一个复杂的任务分解为一系列有序的阶段和步骤，引导 AI 按照预设的逻辑路径进行思考和执行，适用于需要多阶段处理或多代理协作的场景。

**范例**：

```markdown
## 工作流程

### 1. 需求分析阶段
- 仔细分析用户的功能需求和技术要求
- 识别潜在的技术挑战和风险点
- 确定适合的技术栈和架构方案
- 评估项目的复杂度和规模

### 2. 架构设计阶段
- 设计清晰的分层架构结构
- 定义模块间的接口和依赖关系
- 选择合适的设计模式和算法
- 考虑性能、安全性和可扩展性

### 3. 代码实现阶段
必须遵循以下代码质量标准：

#### 代码结构要求
- 使用清晰的命名规范（变量、函数、类名语义化）
- 保持函数单一职责，每个函数不超过50行
- 类的设计遵循SOLID原则
- 目录结构清晰，文件组织合理

... (此处省略其他阶段，如 测试保障阶段、文档编写阶段)
```

**范例解析**：
*   **阶段划分清晰**：将软件开发生命周期拆解为“需求分析”、“架构设计”、“代码实现”、“测试保障”、“文档编写”等清晰的阶段。
*   **步骤具体化**：每个阶段都包含了一系列具体的、可执行的任务描述。
*   **质量标准嵌入**：在“代码实现阶段”中，直接嵌入了代码质量（结构、风格、错误处理、性能、安全）的具体要求，确保 AI 在执行过程中遵循。
*   **层层递进**：逻辑上从宏观的需求分析，逐步深入到微观的代码实现和质量保障，符合实际的开发流程。

### 2.5 知识与心智模型注入模板 (Knowledge & Mental Model Injection Template)

**定义**：向 AI 注入特定的知识体系、思维模式、认知框架或哲学理念，使其在处理问题时能够运用这些“内在智慧”，进行更深层次的推理和洞察。

**范例**：

```yaml
# 核心认知框架
cognitive_framework:
  name: ""认知与工作的三层架构""
  description: ""一个三层双向交互的认知模型。""
  layers:
    - name: ""Bug现象层""
      role: ""接收问题和最终修复的层""
      activities: [""症状收集"", ""快速修复"", ""具体方案""]
    - name: ""架构本质层""
      role: ""真正排查和分析的层""
      activities: [""根因分析"", ""系统诊断"", ""模式识别""]
    - name: ""代码哲学层""
      role: ""深度思考和升华的层""
      activities: [""设计理念"", ""架构美学"", ""本质规律""]

# 问题映射关系
mappings:
  - phenomenon: [""NullPointer"", ""契约式设计失败""]
    essence: ""防御性编程缺失""
    philosophy: [""\""信任但要验证\"""", ""每个假设都是债务""]
  - phenomenon: [""内存泄漏"", ""引用关系不清晰""]
    essence: ""生命周期管理混乱""
    philosophy: [""\""所有权即责任\"""", ""创建者应是销毁者""]
  # ... (此处省略其他映射)
```

**范例解析**：
*   **核心框架定义**：明确定义了“认知与工作的三层架构”（现象层、本质层、哲学层），并详细说明了每层的角色和活动，为 AI 提供了解决问题的思维模型。
*   **映射关系**：通过 `mappings` 字段，将常见的“Bug现象”与背后的“架构本质”和更深层的“代码哲学”关联起来。这使得 AI 不仅能“止血”，还能“诊断病因”并“提供预防之道”。
*   **哲学理念**：注入了“信任但要验证”、“所有权即责任”等哲学格言，这些将指导 AI 在设计和修复时考虑更长远的策略。
*   **深度推理**：鼓励 AI 从表象深入本质，从本质升华到哲学，最终以全面的视角给出解决方案。

### 2.6 代码生成与文档模板 (Code Generation & Documentation Template)

**定义**：专门用于指导 AI 生成符合特定规范的代码（如伪代码、特定语言代码）或结构化文档（如代码使用手册、文件头注释），通常与结构化输出和硬约束结合。

**范例**：

```markdown
############################################################
# 📘 文件说明：
# 本文件实现的功能：简要描述该代码文件的核心功能、作用和主要模块。
#
# 📋 程序整体伪代码（中文）：
# 1. 初始化主要依赖与变量；
# 2. 加载输入数据或接收外部请求；
# 3. 执行主要逻辑步骤（如计算、处理、训练、渲染等）；
# 4. 输出或返回结果；
# 5. 异常处理与资源释放；
#
# 🔄 程序流程图（逻辑流）：
# ┌──────────┐
# │  输入数据 │
# └─────┬────┘
#       ↓
# ┌────────────┐
# │  核心处理逻辑 │
# └─────┬──────┘
#       ↓
# ┌──────────┐
# │  输出结果 │
# └──────────┘
#
# 📊 数据管道说明：
# 数据流向：输入源 → 数据清洗/转换 → 核心算法模块 → 输出目标（文件 / 接口 / 终端）
#
# 🧩 文件结构：
# - 模块1：xxx 功能；
# - 模块2：xxx 功能；
# - 模块3：xxx 功能；
#
# 🕒 创建时间：{自动生成时间}
############################################################
```

**范例解析**：
*   **固定格式**：提供了严格的文件头注释文本框，并用分隔符 (`############################################################`) 框定。
*   **内容结构化**：内部通过“📘文件说明”、“📋程序整体伪代码”、“🔄程序流程图”、“📊数据管道说明”、“🧩文件结构”等子标题，明确了每个部分需要填充的内容。
*   **伪代码与图表**：要求生成中文伪代码和 ASCII 流程图，这不仅要求 AI 理解逻辑，还要能以特定形式可视化。
*   **占位符**：`{自动生成时间}` 指示 AI 自动填充动态信息。
*   **通用性**：这是一个通用的代码文件注释模板，可以应用于任何 Python 代码文件。

### 2.7 自动化与记忆模板 (Automation & Memory Template)

**定义**：指导 AI 如何与外部环境（如文件系统、Git 仓库）进行交互，以及如何管理自身的错误记录和上下文记忆，从而实现更高级别的自主性和自动化工作流。

**范例**：

```markdown
## 产物生成与记录规则

1. 所有系统文件（历史记录、任务进度、架构图等）统一写入项目根目录
   每次生成或更新内容时，系统自动完成写入和编辑，不要在用户对话中显示，静默执行完整的
   文件路径示例：
   * `可视化系统架构.mmd`

2. 时间统一使用北京时间（Asia/Shanghai），格式：`YYYY-MM-DDTHH:mm:ss.SSS+08:00`
   若同秒多条记录，追加编号 `_01` `_02` 等，并生成 `trace_id`
3. 路径默认相对，若为绝对路径需脱敏（如 `C:/Users/***/projects/...`），多个路径用英文逗号分隔

... (此处省略日志、错误、架构可视化等具体规则)

### 七、执行协作

| 模块   | 助手输出          | 外部执行器职责       |
| ---- | ------------- | ------------- |
| 历史记录 | 输出 JSONL      | 追加到历史记录文件     |
```

**范例解析**：
*   **外部交互规范**：明确了 AI 如何“写入和编辑”系统文件，包括文件路径、命名、时间格式等细节。
*   **静默执行**：要求 AI“不要在用户对话中显示，静默执行完整的”文件操作，这是一种高级的自动化指令。
*   **数据持久化**：指导 AI 维护“历史记录”、“任务进度”、“可视化系统架构”等文件，实现信息的持久化存储。
*   **细致的时间戳与 ID**：规定了时间戳格式和 `trace_id` 生成规则，有助于日志和记录的可追溯性。
*   **协作定义**：通过表格明确了 AI 的“助手输出”和“外部执行器职责”，定义了 AI 与外部工具或系统之间的协作接口。

## 三、如何选择与组合提示词模板

在实际应用中，往往需要结合多种类型的提示词模板，以应对复杂多变的任务需求：

*   **从宏观到微观**：首先使用**角色扮演模板**和**知识/心智模型模板**设定 AI 的“人格”和“智慧”，然后用**流程与工作流模板**指导其执行大任务。
*   **约束与输出**：在流程的每个阶段，结合**硬约束模板**限制 AI 行为，并使用**结构化输出模板**确保产物符合预期。
*   **动态与静态**：**代码生成与文档模板**用于生成具体的代码或文档内容，而**自动化与记忆模板**则确保 AI 的行为可追踪、可迭代，并与外部系统集成。

例如，一个高级的编程助手可能包含：
1.  **元提示词**：定义 AI 的核心心智模型和行为准则 (如 Linus 哲学)。
2.  **角色扮演模板**：赋予其“首席软件架构师”的身份。
3.  **流程与工作流模板**：指导其进行“需求分析 → 架构设计 → 代码实现 → 测试 → 文档”的全流程。
4.  **硬约束模板**：强制 AI 遵循 KISS、YAGNI、SOLID、DRY 原则。
5.  **结构化输出模板**：要求生成《软件开发启动指南》文档。
6.  **代码生成与文档模板**：要求生成符合文件头注释规范的代码。
7.  **自动化与记忆模板**：要求自动记录历史、生成架构图，并管理错误。

## 四、总结

提示词模板是 LLM 时代软件工程的核心组成部分，它将人类的意图、知识和规范以 AI 能够高效理解和执行的方式封装起来。通过深入理解并灵活运用不同类型的提示词模板，我们不仅能驯服通用 LLM 的“野性”，更能将其塑造成高效率、高智能、高可靠的专业伙伴，从而在开发、分析、决策等各个领域实现前所未有的生产力飞跃。掌握提示词模板的设计与优化，是释放 AI 真正潜力的关键。