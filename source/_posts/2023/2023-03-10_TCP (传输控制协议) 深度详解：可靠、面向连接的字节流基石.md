---
title: TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石
date: 2023-03-10 06:24:00
tags:
  - 2023
  - TCP
  - 计算机网络
  - 网络协议
categories:
  - 计算机网络
  - 网络协议
---

> **传输控制协议 (TCP - Transmission Control Protocol)** 是互联网协议套件 (TCP/IP) 中最重要的协议之一，位于传输层。它提供了一种**可靠 (Reliable)**、**面向连接 (Connection-Oriented)**、**基于字节流 (Byte Stream-Oriented)** 的传输服务，确保数据能够准确、完整且按序地从一个应用程序传输到另一个应用程序。几乎所有对数据完整性有严格要求的应用，如网页浏览、文件传输、电子邮件等，都构建在 TCP 之上。

{% note info %}
**核心思想**：TCP 致力于在不可靠的 IP 网络之上，构建起一个**端到端的高度可靠的虚拟链路**，通过复杂的机制来保障数据不丢、不重、不乱序，并有效地管理网络资源。
{% endnote %}
------

## 一、TCP 的核心特性与设计哲学

TCP 的设计目标是克服底层 IP 网络的不可靠性，为应用程序提供一个稳定、可靠的数据传输通道。其核心特性包括：

1.  **面向连接 (Connection-Oriented)**：
    *   在数据传输之前，通信双方必须通过**三次握手**建立一个逻辑上的连接。
    *   连接建立后，双方才能开始交换数据。
    *   数据传输完成后，通过**四次挥手**终止连接。
    *   这个过程确保了通信双方都已准备就绪，并维护了连接状态（如序列号、窗口大小等）。

2.  **可靠传输 (Reliable Transmission)**：
    *   **序号 (Sequence Number)**：TCP 给发送的每一个字节都编上序号，接收方根据序号对数据进行重排，确保数据报文按序递交。
    *   **确认应答 (Acknowledgement - ACK)**：接收方成功收到数据后，会发送一个确认报文。发送方在规定时间内未收到确认则会启动**重传计时器**自动重传数据。
    *   **校验和 (Checksum)**：对报文头部和数据进行校验，检测传输过程中是否发生损坏。
    *   **重复丢弃 (Duplicate Discarding)**：接收方会根据序号识别并丢弃重复接收的数据包，保证数据不重复。
    *   **流量控制 (Flow Control)**：通过滑动窗口机制，防止发送方发送速度过快导致接收方缓冲区溢出。
    *   **拥塞控制 (Congestion Control)**：避免发送方发送速度过快导致网络拥塞。

3.  **基于字节流 (Byte Stream-Oriented)**：
    *   TCP 不关心应用程序发送的原始消息边界。对应用程序而言，TCP 传输的是一个没有结构、没有边界的连续字节流。
    *   TCP 收到应用程序的字节流后，会根据自身的策略将其分割成一个个的报文段 (Segment) 进行传输。
    *   接收方应用程序从 TCP 接收到的也是连续的字节流，需要自行处理消息的解析和边界问题。

4.  **全双工通信 (Full-Duplex Communication)**：
    *   TCP 连接建立后，数据可以在两个方向上**同时独立地传输**。
    *   这意味着客户端和服务器可以同时发送和接收数据。

## 二、TCP 报文段结构

TCP 报文段是 TCP 传输的基本单位。它由 TCP 头部和应用程序数据 (Payload) 组成。一个标准的 TCP 头部有 20 字节，如果包含选项字段，则最长可达 60 字节。

```
+-------------------------------------------------------------+
| Source Port (16 bits)     | Destination Port (16 bits)    |
+-------------------------------------------------------------+
| Sequence Number (32 bits)                                   |
+-------------------------------------------------------------+
| Acknowledgment Number (32 bits)                             |
+-------------------------------------------------------------+
| Data Offset | Reserved | Flags (9 bits) | Window Size (16 bits)    |
+-------------+----------+----------------+--------------------------+
| Checksum (16 bits)        | Urgent Pointer (16 bits)                |
+-------------------------------------------------------------+
| Options (variable, 0-320 bits)                              |
+-------------------------------------------------------------+
| Padding (for 32-bit alignment)                              |
+-------------------------------------------------------------+
|                                                             |
|                          Data (Payload)                     |
|                                                             |
+-------------------------------------------------------------+
```

**关键字段解释**：

*   **源端口 (Source Port) / 目的端口 (Destination Port)** (各 16 位)：
    *   用于标识发送和接收数据的应用程序。端口号 0-1023 是熟知端口，1024-49151 是注册端口，49152-65535 是动态/私有端口。
*   **序号 (Sequence Number)** (32 位)：
    *   发送方**本次发送报文段中数据的第一个字节在整个字节流中的序号**。
    *   在建立连接时，双方会各自选择一个初始序列号 (ISN - Initial Sequence Number)。
    *   用于解决网络包乱序和重复问题。
*   **确认号 (Acknowledgment Number)** (32 位)：
    *   发送方**期望接收到的下一个字节的序列号**。
    *   当该字段有效时，`ACK` 标志位必须置 1。
    *   表示发送方已成功接收到确认号之前的所有数据。
*   **数据偏移 (Data Offset)** (4 位)：
    *   表示 TCP 头部长度，**以 4 字节为单位**。
    *   最小值为 5 (20 字节，无选项字段)，最大值为 15 (60 字节，包含选项字段)。
*   **保留位 (Reserved)** (6 位)：
    *   保留给将来使用，目前必须置 0。
*   **标志位 (Flags)** (9 位)：
    *   `URG` (Urgent)：紧急指针有效。
    *   `ACK` (Acknowledgement)：确认号字段有效，所有 TCP 报文段除了 SYN 报文段以外都应该把 ACK 置 1。
    *   `PSH` (Push)：通知接收方应用程序立即将缓冲区中的数据提交给应用程序，而不是等待更多数据。
    *   `RST` (Reset)：重置连接，通常表示连接错误或拒绝连接。
    *   `SYN` (Synchronization)：同步序号，用于建立连接（三次握手）。
    *   `FIN` (Finish)：终止连接，发送方数据已发送完毕（四次挥手）。
    *   `ECN` (Explicit Congestion Notification)：显式拥塞通知。
    *   `CWR` (Congestion Window Reduced)：拥塞窗口减小。
    *   `ECE` (ECN-Echo)：ECN 回显。
*   **窗口大小 (Window Size)** (16 位)：
    *   接收方当前**愿意接收的字节数**（滑动窗口机制），用于流量控制。
    *   值从确认号开始计算。
*   **校验和 (Checksum)** (16 位)：
    *   用于**检测整个 TCP 报文段（头部 + 数据 + 伪头部）在传输过程中是否出现错误**。
    *   伪头部包含源 IP、目的 IP、协议号和 TCP 长度，不实际传输，只用于校验和计算。
*   **紧急指针 (Urgent Pointer)** (16 位)：
    *   当 `URG` 标志置 1 时有效。它是一个偏移量，与序号字段的值相加表示紧急数据的最后一个字节的序号。
*   **选项 (Options)** (变长)：
    *   用于协商一些可选参数，如：
        *   **MSS (Maximum Segment Size)**：最大报文段长度，TCP 连接建立时协商。
        *   **窗口扩大因子 (Window Scale)**：解决窗口大小只有 16 位限制，扩大到 2^30 字节。
        *   **时间戳选项 (Timestamps)**：用于精确计算 RTT (Round Trip Time) 和防止序号回绕。
        *   **SACK (Selective Acknowledgement)**：选择性确认，解决传统 ACK 只能确认最前沿连续数据的问题。
*   **填充 (Padding)**：
    *   使 TCP 头部长度成为 32 位（4 字节）的整数倍。

## 三、TCP 连接管理

TCP 连接的建立与终止是其“面向连接”特性的核心体现。

### 3.1 1. 三次握手 (Three-Way Handshake) - 建立连接

客户端与服务器之间建立 TCP 连接的过程：

{% mermaid %}
sequenceDiagram
    participant C as 客户端 (CLOSED)
    participant S as 服务器 (LISTEN)

    Note over C,S: 连接初始化
    C->>S: 1. SYN=1, Seq=x              (客户端发送 SYN 包，选择初始序列号 x，进入 SYN-SENT 状态)
    activate S
    S->>C: 2. SYN=1, ACK=1, Seq=y, Ack=x+1 (服务器收到 SYN，发送 SYN+ACK 包，选择初始序列号 y，确认 x+1，进入 SYN-RECEIVED 状态)
    deactivate S
    activate C
    C->>S: 3. ACK=1, Ack=y+1            (客户端收到 SYN+ACK，发送 ACK 包，确认 y+1，进入 ESTABLISHED 状态)
    deactivate C
    activate S
    Note over C,S: 数据传输
    S->>S: (服务器收到 ACK，进入 ESTABLISHED 状态)
    deactivate S
{% endmermaid %}

**连接状态变化**：
*   **客户端**：CLOSED -> SYN-SENT -> ESTABLISHED
*   **服务器**：LISTEN -> SYN-RECEIVED -> ESTABLISHED

### 3.2 2. 四次挥手 (Four-Way Handshake) - 终止连接

当通信双方任何一方完成数据传输，希望关闭连接时，都需要发起挥手。由于 TCP 是全双工的，每一方都需要独立关闭自己的发送通道。

{% mermaid %}
sequenceDiagram
    participant C as 客户端 (ESTABLISHED)
    participant S as 服务器 (ESTABLISHED)

    Note over C,S: 客户端希望关闭连接，发送 FIN
    activate C
    C->>S: 1. FIN=1, Seq=u           (客户端进入 FIN_WAIT_1 状态)
    deactivate C
  
    Note over C,S: 服务器确认客户端的 FIN，但仍可发送数据
    activate S
    S->>C: 2. ACK=1, Ack=u+1         (服务器进入 CLOSE_WAIT 状态)
    deactivate S
  
    activate C
    Note left of C: 客户端收到 ACK，进入 FIN_WAIT_2 状态，等待服务器 FIN
    deactivate C
  
    Note over S,C: 服务器发送完所有数据后，发送 FIN
    activate S
    S->>C: 3. FIN=1, ACK=1, Seq=w, Ack=u+1 (服务器进入 LAST_ACK 状态)
    deactivate S
  
    Note over C,S: 客户端确认服务器的 FIN，进入 TIME_WAIT
    activate C
    C->>S: 4. ACK=1, Ack=w+1         (客户端进入 TIME_WAIT 状态，等待2MSL)
    deactivate C
  
    activate S
    Note right of S: 服务器收到 ACK，进入 CLOSED 状态
    S--X S: (服务器线程可能已终结)
    deactivate S
  
    activate C
    Note left of C: 客户端等待 2 MSL 后，也进入 CLOSED 状态
    C--X C: (客户端线程可能已终结)
    deactivate C
{% endmermaid %}

**连接状态变化**：
*   **主动关闭方 (通常是客户端)**：ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED
*   **被动关闭方 (通常是服务器)**：ESTABLISHED -> CLOSE_WAIT -> LAST_ACK -> CLOSED

**TIME_WAIT 状态**：
*   确保最后一个 ACK 报文能够到达服务器。
*   允许网络中可能存在的、延迟的数据包被丢弃，避免它们被新的连接误认为是旧连接的数据。
*   持续**2 MSL (Maximum Segment Lifetime)**，即报文段在网络中的最大生存时间的两倍。

## 四、TCP 的可靠性机制

TCP 实现了多方面的机制来确保数据的可靠传输：

1.  **序号与确认应答 (Sequence Numbers & Acknowledgments)**：
    *   **序号 (Seq)**：每个 TCP 报文段都包含一个序号，表示该报文段中第一个数据字节在整个字节流中的位置。
    *   **确认号 (Ack)**：接收方发送确认报文时，确认号字段表示它**期望收到的下一个字节的序号**。这隐含地确认了到这个序号为止（不包括这个序号）的所有数据都已经收到。
    *   **重传**：发送方启动定时器。如果定时器超时仍未收到确认，则认为数据丢失，会重传该数据。
    *   **累积确认**：通常 ACK 确认的是连续到达的最后一个字节，之前的都默认为已收到。

2.  **流量控制 (Flow Control)**：
    *   **滑动窗口 (Sliding Window)**：接收方在 ACK 报文中会包含其当前的**接收窗口 (Receive Window - RWND)** 大小。这告诉发送方自己还能接收多少字节的数据。
    *   发送方根据这个窗口大小来调整自己可以发送但尚未得到确认的数据量，防止将数据发送到接收方缓冲区已经满的情况，导致数据溢出丢失。
    *   [`Zero Window Probe`](https://www.google.com/search?q=Zero+Window+Probe) 机制：当接收方窗口变为 0 时，发送方会定期发送小的数据包探测接收方窗口是否已恢复。

3.  **拥塞控制 (Congestion Control)**：
    *   与流量控制针对接收方能力不同，拥塞控制是针对整个网络状况。当网络出现拥塞时，TCP 会降低发送速率，避免数据包在路由器中大量积压和丢失，从而加剧拥塞。
    *   主要算法：
        *   **慢启动 (Slow Start)**：连接建立后初始阶段，拥塞窗口 (CWND) 呈指数级增长，直到达到慢启动阈值。
        *   **拥塞避免 (Congestion Avoidance)**：CWND 呈线性增长，直到发生丢包或超时。
        *   **快速重传 (Fast Retransmit)**：当发送方收到三个或更多重复的 ACK (Duplicate ACK) 时，不等重传计时器超时就立即重传可能丢失的数据包，提高响应速度。
        *   **快速恢复 (Fast Recovery)**：与快速重传配合，在重传后不立即回到慢启动阶段，而是更温和地恢复发送速率。
    *   **拥塞窗口 (Congestion Window - CWND)**：发送方实际可发送的数据量是 `min(RWND, CWND)`。

4.  **超时与重传 (Timeout & Retransmission)**：
    *   发送方在发送每个报文段时都启动一个定时器。
    *   **RTT (Round Trip Time)**：TCP 会动态估算数据包往返时间来设置重传超时时间 (RTO - Retransmission Timeout)。
    *   如果 RTO 到期仍未收到确认，则认为数据包丢失并进行重传。

5.  **校验和 (Checksum)**：
    *   每个 TCP 报文段都会计算校验和，用于检测头部和数据部分的位错误。
    *   如果校验和不匹配，接收方会丢弃该报文段，不发送 ACK，等待发送方重传。

## 五、TCP 的优缺点与适用场景

### 5.1 优点：

1.  **可靠性**：通过多种机制保证数据不丢、不重、不乱序，适合对数据完整性有严格要求的应用。
2.  **面向连接**：确保通信双方都处于准备就绪状态，便于管理会话。
3.  **全双工**：数据可以双向同时传输。
4.  **流量控制和拥塞控制**：有效地利用网络资源，防止网络崩溃，并适应网络状况变化。

### 5.2 缺点：

1.  **性能开销大**：
    *   建立和终止连接需要额外的握手和挥手过程。
    *   可靠性机制（确认、重传、序号管理）增加了头部开销和处理复杂性。
    *   流量控制和拥塞控制可能导致传输速率降低。
2.  **实时性差**：
    *   重传机制可能导致数据的延迟，不适合对实时性要求极高的应用。
    *   TCP **队头阻塞 (Head-of-Line Blocking)**：即使后续数据已到达，如果前面的数据包丢失或乱序，也必须等待前面的数据处理完才能递交给应用程序，影响多路复用效率。

### 5.3 适用场景：

*   **文件传输 (FTP, SFTP, BitTorrent)**：文件内容绝不能有缺失或损坏。
*   **网页浏览 (HTTP/HTTPS)**：网页内容、图片、样式等必须完整加载。
*   **电子邮件 (SMTP, POP3, IMAP)**：邮件内容需要准确无误地传输。
*   **数据库连接 (如 MySQL, PostgreSQL)**：数据传输的完整性和一致性是核心。
*   **远程登录 (SSH, Telnet)**：命令和输出需要精确无误。

## 六、高级 TCP 特性与扩展

随着网络技术的发展，TCP 也不断进行改进和扩展，以适应新的需求：

1.  **TCP 窗口扩大选项 (Window Scale Option)**：
    *   在高速网络中，16 位的窗口大小（最大 64KB）不足以满足需求。该选项允许窗口大小扩展到最高 1GB。
2.  **TCP 时间戳选项 (Timestamp Option)**：
    *   用于精确计算 RTT，以及防止序号回绕问题 (PAWS - Protection Against Wrapped Sequence Numbers)。
3.  **SACK (Selective Acknowledgement) 选择性确认**：
    *   传统 TCP 只能通过确认号确认连续收到的数据。如果中间有多个数据包丢失，ACK 只能确认到第一个丢失包之前的连续数据。
    *   SACK 允许接收方告知发送方已经收到了哪些非连续的数据段，从而发送方只需重传确定的丢失数据，减少不必要的重传。
4.  **ECN (Explicit Congestion Notification) 显式拥塞通知**：
    *   路由器可以在不丢弃数据包的情况下，显式地通知发送方网络正在发生拥塞，从而让发送方提前降低发送速率，而不是等到丢包才感知拥塞。
5.  **TCP Fast Open (TFO)**：
    *   在某些条件下，允许在 TCP 连接的第一次握手时就开始发送数据，减少了 HTTP 请求的延迟。
6.  **各种拥塞控制算法**：
    *   除了经典的 Reno/NewReno，还有 BBR (Bottleneck Bandwidth and Round-trip propagation time)、Cubic 等现代拥塞控制算法，旨在更好地利用带宽，减少延迟。

## 七、总结

TCP 作为互联网的“可靠管道”，通过其精妙的连接管理、序号与确认、流量控制和拥塞控制等机制，在不可靠的 IP 数据报服务之上，构建了一个端到端的高度可靠的传输通道。它为绝大多数需要保证数据完整性和有序性的网络应用提供了坚实的基础。理解 TCP 的工作原理不仅是网络工程师和开发者的基本功，也是构建高性能、高可用分布式系统的关键。