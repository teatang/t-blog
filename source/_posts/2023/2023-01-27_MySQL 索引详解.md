---
title: MySQL 索引详解
date: 2023-01-27 06:24:00
tags: 
    - 2023
    - MySQL
    - 中间件
categories:
  - 中间件
  - MySQL
---

> 索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I/O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。

{% note info %}
“好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言
{% endnote %}
------

## 一、什么是索引？

索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用它来快速定位数据。可以将其类比为一本书的目录，通过目录我们可以快速找到感兴趣的章节，而不需要通读整本书。

在数据库中，没有索引的查询需要全表扫描，即逐行检查每条记录，直到找到符合条件的记录。当数据量非常大时，这种操作的效率会非常低下。索引通过创建指向数据物理位置的指针，使得数据库在查询时能够直接跳转到相关记录，从而大大加快查询速度。

## 二、索引的优缺点

### 优点

1.  **显著提高数据检索速度**：这是索引最核心、最主要的优点。
2.  **加快表与表之间的连接速度**：对于 `JOIN` 操作，索引可以加速连接条件的匹配。
3.  **加快分组和排序操作**：`GROUP BY` 和 `ORDER BY` 操作通常通过消除临时表和对文件进行排序来提高效率。
4.  **保证数据的唯一性**：唯一索引（Unique Index）可以强制列的数据不重复。

### 缺点

1.  **占用磁盘空间**：索引本身也是一种数据结构，需要存储在磁盘上。
2.  **降低更新速度**：当对表中的数据进行 `INSERT`、`UPDATE`、`DELETE` 操作时，除了修改数据本身，还需要同时更新索引，这会增加数据库的写操作负担。
3.  **维护成本**：索引越多，维护成本越高，查询优化器选择索引的代价也可能增加。

## 三、索引的分类

MySQL 中索引可以从不同的维度进行分类：

### 1. 按数据结构分类

MySQL 主要支持两种索引结构，`B+Tree` 和 `Hash`。

#### (1) B+Tree 索引 (默认，常用)

*   **特点**:
    *   `B+Tree` 是一种多路平衡查找树，所有数据都存储在叶子节点，并且叶子节点之间通过指针连接，形成一个有序链表。
    *   非叶子节点只存储索引键，不存储数据，减少了树的高度，提高了查询效率。
    *   适合范围查询、模糊查询（前缀匹配）、排序等。
    *   MySQL 的 InnoDB 存储引擎默认使用 `B+Tree` 索引。
*   **适用场景**: 几乎所有类型的查询，包括等值查询、范围查询、排序和分组操作。

#### (2) Hash 索引

*   **特点**:
    *   基于哈希表实现，通过哈希算法将索引列的值映射到哈希表中，存储行指针。
    *   查询速度极快，只需要进行一次哈希计算和一次指针查找。
    *   仅支持精确匹配查询（等值查询），不支持范围查询和排序。
    *   哈希冲突处理会影响性能。
    *   MySQL 的 Memory 存储引擎默认支持，InnoDB 存储引擎不支持显式创建 Hash 索引，但有自适应哈希索引 (Adaptive Hash Index)。
*   **适用场景**: 等值查询，例如 `WHERE id = 123`。

### 2. 按物理存储分类 (InnoDB 存储引擎)

#### (1) 聚集索引 (Clustered Index)

*   **特点**:
    *   **一个表只有一个聚集索引**。
    *   **将数据行存储在索引的叶子节点中**。也就是说，数据和索引是存储在一起的。
    *   InnoDB 存储引擎会自动为主键列创建聚集索引。如果表没有主键，MySQL 会选择第一个非空的唯一索引。如果也没有非空的唯一索引，InnoDB 会隐式地生成一个行 ID 作为聚集索引。
    *   查询效率极高，因为找到索引就意味着找到了数据。
*   **适用场景**: 查询主键或按主键范围查询。

#### (2) 非聚集索引 (Secondary Index / Auxiliary Index)

*   **特点**:
    *   一个表可以有多个非聚集索引。
    *   **索引的叶子节点存储的是主键值**，而不是数据行本身。
    *   当通过非聚集索引查询时，首先在非聚集索引中找到对应的主键值，然后（通过主键值）再去聚集索引中找到完整的数据行。这个过程称为**回表查询**。
*   **适用场景**: 除了主键以外的所有索引，包括普通索引、唯一索引等。
*   **覆盖索引 (Covering Index)**: 当非聚集索引中包含查询所需的所有列时，就不需要回表查询完整数据行，这种索引被称为覆盖索引。覆盖索引能极大地提高查询性能。

### 3. 按逻辑分类

#### (1) 普通索引 (Normal / Non-Unique Index)

*   **特点**: 最基本的索引，没有任何限制，可重复。
*   **创建**: `CREATE INDEX index_name ON table_name (column_name);`

#### (2) 唯一索引 (Unique Index)

*   **特点**: 要求索引列的值必须唯一，但允许有 `NULL` 值（且 `NULL` 值可以有多个）。
*   **创建**: `CREATE UNIQUE INDEX index_name ON table_name (column_name);` 或 `ALTER TABLE table_name ADD UNIQUE (column_name);`

#### (3) 主键索引 (Primary Key Index)

*   **特点**: 一种特殊的唯一索引，一个表只能有一个主键。主键列的值必须唯一，且不能为 `NULL`。
*   **创建**: `ALTER TABLE table_name ADD PRIMARY KEY (column_name);` 或在创建表时定义。
*   在 InnoDB 中，主键索引就是**聚集索引**。

#### (4) 全文索引 (Full-Text Index)

*   **特点**: 用于在文本列（如 `VARCHAR`, `TEXT`）中进行关键词查找，支持自然语言查询。
*   **创建**: `CREATE FULLTEXT INDEX index_name ON table_name (column_name);`
*   **适用场景**: 博客文章内容搜索、商品描述搜索等。

#### (5) 复合索引 (Composite / Combination Index)

*   **特点**: 在多个列上创建的索引。遵循“**最左前缀原则**”。
*   **最左前缀原则**: 如果在一个 `(col1, col2, col3)` 的复合索引上，查询条件可以使用 `col1`、`(col1, col2)`、`(col1, col2, col3)` 来匹配索引，但不能直接使用 `col2` 或 `col3`。
*   **创建**: `CREATE INDEX index_name ON table_name (col1, col2, col3);`

## 四、索引的创建与删除

### 创建索引

1.  **创建表时指定**
    ```sql
    CREATE TABLE users (
        id INT PRIMARY KEY AUTO_INCREMENT,
        username VARCHAR(50) UNIQUE,
        email VARCHAR(100),
        status TINYINT,
        INDEX idx_status (status)  -- 普通索引
    );
    ```

2.  **使用 `CREATE INDEX` 语句**
    ```sql
    CREATE INDEX idx_email ON users (email);
    CREATE UNIQUE INDEX uidx_username ON users (username);
    CREATE INDEX idx_username_email ON users (username, email); -- 复合索引
    ```

3.  **使用 `ALTER TABLE` 语句**
    ```sql
    ALTER TABLE users ADD INDEX idx_email (email);
    ALTER TABLE users ADD UNIQUE INDEX uidx_username (username);
    ALTER TABLE users ADD PRIMARY KEY (id); -- 添加主键（如果是新表）
    ALTER TABLE articles ADD FULLTEXT INDEX ft_content (content);
    ```

### 删除索引

```sql
DROP INDEX index_name ON table_name;
ALTER TABLE table_name DROP INDEX index_name; -- 如果是唯一索引/普通索引
ALTER TABLE table_name DROP PRIMARY KEY;     -- 如果是主键索引
```

## 五、索引优化策略

### 1. 选择合适的列创建索引

*   **WHERE 条件中经常使用的列**：等值查询、范围查询的列。
*   **JOIN 连接条件中使用的列**：`ON` 子句中的列。
*   **ORDER BY 和 GROUP BY 子句中使用的列**：可以避免文件排序。
*   **选择性高的列**：列中值的重复率越低，索引的效果越好。例如，性别这种只有两种值的列，选择性很低，不适合单独建立索引。
*   **不为 NULL 的列**：如果列可以为 `NULL`，索引可能会失效。

### 2. 避免索引失效

*   **不要在 `WHERE` 子句中使用 `OR` 连接条件**：除非 `OR` 连接的所有列都创建了索引。
*   **避免在索引列上进行函数操作**：`WHERE YEAR(create_time) = 2023` 会导致索引失效。
*   **避免在索引列上进行类型转换**：例如，将字符串与数字进行比较。
*   **`LIKE` 查询中，通配符 `%` 不要放在开头**：`WHERE column_name LIKE 'prefix%'` 会使用索引，而 `WHERE column_name LIKE '%suffix'` 或 `'%pattern%'` 不会。
*   **避免使用 `!=` 或 `<>` 操作符**：这些操作符通常会导致全表扫描。
*   **`IS NULL` 和 `IS NOT NULL`**：在某些情况下可能使索引失效，取决于 MySQL 版本和优化器。通常最好让列始终有值。
*   **复合索引的“最左前缀原则”**：查询条件必须从复合索引的最左边列开始使用，才能利用到该索引。

### 3. 优化索引设计

*   **考虑使用覆盖索引**：如果查询只需要索引中的列，就不需要回表，效率极高。
*   **创建短索引/前缀索引**：对于很长的字符串列，可以只索引其前缀。
    ```sql
    CREATE INDEX idx_long_text ON your_table (long_text(20)); -- 只索引前20个字符
    ```
    这样可以节省磁盘空间，提高索引效率，但可能会降低索引的选择性。
*   **利用联合索引**：将经常一起查询的列创建为联合索引，并注意列的顺序（将选择性高的列放在前面）。
*   **考虑 InnoDB 的主键选择**：如果业务 ID 是自增的，设为主键会减少页分裂和数据移动，提升性能。如果业务 ID 是UUID等随机值，考虑使用一个自增代理主键，业务 UUID 则作为唯一索引。
*   **定期维护索引**：对索引进行优化和重建，例如 `OPTIMIZE TABLE`。

### 4. 观察和分析

*   **使用 `EXPLAIN` 分析查询语句**：这是最重要的工具，可以查看 MySQL 如何执行查询，是否使用了索引，使用了哪个索引，以及回表情况等。
    ```sql
    EXPLAIN SELECT * FROM users WHERE username = 'Alice';
    ```
    重点关注 `type`（访问类型）、`key`（实际使用的索引）、`rows`（大概扫描的行数）、`Extra` 等信息。
*   **慢查询日志**：记录执行时间超过阈值的查询语句，方便定位性能瓶颈。
*   **监控数据库性能指标**：如磁盘 I/O、CPU 使用率、缓存命中率等。

## 六、总结

MySQL 索引是数据库性能优化的基石。正确理解和使用不同类型的索引，结合实际业务场景进行设计，并根据 `EXPLAIN` 等工具的分析结果进行迭代优化，才能真正发挥索引的威力。索引并非越多越好，它是一个需要合理权衡的过程，旨在在查询速度和写入速度之间取得最佳平衡。