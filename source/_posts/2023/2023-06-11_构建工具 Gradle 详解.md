---
title: 构建工具 Gradle 详解
date: 2023-06-11 06:24:00
tags:
  - 2023
  - Java
  - 包管理
  - 项目构建
categories:
  - Java
  - 项目构建
---
> **Gradle** 是一个基于 Apache Ant 和 Apache Maven 概念的**项目自动化构建工具**。它使用 Groovy 语言（或 Kotlin DSL）来编写构建脚本，提供了一种声明式和命令式兼备的强大构建方式。Gradle 融合了 Ant 的灵活性和 Maven 的约定式管理及依赖管理能力，旨在为多项目构建提供更强大的支持、更高的性能和更灵活的配置。

{% note info %}
**核心思想**：Gradle 采用 **基于 Groovy/Kotlin DSL 的脚本** 来定义构建逻辑，结合了 **增量编译** 和 **构建缓存** 技术，以实现高性能。它通过 **自定义任务和插件** 提供了极高的灵活性，同时通过 **约定优于配置** 的原则降低了复杂性。
{% endnote %}
------

## 一、为什么需要 Gradle？

尽管 Maven 在 Java 项目构建中取得了巨大成功，但它也存在一些局限性，促使了 Gradle 的出现和流行：

1.  **Maven 的 XML 配置冗长复杂**：
    *   `pom.xml` 文件随着项目规模的增长会变得非常庞大和难以阅读。
    *   XML 配置相比于编程语言，表达能力有限，实现复杂逻辑时会很繁琐。
2.  **Maven 的灵活性不足**：
    *   Maven 严格遵循“约定优于配置”，虽然简化了常见场景，但在需要定制化构建逻辑时，Maven 的插件扩展机制和生命周期钩子相对笨拙。
3.  **Maven 的性能问题**：
    *   Maven 不支持增量编译。每次构建都会编译所有需要编译的源文件，即使只有少量更改。
    *   Maven 的多模块构建在某些情况下可能效率不高。

Gradle 旨在解决这些痛点，提供一个**更强大、更灵活、更高效**的构建工具：

*   **声明式与命令式结合的脚本 (Groovy/Kotlin DSL)**：
    *   使用 Groovy 或 Kotlin 脚本来定义构建逻辑，相比 XML 更简洁、更具表现力。
    *   既能声明性地定义项目结构和依赖，也能命令性地编写复杂的自定义任务。
*   **出色的性能**：
    *   支持**增量编译** (Incremental Builds)：只编译发生变化的文件，显著提升编译速度。
    *   支持**构建缓存** (Build Cache)：可以复用之前构建的输出，甚至是其他机器上的构建结果。
    *   支持**并行执行**：并发执行相互独立的任务。
*   **灵活的多项目构建**：
    *   天生为多项目（多模块）构建设计，管理复杂的多模块结构更加简单高效。
*   **强大的可扩展性**：
    *   一切皆任务 (Task)：可以轻松创建自定义任务和插件。
    *   丰富的插件生态系统。
*   **兼容 Maven 仓库**：
    *   可以无缝使用 Maven 的依赖管理体系和中央仓库。
*   **平滑迁移**：
    *   支持 Maven 的 `pom.xml` 文件作为依赖管理，使从 Maven 迁移到 Gradle 更加容易。

## 二、核心概念

### 2.1 Project 和 Task

Gradle 将所有构建过程抽象为**项目 (Project)** 和**任务 (Task)**。

*   **Project (项目)**：
    *   在 Gradle 中，每一个 `build.gradle` 文件都代表一个 Project。
    *   一个 Project 通常对应一个可独立部署的组件（如 JAR 包、WAR 包、Web 应用），或是一个聚合其他 Project 的父模块。
    *   Project 包含了一系列 Task。
*   **Task (任务)**：
    *   Task 是 Gradle 构建的基本执行单元，例如编译源代码、运行测试、打包 JAR 文件、生成文档等。
    *   每个 Task 都有一个名称，并定义了要执行的特定操作。
    *   Task 可以有依赖关系，Gradle 会根据依赖顺序执行 Task。

**`build.gradle` 示例 (Groovy DSL)**：
```groovy
// 声明一个插件
plugins {
    id 'java' // 应用 Java 插件，自带编译、测试、打包等任务
}

// 定义项目的分组、名称和版本
group 'com.example'
version '1.0-SNAPSHOT'

// 配置 Java 版本
java {
    sourceCompatibility = '17'
    targetCompatibility = '17'
}

// 仓库配置，Gradle 会从这里查找依赖
repositories {
    mavenCentral() // 使用 Maven Central 仓库
}

// 依赖配置
dependencies {
    // 编译时依赖
    implementation 'org.slf4j:slf4j-api:2.0.7'
    // 测试时依赖
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'
}

// 自定义 Task (命令式写法)
task hello {
    doLast { // 定义 Task 要执行的动作
        println 'Hello from Gradle Task!'
    }
}

// 另一个自定义 Task，依赖于 'hello' Task
task goodbye(type: MyCustomTask) {
    message = 'Goodbye from custom task!'
    dependsOn hello // goodbye 任务依赖于 hello 任务
}

class MyCustomTask extends DefaultTask {
    @Input var message = "Default message"

    @TaskAction
    fun run() {
        println(message)
    }
}
```

### 2.2 构建脚本 (Build Scripts)

Gradle 构建脚本使用 Groovy 或 Kotlin DSL (Domain Specific Language) 编写，通常位于 `build.gradle` 文件中。

*   **Groovy DSL (默认)**：基于 Groovy 语言，语法灵活，支持省略括号、点号等。
*   **Kotlin DSL (推荐)**：基于 Kotlin 语言，提供更强大的 IDE 支持 (代码补全、类型安全、重构)，逐渐成为主流。文件名为 `build.gradle.kts`。

**Kotlin DSL 示例**：
```kotlin
// plugins 块使用 `plugins { ... }` 而不是 `apply plugin: '...'`
plugins {
    java
}

group = "com.example"
version = "1.0-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.slf4j:slf4j-api:2.0.7")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.0")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.0")
}

// Kotlin DSL 中定义任务通常使用 `tasks.register`
tasks.register("hello") {
    doLast {
        println("Hello from Gradle Task (Kotlin)!")
    }
}
```

### 2.3 插件 (Plugins)

Gradle 的核心功能也是通过**插件**实现的。插件可以向项目添加新的 Task、配置约定、扩展现有 Task 等。

*   **核心插件**：如 `java` (编译、测试 Java 代码), `application` (支持可执行 JAR), `war` (构建 Web 应用)。
*   **常用插件**：`spring-boot` (Spring Boot 项目), `idea` (生成 IntelliJ IDEA 项目文件), `kotlin` (Kotlin 项目)。

应用插件的方式：
```groovy
// Groovy DSL
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0' // 外部插件需要指定版本
}
// 或者旧式写法
// apply plugin: 'java'
// apply plugin: 'war'
```

```kotlin
// Kotlin DSL
plugins {
    java
    id("org.springframework.boot") version "3.2.0"
}
```

### 2.4 依赖管理 (Dependency Management)

Gradle 的依赖管理功能与 Maven 类似，但更加灵活。它也可以从 Maven 仓库、JCenter 或其他自定义仓库下载依赖。

*   **依赖配置块**：`dependencies { ... }`
*   **依赖类型 (或称为配置)**：
    *   `implementation` (推荐)：用于编译和运行时，不会将 API 暴露给依赖此模块的模块，有助于更快的增量编译。
    *   `api`：用于编译和运行时，会将 API 暴露给依赖此模块的模块，类似于旧的 `compile` 作用。
    *   `compileOnly`：只在编译时需要，包不会被打包进最终构件。
    *   `runtimeOnly`：只在运行时需要，编译时不需要。
    *   `testImplementation`：测试编译和运行时需要。
    *   `testRuntimeOnly`：测试运行时需要。
    *   `annotationProcessor`：用于注解处理器。

**依赖的声明方式**：
```groovy
// Groovy DSL
dependencies {
    implementation 'groupId:artifactId:version'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
}
``````kotlin
// Kotlin DSL (通常字符串需要双引号，且推荐使用 `()`)
dependencies {
    implementation("groupId:artifactId:version")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.10.0")
}
```
**依赖冲突解决**：
Gradle 会自动尝试解决依赖冲突，默认会选择最新版本。你也可以手动进行配置：

```groovy
configurations.all {
    resolutionStrategy {
        // 强制使用某个版本
        force 'com.google.guava:guava:32.0.0-jre'

        // 排除某个传递性依赖
        eachDependency { DependencyResolveDetails details ->
            if (details.requested.group == 'org.slf4j' && details.requested.name == 'slf4j-api') {
                details.useVersion '2.0.7' // 强制 slf4j-api 使用 2.0.7
            }
        }
    }
}
```

## 三、Gradle 构建流程与结构

### 3.1 标准目录结构

类似于 Maven，Gradle 也有其推荐的项目布局：

```
project-root/
├── build.gradle              <- 根项目的构建脚本 (Groovy DSL)
├── settings.gradle           <- 声明项目的子模块
├── gradelew                  <- Gradle Wrapper 脚本 (Linux/macOS)
├── gradlew.bat               <- Gradle Wrapper 脚本 (Windows)
├── .gradle/                  <- Gradle 缓存目录
├── src/
│   ├── main/                 <- 主代码和资源文件
│   │   ├── java/             <- Java 源代码
│   │   ├── resources/        <- 资源文件
│   │   └── webapp/           <- Web 应用根目录 (仅适用于 war 包)
│   └── test/                 <- 测试代码和资源文件
│       ├── java/             <- Java 测试源代码
│       └── resources/        <- 测试资源文件
└── build/                    <- 构建输出目录，由 Gradle 自动生成
```

### 3.2 Gradle Wrapper

Gradle Wrapper (gradlew) 是推荐的 Gradle 使用方式。它允许你在没有预先安装 Gradle 的机器上运行 Gradle 构建。

*   Wrapper 负责下载和安装指定版本的 Gradle。
*   确保所有开发者使用相同版本的 Gradle 进行构建，避免“在我机器上跑得好好的”问题。
*   使用 `gradlew` (Linux/macOS) 或 `gradlew.bat` (Windows) 命令而不是 `gradle` 命令来执行构建。

### 3.3 多项目构建 (Multi-Project Builds)

Gradle 多项目构建的核心是 `settings.gradle` (settings.gradle.kts) 文件。

*   `settings.gradle` 负责定义项目的结构，通过 `include` 方法声明子模块。
*   每个子模块都有自己的 `build.gradle` 文件。
*   根目录的 `build.gradle` 可以定义所有子模块的公共配置。

**`settings.gradle` 示例**：
```groovy
rootProject.name = 'my-multi-project'
include 'app', 'library' // 包含 app 和 library 两个子模块
```
**`build.gradle` (根目录)**：
```groovy
subprojects { // 为所有子模块应用此配置
    apply plugin: 'java'
    repositories {
        mavenCentral()
    }
    dependencies {
        implementation 'org.slf4j:slf4j-api:2.0.7'
    }
}
```

### 3.4 构建生命周期

Gradle 的构建生命周期分为三个阶段：

1.  **初始化 (Initialization)**：
    *   `settings.gradle` 和 `settings.gradle.kts` 文件被执行。
    *   确定哪些 Project 参与构建，并创建对应的 Project 实例。
2.  **配置 (Configuration)**：
    *   所有 Project 的 `build.gradle` 或 `build.gradle.kts` 文件被执行。
    *   解析所有 Task、它们的属性和依赖关系。
    *   这是构建脚本的主要执行阶段。
3.  **执行 (Execution)**：
    *   根据配置阶段解析的 Task 依赖图，Gradle 执行请求的 Task 及其依赖的 Task。
    *   这个阶段会应用增量编译和构建缓存等优化。

## 四、常用 Gradle 命令

*   `./gradlew tasks`：列出所有可用的 Task。
*   `./gradlew build`：执行默认的 `build` Task，通常会编译、测试、打包。
*   `./gradlew clean`：清理构建输出目录。
*   `./gradlew test`：运行所有测试。
*   `./gradlew jar`：打包 JAR 文件。
*   `./gradlew run`：运行应用 (如果应用了 `application` 插件)。
*   `./gradlew --info` / `./gradlew --debug`：显示更详细的日志信息。
*   `./gradlew --stop`：停止 Gradle Daemon (后台进程)。
*   `./gradlew help --task <taskName>`：获取指定 Task 的帮助信息。
*   在多模块项目中，可以在子模块目录执行 `./gradlew <taskName>`，或在根目录执行 `./gradlew :<moduleName>:<taskName>`。

## 五、性能优化

*   **Gradle Daemon**：一个后台进程，启动一次后可以重复使用，避免了每次构建都重新启动 JVM，显著加快后续构建速度。
*   **构建缓存 (Build Cache)**：缓存构建任务的输入和输出。如果任务的输入没有变化，Gradle 可以直接复用缓存中的输出，而无需重新执行任务。可以配置本地缓存和远程缓存。
*   **增量构建 (Incremental Build)**：Gradle 会跟踪输入文件，只有当输入文件发生变化时才重新执行任务。
*   **配置优化**：优化脚本，避免在配置阶段执行耗时操作。

## 六、与 Maven 的比较

| 特性         | Maven                                        | Gradle                                                               |
| :----------- | :------------------------------------------- | :------------------------------------------------------------------- |
| **构建脚本** | XML (pom.xml)                                | Groovy DSL (build.gradle) 或 Kotlin DSL (build.gradle.kts)       |
| **灵活性**   | 约定优于配置，不够灵活，定制化困难。         | 灵活度高，可轻松定制任务和插件，Groovy/Kotlin 编程能力。           |
| **可读性**   | XML 冗长，层级多。                           | DSL 更简洁，更易读，但需要熟悉 Groovy/Kotlin 语法。                |
| **性能**     | 仅支持全量编译，无构建缓存，速度相对较慢。   | 支持增量编译、构建缓存、Gradle Daemon，速度通常更快。              |
| **多模块**   | 基于父 POM 继承，配置较复杂。                  | 基于 `settings.gradle` 和 `subprojects()` 实现，更灵活高效。     |
| **依赖管理** | 良好，基于 XML。                               | 强大，基于 DSL，提供更多控制，如依赖冲突解决策略、排除传递依赖等。 |
| **学习曲线** | 相对平缓，主要学习 XML 结构和生命周期。    |  steeper，需要掌握 Groovy/Kotlin 语法和 Gradle DSL 概念。          |
| **IDE 支持** | 广泛且成熟。                                 | 良好，特别是 Kotlin DSL 带来了更好的 IDE 体验。                     |

## 七、总结

Gradle 是一个现代化、高性能、高度灵活的 Java 项目构建工具。它通过引入 Groovy/Kotlin DSL、增量编译、构建缓存和强大的插件机制，解决了 Maven 在灵活性和性能方面的不足。

对于追求极致构建性能、需要高度定制化构建逻辑、或管理复杂多模块项目的开发者而言，Gradle 是一个非常理想的选择。它在 Android 开发领域已成为事实标准，并在 Java 后端和微服务领域越来越受欢迎。虽然其学习曲线可能比 Maven 略陡峭，但它带来的强大功能和效率提升绝对值得投入学习。