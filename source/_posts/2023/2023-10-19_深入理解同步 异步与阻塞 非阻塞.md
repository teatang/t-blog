---
title: 深入理解同步/异步与阻塞/非阻塞
date: 2023-10-19 06:24:00
tags:
  - 2023
  - 编程技巧
  - 并发编程
  - 异步编程
categories:
  - 编程技巧
---
> 在计算机科学和并发编程中，**同步/异步** (Synchronous/Asynchronous) 和 **阻塞/非阻塞** (Blocking/Non-blocking) 是描述程序执行流程和资源访问方式的两个核心概念。它们经常被一起讨论，但实际上是从不同的角度来描述系统行为的。理解这两对概念对于设计高性能、响应式的系统至关重要。

{% note info %}
核心思想：
*   **同步/异步** 描述的是**消息通知机制**：调用者何时收到被调用者的结果。
*   **阻塞/非阻塞** 描述的是**调用者等待结果时的状态**：调用者是否可以继续执行其他任务。
{% endnote %}

------

## 一、同步 (Synchronous) 与 异步 (Asynchronous)

**同步** (Synchronous) 和 **异步** (Asynchronous) 关注的是**一个任务的调用者 (Caller) 何时才能获得被调用者 (Callee) 的执行结果或通知。**

### 1.1 同步 (Synchronous)

当一个任务是同步的时候，**调用者在调用被调用者后，必须等待被调用者完成其全部工作并返回结果后，才能继续执行调用者自己的后续操作。**

**特点：**
*   **顺序执行**：任务按照代码编写的顺序逐一执行。
*   **简单直观**：编程模型简单，逻辑易于理解。
*   **效率低下**：当被调用者进行耗时操作（如 I/O、网络请求）时，调用者会被“挂起”，无法利用这段时间做其他事情，导致整体效率不高。

**生活类比：**
你打电话给客服咨询问题。客服说“请稍等，我查一下”，然后你拿着电话一直在听等待，直到客服查完告诉你结果，你才能做其他事情。

**编程示例 (Python)：**

```python
import time

def sync_task(name):
    print(f"Task {name}: 开始执行...")
    time.sleep(2) # 模拟耗时操作 (例如，文件读写、网络请求)
    print(f"Task {name}: 执行完毕。")
    return f"结果来自 {name}"

print("主程序：调用 Task A")
result_a = sync_task("A")
print(f"主程序：收到结果：{result_a}")

print("主程序：调用 Task B")
result_b = sync_task("B")
print(f"主程序：收到结果：{result_b}")

print("主程序：所有任务完成")
# Output:
# 主程序：调用 Task A
# Task A: 开始执行...
# Task A: 执行完毕。
# 主程序：收到结果：结果来自 A
# 主程序：调用 Task B
# Task B: 开始执行...
# Task B: 执行完毕。
# 主程序：收到结果：结果来自 B
# 主程序：所有任务完成
# 总耗时约 4 秒
```

### 1.2 异步 (Asynchronous)

当一个任务是异步的时候，**调用者在调用被调用者后，不会立即等待被调用者返回结果。它会继续执行自己的后续操作，而被调用者在后台进行操作。当被调用者完成工作后，会通过某种机制（如回调函数、事件、Promise/Future）通知调用者并传递结果。**

**特点：**
*   **并发执行**：调用者可以在等待被调用者执行的同时，执行其他任务，提高了资源利用率和系统响应性。
*   **编程模型复杂**：需要处理回调、事件循环等机制，逻辑可能不如同步直观。
*   **高效率**：特别适合 I/O 密集型操作，能够显著提升系统吞吐量。

**生活类比：**
你给客服留言咨询问题。客服说“我们收到留言了，稍后会回复”，然后你挂了电话继续做自己的事情。客服查完后，通过短信或邮件通知你结果。

**编程示例 (Python - 使用 `asyncio`)：**

```python
import asyncio
import time

async def async_task(name):
    print(f"Async Task {name}: 开始执行...")
    await asyncio.sleep(2) # 模拟耗时操作，非阻塞等待
    print(f"Async Task {name}: 执行完毕。")
    return f"结果来自 {name}"

async def main():
    print("主程序：调用 Async Task A 和 B")
    # concurrently_tasks = [async_task("A"), async_task("B")]
    # results = await asyncio.gather(*concurrently_tasks) # 同时运行 A 和 B

    task_a = asyncio.create_task(async_task("A")) # 创建任务，立即返回
    task_b = asyncio.create_task(async_task("B")) # 创建任务，立即返回

    print("主程序：我还在忙其他事情...") # 在等待的同时可以执行其他操作

    result_a = await task_a # 等待 Task A 完成
    result_b = await task_b # 等待 Task B 完成

    print(f"主程序：收到结果：{result_a}")
    print(f"主程序：收到结果：{result_b}")
    print("主程序：所有任务完成")

if __name__ == "__main__":
    asyncio.run(main())
# Output (大致顺序，实际可能因调度而异):
# 主程序：调用 Async Task A 和 B
# Async Task A: 开始执行...
# Async Task B: 开始执行...
# 主程序：我还在忙其他事情...
# Async Task A: 执行完毕。
# Async Task B: 执行完毕。
# 主程序：收到结果：结果来自 A
# 主程序：收到结果：结果来自 B
# 主程序：所有任务完成
# 总耗时约 2 秒 (因为 A 和 B 并发执行)
```

## 二、阻塞 (Blocking) 与 非阻塞 (Non-blocking)

**阻塞** (Blocking) 和 **非阻塞** (Non-blocking) 关注的是**调用者 (Caller) 在调用被调用者 (Callee) 时，其线程是否会被暂停 (挂起)，直到被调用者处理完成并返回。**

### 2.1 阻塞 (Blocking)

当一个操作是阻塞的时候，**调用者在发出调用后，其执行线程会暂停，等待被调用者返回结果，期间不能做任何其他事情。**

**特点：**
*   **线程挂起**：调用线程在操作完成前无法继续执行。
*   **资源浪费**：如果线程被长时间阻塞，它就无法服务其他请求，特别是在单线程或线程池大小有限的系统中，可能导致性能瓶颈。
*   **编程模型简单**：与同步类似，因为线程被挂起，所以可以像编写顺序代码一样处理。

**生活类比：**
你把水壶放到炉子上烧水。你不能离开炉子，必须一直盯着水壶，直到水烧开，你才能拿起水壶做其他事情。

**编程示例 (Python - 文件 I/O)：**

```python
import os
import time

def read_blocking_file(filename):
    print(f"Blocking Read: 线程开始读取文件 '{filename}'...")
    with open(filename, 'r') as f:
        # read() 操作是阻塞的，直到所有内容读取完毕才能继续
        content = f.read()
    print(f"Blocking Read: 线程读取文件 '{filename}' 完毕。")
    return content

# 写入一个大文件用于测试
with open("test_blocking.txt", "w") as f:
    f.write("A" * 1024 * 1024 * 10) # 10MB 文件

print("主线程：开始执行阻塞文件读取。")
start_time = time.time()
file_content = read_blocking_file("test_blocking.txt")
end_time = time.time()
print(f"主线程：读取内容长度 {len(file_content)}。")
print(f"主线程：阻塞文件读取耗时 {end_time - start_time:.2f} 秒。")

print("主线程：我只能在读取完毕后才能做其他事情。")
# Output (大致):
# 主线程：开始执行阻塞文件读取。
# Blocking Read: 线程开始读取文件 'test_blocking.txt'...
# Blocking Read: 线程读取文件 'test_blocking.txt' 完毕。
# 主线程：读取内容长度 10485760。
# 主线程：阻塞文件读取耗时 0.0X 秒。(取决于硬盘速度)
# 主线程：我只能在读取完毕后才能做其他事情。
```

### 2.2 非阻塞 (Non-blocking)

当一个操作是非阻塞的时候，**调用者在发出调用后，会立即得到一个响应（通常表示操作是否已开始或当前状态），而不会等待被调用者完成其全部工作。调用者可以继续执行其他任务，并需要在将来某个时刻主动查询或通过事件机制获取操作的最终结果。**

**特点：**
*   **线程不挂起**：调用线程可以立即返回并执行其他任务。
*   **高效率**：提高了线程的利用率，特别适合处理大量并发连接的 I/O 操作。
*   **编程模型复杂**：需要额外的机制来处理结果（如轮询、事件通知）。

**生活类比：**
你把水壶放到炉子上烧水。你设定了一个定时器或在水壶上装了一个哨子。放下水壶后，你可以去做其他事情，当定时器响或哨子响时（事件通知），你才回来处理水壶。

**编程示例 (Python - 网络 I/O，概念性示例，需要 `selectors` 或 `asyncio` 等库实际实现)：**

```python
# ! 这个例子是概念性的，Python 的内置文件I/O通常是阻塞的。
# ! 真正做非阻塞I/O需要使用像 asyncio 模块或底层系统调用（如 select/poll/epoll/kqueue）。

# import os
# import time
#
# # 假设有一个非阻塞的文件读取API (实际Python标准库没有直接的非阻塞文件读取)
# # 真正的非阻塞文件IO在Python中通常通过 event loop 和 Futures 实现
#
# def non_blocking_read_start(filename):
#     print(f"Non-blocking Read: 开始非阻塞读取文件 '{filename}'...")
#     # 实际这里会触发一个底层非阻塞I/O操作，并立即返回一个"句柄"或"Future"
#     # 应用程序可以继续做其他事情
#     print(f"Non-blocking Read: 立即返回，应用程序可继续执行。")
#     return f"file_handle_{filename}" # 返回一个占位符句柄
#
# def check_non_blocking_read_status(handle):
#     # 模拟检查状态，这里假设每隔一段时间会完成
#     if hasattr(check_non_blocking_read_status, 'progress'):
#         check_non_blocking_read_status.progress += 1
#     else:
#         check_non_blocking_read_status.progress = 0
#
#     if check_non_blocking_read_status.progress < 3: # 模拟多次检查后才会完成
#         return "IN_PROGRESS", None
#     else:
#         return "COMPLETED", "文件内容假装已读取"
#
#
# print("主线程：开始执行非阻塞文件读取。")
# start_time = time.time()
# file_handle = non_blocking_read_start("large_file.txt")
#
# print("主线程：我可以在等待文件读取完成的同时，做其他事情...")
# # 模拟在此期间做一些其他工作
# for i in range(5):
#     print(f"主线程：做其他工作 {i}...")
#     time.sleep(0.5)
#
# # 轮询检查操作状态，或者通过事件机制
# status = "IN_PROGRESS"
# content = None
# while status == "IN_PROGRESS":
#     status, content = check_non_blocking_read_status(file_handle)
#     if status == "IN_PROGRESS":
#         print("主线程：文件仍在读取中，继续等待或做其他事。")
#         time.sleep(0.5)
#
# end_time = time.time()
# print(f"主线程：非阻塞文件读取最终完成。内容：{content[:20]}...")
# print(f"主线程：总耗时 {end_time - start_time:.2f} 秒。")
```

## 三、关系解读与组合

同步/异步和阻塞/非阻塞是正交的概念，它们可以有四种组合：

### 3.1 同步阻塞 (Synchronous Blocking)

这是最常见、最简单的编程模型。调用者在调用后会等待被调用者完成并返回结果，期间线程被挂起。

*   **场景**：大部分传统的单线程程序中的函数调用，如简单的文件读写、数据库操作（不使用异步驱动时）。
*   **特点**：任务串行，编程简单，但效率低。

**示例：**
{% mermaid %}
sequenceDiagram
    participant Caller
    participant Callee

    Caller->>Callee: 调用一个同步阻塞函数
    Note over Callee: 执行耗时操作... (调用线程在此处被挂起，无法执行其他任务)
    Callee-->>Caller: 返回结果 (完成)
    Caller->>Caller: 继续执行后续操作
{% endmermaid %}

### 3.2 同步非阻塞 (Synchronous Non-blocking)

调用者发出调用后，立即返回，但调用者需要**主动轮询** (Polling) 被调用者的状态，直到操作完成。在每次轮询间隔中，调用者可以做其他事情。

*   **场景**：游戏循环中的输入检查、某些嵌入式系统的硬件状态查询。这种模式相对较少直接使用，更多是作为底层异步I/O的实现机制。
*   **特点**：调用者线程不会被完全挂起，但需要不断轮询状态，可能导致 CPU 浪费。

**示例：**
{% mermaid %}
sequenceDiagram
    participant Caller
    participant Callee

    Caller->>Callee: 调用一个同步非阻塞函数 (立即返回)
    Callee-->>Caller: 操作未完成，返回 "进行中" 状态/句柄
    loop 轮询检查
        Caller->>Caller: 执行其他操作...
        Caller->>Callee: 检查状态?
        Callee-->>Caller: 操作未完成，返回 "进行中"
    end
    Caller->>Callee: 检查状态?
    Callee-->>Caller: 操作已完成，返回结果
    Caller->>Caller: 继续执行后续操作
{% endmermaid %}

### 3.3 异步阻塞 (Asynchronous Blocking)

这个组合在直觉上听起来有些矛盾，但在某些上下文是有意义的：**调用者发起了对一个异步操作的调用，但自身却通过某种机制（如 `Future.get()`、`await` 在没有 `async` 标记的函数中）阻塞等待这个异步操作的结果。** 尽管被调用的操作本身在后台是非阻塞执行的，但调用者选择阻塞等待其完成。

*   **场景**：在非 `async` 函数中，调用一个返回 `Future` 的函数，并立即调用 `Future.result()` 或 `Future.wait()` 等方法。这相当于将一个异步操作“同步化”了。
*   **特点**：虽然底层操作是异步执行的，但调用者的线程依然会被挂起，直到结果可用。这通常是为了简化某个局部代码的逻辑，但牺牲了整体效率。

**示例：**
{% mermaid %}
sequenceDiagram
    participant Caller
    participant ServiceThread # 模拟执行异步操作的线程/协程
    participant CalleeTask # 被调用的异步任务

    Caller->>ServiceThread: 启动异步任务 (并阻塞等待结果)
    Note over ServiceThread: 线程被Caller阻塞
    ServiceThread->>CalleeTask: 派发异步任务(非阻塞)
    Note over CalleeTask: 在后台执行耗时操作...
    CalleeTask-->>ServiceThread: 任务完成，返回结果
    Note over ServiceThread: 解除阻塞
    ServiceThread-->>Caller: 返回最终结果
    Caller->>Caller: 继续执行后续操作
{% endmermaid %}

### 3.4 异步非阻塞 (Asynchronous Non-blocking)

这是最高效、最复杂的组合。调用者在调用后立即返回，不等待操作完成，并且通过**事件通知 (Event Notification)** 或**回调函数**来获取操作结果。调用者线程在等待期间可以自由地执行其他任务。

*   **场景**：Node.js 中的 I/O 操作、Python 的 `asyncio`、Java 的 NIO、Go 的 Goroutines + Channels。适用于高并发、I/O 密集型应用，如 Web 服务器、聊天室等。
*   **特点**：极大提升系统吞吐量和响应性，但编程模型复杂，需要管理事件循环、回调或协程。

**示例：**
{% mermaid %}
sequenceDiagram
    participant Caller
    participant CalleeSystem # 或事件循环
    participant CalleeTask # 被调用的异步任务

    Caller->>CalleeSystem: 派发一个异步非阻塞任务 (立即返回)
    CalleeSystem-->>Caller: 返回任务句柄/Future
    Caller->>Caller: 继续执行其他操作... (线程不被挂起)
    CalleeSystem->>CalleeTask: 启动后台任务
    Note over CalleeTask: 在后台执行耗时操作...
    CalleeTask-->>CalleeSystem: 任务完成，通知 CalleSystem
    CalleeSystem->>Caller: 事件通知/回调函数传递结果
    Caller->>Caller: 处理收到的结果
{% endmermaid %}

## 四、总结与辨析

| 特性维度 | 同步 (Synchronous)                               | 异步 (Asynchronous)                                      |
| :------- | :----------------------------------------------- | :------------------------------------------------------- |
| **关注点** | 结果通知时机：调用方等待被调方返回结果           | 结果通知时机：调用方不等待被调方，通过回调/事件接收结果  |
| **控制力** | 调用方完全控制被调方何时返回                     | 被调方完成任务后，通过外部机制通知调用方                 |
| **编程模型** | 简单、顺序                                       | 复杂、需要回调/Promises/Futures/协程                     |

| 特性维度 | 阻塞 (Blocking)                                  | 非阻塞 (Non-blocking)                                    |
| :------- | :----------------------------------------------- | :------------------------------------------------------- |
| **关注点** | 线程状态：调用方线程是否暂停                     | 线程状态：调用方线程是否暂停                             |
| **性能**   | 线程利用率低，等待耗时操作时浪费资源             | 线程利用率高，可同时执行其他任务                         |
| **实现**   | 通常由操作系统或运行时环境自动挂起和恢复线程     | 需要底层 I/O 模型 （如 select/poll/epoll）和事件循环支持 |

**关键区分：**

*   **同步/异步是高级概念，描述的是通信机制**：你期望的是即时反馈 (同步) 还是稍后通知 (异步)。
*   **阻塞/非阻塞是底层概念，描述的是线程状态**：你的线程是否被强制暂停等待 (阻塞) 还是可以继续运行 (非阻塞)。

### 哪个最优？

没有绝对的“最优”模式，选择取决于具体的应用场景：

*   **编程简单性优先，且任务耗时短或 CPU 密集型**：同步阻塞模型可能就足够了。
*   **I/O 密集型，需要高并发和响应性**：异步非阻塞模型是最佳选择，但会增加编程复杂性。
*   **需要利用多核 CPU 资源**：并行处理（多线程/多进程）可能更合适，它与同步/异步、阻塞/非阻塞的概念可以结合使用。

理解这些概念是构建高效、健壮的软件系统的第一步。