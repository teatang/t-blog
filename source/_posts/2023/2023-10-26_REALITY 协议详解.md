---
title: REALITY 协议详解
date: 2023-10-26 06:24:00
tags:
  - 2023
  - REALITY
  - 代理协议
  - 计算机网络
categories:
  - 计算机网络
  - 代理协议
---

> **REALITY** 是一个由 Xray (Vless) 项目引入的**无证书 (Certificate-less) 伪装协议**，旨在彻底解决传统 TLS 代理（如 Trojan、VLESS+TLS）在抗审查领域面临的**证书指纹、SNI 阻断以及服务器真实 IP 暴露**等问题。REALITY 的核心思想是**劫持目标网站的入站 (Inbound) TLS 流量**，将代理流量伪装成合法网站的真实流量，从而达到极致的隐蔽性。

{% note info %}
**核心思想**：客户端在连接时模仿知名网站的 TLS 握手，使审查设备误认为是访问合法网站。服务器通过劫持（重定向）这个“合法”连接的入站流量，识别并处理来自客户端的代理请求，而无需自己拥有或生成 TLS 证书，避免了证书指纹的暴露。
{% endnote %}

## 一、为什么需要 REALITY？

传统的基于 TLS 的代理协议（如 Trojan、VLESS+TLS）通过将代理流量封装在 TLS 协议中，并使用有效（通常是 Let's Encrypt 签发）的证书来伪装成 HTTPS 流量。这种方法虽然有效，但存在一些固有的弱点，随着审查技术的升级，这些弱点逐渐暴露：

1.  **TLS 证书指纹**：由证书颁发机构 (CA)（如 Let's Encrypt）签发的证书具有可以被识别的指纹。审查设备可以通过分析这些证书的特征来识别并阻断代理流量。
2.  **SNI (Server Name Indication) 阻断**：即使使用伪装域名，如果该域名被列入黑名单，或审查设备对非主流域名的 TLS 流量进行更严格的审查，也可能导致连接被阻断。
3.  **服务器 IP 暴露和端口探测**：服务器的 IP 地址是固定的。一旦某个 IP 上的 TLS 服务被识别为代理，整个 IP 可能会被墙。主动探测（如扫描 443 端口）也可能暴露代理服务器。
4.  **证书申请维护成本**：需要为伪装域名申请和维护 TLS 证书，增加了部署和管理的复杂性。

REALITY 旨在解决上述所有问题，通过一种更加激进和巧妙的伪装策略，提供**前所未有的隐蔽性和抗审查能力**。

## 二、REALITY 的核心技术特性

REALITY 协议的实现高度依赖于 **Xray Core**，并结合了多种现代网络技术和密码学原理：

### 2.1 无证书设计与流量劫持

1.  **服务器无证书**：REALITY 的最大特点是代理服务器**无需拥有或使用任何 TLS 证书**。这彻底避免了证书指纹的问题。
2.  **目标网站 (Website) 重定向**：
    *   **选择目标网站**：用户在配置 REALITY 时，需要指定一个或多个**真实存在的、流量巨大、具有 CDN 服务的著名网站**作为其伪装目标 (target host / destination)。例如：`www.microsoft.com`、`www.apple.com`、Youtube CDN 等。
    *   **客户端模仿**：客户端在连接到代理服务器时，并非直接与代理服务器建立 TLS 连接，而是**模仿与目标网站建立 TLS 连接**。这意味着客户端发送的 Client Hello 报文将包含目标网站的 SNI、ALPN 等信息。
    *   **入站流量劫持 (Inbound Connection Redirect)**：REALITY 的服务器端会在**本地**监听一个**真实的 TLS 端口 (通常是 443)**。当收到一个入站连接时，它会判断这个连接是否是来自 REALITY 客户端。
        *   如果是 REALITY 客户端，服务器会**直接处理**它，将其作为代理流量。
        *   如果不是 REALITY 客户端（即真实的、发往目标网站的流量被重定向到了你的服务器），服务器会将这个连接**重定向**到真正的目标网站。例如，如果你的代理服务器 IP 是 `A.B.C.D`，目标网站是 `www.microsoft.com`，当有人误将 `www.microsoft.com` 的流量发送到 `A.B.C.D` 时，你的服务器会将这个流量转发给真实的 `www.microsoft.com` 服务器，**看起来你的服务器只是一个 CDN 节点或中间代理**。
    *   **通过这种设计，REALITY 服务器可以伪装成目标网站的一个 CDN 边缘节点，甚至是意外的中间代理跳板，从而极大地提高了隐蔽性。**

### 2.2 强化抗指纹与隐蔽性

1.  **TLS 指纹模仿 (Client Hello Faking / Spoofing)**：
    *   客户端会精确地模仿主流浏览器 (如 Chrome、Firefox、Safari) 的 Client Hello 报文，包括 TLS 版本、加密套件 (Cipher Suites)、扩展 (Extensions) 等，使得其 TLS 握手特征与真实浏览器完全一致。这有效对抗了 TLS 客户端指纹 (如 JA3/JA4) 检测。
    *   **SNI 伪装**：客户端始终使用目标网站的 SNI 连接代理服务器。

2.  **随机化 Session ID**：
    *   REALITY 会随机化 TLS Session ID，防止通过长时间的会话 ID 来识别代理连接。

3.  **流量模式混淆**：
    *   通过对数据包长度、时间间隔等进行随机化和混淆，使得代理流量在行为模式上也难以被识别。

### 2.3 认证机制与安全性

1.  **VLESS 协议承载**：REALITY 通常作为 VLESS 协议的传输层。VLESS 本身是无协议头的，其认证信息（通常是 UUID）在 TLS 握手完成后的数据流中传输。
2.  **Short ID (sid)**：REALITY 引入了 Short ID (sid) 机制。客户端在发起连接时，会在 TLS 客户端Hello中带上一个预定义的 Short ID（通过 Client Hello 的某个扩展字段或其他巧妙方式）。服务器通过比对这个 Short ID 来识别合法的 REALITY 客户端连接，确保只有知道正确 Short ID 的客户端才能连接。
    *   这个 Short ID 的长度通常很短 (例如 4-8 字节)，很难被暴力破解。
    *   **重要性**：Short ID 是服务器判断是否为 REALITY 客户端的核心依据，也是避免将真实流量误判为代理流量的关键。没有 Short ID，所有发往目标网站的入站流量都可能被认为是代理流量，导致服务混乱。

## 三、REALITY 的工作原理 (图示)

{% mermaid %}
sequenceDiagram
    participant App as 用户应用程序
    participant Client as REALITY 客户端
    participant ProxyServer as REALITY 代理服务器 (Your IP: A)
    participant TargetWebsite as 目标网站 (Real IP: B)
    participant GFW as 防火墙/审查设备

    App->>Client: 1. 代理应用流量 (SOCKS5/HTTP)
    Client->>GFW: 2. 发送 Client Hello (模仿浏览器访问 TargetWebsite, SNI: target.com, 带 Short ID)
    GFW->>ProxyServer: 3. 转发流量 (误认为是 TargetWebsite 的 CDN/边缘节点)

    ProxyServer->>ProxyServer: 4. 检查 Client Hello 是否包含有效 Short ID
    alt Short ID 匹配 (合法 REALITY 客户端)
      ProxyServer-->>Client: 5. 进行 VLESS + TLS 握手，开始代理
      Client->>ProxyServer: 6. 发送加密流量 (VLESS over REALITY)
      ProxyServer-->>Client: 6'. 接收加密流量 (VLESS over REALITY)
      ProxyServer->>TargetWebsite: 7. 转发真实目标流量
      TargetWebsite-->>ProxyServer: 8. 返回目标响应
      ProxyServer-->>Client: 9. 返回给客户端
    else Short ID 不匹配 (非 REALITY 客户端，或发往 TargetWebsite 的流量被重定向)
      ProxyServer->>TargetWebsite: 5. 将该入站连接重定向/转发给真实的 TargetWebsite
      TargetWebsite-->>ProxyServer: 6. 返回 TargetWebsite 响应
      ProxyServer->>GFW: 7. 将 TargetWebsite 响应返回 (作为中转)
      GFW-->>Client: 8. Client 收到 TargetWebsite 响应 (GFW 认为这直接来自 TargetWebsite)
    end
{% endmermaid %}


**补充说明：**

*   客户端不需要关心 REALITY 服务器的 IP 到底是谁，它只知道要连接到 `target.com`，并且在 TLS 握手中带上特定的 Short ID。
*   审查设备看到的是一个完美模仿 `target.com` 的 TLS 握手，无法判断这是否是代理流量。
*   REALITY 服务器的 IP 是暴露的，但由于其行为和真实的 CDN/边缘节点一致（对于非 REALITY 流量，它会转发请求到目标网站），审查设备很难判断其真实用途。

## 四、REALITY 的优缺点

### 4.1 优点

*   **极致抗审查**：解决了证书指纹、SNI 阻断等问题，通过伪装成大流量合法网站，极大提高了隐蔽性。
*   **无需证书**：部署和维护成本降低，无需申请和续期 Let's Encrypt 证书。
*   **服务器 IP 抗探测**：由于服务器会转发所有发往目标网站的流量，即使被探测到开放 443 端口，也可能被误认为是目标网站的 CDN 节点或中间代理点，降低了被封锁的风险。
*   **高性能**：作为 VLESS 的传输层，继承了 VLESS 轻量、高效的特点。
*   **UDP 转发**：通过 VLESS 底层支持 UDP 转发。

### 4.2 缺点

*   **配置复杂度**：相比其他协议，REALITY 的配置相对复杂，需要对 TLS 和网络协议有一定了解。
*   **依赖知名网站**：需要选择一个**网络稳定、流量巨大、最好有 CDN 服务的真实网站**作为伪装目标。一旦该网站出现故障或被封锁，可能会影响代理稳定性。
*   **资源消耗**：服务器需要处理所有发往目标网站的重定向流量 (即使不是代理流量)，可能会增加一定的资源消耗，尤其是在高流量环境下。
*   **Client Hello 指纹更新**：依赖于社区对主流浏览器 Client Hello 指纹的持续更新，以保持最佳的伪装效果。
*   **Xray 专属**：目前 REALITY 是 Xray Core 的独有功能，客户端支持度可能不如通用协议。

## 五、REALITY 的部署与使用（概念性）

REALITY 的部署主要集中在 Xray Core 上。

1.  **服务器端 (`Xray-core`)**：
    *   配置 `inbound` 使用 `VLESS` 协议，`streamSettings` 的 `security` 设置为 `reality`。
    *   提供`dest` (目标网站的地址，如 `www.google.com:443`)。
    *   提供 `xver` (TLS 的 Client Hello 版本)。
    *   配置用于认证的 `uuid`。
    *   生成`shortIds` (通常是随机生成多个，客户端随机选择一个使用)。
    *   服务器会监听一个端口 (通常是 443)，并处理入站流量。
2.  **客户端 (`Xray-core` 或集成客户端)**：
    *   配置 `outbound` 使用 `VLESS` 协议，`streamSettings` 的 `security` 设置为 `reality`。
    *   提供 `dest` (REALITY 代理服务器的 IP 地址和端口)。
    *   提供 `serverNames` (伪装的目标网站的域名，必须与服务器配置的 `dest` 匹配)。
    *   提供 `fingerprint` (要模仿的浏览器 Client Hello 指纹，如 `chrome`)。
    *   提供 `shortId` (从服务器配置中获取的一个 `shortId`)。
    *   提供用于认证的 `uuid`。

**关键配置项 (示例)**：

```json
// 服务器端 (inbound VLESS with REALITY)
{
  "inbounds": [
    {
      "port": 443,
      "protocol": "vless",
      "settings": {
        "clients": [
          {
            "id": "your-uuid-here"
          }
        ],
        "decryption": "none"
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "show": false, // 或者 true, 建议 false
          "dest": "www.google.com:443", // 伪装的目标网站
          "xver": 0, // 0或1，通常0
          "serverNames": [ // 客户端将模仿这些SNI
            "www.microsoft.com",
            "www.apple.com"
          ],
          "privateKey": "auto-generated-private-key", // 自动生成
          "minClientVer": "1.8.0",
          "maxClientVer": "2.0.0",
          "maxTimeDiff": 60000,
          "shortIds": [ // 客户端使用这些Short ID来认证
            "random-short-id-1",
            "random-short-id-2"
          ]
        }
      }
    }
  ]
}

// 客户端 (outbound VLESS with REALITY)
{
  "outbounds": [
    {
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "your-server-ip",
            "port": 443,
            "users": [
              {
                "id": "your-uuid-here"
              }
            ]
          }
        ]
      },
      "streamSettings": {
        "network": "tcp",
        "security": "reality",
        "realitySettings": {
          "dest": "your-server-ip", // REALITY 服务器的真实 IP
          "serverNames": [ // 伪装的目标网站，与服务器配置的serverNames匹配
            "www.microsoft.com"
          ],
          "fingerprint": "chrome", // 模仿的浏览器指纹
          "publicKey": "server-generated-public-key", // 对应服务器的publicKey
          "shortId": "server-given-short-id-1", // 客户端使用的Short ID
          "spiderX": "/" // 可选：指定路径匹配
        }
      }
    }
  ]
}
```

## 六、总结

REALITY 协议代表了当前对抗高级网络审查技术的顶尖水平。它通过巧妙的无证书设计和流量劫持机制，将代理流量完美伪装成访问著名网站的真实 HTTPS 流量，同时解决 TLS 证书指纹和 SNI 阻断等传统问题。尽管配置相对复杂，且依赖于目标网站的稳定性和流量，但其提供的极致隐蔽性和抗审查能力，使其成为在严格审查环境中突破封锁的强大工具。对于追求最高隐蔽性的用户和开发者来说，REALITY 是一个非常值得深入研究和尝试的协议。