---
title: HTTP/1.1 协议深度详解：Web 通信的基石
date: 2023-03-23 06:24:00
tags:
  - 2023
  - HTTP
  - 计算机网络
  - 网络协议
categories:
  - 计算机网络
  - 网络协议
---

> **HTTP (HyperText Transfer Protocol - 超文本传输协议)** 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。**HTTP/1.1** 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP/1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。

{% note info %}
**核心思想**：HTTP/1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于**请求-响应模型**，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。
{% endnote %}

## 一、HTTP/1.0 到 HTTP/1.1 的演进：解决痛点

HTTP/1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：

1.  **短连接 (Short Connection)**：HTTP/1.0 默认每个请求/响应事务都需要建立一个新的 TCP 连接。这意味着：
    *   每次请求都有 TCP 三次握手和四次挥手的开销。
    *   对于包含大量小资源的网页（如图片、CSS、JS 文件），会建立和关闭很多次连接，造成严重延迟。
    *   TCP 连接的慢启动机制无法有效发挥作用，因为每次新建连接都会重置。
2.  **无状态性 (Statelessness)**：虽然 HTTP 本身是无状态的，但 HTTP/1.0 缺乏有效的机制来维护会话状态，如 Cookie。
3.  **不支持虚拟主机**：HTTP/1.0 在请求头中没有 `Host` 字段，导致一个 IP 地址只能对应一个域名，无法在同一个服务器上托管多个网站。
4.  **带宽浪费**：缺乏有效的缓存策略和断点续传机制。

**HTTP/1.1 于 1999 年发布，旨在解决这些问题，带来了以下关键改进：**

1.  **持久连接 (Persistent Connections)**：默认开启，允许在同一个 TCP 连接上发送多个 HTTP 请求和接收多个响应。
2.  **请求管线化 (Pipelining)**：在持久连接的基础上，允许客户端在收到前一个响应之前，就发送下一个请求。
3.  **缓存控制 (Cache Control)**：引入了更精细和强大的缓存机制 (`Cache-Control`、`ETag` 等)。
4.  **范围请求 (Range Requests)**：支持断点续传，允许客户端只请求资源的某个部分。
5.  **Host 头**：强制要求请求头包含 `Host` 字段，支持虚拟主机。
6.  **错误通知**：增加了更丰富的状态码。

## 二、HTTP/1.1 的基本特性

### 2.1 1. 请求-响应模型

HTTP/1.1 遵循经典的请求-响应模型。客户端发送请求报文，服务器发送响应报文。

{% mermaid %}
sequenceDiagram
    participant C as 客户端 (浏览器)
    participant S as 服务器 (Web Server)

    activate C
    C->>S: 1. 建立 TCP 连接 (如果不是持久连接或首次)
    activate S
    C->>S: 2. 发送 HTTP 请求报文
    activate S
    S-->>C: 3. 发送 HTTP 响应报文
    deactivate S
    C->>S: 4. 关闭 TCP 连接 (如果不是持久连接)
    deactivate C
{% endmermaid %}

一次 HTTP 事务包含请求和响应两个部分，每个部分都由三部分构成：**起始行、头部字段集、空行、实体主体**。

### 2.2 2. 无状态性与 Cookie

HTTP/1.1 协议本身是无状态的，即服务器不会保存客户端以前的请求信息，每个请求都是独立的。

然而，为了在无状态的 HTTP 上实现有状态的会话管理（如用户登录状态、购物车），引入了 **Cookie** 机制：

*   服务器通过 `Set-Cookie` 响应头向客户端发送 Cookie。
*   客户端将 Cookie 存储起来，并在后续请求中通过 `Cookie` 请求头自动发送回服务器。
*   服务器根据 Cookie 识别客户端并维护会话状态。

### 2.3 3. 头部字段 (Headers)

HTTP 头部字段是请求和响应的关键元数据，它们提供了关于报文、请求/响应的附加信息，如内容类型、编码、缓存策略、认证信息等。

**常见请求头示例：**

*   `Host`: `www.example.com` (必须，指定目标服务器的域名)
*   `User-Agent`: `Mozilla/5.0 ...` (客户端浏览器和操作系统信息)
*   `Accept`: `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8` (客户端能接受的媒体类型)
*   `Accept-Encoding`: `gzip, deflate, br` (客户端能接受的内容编码)
*   `Accept-Language`: `zh-CN,zh;q=0.9,en;q=0.8` (客户端能接受的语言)
*   `Connection`: `keep-alive` (控制持久连接，HTTP/1.1 默认 `keep-alive`)
*   `Content-Length`: `1024` (请求体长度)
*   `Content-Type`: `application/json` (请求体的媒体类型)
*   `Cookie`: `sessionid=abc123; user=john` (客户端发送的 Cookie)
*   `Authorization`: `Bearer <token>` (认证凭证)
*   `If-Modified-Since`: `Fri, 26 Jul 2024 10:00:00 GMT` (条件请求，用于缓存验证)
*   `If-None-Match`: `"<etag>"` (条件请求，用于缓存验证)

**常见响应头示例：**

*   `Server`: `Apache/2.4.6 (CentOS)` (服务器软件信息)
*   `Content-Type`: `text/html; charset=utf-8` (响应体媒体类型和字符集)
*   `Content-Length`: `2048` (响应体长度)
*   `Connection`: `keep-alive` (控制持久连接)
*   `Cache-Control`: `max-age=3600, public` (缓存指令)
*   `Expires`: `Fri, 26 Jul 2025 10:00:00 GMT` (缓存过期时间)
*   `Last-Modified`: `Fri, 26 Jul 2024 10:00:00 GMT` (资源最后修改时间)
*   `ETag`: `"<etag_hash>"` (资源实体标签，用于缓存验证)
*   `Vary`: `Accept-Encoding` (指示响应会因请求头的不同而不同)
*   `Set-Cookie`: `sessionid=xyz456; Path=/; HttpOnly` (服务器设置 Cookie)
*   `Location`: `http://www.example.com/new-resource` (重定向目标 URL)

### 2.4 4. 状态码 (Status Codes)

HTTP 状态码是服务器对请求的反馈，一个三位数字，用来告诉客户端请求是成功、失败还是有其他情况需要处理。

*   **1xx (信息)**：请求已被接收，继续处理。
    *   `100 Continue`：客户端应继续其请求。
    *   `101 Switching Protocols`：服务器已理解并接受客户端的 Upgrade 请求，并将切换到新的协议（如 WebSocket 握手）。
*   **2xx (成功)**：请求已成功被接收、理解、接受。
    *   `200 OK`：请求成功，响应头和响应体中包含所请求的资源。
    *   `201 Created`：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。
    *   `204 No Content`：服务器成功处理了请求，但没有返回任何内容（如 DELETE 请求）。
    *   `206 Partial Content`：服务器已成功处理了部分 GET 请求（用于断点续传或多线程下载）。
*   **3xx (重定向)**：需要进一步操作以完成请求。
    *   `301 Moved Permanently`：资源已被永久移动到新位置。
    *   `302 Found`：资源临时移动到新位置。
    *   `304 Not Modified`：自上次请求以来资源未被修改，客户端可使用缓存副本。
*   **4xx (客户端错误)**：请求包含语法错误或无法完成请求。
    *   `400 Bad Request`：服务器无法理解客户端的请求，因为请求报文有语法错误。
    *   `401 Unauthorized`：请求需要用户验证。
    *   `403 Forbidden`：服务器理解请求，但拒绝执行（通常是权限问题）。
    *   `404 Not Found`：服务器找不到请求的资源。
    *   `405 Method Not Allowed`：请求方法不被服务器支持。
    *   `408 Request Timeout`：客户端没有在时限内发送完整的请求。
    *   `409 Conflict`：由于和资源当前的冲突而不能完成该请求。
    *   `413 Payload Too Large`：请求体太大。
    *   `415 Unsupported Media Type`：服务器无法处理请求附带的媒体格式。
*   **5xx (服务器错误)**：服务器未能实现请求。
    *   `500 Internal Server Error`：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。
    *   `502 Bad Gateway`：服务器作为网关或代理，从上游服务器收到无效响应。
    *   `503 Service Unavailable`：服务器目前无法响应请求，通常由于超载或停机维护。
    *   `504 Gateway Timeout`：服务器作为网关或代理，没有及时从上游服务器收到响应。

## 三、HTTP/1.1 的核心新特性

### 3.1 1. 持久连接 (Persistent Connections)

*   **HTTP/1.0 默认短连接**：每个请求创建一个新的 TCP 连接，传输数据后立即关闭。
*   **HTTP/1.1 默认持久连接**：引入 `keep-alive` 机制（虽然现在 `Connection: keep-alive` 头通常可以省略，因为它已是默认行为），允许在同一个 TCP 连接上发送和接收多个请求和响应。
*   **优势**：
    1.  **减少 TCP 连接建立开销**：避免了多次 TCP 三次握手和四次挥手。
    2.  **TCP 慢启动**：一旦 TCP 连接建立并进入稳定状态，可以避免慢启动带来的延迟。
    3.  **节省带宽**：减少了连接管理相关的报文传输。
*   **配置**：服务器可以通过 `Keep-Alive` 响应头指定连接保持时间或最大请求数。

### 3.2 2. 请求管线化 (Pipelining)

*   在持久连接的基础上，允许客户端在收到上一个请求的响应之前，就发送下一个请求。
*   **工作方式**：客户端连续发送多个请求，服务器收到后会按顺序处理这些请求，并按顺序返回响应。
*   **优势**：提高了请求的并行度，减少了客户端的等待时间。
*   **局限性 (队头阻塞 - Head-of-Line Blocking)**：
    *   服务器必须按请求的顺序发送响应。如果第一个请求处理时间很长，后面的请求即使处理完了，也必须等待它先发送响应。
    *   由于这些限制和实现的复杂性，以及后续 HTTP/2 的出现，**现代浏览器通常默认不开启 HTTP/1.1 的请求管线化。**

### 3.3 3. 缓存控制 (Cache Control)

HTTP/1.1 提供了强大而精细的缓存控制机制，避免重复下载相同的资源，显著提高了 Web 性能。

*   **强缓存**：当命中时，浏览器直接使用本地缓存，不与服务器通信。
    *   `Cache-Control` 响应头：
        *   `max-age=<seconds>`：缓存的最大新鲜时间。
        *   `no-cache`：每次都向服务器验证缓存的有效性。
        *   `no-store`：不缓存任何内容。
        *   `public`：可以被任何缓存（包括代理服务器）缓存。
        *   `private`：只能被客户端浏览器缓存。
    *   `Expires` 响应头：指定缓存的绝对过期时间 (HTTP/1.0 产物，优先级低于 `Cache-Control`)。
*   **协商缓存**：强缓存过期或未命中的情况下，浏览器带着缓存标识向服务器询问资源是否改变，如果未改变，服务器返回 304 状态码，浏览器使用本地缓存。
    *   `Last-Modified` / `If-Modified-Since`：
        *   服务器通过 `Last-Modified` 响应头告诉资源最后修改时间。
        *   客户端在下次请求时，通过 `If-Modified-Since` 请求头携带此时间，服务器比对。
    *   `ETag` / `If-None-Match`：
        *   服务器通过 `ETag` 响应头提供资源的唯一标识符（通常是内容的哈希值）。
        *   客户端在下次请求时，通过 `If-None-Match` 请求头携带此 ETag，服务器比对。**`ETag` 优先级高于 `Last-Modified`。**

### 3.4 4. 范围请求 (Range Requests)

允许客户端只请求资源的特定一部分，而不是整个资源。

*   客户端通过 `Range` 请求头指定请求的字节范围，例如 `Range: bytes=0-1023`。
*   服务器如果支持，会返回 `206 Partial Content` 状态码，并在 `Content-Range` 响应头中指定返回的范围，响应体中只包含请求的部分数据。
*   **应用场景**：断点续传、多线程下载、音视频流媒体（按需加载）。

### 3.5 5. Host 头

HTTP/1.1 **强制**要求客户端在请求中包含 `Host` 头，指定请求的目标域名。

*   **作用**：使得可以在同一台服务器（同一个 IP 地址）上托管多个域名不同的网站（虚拟主机）。服务器根据 `Host` 头来区分不同的站点，从而将请求路由到正确的应用程序。

### 3.6 6. 更多的状态码和请求方法

HTTP/1.1 引入了更多细致的状态码，如 `100 Continue`、`206 Partial Content`、`409 Conflict`、`410 Gone` 等，以及 `OPTIONS`、`PUT`、`DELETE` 等请求方法，使得 HTTP API 设计更加灵活和语义化。

## 四、HTTP/1.1 的优缺点

### 4.1 优点：

*   **广泛兼容性**：作为 Web 的核心协议，拥有几乎无处不在的兼容性。
*   **相对高效**：通过持久连接和缓存机制，在一定程度上解决了 HTTP/1.0 的性能问题。
*   **简单易用**：协议结构相对简单，易于理解和实现。
*   **功能丰富**：支持虚拟主机、断点续传、更精细的缓存控制等。

### 4.2 缺点：

*   **队头阻塞 (Head-of-Line Blocking)**：尽管有管线化，但由于服务器必须按序响应，如果前一个请求响应慢，会阻塞后续请求的响应。
*   **单个 TCP 连接的限制**：虽然持久连接减少了连接开销，但单个 TCP 连接在同一时间只能处理一个请求-响应对（即使管线化，也只是请求可以并发，响应仍是串行），为了提高并行度，浏览器通常会为同一个域名建立 6-8 个 TCP 连接。
*   **冗余头部**：即使是持久连接，每次请求和响应仍携带完整的 HTTP 头部信息，这尤其对于小资源的频繁请求会造成带宽浪费。
*   **强制明文**：HTTP 协议本身不提供加密，需要通过 HTTPS (HTTP over TLS/SSL) 来实现安全传输。
*   **不支持服务器推送**：服务器无法主动向客户端推送数据，需要客户端发起拉取。

## 五、HTTP/1.1 与后续版本的关系

*   **HTTP/2**：于 2015 年发布，旨在解决 HTTP/1.1 的队头阻塞、头部冗余和不支持服务器推送等问题。它引入了二进制分帧、多路复用、头部压缩、服务器推送等新特性，大幅提升了性能。
*   **HTTP/3**：于 2022 年发布，基于 QUIC 传输协议而非 TCP，进一步解决了传输层的队头阻塞问题，并在加密、连接迁移等方面有显著优势。

尽管 HTTP/2 和 HTTP/3 提供了更优越的性能，但 HTTP/1.1 仍是 Web 的基础协议。大部分的 Web 服务器和客户端仍然支持并广泛使用 HTTP/1.1，并且许多高级协议（如 WebSocket 的握手）也依然利用了 HTTP/1.1 的机制。

## 六、总结

HTTP/1.1 作为一个成熟且强大的协议，是现代 Web 的基石，其引入的持久连接、缓存控制、Host 头等特性极大地推动了互联网的发展。理解 HTTP/1.1 的工作原理、报文结构和核心特性，对于每一个 Web 开发者和网络工程师都至关重要。虽然更高版本的 HTTP 协议不断涌现，但 HTTP/1.1 仍然以其坚实的基础和广泛的兼容性，在今天的网络世界中发挥着不可替代的作用。