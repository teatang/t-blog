---
title: Git命令详解与实践
date: 2023-11-02 06:24:00
tags:
  - 2023
  - 开发工具
  - Git
categories:
  - 开发工具
  - Git
---

> Git 作为一个分布式版本控制系统，是现代软件开发中不可或缺的工具。它允许开发者追踪代码变更、协调团队协作，并管理项目版本。本文旨在对 Git 的核心命令进行详尽解析，涵盖从初始化仓库到高级操作的各个方面，帮助开发者更深入地理解和高效地利用 Git。

{% note info %}
核心思想：**理解 Git 的工作区、暂存区和仓库之间的关系，以及每个命令如何操作这些区域，是掌握 Git 的关键。**
{% endnote %}
------

## 一、Git 核心概念回顾

在深入 Git 命令之前，理解几个核心概念对于后续的学习至关重要。

### 1.1 工作区 (Working Directory)

你正在编辑和修改的文件所在的目录，也是你肉眼可见的目录。

### 1.2 暂存区 (Staging Area / Index)

一个轻量级的中间区域，用于存放你准备提交的文件快照。当执行 `git add` 命令时，文件就从工作区被添加到暂存区。

### 1.3 本地仓库 (Local Repository)

存放项目的所有版本历史记录（即一系列提交）。当你执行 `git commit` 命令时，暂存区的文件快照就会被永久保存到本地仓库。

### 1.4 远程仓库 (Remote Repository)

通常位于网络上的另一个服务器，用于团队协作和备份。本地仓库可以与远程仓库进行同步（`git push`, `git pull`, `git fetch`）。

### 1.5 HEAD

一个特殊的指针，总是指向你当前所在分支的最新提交。当你切换分支或提交新代码时，`HEAD` 会随之移动。

### 1.6 Commit (提交)

Git 中最基本的单位，代表了项目历史中的一个快照。每次提交都包含作者信息、提交时间、提交信息以及指向父提交的指针（除了第一个提交）。

### 1.7 Branch (分支)

一个指向提交的指针。分支允许开发者在不影响主线开发的情况下，独立进行新功能开发或 Bug 修复。

{% mermaid %}
graph LR
    A[工作区] -- git add --> B["暂存区 (Index)"]
    B -- git commit --> C[本地仓库]
    C -- git push --> D[远程仓库]
    D -- git pull/fetch --> C
{% endmermaid %}

## 二、Git 命令详解

本节将分类详细介绍 Git 的常用命令。

### 2.1 配置类命令

首次使用 Git 或更换开发环境时，需要配置用户信息。

#### 2.1.1 `git config`

**作用**：设置 Git 的配置变量，例如用户身份、编辑器、别名等。

**语法**：
*   `git config --global user.name "Your Name"`：设置全局用户名。
*   `git config --global user.email "your_email@example.com"`：设置全局用户邮箱。
*   `git config --list`：查看所有配置信息。
*   `git config user.name`：查看当前仓库的用户名。
*   `git config --global -e`：使用编辑器打开全局配置文件进行编辑。

**示例**：

```bash
git config --global user.name "张三"
git config --global user.email "zhangsan@example.com"
git config --list
# output:
# user.name=张三
# user.email=zhangsan@example.com
# ...
```

**说明**：`--global` 选项表示配置对当前用户的所有 Git 仓库生效。如果没有 `--global`，则配置仅对当前仓库生效。

### 2.2 仓库初始化与克隆

#### 2.2.1 `git init`

**作用**：在当前目录初始化一个新的 Git 仓库。这会在当前目录创建一个 `.git` 隐藏文件夹，包含了所有 Git 仓库的元数据。

**语法**：`git init`

**示例**：

```bash
mkdir my_project
cd my_project
git init
# output: Initialized empty Git repository in /path/to/my_project/.git/
```

**说明**：通常用于将一个现有项目转换为 Git 仓库。

#### 2.2.2 `git clone`

**作用**：克隆一个远程 Git 仓库到本地。它会下载远程仓库的所有版本历史，并自动设置好远程仓库的跟踪关系。

**语法**：`git clone <repository_url> [directory_name]`

**示例**：

```bash
git clone https://github.com/octocat/Spoon-Knife.git
# output: Cloning into 'Spoon-Knife'... (下载过程)
```

**说明**：`[directory_name]` 是可选的，如果省略，则会在当前目录创建一个与仓库同名的文件夹。

### 2.3 基本操作

#### 2.3.1 `git status`

**作用**：显示工作区和暂存区的当前状态，包括哪些文件被修改、哪些被暂存、哪些是未跟踪文件等。

**语法**：`git status`

**示例**：

```bash
# 修改了文件 index.html，新增了文件 new.txt
git status
# output:
# On branch main
# Your branch is up to date with 'origin/main'.
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git restore <file>..." to discard changes in working directory)
#         modified:   index.html
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#         new.txt
```

**说明**：这是一个非常常用的命令，帮助你了解当前代码库的状况。

#### 2.3.2 `git add`

**作用**：将工作区的修改或新增文件添加到暂存区，准备进行提交。

**语法**：
*   `git add <file1> <file2> ...`：添加指定文件。
*   `git add .`：添加当前目录及子目录下所有新建、修改的文件（不包括删除的文件）。
*   `git add -u`：添加所有已跟踪的修改和删除的文件（不包括新增文件）。
*   `git add -A`：添加所有更改（包括新增、修改、删除）。等同于 `git add .` 或 `git add --all`。

**示例**：

```bash
# 修改了 index.html
git add index.html # 将 index.html 的修改添加到暂存区

# 新增了 style.css
git add . # 将所有修改和新增文件添加到暂存区

git status
# output:
# On branch main
# Your branch is up to date with 'origin/main'.
#
# Changes to be committed:
#   (use "git restore --staged <file>..." to unstage)
#         modified:   index.html
#         new file:   style.css
```

**说明**：`git add` 是一个增量操作，每次添加都会将文件的当前状态存入暂存区。

#### 2.3.3 `git commit`

**作用**：将暂存区中的所有更改作为一个新的提交保存到本地仓库。

**语法**：
*   `git commit -m "Commit message"`：使用 `-m` 选项直接提供提交信息。
*   `git commit`：打开默认编辑器（如 Vim）编写提交信息。
*   `git commit -am "Commit message"`：跳过暂存区，直接将所有已跟踪的修改（不包括新增文件）提交。相当于 `git add -u` 后再 `git commit -m`。

**示例**：

```bash
git add .
git commit -m "feat: Add user login feature"
# output:
# [main b2f1c8a] feat: Add user login feature
#  2 files changed, 25 insertions(+), 3 deletions(-)
#  create mode 100644 src/login.py
```

**说明**：一个好的提交信息对于项目历史的可读性和维护性至关重要。建议遵循 [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) 规范。

#### 2.3.4 `git log`

**作用**：显示提交历史记录。

**语法**：
*   `git log`：显示所有提交，按时间倒序排列。
*   `git log --oneline`：以简洁的单行格式显示提交。
*   `git log --graph --oneline --all`：以图形方式显示所有分支的提交历史。
*   `git log -p`：显示每个提交的具体更改内容 (diff)。
*   `git log --author="Your Name"`：按作者过滤提交。
*   `git log --since="2 weeks ago"`：过滤最近两周的提交。

**示例**：

```bash
git log --oneline --graph --all
# output:
# * 8e2a3c1 (HEAD -> main, origin/main) feat: add contact form
# * 6b7c8d9 fix: correct typo in homepage
# * 1a2b3c4 Initial commit
```

**说明**：`git log` 是理解项目演变和追溯问题的重要工具。

#### 2.3.5 `git diff`

**作用**：比较文件之间的差异。

**语法**：
*   `git diff`：比较工作区和暂存区之间的差异。
*   `git diff --staged` 或 `git diff --cached`：比较暂存区和上次提交之间的差异。
*   `git diff HEAD`：比较工作区和上次提交之间的差异。
*   `git diff <commit1> <commit2>`：比较两个提交之间的差异。
*   `git diff <branch1> <branch2>`：比较两个分支的最新提交之间的差异。

**示例**：

```bash
# 在 working_file.txt 中做了修改，但未 git add
git diff
# output: (显示 working_file.txt 的修改内容)

git add working_file.txt
git diff --staged
# output: (显示 working_file.txt 在暂存区和上次提交的差异)
```

**说明**：`git diff` 可以帮助你在提交前审查自己的更改，或在审查他人代码时理解改动。

### 2.4 分支管理

#### 2.4.1 `git branch`

**作用**：列出、创建、删除分支。

**语法**：
*   `git branch`：列出所有本地分支。
*   `git branch -a`：列出所有本地和远程分支。
*   `git branch <branch_name>`：创建新分支，但不切换过去。
*   `git branch -d <branch_name>`：删除本地分支。
*   `git branch -D <branch_name>`：强制删除本地分支（即使有未合并的提交）。

**示例**：

```bash
git branch # 列出本地分支
# output:
# * main
#   feature/login

git branch new-feature # 创建新分支 new-feature
git branch -d feature/login # 删除 feature/login 分支
```

#### 2.4.2 `git checkout` (旧版)

**作用**：切换分支或恢复文件。在 Git 2.23 之后，其文件恢复和分支切换功能被 `git restore` 和 `git switch` 分离。

**语法**：
*   `git checkout <branch_name>`：切换到指定分支。
*   `git checkout -b <new_branch_name>`：创建并切换到新分支。
*   `git checkout <file_path>`：丢弃工作区中文件的所有修改，恢复到最近一次提交的状态。
*   `git checkout <commit_hash> <file_path>`：将文件恢复到指定提交时的状态。

**示例**：

```bash
git checkout feature/dashboard # 切换到 dashboard 分支
git checkout -b feature/analytics # 创建并切换到 analytics 分支
git checkout index.html # 丢弃 index.html 的所有本地修改
```

#### 2.4.3 `git switch` (新版，Git 2.23+)

**作用**：专门用于切换分支。旨在替代 `git checkout` 的分支切换功能。

**语法**：
*   `git switch <branch_name>`：切换到指定分支。
*   `git switch -c <new_branch_name>`：创建并切换到新分支。
*   `git switch -C <new_branch_name>`：强制创建并切换到新分支（会覆盖同名分支）。

**示例**：

```bash
git switch develop # 切换到 develop 分支
git switch -c feature/new-design # 创建并切换到新分支
```

**说明**：推荐使用 `git switch` 进行分支切换，因为它更清晰地表达了意图。

#### 2.4.4 `git restore` (新版，Git 2.23+)

**作用**：专门用于恢复文件。旨在替代 `git checkout` 的文件恢复功能。

**语法**：
*   `git restore <file_path>`：丢弃工作区中文件的所有修改，恢复到暂存区或上次提交的状态。
*   `git restore --staged <file_path>`：将文件从暂存区撤回到工作区（但不会丢弃工作区中的修改）。
*   `git restore --source=<commit_hash> <file_path>`：将文件恢复到指定提交时的状态。

**示例**：

```bash
# 修改了 main.py，已 git add
git restore --staged main.py # 将 main.py 从暂存区撤回
git restore main.py # 丢弃 main.py 在工作区的修改
```

**说明**：推荐使用 `git restore` 进行文件恢复，因为它更清晰地表达了意图。

#### 2.4.5 `git merge`

**作用**：将一个分支的更改合并到当前分支。

**语法**：`git merge <source_branch>`

**示例**：

```bash
git checkout develop
git merge feature/new-feature # 将 feature/new-feature 分支合并到 develop
# output: (合并信息，可能需要解决冲突)
```

**说明**：`git merge` 会创建一个新的合并提交（三方合并），保留了完整的历史记录。如果不需要新的合并提交（例如目标分支是源分支的直接祖先），Git 会执行快进合并 (fast-forward merge)。
**详细对比请参阅 `Git Merge vs. Rebase 对比详解` 文档。**

#### 2.4.6 `git rebase`

**作用**：将一系列提交从一个分支移动或复制到另一个分支的顶部，从而创建线性的历史记录。它会改写提交历史。

**语法**：`git rebase <base_branch>`

**示例**：

```bash
git checkout feature/new-feature
git rebase develop # 将 feature/new-feature 分支的提交应用到 develop 分支的最新提交之上
# output: (变基过程，可能需要解决冲突)
```

**说明**：`git rebase` 可以使提交历史更整洁，但会改写历史，**切勿在已推送到公共仓库的分支上使用**。
**详细对比请参阅 `Git Merge vs. Rebase 对比详解` 文档。**

### 2.5 远程仓库操作

#### 2.5.1 `git remote`

**作用**：管理远程仓库。

**语法**：
*   `git remote -v`：列出所有远程仓库及其 URL。
*   `git remote add <name> <url>`：添加一个新的远程仓库。
*   `git remote remove <name>`：移除指定远程仓库。

**示例**：

```bash
git remote add upstream https://github.com/another/repo.git
git remote -v
# output:
# origin  https://github.com/my/repo.git (fetch)
# origin  https://github.com/my/repo.git (push)
# upstream    https://github.com/another/repo.git (fetch)
# upstream    https://github.com/another/repo.git (push)
```

**说明**：`origin` 是克隆仓库时默认创建的远程仓库别名。

#### 2.5.2 `git fetch`

**作用**：从远程仓库下载最新的提交和分支信息，但**不合并**到当前本地分支。它只会更新本地的远程分支引用（例如 `origin/main`）。

**语法**：`git fetch [remote_name]`

**示例**：

```bash
git fetch origin
# output: (下载远程仓库的最新内容)
git log HEAD..origin/main # 查看本地和远程/main的差异
```

**说明**：`git fetch` 是一个安全的操作，因为它不会改变你的工作区或本地分支。

#### 2.5.3 `git pull`

**作用**：从远程仓库下载最新的提交，并自动合并到当前本地分支。等同于 `git fetch` 后再 `git merge`。

**语法**：`git pull [remote_name] [branch_name]`

**示例**：

```bash
git pull origin main # 从 origin 远程仓库的 main 分支拉取并合并到当前分支
# output: (拉取并合并信息，可能需要解决冲突)
```

**说明**：`git pull` 可能会导致合并冲突。可以使用 `git pull --rebase` 来替代 `git pull`，将本地提交变基到远程最新提交之上，避免合并提交。

#### 2.5.4 `git push`

**作用**：将本地仓库的提交推送到远程仓库。

**语法**：
*   `git push [remote_name] [branch_name]`：将本地分支推送到远程仓库的同名分支。
*   `git push -u origin main`：设置本地 `main` 分支与远程 `origin/main` 分支的跟踪关系，并首次推送。后续只需 `git push`。
*   `git push --force` 或 `git push --force-with-lease`：强制推送。**慎用！** 这会覆盖远程仓库的历史记录。

**示例**：

```bash
git push origin main # 将本地 main 分支推送到 origin 远程仓库的 main 分支
```

**说明**：当远程仓库有你本地没有的提交时，`git push` 会被拒绝。你需要先 `git pull` 同步远程更改并解决冲突后才能推送。`--force-with-lease` 比 `--force` 更安全，因为它会在强制推送前检查远程分支是否与本地分支的旧版本匹配，避免覆盖他人新的工作。

### 2.6 撤销与修改

#### 2.6.1 `git reset`

**作用**：重置 `HEAD` 指针和（可选）暂存区、工作区。这是一个**破坏性**命令，尤其是 `--hard` 选项。

**语法**：
*   `git reset <file_path>`：将暂存区中指定文件撤回到工作区（即取消 `git add`）。
*   `git reset --soft <commit_hash>`：移动 `HEAD` 到指定提交，但**保留**工作区和暂存区的更改。
*   `git reset --mixed <commit_hash>` (默认)：移动 `HEAD` 到指定提交，**清空**暂存区，但**保留**工作区的更改。
*   `git reset --hard <commit_hash>`：移动 `HEAD` 到指定提交，**清空**暂存区和工作区。**最危险！会丢失未提交的更改。**

**示例**：

```bash
# 撤销对 file.txt 的暂存
git reset file.txt

# 撤销最近两次提交，但保留所有修改在工作区和暂存区
git reset --soft HEAD~2

# 撤销最近一次提交，清空暂存区，但保留工作区修改
git reset HEAD~1

# 撤销最近一次提交，并丢弃所有修改，回到上一个提交的干净状态
git reset --hard HEAD~1
```

**说明**：`git reset` 应该小心使用，尤其是在已共享的分支上。

#### 2.6.2 `git revert`

**作用**：创建一个新的提交来撤销指定提交所引入的更改。这是一个**安全**的撤销操作，因为它不改写历史。

**语法**：`git revert <commit_hash>`

**示例**：

```bash
git revert 2c3f4e5 # 撤销哈希为 2c3f4e5 的提交，并创建一个新的提交
```

**说明**：`git revert` 是在公共分支上撤销更改的首选方式，因为它保留了完整的历史记录。

#### 2.6.3 `git commit --amend`

**作用**：修改最近一次提交。可以修改提交信息，或添加、移除文件到最近一次提交。

**语法**：`git commit --amend -m "New commit message"`

**示例**：

```bash
# 提交后发现信息写错了
git commit --amend -m "fix: Corrected typo in previous commit"

# 提交后发现漏掉了 file.txt
git add file.txt
git commit --amend --no-edit # 添加 file.txt 到上一次提交，不修改提交信息
```

**说明**：此命令会替换掉最近的提交，生成一个新的提交哈希。因此，**不要修改已推送到公共仓库的提交**。

#### 2.6.4 `git clean`

**作用**：移除工作区中未跟踪的文件和目录。这是一个**危险**的命令，因为它会永久删除文件。

**语法**：
*   `git clean -n` (dry run)：模拟执行，显示会删除哪些文件，但实际不删除。
*   `git clean -f`：强制删除未跟踪的文件。
*   `git clean -fd`：强制删除未跟踪的文件和目录。

**示例**：

```bash
git clean -n # 查看将要删除的文件
git clean -fd # 确认后执行删除
```

**说明**：在执行 `git clean` 之前，务必先使用 `-n` 选项进行预览。

### 2.7 标签与工具

#### 2.7.1 `git tag`

**作用**：创建、列出、删除标签。标签通常用于标记项目的重要里程碑，如发布版本。

**语法**：
*   `git tag`：列出所有标签。
*   `git tag -l "v1.*"`：列出符合模式的标签。
*   `git tag <tag_name>`：创建轻量级标签（指向某个提交的指针）。
*   `git tag -a <tag_name> -m "Tag message"`：创建附注标签（推荐，包含作者、日期和信息）。
*   `git tag -d <tag_name>`：删除本地标签。
*   `git push origin <tag_name>`：将指定标签推送到远程仓库。
*   `git push origin --tags`：将所有本地标签推送到远程仓库。

**示例**：

```bash
git tag v1.0.0 # 创建轻量级标签
git tag -a v1.0.1 -m "Release version 1.0.1" # 创建附注标签
git push origin --tags # 推送所有标签
```

#### 2.7.2 `git stash`

**作用**：临时保存当前工作区和暂存区的修改，以便切换到其他任务，而无需提交这些不完整的更改。

**语法**：
*   `git stash push -m "Stash message"`：保存当前修改并附带消息。
*   `git stash list`：列出所有 stash。
*   `git stash pop`：应用最近的一个 stash 并从列表中删除。
*   `git stash apply <stash@{n}>`：应用指定的 stash，但不从列表中删除。
*   `git stash drop <stash@{n}>`：删除指定的 stash。
*   `git stash clear`：删除所有 stash。

**示例**：

```bash
# 正在开发新功能，但来了个紧急 Bug 需要修复
git stash push -m "WIP: login feature" # 保存当前工作

# 切换到 main 分支修复 Bug...

# Bug 修复完成后，回到 feature 分支恢复工作
git checkout feature/login
git stash pop
```

#### 2.7.3 `git cherry-pick`

**作用**：选择一个或多个已存在的提交，并将其应用到当前分支上。这对于将一个分支上的特定 Bug 修复或小功能应用到另一个分支非常有用。

**语法**：`git cherry-pick <commit_hash>`

**示例**：

```bash
# 假设有一个 Bug 修复提交在 hotfix 分支上，现在要应用到 develop
git checkout develop
git cherry-pick a1b2c3d # a1b2c3d 是 hotfix 分支上的 Bug 修复提交
```

**说明**：`git cherry-pick` 会创建一个新的提交，其内容与原提交相同，但哈希不同。

#### 2.7.4 `git reflog`

**作用**：记录 `HEAD` 每次移动的日志。这是一个非常强大的“后悔药”，即使 `git log` 无法显示的历史，`reflog` 也能找回。

**语法**：`git reflog`

**示例**：

```bash
git reflog
# output:
# d1e2f3g (HEAD -> main) HEAD@{0}: commit: Add new feature
# a0b1c2d HEAD@{1}: commit: Fix bug
# ...
# d3e4f5g HEAD@{10}: reset --hard: moving to HEAD~2
```

**说明**：如果你不小心执行了 `git reset --hard` 并丢失了提交，`git reflog` 可以帮你找到丢失提交的哈希，然后通过 `git reset --hard <commit_hash>` 恢复。

## 三、总结

Git 强大的版本控制能力来源于其丰富且灵活的命令集。从基础的 `init`、`add`、`commit` 到高级的 `rebase`、`stash`、`cherry-pick`，每个命令都有其特定的用途和对仓库历史的影响。掌握这些命令及其背后的原理，理解工作区、暂存区和仓库之间的交互，是成为高效 Git 用户的关键。在实际工作中，建议遵循团队协作规范，并谨慎使用会改写历史的破坏性命令，以确保项目历史的清晰和团队协作的顺畅。