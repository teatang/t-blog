---
title: MySQL B+树索引原理详解与对比
date: 2023-07-11 06:24:00
tags:
  - 2023
  - MySQL
  - 中间件
  - 数据结构
  - 算法
categories:
  - 中间件
  - MySQL
---

> 数据库索引是提升查询性能的关键，而 MySQL 中最常见的索引结构就是 **B+树**。理解 B+树的原理对于优化数据库性能至关重要。本文将详细解析 B+树索引的内部工作机制，并将其与二叉查找树、平衡二二叉查找树、红黑树和 B 树进行对比，阐明 B+树在磁盘存储和数据库查询场景下的优势。

{% note info %}
“索引的本质是空间换时间，而 B+树是这种理念在磁盘存储场景下的极致优化。”
{% endnote %}
------

## 一、为什么需要索引？

想象一下，你有一本几百页的字典，如果要查找一个词，没有目录（索引）的话，你可能需要从头到尾翻阅。而有了目录（索引），你可以快速定位到词语的大致位置，大大提高查找效率。

在数据库中，表是按照某种顺序（不一定是逻辑顺序）存储在磁盘上的。当数据量巨大时，如果没有索引，每次查询都需要进行**全表扫描**（Full Table Scan），这意味着数据库需要读取磁盘上的每一行数据并进行比较，效率极低。

索引通过创建一种特殊的数据结构，可以快速定位到数据记录的位置，从而显著减少磁盘 I/O 次数，提高查询速度。

## 二、各种树结构简述与对比

在深入 B+树之前，我们先回顾一下几种常见的树形数据结构，了解它们的优缺点，从而更好理解 B+树为何是数据库索引的优选。

### 1. 二叉查找树 (Binary Search Tree - BST)

- **特点**：左子树所有节点的值小于根节点，右子树所有节点的值大于根节点。
- **查找效率**：平均情况下 `O(logN)`。
- **缺点**：在极端情况下（如插入的元素有序），二叉查找树会退化成链表，查找效率变为 `O(N)`。

```
       50
      /  \
    30    70
   / \    / \
  20 40  60 80

// 退化情况 (左倾斜树)
10
 \
  20
   \
    30
     \
      40
```

### 2. 平衡二叉查找树 (Balanced Binary Search Tree - BBST)

- **特点**：为了解决 BST 退化问题，BBST 引入平衡因子，确保树的高度尽可能小。任意节点的左右子树高度差不超过 1。常见的实现有 AVL 树。
- **查找效率**：始终保持 `O(logN)`。
- **缺点**：插入和删除操作时，可能需要进行多次旋转来维护平衡，增加了操作的复杂度。

```
        40
       /  \
     20    60
    / \    / \
   10 30  50 70
```

### 3. 红黑树 (Red-Black Tree - RBT)

- **特点**：一种自平衡二叉查找树，比 AVL 树的平衡条件更宽松，通过节点着色（红或黑）和旋转来保持平衡。
- **查找效率**：始终保持 `O(logN)`。
- **优点**：与 AVL 树相比，RBT 在插入和删除时进行旋转的次数更少，因此在读写混合的场景下表现更好。
- **缺点**：仍然是二叉树结构，每个节点只能有两个子节点。当数据量巨大时，树的高度依然会相对较高。

### 4. B 树 (B-Tree)

- **特点**：**多路平衡查找树**。每个节点可以有多个子节点（通常是 2 个以上），而不仅仅是 2 个。节点内会存储多个关键字 (`key`)，并将搜索范围分割成多个子树。
- **查找效率**：`O(log(k)N)`，其中 `k` 是树的度（B 树中节点最大子节点数）。
- **优点**：
  - **降低树的高度**：由于一个节点可以存储多个关键字和子节点指针，B 树的高度远低于二叉树。这对于磁盘存储至关重要，因为树的高度决定了磁盘 I/O 的次数。
  - **适应磁盘 I/O**：B 树的节点大小通常设计为磁盘页（Page）的大小（如 4KB、16KB），一次磁盘 I/O 可以读取整个节点，减少 I/O 次数。
- **缺点**：每个节点既存储关键字又存储数据指针，数据指针可能分散在整个树中，导致范围查询效率相对较低。

**B 树节点结构概览：**

```
| Pointer1 | Key1 | Pointer2 | Key2 | Pointer3 | ... | KeyN | PointerN+1 |
```

- `Key`：索引值。
- `Pointer`：指向子节点的指针。

### 5. 对比总结

| 特性          | 二叉查找树       | 平衡二叉查找树     | 红黑树           | B 树                      |
| :------------ | :--------------- | :----------------- | :--------------- | :------------------------ |
| 节点子节点数  | 2                | 2                  | 2                | **M (多于 2)**            |
| 平衡机制      | 无               | 严格平衡（AVL）    | 宽松平衡         | 自平衡（分裂与合并）      |
| 树高          | `O(N)`~`O(logN)` | `O(logN)`          | `O(logN)`        | **`O(log(M)N)` (非常低)** |
| 磁盘 I/O 次数 | 高               | 高                 | 高               | **低**                    |
| 优点          | 实现简单         | 查找稳定 `O(logN)` | 读写均衡         | 适合磁盘存储，降低 I/O    |
| 缺点          | 易退化           | 维护开销大         | 仍然是二叉树结构 | 范围查询效率略低          |

从上表可以看出，对于数据库这种数据量大且存储在磁盘上的系统，B 树的多路、低高度特性使其比二叉树更具优势。但 B 树仍然有优化空间。

## 三、B+树索引原理详解

B+树是 B 树的变种，专门为文件系统和数据库设计，进一步优化了磁盘 I/O 和范围查询。

### 1. B+树的特点

1.  **所有关键字（索引值）都出现在叶子节点中**：非叶子节点只存储关键字和指向子节点的指针，不存储真正的数据。
2.  **叶子节点包含了所有数据记录的指针，且互相连接（链表结构）**：所有叶子节点构成一个有序链表，方便范围查询。
3.  **非叶子节点（内节点）仅作为索引和分路，不存储数据**：也称为索引节点。每个内节点中的关键字都是其子树中的最大（或最小）关键字。

**B+树节点结构概览：**

- **内节点 (非叶子节点)**：
  ```
  | Pointer1 | Key1 | Pointer2 | Key2 | ... | KeyM-1 | PointerM |
  ```
  - `Key`：索引值，**仅用于指向子树，本身不带数据**。
  - `Pointer`：指向子节点的指针。
- **叶子节点**：
  ```
  | Key1 | DataPointer1 | NextLeafPointer |
  | Key2 | DataPointer2 | NextLeafPointer |
  | ...                 | NextLeafPointer |
  ```
  - `Key`：索引值。
  - `DataPointer`：指向磁盘上实际数据记录的指针（对于聚簇索引，就是数据本身）。
  - `NextLeafPointer`：指向下一个叶子节点的指针，形成有序链表。

### 2. B+树的查找过程

1.  **从根节点开始**：根据要查找的关键字，在根节点内存中进行**二分查找**（或线性查找，取决于节点内关键字数量），找到对应的区间。
2.  **沿指针下溯**：根据找到的区间，获得指向子节点的指针，加载子节点到内存。
3.  **重复步骤 1 和 2**：直到达到叶子节点。
4.  **在叶子节点中查找**：在叶子节点内存中进行二分查找，找到目标关键字。
5.  **获取数据指针/数据**：通过叶子节点存储的数据指针，定位并读取磁盘上的实际数据记录。

**示例：查找 Key = 60**

```
          [50, 80]     (根节点，在内存中)
         /    |    \
        /     |     \
     [1-40] [51-70] [81-100] (非叶子节点1，非叶子节点2，非叶子节点3)
       |      |       |
       V      V       V
  [10,20,30,40] [50,60,70] [80,90,100] (叶子节点，链表连接)
```

**查找 60：**

1.  从根节点 `[50, 80]` 开始，`60 > 50` 且 `60 < 80`，走第二个指针。
2.  加载非叶子节点 `[51-70]` 到内存，`60` 在这个范围内，走指向 `[50,60,70]` 叶子节点的指针。
3.  加载叶子节点 `[50,60,70]` 到内存，找到 `60`。
4.  根据 `60` 对应的数据指针，获取数据。

### 3. B+树的优势

1.  **磁盘 I/O 效率高**：
    - **树的高度低**：每个节点可以保存大量的关键字，使得 B+树的高度非常矮。通常 3-4 层深的 B+树就可以索引几十亿的数据。
    - **节点与磁盘页对应**：B+树的节点大小通常等于一个磁盘页（如 16KB），一次磁盘 I/O 可以读取整个节点，减少 I/O 次数。大多数查询只需 3-4 次磁盘 I/O 即可找到目标数据。
2.  **范围查询友好**：
    - 所有叶子节点组成一个有序链表。当查找完一个范围的起点后，只需沿着叶子节点的链表指针顺序遍历，而无需回溯到父节点，效率极高。
3.  **查询性能稳定**：
    - 所有查询都必须从根节点走到叶子节点，查询路径长度基本一致，因此查询性能稳定。
4.  **有利于缓存**：
    - 内节点只存储关键字和指针，占用空间小。当 B+树的内节点被加载到内存时，可以缓存更多的节点，进一步减少磁盘 I/O。

### 4. B+树的增删操作

B+树的插入和删除操作相对复杂，需要保持树的平衡性、节点内关键字的有序性以及叶子节点链表的完整性。

- **插入**：
  1.  找到合适的叶子节点插入新关键字。
  2.  如果叶子节点未满，直接插入。
  3.  如果叶子节点已满，则进行**分裂**：将一半关键字移到新的叶子节点，并将中间关键字（或其拷贝）提升到父节点。
  4.  如果父节点也满了，则继续分裂，这个过程可能一直向上蔓延到根节点（导致树的高度增加）。
- **删除**：
  1.  找到并删除叶子节点中的关键字。
  2.  如果叶子节点关键字数量低于阈值，则尝试从兄弟节点**借用**关键字。
  3.  如果无法借用，则进行**合并**：将该叶子节点与兄弟节点合并，并从父节点移除对应的关键字。
  4.  合并过程也可能向上蔓延。

## 四、MySQL 中的 B+树索引

MySQL 主要存储引擎 `InnoDB` 实现了 B+树索引。它分为两种类型：**聚簇索引**和**辅助索引（非聚簇索引）**。

### 1. 聚簇索引 (Clustered Index)

- **定义**：数据行本身就是存储在 B+树的叶子节点中。每个表只能有一个聚簇索引。
- **特性**：
  - 通常是表的主键（PRIMARY KEY）。如果表没有主键，InnoDB 会自动选择一个唯一的非空索引。如果没有这样的索引，InnoDB 会隐式地定义一个隐藏的行 ID 作为聚簇索引。
  - 数据的物理存储顺序与聚簇索引的逻辑顺序一致。
  - 优点：对于主键的查找和范围查询非常快，因为数据就在索引旁边，一步到位。
  - 缺点：数据插入顺序要尽可能和主键顺序一致，否则会造成大量的页分裂和数据挪动，导致性能下降和碎片化。
- **数据结构**：
  - B+树的叶子节点存储完整的数据行。
  - 非叶子节点存储索引值和指向子节点的页指针。

### 2. 辅助索引 / 非聚簇索引 (Secondary Index / Non-clustered Index)

- **定义**：除了聚簇索引之外的所有索引都是辅助索引。
- **特性**：
  - 不需要覆盖所有列，只包含索引列和**聚簇索引的键值**。
  - 优点：可以为不同的列创建多个辅助索引来优化不同查询。
  - 缺点：相比聚簇索引，它的查询过程是“回表”：
    1.  通过辅助索引找到对应的聚簇索引键值。
    2.  再通过聚簇索引键值去聚簇索引树中找到完整的数据行。
- **数据结构**：
  - B+树的叶子节点存储索引值和**对应的聚簇索引键值（主键值）**。
  - 非叶子节点存储索引值和指向子节点的页指针。

**举例说明“回表”：**

假设 `users` 表有 `id (主键, 聚簇索引)`, `name (辅助索引)`, `age` 列。

- **查询 `SELECT * FROM users WHERE id = 100;`**
  - 直接通过聚簇索引 B+树查找，一次定位到叶子节点，获取完整数据。
- **查询 `SELECT * FROM users WHERE name = 'Alice';`**
  - 首先通过 `name` 辅助索引 B+树查找。
  - 在 `name` 索引的叶子节点找到 `name='Alice'` 对应的 `id` 值（例如 `id=100`）。
  - 然后拿着 `id=100`，再去聚簇索引 B+树中查找，最终找到完整数据行。
  - 这个过程就是“回表”。

**索引覆盖 (Covering Index)**:

如果辅助索引的叶子节点包含了所有查询需要的列，那么就不需要“回表”了。例如：
`SELECT id, name FROM users WHERE name = 'Alice';`
如果 `name` 列上有一个辅助索引，其叶子节点存储了 `name` 和 `id`，那么查询可以直接从辅助索引中获取 `id` 和 `name`，而无需回表。这种情况下，辅助索引成为“覆盖索引”，查询效率得到极大提升。

## 五、总结

B+树作为 MySQL 最核心的索引结构，凭借其独特的性质完美契合了磁盘存储和数据库查询的需求：

1.  **多路结构、高度矮**：极大地减少了磁盘 I/O 次数，这是数据库性能的关键瓶颈。
2.  **叶子节点链表**：高效支持范围查询和全表扫描。
3.  **内节点只存储索引**：有助于将更多索引节点缓存在内存中。

理解 B+树的这些原理，能够帮助我们：

- **正确选择索引列**：将经常用于 `WHERE`、`ORDER BY`、`GROUP BY` 的列作为索引。
- **避免全表扫描**：设计合适的索引以利用 B+树的快速查找能力。
- **理解索引覆盖**：通过创建覆盖索引来避免回表，进一步提高查询性能。
- **优化插入顺序**：对于聚簇索引，尽量使插入顺序与主键顺序一致，减少页分裂。

总之，B+树是数据库查询性能的幕后英雄，深入理解其工作原理是数据库优化不可或缺的一环。
