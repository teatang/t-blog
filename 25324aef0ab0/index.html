<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git Merge vs. Rebase 对比详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Git 版本控制系统中，git merge 和 git rebase 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。  核心思想：git merge 通过创建新的合并提交来集成更改，保留">
<meta property="og:type" content="article">
<meta property="og:title" content="Git Merge vs. Rebase 对比详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/25324aef0ab0/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在 Git 版本控制系统中，git merge 和 git rebase 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。  核心思想：git merge 通过创建新的合并提交来集成更改，保留">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg">
<meta property="article:published_time" content="2024-02-14T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-05T09:12:04.343Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="Git">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git Merge vs. Rebase 对比详解",
  "url": "https://blog.tbf1211.xx.kg/25324aef0ab0/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-08.jpg",
  "datePublished": "2024-02-14T22:24:00.000Z",
  "dateModified": "2026-01-05T09:12:04.343Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/25324aef0ab0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git Merge vs. Rebase 对比详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">466</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-08.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Git Merge vs. Rebase 对比详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git Merge vs. Rebase 对比详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-02-14T22:24:00.000Z" title="发表于 2024-02-15 06:24:00">2024-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在 Git 版本控制系统中，<code>git merge</code> 和 <code>git rebase</code> 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<code>git merge</code> 通过创建<strong>新的合并提交</strong>来集成更改，保留了所有分支的历史；<code>git rebase</code> 通过<strong>重写提交历史</strong>将一个分支的提交应用到另一个分支的顶部，从而创建线性的历史记录。</p>
</div>
<hr>
<h2 id="一、Git-Merge-合并"><a href="#一、Git-Merge-合并" class="headerlink" title="一、Git Merge (合并)"></a>一、Git Merge (合并)</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong><code>git merge</code></strong> 命令用于将来自一个或多个分支的独立开发历史合并到当前分支。它通过创建一个<strong>新的合并提交 (merge commit)</strong> 来实现这一点，这个合并提交的父提交指向两个被合并分支的最新提交。这意味着 <code>git merge</code> 会保留所有分支的原始提交历史，并显式地记录合并发生的时间和地点。</p>
<h3 id="1-2-工作原理"><a href="#1-2-工作原理" class="headerlink" title="1.2 工作原理"></a>1.2 工作原理</h3><p>当执行 <code>git merge &lt;branch_name&gt;</code> 时：</p>
<ol>
<li>Git 找到当前分支 (<code>HEAD</code>) 和 <code>&lt;branch_name&gt;</code> 之间最新的共同祖先 (common ancestor)。</li>
<li>它将 <code>&lt;branch_name&gt;</code> 上的更改应用到当前分支，并尝试将它们合并。</li>
<li>如果两个分支的历史已经分叉（即在共同祖先之后都有各自的提交），并且存在冲突，你需要手动解决冲突。</li>
<li>解决冲突后，Git 会创建一个新的合并提交，这个提交有两个父提交：一个是当前分支的最新提交，另一个是 <code>&lt;branch_name&gt;</code> 的最新提交。</li>
</ol>
<p><strong>两种主要合并方式：</strong></p>
<ul>
<li><p><strong>快进合并 (Fast-Forward Merge)</strong>：如果当前分支的最新提交是另一个分支的直接祖先，Git 会直接将当前分支的指针向前移动到另一个分支的最新提交，不创建新的合并提交。这种情况只发生在合并分支没有在共同祖先之后有任何新的提交时。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    gitGraph
    commit id: &quot;C1&quot;
    commit id: &quot;C2&quot;
    branch feature
    checkout feature
    commit id: &quot;F1&quot;
    commit id: &quot;F2&quot;
    checkout main
    merge feature
  </pre></div>
<p><em>上述图示中，如果main分支只有C1、C2，feature分支有F1、F2，且main是feature的直接祖先，则merge feature后，main会直接指向F2，形成一条直线。</em></p>
</li>
<li><p><strong>三方合并 (Three-Way Merge)</strong>：当两个分支的历史已经分叉时，Git 会创建一个新的合并提交。这是最常见的合并方式，也是 <code>git merge</code> 的核心特性。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    gitGraph
    commit id: &quot;A&quot;
    commit id: &quot;B&quot;
    branch feature
    checkout feature
    commit id: &quot;C&quot;
    checkout main
    commit id: &quot;D&quot;
    merge feature
    commit id: &quot;M&quot;
  </pre></div>
<p>上图中，<code>A</code> 是共同祖先，<code>D</code> 是 <code>main</code> 的最新提交，<code>C</code> 是 <code>feature</code> 的最新提交，<code>M</code> 是合并提交。</p>
</li>
</ul>
<h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h3><ul>
<li><strong>非破坏性</strong>：<code>git merge</code> 不会改写任何现有的提交历史。它保留了所有分支的原始历史记录，是一个安全的操作。</li>
<li><strong>可追溯性</strong>：合并提交明确地指出了两个分支何时、何地以及如何被集成。这使得追溯项目的历史、理解分支的生命周期变得容易。</li>
<li><strong>记录分支历史</strong>：通过合并提交，你可以清楚地看到每个分支的开发路径，以及它们是如何汇聚在一起的。</li>
</ul>
<h3 id="1-4-缺点"><a href="#1-4-缺点" class="headerlink" title="1.4 缺点"></a>1.4 缺点</h3><ul>
<li><strong>历史记录复杂</strong>：如果频繁地进行合并，项目的提交历史可能会变得非常复杂和混乱，充斥着大量的合并提交，形成“钻石”形状的非线性历史。</li>
<li><strong>可读性降低</strong>：复杂的历史记录可能会使 <code>git log</code> 输出难以阅读和理解，尤其是在处理大型项目或长期存在的分支时。</li>
</ul>
<h3 id="1-5-适用场景"><a href="#1-5-适用场景" class="headerlink" title="1.5 适用场景"></a>1.5 适用场景</h3><ul>
<li><strong>公共分支集成</strong>：将功能分支合并到长期存在的公共分支（如 <code>develop</code> 或 <code>main</code>）时，通常使用 <code>merge</code> 来保留完整的历史记录。</li>
<li><strong>发布分支合并</strong>：<code>release</code> 分支完成后，合并到 <code>main</code> 和 <code>develop</code> 时，应使用 <code>merge</code>。</li>
<li><strong>需要保留完整历史记录的场景</strong>：例如，审计日志或需要清晰展示所有分支演变路径的项目。</li>
<li><strong>团队协作中已共享的分支</strong>：在团队中共享的功能分支上，通常建议使用 <code>merge</code>，因为 <code>rebase</code> 会改写历史，给其他协作者带来麻烦。</li>
</ul>
<h2 id="二、Git-Rebase-变基"><a href="#二、Git-Rebase-变基" class="headerlink" title="二、Git Rebase (变基)"></a>二、Git Rebase (变基)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong><code>git rebase</code></strong> 命令用于将一系列提交从一个分支移动或复制到另一个分支的顶部。它的核心思想是<strong>重写提交历史</strong>，使得提交看起来就像是在目标分支上顺序进行的，从而创建出一条线性的历史记录。</p>
<h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p>当执行 <code>git rebase &lt;base_branch&gt;</code> 命令时，Git 会执行以下操作：</p>
<ol>
<li>Git 找到当前分支 (<code>HEAD</code>) 和 <code>&lt;base_branch&gt;</code> 之间最新的共同祖先。</li>
<li>它将当前分支上，从共同祖先到当前分支 <code>HEAD</code> 的所有提交<strong>暂时存储</strong>起来（这些是当前分支独有的提交）。</li>
<li>然后，它会将当前分支的 <code>HEAD</code> 移动到 <code>&lt;base_branch&gt;</code> 的最新提交上。</li>
<li>最后，Git 会将之前存储的那些提交<strong>逐个重新应用 (re-apply)</strong> 到新的 <code>HEAD</code> 上。</li>
</ol>
<p><em>重要的是，在重新应用提交时，Git 会为这些提交生成<strong>新的提交哈希 (commit hash)</strong>。</em> 这就是为什么 <code>rebase</code> 会<strong>重写历史</strong>的原因。</p>
<p><strong><code>git rebase</code> 示例：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    gitGraph
    commit id: &quot;A&quot;
    commit id: &quot;B&quot;
    branch feature
    checkout feature
    commit id: &quot;C&quot;
    checkout main
    commit id: &quot;D&quot;
    checkout feature
    commit id: &quot;C&#39;&quot;
    checkout main
    merge feature
    commit id: &quot;E&quot;
  </pre></div>
<p>上图中，<code>A</code> 是共同祖先，<code>D</code> 是 <code>main</code> 的最新提交，<code>C</code> 是 <code>feature</code> 的最新提交。<code>rebase</code> 后，<code>feature</code> 分支的 <code>C</code> 提交被重新应用为 <code>C&#39;</code>，历史记录变得线性。最终 <code>main</code> 合并 <code>feature</code> 只需要快进合并（<code>E</code> 即 <code>C&#39;</code>）。</p>
<h3 id="2-3-优点"><a href="#2-3-优点" class="headerlink" title="2.3 优点"></a>2.3 优点</h3><ul>
<li><strong>清晰、线性的历史记录</strong>：<code>rebase</code> 消除了合并提交，使得项目的提交历史看起来像一条直线，非常整洁和易于阅读。</li>
<li><strong>简化合并</strong>：在 <code>rebase</code> 之后，将功能分支合并回 <code>main</code> 或 <code>develop</code> 通常可以通过<strong>快进合并 (fast-forward merge)</strong> 完成，避免了额外的合并提交。</li>
<li><strong>更容易查找 Bug</strong>：线性的历史记录和更少的合并提交使得使用 <code>git bisect</code> 等工具查找引入 Bug 的提交变得更加容易。</li>
<li><strong>提交优化</strong>：配合 <code>git rebase -i</code> (交互式变基)，可以在合并前清理、修改、压缩或重新排序提交，优化提交历史。</li>
</ul>
<h3 id="2-4-缺点"><a href="#2-4-缺点" class="headerlink" title="2.4 缺点"></a>2.4 缺点</h3><ul>
<li><strong>破坏性</strong>：<code>git rebase</code> 会改写提交历史。被 <code>rebase</code> 的提交会获得新的提交哈希，这会使得 Git 认为它们是全新的提交。</li>
<li><strong>团队协作风险</strong>：<strong>这是 <code>rebase</code> 最大的风险。</strong> 如果你 <code>rebase</code> 了一个已经被推送到远程仓库并且其他团队成员正在其基础上进行开发的分支，那么当其他人尝试与远程仓库同步时，将会遇到历史冲突（因为他们的本地历史与远程历史不匹配），导致复杂的问题。<ul>
<li><strong>黄金法则：</strong> <strong>“不要对已经推送到公共仓库的提交进行 rebase。”</strong></li>
</ul>
</li>
<li><strong>操作复杂性</strong>：相比 <code>merge</code>，<code>rebase</code> 在解决冲突或处理复杂场景时可能需要更深入的 Git 理解。</li>
</ul>
<h3 id="2-5-适用场景"><a href="#2-5-适用场景" class="headerlink" title="2.5 适用场景"></a>2.5 适用场景</h3><ul>
<li><strong>清理个人功能分支</strong>：在将个人开发的功能分支推送到远程或合并到公共分支之前，使用 <code>rebase</code> 将其变基到最新的 <code>develop</code> 或 <code>main</code> 分支上，以保持一个干净、线性的提交历史。</li>
<li><strong>私有分支工作流</strong>：如果你在一个私有的、未共享的分支上工作，并且希望保持提交历史整洁，<code>rebase</code> 是一个好选择。</li>
<li><strong>准备 Pull Request (PR) 或 Merge Request (MR)</strong>：在提交 PR&#x2F;MR 之前，将你的功能分支 <code>rebase</code> 到目标分支的最新状态，可以使你的 PR&#x2F;MR 看起来更整洁，更容易审查和合并。</li>
<li><strong>修改提交历史</strong>：通过 <code>git rebase -i</code> 可以对提交进行修改、合并、删除等操作，用于优化提交历史。</li>
</ul>
<h2 id="三、Merge-vs-Rebase-核心对比"><a href="#三、Merge-vs-Rebase-核心对比" class="headerlink" title="三、Merge vs. Rebase 核心对比"></a>三、Merge vs. Rebase 核心对比</h2><p>下表总结了 <code>git merge</code> 和 <code>git rebase</code> 的主要区别：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Git Merge (合并)</th>
<th align="left">Git Rebase (变基)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>历史记录</strong></td>
<td align="left">非线性，保留所有分支的原始历史，有合并提交。</td>
<td align="left">线性，通过重写历史消除合并提交。</td>
</tr>
<tr>
<td align="left"><strong>提交类型</strong></td>
<td align="left">创建新的合并提交。</td>
<td align="left">重新应用现有提交，生成新的提交哈希。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">非破坏性，非常安全。</td>
<td align="left">破坏性，会改写提交历史，在公共分支上危险。</td>
</tr>
<tr>
<td align="left"><strong>冲突处理</strong></td>
<td align="left">在创建合并提交时一次性解决所有冲突。</td>
<td align="left">在重新应用每个冲突提交时，逐个解决冲突。</td>
</tr>
<tr>
<td align="left"><strong>易用性</strong></td>
<td align="left">相对简单，适合新手。</td>
<td align="left">相对复杂，需要更深入的理解，可能造成困惑。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">公共分支集成、需要保留完整历史的项目、已共享的分支。</td>
<td align="left">清理个人功能分支、优化提交历史、使 PR 更简洁。</td>
</tr>
<tr>
<td align="left"><strong>何时避免</strong></td>
<td align="left">几乎没有需要避免的场景，除非追求极致线性历史。</td>
<td align="left"><strong>绝不能</strong>对已经推送到公共仓库的提交进行 rebase。</td>
</tr>
</tbody></table>
<h2 id="四、最佳实践与建议"><a href="#四、最佳实践与建议" class="headerlink" title="四、最佳实践与建议"></a>四、最佳实践与建议</h2><ol>
<li><strong>坚持“黄金法则”：</strong> <strong>永远不要 <code>rebase</code> 已经推送到远程仓库并与其他团队成员共享的分支上的提交。</strong> 如果你这样做了，你将改写历史，导致其他协作者在与远程同步时遇到冲突。为了修复这些问题，他们将不得不回滚或强制推送，这会带来混乱和数据丢失的风险。</li>
<li><strong>在功能分支上使用 <code>rebase</code>：</strong><ul>
<li>在将你的本地功能分支合并到 <code>develop</code> 或 <code>main</code> 之前，你可以将其 <code>rebase</code> 到目标分支的最新版本。这会使你的功能分支看起来像是从最新的 <code>develop</code>&#x2F;<code>main</code> 开始的，从而实现快进合并，保持主分支的整洁。</li>
<li>这个操作应该在你<strong>本地的功能分支</strong>上进行，并且在<strong>推送到远程之前</strong>完成。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-branch</span><br><span class="line">git pull origin feature-branch <span class="comment"># 确保本地 feature-branch 最新</span></span><br><span class="line">git rebase develop <span class="comment"># 将 feature-branch 变基到 develop</span></span><br><span class="line"><span class="comment"># 如果有冲突，解决冲突后执行 `git add .` 和 `git rebase --continue`</span></span><br><span class="line">git push origin feature-branch --force-with-lease <span class="comment"># 变基后需要强制推送 (仅限个人未共享分支)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>在公共分支上使用 <code>merge</code>：</strong><ul>
<li>对于 <code>develop</code>、<code>main</code> 或 <code>main</code> 等公共分支，通常建议使用 <code>merge</code>。这保留了所有历史记录，包括功能分支何时何地被集成。</li>
<li>考虑使用 <code>git merge --no-ff</code>：即使可以进行快进合并，<code>--no-ff</code> 选项也会强制创建一个合并提交。这能显式记录合并事件，即使历史记录是线性的，也能清晰地看到功能的集成点。</li>
<li>示例 (将 feature 合并到 develop)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull origin develop <span class="comment"># 确保本地 develop 最新</span></span><br><span class="line">git merge --no-ff feature-branch</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>根据团队协议选择：</strong> 最终，选择 <code>merge</code> 还是 <code>rebase</code> 很大程度上取决于团队的工作流偏好。重要的是团队成员之间达成共识，并严格遵守统一的实践。</li>
<li><strong>交互式变基 (<code>git rebase -i</code>)：</strong> 这是一种强大的工具，可以在将提交合并到主线之前，清理和优化你的提交历史（如合并多个小提交、修改提交信息、删除不需要的提交）。这应该只在你的<strong>本地非共享分支</strong>上进行。</li>
</ol>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><code>git merge</code> 和 <code>git rebase</code> 各有其优势和劣势。<code>merge</code> 是非破坏性的，保留了完整的项目历史，但可能导致复杂的提交图。<code>rebase</code> 创建了干净、线性的历史记录，但会重写历史，在处理已共享的分支时存在风险。</p>
<p>理解它们的工作原理和适用场景，并遵循“不在公共分支上 <code>rebase</code>”的黄金法则，是高效利用 Git 进行版本控制的关键。在实际项目中，往往会结合使用这两种策略：在个人功能开发阶段，可以利用 <code>rebase</code> 保持提交历史的整洁；在将功能集成到公共分支时，则倾向于使用 <code>merge</code> 来保留完整的集成记录。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/25324aef0ab0/">https://blog.tbf1211.xx.kg/25324aef0ab0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/Git/">Git</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-08.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/25dabaebd519/" title="JUnit (单元测试框架) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JUnit (单元测试框架) 详解</div></div><div class="info-2"><div class="info-item-1"> JUnit 是一个开源的 Java 语言单元测试框架，也是 Java 开发中最常用、最具影响力的测试框架之一。它提供了一套用于编写和运行可重复测试的工具集，旨在帮助开发者实现测试驱动开发 (TDD) 和确保代码质量。JUnit 是 xUnit 家族的一员，它的核心理念是：先编写测试，再编写业务代码，并确保测试能够通过，从而验证代码的正确性。  核心思想：JUnit 提供了一套标准化的注解和断言方法，使得开发者能够以结构化、可自动化执行的方式，对程序中的最小可测试单元（通常是方法）进行验证，确保其行为符合预期。    一、为什么需要单元测试与 JUnit？在软件开发过程中，测试是不可或缺的一环。单元测试尤其重要，它专注于测试程序中最小的功能模块（例如一个类的一个方法）。没有单元测试，开发者会面临以下挑战：  代码质量难以保证：无法及时发现代码中的逻辑错误、边界条件问题。 回归测试困难：修改现有代码后，很难确保没有引入新的 Bug 到原有功能中。 重构风险高：缺乏测试覆盖的代码，在重构时容易引入新的问题，因为无法快速验证重构后的代码是否依然正确。 调试成本高：问题往往在集成测试或生...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/a8310012f32b/" title="Git 从开发测试到上线的流程详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">Git 从开发测试到上线的流程详解</div></div><div class="info-2"><div class="info-item-1"> Git 作为一个分布式版本控制系统，在现代软件开发中扮演着核心角色。它不仅能追踪代码变更、协调团队协作，还能支撑复杂的开发、测试到上线的全流程管理。本文将详细阐述基于 Git 的标准开发、测试到上线流程，旨在提供一个清晰、可操作的实践指南。  核心思想：利用 Git 的分支管理能力，清晰地划分开发阶段，确保代码质量，并实现高效、可追溯的部署。   一、Git 分支模型选择在开始流程之前，选择一个合适的分支模型至关重要。常见的分支模型包括 Git Flow 和 GitHub Flow (或 GitLab Flow)。 1.1 Git FlowGit Flow 是一种较为复杂的、结构化的分支模型，适用于发布周期较长、版本发布严格的项目。它定义了五种主要分支：  main (或 master) 分支：用于存放生产环境稳定代码。只有当代码准备好发布时，才合并到此分支。每次合并到 main 都应该打上版本标签。 develop 分支：用于存放最新开发完成的代码，是所有功能开发分支的集成点。 feature 分支：用于开发新功能。通常从 develop 分支创建，完成功能开发后合并回 de...</div></div></div></a><a class="pagination-related" href="/30f43e04d28e/" title="中断机制详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="info-item-2">中断机制详解</div></div><div class="info-2"><div class="info-item-1"> 中断 (Interrupt) 是指当 CPU 在执行程序时，由于发生了某个事件（如 I&#x2F;O 完成、硬件故障、定时器溢出、程序错误等），导致 CPU 暂停当前程序的执行，转而去处理该事件，处理完毕后，再回到原程序继续执行的过程。中断是实现多任务、设备管理、错误处理等操作系统核心功能的基础。  核心思想：打破 CPU 顺序执行指令的模式，允许外部或内部事件暂时接管 CPU 控制权，提高系统效率和响应性。   一、为什么需要中断？在没有中断的早期计算机系统中，CPU 必须通过轮询 (Polling) 的方式来检查外部设备的状态。例如，CPU 需要不断地询问键盘是否有按键按下，或者打印机是否完成打印。这种方式存在明显的问题：  效率低下：CPU 大部分时间都在等待慢速设备，造成宝贵的计算资源浪费。 实时性差：如果 CPU 在执行一个耗时任务，无法及时响应其他设备的请求。 编程复杂：程序员需要手动编写大量轮询代码，增加了开发难度。  中断机制旨在解决这些问题，提供一种更高效、更灵活的事件处理方式：  提高 CPU 利用率：当设备忙碌或等待事件时，CPU 可以执行其他任务，而不是...</div></div></div></a><a class="pagination-related" href="/5b9845e2d12f/" title="电平详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="info-item-2">电平详解</div></div><div class="info-2"><div class="info-item-1"> 在电子工程和通信领域，电平 (Level) 是一个基础且重要的概念。它通常指代信号的幅值或强度，尤其是在特定的参考点或参考值下。电平可以是电压、电流、功率或其他物理量的度量。在数字电路中，电平用于区分二进制状态（0 和 1）；在模拟电路中，电平则表示信号的瞬时幅值。理解电平对于正确设计、分析和调试电子系统至关重要。  核心思想： 电平是信号强度的一种度量，在不同应用场景下具有不同的含义和标准，但其本质都是为了量化和区分信号状态或强度。   一、电平的基本概念电平最常见的表示形式是电压电平，因为它直接反映了电路中电势的差异。  电压 (Voltage)：两点之间的电势差，单位是伏特 (V)。 电流 (Current)：电荷的流动，单位是安培 (A)。 功率 (Power)：单位时间内电能的转换或传输速率，单位是瓦特 (W)。  电平的概念通常伴随着参考点。在电路中，我们通常将一个点（如地线 GND）定义为 0V 参考点，然后测量其他点的电势相对于这个参考点的电压。 二、数字电平 (Digital Logic Levels)在数字电路中，电平用于表示二进制数据“0”和“1”。为了确...</div></div></div></a><a class="pagination-related" href="/eb73d4317e80/" title="数字电子电路详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-12</div><div class="info-item-2">数字电子电路详解</div></div><div class="info-2"><div class="info-item-1"> 数字电子电路 是处理离散信号的电路，这些信号通常只有有限的几个状态，最常见的是两个状态（如高电平&#x2F;低电平，1&#x2F;0）。它构成了现代计算机、通信系统和各种智能设备的基础。与模拟电子电路处理连续信号不同，数字电路通过逻辑运算和存储实现复杂的功能。  核心思想： 利用半导体器件的开关特性，实现二进制逻辑运算（布尔代数）和状态存储，进而构建复杂的数字系统，处理、存储和传输信息。   一、数字电子电路概述1.1 什么是数字信号？数字信号是指在时间上和数值上都是离散的信号。最简单的数字信号是二进制信号，它只有两个状态，通常用电压的高电平（H 或 1）和低电平（L 或 0）来表示。 例如：  计算机内部的数据 开关的状态（开&#x2F;关） CD&#x2F;DVD&#x2F;蓝光光盘中存储的信息 以太网数据包  1.2 数字电路的优点 抗干扰能力强：由于只有两个状态，较小的噪声不容易改变信号的逻辑状态。 易于设计和实现：基于逻辑门和布尔代数，设计方法相对标准化。 易于存储和处理：二进制数据可以方便地存储在寄存器、存储器中，并通过算法进行复杂处理。 可编程性强：通过改变软件或...</div></div></div></a><a class="pagination-related" href="/fa69350b38ad/" title="Git Submodules 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-16</div><div class="info-item-2">Git Submodules 详解</div></div><div class="info-2"><div class="info-item-1"> Git Submodule (子模块) 是 Git 版本控制系统提供的一种机制，允许一个 Git 仓库 (称为主仓库或 superproject) 将另一个完整的 Git 仓库 (称为子模块) 作为其子目录嵌入。主仓库会记录子模块的特定提交 (specific commit)，而不是其最新的 HEAD 状态。这意味着，当你克隆主仓库时，你并不会自动获得子模块的所有历史，而是获得其在主仓库中被记录的那个确切版本。  核心思想：将一个独立的 Git 仓库作为另一个 Git 仓库的子目录进行管理，并追踪子模块的特定提交，以实现外部依赖管理、模块化或代码复用，同时保持各仓库的独立性。   一、为什么需要 Git Submodules？在软件开发中，经常会遇到以下场景：  管理外部依赖：你的项目依赖于一个由第三方维护的库或框架，你希望将其代码包含在自己的仓库中，但又不想复制粘贴或手动更新。 模块化大型项目：一个大型项目由多个相对独立的组件构成，这些组件各自有独立的开发生命周期和版本控制，但需要在一个主项目中统一协调。 代码复用：多个项目共享同一段代码或一个公共库，你希望这段共享代码能够独...</div></div></div></a><a class="pagination-related" href="/4d4d04e1eb80/" title="脉冲信号详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-15</div><div class="info-item-2">脉冲信号详解</div></div><div class="info-2"><div class="info-item-1"> 脉冲信号 (Pulse Signal) 是一种在短时间内快速变化并随后迅速恢复到初始状态的非连续信号。它通常由一个或多个短暂的电压或电流“突变”组成，这些突变相对于其持续的背景状态具有显著的幅值。脉冲信号是数字电路、通信、控制系统、雷达、医疗设备等众多领域的基础，承载着信息、控制时序或触发事件。  核心思想： 脉冲信号通过其幅值、宽度、周期、频率、占空比等特性来编码信息、驱动操作或提供时间基准。   一、脉冲信号的基本特性理想的脉冲信号是矩形的，但在实际中，脉冲往往具有一定的上升和下降时间。      graph TD     subgraph 理想脉冲特性         A[低电平] --&gt; B{上升沿}         B --&gt; C[&quot;高电平 (脉冲幅值)&quot;]         C --&gt; D{下降沿}         D --&gt; A     end     1.1 幅值 (Amplitude) 定义：脉冲信号从基准电平（通常是低电平）到峰值电平的电压或电流差。 作用：决定了脉冲的“强度”，在数字电路中通常对应逻辑高电平电压。 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">466</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Git-Merge-%E5%90%88%E5%B9%B6"><span class="toc-text">一、Git Merge (合并)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.2 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BC%98%E7%82%B9"><span class="toc-text">1.3 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">1.4 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1.5 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Git-Rebase-%E5%8F%98%E5%9F%BA"><span class="toc-text">二、Git Rebase (变基)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.2 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BC%98%E7%82%B9"><span class="toc-text">2.3 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">2.4 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.5 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Merge-vs-Rebase-%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94"><span class="toc-text">三、Merge vs. Rebase 核心对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-text">四、最佳实践与建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-08.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>