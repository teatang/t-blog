<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git Merge vs. Rebase 对比详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Git 版本控制系统中，git merge 和 git rebase 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。  核心思想：git merge 通过创建新的合并提交来集成更改，保留">
<meta property="og:type" content="article">
<meta property="og:title" content="Git Merge vs. Rebase 对比详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/25324aef0ab0/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在 Git 版本控制系统中，git merge 和 git rebase 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。  核心思想：git merge 通过创建新的合并提交来集成更改，保留">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg">
<meta property="article:published_time" content="2024-02-14T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-30T03:20:58.341Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="Git">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git Merge vs. Rebase 对比详解",
  "url": "https://blog.tbf1211.xx.kg/25324aef0ab0/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg",
  "datePublished": "2024-02-14T22:24:00.000Z",
  "dateModified": "2026-01-30T03:20:58.341Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/25324aef0ab0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git Merge vs. Rebase 对比详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-27.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Git Merge vs. Rebase 对比详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git Merge vs. Rebase 对比详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-02-14T22:24:00.000Z" title="发表于 2024-02-15 06:24:00">2024-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在 Git 版本控制系统中，<code>git merge</code> 和 <code>git rebase</code> 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<code>git merge</code> 通过创建<strong>新的合并提交</strong>来集成更改，保留了所有分支的历史；<code>git rebase</code> 通过<strong>重写提交历史</strong>将一个分支的提交应用到另一个分支的顶部，从而创建线性的历史记录。</p>
</div>
<hr>
<h2 id="一、Git-Merge-合并"><a href="#一、Git-Merge-合并" class="headerlink" title="一、Git Merge (合并)"></a>一、Git Merge (合并)</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong><code>git merge</code></strong> 命令用于将来自一个或多个分支的独立开发历史合并到当前分支。它通过创建一个<strong>新的合并提交 (merge commit)</strong> 来实现这一点，这个合并提交的父提交指向两个被合并分支的最新提交。这意味着 <code>git merge</code> 会保留所有分支的原始提交历史，并显式地记录合并发生的时间和地点。</p>
<h3 id="1-2-工作原理"><a href="#1-2-工作原理" class="headerlink" title="1.2 工作原理"></a>1.2 工作原理</h3><p>当执行 <code>git merge &lt;branch_name&gt;</code> 时：</p>
<ol>
<li>Git 找到当前分支 (<code>HEAD</code>) 和 <code>&lt;branch_name&gt;</code> 之间最新的共同祖先 (common ancestor)。</li>
<li>它将 <code>&lt;branch_name&gt;</code> 上的更改应用到当前分支，并尝试将它们合并。</li>
<li>如果两个分支的历史已经分叉（即在共同祖先之后都有各自的提交），并且存在冲突，你需要手动解决冲突。</li>
<li>解决冲突后，Git 会创建一个新的合并提交，这个提交有两个父提交：一个是当前分支的最新提交，另一个是 <code>&lt;branch_name&gt;</code> 的最新提交。</li>
</ol>
<p><strong>两种主要合并方式：</strong></p>
<ul>
<li><p><strong>快进合并 (Fast-Forward Merge)</strong>：如果当前分支的最新提交是另一个分支的直接祖先，Git 会直接将当前分支的指针向前移动到另一个分支的最新提交，不创建新的合并提交。这种情况只发生在合并分支没有在共同祖先之后有任何新的提交时。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    gitGraph
    commit id: &quot;C1&quot;
    commit id: &quot;C2&quot;
    branch feature
    checkout feature
    commit id: &quot;F1&quot;
    commit id: &quot;F2&quot;
    checkout main
    merge feature
  </pre></div>
<p><em>上述图示中，如果main分支只有C1、C2，feature分支有F1、F2，且main是feature的直接祖先，则merge feature后，main会直接指向F2，形成一条直线。</em></p>
</li>
<li><p><strong>三方合并 (Three-Way Merge)</strong>：当两个分支的历史已经分叉时，Git 会创建一个新的合并提交。这是最常见的合并方式，也是 <code>git merge</code> 的核心特性。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    gitGraph
    commit id: &quot;A&quot;
    commit id: &quot;B&quot;
    branch feature
    checkout feature
    commit id: &quot;C&quot;
    checkout main
    commit id: &quot;D&quot;
    merge feature
    commit id: &quot;M&quot;
  </pre></div>
<p>上图中，<code>A</code> 是共同祖先，<code>D</code> 是 <code>main</code> 的最新提交，<code>C</code> 是 <code>feature</code> 的最新提交，<code>M</code> 是合并提交。</p>
</li>
</ul>
<h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h3><ul>
<li><strong>非破坏性</strong>：<code>git merge</code> 不会改写任何现有的提交历史。它保留了所有分支的原始历史记录，是一个安全的操作。</li>
<li><strong>可追溯性</strong>：合并提交明确地指出了两个分支何时、何地以及如何被集成。这使得追溯项目的历史、理解分支的生命周期变得容易。</li>
<li><strong>记录分支历史</strong>：通过合并提交，你可以清楚地看到每个分支的开发路径，以及它们是如何汇聚在一起的。</li>
</ul>
<h3 id="1-4-缺点"><a href="#1-4-缺点" class="headerlink" title="1.4 缺点"></a>1.4 缺点</h3><ul>
<li><strong>历史记录复杂</strong>：如果频繁地进行合并，项目的提交历史可能会变得非常复杂和混乱，充斥着大量的合并提交，形成“钻石”形状的非线性历史。</li>
<li><strong>可读性降低</strong>：复杂的历史记录可能会使 <code>git log</code> 输出难以阅读和理解，尤其是在处理大型项目或长期存在的分支时。</li>
</ul>
<h3 id="1-5-适用场景"><a href="#1-5-适用场景" class="headerlink" title="1.5 适用场景"></a>1.5 适用场景</h3><ul>
<li><strong>公共分支集成</strong>：将功能分支合并到长期存在的公共分支（如 <code>develop</code> 或 <code>main</code>）时，通常使用 <code>merge</code> 来保留完整的历史记录。</li>
<li><strong>发布分支合并</strong>：<code>release</code> 分支完成后，合并到 <code>main</code> 和 <code>develop</code> 时，应使用 <code>merge</code>。</li>
<li><strong>需要保留完整历史记录的场景</strong>：例如，审计日志或需要清晰展示所有分支演变路径的项目。</li>
<li><strong>团队协作中已共享的分支</strong>：在团队中共享的功能分支上，通常建议使用 <code>merge</code>，因为 <code>rebase</code> 会改写历史，给其他协作者带来麻烦。</li>
</ul>
<h2 id="二、Git-Rebase-变基"><a href="#二、Git-Rebase-变基" class="headerlink" title="二、Git Rebase (变基)"></a>二、Git Rebase (变基)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong><code>git rebase</code></strong> 命令用于将一系列提交从一个分支移动或复制到另一个分支的顶部。它的核心思想是<strong>重写提交历史</strong>，使得提交看起来就像是在目标分支上顺序进行的，从而创建出一条线性的历史记录。</p>
<h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p>当执行 <code>git rebase &lt;base_branch&gt;</code> 命令时，Git 会执行以下操作：</p>
<ol>
<li>Git 找到当前分支 (<code>HEAD</code>) 和 <code>&lt;base_branch&gt;</code> 之间最新的共同祖先。</li>
<li>它将当前分支上，从共同祖先到当前分支 <code>HEAD</code> 的所有提交<strong>暂时存储</strong>起来（这些是当前分支独有的提交）。</li>
<li>然后，它会将当前分支的 <code>HEAD</code> 移动到 <code>&lt;base_branch&gt;</code> 的最新提交上。</li>
<li>最后，Git 会将之前存储的那些提交<strong>逐个重新应用 (re-apply)</strong> 到新的 <code>HEAD</code> 上。</li>
</ol>
<p><em>重要的是，在重新应用提交时，Git 会为这些提交生成<strong>新的提交哈希 (commit hash)</strong>。</em> 这就是为什么 <code>rebase</code> 会<strong>重写历史</strong>的原因。</p>
<p><strong><code>git rebase</code> 示例：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    gitGraph
    commit id: &quot;A&quot;
    commit id: &quot;B&quot;
    branch feature
    checkout feature
    commit id: &quot;C&quot;
    checkout main
    commit id: &quot;D&quot;
    checkout feature
    commit id: &quot;C&#39;&quot;
    checkout main
    merge feature
    commit id: &quot;E&quot;
  </pre></div>
<p>上图中，<code>A</code> 是共同祖先，<code>D</code> 是 <code>main</code> 的最新提交，<code>C</code> 是 <code>feature</code> 的最新提交。<code>rebase</code> 后，<code>feature</code> 分支的 <code>C</code> 提交被重新应用为 <code>C&#39;</code>，历史记录变得线性。最终 <code>main</code> 合并 <code>feature</code> 只需要快进合并（<code>E</code> 即 <code>C&#39;</code>）。</p>
<h3 id="2-3-优点"><a href="#2-3-优点" class="headerlink" title="2.3 优点"></a>2.3 优点</h3><ul>
<li><strong>清晰、线性的历史记录</strong>：<code>rebase</code> 消除了合并提交，使得项目的提交历史看起来像一条直线，非常整洁和易于阅读。</li>
<li><strong>简化合并</strong>：在 <code>rebase</code> 之后，将功能分支合并回 <code>main</code> 或 <code>develop</code> 通常可以通过<strong>快进合并 (fast-forward merge)</strong> 完成，避免了额外的合并提交。</li>
<li><strong>更容易查找 Bug</strong>：线性的历史记录和更少的合并提交使得使用 <code>git bisect</code> 等工具查找引入 Bug 的提交变得更加容易。</li>
<li><strong>提交优化</strong>：配合 <code>git rebase -i</code> (交互式变基)，可以在合并前清理、修改、压缩或重新排序提交，优化提交历史。</li>
</ul>
<h3 id="2-4-缺点"><a href="#2-4-缺点" class="headerlink" title="2.4 缺点"></a>2.4 缺点</h3><ul>
<li><strong>破坏性</strong>：<code>git rebase</code> 会改写提交历史。被 <code>rebase</code> 的提交会获得新的提交哈希，这会使得 Git 认为它们是全新的提交。</li>
<li><strong>团队协作风险</strong>：<strong>这是 <code>rebase</code> 最大的风险。</strong> 如果你 <code>rebase</code> 了一个已经被推送到远程仓库并且其他团队成员正在其基础上进行开发的分支，那么当其他人尝试与远程仓库同步时，将会遇到历史冲突（因为他们的本地历史与远程历史不匹配），导致复杂的问题。<ul>
<li><strong>黄金法则：</strong> <strong>“不要对已经推送到公共仓库的提交进行 rebase。”</strong></li>
</ul>
</li>
<li><strong>操作复杂性</strong>：相比 <code>merge</code>，<code>rebase</code> 在解决冲突或处理复杂场景时可能需要更深入的 Git 理解。</li>
</ul>
<h3 id="2-5-适用场景"><a href="#2-5-适用场景" class="headerlink" title="2.5 适用场景"></a>2.5 适用场景</h3><ul>
<li><strong>清理个人功能分支</strong>：在将个人开发的功能分支推送到远程或合并到公共分支之前，使用 <code>rebase</code> 将其变基到最新的 <code>develop</code> 或 <code>main</code> 分支上，以保持一个干净、线性的提交历史。</li>
<li><strong>私有分支工作流</strong>：如果你在一个私有的、未共享的分支上工作，并且希望保持提交历史整洁，<code>rebase</code> 是一个好选择。</li>
<li><strong>准备 Pull Request (PR) 或 Merge Request (MR)</strong>：在提交 PR&#x2F;MR 之前，将你的功能分支 <code>rebase</code> 到目标分支的最新状态，可以使你的 PR&#x2F;MR 看起来更整洁，更容易审查和合并。</li>
<li><strong>修改提交历史</strong>：通过 <code>git rebase -i</code> 可以对提交进行修改、合并、删除等操作，用于优化提交历史。</li>
</ul>
<h2 id="三、Merge-vs-Rebase-核心对比"><a href="#三、Merge-vs-Rebase-核心对比" class="headerlink" title="三、Merge vs. Rebase 核心对比"></a>三、Merge vs. Rebase 核心对比</h2><p>下表总结了 <code>git merge</code> 和 <code>git rebase</code> 的主要区别：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Git Merge (合并)</th>
<th align="left">Git Rebase (变基)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>历史记录</strong></td>
<td align="left">非线性，保留所有分支的原始历史，有合并提交。</td>
<td align="left">线性，通过重写历史消除合并提交。</td>
</tr>
<tr>
<td align="left"><strong>提交类型</strong></td>
<td align="left">创建新的合并提交。</td>
<td align="left">重新应用现有提交，生成新的提交哈希。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">非破坏性，非常安全。</td>
<td align="left">破坏性，会改写提交历史，在公共分支上危险。</td>
</tr>
<tr>
<td align="left"><strong>冲突处理</strong></td>
<td align="left">在创建合并提交时一次性解决所有冲突。</td>
<td align="left">在重新应用每个冲突提交时，逐个解决冲突。</td>
</tr>
<tr>
<td align="left"><strong>易用性</strong></td>
<td align="left">相对简单，适合新手。</td>
<td align="left">相对复杂，需要更深入的理解，可能造成困惑。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">公共分支集成、需要保留完整历史的项目、已共享的分支。</td>
<td align="left">清理个人功能分支、优化提交历史、使 PR 更简洁。</td>
</tr>
<tr>
<td align="left"><strong>何时避免</strong></td>
<td align="left">几乎没有需要避免的场景，除非追求极致线性历史。</td>
<td align="left"><strong>绝不能</strong>对已经推送到公共仓库的提交进行 rebase。</td>
</tr>
</tbody></table>
<h2 id="四、最佳实践与建议"><a href="#四、最佳实践与建议" class="headerlink" title="四、最佳实践与建议"></a>四、最佳实践与建议</h2><ol>
<li><strong>坚持“黄金法则”：</strong> <strong>永远不要 <code>rebase</code> 已经推送到远程仓库并与其他团队成员共享的分支上的提交。</strong> 如果你这样做了，你将改写历史，导致其他协作者在与远程同步时遇到冲突。为了修复这些问题，他们将不得不回滚或强制推送，这会带来混乱和数据丢失的风险。</li>
<li><strong>在功能分支上使用 <code>rebase</code>：</strong><ul>
<li>在将你的本地功能分支合并到 <code>develop</code> 或 <code>main</code> 之前，你可以将其 <code>rebase</code> 到目标分支的最新版本。这会使你的功能分支看起来像是从最新的 <code>develop</code>&#x2F;<code>main</code> 开始的，从而实现快进合并，保持主分支的整洁。</li>
<li>这个操作应该在你<strong>本地的功能分支</strong>上进行，并且在<strong>推送到远程之前</strong>完成。</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-branch</span><br><span class="line">git pull origin feature-branch <span class="comment"># 确保本地 feature-branch 最新</span></span><br><span class="line">git rebase develop <span class="comment"># 将 feature-branch 变基到 develop</span></span><br><span class="line"><span class="comment"># 如果有冲突，解决冲突后执行 `git add .` 和 `git rebase --continue`</span></span><br><span class="line">git push origin feature-branch --force-with-lease <span class="comment"># 变基后需要强制推送 (仅限个人未共享分支)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>在公共分支上使用 <code>merge</code>：</strong><ul>
<li>对于 <code>develop</code>、<code>main</code> 或 <code>main</code> 等公共分支，通常建议使用 <code>merge</code>。这保留了所有历史记录，包括功能分支何时何地被集成。</li>
<li>考虑使用 <code>git merge --no-ff</code>：即使可以进行快进合并，<code>--no-ff</code> 选项也会强制创建一个合并提交。这能显式记录合并事件，即使历史记录是线性的，也能清晰地看到功能的集成点。</li>
<li>示例 (将 feature 合并到 develop)：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull origin develop <span class="comment"># 确保本地 develop 最新</span></span><br><span class="line">git merge --no-ff feature-branch</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>根据团队协议选择：</strong> 最终，选择 <code>merge</code> 还是 <code>rebase</code> 很大程度上取决于团队的工作流偏好。重要的是团队成员之间达成共识，并严格遵守统一的实践。</li>
<li><strong>交互式变基 (<code>git rebase -i</code>)：</strong> 这是一种强大的工具，可以在将提交合并到主线之前，清理和优化你的提交历史（如合并多个小提交、修改提交信息、删除不需要的提交）。这应该只在你的<strong>本地非共享分支</strong>上进行。</li>
</ol>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><code>git merge</code> 和 <code>git rebase</code> 各有其优势和劣势。<code>merge</code> 是非破坏性的，保留了完整的项目历史，但可能导致复杂的提交图。<code>rebase</code> 创建了干净、线性的历史记录，但会重写历史，在处理已共享的分支时存在风险。</p>
<p>理解它们的工作原理和适用场景，并遵循“不在公共分支上 <code>rebase</code>”的黄金法则，是高效利用 Git 进行版本控制的关键。在实际项目中，往往会结合使用这两种策略：在个人功能开发阶段，可以利用 <code>rebase</code> 保持提交历史的整洁；在将功能集成到公共分支时，则倾向于使用 <code>merge</code> 来保留完整的集成记录。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/25324aef0ab0/">https://blog.tbf1211.xx.kg/25324aef0ab0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/Git/">Git</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-27.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/25dabaebd519/" title="JUnit (单元测试框架) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JUnit (单元测试框架) 详解</div></div><div class="info-2"><div class="info-item-1"> JUnit 是一个开源的 Java 语言单元测试框架，也是 Java 开发中最常用、最具影响力的测试框架之一。它提供了一套用于编写和运行可重复测试的工具集，旨在帮助开发者实现测试驱动开发 (TDD) 和确保代码质量。JUnit 是 xUnit 家族的一员，它的核心理念是：先编写测试，再编写业务代码，并确保测试能够通过，从而验证代码的正确性。  核心思想：JUnit 提供了一套标准化的注解和断言方法，使得开发者能够以结构化、可自动化执行的方式，对程序中的最小可测试单元（通常是方法）进行验证，确保其行为符合预期。    一、为什么需要单元测试与 JUnit？在软件开发过程中，测试是不可或缺的一环。单元测试尤其重要，它专注于测试程序中最小的功能模块（例如一个类的一个方法）。没有单元测试，开发者会面临以下挑战：  代码质量难以保证：无法及时发现代码中的逻辑错误、边界条件问题。 回归测试困难：修改现有代码后，很难确保没有引入新的 Bug 到原有功能中。 重构风险高：缺乏测试覆盖的代码，在重构时容易引入新的问题，因为无法快速验证重构后的代码是否依然正确。 调试成本高：问题往往在集成测试或生...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/a8310012f32b/" title="Git 从开发测试到上线的流程详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">Git 从开发测试到上线的流程详解</div></div><div class="info-2"><div class="info-item-1"> Git 作为一个分布式版本控制系统，在现代软件开发中扮演着核心角色。它不仅能追踪代码变更、协调团队协作，还能支撑复杂的开发、测试到上线的全流程管理。本文将详细阐述基于 Git 的标准开发、测试到上线流程，旨在提供一个清晰、可操作的实践指南。  核心思想：利用 Git 的分支管理能力，清晰地划分开发阶段，确保代码质量，并实现高效、可追溯的部署。   一、Git 分支模型选择在开始流程之前，选择一个合适的分支模型至关重要。常见的分支模型包括 Git Flow 和 GitHub Flow (或 GitLab Flow)。 1.1 Git FlowGit Flow 是一种较为复杂的、结构化的分支模型，适用于发布周期较长、版本发布严格的项目。它定义了五种主要分支：  main (或 master) 分支：用于存放生产环境稳定代码。只有当代码准备好发布时，才合并到此分支。每次合并到 main 都应该打上版本标签。 develop 分支：用于存放最新开发完成的代码，是所有功能开发分支的集成点。 feature 分支：用于开发新功能。通常从 develop 分支创建，完成功能开发后合并回 de...</div></div></div></a><a class="pagination-related" href="/876a758cde0d/" title=".gitignore 与 .gitattributes 文件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="info-item-2">.gitignore 与 .gitattributes 文件详解</div></div><div class="info-2"><div class="info-item-1"> .gitignore 和 .gitattributes 是 Git 版本控制系统中两个重要的配置文件，它们帮助开发者精细地控制 Git 如何处理工作目录中的文件。gitignore 主要用于忽略不应该被版本控制的文件，而 gitattributes 则用于定义不同文件的属性，影响 Git 存储和比较文件的方式。理解和正确使用这两个文件对于维护干净、高效且一致的 Git 仓库至关重要。  核心思想：  .gitignore 告诉 Git 哪些文件或目录应该被忽略，不纳入版本控制。 .gitattributes 告诉 Git 如何对待特定类型的文件，例如行尾符、合并策略、文本转换等。    一、.gitignore 文件详解.gitignore 文件用于指定 Git 应该忽略哪些文件或目录。 这些被忽略的文件不会被 Git 跟踪，也不会被添加到仓库中。这对于排除构建产物、日志文件、敏感配置、IDE 特定文件等内容非常有用，可以保持仓库的整洁，避免提交不必要的文件，并减少仓库大小。 1.1 工作原理Git 在执行 git add 或 git commit 等命令时，会检查工作目录中是...</div></div></div></a><a class="pagination-related" href="/4b5b30fd759e/" title="U8g2lib 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-14</div><div class="info-item-2">U8g2lib 详解</div></div><div class="info-2"><div class="info-item-1"> U8g2lib 是一个用于单色图形显示器 (monochrome graphics displays) 的开源嵌入式图形库。它支持各种 OLED 和 LCD 显示器，例如经典的 128x64 SSD1306 OLED 显示器。U8g2lib 以其广泛的硬件支持、丰富的字体集、高效的内存使用以及强大的图形绘制功能而闻名。它是 U8glib 的继任者，相比 U8glib，U8g2lib 在内存效率和功能上进行了优化和扩展，支持帧缓冲模式 (full buffer) 和页缓冲模式 (page buffer)。  核心思想：提供一个统一的 API 接口，驱动各种单色图形显示器，并提供一套完整的图形绘制和字体渲染功能，同时兼顾嵌入式设备的资源限制。 开发者无需关心底层显示器的驱动细节，专注于界面设计。   一、为什么需要 U8g2lib？嵌入式显示器的痛点在嵌入式系统中集成单色图形显示器时，开发者常常面临以下挑战：  硬件驱动复杂：不同的显示器控制器 (如 SSD1306, SH1106, ST7920) 有不同的初始化序列、命令集和数据传输协议（SPI, I2C, 并行）。手动编写驱动...</div></div></div></a><a class="pagination-related" href="/5b9845e2d12f/" title="电平详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="info-item-2">电平详解</div></div><div class="info-2"><div class="info-item-1"> 在电子工程和通信领域，电平 (Level) 是一个基础且重要的概念。它通常指代信号的幅值或强度，尤其是在特定的参考点或参考值下。电平可以是电压、电流、功率或其他物理量的度量。在数字电路中，电平用于区分二进制状态（0 和 1）；在模拟电路中，电平则表示信号的瞬时幅值。理解电平对于正确设计、分析和调试电子系统至关重要。  核心思想： 电平是信号强度的一种度量，在不同应用场景下具有不同的含义和标准，但其本质都是为了量化和区分信号状态或强度。   一、电平的基本概念电平最常见的表示形式是电压电平，因为它直接反映了电路中电势的差异。  电压 (Voltage)：两点之间的电势差，单位是伏特 (V)。 电流 (Current)：电荷的流动，单位是安培 (A)。 功率 (Power)：单位时间内电能的转换或传输速率，单位是瓦特 (W)。  电平的概念通常伴随着参考点。在电路中，我们通常将一个点（如地线 GND）定义为 0V 参考点，然后测量其他点的电势相对于这个参考点的电压。 二、数字电平 (Digital Logic Levels)在数字电路中，电平用于表示二进制数据“0”和“1”。为了确...</div></div></div></a><a class="pagination-related" href="/30f43e04d28e/" title="中断机制详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="info-item-2">中断机制详解</div></div><div class="info-2"><div class="info-item-1"> 中断 (Interrupt) 是指当 CPU 在执行程序时，由于发生了某个事件（如 I&#x2F;O 完成、硬件故障、定时器溢出、程序错误等），导致 CPU 暂停当前程序的执行，转而去处理该事件，处理完毕后，再回到原程序继续执行的过程。中断是实现多任务、设备管理、错误处理等操作系统核心功能的基础。  核心思想：打破 CPU 顺序执行指令的模式，允许外部或内部事件暂时接管 CPU 控制权，提高系统效率和响应性。   一、为什么需要中断？在没有中断的早期计算机系统中，CPU 必须通过轮询 (Polling) 的方式来检查外部设备的状态。例如，CPU 需要不断地询问键盘是否有按键按下，或者打印机是否完成打印。这种方式存在明显的问题：  效率低下：CPU 大部分时间都在等待慢速设备，造成宝贵的计算资源浪费。 实时性差：如果 CPU 在执行一个耗时任务，无法及时响应其他设备的请求。 编程复杂：程序员需要手动编写大量轮询代码，增加了开发难度。  中断机制旨在解决这些问题，提供一种更高效、更灵活的事件处理方式：  提高 CPU 利用率：当设备忙碌或等待事件时，CPU 可以执行其他任务，而不是...</div></div></div></a><a class="pagination-related" href="/b36f74dae615/" title="FreeRTOS 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-08</div><div class="info-item-2">FreeRTOS 详解</div></div><div class="info-2"><div class="info-item-1"> FreeRTOS 是一个针对嵌入式系统的小型、实时、开源的操作系统 (RTOS)。它提供了一套完整的调度器、任务管理、任务间通信和同步机制，旨在帮助开发者构建高可靠、高效率的嵌入式应用程序。FreeRTOS 以其高度可配置性、低内存占用、易于移植等特点，成为全球最受欢迎的微控制器 RTOS 之一。  FreeRTOS 的核心价值在于：将复杂的嵌入式应用程序分解为多个独立、可并发执行的“任务”，通过实时调度器实现任务的有序执行和高效切换，从而简化程序设计，提高系统的响应性和可靠性。   一、为什么需要 FreeRTOS？在没有操作系统的嵌入式开发中，程序通常采用裸机 (Bare-metal) 循环或中断驱动的方式运行。这在简单应用中尚可，但在复杂应用中会面临诸多挑战：  复杂性：多个功能模块（如传感器读取、通信、用户界面）需要共享 CPU，代码会变得庞大、耦合度高，难以维护。 实时性：重要任务可能因为低优先级任务的长时间运行而被延迟，无法满足严格的时间要求。 并发处理：裸机程序很难实现多个任务的伪并行执行，导致系统响应迟钝。 资源管理：内存、外设等资源的管理混乱，容易引发冲突和 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Git-Merge-%E5%90%88%E5%B9%B6"><span class="toc-text">一、Git Merge (合并)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.2 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BC%98%E7%82%B9"><span class="toc-text">1.3 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">1.4 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1.5 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Git-Rebase-%E5%8F%98%E5%9F%BA"><span class="toc-text">二、Git Rebase (变基)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.2 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BC%98%E7%82%B9"><span class="toc-text">2.3 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">2.4 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.5 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Merge-vs-Rebase-%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94"><span class="toc-text">三、Merge vs. Rebase 核心对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="toc-text">四、最佳实践与建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-27.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>