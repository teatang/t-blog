<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络编程中“流”的详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机网络编程中，“流 (Stream)”是一个非常核心且抽象的概念，它通常用来描述数据在两个实体之间进行传输时，数据流动的抽象表示。尤其在基于 TCP 协议的网络通信中，“流”的概念至关重要，它模拟了数据的顺序传输和持续性连接。理解“流”有助于开发者更好地掌握网络数据传输的本质，并编写出健壮、高效的网络应用程序。  核心思想：网络编程中的“流”是一种抽象，表示数据像水流一样顺序、持续地从一个">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程中“流”的详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/eb77bb139028/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在计算机网络编程中，“流 (Stream)”是一个非常核心且抽象的概念，它通常用来描述数据在两个实体之间进行传输时，数据流动的抽象表示。尤其在基于 TCP 协议的网络通信中，“流”的概念至关重要，它模拟了数据的顺序传输和持续性连接。理解“流”有助于开发者更好地掌握网络数据传输的本质，并编写出健壮、高效的网络应用程序。  核心思想：网络编程中的“流”是一种抽象，表示数据像水流一样顺序、持续地从一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg">
<meta property="article:published_time" content="2023-06-16T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-16T10:25:31.940Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络编程中“流”的详解",
  "url": "https://blog.tbf1211.xx.kg/eb77bb139028/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg",
  "datePublished": "2023-06-16T22:24:00.000Z",
  "dateModified": "2026-01-16T10:25:31.940Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/eb77bb139028/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程中“流”的详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">497</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-09.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">网络编程中“流”的详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">网络编程中“流”的详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-16T22:24:00.000Z" title="发表于 2023-06-17 06:24:00">2023-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在计算机网络编程中，“<strong>流 (Stream)</strong>”是一个非常核心且抽象的概念，它通常用来描述<strong>数据在两个实体之间进行传输时，数据流动的抽象表示</strong>。尤其在基于 TCP 协议的网络通信中，“流”的概念至关重要，它模拟了数据的顺序传输和持续性连接。理解“流”有助于开发者更好地掌握网络数据传输的本质，并编写出健壮、高效的网络应用程序。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>网络编程中的“流”是一种抽象，表示数据像水流一样顺序、持续地从一个端点流向另一个端点，封装了底层网络传输的复杂性。</strong></p>
</div>
<hr>
<h2 id="一、什么是“流”？"><a href="#一、什么是“流”？" class="headerlink" title="一、什么是“流”？"></a>一、什么是“流”？</h2><p>在网络编程中，“流”可以被理解为：</p>
<ol>
<li><strong>数据的有序序列 (Ordered Sequence of Data)</strong>：数据被发送时按照发送的顺序到达接收方，不会乱序。</li>
<li><strong>持续的数据传输通道 (Continuous Data Flow Channel)</strong>：它代表了客户端与服务器之间建立的一种逻辑连接，数据可以在这个连接上持续不断地传输，就像水流一样。</li>
<li><strong>抽象的读写接口 (Abstract Read&#x2F;Write Interface)</strong>：开发者通过操作流接口（例如 <code>read()</code>、<code>write()</code>），而不必关心底层数据的分段、组装、路由等细节。</li>
<li><strong>字节流 (Byte Stream)</strong>：通常情况下，网络流处理的是原始字节，不关心数据的具体格式或含义（例如是文本、图片还是协议数据）。由应用程序自行解析字节的含义。</li>
</ol>
<p>“流”的概念在多种编程语言和框架中都有体现，例如 Java 的 <code>InputStream</code>&#x2F;<code>OutputStream</code>、Python 的 <code>socket</code> 对象的读写方法、Node.js 的 <code>Stream</code> 模块等。</p>
<h2 id="二、“流”在-TCP-和-UDP-中的不同体现"><a href="#二、“流”在-TCP-和-UDP-中的不同体现" class="headerlink" title="二、“流”在 TCP 和 UDP 中的不同体现"></a>二、“流”在 TCP 和 UDP 中的不同体现</h2><p>“流”这个概念在 TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 这两种主要的传输层协议中有着截然不同的体现。</p>
<h3 id="2-1-TCP-连接中的“流”-Stream-oriented"><a href="#2-1-TCP-连接中的“流”-Stream-oriented" class="headerlink" title="2.1 TCP 连接中的“流” (Stream-oriented)"></a>2.1 TCP 连接中的“流” (Stream-oriented)</h3><p>TCP 是一个<strong>面向连接 (Connection-oriented)</strong> 和<strong>面向流 (Stream-oriented)</strong> 的协议。</p>
<ol>
<li><strong>面向连接</strong>：在使用 TCP 进行通信前，客户端和服务器之间必须先建立一个可靠的连接（三次握手）。这个连接一旦建立，就形成了一个逻辑上的“管道”。</li>
<li><strong>面向流</strong>：<ul>
<li><strong>数据像管道水流</strong>：一旦连接建立，应用程序往这个“管道”里写入字节流，对方就能从管道的另一端按顺序读取字节流。发送方写入多少数据，接收方就能读取多少，数据的边界不再由每次发送操作决定。</li>
<li><strong>无消息边界</strong>：TCP 不保留消息记录。发送方可以发送 100 字节，接收方可以分两次（例如先 50 字节，再 50 字节）或一次性读取 100 字节，甚至更多，<code>read</code> 操作可能只读取了部分发送的数据。反之亦然，发送方可以发送多次小块数据，TCP 可能会将其合并为更大的数据包再发送。</li>
<li><strong>数据完整性和顺序性</strong>：TCP 保证数据的可靠传输（无丢失、无重复）和按序到达。这是通过序列号、确认应答、重传机制、流量控制和拥塞控制等一系列复杂机制实现的，这些复杂性都被“流”这个抽象封装起来了。</li>
<li><strong>半关闭 (Half-close)</strong>：TCP 连接可以单方面关闭发送方向的流，而接收方向的流仍可保持开放，反之亦然。</li>
</ul>
</li>
</ol>
<p><strong>用一个比喻来理解 TCP 流：</strong></p>
<p>想象你打电话：</p>
<ul>
<li><strong>建立连接</strong>：你先拨号，对方接听，建立对话。</li>
<li><strong>数据像流</strong>：一旦通话建立，你说的话（数据）会连续不断地传给对方。你不会说“这是第一句”，再等对方确认后说“这是第二句”。</li>
<li><strong>无消息边界</strong>：你可能连续说好几段话，对方可以随时打断你做出回应，也可以等你全部说完再回应。数据接收方并不关心你每句话的长度。</li>
<li><strong>可靠性</strong>：如果你没听清，你会让对方再说一遍。TCP 也是如此，确保数据送达。</li>
</ul>
<h3 id="2-2-UDP-中的“数据报”-Datagram-oriented"><a href="#2-2-UDP-中的“数据报”-Datagram-oriented" class="headerlink" title="2.2 UDP 中的“数据报” (Datagram-oriented)"></a>2.2 UDP 中的“数据报” (Datagram-oriented)</h3><p>UDP 是一个<strong>无连接 (Connectionless)</strong> 和<strong>面向数据报 (Datagram-oriented)</strong> 的协议。</p>
<ol>
<li><strong>无连接</strong>：UDP 在发送数据前不需要建立连接。每个数据报都是一个独立的单元，发送后就“不管”了。</li>
<li><strong>面向数据报</strong>：<ul>
<li><strong>独立的数据包</strong>：每次发送操作都会生成一个独立的数据报。这个数据报有一个明确的边界。</li>
<li><strong>消息边界保留</strong>：发送方发送一个 100 字节的数据报，接收方通常会一次性接收到完整的 100 字节。如果接收方的缓冲区不够大，整个数据报可能会被丢弃。</li>
<li><strong>不保证可靠性、顺序性</strong>：UDP 不保证数据报的可靠传输（可能会丢失）、顺序到达（可能会乱序）和无重复。这些特性需要应用程序自己实现。</li>
<li><strong>适用于广播&#x2F;多播</strong>：UDP 适合发送少量、非关键性数据，或者需要快速传输、允许少量数据丢失的场景（如流媒体、在线游戏）。</li>
</ul>
</li>
</ol>
<p><strong>用一个比喻来理解 UDP 数据报：</strong></p>
<p>想象你寄明信片：</p>
<ul>
<li><strong>无连接</strong>：你直接写好明信片就寄出去，不需要先建立什么“连接”。</li>
<li><strong>数据像数据报</strong>：每张明信片都是一个独立的信息单元。你寄了三张明信片，对方就会收到三张独立的明信片。</li>
<li><strong>有消息边界</strong>：每张明信片都有自己的边界，内容不会和别的明信片混淆。</li>
<li><strong>不可靠性</strong>：邮局不保证明信片能准确投递，可能丢失，可能先后顺序颠倒。</li>
</ul>
<h2 id="三、Socket-与流的关联"><a href="#三、Socket-与流的关联" class="headerlink" title="三、Socket 与流的关联"></a>三、Socket 与流的关联</h2><p>在大多数编程语言中，通过 <strong>Socket (套接字)</strong> 接口进行网络编程。</p>
<ul>
<li><strong>TCP Socket</strong>：创建 TCP Socket 后，进行 <code>connect()</code> 或 <code>accept()</code> 操作，就会建立起一个 TCP 连接。这个连接实际上就形成了一个双向的“流”。应用程序通过对这个 Socket 调用 <code>send()</code>&#x2F;<code>write()</code> 将数据写入流，调用 <code>recv()</code>&#x2F;<code>read()</code> 从流中读取数据。</li>
<li><strong>UDP Socket</strong>：UDP Socket 不会建立持久的“连接流”，每次发送数据都通过 <code>sendto()</code> 指定目标地址，每次接收数据都通过 <code>recvfrom()</code> 从任意来源接收带地址信息的数据报。UDP Socket 通常不具备传统意义上的“流”的特性，更像是数据的“邮筒”。</li>
</ul>
<h3 id="示例-Python-socket-模块"><a href="#示例-Python-socket-模块" class="headerlink" title="示例 (Python socket 模块)"></a>示例 (Python <code>socket</code> 模块)</h3><p><strong>TCP 客户端 (流读写)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.connect((HOST, PORT))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connected to server.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入流</span></span><br><span class="line">    s.sendall(<span class="string">b&#x27;Hello, server!&#x27;</span>)</span><br><span class="line">    s.sendall(<span class="string">b&#x27;How are you?&#x27;</span>) <span class="comment"># 后续写入，与前一次写入的数据在同一个流中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从流中读取，可能一次读完，也可能分多次</span></span><br><span class="line">    data1 = s.recv(<span class="number">1024</span>) <span class="comment"># 尝试读取最多 1024 字节</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received part 1: <span class="subst">&#123;data1.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    data2 = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received part 2: <span class="subst">&#123;data2.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Total received from server: <span class="subst">&#123;data1.decode() + data2.decode()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>TCP 服务器 (流读写)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((HOST, PORT))</span><br><span class="line">    s.listen()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Server listening on <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    conn, addr = s.accept() <span class="comment"># 接受连接</span></span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected by <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">        all_data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = conn.recv(<span class="number">10</span>) <span class="comment"># 每次只读取 10 字节</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            all_data += data</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Received chunk: <span class="subst">&#123;data.decode()&#125;</span> (Total len: <span class="subst">&#123;<span class="built_in">len</span>(all_data)&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Full message from client: <span class="subst">&#123;all_data.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写入流</span></span><br><span class="line">        conn.sendall(<span class="string">b&#x27;Hi client,&#x27;</span>)</span><br><span class="line">        conn.sendall(<span class="string">b&#x27;I am fine!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>UDP 客户端 (数据报发送)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> s:</span><br><span class="line">    <span class="comment"># 发送数据报，每个 sendto() 是一个独立的包</span></span><br><span class="line">    s.sendto(<span class="string">b&#x27;Hello UDP Server!&#x27;</span>, (HOST, PORT))</span><br><span class="line">    s.sendto(<span class="string">b&#x27;How are you?&#x27;</span>, (HOST, PORT))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收数据报</span></span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received from <span class="subst">&#123;addr&#125;</span>: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>UDP 服务器 (数据报接收)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((HOST, PORT))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;UDP Server listening on <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, addr = s.recvfrom(<span class="number">1024</span>) <span class="comment"># 接收一个完整的数据报</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Received <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span> bytes from <span class="subst">&#123;addr&#125;</span>: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># Echo back</span></span><br><span class="line">        s.sendto(<span class="string">b&#x27;Got your message!&#x27;</span>, addr)</span><br></pre></td></tr></table></figure>

<h2 id="四、流缓冲区-Stream-Buffering"><a href="#四、流缓冲区-Stream-Buffering" class="headerlink" title="四、流缓冲区 (Stream Buffering)"></a>四、流缓冲区 (Stream Buffering)</h2><p>在实际的网络编程中，为了提高效率，操作系统和编程语言运行时通常会对网络流进行<strong>缓冲 (Buffering)</strong>。</p>
<ul>
<li><strong>发送缓冲区</strong>：当应用程序调用 <code>write()</code> 或 <code>send()</code> 向流中写入数据时，数据可能不会立即发送到网络。它会先被放入一个发送缓冲区。当缓冲区满了，或者满足一定条件（如 TCP 的 Nagle 算法），或者应用程序显式刷新缓冲区时，数据才会被发送。</li>
<li><strong>接收缓冲区</strong>：当数据从网络到达时，首先会被放入接收方的操作系统缓冲区。应用程序调用 <code>read()</code> 或 <code>recv()</code> 时，是从这个缓冲区中读取数据，而不是直接从网络中读取。</li>
</ul>
<p><strong>缓冲的优点：</strong></p>
<ul>
<li><strong>提高效率</strong>：减少系统调用次数和网络传输频次。</li>
<li><strong>平滑数据流</strong>：应对发送方和接收方处理速度不匹配的情况。</li>
</ul>
<p><strong>缓冲的缺点或需要注意的问题：</strong></p>
<ul>
<li><strong>延迟</strong>：数据可能在缓冲区中停留一段时间才被发送或处理。</li>
<li><strong>“粘包” (Stick Packet)</strong>：在 TCP 中，由于没有消息边界，接收方可能会将多个发送方的小数据包合并读取（如果操作系统缓冲区中积累了多个数据包），或者一个大的数据包被拆分为多个小块读取。这需要应用程序层进行协议设计和数据解包。</li>
</ul>
<h3 id="解决“粘包”问题"><a href="#解决“粘包”问题" class="headerlink" title="解决“粘包”问题"></a>解决“粘包”问题</h3><p>由于 TCP 是面向字节流的，应用程序需要自己定义协议来处理消息边界。常见的解决方案有：</p>
<ol>
<li><strong>定长协议</strong>：数据包的长度是固定的。</li>
<li><strong>包头 + 包体协议</strong>：在数据包头部包含一个字段表示包体的长度。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬────────────────────┐</span><br><span class="line">│ Length (4 bytes) │ Actual Data (Length bytes) │</span><br><span class="line">└─────────────┴────────────────────┘</span><br></pre></td></tr></table></figure></li>
<li><strong>特殊分隔符协议</strong>：使用一个独特的字符序列作为消息的结束符。</li>
</ol>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>网络编程中的“流”是一个强大的抽象，它极大地简化了开发者处理底层网络传输的复杂性。在 TCP 协议中，“流”代表了数据的有序、可靠、持续传输，但要求应用程序自行处理消息边界。而在 UDP 协议中，数据以独立的“数据报”形式传输，注重效率而非可靠性，每个数据报都有明确的边界。</p>
<p>理解这两种协议对“流”的不同处理方式，以及与之相关的 Socket 编程接口、缓冲机制和“粘包”问题，是编写高效、健壮网络应用的基础。开发者需要根据具体的应用场景和需求，选择合适的协议并设计相应的应用层协议来有效地管理网络数据流。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/eb77bb139028/">https://blog.tbf1211.xx.kg/eb77bb139028/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-09.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/70a4fee407c8/" title="Spring 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Spring 框架详解</div></div><div class="info-2"><div class="info-item-1"> Spring Framework 是一个开源的、轻量级的 Java 企业级开发框架，旨在简化企业级应用程序的开发。它提供了一个全面的编程和配置模型，用于构建现代的、基于 Java 的企业应用。Spring 的核心思想是控制反转 (IoC) 和面向切面编程 (AOP)，通过这些机制，它促进了松耦合、模块化、易于测试的代码结构，并提供了对各种技术（如事务管理、Web 应用程序、数据访问、安全性等）的广泛支持。  核心思想：Spring 致力于通过 IoC (控制反转) 机制来管理对象及其依赖关系，实现组件间的松耦合；通过 AOP (面向切面编程) 来分离横切关注点，提高代码的模块化和复用性。它提供了一个强大的容器来管理应用的生命周期，并提供了丰富的模块来支持企业级开发的各个方面。   一、核心理念Spring Framework 的成功建立在两大核心理念之上：控制反转 (Inversion of Control - IoC) 和面向切面编程 (Aspect-Oriented Programming - AOP)。 1.1 控制反转 (Inversion of Control - I...</div></div></div></a><a class="pagination-related" href="/f52f9b242f1c/" title="Python装饰器详解：从基础到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python装饰器详解：从基础到高级应用</div></div><div class="info-2"><div class="info-item-1"> Python 装饰器 (Decorators) 是一种高级的 Python 语法糖，它允许你在不修改原始函数定义的情况下，增强或修改函数的功能。装饰器本质上是一个 Python 函数，它接收一个函数作为参数，并返回一个修改后或增强后的新函数。它们是实现“开闭原则”（对扩展开放，对修改关闭）的重要工具，常用于日志记录、性能测试、事务处理、权限验证等场景，属于面向切面编程 (AOP) 的范畴。  核心思想：装饰器是“函数套函数”的语法糖，通过闭包的特性，在不改变被装饰函数代码的情况下，为其添加预处理、后处理或其他功能。    一、理解装饰器前的预备知识要真正理解装饰器，我们需要先掌握几个 Python 核心概念： 1.1 函数是第一类对象 (First-Class Objects)在 Python 中，函数与其他数据类型（如整数、字符串）一样，是第一类对象。这意味着你可以：  将函数赋值给变量 将函数作为参数传递给其他函数 将函数作为另一个函数的返回值 在数据结构中存储函数  示例： 123456789101112131415161718192021def greet(name):...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/18f2ce1e9660/" title="DNS (Domain Name System) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="info-item-2">DNS (Domain Name System) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS (Domain Name System) 是互联网的一项核心服务，它将人类可读的域名（如 www.example.com）转换为机器可读的 IP 地址（如 192.168.1.1 或 2001:0db8::1）。这种翻译功能使得用户可以方便地通过记忆友好的域名来访问网站和其他网络资源，而无需记住复杂的数字 IP 地址。DNS 本质上是一个分布式数据库系统，运行在应用层，通常使用 UDP 的 53 端口进行查询，TCP 53 端口用于区域传输 (zone transfer)。  核心思想：将域名映射到 IP 地址，提供一套全球性的、分层的、分布式数据库系统，从而实现互联网资源的定位和访问。   一、为什么需要 DNS？在互联网的早期，少量的计算机通过一个名为 HOSTS.TXT 的静态文件来完成主机名到 IP 地址的映射。然而，随着计算机数量的爆发式增长，这种中心化的、静态的管理方式变得不可行，主要原因如下：  人类记忆限制：用户难以记住大量复杂且不断变化的 IP 地址。 管理困难：集中式文件更新和同步的效率低下，无法适应全球范围内的网络变化。 扩展性差：集中式系统无法承...</div></div></div></a><a class="pagination-related" href="/14fbc43cdbd2/" title="Trojan协议详解：伪装为 HTTPS 的无状态代理协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="info-item-2">Trojan协议详解：伪装为 HTTPS 的无状态代理协议</div></div><div class="info-2"><div class="info-item-1"> Trojan 是一个开源的代理协议，其核心设计理念是“伪装为最常见的 HTTPS 流量”。它通过模仿 HTTPS 流量的特征，并利用 TLS (Transport Layer Security) 的加密和认证机制，旨在实现几乎无法被识别和阻断的代理连接。Trojan 协议放弃了传统代理协议常见的复杂头部和混淆算法，转而直接将代理数据封装在 TLS 中，并强制要求使用 443 端口和合法 TLS 证书，以最大化其隐蔽性。  核心思想：将代理流量深度伪装为 HTTPS 流量，通过在 443 端口上直接利用 TLS 协议的加密会话来传输代理数据，从而使其在外部看来与正常的 HTTPS 流量几乎无异。   一、Trojan 协议的诞生背景与目标Trojan 协议的出现，是对传统代理协议（如 Shadowsocks、VMess 等）在对抗深度包检测 (DPI) 和主动探测时的局限性的一种回应。主要背景如下：  协议特征识别：许多代理协议，即使经过混淆，仍可能因其特定的协议头部、握手流程、流量模式或不符合 TLS 规范的行为而被识别。 主动探测：审查系统可能会主动连接代理服务器，发送探测包...</div></div></div></a><a class="pagination-related" href="/a9313d4ed6e2/" title="Dokodemo-door 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="info-item-2">Dokodemo-door 协议详解</div></div><div class="info-2"><div class="info-item-1"> Dokodemo-door (任意门) 是 V2Ray (Project V) 中一个特殊的 Inbound (入站) 代理协议。它的设计灵感来源于哆啦A梦的“任意门”，主要作用是将指定端口或 IP&#x2F;端口范围的所有流量透明地转发到预设的目标地址。与 SOCKS、HTTP 等常见的代理协议不同，Dokodemo-door 不期望客户端发送任何代理协议头信息，而是直接捕获并处理原始的 TCP&#x2F;UDP 流量。  核心思想：透明地拦截并重定向指定端口&#x2F;IP 的网络流量，无需客户端配置代理，实现“强制代理”或“透明代理”的效果。   一、Dokodemo-door 的工作原理与用途Dokodemo-door 协议本身并不是一个用于客户端与 V2Ray 服务端通信的“伪装”或“加密”协议（如 VMess、VLESS、Trojan）。它是一个入站协议 (Inbound Protocol)，这意味着它在 V2Ray 的服务器端或本地代理端接收流量。 1.1 工作原理当配置了 Dokodemo-door Inbound 时，V2Ray 会监听指定的端口和&#x2F;...</div></div></div></a><a class="pagination-related" href="/2dc209b3606e/" title="OSI 七层模型详解 (The OSI 7-Layer Model Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-12</div><div class="info-item-2">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</div></div><div class="info-2"><div class="info-item-1"> OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。  核心思想：将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。   一、为什么需要 OSI 模型？在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个统一的标准来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：  标准化：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。 模块化：将复杂的网络通...</div></div></div></a><a class="pagination-related" href="/6d2713973946/" title="SOCKS5协议详解：网络代理的基础与通用协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-22</div><div class="info-item-2">SOCKS5协议详解：网络代理的基础与通用协议</div></div><div class="info-2"><div class="info-item-1"> SOCKS5 是一种网络传输协议，它允许客户端通过一个“代理服务器”间接地连接到其他服务器。SOCKS 是 “SOCKet Secure” 的缩写，版本 5 是目前最常用的 SOCKS 协议版本。SOCKS5 协议工作在 OSI 模型中的会话层 (第五层)，能够处理TCP 和 UDP 两种流量，并且支持多种认证方式。它本身不提供加密功能，主要用于路由流量和隐藏真实 IP 地址，是许多更高级代理协议（如 Shadowsocks、V2Ray 客户端的本地监听）的基础。  核心思想：SOCKS5 是一个通用的网络代理协议，它实现了在客户端和目标服务器之间建立连接的中间转发机制。它不关心应用层数据，只负责转发 TCP 连接和 UDP 数据包，并提供认证功能。   一、为什么需要 SOCKS5 代理？在没有代理的情况下，应用程序直接连接到目标服务器。SOCKS5 代理的出现，主要解决了以下问题：  突破网络限制：当直接访问某个服务受阻时，可以通过 SOCKS5 代理服务器进行中转，绕过本地网络限制。 隐藏真实 IP 地址：客户端的真实 IP 地址对目标服务器隐藏，保护用户隐私。 负载均衡...</div></div></div></a><a class="pagination-related" href="/378a51590e55/" title="HTTP&#x2F;1.1 协议深度详解：Web 通信的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="info-item-2">HTTP&#x2F;1.1 协议深度详解：Web 通信的基石</div></div><div class="info-2"><div class="info-item-1"> HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。  核心思想：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于请求-响应模型，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。   一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：  短连接 (Short Connection)：HTTP&#x2F;1.0 默认每个请求&#x2F;响应...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">497</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E6%B5%81%E2%80%9D%EF%BC%9F"><span class="toc-text">一、什么是“流”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E2%80%9C%E6%B5%81%E2%80%9D%E5%9C%A8-TCP-%E5%92%8C-UDP-%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BD%93%E7%8E%B0"><span class="toc-text">二、“流”在 TCP 和 UDP 中的不同体现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-TCP-%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E2%80%9C%E6%B5%81%E2%80%9D-Stream-oriented"><span class="toc-text">2.1 TCP 连接中的“流” (Stream-oriented)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-UDP-%E4%B8%AD%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%8A%A5%E2%80%9D-Datagram-oriented"><span class="toc-text">2.2 UDP 中的“数据报” (Datagram-oriented)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Socket-%E4%B8%8E%E6%B5%81%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-text">三、Socket 与流的关联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-Python-socket-%E6%A8%A1%E5%9D%97"><span class="toc-text">示例 (Python socket 模块)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA-Stream-Buffering"><span class="toc-text">四、流缓冲区 (Stream Buffering)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E2%80%9C%E7%B2%98%E5%8C%85%E2%80%9D%E9%97%AE%E9%A2%98"><span class="toc-text">解决“粘包”问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-09.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>