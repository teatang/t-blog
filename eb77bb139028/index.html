<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络编程中“流”的详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机网络编程中，“流 (Stream)”是一个非常核心且抽象的概念，它通常用来描述数据在两个实体之间进行传输时，数据流动的抽象表示。尤其在基于 TCP 协议的网络通信中，“流”的概念至关重要，它模拟了数据的顺序传输和持续性连接。理解“流”有助于开发者更好地掌握网络数据传输的本质，并编写出健壮、高效的网络应用程序。  核心思想：网络编程中的“流”是一种抽象，表示数据像水流一样顺序、持续地从一个">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程中“流”的详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/eb77bb139028/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在计算机网络编程中，“流 (Stream)”是一个非常核心且抽象的概念，它通常用来描述数据在两个实体之间进行传输时，数据流动的抽象表示。尤其在基于 TCP 协议的网络通信中，“流”的概念至关重要，它模拟了数据的顺序传输和持续性连接。理解“流”有助于开发者更好地掌握网络数据传输的本质，并编写出健壮、高效的网络应用程序。  核心思想：网络编程中的“流”是一种抽象，表示数据像水流一样顺序、持续地从一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2023-06-16T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-31T14:22:27.332Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络编程中“流”的详解",
  "url": "https://blog.tbf1211.xx.kg/eb77bb139028/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2023-06-16T22:24:00.000Z",
  "dateModified": "2025-12-31T14:22:27.332Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/eb77bb139028/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程中“流”的详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">450</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">网络编程中“流”的详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">网络编程中“流”的详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-16T22:24:00.000Z" title="发表于 2023-06-17 06:24:00">2023-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在计算机网络编程中，“<strong>流 (Stream)</strong>”是一个非常核心且抽象的概念，它通常用来描述<strong>数据在两个实体之间进行传输时，数据流动的抽象表示</strong>。尤其在基于 TCP 协议的网络通信中，“流”的概念至关重要，它模拟了数据的顺序传输和持续性连接。理解“流”有助于开发者更好地掌握网络数据传输的本质，并编写出健壮、高效的网络应用程序。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>网络编程中的“流”是一种抽象，表示数据像水流一样顺序、持续地从一个端点流向另一个端点，封装了底层网络传输的复杂性。</strong></p>
</div>
<hr>
<h2 id="一、什么是“流”？"><a href="#一、什么是“流”？" class="headerlink" title="一、什么是“流”？"></a>一、什么是“流”？</h2><p>在网络编程中，“流”可以被理解为：</p>
<ol>
<li><strong>数据的有序序列 (Ordered Sequence of Data)</strong>：数据被发送时按照发送的顺序到达接收方，不会乱序。</li>
<li><strong>持续的数据传输通道 (Continuous Data Flow Channel)</strong>：它代表了客户端与服务器之间建立的一种逻辑连接，数据可以在这个连接上持续不断地传输，就像水流一样。</li>
<li><strong>抽象的读写接口 (Abstract Read&#x2F;Write Interface)</strong>：开发者通过操作流接口（例如 <code>read()</code>、<code>write()</code>），而不必关心底层数据的分段、组装、路由等细节。</li>
<li><strong>字节流 (Byte Stream)</strong>：通常情况下，网络流处理的是原始字节，不关心数据的具体格式或含义（例如是文本、图片还是协议数据）。由应用程序自行解析字节的含义。</li>
</ol>
<p>“流”的概念在多种编程语言和框架中都有体现，例如 Java 的 <code>InputStream</code>&#x2F;<code>OutputStream</code>、Python 的 <code>socket</code> 对象的读写方法、Node.js 的 <code>Stream</code> 模块等。</p>
<h2 id="二、“流”在-TCP-和-UDP-中的不同体现"><a href="#二、“流”在-TCP-和-UDP-中的不同体现" class="headerlink" title="二、“流”在 TCP 和 UDP 中的不同体现"></a>二、“流”在 TCP 和 UDP 中的不同体现</h2><p>“流”这个概念在 TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 这两种主要的传输层协议中有着截然不同的体现。</p>
<h3 id="2-1-TCP-连接中的“流”-Stream-oriented"><a href="#2-1-TCP-连接中的“流”-Stream-oriented" class="headerlink" title="2.1 TCP 连接中的“流” (Stream-oriented)"></a>2.1 TCP 连接中的“流” (Stream-oriented)</h3><p>TCP 是一个<strong>面向连接 (Connection-oriented)</strong> 和<strong>面向流 (Stream-oriented)</strong> 的协议。</p>
<ol>
<li><strong>面向连接</strong>：在使用 TCP 进行通信前，客户端和服务器之间必须先建立一个可靠的连接（三次握手）。这个连接一旦建立，就形成了一个逻辑上的“管道”。</li>
<li><strong>面向流</strong>：<ul>
<li><strong>数据像管道水流</strong>：一旦连接建立，应用程序往这个“管道”里写入字节流，对方就能从管道的另一端按顺序读取字节流。发送方写入多少数据，接收方就能读取多少，数据的边界不再由每次发送操作决定。</li>
<li><strong>无消息边界</strong>：TCP 不保留消息记录。发送方可以发送 100 字节，接收方可以分两次（例如先 50 字节，再 50 字节）或一次性读取 100 字节，甚至更多，<code>read</code> 操作可能只读取了部分发送的数据。反之亦然，发送方可以发送多次小块数据，TCP 可能会将其合并为更大的数据包再发送。</li>
<li><strong>数据完整性和顺序性</strong>：TCP 保证数据的可靠传输（无丢失、无重复）和按序到达。这是通过序列号、确认应答、重传机制、流量控制和拥塞控制等一系列复杂机制实现的，这些复杂性都被“流”这个抽象封装起来了。</li>
<li><strong>半关闭 (Half-close)</strong>：TCP 连接可以单方面关闭发送方向的流，而接收方向的流仍可保持开放，反之亦然。</li>
</ul>
</li>
</ol>
<p><strong>用一个比喻来理解 TCP 流：</strong></p>
<p>想象你打电话：</p>
<ul>
<li><strong>建立连接</strong>：你先拨号，对方接听，建立对话。</li>
<li><strong>数据像流</strong>：一旦通话建立，你说的话（数据）会连续不断地传给对方。你不会说“这是第一句”，再等对方确认后说“这是第二句”。</li>
<li><strong>无消息边界</strong>：你可能连续说好几段话，对方可以随时打断你做出回应，也可以等你全部说完再回应。数据接收方并不关心你每句话的长度。</li>
<li><strong>可靠性</strong>：如果你没听清，你会让对方再说一遍。TCP 也是如此，确保数据送达。</li>
</ul>
<h3 id="2-2-UDP-中的“数据报”-Datagram-oriented"><a href="#2-2-UDP-中的“数据报”-Datagram-oriented" class="headerlink" title="2.2 UDP 中的“数据报” (Datagram-oriented)"></a>2.2 UDP 中的“数据报” (Datagram-oriented)</h3><p>UDP 是一个<strong>无连接 (Connectionless)</strong> 和<strong>面向数据报 (Datagram-oriented)</strong> 的协议。</p>
<ol>
<li><strong>无连接</strong>：UDP 在发送数据前不需要建立连接。每个数据报都是一个独立的单元，发送后就“不管”了。</li>
<li><strong>面向数据报</strong>：<ul>
<li><strong>独立的数据包</strong>：每次发送操作都会生成一个独立的数据报。这个数据报有一个明确的边界。</li>
<li><strong>消息边界保留</strong>：发送方发送一个 100 字节的数据报，接收方通常会一次性接收到完整的 100 字节。如果接收方的缓冲区不够大，整个数据报可能会被丢弃。</li>
<li><strong>不保证可靠性、顺序性</strong>：UDP 不保证数据报的可靠传输（可能会丢失）、顺序到达（可能会乱序）和无重复。这些特性需要应用程序自己实现。</li>
<li><strong>适用于广播&#x2F;多播</strong>：UDP 适合发送少量、非关键性数据，或者需要快速传输、允许少量数据丢失的场景（如流媒体、在线游戏）。</li>
</ul>
</li>
</ol>
<p><strong>用一个比喻来理解 UDP 数据报：</strong></p>
<p>想象你寄明信片：</p>
<ul>
<li><strong>无连接</strong>：你直接写好明信片就寄出去，不需要先建立什么“连接”。</li>
<li><strong>数据像数据报</strong>：每张明信片都是一个独立的信息单元。你寄了三张明信片，对方就会收到三张独立的明信片。</li>
<li><strong>有消息边界</strong>：每张明信片都有自己的边界，内容不会和别的明信片混淆。</li>
<li><strong>不可靠性</strong>：邮局不保证明信片能准确投递，可能丢失，可能先后顺序颠倒。</li>
</ul>
<h2 id="三、Socket-与流的关联"><a href="#三、Socket-与流的关联" class="headerlink" title="三、Socket 与流的关联"></a>三、Socket 与流的关联</h2><p>在大多数编程语言中，通过 <strong>Socket (套接字)</strong> 接口进行网络编程。</p>
<ul>
<li><strong>TCP Socket</strong>：创建 TCP Socket 后，进行 <code>connect()</code> 或 <code>accept()</code> 操作，就会建立起一个 TCP 连接。这个连接实际上就形成了一个双向的“流”。应用程序通过对这个 Socket 调用 <code>send()</code>&#x2F;<code>write()</code> 将数据写入流，调用 <code>recv()</code>&#x2F;<code>read()</code> 从流中读取数据。</li>
<li><strong>UDP Socket</strong>：UDP Socket 不会建立持久的“连接流”，每次发送数据都通过 <code>sendto()</code> 指定目标地址，每次接收数据都通过 <code>recvfrom()</code> 从任意来源接收带地址信息的数据报。UDP Socket 通常不具备传统意义上的“流”的特性，更像是数据的“邮筒”。</li>
</ul>
<h3 id="示例-Python-socket-模块"><a href="#示例-Python-socket-模块" class="headerlink" title="示例 (Python socket 模块)"></a>示例 (Python <code>socket</code> 模块)</h3><p><strong>TCP 客户端 (流读写)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.connect((HOST, PORT))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connected to server.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入流</span></span><br><span class="line">    s.sendall(<span class="string">b&#x27;Hello, server!&#x27;</span>)</span><br><span class="line">    s.sendall(<span class="string">b&#x27;How are you?&#x27;</span>) <span class="comment"># 后续写入，与前一次写入的数据在同一个流中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从流中读取，可能一次读完，也可能分多次</span></span><br><span class="line">    data1 = s.recv(<span class="number">1024</span>) <span class="comment"># 尝试读取最多 1024 字节</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received part 1: <span class="subst">&#123;data1.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    data2 = s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received part 2: <span class="subst">&#123;data2.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Total received from server: <span class="subst">&#123;data1.decode() + data2.decode()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>TCP 服务器 (流读写)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((HOST, PORT))</span><br><span class="line">    s.listen()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Server listening on <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    conn, addr = s.accept() <span class="comment"># 接受连接</span></span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected by <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">        all_data = <span class="string">b&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = conn.recv(<span class="number">10</span>) <span class="comment"># 每次只读取 10 字节</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            all_data += data</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Received chunk: <span class="subst">&#123;data.decode()&#125;</span> (Total len: <span class="subst">&#123;<span class="built_in">len</span>(all_data)&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Full message from client: <span class="subst">&#123;all_data.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写入流</span></span><br><span class="line">        conn.sendall(<span class="string">b&#x27;Hi client,&#x27;</span>)</span><br><span class="line">        conn.sendall(<span class="string">b&#x27;I am fine!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>UDP 客户端 (数据报发送)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> s:</span><br><span class="line">    <span class="comment"># 发送数据报，每个 sendto() 是一个独立的包</span></span><br><span class="line">    s.sendto(<span class="string">b&#x27;Hello UDP Server!&#x27;</span>, (HOST, PORT))</span><br><span class="line">    s.sendto(<span class="string">b&#x27;How are you?&#x27;</span>, (HOST, PORT))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收数据报</span></span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received from <span class="subst">&#123;addr&#125;</span>: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>UDP 服务器 (数据报接收)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="number">65432</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((HOST, PORT))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;UDP Server listening on <span class="subst">&#123;HOST&#125;</span>:<span class="subst">&#123;PORT&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, addr = s.recvfrom(<span class="number">1024</span>) <span class="comment"># 接收一个完整的数据报</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Received <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span> bytes from <span class="subst">&#123;addr&#125;</span>: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># Echo back</span></span><br><span class="line">        s.sendto(<span class="string">b&#x27;Got your message!&#x27;</span>, addr)</span><br></pre></td></tr></table></figure>

<h2 id="四、流缓冲区-Stream-Buffering"><a href="#四、流缓冲区-Stream-Buffering" class="headerlink" title="四、流缓冲区 (Stream Buffering)"></a>四、流缓冲区 (Stream Buffering)</h2><p>在实际的网络编程中，为了提高效率，操作系统和编程语言运行时通常会对网络流进行<strong>缓冲 (Buffering)</strong>。</p>
<ul>
<li><strong>发送缓冲区</strong>：当应用程序调用 <code>write()</code> 或 <code>send()</code> 向流中写入数据时，数据可能不会立即发送到网络。它会先被放入一个发送缓冲区。当缓冲区满了，或者满足一定条件（如 TCP 的 Nagle 算法），或者应用程序显式刷新缓冲区时，数据才会被发送。</li>
<li><strong>接收缓冲区</strong>：当数据从网络到达时，首先会被放入接收方的操作系统缓冲区。应用程序调用 <code>read()</code> 或 <code>recv()</code> 时，是从这个缓冲区中读取数据，而不是直接从网络中读取。</li>
</ul>
<p><strong>缓冲的优点：</strong></p>
<ul>
<li><strong>提高效率</strong>：减少系统调用次数和网络传输频次。</li>
<li><strong>平滑数据流</strong>：应对发送方和接收方处理速度不匹配的情况。</li>
</ul>
<p><strong>缓冲的缺点或需要注意的问题：</strong></p>
<ul>
<li><strong>延迟</strong>：数据可能在缓冲区中停留一段时间才被发送或处理。</li>
<li><strong>“粘包” (Stick Packet)</strong>：在 TCP 中，由于没有消息边界，接收方可能会将多个发送方的小数据包合并读取（如果操作系统缓冲区中积累了多个数据包），或者一个大的数据包被拆分为多个小块读取。这需要应用程序层进行协议设计和数据解包。</li>
</ul>
<h3 id="解决“粘包”问题"><a href="#解决“粘包”问题" class="headerlink" title="解决“粘包”问题"></a>解决“粘包”问题</h3><p>由于 TCP 是面向字节流的，应用程序需要自己定义协议来处理消息边界。常见的解决方案有：</p>
<ol>
<li><strong>定长协议</strong>：数据包的长度是固定的。</li>
<li><strong>包头 + 包体协议</strong>：在数据包头部包含一个字段表示包体的长度。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬────────────────────┐</span><br><span class="line">│ Length (4 bytes) │ Actual Data (Length bytes) │</span><br><span class="line">└─────────────┴────────────────────┘</span><br></pre></td></tr></table></figure></li>
<li><strong>特殊分隔符协议</strong>：使用一个独特的字符序列作为消息的结束符。</li>
</ol>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>网络编程中的“流”是一个强大的抽象，它极大地简化了开发者处理底层网络传输的复杂性。在 TCP 协议中，“流”代表了数据的有序、可靠、持续传输，但要求应用程序自行处理消息边界。而在 UDP 协议中，数据以独立的“数据报”形式传输，注重效率而非可靠性，每个数据报都有明确的边界。</p>
<p>理解这两种协议对“流”的不同处理方式，以及与之相关的 Socket 编程接口、缓冲机制和“粘包”问题，是编写高效、健壮网络应用的基础。开发者需要根据具体的应用场景和需求，选择合适的协议并设计相应的应用层协议来有效地管理网络数据流。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/eb77bb139028/">https://blog.tbf1211.xx.kg/eb77bb139028/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/70a4fee407c8/" title="Spring 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Spring 框架详解</div></div><div class="info-2"><div class="info-item-1"> Spring Framework 是一个开源的、轻量级的 Java 企业级开发框架，旨在简化企业级应用程序的开发。它提供了一个全面的编程和配置模型，用于构建现代的、基于 Java 的企业应用。Spring 的核心思想是控制反转 (IoC) 和面向切面编程 (AOP)，通过这些机制，它促进了松耦合、模块化、易于测试的代码结构，并提供了对各种技术（如事务管理、Web 应用程序、数据访问、安全性等）的广泛支持。  核心思想：Spring 致力于通过 IoC (控制反转) 机制来管理对象及其依赖关系，实现组件间的松耦合；通过 AOP (面向切面编程) 来分离横切关注点，提高代码的模块化和复用性。它提供了一个强大的容器来管理应用的生命周期，并提供了丰富的模块来支持企业级开发的各个方面。   一、核心理念Spring Framework 的成功建立在两大核心理念之上：控制反转 (Inversion of Control - IoC) 和面向切面编程 (Aspect-Oriented Programming - AOP)。 1.1 控制反转 (Inversion of Control - I...</div></div></div></a><a class="pagination-related" href="/f52f9b242f1c/" title="Python装饰器详解：从基础到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python装饰器详解：从基础到高级应用</div></div><div class="info-2"><div class="info-item-1"> Python 装饰器 (Decorators) 是一种高级的 Python 语法糖，它允许你在不修改原始函数定义的情况下，增强或修改函数的功能。装饰器本质上是一个 Python 函数，它接收一个函数作为参数，并返回一个修改后或增强后的新函数。它们是实现“开闭原则”（对扩展开放，对修改关闭）的重要工具，常用于日志记录、性能测试、事务处理、权限验证等场景，属于面向切面编程 (AOP) 的范畴。  核心思想：装饰器是“函数套函数”的语法糖，通过闭包的特性，在不改变被装饰函数代码的情况下，为其添加预处理、后处理或其他功能。    一、理解装饰器前的预备知识要真正理解装饰器，我们需要先掌握几个 Python 核心概念： 1.1 函数是第一类对象 (First-Class Objects)在 Python 中，函数与其他数据类型（如整数、字符串）一样，是第一类对象。这意味着你可以：  将函数赋值给变量 将函数作为参数传递给其他函数 将函数作为另一个函数的返回值 在数据结构中存储函数  示例： 123456789101112131415161718192021def greet(name):...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a><a class="pagination-related" href="/a97c16bf3fd0/" title="奇偶检验详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-14</div><div class="info-item-2">奇偶检验详解</div></div><div class="info-2"><div class="info-item-1"> 奇偶检验 (Parity Check) 是一种最简单、最古老的错误检测方法，用于验证数据在传输或存储过程中是否发生了一位或奇数位的错误。它通过在原始数据的基础上添加一个额外的比特位（称为奇偶校验位）来实现。  核心思想： 通过统计数据位中 ‘1’ 的数量是奇数还是偶数，并添加一个校验位来使其总数符合预设的奇偶性，从而在接收端检测数据是否被意外翻转。   一、奇偶检验的基本原理奇偶检验的基本思想是确保一组二进制位中 ‘1’ 的总数（包括校验位）始终是奇数或偶数。 1.1 两种类型根据要求的奇偶性，奇偶检验分为两种：  奇校验 (Odd Parity Check)：  发送方统计数据位中 ‘1’ 的个数。 如果 ‘1’ 的个数为偶数，则奇偶校验位设置为 ‘1’，使包括校验位在内的所有位中 ‘1’ 的总数为奇数。 如果 ‘1’ 的个数为奇数，则奇偶校验位设置为 ‘0’，使包括校验位在内的所有位中 ‘1’ 的总数仍为奇数。 目标：传输的整个数据串（数据位 + 校验位）中 ‘1’ 的个数为奇数。   偶校验 (Even Parity Check)：  发送方统计数据位中 ‘1’ 的个数。...</div></div></div></a><a class="pagination-related" href="/5d5f7c78ff8d/" title="五层因特网协议栈深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-14</div><div class="info-item-2">五层因特网协议栈深度详解</div></div><div class="info-2"><div class="info-item-1"> 五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。  核心思想：将互联网的通信过程划分为五个逻辑层级，自顶向下依次为应用层、传输层、网络层、数据链路层和物理层，每层负责不同的通信职责，协同工作以实现全球互联。   一、为什么选择五层协议栈？尽管 OSI 七层模型提供了非常详细的理论分层，但由于其设计时在标准制定上花费了大量时间，并且部分层次划分在实际实现中显得过于细致，导致其未能大规模落地。相反，TCP&#x2F;IP 协议族在互联网的早期发展中迅速崛起并成为事实标准。五层协议栈结合了二者的优点：  实用性：它直接反映了 TCP&#x2F;IP 协议族栈的工作方式，是互联网实际运行的写照。 简洁性：相比 OSI 七层模型，它将 OSI 的...</div></div></div></a><a class="pagination-related" href="/19a6c2b992d7/" title="IPv6 (Internet Protocol Version 6) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">IPv6 (Internet Protocol Version 6) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv6 (Internet Protocol Version 6) 是互联网协议 (IP) 的最新版本，旨在取代其前身 IPv4。它解决了 IPv4 长期存在的地址枯竭问题，并引入了多项设计改进，以更好地适应现代互联网的需求，包括支持更简单的头部处理、增强的安全性、更好的服务质量 (QoS) 和更强大的移动性功能。  核心思想：从根本上解决 IPv4 地址短缺问题，同时优化协议设计，为万物互联 (IoT)、5G 和未来网络应用提供坚实基础。    一、为什么需要 IPv6？IPv4 (Internet Protocol Version 4) 作为互联网的核心协议已成功运行数十年，但随着互联网的爆炸式增长，其固有的设计局限性日益凸显：  地址枯竭 (Address Exhaustion)：IPv4 地址空间为 32 位，最多有约 43 亿个地址。尽管采取了无类别域间路由 (CIDR) 和网络地址转换 (NAT) 等技术来延缓地址枯竭，但根源问题并未解决。全球各区域的 IPv4 地址池已基本分配完毕，成为互联网进一步发展的瓶颈。 NAT 的复杂性与限制：网络地址转换 (NAT) ...</div></div></div></a><a class="pagination-related" href="/f32c05ed494f/" title="VLESS协议详解：下一代无状态加密传输协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="info-item-2">VLESS协议详解：下一代无状态加密传输协议</div></div><div class="info-2"><div class="info-item-1"> VLESS 是一种由 Xray-core 团队设计和实现的代理协议，旨在提供一种简洁、透明且高性能的传输方式。与 VMess 等协议不同，VLESS 自身不包含任何加密或混淆功能，它将这些任务委托给传输层（如 TLS, WebSocket）来完成。VLESS 的核心理念是“不加密，不混淆，只传输”，它极大地减少了协议自身的开销，从而带来了更快的速度和更低的资源占用。  核心思想：将协议开销降到最低，只负责将客户端的流量“透明”地转发给目标服务器，而将加密和混淆的重任完全交给底层的传输协议（如 TLS、WebSocket）。   一、VLESS 协议的诞生背景与目标VLESS 协议的诞生，是对 VMess 协议以及其他一些传统代理协议的反思和改进。它主要为了解决以下问题：  双重加密的性能损耗： 许多代理协议（如 VMess）自身会进行数据加密和混淆。 当这些协议再叠加 TLS（HTTPS）等传输层加密时，就会形成“双重加密”，导致不必要的 CPU 消耗和延迟。   协议特征暴露： 复杂的协议自身往往会产生固定的“指纹”或特征，可能被深度包检测 (DPI) 识别并封锁。 协议越简...</div></div></div></a><a class="pagination-related" href="/c5054902e8b1/" title="iptables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-25</div><div class="info-item-2">iptables 详解</div></div><div class="info-2"><div class="info-item-1"> iptables 是 Linux 系统中一个强大的防火墙工具，它基于 Netfilter 框架。Netfilter 是 Linux 内核中的一个数据包过滤和修改框架，而 iptables 是用于在用户空间配置 Netfilter 规则的命令行工具。通过 iptables，系统管理员可以定义各种规则来过滤、修改、转发或拦截网络数据包，从而实现网络流量控制、端口转发、地址伪装等功能。可以说，iptables 是 Linux 系统网络安全和流量管理的基石。  核心思想：基于规则链对数据包进行匹配和处理。 数据包在网络协议栈中穿行时，会根据定义好的规则链进行检查，并按照链中的规则顺序执行相应的动作。   一、Netfilter 框架与 iptables 关系理解 iptables，首先要了解它与 Netfilter 的关系：  Netfilter：位于 Linux 内核中，是一个用于网络数据包过滤、修改、转发和跟踪的框架。它定义了几个”钩子” (Hooks) 点，当数据包经过这些钩子点时，Netfilter 会检查是否有注册的规则需要处理该数据包。 iptables：是用户空间的命令行...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">450</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E6%B5%81%E2%80%9D%EF%BC%9F"><span class="toc-text">一、什么是“流”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E2%80%9C%E6%B5%81%E2%80%9D%E5%9C%A8-TCP-%E5%92%8C-UDP-%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BD%93%E7%8E%B0"><span class="toc-text">二、“流”在 TCP 和 UDP 中的不同体现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-TCP-%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E2%80%9C%E6%B5%81%E2%80%9D-Stream-oriented"><span class="toc-text">2.1 TCP 连接中的“流” (Stream-oriented)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-UDP-%E4%B8%AD%E7%9A%84%E2%80%9C%E6%95%B0%E6%8D%AE%E6%8A%A5%E2%80%9D-Datagram-oriented"><span class="toc-text">2.2 UDP 中的“数据报” (Datagram-oriented)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Socket-%E4%B8%8E%E6%B5%81%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-text">三、Socket 与流的关联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-Python-socket-%E6%A8%A1%E5%9D%97"><span class="toc-text">示例 (Python socket 模块)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA-Stream-Buffering"><span class="toc-text">四、流缓冲区 (Stream Buffering)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E2%80%9C%E7%B2%98%E5%8C%85%E2%80%9D%E9%97%AE%E9%A2%98"><span class="toc-text">解决“粘包”问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>