<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GoLang Wails 框架详解：用 Web 技术构建桌面应用 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Wails 是一个 Go 语言编写的框架，用于使用 Go 语言的强大后端能力和熟悉的 Web 前端技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能、原生的跨平台桌面应用程序。它与 Tauri 类似，都是 Electron 的替代品，但 Wails 的核心优势在于其后端是 Go">
<meta property="og:type" content="article">
<meta property="og:title" content="GoLang Wails 框架详解：用 Web 技术构建桌面应用">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/cdecf00b2f41/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Wails 是一个 Go 语言编写的框架，用于使用 Go 语言的强大后端能力和熟悉的 Web 前端技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能、原生的跨平台桌面应用程序。它与 Tauri 类似，都是 Electron 的替代品，但 Wails 的核心优势在于其后端是 Go">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg">
<meta property="article:published_time" content="2025-09-17T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-04T09:13:31.574Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="桌面开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "GoLang Wails 框架详解：用 Web 技术构建桌面应用",
  "url": "https://blog.tbf1211.xx.kg/cdecf00b2f41/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg",
  "datePublished": "2025-09-17T22:24:00.000Z",
  "dateModified": "2026-01-04T09:13:31.574Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/cdecf00b2f41/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GoLang Wails 框架详解：用 Web 技术构建桌面应用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">455</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-28.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">GoLang Wails 框架详解：用 Web 技术构建桌面应用</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">GoLang Wails 框架详解：用 Web 技术构建桌面应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-09-17T22:24:00.000Z" title="发表于 2025-09-18 06:24:00">2025-09-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/">桌面开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Wails</strong> 是一个 Go 语言编写的框架，用于使用 Go 语言的强大后端能力和熟悉的 Web 前端技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能、原生的跨平台桌面应用程序。它与 Tauri 类似，都是 Electron 的替代品，但 Wails 的核心优势在于其后端是 Go 语言，这对于 Go 开发者来说更具亲和力。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将现代 Web 前端技术与 Go 语言编写的原生后端无缝结合，通过操作系统的 WebView 渲染 UI，实现高性能、低资源消耗且易于 Go 开发者上手的桌面应用开发。</strong></p>
</div>

<hr>
<h2 id="一、为什么选择-Wails？"><a href="#一、为什么选择-Wails？" class="headerlink" title="一、为什么选择 Wails？"></a>一、为什么选择 Wails？</h2><p>与 Electron 相比，Wails 提供了一系列优势，特别吸引 Go 语言开发者：</p>
<ol>
<li><strong>极小的捆包体积</strong>：Wails 应用同样不捆绑 Chromium 或 Node.js 运行时。它利用操作系统自带的 WebView 控件（如 Windows 上的 WebView2&#x2F;EdgeHTML、macOS 上的 WKWebView、Linux 上的 WebKitGTK&#x2F;WebView2），使得最终应用体积非常小，通常只有几MB。</li>
<li><strong>低内存占用</strong>：由于使用系统 WebView，内存占用大幅降低，更接近原生应用。</li>
<li><strong>高性能 Go 后端</strong>：开发者可以使用 Go 语言编写应用程序的后端逻辑，利用 Go 的高性能、并发能力和丰富的标准库。这对于需要处理大量数据、网络通信或复杂业务逻辑的应用尤其有利。</li>
<li><strong>Go 语言亲和性</strong>：对于已经熟悉 Go 语言的开发者，Wails 提供了非常自然的开发体验，无需学习 Rust（像 Tauri 那样）或 Node.js（像 Electron 那样）来编写后端。</li>
<li><strong>跨平台</strong>：一套 Go 和 Web 代码库可以构建 Windows、macOS 和 Linux 平台上的应用。</li>
<li><strong>Web 技术栈</strong>：前端开发者可以继续使用熟悉的 HTML、CSS、JavaScript 和各种前端框架。</li>
</ol>
<h2 id="二、Wails-的核心架构与概念"><a href="#二、Wails-的核心架构与概念" class="headerlink" title="二、Wails 的核心架构与概念"></a>二、Wails 的核心架构与概念</h2><p>Wails 的架构设计与 Tauri 有相似之处，但核心后端语言是 Go：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    A[&quot;用户界面 (UI)HTML&#x2F;CSS&#x2F;JS &lt;br&gt;(React, Vue等)&quot;] --&gt; B[&quot;Wails Runtime Bridge (Go)&quot;]
    B --&gt; C[&quot;Go 后端 (Backend) 业务逻辑, &lt;br&gt;系统API, 文件系统, 网络等&quot;]
    C --&gt; D[操作系统原生物件&lt;br&gt;窗口, 菜单, 通知]
    C --&gt; E[系统级能力文件读写, &lt;br&gt;网络请求, 数据库操作]
    F[&quot;操作系统 WebView 控件&lt;br&gt;(Windows: WebView2, &lt;br&gt;macOS: WKWebView, &lt;br&gt;Linux: WebKitGTK)&quot;] --&gt; A
  
    subgraph Wails 应用
        A -- 渲染 --&gt; F
        A -- 调用 --&gt; B
        B -- 驱动 --&gt; C
        C -- 控制 --&gt; D
        C -- 访问 --&gt; E
    end
  </pre></div>

<h3 id="2-1-WebView-前端渲染"><a href="#2-1-WebView-前端渲染" class="headerlink" title="2.1 WebView (前端渲染)"></a>2.1 WebView (前端渲染)</h3><ul>
<li><strong>定义</strong>：与 Tauri 类似，Wails 也利用操作系统提供的原生 Web 内容渲染组件来显示前端 UI。</li>
<li><strong>优势</strong>：捆包体积小、内存占用低、外观与系统更协调。</li>
<li><strong>跨平台差异</strong>：<ul>
<li><strong>Windows</strong>：WebView2 (基于 Edge Chromium)，如果不可用则回退到 EdgeHTML (IE 的 MSHTML 引擎)。</li>
<li><strong>macOS</strong>：WKWebView (基于 Safari 的 WebKit)。</li>
<li><strong>Linux</strong>：通常使用 WebKitGTK 或 WebView2。</li>
</ul>
</li>
<li><strong>与 Web 交互</strong>：前端 Web 代码运行在 WebView 中，通过 Wails 提供的 Runtime 桥接器与 Go 后端进行通信。</li>
</ul>
<h3 id="2-2-Go-后端-业务逻辑"><a href="#2-2-Go-后端-业务逻辑" class="headerlink" title="2.2 Go 后端 (业务逻辑)"></a>2.2 Go 后端 (业务逻辑)</h3><ul>
<li><strong>定义</strong>：Wails 的核心后端逻辑由 Go 语言编写，负责处理文件系统操作、网络请求、调用操作系统原生 API、应用生命周期管理、系统托盘、菜单、通知以及所有业务逻辑。</li>
<li><strong>优势</strong>：<ul>
<li><strong>性能</strong>：Go 提供了出色的性能，尤其适合高并发和 I&#x2F;O 密集型任务。</li>
<li><strong>并发模型</strong>：Goroutines 和 Channels 使得编写并发代码非常简单高效。</li>
<li><strong>丰富的生态</strong>：Go 拥有强大的标准库和成熟的第三方库生态系统。</li>
<li><strong>单文件可执行程序</strong>：Go 应用程序可以被编译成单一的静态链接可执行文件，便于分发。</li>
</ul>
</li>
<li><strong>API 接口</strong>：Wails 提供了一套 Go API 和结构体，用于在后端实现业务逻辑，并通过 JSON-RPC 风格的机制暴露给前端。</li>
</ul>
<h3 id="2-3-Runtime-桥接-IPC"><a href="#2-3-Runtime-桥接-IPC" class="headerlink" title="2.3 Runtime 桥接 (IPC)"></a>2.3 Runtime 桥接 (IPC)</h3><ul>
<li><strong>定义</strong>：Wails 框架在前端 JavaScript 和后端 Go 之间建立了一个高效的通信桥梁。</li>
<li><strong>工作原理</strong>：<ul>
<li><strong>前端调用后端 (Go 方法)</strong>：前端 JavaScript 通过 <code>window.go.main.&lt;YourStruct&gt;.&lt;YourMethod&gt;()</code> 这样的 API 来调用 Go 后端注册的结构体方法。这些 Go 方法会被自动暴露给前端。Wails 会自动进行参数和返回值的序列化&#x2F;反序列化（JSON）。</li>
<li><strong>后端发送事件到前端 (Event)</strong>：Go 后端可以通过 <code>runtime.EventsEmit(ctx, &quot;eventName&quot;, data)</code> 向前端发送自定义事件，JavaScript 可以在前端使用 <code>runtime.EventsOn(&quot;eventName&quot;, callback)</code> 监听这些事件。</li>
</ul>
</li>
<li><strong>数据绑定</strong>：Wails 的数据绑定功能允许前端直接调用 Go 方法并获取返回值，或者订阅 Go 发出的事件，实现前后端数据的实时同步和交互。</li>
</ul>
<h3 id="2-4-Wails-CLI-Command-Line-Interface"><a href="#2-4-Wails-CLI-Command-Line-Interface" class="headerlink" title="2.4 Wails CLI (Command Line Interface)"></a>2.4 Wails CLI (Command Line Interface)</h3><ul>
<li><strong>定义</strong>：Wails CLI 是一个强大的命令行工具，用于创建、开发、构建 Wails 项目。</li>
<li><strong>功能</strong>：<ul>
<li><code>wails init</code>：初始化 Wails 项目，可以选择前端框架模板。</li>
<li><code>wails dev</code>：开发模式运行应用，支持热重载。</li>
<li><code>wails build</code>：构建生产环境的应用，生成安装包（<code>.exe</code>, <code>.app</code>, <code>.deb</code> 等）。</li>
<li><code>wails generate</code>：生成绑定代码等。</li>
</ul>
</li>
</ul>
<h3 id="2-5-配置文件-wails-json"><a href="#2-5-配置文件-wails-json" class="headerlink" title="2.5 配置文件 (wails.json)"></a>2.5 配置文件 (<code>wails.json</code>)</h3><ul>
<li><strong>定义</strong>：Wails 项目的核心配置文件，定义了应用的元数据、构建选项、桌面原生特性等。</li>
<li><strong>关键配置项</strong>：<ul>
<li><code>name</code>：应用名称。</li>
<li><code>shortname</code>：短名称。</li>
<li><code>description</code>：应用描述。</li>
<li><code>frontend</code>：前端构建命令、分发目录等。</li>
<li><code>wails</code>：<ul>
<li><code>app</code>：配置应用窗口属性（标题、大小、是否可调整大小等）、图标、菜单等。</li>
<li><code>webview</code>：WebView 特有的配置。</li>
<li><code>build</code>：Go 模块路径、编译标志等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、Wails-的开发流程"><a href="#三、Wails-的开发流程" class="headerlink" title="三、Wails 的开发流程"></a>三、Wails 的开发流程</h2><h3 id="3-1-准备环境"><a href="#3-1-准备环境" class="headerlink" title="3.1 准备环境"></a>3.1 准备环境</h3><ol>
<li><strong>Go 语言环境</strong>：安装 Go SDK (Go 1.18+)。</li>
<li><strong>Node.js 和 npm&#x2F;yarn</strong>：用于前端项目管理。</li>
<li><strong>系统 WebView 依赖</strong>：<ul>
<li><strong>Windows</strong>：需要安装 WebView2 Runtime（如果系统没有）。</li>
<li><strong>Linux</strong>：需要安装 <code>webkit2gtk</code> 或 <code>webkitgtk</code> 等依赖。</li>
<li><strong>macOS</strong>：通常无需额外安装。</li>
</ul>
</li>
<li><strong>Wails CLI</strong>：<code>go install github.com/wailsapp/wails/v2/cmd/wails@latest</code>。</li>
</ol>
<h3 id="3-2-创建项目"><a href="#3-2-创建项目" class="headerlink" title="3.2 创建项目"></a>3.2 创建项目</h3><p>使用 Wails CLI 初始化一个新项目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wails init -n my-wails-app -t vue <span class="comment"># 选择 Vue 模板</span></span><br><span class="line"><span class="comment"># 或者 wails init -n my-wails-app -t react</span></span><br></pre></td></tr></table></figure>

<p>项目结构示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-wails-app/</span><br><span class="line">├── frontend/              # 前端 Web 代码 (例如 Vue/React 项目)</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── src/</span><br><span class="line">│   └── package.json</span><br><span class="line">├── main.go                # Go 后端代码和应用入口点</span><br><span class="line">├── wails.json             # Wails 核心配置文件</span><br><span class="line">└── go.mod / go.sum        # Go 模块文件</span><br></pre></td></tr></table></figure>

<h3 id="3-3-编写前端代码"><a href="#3-3-编写前端代码" class="headerlink" title="3.3 编写前端代码"></a>3.3 编写前端代码</h3><p>在 <code>frontend/</code> 目录下像往常一样编写你的 Web 应用。<br><strong>示例 (前端调用后端 Go 方法):</strong><br><code>frontend/src/App.vue</code> (Vue 示例)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello Wails!&lt;/h1&gt;</span><br><span class="line">    &lt;input v-model=&quot;name&quot; placeholder=&quot;Enter your name&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">    &lt;p v-if=&quot;greeting&quot;&gt;&#123;&#123; greeting &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const name = ref(&#x27;&#x27;);</span><br><span class="line">const greeting = ref(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">async function greet() &#123;</span><br><span class="line">  if (name.value) &#123;</span><br><span class="line">    // 调用 Go 后端的 &#x27;Greet&#x27; 方法，这里的 &#x27;App&#x27; 是 Go 结构体的实例名</span><br><span class="line">    // 假设 Go 后端有一个名为 &#x27;App&#x27; 的结构体，上面有一个 &#x27;Greet&#x27; 方法</span><br><span class="line">    greeting.value = await window.go.main.App.Greet(name.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-编写后端代码-Go"><a href="#3-4-编写后端代码-Go" class="headerlink" title="3.4 编写后端代码 (Go)"></a>3.4 编写后端代码 (Go)</h3><p>在 <code>main.go</code> 中定义 Go 结构体和方法，并注册到 Wails 应用中。<br><strong>示例 (Go 后端方法):</strong><br><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/wailsapp/wails/v2/pkg/runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// App struct 包含应用程序的上下文和业务逻辑</span></span><br><span class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</span><br><span class="line">	ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewApp 创建一个新的 App 结构体实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span></span> *App &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;App&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// startup 是在应用启动时调用的方法，用于注入上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> startup(ctx context.Context) &#123;</span><br><span class="line">	a.ctx = ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greet 方法是一个暴露给前端的 Go 方法</span></span><br><span class="line"><span class="comment">// 前端可以调用这个方法，并传递一个 name 参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> Greet(name <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 可以在这里执行 Go 的业务逻辑，例如文件操作、网络请求等</span></span><br><span class="line">	<span class="comment">// 也可以通过 runtime.Log.Info 等记录日志</span></span><br><span class="line">	runtime.LogInfo(a.ctx, fmt.Sprintf(<span class="string">&quot;Greet method called with name: %s&quot;</span>, name))</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hello %s, from Go!&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	app := NewApp()</span><br><span class="line"></span><br><span class="line">	err := wails.Run(&amp;options.App&#123;</span><br><span class="line">		Title:  <span class="string">&quot;My Wails App&quot;</span>,</span><br><span class="line">		Width:  <span class="number">1024</span>,</span><br><span class="line">		Height: <span class="number">768</span>,</span><br><span class="line">		AssetServer: &amp;options.AssetServer&#123;</span><br><span class="line">			Handler: assets.NewFileSystem(),</span><br><span class="line">		&#125;,</span><br><span class="line">		BackgroundColour: &amp;options.RGBA&#123;R: <span class="number">27</span>, G: <span class="number">38</span>, B: <span class="number">54</span>, A: <span class="number">1</span>&#125;,</span><br><span class="line">		OnStartup:        app.startup, <span class="comment">// 注册 startup 方法</span></span><br><span class="line">		Bind: []<span class="keyword">interface</span>&#123;&#125;&#123;           <span class="comment">// 注册 Go 结构体实例，其方法将暴露给前端</span></span><br><span class="line">			app,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;Error:&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-运行与构建"><a href="#3-5-运行与构建" class="headerlink" title="3.5 运行与构建"></a>3.5 运行与构建</h3><ul>
<li><strong>开发模式</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wails dev</span><br></pre></td></tr></table></figure>
这会启动你的前端开发服务器，并在一个 Wails 窗口中加载它。支持热重载。</li>
<li><strong>构建生产版本</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wails build</span><br></pre></td></tr></table></figure>
这会编译你的 Go 后端，打包前端资源，并生成针对当前操作系统架构的原生应用安装包或可执行文件。</li>
</ul>
<h2 id="四、Wails-与-Tauri-的对比"><a href="#四、Wails-与-Tauri-的对比" class="headerlink" title="四、Wails 与 Tauri 的对比"></a>四、Wails 与 Tauri 的对比</h2><p>Wails 和 Tauri 都是优秀的 Electron 替代品，它们共享许多核心理念（如使用系统 WebView、小体积、低内存）。主要区别在于后端语言和生态：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Wails</th>
<th align="left">Tauri</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>后端语言</strong></td>
<td align="left">Go 语言</td>
<td align="left">Rust 语言</td>
</tr>
<tr>
<td align="left"><strong>后端性能</strong></td>
<td align="left">高，Go 的并发和运行时性能优异</td>
<td align="left">极高，Rust 提供极致的内存安全和运行时性能</td>
</tr>
<tr>
<td align="left"><strong>语言门槛</strong></td>
<td align="left">Go 开发者友好，学习曲线相对平缓</td>
<td align="left">Rust 学习曲线陡峭，对新人可能更具挑战</td>
</tr>
<tr>
<td align="left"><strong>生态系统</strong></td>
<td align="left">依赖 Go 生态，标准库和工具链成熟</td>
<td align="left">依赖 Rust 生态，内存安全和系统编程能力强</td>
</tr>
<tr>
<td align="left"><strong>安全强调</strong></td>
<td align="left">良好的安全实践，但也依赖 Go 的安全性</td>
<td align="left">默认安全，Rust 语言特性和严格的权限控制提供更高级别的安全保障</td>
</tr>
<tr>
<td align="left"><strong>社区活跃度</strong></td>
<td align="left">活跃，但相对 Tauri 稍小</td>
<td align="left">极度活跃，社区成长迅速，获得更多关注和投资</td>
</tr>
<tr>
<td align="left"><strong>打包体积</strong></td>
<td align="left">极小 (几MB)</td>
<td align="left">极小 (几MB)</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">低，接近原生应用</td>
<td align="left">低，接近原生应用</td>
</tr>
</tbody></table>
<p><strong>选择建议：</strong></p>
<ul>
<li><strong>如果你是 Go 开发者</strong>，或者你的项目已经有大量 Go 代码，Wails 可能是更自然、更高效的选择。你可以直接复用 Go 的库和经验。</li>
<li><strong>如果你关注极致的性能、内存安全，或者你的团队已经有 Rust 经验</strong>，并且愿意投入学习 Rust，Tauri 提供了更强大的底层控制和更强的安全保证。</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Wails 提供了一个出色的解决方案，让 Go 开发者能够利用他们熟悉的语言构建高性能、轻量级、跨平台的桌面应用程序。它结合了 Go 语言的简洁、高效和 Web 前端技术的灵活性，为桌面应用开发带来了新的活力。</p>
<p>虽然它仍是一个相对年轻的框架，但其核心优势（小体积、低内存、Go 后端）使其在特定场景下成为 Electron 或其他更重型框架的有力竞争者。对于 Go 语言生态中的开发者而言，Wails 无疑是构建桌面应用时一个值得认真考虑的优秀选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/cdecf00b2f41/">https://blog.tbf1211.xx.kg/cdecf00b2f41/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91/">桌面开发</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/0d75739ade66/" title="OrbStack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">OrbStack 详解</div></div><div class="info-2"><div class="info-item-1"> OrbStack 是一款专为 macOS 和 Linux 用户设计的高性能、轻量级工具，旨在成为 Docker Desktop 和 Colima&#x2F;Rancher Desktop 的替代品。它提供了一个闪电般快速的开发环境，用于运行 Docker 容器、Kubernetes 集群以及完整的 Linux 虚拟机，旨在提供原生级别的性能、更低的资源占用和更卓越的用户体验。  核心思想： OrbStack 专注于优化在 macOS 和 Linux 上运行容器和 Linux 环境的性能和资源效率，通过巧妙的虚拟化技术和精简设计，提供比传统解决方案更快启动、更少耗电、更流畅的体验。   一、为什么需要 OrbStack？传统的 Docker Desktop 或 Colima&#x2F;Rancher Desktop 在 macOS 上存在一些痛点：  性能问题： Docker Desktop 基于笨重的 HyperKit 或 QEMU 虚拟机，启动慢，文件 I&#x2F;O 性能差，尤其是在处理大量文件操作时（如 Node.js 或 PHP 项目的 node_modules）。 ...</div></div></div></a><a class="pagination-related" href="/1f3778022029/" title="Rust Tauri 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Rust Tauri 详解</div></div><div class="info-2"><div class="info-item-1"> Tauri 是一个用 Rust 编写的开源框架，旨在帮助开发者使用前端 Web 技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能且安全的原生跨平台桌面应用程序。它被视为 Electron 的轻量级、高性能替代方案，特别强调捆包体积小、内存占用低和增强的安全性。  核心思想：将现代 Web 前端技术与 Rust 编写的原生后端结合，通过操作系统的 WebView 渲染 UI，实现性能与安全并重的桌面应用开发。    一、为什么选择 Tauri？传统的 Web 技术构建桌面应用主要依赖于像 Electron 这样的框架。Electron 的优势在于能够直接复用 Web 生态，但其劣势也显而易见：  捆包体积大：Electron 应用会捆绑 Chromium 浏览器和 Node.js 运行时，导致应用体积通常较大（数十MB到数百MB）。 内存占用高：Chromium 和 Node.js 运行时都会消耗大量内存，使得 Electron 应用的内存占用普遍较高。 性能...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2565d3c3db01/" title="Go语言embed包详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">Go语言embed包详解</div></div><div class="info-2"><div class="info-item-1"> Go 标准库从 Go 1.16 版本开始引入了 embed 1 包。这个包提供了一种简单、声明式的方式，允许开发者将静态文件（如 HTML 模板、CSS、JavaScript、图片、配置文件等）直接嵌入到 Go 可执行文件中。这意味着你可以通过一个独立的二进制文件分发所有应用程序所需的资源，而无需额外管理外部文件，极大地简化了部署和分发过程。  核心思想：将应用程序的外部资源（静态文件）编译进最终的二进制文件，实现“单一二进制文件”的发布和部署，消除外部文件依赖带来的复杂性。   一、为什么需要 embed 包？在 embed 包之前，Go 语言应用程序处理静态资源通常有以下几种方式：  外部文件：将静态文件与可执行文件放在一起分发。这会带来：  部署复杂性：需要确保文件结构正确，并处理文件丢失或路径错误的问题。 文件篡改风险：外部文件容易被修改，可能影响程序的行为或安全性。 分发不便：每次更新都需要同步可执行文件和所有相关资源文件。   go:embed 第三方库：许多第三方库（如 go-bindata, packr）实现了文件嵌入功能。这些库虽然有效，但通常需要一些额外的构...</div></div></div></a><a class="pagination-related" href="/1f3778022029/" title="Rust Tauri 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">Rust Tauri 详解</div></div><div class="info-2"><div class="info-item-1"> Tauri 是一个用 Rust 编写的开源框架，旨在帮助开发者使用前端 Web 技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能且安全的原生跨平台桌面应用程序。它被视为 Electron 的轻量级、高性能替代方案，特别强调捆包体积小、内存占用低和增强的安全性。  核心思想：将现代 Web 前端技术与 Rust 编写的原生后端结合，通过操作系统的 WebView 渲染 UI，实现性能与安全并重的桌面应用开发。    一、为什么选择 Tauri？传统的 Web 技术构建桌面应用主要依赖于像 Electron 这样的框架。Electron 的优势在于能够直接复用 Web 生态，但其劣势也显而易见：  捆包体积大：Electron 应用会捆绑 Chromium 浏览器和 Node.js 运行时，导致应用体积通常较大（数十MB到数百MB）。 内存占用高：Chromium 和 Node.js 运行时都会消耗大量内存，使得 Electron 应用的内存占用普遍较高。 性能...</div></div></div></a><a class="pagination-related" href="/f200f6bfe5fa/" title="Golang 特殊注释 (Special Comments) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="info-item-2">Golang 特殊注释 (Special Comments) 详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，除了我们日常用于解释代码逻辑的普通注释 // 和 /* */ 之外，还存在一些具有特殊含义的注释。这些特殊注释通常以 //go: 或 // + 开头，它们并不是为程序员阅读而生，而是作为指令直接与 Go 工具链（编译器、链接器、go generate 等）交互，用于控制编译行为、生成代码、导入 C 代码，或者提供额外的信息。  核心思想：特殊注释是 Go 工具链的“命令”，用于扩展 Go 语言的能力，例如嵌入文件、生成代码、与 C 语言交互或进行性能优化。   一、Go 特殊注释的分类与作用Go 的特殊注释大致可以分为几类：  编译器指令 (Build Constraints)：控制哪些文件或代码块在特定条件下编译。 代码生成指令 (go generate)：标记需要执行特定外部工具来生成代码的位置。 cgo 指令：用于 Go 和 C&#x2F;C++ 代码之间的互操作。 embed 指令：将静态文件嵌入到 Go 二进制文件中 (Go 1.16+)。 运行时或工具指令：用于性能分析、内存管理等内部或高级用途。  接下来的章节将详细介绍这些特殊注释。 二、//g...</div></div></div></a><a class="pagination-related" href="/8f9f1342d7a2/" title="Golang 如何等待多个 Goroutine"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">Golang 如何等待多个 Goroutine</div></div><div class="info-2"><div class="info-item-1"> Goroutine 是 Go 语言轻量级并发的核心，它使得在程序中同时运行多个任务变得简单高效。然而，当启动多个 Goroutine 后，主程序或管理 Goroutine 常常需要知道这些并发任务何时完成，或者需要等待它们全部完成后再继续执行。这种“等待 Goroutine 完成”的机制是并发编程中至关重要的一环，确保了程序的正确性、资源的有序释放以及结果的汇总。  核心思想：管理 Goroutine 的生命周期是并发编程的关键。Go 提供了 sync.WaitGroup、Channels 以及 context.Context 结合 errgroup.Group 等多种机制，以适应不同复杂度和需求的 Goroutine 等待场景。   一、为什么需要等待 Goroutine？在 Go 语言中，main 函数的 Goroutine 启动后，即使它退出了，其他未完成的 Goroutine 也会继续运行。但通常情况下，我们希望：  确保任务完成：等待所有子 Goroutine 完成计算、I&#x2F;O 操作或数据处理，以避免数据丢失或不完整。 结果汇总：在所有 Goroutine ...</div></div></div></a><a class="pagination-related" href="/039eceb7c0db/" title="Golang Dig 深度解析：强大的依赖注入容器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-11</div><div class="info-item-2">Golang Dig 深度解析：强大的依赖注入容器</div></div><div class="info-2"><div class="info-item-1"> Dig 是 Google 开源的一个用于 Go 语言的依赖注入 (Dependency Injection, DI) 容器。它旨在帮助 Go 开发者管理复杂的应用程序对象图，通过自动化的方式解决组件之间的依赖关系，从而提高代码的可测试性、可维护性和模块化程度。  核心思想：Dig 通过 Go 语言的反射机制，在运行时分析函数的参数和返回值类型，自动构建并解析应用程序的依赖图。它将对象创建的逻辑（”提供者”）和对象使用的逻辑（”调用者”）分离，使得开发者无需手动管理复杂的对象实例化过程。   一、为什么需要依赖注入和 Dig？在构建复杂的 Go 应用程序时，组件之间往往存在错综复杂的依赖关系。手动管理这些依赖通常会导致以下问题：  代码耦合度高：当一个结构体直接实例化其依赖的结构体时，两者紧密耦合。 难以测试：紧密耦合使得单元测试难以进行，因为无法轻松替换依赖项（如用 Mock 对象替代真实的数据库连接）。 实例化逻辑分散：对象的创建逻辑可能散布在应用程序的各个部分，难以统一管理和追踪。 难以重构：修改一个组件的依赖可能需要修改所有使用它的地方。  依赖注入 (DI) 是一种软件...</div></div></div></a><a class="pagination-related" href="/eebf85c66545/" title="hls.js 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-17</div><div class="info-item-2">hls.js 详解</div></div><div class="info-2"><div class="info-item-1"> hls.js 是一个开源的 JavaScript 库，它实现了 HTTP Live Streaming (HLS) 协议，使浏览器能够通过标准的 HTML5 &lt;video&gt; 标签播放 HLS 视频流。HLS 是 Apple 公司开发的一种流媒体传输协议，被广泛应用于音视频内容的分发。由于原生浏览器通常只支持播放 MP4 等直接文件格式或特定 HLS 实现（如 Safari），而 Chrome、Firefox 等浏览器缺乏对 HLS 的原生支持，hls.js 填补了这一空白，让开发者能够在几乎所有现代浏览器中提供 HLS 流媒体服务。  核心思想：hls.js 通过 JavaScript 解析 HLS manifest (M3U8) 文件，动态加载和拼接 TS (MPEG-2 Transport Stream) 片段，并利用 Media Source Extensions (MSE) API 将这些片段喂给 HTML5 &lt;video&gt; 元素进行播放，从而实现浏览器对 HLS 流媒体的广泛支持。   一、为什么需要 hls.js？HLS 协议是目前最流行的流...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">455</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-Wails%EF%BC%9F"><span class="toc-text">一、为什么选择 Wails？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Wails-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Wails 的核心架构与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-WebView-%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-text">2.1 WebView (前端渲染)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Go-%E5%90%8E%E7%AB%AF-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-text">2.2 Go 后端 (业务逻辑)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Runtime-%E6%A1%A5%E6%8E%A5-IPC"><span class="toc-text">2.3 Runtime 桥接 (IPC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Wails-CLI-Command-Line-Interface"><span class="toc-text">2.4 Wails CLI (Command Line Interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-wails-json"><span class="toc-text">2.5 配置文件 (wails.json)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Wails-%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">三、Wails 的开发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83"><span class="toc-text">3.1 准备环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">3.2 创建项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E5%86%99%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-text">3.3 编写前端代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BC%96%E5%86%99%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81-Go"><span class="toc-text">3.4 编写后端代码 (Go)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%BF%90%E8%A1%8C%E4%B8%8E%E6%9E%84%E5%BB%BA"><span class="toc-text">3.5 运行与构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Wails-%E4%B8%8E-Tauri-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">四、Wails 与 Tauri 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-28.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>