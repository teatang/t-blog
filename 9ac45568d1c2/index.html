<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WSL2详解：在Windows运行Linux的新标准 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="WSL 2 (适用于 Linux 的 Windows 子系统 2 - Windows Subsystem for Linux 2) 是微软推出的一项技术，它允许开发者在 Windows 操作系统上直接运行原生 Linux 环境，而无需双启动或传统虚拟机。WSL 2 相较于其前身 WSL 1，最大的变化是它运行在一个轻量级的虚拟机中，其中包含一个完整的 Linux 内核，这极大地提升了文件系统性能">
<meta property="og:type" content="article">
<meta property="og:title" content="WSL2详解：在Windows运行Linux的新标准">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/9ac45568d1c2/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="WSL 2 (适用于 Linux 的 Windows 子系统 2 - Windows Subsystem for Linux 2) 是微软推出的一项技术，它允许开发者在 Windows 操作系统上直接运行原生 Linux 环境，而无需双启动或传统虚拟机。WSL 2 相较于其前身 WSL 1，最大的变化是它运行在一个轻量级的虚拟机中，其中包含一个完整的 Linux 内核，这极大地提升了文件系统性能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2025-09-21T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-24T07:56:13.745Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="虚拟机">
<meta property="article:tag" content="WSL2">
<meta property="article:tag" content="Hyper-V">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WSL2详解：在Windows运行Linux的新标准",
  "url": "https://blog.tbf1211.xx.kg/9ac45568d1c2/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2025-09-21T22:24:00.000Z",
  "dateModified": "2025-12-24T07:56:13.745Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/9ac45568d1c2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WSL2详解：在Windows运行Linux的新标准',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">431</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">222</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">WSL2详解：在Windows运行Linux的新标准</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">WSL2详解：在Windows运行Linux的新标准</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>WSL 2 (适用于 Linux 的 Windows 子系统 2 - Windows Subsystem for Linux 2)</strong> 是微软推出的一项技术，它允许开发者在 Windows 操作系统上直接运行原生 Linux 环境，而无需双启动或传统虚拟机。WSL 2 相较于其前身 WSL 1，最大的变化是它运行在一个轻量级的虚拟机中，其中包含一个完整的 Linux 内核，这极大地提升了文件系统性能、系统调用兼容性和 Docker Desktop 的体验。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>在 Windows 内部无缝集成一个高性能、高度兼容的原生 Linux 环境，兼顾 Windows 的图形界面和 Linux 的命令行工具优势。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-WSL-2？"><a href="#一、为什么需要-WSL-2？" class="headerlink" title="一、为什么需要 WSL 2？"></a>一、为什么需要 WSL 2？</h2><p>传统的 Linux 开发环境设置通常涉及以下几种方式：</p>
<ol>
<li><strong>双系统</strong>：需要重启电脑才能切换操作系统，且占用硬盘空间大。</li>
<li><strong>虚拟机 (VirtualBox, VMWare)</strong>：性能开销大，与 Windows 系统的集成度不高，共享文件、剪贴板等操作相对繁琐。</li>
<li><strong>WSL 1</strong>：提供了一个兼容层，将 Linux 系统调用转换为 Windows NT 内核调用。性能优于虚拟机，但文件系统性能（尤其是涉及到大量文件操作）和系统调用兼容性仍有局限性。</li>
</ol>
<p>WSL 2 通过引入真实的 Linux 内核，旨在解决这些痛点，提供以下核心优势：</p>
<ul>
<li><strong>完全的系统调用兼容性</strong>：由于运行的是真实的 Linux 内核，几乎所有的 Linux 应用程序都可以运行，包括 Docker、Kubernetes 以及其他需要完整内核访问权限的工具。</li>
<li><strong>卓越的文件系统性能</strong>：在 Linux 文件系统内部操作文件时，性能与原生 Linux 几乎无异，尤其是在进行 <code>git clone</code>、<code>npm install</code>、<code>apt update</code> 等操作时感受明显。</li>
<li><strong>性能提升</strong>：整体性能优于 WSL 1 和传统虚拟机，启动速度快，资源占用低。</li>
<li><strong>与 Windows 进程高度集成</strong>：无需配置网络，Windows 和 WSL 之间可以直接通过 <code>localhost</code> 访问服务，并且可以直接在 Windows 文件管理器中访问 Linux 文件系统。</li>
<li><strong>Docker Desktop 增强</strong>：Docker Desktop for Windows 可以直接使用 WSL 2 作为后端，极大地提升了其性能和稳定性。</li>
</ul>
<h2 id="二、WSL-2-的架构与工作原理"><a href="#二、WSL-2-的架构与工作原理" class="headerlink" title="二、WSL 2 的架构与工作原理"></a>二、WSL 2 的架构与工作原理</h2><p>WSL 2 运行在轻量级的实用程序虚拟机中，它利用了 Windows 的 Hyper-V (虚拟化) 技术。与传统 Hyper-V 虚拟机不同的是，WSL 2 拥有更低的资源占用和更快的启动速度。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[用户] --&gt; B[Windows 应用程序]
    A[用户] --&gt; C[&quot;WSL 2 (Linux 终端)&quot;]

    B --&gt; D[Windows 内核]
    D -- Hyper-V 虚拟化技术 --&gt; E[轻量级 Utility VM]
    C --&gt; E

    E --&gt; F[Linux 内核]
    F --&gt; G[&quot;Linux 发行版 (Ubuntu, Debian等)&quot;]
    F --- H[Docker Desktop 集成]
    H --&gt; G
  </pre></div>

<p><strong>关键组件：</strong></p>
<ul>
<li><strong>轻量级 Utility VM</strong>：这是一个高度优化的 Hyper-V 虚拟机，专门为运行 WSL 2 实例而设计。它只占用所需的资源，并在不需要时自动释放内存。</li>
<li><strong>真实的 Linux 内核</strong>：微软基于最新的稳定版 Linux 内核进行了优化和定制，使其能够运行在 Utility VM 中。这个内核提供了完整的系统调用支持。</li>
<li><strong>文件系统集成</strong>：WSL 2 将 Linux 文件系统作为一个 VHD (Virtual Hard Disk) 文件存储在 Windows 文件系统上。Windows 提供了网络共享的方式，允许用户通过 <code>\\wsl$\&lt;DistroName&gt;</code> 路径直接访问 Linux 文件系统。</li>
<li><strong>网络桥接</strong>：WSL 2 虚拟机拥有自己的 IP 地址，并通过网络地址转换 (NAT) 与 Windows 主机进行通信。同时，Windows 通过一些后台服务将 WSL 2 的端口转发到 <code>localhost</code>，实现了两者间的无缝通信。</li>
</ul>
<h2 id="三、WSL-2-的安装与设置"><a href="#三、WSL-2-的安装与设置" class="headerlink" title="三、WSL 2 的安装与设置"></a>三、WSL 2 的安装与设置</h2><h3 id="3-1-环境要求"><a href="#3-1-环境要求" class="headerlink" title="3.1 环境要求"></a>3.1 环境要求</h3><ul>
<li><strong>Windows 版本</strong>：Windows 10 版本 1903 或更高，或 Windows 11。</li>
<li><strong>启用虚拟化</strong>：BIOS&#x2F;UEFI 中需要启用虚拟化功能 (如 Intel VT-x, AMD-V)。</li>
<li><strong>WSL 功能</strong>：需要启用“适用于 Linux 的 Windows 子系统”和“虚拟机平台”组件。</li>
</ul>
<h3 id="3-2-命令行简化安装-Windows-11-或更高版本，以及部分-Windows-10-更新"><a href="#3-2-命令行简化安装-Windows-11-或更高版本，以及部分-Windows-10-更新" class="headerlink" title="3.2 命令行简化安装 (Windows 11 或更高版本，以及部分 Windows 10 更新)"></a>3.2 命令行简化安装 (Windows 11 或更高版本，以及部分 Windows 10 更新)</h3><p>对于大多数用户，可以通过一个命令进行简化安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure>

<p>此命令将：</p>
<ol>
<li>启用所需的 WSL 和虚拟机平台组件。</li>
<li>下载并安装最新的 Linux 内核。</li>
<li>安装 Ubuntu 作为默认的 Linux 发行版。</li>
</ol>
<h3 id="3-3-手动安装步骤-适用于-Windows-10-旧版本或自定义安装"><a href="#3-3-手动安装步骤-适用于-Windows-10-旧版本或自定义安装" class="headerlink" title="3.3 手动安装步骤 (适用于 Windows 10 旧版本或自定义安装)"></a>3.3 手动安装步骤 (适用于 Windows 10 旧版本或自定义安装)</h3><ol>
<li><p><strong>启用 WSL 和虚拟机平台组件：</strong><br>以管理员身份打开 PowerShell 或命令提示符，执行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows-Subsystem-Linux</span> /all /norestart</span><br><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>
<p>然后重启电脑。</p>
</li>
<li><p><strong>下载并安装 Linux 内核更新包：</strong><br>访问 WSL 的官方安装指南 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual"><sup>1</sup></a> 下载 “WSL2 Linux 内核更新包”。安装该 <code>.msi</code> 包。</p>
</li>
<li><p><strong>将 WSL 2 设置为默认版本：</strong><br>打开 PowerShell，执行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果遇到错误，请确保已安装内核更新包。</p>
</li>
<li><p><strong>安装 Linux 发行版：</strong><br>从 Microsoft Store 搜索并下载你喜欢的 Linux 发行版 (如 Ubuntu, Debian, Kali Linux)。<br>首次启动发行版时，会提示你创建用户名和密码。</p>
</li>
<li><p><strong>将已安装的 WSL 1 发行版升级到 WSL 2 (如果之前有 WSL 1)：</strong><br>首先，查看你的发行版列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<p>然后，将指定发行版升级到 WSL 2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-version &lt;DistroName&gt; 2</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-version Ubuntu 2</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="四、WSL-2-常用指令详解"><a href="#四、WSL-2-常用指令详解" class="headerlink" title="四、WSL 2 常用指令详解"></a>四、WSL 2 常用指令详解</h2><p>以下是 WSL 2 的一些关键命令行指令，用于管理和操作你的 Linux 发行版。</p>
<h3 id="4-1-管理-WSL-发行版"><a href="#4-1-管理-WSL-发行版" class="headerlink" title="4.1 管理 WSL 发行版"></a>4.1 管理 WSL 发行版</h3><ul>
<li><p><strong>列出已安装的发行版及其状态：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v  <span class="comment"># 或 wsl --list --verbose</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>NAME</code>：发行版名称。</li>
<li><code>STATE</code>：发行版状态 (如 Running, Stopped)。</li>
<li><code>VERSION</code>：WSL 版本 (1 或 2)。</li>
</ul>
<p><strong>示例输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  NAME            STATE           VERSION</span><br><span class="line">* Ubuntu          Running         2</span><br><span class="line">  Debian          Stopped         2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置默认 WSL 版本 (1 或 2)：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version &lt;VersionNumber&gt;</span><br></pre></td></tr></table></figure>
<p>这会影响未来新安装的发行版的默认版本。</p>
</li>
<li><p><strong>设置指定发行版的版本：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-version &lt;DistroName&gt; &lt;VersionNumber&gt;</span><br></pre></td></tr></table></figure>
<p>例如，将 Ubuntu 切换到 WSL 1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-version Ubuntu 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将指定发行版设置为默认发行版：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default &lt;DistroName&gt;</span><br></pre></td></tr></table></figure>
<p>每次运行 <code>wsl</code> 命令，启动的将是这个默认发行版。</p>
</li>
<li><p><strong>终止指定发行版：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --terminate &lt;DistroName&gt;  <span class="comment"># 或 wsl -t &lt;DistroName&gt;</span></span><br></pre></td></tr></table></figure>
<p>这会强制停止正在运行的发行版。</p>
</li>
<li><p><strong>关停所有运行的发行版和 WSL 2 VM：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>
<p>这会释放 WSL 2 占用的所有内存资源。</p>
</li>
<li><p><strong>注销&#x2F;卸载发行版：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;DistroName&gt;</span><br></pre></td></tr></table></figure>
<p>警告：这将删除该发行版的所有数据和文件！</p>
</li>
<li><p><strong>修改 WSL 2 虚拟硬盘大小 (或移动)：</strong><br>WSL 2 的虚拟硬盘通常随着使用而增长，但不会自动收缩。你可以手动收缩。</p>
<ol>
<li>首先，关停所有 WSL 2 实例：<code>wsl --shutdown</code>。</li>
<li>找到 VHD 文件路径。你可以在 Windows 资源管理器中输入 <code>\\wsl$\</code>，然后进入你的发行版，搜索 <code>.vhdx</code> 文件。通常在 <code>%LOCALAPPDATA%\Packages\&lt;DistroPackageName&gt;\LocalState\ext4.vhdx</code>。</li>
<li>打开 PowerShell 管理员模式，使用磁盘管理工具 (Diskpart)。<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;&lt;PathToYourVHDXFile&gt;&quot;</span> <span class="comment"># 替换为你的vhd文件路径</span></span><br><span class="line">attach vdisk readonly</span><br><span class="line">compact vdisk</span><br><span class="line">detach vdisk</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="4-2-访问-WSL-文件系统"><a href="#4-2-访问-WSL-文件系统" class="headerlink" title="4.2 访问 WSL 文件系统"></a>4.2 访问 WSL 文件系统</h3><ul>
<li><p><strong>从 Windows 访问 Linux 文件系统：</strong><br>在 Windows 文件资源管理器中，你可以在地址栏输入 <code>\\wsl$</code>，然后会看到所有已安装的 WSL 发行版。点击进入即可像普通网络共享一样访问 Linux 文件。<br>或者直接在 PowerShell 或 CMD 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explorer.exe \\wsl$\Ubuntu\home\&lt;YourUserName&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从 Linux 访问 Windows 文件系统：</strong><br>Windows 驱动器被自动挂载到 <code>/mnt</code> 目录下。<br>例如，Windows 的 C 盘在 Linux 中是 <code>/mnt/c</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c/Users/&lt;YourWindowsUserName&gt;/Documents</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3-启动和执行命令"><a href="#4-3-启动和执行命令" class="headerlink" title="4.3 启动和执行命令"></a>4.3 启动和执行命令</h3><ul>
<li><p><strong>启动默认 WSL 发行版：</strong><br>直接在命令提示符或 PowerShell 中输入 <code>wsl</code>，会启动默认的 Linux 发行版。</p>
</li>
<li><p><strong>启动指定的 WSL 发行版：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -d &lt;DistroName&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -d Debian</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 WSL 发行版中执行命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="built_in">ls</span> -l /</span><br><span class="line">wsl apt update</span><br></pre></td></tr></table></figure>
<p>你也可以针对特定发行版执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -d Ubuntu apt install gcc</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Windows 上执行 Linux 命令：</strong><br>反之亦然，你可以在 Linux 终端中运行 Windows 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Linux 终端中运行 Windows powershell 命令</span></span><br><span class="line">powershell.exe Get-Service</span><br><span class="line"><span class="comment"># 在 Linux 终端中运行 Windows notepad</span></span><br><span class="line">notepad.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-4-网络配置"><a href="#4-4-网络配置" class="headerlink" title="4.4 网络配置"></a>4.4 网络配置</h3><p>WSL 2 默认使用 NAT 网络模式，这意味着它有一个独立的 IP 地址，并且通过端口转发与 Windows 主机通信。</p>
<ul>
<li><p><strong>在 Windows 访问 WSL 2 服务：</strong><br>如果你的 WSL 2 中运行了一个服务 (例如 Web 服务器在 8000 端口)，你可以直接在 Windows 浏览器中访问 <code>http://localhost:8000</code>。<br>WSL 2 会自动进行端口转发。</p>
</li>
<li><p><strong>在 WSL 2 中访问 Windows 服务：</strong><br>Windows 主机的 IP 地址通常可以通过 <code>cat /etc/resolv.conf</code> 查看到 <code>nameserver</code> 的 IP，这就是你的 Windows 主机 IP。<br>例如，如果 Windows 上运行的服务在 <code>192.168.1.100:8080</code>，那么在 WSL 中访问 <code>http://192.168.1.100:8080</code> 即可。</p>
</li>
<li><p><strong>固定 WSL 2 IP (高级)：</strong><br>由于 WSL 2 的 IP 地址会动态变化，这可能对一些高级网络配置造成不便。可以通过修改 <code>.wslconfig</code> 文件来固定 IP 地址 (但建议仅在确实需要时进行，因为这会增加维护成本)。</p>
<p>创建一个 <code>%UserProfile%\.wslconfig</code> 文件 (如果不存在)，其内容示例如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="comment"># 固定 IP 地址 (仅示例，需要替换为你希望的子网和IP)</span></span><br><span class="line"><span class="comment"># virtualSwitch = wsl</span></span><br><span class="line"><span class="comment"># defaultIp = 192.168.50.10</span></span><br><span class="line"><span class="comment"># defaultGateway = 192.168.50.1</span></span><br><span class="line"><span class="comment"># dhcp = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制 WSL 2 分配的内存和处理器核心数</span></span><br><span class="line"><span class="attr">memory</span>=<span class="number">4</span>GB</span><br><span class="line"><span class="attr">processors</span>=<span class="number">2</span></span><br><span class="line"><span class="comment"># 禁用自动挂载所有 Windows 驱动器</span></span><br><span class="line"><span class="comment"># automount.enabled=false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-5-与-Visual-Studio-Code-集成"><a href="#4-5-与-Visual-Studio-Code-集成" class="headerlink" title="4.5 与 Visual Studio Code 集成"></a>4.5 与 Visual Studio Code 集成</h3><p>Visual Studio Code 对 WSL 2 提供了原生支持，这是 WSL 2 最强大的功能之一。</p>
<ol>
<li><p><strong>安装 Remote - WSL 扩展：</strong><br>在 VS Code 中安装 “Remote - WSL” 扩展。</p>
</li>
<li><p><strong>在 WSL 中打开项目：</strong></p>
<ul>
<li>在 WSL 终端中，导航到你的项目目录，然后输入 <code>code .</code>。</li>
<li>在 VS Code 中，点击左下角的绿色“远程指示器”，然后选择 “Connect to WSL”。</li>
<li>在 VS Code 中，使用 “File” -&gt; “Open Folder”，然后在弹出的对话框中选择 WSL 文件夹。</li>
</ul>
<p>VS Code 会在 WSL 中安装一个服务器，所有开发工作都在 Linux 环境中进行，但你依然使用 Windows 的 VS Code 界面。</p>
</li>
</ol>
<h2 id="五、WSL-2-的优缺点与适用场景"><a href="#五、WSL-2-的优缺点与适用场景" class="headerlink" title="五、WSL 2 的优缺点与适用场景"></a>五、WSL 2 的优缺点与适用场景</h2><h3 id="5-1-优点："><a href="#5-1-优点：" class="headerlink" title="5.1 优点："></a>5.1 优点：</h3><ol>
<li><strong>原生 Linux 内核</strong>：完整系统调用兼容性，几乎所有 Linux 应用和工具都能运行。</li>
<li><strong>高性能</strong>：文件系统性能大幅提升，尤其是涉及大量文件操作的场景。</li>
<li><strong>与 Windows 无缝集成</strong>：文件访问、网络互通、VS Code 远程开发体验极佳。</li>
<li><strong>Docker Desktop 完美后端</strong>：显著提升 Docker 在 Windows 上的性能和稳定性。</li>
<li><strong>资源效率高</strong>：轻量级虚拟机，启动快，资源占用少。</li>
</ol>
<h3 id="5-2-缺点："><a href="#5-2-缺点：" class="headerlink" title="5.2 缺点："></a>5.2 缺点：</h3><ol>
<li><strong>占用磁盘空间</strong>：每个发行版都是一个 <code>.vhdx</code> 文件，会随使用增长，需要手动收缩。</li>
<li><strong>图形界面支持有限</strong>：虽然可以通过 X server 运行简单的 Linux GUI 应用，但体验不如原生桌面。</li>
<li><strong>网络配置复杂性 (特定情况)</strong>：默认 NAT 模式对某些高级网络配置（如需要固定 IP、内网穿透）可能带来挑战。</li>
<li><strong>初始设置略复杂 (旧版本 Windows)</strong>：对于没有 <code>wsl --install</code> 命令的旧版 Windows 10，需要手动安装步骤。</li>
</ol>
<h3 id="5-3-适用场景："><a href="#5-3-适用场景：" class="headerlink" title="5.3 适用场景："></a>5.3 适用场景：</h3><ul>
<li><strong>Web 开发</strong>：前端或后端 (Node.js, Python, Go, Ruby 等) 开发者，无需在 Windows 上搭建复杂的环境，直接使用 Linux 的包管理器和工具链。</li>
<li><strong>容器化开发 (Docker, Kubernetes)</strong>：Docker Desktop for Windows 配合 WSL 2 提供了近乎原生的容器体验。</li>
<li><strong>跨平台开发</strong>：在 Windows 上进行 Linux 环境下的 C&#x2F;C++、Java 等开发。</li>
<li><strong>学习 Linux</strong>：想在不完全脱离 Windows 的情况下学习和使用 Linux 命令和工具。</li>
<li><strong>脚本和自动化</strong>：运行各种 Linux Shell 脚本。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>WSL 2 是微软在 Windows 与 Linux 融合方面迈出的重要一步，它为 Windows 开发者提供了一个强大、高性能且与 Windows 系统深度集成的 Linux 开发环境。无论是 Web 开发、容器化、系统编程还是仅仅想学习 Linux，WSL 2 都提供了一个无与伦比的体验。掌握其常用指令，将能让你更高效地利用这一强大工具，极大地提升你的开发效率和便利性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/9ac45568d1c2/">https://blog.tbf1211.xx.kg/9ac45568d1c2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Windows/">Windows</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a><a class="post-meta__tags" href="/tags/WSL2/">WSL2</a><a class="post-meta__tags" href="/tags/Hyper-V/">Hyper-V</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/325e0377afd7/" title="Golang 内存逃逸详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang 内存逃逸详解</div></div><div class="info-2"><div class="info-item-1"> 内存逃逸 (Memory Escape) 是 Go 语言编译器在编译时进行的一项静态分析。它的核心目的是确定程序中变量的内存分配位置：是分配在栈 (Stack) 上，还是分配在堆 (Heap) 上。通过精确地判断变量的生命周期和作用域，编译器能够做出最优化选择，从而有效降低垃圾回收 (GC) 的压力，提升程序性能。  核心思想：如果一个变量的生命周期超出了其声明函数的作用域，它就必须被分配在堆上；否则，如果其生命周期仅限于函数内部，优先分配在栈上。   一、内存分配基础：栈与堆在深入理解内存逃逸之前，我们首先需要了解程序中两种基本的内存分配区域：栈和堆。 1.1 栈 (Stack) 特性： LIFO (Last-In, First-Out) 结构。 由编译器自动管理，分配和回收速度极快。 内存是连续的。 分配与释放成本低：只需移动栈指针即可。 线程&#x2F;Goroutine 私有：每个 Goroutine 都有自己的栈。   用途： 存储局部变量。 存储函数参数。 存储函数返回值。 存储函数调用栈帧。   生命周期：与函数调用栈帧一致，函数执行完毕后，栈上的内存会被自动回收...</div></div></div></a><a class="pagination-related" href="/0d75739ade66/" title="OrbStack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">OrbStack 详解</div></div><div class="info-2"><div class="info-item-1"> OrbStack 是一款专为 macOS 和 Linux 用户设计的高性能、轻量级工具，旨在成为 Docker Desktop 和 Colima&#x2F;Rancher Desktop 的替代品。它提供了一个闪电般快速的开发环境，用于运行 Docker 容器、Kubernetes 集群以及完整的 Linux 虚拟机，旨在提供原生级别的性能、更低的资源占用和更卓越的用户体验。  核心思想： OrbStack 专注于优化在 macOS 和 Linux 上运行容器和 Linux 环境的性能和资源效率，通过巧妙的虚拟化技术和精简设计，提供比传统解决方案更快启动、更少耗电、更流畅的体验。   一、为什么需要 OrbStack？传统的 Docker Desktop 或 Colima&#x2F;Rancher Desktop 在 macOS 上存在一些痛点：  性能问题： Docker Desktop 基于笨重的 HyperKit 或 QEMU 虚拟机，启动慢，文件 I&#x2F;O 性能差，尤其是在处理大量文件操作时（如 Node.js 或 PHP 项目的 node_modules）。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6d6856b2b7ad/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</div></div><div class="info-2"><div class="info-item-1"> Hyper-V 是微软提供的一款基于 Hypervisor 的虚拟化技术，它允许用户在单一物理服务器上运行多个独立的虚拟机 (Virtual Machines, VMs)。作为 Windows Server 操作系统的一个角色功能，以及 Windows 客户端操作系统（Pro、Enterprise、Education 版本）的一个可选功能，Hyper-V 提供了一个可靠、高效且可扩展的平台，用于创建、运行和管理虚拟机。它支持运行多种操作系统，包括 Windows、Linux 以及其他变体，是企业级数据中心、开发测试环境以及个人专业用户不可或缺的工具。  核心思想：Hyper-V 在硬件和操作系统之间插入一个薄薄的虚拟化层——Hypervisor (管理程序)。这个 Hypervisor 直接管理物理硬件资源，并高效地分配给多个虚拟机，每个虚拟机都像一台独立的物理机器一样运行，拥有自己的操作系统和应用程序，从而实现资源的隔离和高效利用。   一、虚拟化技术概述与 Hyper-V 的定位1.1 什么是虚拟化？虚拟化是一种创建事物虚拟版本（而不是物理版本）的技术，通常指创建虚拟计算机...</div></div></div></a><a class="pagination-related" href="/0d75739ade66/" title="OrbStack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-20</div><div class="info-item-2">OrbStack 详解</div></div><div class="info-2"><div class="info-item-1"> OrbStack 是一款专为 macOS 和 Linux 用户设计的高性能、轻量级工具，旨在成为 Docker Desktop 和 Colima&#x2F;Rancher Desktop 的替代品。它提供了一个闪电般快速的开发环境，用于运行 Docker 容器、Kubernetes 集群以及完整的 Linux 虚拟机，旨在提供原生级别的性能、更低的资源占用和更卓越的用户体验。  核心思想： OrbStack 专注于优化在 macOS 和 Linux 上运行容器和 Linux 环境的性能和资源效率，通过巧妙的虚拟化技术和精简设计，提供比传统解决方案更快启动、更少耗电、更流畅的体验。   一、为什么需要 OrbStack？传统的 Docker Desktop 或 Colima&#x2F;Rancher Desktop 在 macOS 上存在一些痛点：  性能问题： Docker Desktop 基于笨重的 HyperKit 或 QEMU 虚拟机，启动慢，文件 I&#x2F;O 性能差，尤其是在处理大量文件操作时（如 Node.js 或 PHP 项目的 node_modules）。 ...</div></div></div></a><a class="pagination-related" href="/195d130ae5a4/" title="Ansible 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Ansible 深度解析</div></div><div class="info-2"><div class="info-item-1"> Ansible 是一个开源的自动化引擎，用于配置管理 (Configuration Management)、应用部署 (Application Deployment)、任务自动化 (Task Automation) 和编排 (Orchestration)。它以其无代理 (Agentless)、简单易用和人性化的特点而广受欢迎。Ansible 使用标准的 SSH 协议连接到目标机器，并使用 YAML 语法编写自动化任务，使得编写、理解和维护自动化脚本变得直观。  核心思想：Ansible 通过 SSH 远程执行操作，无需在被管理节点上安装任何客户端或代理程序。它采用声明式 YAML 语言描述期望的状态，并确保系统达到该状态，同时保证操作的幂等性。   一、为什么选择 Ansible？传统的服务器管理和应用部署往往涉及大量重复、手工且容易出错的任务。随着 IT 基础设施的规模不断扩大，这种手工操作的弊端日益凸显：  效率低下：手动操作耗时且重复。 易出错：人为失误在重复性任务中难以避免。 配置漂移 (Configuration Drift)：不同服务器的配置可能因手工操作而逐渐不一...</div></div></div></a><a class="pagination-related" href="/9b793354c088/" title="nftables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-28</div><div class="info-item-2">nftables 详解</div></div><div class="info-2"><div class="info-item-1"> nftables 是 Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在逐步取代传统的 iptables (以及 ip6tables, arptables, ebtables) 工具集，提供一个统一的、高效的、更易于管理和扩展的防火墙解决方案。nftables 引入了一套全新的语法和设计理念，旨在解决 iptables 长期存在的一些问题，例如命令复杂性、重复代码以及 IPv4 和 IPv6 规则管理的独立性等。  核心思想：基于表达式的统一规则集，支持原子性更新，并针对 IPv4&#x2F;IPv6&#x2F;桥接等协议提供统一管理。 它的设计哲学是从指令式规则集转向声明式通用虚拟机指令，使得规则处理更高效、更灵活。   一、为什么需要 nftables？iptables 的局限性虽然 iptables 强大且稳定，但它在设计和使用上存在一些固有的局限性，促使 Netfilter 社区开发 nftables：  语法复杂且碎片化：  iptables (用于 IPv4)、ip6tables (用于 IPv6)、arptables (用于 ARP)、ebtab...</div></div></div></a><a class="pagination-related" href="/5f4f405cbb7a/" title="Scoop (Windows 命令行包管理器) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-23</div><div class="info-item-2">Scoop (Windows 命令行包管理器) 详解</div></div><div class="info-2"><div class="info-item-1"> Scoop 是一个针对 Windows 操作系统的命令行包管理器，它专注于提供一种简洁、无管理员权限、用户级别的方式来安装、更新和管理应用程序。Scoop 的设计哲学是“零副作用 (zero-side-effects)”，即不污染系统 PATH、不依赖 UAC 提示、不创建不必要的注册表项，旨在为开发者提供一个干净、可移植的环境。  核心思想：将软件安装到用户目录下的一个沙盒环境，并通过动态修改用户 PATH 来实现软件的可用性，避免全局污染和管理员权限依赖。   一、为什么选择 Scoop？传统的 Windows 软件安装方式常常伴随着以下问题：  管理员权限依赖：许多安装程序需要管理员权限才能运行，这在高安全环境或没有管理员权限的用户电脑上是问题。 系统污染：软件通常安装到 Program Files 目录下，并在注册表、系统 PATH 中留下大量痕迹。卸载不彻底可能导致残留。 环境变量管理：安装某些开发工具（如 Git, Node.js, Python, Go）时，需要手动或安装程序自动配置环境变量，这可能导致冲突或版本问题。 更新与卸载繁琐：更新软件需要重新下载安装包，...</div></div></div></a><a class="pagination-related" href="/a92b9122509b/" title="Ubuntu UFW (Uncomplicated Firewall) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-01</div><div class="info-item-2">Ubuntu UFW (Uncomplicated Firewall) 详解</div></div><div class="info-2"><div class="info-item-1"> UFW (Uncomplicated Firewall) 是 Ubuntu Linux 及其衍生发行版中一个简化且易于使用的防火墙配置工具。它作为 iptables 的前端，提供了一个用户友好的命令行界面，让普通用户和系统管理员能够更轻松地管理 Linux 内核的 Netfilter 防火墙规则。UFW 的目标是“不复杂”，即简化防火墙的管理，使其不再令人生畏。  核心思想： UFW 提供了一种高级抽象，将复杂的 iptables 命令封装成少数直观的指令，使得用户无需深入理解 iptables 规则链即可实现基本的防火墙配置。   一、为什么选择 UFW？Linux 系统内置了强大的 Netfilter 框架和 iptables 工具，但 iptables 的语法复杂，规则众多，对于初学者来说学习曲线陡峭。UFW 旨在解决以下问题：  简化防火墙管理：  易于上手：通过简单的命令即可配置常见的防火墙规则，无需掌握复杂的 iptables 语法。 减少错误：简化后的命令减少了因语法错误导致配置失误的风险。   增强系统安全性：  默认拒绝策略：UFW 默认采用“默认拒绝所有传入...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">431</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">222</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-WSL-2%EF%BC%9F"><span class="toc-text">一、为什么需要 WSL 2？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81WSL-2-%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、WSL 2 的架构与工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81WSL-2-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="toc-text">三、WSL 2 的安装与设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82"><span class="toc-text">3.1 环境要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E5%8C%96%E5%AE%89%E8%A3%85-Windows-11-%E6%88%96%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%AC%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%83%A8%E5%88%86-Windows-10-%E6%9B%B4%E6%96%B0"><span class="toc-text">3.2 命令行简化安装 (Windows 11 或更高版本，以及部分 Windows 10 更新)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-%E9%80%82%E7%94%A8%E4%BA%8E-Windows-10-%E6%97%A7%E7%89%88%E6%9C%AC%E6%88%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85"><span class="toc-text">3.3 手动安装步骤 (适用于 Windows 10 旧版本或自定义安装)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81WSL-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">四、WSL 2 常用指令详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AE%A1%E7%90%86-WSL-%E5%8F%91%E8%A1%8C%E7%89%88"><span class="toc-text">4.1 管理 WSL 发行版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%AE%BF%E9%97%AE-WSL-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.2 访问 WSL 文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%90%AF%E5%8A%A8%E5%92%8C%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">4.3 启动和执行命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-text">4.4 网络配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E4%B8%8E-Visual-Studio-Code-%E9%9B%86%E6%88%90"><span class="toc-text">4.5 与 Visual Studio Code 集成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81WSL-2-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、WSL 2 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">5.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">5.2 缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">5.3 适用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>