<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CommonJS 与 ES Modules 对比详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 JavaScript 生态系统中，模块化是组织和重用代码的核心机制。随着 Web 应用复杂度的不断提升，以及 Node.js 等服务端 JavaScript 平台的兴起，对模块化方案的需求也日益增长。目前主流的两种模块化规范是 CommonJS (CJS) 和 ES Modules (ESM)。理解它们的异同对于现代 JavaScript 开发至关重要。  核心思想：CommonJS 诞生于">
<meta property="og:type" content="article">
<meta property="og:title" content="CommonJS 与 ES Modules 对比详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/b4cf2900f9ab/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在 JavaScript 生态系统中，模块化是组织和重用代码的核心机制。随着 Web 应用复杂度的不断提升，以及 Node.js 等服务端 JavaScript 平台的兴起，对模块化方案的需求也日益增长。目前主流的两种模块化规范是 CommonJS (CJS) 和 ES Modules (ESM)。理解它们的异同对于现代 JavaScript 开发至关重要。  核心思想：CommonJS 诞生于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg">
<meta property="article:published_time" content="2023-11-26T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-06T10:03:38.374Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="项目构建">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CommonJS 与 ES Modules 对比详解",
  "url": "https://blog.tbf1211.xx.kg/b4cf2900f9ab/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg",
  "datePublished": "2023-11-26T22:24:00.000Z",
  "dateModified": "2026-01-06T10:03:38.374Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/b4cf2900f9ab/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CommonJS 与 ES Modules 对比详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">470</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">CommonJS 与 ES Modules 对比详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CommonJS 与 ES Modules 对比详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-26T22:24:00.000Z" title="发表于 2023-11-27 06:24:00">2023-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/">项目构建</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在 JavaScript 生态系统中，模块化是组织和重用代码的核心机制。随着 Web 应用复杂度的不断提升，以及 Node.js 等服务端 JavaScript 平台的兴起，对模块化方案的需求也日益增长。目前主流的两种模块化规范是 <strong>CommonJS (CJS)</strong> 和 <strong>ES Modules (ESM)</strong>。理解它们的异同对于现代 JavaScript 开发至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>CommonJS 诞生于服务端，采用同步加载，适用于 Node.js 的文件系统特性；ES Modules 是 JavaScript 官方标准，支持异步加载，同时适用于浏览器和 Node.js，具有静态分析、Tree Shaking 等高级特性。</strong> 它们代表了 JavaScript 模块化的两种不同哲学和演进路径。</p>
</div>
<hr>
<h2 id="一、模块化简史与背景"><a href="#一、模块化简史与背景" class="headerlink" title="一、模块化简史与背景"></a>一、模块化简史与背景</h2><p>在模块化规范出现之前，JavaScript 主要通过以下方式组织代码：</p>
<ol>
<li><strong>全局变量</strong>：所有脚本共享全局命名空间，容易造成命名冲突和污染。</li>
<li><strong>立即执行函数表达式 (IIFE)</strong>：通过创建私有作用域来避免命名冲突，但依然需要手动管理依赖顺序。</li>
</ol>
<p>随着前端应用变得复杂，以及 Node.js 的崛起，急需一种标准化的模块加载机制。</p>
<ul>
<li><strong>CommonJS</strong>：主要用于 Node.js 环境，是 Node.js 模块化的基石，采用<strong>同步加载</strong>。</li>
<li><strong>AMD (Asynchronous Module Definition)</strong>：主要用于浏览器环境，如 RequireJS，采用<strong>异步加载</strong>。</li>
<li><strong>CMD (Common Module Definition)</strong>：主要用于浏览器环境，如 Sea.js，兼顾 CommonJS 和 AMD 的特点。</li>
<li><strong>UMD (Universal Module Definition)</strong>：一种通用模式，旨在兼容 CommonJS、AMD 和全局变量，使得模块可以在多种环境中使用。</li>
<li><strong>ES Modules (ESM)</strong>：JavaScript 语言层面的官方模块化标准，旨在统一前端和后端模块化，采用<strong>异步加载</strong>。</li>
</ul>
<h2 id="二、CommonJS-CJS-详解"><a href="#二、CommonJS-CJS-详解" class="headerlink" title="二、CommonJS (CJS) 详解"></a>二、CommonJS (CJS) 详解</h2><h3 id="2-1-产生背景与特点"><a href="#2-1-产生背景与特点" class="headerlink" title="2.1 产生背景与特点"></a>2.1 产生背景与特点</h3><p>CommonJS 规范最初是为了解决服务器端 JavaScript 的模块化问题而诞生的，尤其是为了 Node.js。</p>
<ul>
<li><strong>同步加载</strong>：这是其最显著的特点。当 <code>require()</code> 一个模块时，Node.js 会立即加载并执行该模块，然后返回模块的导出内容。这意味着在模块加载完成之前，后续代码不会执行。</li>
<li><strong>运行时加载</strong>：模块的导入和导出发生在代码执行时。<code>require()</code> 语句可以在代码的任何地方出现，并且支持动态路径。</li>
<li><strong>值拷贝</strong>：模块导出的是一个值的拷贝。一旦模块被加载，其导出内容的任何修改不会影响到已经导入它的模块。</li>
<li><strong>缓存机制</strong>：每个模块在第一次加载后会被缓存。后续的 <code>require()</code> 调用将直接返回缓存中的模块实例，而不是重新加载和执行。</li>
</ul>
<h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><ul>
<li><p><strong>导出 (Export)</strong>：</p>
<ul>
<li><code>module.exports = ...</code>：导出单个对象或值，会完全覆盖默认的空对象。</li>
<li><code>exports.property = value</code>：导出多个属性，每次向 <code>exports</code> 对象添加属性。</li>
</ul>
</li>
<li><p><strong>导入 (Import)</strong>：</p>
<ul>
<li><code>require(&#39;module-name&#39;)</code>：导入模块，并返回其导出的内容。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<p><code>math.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出单个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subtract</span> = (<span class="params">a, b</span>) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  add,</span><br><span class="line">  subtract</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="comment">// exports.add = function(a, b) &#123; return a + b; &#125;;</span></span><br><span class="line"><span class="comment">// exports.subtract = (a, b) =&gt; a - b;</span></span><br></pre></td></tr></table></figure>

<p><code>app.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>); <span class="comment">// 同步加载</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>));      <span class="comment">// 输出: 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">subtract</span>(<span class="number">10</span>, <span class="number">4</span>)); <span class="comment">// 输出: 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时加载示例</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamicModule = <span class="built_in">require</span>(<span class="string">&#x27;./dynamic&#x27;</span>); <span class="comment">// 可以在条件语句中加载</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(dynamicModule.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dynamic.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">message</span> = <span class="string">&#x27;I am a dynamically loaded module.&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a>2.3 适用场景</h3><ul>
<li><strong>Node.js 服务端开发</strong>：CommonJS 是 Node.js 的默认模块系统，广泛应用于后端应用程序。</li>
<li><strong>构建工具</strong>：Webpack、Browserify 等构建工具可以将 CommonJS 模块打包成浏览器可用的代码。</li>
</ul>
<h3 id="2-4-局限性"><a href="#2-4-局限性" class="headerlink" title="2.4 局限性"></a>2.4 局限性</h3><ul>
<li><strong>同步加载不适合浏览器</strong>：浏览器环境需要异步加载模块，避免阻塞 UI 渲染。</li>
<li><strong>不支持 Tree Shaking</strong>：由于是运行时加载和值拷贝，无法进行静态分析，导致无法有效移除未使用的代码（Tree Shaking）。</li>
<li><strong>循环依赖处理复杂</strong>：当模块之间存在循环依赖时，可能会出现未完全导出的对象问题。</li>
</ul>
<h2 id="三、ES-Modules-ESM-详解"><a href="#三、ES-Modules-ESM-详解" class="headerlink" title="三、ES Modules (ESM) 详解"></a>三、ES Modules (ESM) 详解</h2><h3 id="3-1-产生背景与特点"><a href="#3-1-产生背景与特点" class="headerlink" title="3.1 产生背景与特点"></a>3.1 产生背景与特点</h3><p>ES Modules 是 ECMAScript 2015 (ES6) 引入的官方标准模块系统。它的设计目标是成为浏览器和 Node.js 的通用解决方案。</p>
<ul>
<li><strong>异步加载</strong>：默认是异步加载。在浏览器中，<code>&lt;script type=&quot;module&quot;&gt;</code> 标签会异步加载；在 Node.js 中，也支持异步加载。</li>
<li><strong>静态分析</strong>：模块的导入和导出语句是在代码编译阶段（而不是运行时）确定的。这意味着可以在不执行代码的情况下分析模块的依赖关系。</li>
<li><strong>引用绑定 (Live Bindings)</strong>：模块导出的是变量的引用，而不是值的拷贝。如果导出模块在后续执行中修改了导出的变量，那么导入模块也能观察到这个变化。</li>
<li><strong>支持 Tree Shaking</strong>：由于是静态分析，打包工具可以识别哪些导出被使用了，从而移除未使用的代码，减小最终包的体积。</li>
<li><strong>严格模式</strong>：ES Modules 自动运行在严格模式下。</li>
<li><strong>单一实例</strong>：每个模块只会被加载和执行一次，无论它被导入多少次。</li>
</ul>
<h3 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h3><ul>
<li><p><strong>导出 (Export)</strong>：</p>
<ul>
<li><strong>命名导出 (Named Exports)</strong>：<code>export const name = value;</code>, <code>export function func() &#123;&#125;</code>, <code>export &#123; name1, name2 &#125;;</code></li>
<li><strong>默认导出 (Default Export)</strong>：<code>export default value;</code> (每个模块只能有一个默认导出)</li>
</ul>
</li>
<li><p><strong>导入 (Import)</strong>：</p>
<ul>
<li><strong>命名导入</strong>：<code>import &#123; name1, name2 &#125; from &#39;module-name&#39;;</code></li>
<li><strong>默认导入</strong>：<code>import defaultName from &#39;module-name&#39;;</code></li>
<li><strong>混合导入</strong>：<code>import defaultName, &#123; name1, name2 &#125; from &#39;module-name&#39;;</code></li>
<li><strong>全部导入</strong>：<code>import * as moduleAlias from &#39;module-name&#39;;</code></li>
<li><strong>副作用导入</strong>：<code>import &#39;module-name&#39;;</code> (只执行模块，不导入任何绑定)</li>
<li><strong>动态导入 (Dynamic Import)</strong>：<code>import(&#39;module-name&#39;)</code>。返回一个 Promise，允许在运行时按需加载模块。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<p><code>math.mjs</code> (或在 <code>package.json</code> 中设置 <code>&quot;type&quot;: &quot;module&quot;</code>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">subtract</span> = (<span class="params">a, b</span>) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出 (每个模块只能有一个)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">a, b</span>) =&gt; a * b;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> multiply;</span><br></pre></td></tr></table></figure>

<p><code>app.mjs</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiply, &#123; add, subtract &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.mjs&#x27;</span>; <span class="comment">// 导入默认导出和命名导出</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>));      <span class="comment">// 输出: 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subtract</span>(<span class="number">10</span>, <span class="number">4</span>)); <span class="comment">// 输出: 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiply</span>(<span class="number">2</span>, <span class="number">6</span>)); <span class="comment">// 输出: 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadDynamicModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamicModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./dynamic.mjs&#x27;</span>); <span class="comment">// 异步加载</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(dynamicModule.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">loadDynamicModule</span>();</span><br></pre></td></tr></table></figure>

<p><code>dynamic.mjs</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> message = <span class="string">&#x27;I am a dynamically loaded ES module.&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-适用场景"><a href="#3-3-适用场景" class="headerlink" title="3.3 适用场景"></a>3.3 适用场景</h3><ul>
<li><strong>现代前端开发</strong>：普遍应用于 React, Vue, Angular 等框架，结合 Webpack, Rollup 等打包工具。</li>
<li><strong>Node.js (实验性或新项目)</strong>：Node.js 对 ESM 的支持逐渐成熟，尤其是在新项目中或需要 Tree Shaking 的场景。</li>
<li><strong>Web Workers 和 Service Workers</strong>：ESM 是这些环境中唯一支持的模块系统。</li>
</ul>
<h3 id="3-4-浏览器中的-ESM"><a href="#3-4-浏览器中的-ESM" class="headerlink" title="3.4 浏览器中的 ESM"></a>3.4 浏览器中的 ESM</h3><p>在浏览器中，使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签来加载 ES Modules。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>ES Modules Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./app.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、CommonJS-与-ES-Modules-对比"><a href="#四、CommonJS-与-ES-Modules-对比" class="headerlink" title="四、CommonJS 与 ES Modules 对比"></a>四、CommonJS 与 ES Modules 对比</h2><p>下表总结了 CommonJS 和 ES Modules 的主要区别：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">CommonJS (CJS)</th>
<th align="left">ES Modules (ESM)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加载方式</strong></td>
<td align="left">同步加载 (Synchronous)</td>
<td align="left">异步加载 (Asynchronous)</td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left">运行时加载 (Runtime)</td>
<td align="left">编译时加载&#x2F;静态分析 (Compile-time&#x2F;Static Analysis)</td>
</tr>
<tr>
<td align="left"><strong>导出值</strong></td>
<td align="left">值拷贝 (Copy of values)</td>
<td align="left">引用绑定 (Live bindings)</td>
</tr>
<tr>
<td align="left"><strong><code>this</code> 指向</strong></td>
<td align="left">模块内部的 <code>this</code> 指向 <code>module.exports</code></td>
<td align="left">模块内部的 <code>this</code> 为 <code>undefined</code></td>
</tr>
<tr>
<td align="left"><strong>缓存</strong></td>
<td align="left"><code>require()</code> 第一次加载后缓存</td>
<td align="left">每个模块只执行一次，结果被缓存</td>
</tr>
<tr>
<td align="left"><strong>语法</strong></td>
<td align="left"><code>require()</code>, <code>module.exports</code>, <code>exports</code></td>
<td align="left"><code>import</code>, <code>export</code>, <code>export default</code></td>
</tr>
<tr>
<td align="left"><strong>动态导入</strong></td>
<td align="left">支持 (任意位置 <code>require()</code>)</td>
<td align="left">支持 (<code>import()</code>)，返回 Promise，异步加载</td>
</tr>
<tr>
<td align="left"><strong>Tree Shaking</strong></td>
<td align="left">不支持</td>
<td align="left">支持 (基于静态分析)</td>
</tr>
<tr>
<td align="left"><strong>循环依赖</strong></td>
<td align="left">返回已导出部分的拷贝，可能不完整</td>
<td align="left">在执行时解决，返回绑定引用，通常更健壮</td>
</tr>
<tr>
<td align="left"><strong>默认格式</strong></td>
<td align="left">Node.js 默认</td>
<td align="left">浏览器默认 (<code>&lt;script type=&quot;module&quot;&gt;</code>), Node.js 通过 <code>.mjs</code> 扩展名或 <code>package.json</code> 中的 <code>&quot;type&quot;: &quot;module&quot;</code> 识别</td>
</tr>
</tbody></table>
<h3 id="模块加载机制对比图"><a href="#模块加载机制对比图" class="headerlink" title="模块加载机制对比图"></a>模块加载机制对比图</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph &quot;CommonJS (Server-side&#x2F;Node.js)&quot;
        CJS_Entry[&quot;Entry Point (app.js)&quot;] --&gt; CJS_Require1{&quot;require(&#39;moduleA&#39;)&quot;}
        CJS_Require1 -- Synchronous --&gt; CJS_ModuleA[Module A Code]
        CJS_ModuleA -- Returns Exports --&gt; CJS_Entry
        CJS_Require2{&quot;require(&#39;moduleB&#39;)&quot;}
        CJS_Entry --&gt; CJS_Require2
        CJS_Require2 -- Synchronous --&gt; CJS_ModuleB[Module B Code]
        CJS_ModuleB -- Returns Exports --&gt; CJS_Entry
        CJS_ModuleA -- Cached After First Load --&gt; CJS_Require1
    end

    subgraph &quot;ES Modules (Browser&#x2F;Node.js)&quot;
        ESM_Entry[&quot;Entry Point (app.mjs or &lt;script type&#x3D;module&gt;)&quot;]
        ESM_Entry --&gt; ESM_Import1{import &#39;moduleA&#39;}
        ESM_Import1 -- Static Analysis&#x2F;Pre-parsing --&gt; ESM_ModuleA[Module A Code]
        ESM_Entry --&gt; ESM_Import2{import &#39;moduleB&#39;}
        ESM_Import2 -- Static Analysis&#x2F;Pre-parsing --&gt; ESM_ModuleB[Module B Code]
        ESM_Entry -- Asynchronous Loading&#x2F;Execution --&gt; ESM_Final[Ready for use]
        ESM_ModuleA -- Live Bindings --&gt; ESM_Entry
        ESM_ModuleB -- Live Bindings --&gt; ESM_Entry
        ESM_Entry --- ESM_Dynamic{&quot;import(&#39;.&#x2F;dynamic.mjs&#39;)&quot;}
        ESM_Dynamic -- Returns Promise&#x2F;Asynchronous --&gt; ESM_DynamicModule[Dynamic Module]
    end
  </pre></div>

<h2 id="五、在-Node-js-中使用-ES-Modules"><a href="#五、在-Node-js-中使用-ES-Modules" class="headerlink" title="五、在 Node.js 中使用 ES Modules"></a>五、在 Node.js 中使用 ES Modules</h2><p>Node.js 在 v12 及更高版本中对 ES Modules 的支持越来越完善。</p>
<p><strong>两种主要方式：</strong></p>
<ol>
<li><strong><code>.mjs</code> 文件扩展名</strong>：将文件命名为 <code>.mjs</code>，Node.js 会将其视为 ES Module。</li>
<li><strong><code>package.json</code> 的 <code>type</code> 字段</strong>：在项目的 <code>package.json</code> 文件中添加 <code>&quot;type&quot;: &quot;module&quot;</code>，则所有 <code>.js</code> 文件默认都被视为 ES Module。此时，如果需要使用 CommonJS 模块，可以将文件命名为 <code>.cjs</code>。</li>
</ol>
<p><strong>混合使用：</strong></p>
<ul>
<li><strong>ESM 中导入 CJS</strong>：可以使用 <code>import cjsModule from &#39;cjs-module&#39;;</code> 或 <code>import * as cjsModule from &#39;cjs-module&#39;;</code>。Node.js 会将 CommonJS 模块包装成一个默认导出。</li>
<li><strong>CJS 中导入 ESM</strong>：这是一个挑战，因为 CJS 是同步的，而 ESM 是异步的。通常需要使用动态 <code>import()</code> 语句，但由于 <code>import()</code> 返回 Promise，所以 CJS 模块必须在 <code>async</code> 函数中使用 <code>await</code> 来等待 ESM 模块加载完成。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CJS 模块 (index.js, type: commonjs)</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; add &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./es-module.mjs&#x27;</span>); <span class="comment">// 动态导入 ESM</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;CJS importing ESM:&#x27;</span>, <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ESM 模块 (es-module.mjs, type: module)</span></span><br><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;./cjs-module.cjs&#x27;</span>; <span class="comment">// 导入 CJS 模块</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ESM importing CJS:&#x27;</span>, cjsModule.<span class="property">message</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CJS 模块 (cjs-module.cjs)</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">message</span> = <span class="string">&quot;Hello from CJS!&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>CommonJS 和 ES Modules 各有其设计哲学和适用场景。CommonJS 简单直接，为 Node.js 提供了坚实的模块化基础，但其同步加载和缺乏静态分析的特性限制了它在现代前端和某些高性能场景的应用。ES Modules 作为语言标准，以其异步加载、静态分析和引用绑定的特性，成为了现代 JavaScript 开发的首选，它更好地支持 Tree Shaking 和跨环境统一模块化。</p>
<p>在实际开发中，我们通常会发现这两个模块系统并行存在。前端项目通常全面拥抱 ESM，而 Node.js 项目则在向 ESM 迁移的过程中，但仍有大量存量代码和第三方库使用 CommonJS。理解它们的原理和交互方式，是成为一名全面 JavaScript 开发者的必备知识。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/b4cf2900f9ab/">https://blog.tbf1211.xx.kg/b4cf2900f9ab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/">项目构建</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f1fc37edcc9c/" title="TUN 隧道详解与 HTTP/SOCKS 代理对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TUN 隧道详解与 HTTP/SOCKS 代理对比</div></div><div class="info-2"><div class="info-item-1"> TUN (Tunnel) 隧道 是一种操作系统内核模块提供的虚拟网络接口，它允许用户空间的应用程序注入和接收 IP 数据包。与传统的网络接口不同，TUN 接口没有物理硬件与之对应，而是纯软件实现的。它在 OSI 模型的网络层（第三层）进行操作，因此能够处理 IP 协议栈的完整功能。  核心思想：TUN 接口模拟了一个点对点连接的网络设备，允许应用程序以编程方式像操作物理网卡一样，来处理 IP 层的数据包。 它使得在用户空间实现复杂的网络协议栈成为可能，是构建 VPN (Virtual Private Network) 等虚拟网络技术的基石。   一、TUN 隧道概述TUN 隧道，全称为 “Tunnel” 虚拟网络接口，是一个 Linux&#x2F;Unix 系统内核提供的一个机制，用于创建虚拟网络设备。这些虚拟设备允许用户空间的程序读取和写入网络层（IP 层）的数据包。当数据包被写入 TUN 接口时，它会被传递给关联的用户空间应用程序；反之，当用户空间应用程序将数据包写入 TUN 接口时，这些数据包会被内核视为从网络中接收的 IP 数据包，并根据路由表进行进一步处理。 1.1 ...</div></div></div></a><a class="pagination-related" href="/eefad265dcbc/" title="JavaScript Lodash 库详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JavaScript Lodash 库详解</div></div><div class="info-2"><div class="info-item-1"> Lodash 是一个广受欢迎的 JavaScript 实用工具库，提供了一系列模块化、高性能的函数，旨在简化 JavaScript 应用程序中的数据操作。它通过提供一致的、跨环境的、经过性能优化的方法，帮助开发者更高效地处理数组、对象、字符串、函数和数字等。Lodash 的函数式编程风格和对不可变数据操作的支持，使其在现代 JavaScript 开发中占据重要地位。  核心思想：提供一套强大、一致且高效的工具函数，用于简化 JavaScript 中的常见任务，尤其是在处理集合（数组和对象）时，提升代码的可读性、可维护性和性能。   一、为什么需要 Lodash？尽管现代 JavaScript (ES6+) 已经提供了许多内置方法（如 Array.prototype.map, filter, reduce），但 Lodash 依然有其独特的价值：  跨环境一致性：Node.js 和浏览器环境下行为一致，抹平了不同 JavaScript 引擎之间的兼容性差异。 更丰富的功能：提供了大量原生 JS 没有的实用工具函数，例如深拷贝 (_.cloneDeep)、对象深度合并 (_.mer...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/7cdd9f5b33c9/" title="前端项目工程化详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="info-item-2">前端项目工程化详解</div></div><div class="info-2"><div class="info-item-1"> 随着前端应用的复杂度日益增加，单纯依靠人工管理和协作已经无法满足高效、高质量开发的需求。前端工程化应运而生，它旨在通过将软件工程的思想和方法引入前端开发，构建一套系统化、标准化、自动化、体系化的解决方案，以提高开发效率、保障代码质量、降低维护成本。  前端工程化的核心思想是：以自动化取代人力，以工具取代重复劳动，以规范约束散漫。   一、什么是前端工程化？前端工程化是构建、管理和维护前端项目的实践和工具集。它涵盖了从项目初始化、开发、构建、测试到部署的整个生命周期，目标是提升团队协作效率、统一代码风格、保证项目质量、优化产物性能以及实现快速迭代。 它不仅仅是使用几个构建工具，更是一种体系化的思维方式和工作流。 二、为什么需要前端工程化？在没有工程化的时代，前端开发面临诸多挑战：  开发效率低下：手动重复任务（如文件合并、压缩），环境搭建复杂。 代码质量参差不齐：缺乏统一的代码规范和质量检查机制，导致 Bug 增多，难以维护。 团队协作困难：不同成员的代码风格差异大，冲突频繁，交接成本高。 项目性能不佳：缺乏自动化优化手段（如图片压缩、按需加载），页面加载慢。 部署上线复杂：手动...</div></div></div></a><a class="pagination-related" href="/ab44062dd349/" title="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="info-item-2">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</div></div><div class="info-2"><div class="info-item-1"> 现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：patch(), patchVnode(), 和 updateChildren()，并辅以 Mermaid 流程图进行可视化说明。  “虚拟 DOM 是前端性能优化的基石，而 Vue 的 patch() 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”   一、虚拟 DOM (Virtual DOM) 再探1.1 什么是虚拟 DOM？虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：  tag：标签名（如 d...</div></div></div></a><a class="pagination-related" href="/eefad265dcbc/" title="JavaScript Lodash 库详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="info-item-2">JavaScript Lodash 库详解</div></div><div class="info-2"><div class="info-item-1"> Lodash 是一个广受欢迎的 JavaScript 实用工具库，提供了一系列模块化、高性能的函数，旨在简化 JavaScript 应用程序中的数据操作。它通过提供一致的、跨环境的、经过性能优化的方法，帮助开发者更高效地处理数组、对象、字符串、函数和数字等。Lodash 的函数式编程风格和对不可变数据操作的支持，使其在现代 JavaScript 开发中占据重要地位。  核心思想：提供一套强大、一致且高效的工具函数，用于简化 JavaScript 中的常见任务，尤其是在处理集合（数组和对象）时，提升代码的可读性、可维护性和性能。   一、为什么需要 Lodash？尽管现代 JavaScript (ES6+) 已经提供了许多内置方法（如 Array.prototype.map, filter, reduce），但 Lodash 依然有其独特的价值：  跨环境一致性：Node.js 和浏览器环境下行为一致，抹平了不同 JavaScript 引擎之间的兼容性差异。 更丰富的功能：提供了大量原生 JS 没有的实用工具函数，例如深拷贝 (_.cloneDeep)、对象深度合并 (_.mer...</div></div></div></a><a class="pagination-related" href="/8258d22937ed/" title="Vue3 ref和reactive对比解析：深入理解响应式数据"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-04</div><div class="info-item-2">Vue3 ref和reactive对比解析：深入理解响应式数据</div></div><div class="info-2"><div class="info-item-1"> 在 Vue 3 的 Composition API 中，ref 和 reactive 是创建响应式状态的两个核心函数。它们都旨在将普通 JavaScript 数据转换为响应式数据，以便在数据变化时自动触发视图更新。然而，它们在处理数据类型、访问方式和底层机制上存在显著差异。理解这些差异对于有效地使用 Composition API 至关重要。  核心思想：ref 用于处理原始值和对象，通过 .value 访问其内部值，而 reactive 专门用于处理对象，直接访问对象的属性，且底层基于 Proxy 实现。   一、ref：处理原始值和对象ref 函数接受一个内部值（inner value），并返回一个响应式的 ref 对象。这个 ref 对象只有一个 value 属性，用来指向内部值。 1.1 定义和用法 定义：ref 可以接收任何类型的值作为参数：原始值 (string, number, boolean, null, undefined, Symbol) 或对象 (Object, Array)。 访问：在 JavaScript 中访问 ref 对象时，需要通过其 .valu...</div></div></div></a><a class="pagination-related" href="/c86d0a022c83/" title="React入门教程：快速构建交互式用户界面"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="info-item-2">React入门教程：快速构建交互式用户界面</div></div><div class="info-2"><div class="info-item-1"> React (通常称为 React.js 或 ReactJS) 是一个用于构建用户界面的 JavaScript 库，由 Facebook (现为 Meta) 创建和维护。它允许开发者声明式地创建复杂的、交互式的 UI，其核心思想是组件化和响应式更新。React 专注于视图层，与传统 MVC 模式中的 V (View) 相对应。  核心思想：“声明式地”构建组件化的 UI。开发者描述 UI 在给定状态下的样子，React 负责高效地更新 DOM 以匹配该状态。    重要提示: React 主要使用 TypeScript 或 JavaScript (JSX) 进行开发。本文档中的所有代码示例都将使用 TypeScript (TSX) 语言，以满足类型安全的需求。  一、为什么需要 React？在现代 Web 开发中，构建复杂的用户界面面临诸多挑战：  DOM 操作的复杂性与性能瓶颈：直接操作 DOM 繁琐且容易出错，尤其是在数据频繁变化时，手动优化 DOM 更新的性能极其困难。 代码组织与复用性：随着应用规模的增长，UI 代码变得难以管理，组件之间的逻辑耦合高，复用性差。 状态管...</div></div></div></a><a class="pagination-related" href="/f67db260675a/" title="Vue3 Hook(组合式 API)与Mixin对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="info-item-2">Vue3 Hook(组合式 API)与Mixin对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin 两种逻辑复用模式，从多方面进行对比分析，帮助开发者理解它们各自的优缺点，并选择最适合自己项目和团队的模式。   一、 理解 Vue 中的逻辑复用在 Vue 组件开发中，我们经常会遇到需要在多个组件中共享相同的逻辑（例如：处理鼠标位置、计时器、表单验证、主题切换等）。如果没有有效的复用机制，这些逻辑就会在不同组件中重复编写，导致代码冗余、难以维护。  Vue 提供了以下主要方式来解决逻辑复用问题：  Mixin (混入)：Vue 2 的主要逻辑复用方式，也在 Vue 3 中继续支持。 Composition API (组合式 API &#x2F; Vue 3 Hook)：Vue 3 引入...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">470</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E5%8F%B2%E4%B8%8E%E8%83%8C%E6%99%AF"><span class="toc-text">一、模块化简史与背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81CommonJS-CJS-%E8%AF%A6%E8%A7%A3"><span class="toc-text">二、CommonJS (CJS) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-text">2.1 产生背景与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AF%AD%E6%B3%95"><span class="toc-text">2.2 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.3 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">2.4 局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ES-Modules-ESM-%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、ES Modules (ESM) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-text">3.1 产生背景与特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AF%AD%E6%B3%95"><span class="toc-text">3.2 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.3 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84-ESM"><span class="toc-text">3.4 浏览器中的 ESM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81CommonJS-%E4%B8%8E-ES-Modules-%E5%AF%B9%E6%AF%94"><span class="toc-text">四、CommonJS 与 ES Modules 对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94%E5%9B%BE"><span class="toc-text">模块加载机制对比图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9C%A8-Node-js-%E4%B8%AD%E4%BD%BF%E7%94%A8-ES-Modules"><span class="toc-text">五、在 Node.js 中使用 ES Modules</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>