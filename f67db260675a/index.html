<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Vue3 Hook(组合式 API)与Mixin对比详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3 Hook(组合式 API)与Mixin对比详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/f67db260675a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg">
<meta property="article:published_time" content="2023-12-03T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T07:40:52.283Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="函数式编程">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vue3 Hook(组合式 API)与Mixin对比详解",
  "url": "https://blog.tbf1211.xx.kg/f67db260675a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg",
  "datePublished": "2023-12-03T22:24:00.000Z",
  "dateModified": "2026-02-01T07:40:52.283Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/f67db260675a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue3 Hook(组合式 API)与Mixin对比详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Vue3 Hook(组合式 API)与Mixin对比详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Vue3 Hook(组合式 API)与Mixin对比详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-12-03T22:24:00.000Z" title="发表于 2023-12-04 06:24:00">2023-12-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/Vue/">Vue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在 Vue.js 的开发中，<strong>逻辑复用</strong> 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 <code>Mixin</code> (混入) 到 Vue 3 推出的 <code>Composition API</code> (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。</p>
</blockquote>
<div class="note info flat"><p>本文将深入探讨 Vue 3 的 <code>Hook</code> (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 <code>Mixin</code> 两种逻辑复用模式，从多方面进行对比分析，帮助开发者理解它们各自的优缺点，并选择最适合自己项目和团队的模式。</p>
</div>
<hr>
<h2 id="一、-理解-Vue-中的逻辑复用"><a href="#一、-理解-Vue-中的逻辑复用" class="headerlink" title="一、 理解 Vue 中的逻辑复用"></a>一、 理解 Vue 中的逻辑复用</h2><p>在 Vue 组件开发中，我们经常会遇到需要在多个组件中共享相同的逻辑（例如：处理鼠标位置、计时器、表单验证、主题切换等）。如果没有有效的复用机制，这些逻辑就会在不同组件中重复编写，导致代码冗余、难以维护。</p>
<p> Vue 提供了以下主要方式来解决逻辑复用问题：</p>
<ol>
<li><strong>Mixin (混入)</strong>：Vue 2 的主要逻辑复用方式，也在 Vue 3 中继续支持。</li>
<li><strong>Composition API (组合式 API &#x2F; Vue 3 Hook)</strong>：Vue 3 引入的核心特性，旨在更好地解决逻辑复用和代码组织问题。</li>
<li><strong>Slot (插槽)</strong>：主要用于内容分发和布局复用，不直接用于逻辑复用。</li>
<li><strong>自定义指令 (Custom Directives)</strong>：用于复用 DOM 操作。</li>
<li><strong>高阶组件 (Higher-Order Components - HOC)</strong>：React 中常用，Vue 中虽然可以实现，但不如 Mixin 和 Composition API 自然。</li>
</ol>
<p>本文重点比较 Mixin 和 Composition API。</p>
<h2 id="二、-Mixin-混入-详解"><a href="#二、-Mixin-混入-详解" class="headerlink" title="二、 Mixin (混入) 详解"></a>二、 Mixin (混入) 详解</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p><code>Mixin</code> 是一种灵活的方式，可以将组件的选项混入到 Vue 组件中。当组件使用 <code>Mixin</code> 时，<code>Mixin</code> 中定义的选项（data、methods、computed、lifecycle hooks 等）会“混入”到组件自身的选项中。</p>
<p><strong>工作原理</strong>: 当组件与 Mixin 发生合并时，如果遇到同名选项，会采取一定的合并策略：</p>
<ul>
<li><strong>data</strong>: 对象的属性会进行递归合并，组件的数据优先。</li>
<li><strong>methods, components, directives</strong>: 以组件选项为准，Mixin 中的同名选项会被覆盖。</li>
<li><strong>生命周期钩子</strong>: 会被合并到一个数组中，所有钩子都会被调用，Mixin 的钩子会在组件自身钩子之前执行。</li>
</ul>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- components/MouseTracker.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse X: &#123;&#123; x &#125;&#125;, Mouse Y: &#123;&#123; y &#125;&#125;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export const mouseMixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMouse(e) &#123;</span><br><span class="line">      this.x = e.pageX;</span><br><span class="line">      this.y = e.pageY;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    window.addEventListener(&#x27;mousemove&#x27;, this.updateMouse);</span><br><span class="line">  &#125;,</span><br><span class="line">  unmounted() &#123; // Vue 3 生命周期对应 Vue 2 的 beforeDestroy</span><br><span class="line">    window.removeEventListener(&#x27;mousemove&#x27;, this.updateMouse);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- MyComponent.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;My Component&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Using Mouse Mixin&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Current Mouse Position: X=&#123;&#123; x &#125;&#125;, Y=&#123;&#123; y &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Count: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mouseMixin &#125; from &#x27;./MouseTracker.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [mouseMixin], // 使用混入</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">      // x: 100, // 此处的 x 会覆盖 Mixin 中的 x，但如果 Mixin 有多个属性，其他仍保留</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">    // updateMouse() &#123; // 如果这里定义了 updateMouse，会覆盖 Mixin 中的同名方法</span><br><span class="line">    //   console.log(&#x27;Component\&#x27;s own updateMouse&#x27;);</span><br><span class="line">    // &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul>
<li><strong>简单易懂</strong>: 对于简单的逻辑复用场景，Mixin 的概念相对直观，容易学习和使用。</li>
<li><strong>兼容性</strong>: 可以在 Vue 2 和 Vue 3 中使用。</li>
<li><strong>集中处理</strong>: 可以在一个文件中定义所有相关逻辑。</li>
</ul>
<h3 id="4-缺点-Vue-3-引入-Composition-API-的主要原因"><a href="#4-缺点-Vue-3-引入-Composition-API-的主要原因" class="headerlink" title="4. 缺点 (Vue 3 引入 Composition API 的主要原因)"></a>4. 缺点 (Vue 3 引入 Composition API 的主要原因)</h3><ul>
<li><strong>命名冲突</strong>: 当多个 Mixin 或 Mixin 与组件自身有同名的数据属性或方法时，容易发生冲突，且难以追踪。</li>
<li><strong>数据来源不明确</strong>: 模板中使用的变量或方法，从何而来（是本组件的，还是哪个 Mixin 的）不清晰，增加了代码阅读和维护的难度。</li>
<li><strong>隐式依赖</strong>: Mixin 可能会对组件的上下文产生隐式依赖，例如期望组件拥有某个 <code>data</code> 属性或 <code>method</code>，这使得 Mixin 变得不那么独立和可预测。</li>
<li><strong>复用性受限</strong>: 当一个 Mixin 需要另一个 Mixin 的某些数据时，处理起来会比较麻烦，或者 Mixin 之间会形成复杂的依赖关系。</li>
<li><strong>性能开销</strong>: 所有的 <code>data</code> 都被合并到组件实例上，即使是未使用的 <code>data</code> 也会被初始化。</li>
<li><strong>难以测试</strong>: 由于隐式依赖和命名冲突问题，测试变得更复杂。</li>
</ul>
<h2 id="三、-Composition-API-组合式-API-Vue-3-Hook-详解"><a href="#三、-Composition-API-组合式-API-Vue-3-Hook-详解" class="headerlink" title="三、 Composition API (组合式 API &#x2F; Vue 3 Hook) 详解"></a>三、 Composition API (组合式 API &#x2F; Vue 3 Hook) 详解</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p><code>Composition API</code> 是 Vue 3 引入的一组 API，允许开发者以函数的形式组织和复用组件逻辑。它旨在解决 Options API 在大型组件或逻辑复用方面遇到的问题。它通过 <code>setup</code> 函数将相关逻辑集中在一起，并通过 <code>ref</code>, <code>reactive</code>, <code>computed</code>, <code>watch</code> 等 API 暴露响应式状态和行为。</p>
<p><strong>工作原理</strong>:</p>
<ul>
<li><code>setup</code> 函数在组件实例化之后、处理 props 之前执行。</li>
<li>它接收 <code>props</code> 和 <code>context</code> 作为参数。</li>
<li>它返回一个对象，该对象的所有属性都将暴露给模板以及 Options API 的 <code>this</code> 上下文。</li>
<li>所有的逻辑（响应式数据、计算属性、方法、侦听器、生命周期钩子）都可以在 <code>setup</code> 函数内部组织和定义。</li>
<li>通过将 <code>setup</code> 函数中的逻辑提取到独立的、可复用的函数中，就可以实现类似 React Hook 的逻辑复用模式。这些可复用函数通常被称为“<strong>组合式函数</strong>”或“<strong>Vue 3 Hook</strong>”。</li>
</ul>
<h3 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- services/useMousePosition.js --&gt;</span><br><span class="line">import &#123; ref, onMounted, onUnmounted &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export function useMousePosition() &#123;</span><br><span class="line">  const x = ref(0);</span><br><span class="line">  const y = ref(0);</span><br><span class="line"></span><br><span class="line">  function update(e) &#123;</span><br><span class="line">    x.value = e.pageX;</span><br><span class="line">    y.value = e.pageY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&#x27;mousemove&#x27;, update);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  onUnmounted(() =&gt; &#123;</span><br><span class="line">    window.removeEventListener(&#x27;mousemove&#x27;, update);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &#123; x, y &#125;; // 返回响应式数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- MyComponentComposition.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;My Component (Composition API)&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Using Mouse Position Hook&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Current Mouse Position: X=&#123;&#123; x &#125;&#125;, Y=&#123;&#123; y &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;Count: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; useMousePosition &#125; from &#x27;../services/useMousePosition&#x27;; // 导入组合式函数</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // Option API 的 setup 语法糖</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const &#123; x, y &#125; = useMousePosition(); // 调用组合式函数，获取响应式数据</span><br><span class="line"></span><br><span class="line">    const count = ref(0);</span><br><span class="line">    const increment = () =&gt; &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123; // 暴露给模板</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      count,</span><br><span class="line">      increment,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-优点-1"><a href="#3-优点-1" class="headerlink" title="3. 优点"></a>3. 优点</h3><ul>
<li><strong>更高的可读性</strong>: 相关逻辑的代码都集中在一起，而不是分散在 <code>data</code>, <code>methods</code>, <code>computed</code>, <code>watch</code> 等选项中，使得代码更易于阅读和理解。</li>
<li><strong>更清晰的数据来源</strong>: 在模板中使用的变量或方法，其来源（是 <code>useMousePosition</code> 提供的 <code>x, y</code> 还是组件自身的 <code>count</code>）在 <code>setup</code> 函数中一目了然。</li>
<li><strong>避免命名冲突</strong>: 组合式函数返回的对象可以进行解构和重命名，完全避免了命名冲突问题。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>(); <span class="comment">// 外部使用 x, y</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">x</span>: scrollX, <span class="attr">y</span>: scrollY &#125; = <span class="title function_">useScrollPosition</span>(); <span class="comment">// 避免与 useMousePosition 的 x, y 冲突</span></span><br></pre></td></tr></table></figure></li>
<li><strong>更灵活的逻辑复用</strong>: <ul>
<li>组合式函数可以接受参数，根据不同组件的需求提供定制化的逻辑。</li>
<li>组合式函数之间可以相互调用，形成更复杂的逻辑组合。</li>
</ul>
</li>
<li><strong>更好的类型推断</strong>: 配合 TypeScript，由于其基于函数的结构，能够提供更好的类型推断支持。</li>
<li><strong>更易测试</strong>: 组合式函数是独立的 JavaScript 函数，可以在脱离 Vue 组件实例的情况下进行单元测试。</li>
</ul>
<h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><ul>
<li><strong>学习曲线</strong>: 相较于 Options API，Composition API 引入了新的概念 (ref, reactive) 和思维模式，对初学者有一定学习曲线。</li>
<li><strong>样板代码</strong>: 对于非常简单的组件或没有逻辑复用需求的组件，使用 Composition API 可能会觉得引入 <code>ref</code> 或 <code>reactive</code> 增加了少量的样板代码。</li>
<li><strong>函数式编程思维</strong>: 需要开发者拥有一定的函数式编程思维，来更好地组织和抽象逻辑。</li>
</ul>
<h2 id="四、-Hook-组合式-API-与-Mixin-对比总结"><a href="#四、-Hook-组合式-API-与-Mixin-对比总结" class="headerlink" title="四、 Hook (组合式 API) 与 Mixin 对比总结"></a>四、 Hook (组合式 API) 与 Mixin 对比总结</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Mixin (混入)</th>
<th align="left">Hook (组合式 API) &#x2F; 组合式函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>代码组织</strong></td>
<td align="left">选项合并式，逻辑分散在组件的各个选项中。</td>
<td align="left"><strong>函数式组织</strong>，相关逻辑集中于一个函数块。</td>
</tr>
<tr>
<td align="left"><strong>数据来源</strong></td>
<td align="left">不明确，需要查看所有 Mixin 和组件自身选项才能确定。</td>
<td align="left"><strong>明确</strong>，<code>setup</code> 函数返回什么，模板就用什么。</td>
</tr>
<tr>
<td align="left"><strong>命名冲突</strong></td>
<td align="left"><strong>存在风险</strong>，同名 props、methods、data 易覆盖。</td>
<td align="left"><strong>可避免</strong>，通过解构重命名来避免命名冲突。</td>
</tr>
<tr>
<td align="left"><strong>复用性</strong></td>
<td align="left">受限，难以传递运行时参数，Mixins 之间依赖复杂。</td>
<td align="left"><strong>高度灵活</strong>，可接受参数、相互调用，形成复杂组合。</td>
</tr>
<tr>
<td align="left"><strong>隐式依赖</strong></td>
<td align="left">强，Mixin 内部可能依赖组件的特定上下文。</td>
<td align="left">弱，组合式函数是独立的 JS 函数，更少依赖组件内部状态。</td>
</tr>
<tr>
<td align="left"><strong>类型支持</strong></td>
<td align="left">较差，难以进行类型推断。</td>
<td align="left"><strong>良好</strong>，函数式结构更利于 TypeScript 类型推断。</td>
</tr>
<tr>
<td align="left"><strong>测试性</strong></td>
<td align="left">较差，依赖于 Vue 实例进行测试。</td>
<td align="left"><strong>优秀</strong>，可独立测试组合式函数。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">所有 Mixin 的 data 都会初始化，即使未使用。</td>
<td align="left">按需调用和响应式化，更精细的控制。</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">较低，接近传统面向对象思维。</td>
<td align="left">稍高，需要理解响应式原语和函数式组合。</td>
</tr>
<tr>
<td align="left"><strong>主流框架</strong></td>
<td align="left">Vue 2 (主要) &amp; Vue 3 (兼容)</td>
<td align="left">Vue 3 (推荐)</td>
</tr>
</tbody></table>
<h2 id="五、-如何选择？"><a href="#五、-如何选择？" class="headerlink" title="五、 如何选择？"></a>五、 如何选择？</h2><p>对于 Vue 3 新项目，<strong>强烈推荐优先使用 Composition API (Hook 模式)</strong>。它解决了 Mixin 存在的诸多痛点，提供了更强大的逻辑复用能力，并带来了更好的代码组织、可读性、可维护性和测试性。</p>
<p><strong>你可能会考虑 Mixin 的场景 (通常是在维护旧代码时):</strong></p>
<ul>
<li><strong>遗留项目升级</strong>: 当你正在将 Vue 2 项目迁移到 Vue 3，并且项目中大量使用了 Mixin，短期内继续使用 Mixin 可能成本较低。</li>
<li><strong>非常简单的、无命名冲突风险的通用行为</strong>: 例如，一个简单的 <code>loggingMixin</code> 只做日志记录，不涉及到复杂的业务逻辑和状态管理。</li>
</ul>
<p><strong>什么时候坚持使用 Composition API？</strong></p>
<ul>
<li><strong>所有新项目</strong>: 从头开始的新项目应该全程采用 Composition API。</li>
<li><strong>需要高质量逻辑复用</strong>: 当你需要共享复杂逻辑、关注数据来源、避免命名冲突，或期望更清晰的代码结构时。</li>
<li><strong>使用 TypeScript</strong>: Composition API 与 TypeScript 的配合度远高于 Mixin。</li>
<li><strong>构建可维护性强的应用</strong>: Composition API 带来的好处在大型、团队协作的项目中尤为明显。</li>
</ul>
<h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>Vue 3 的 Composition API (Hook 模式) 是对逻辑复用问题的一个重大改进，它通过提供一种更灵活、更组织良好的方式来编写和复用组件逻辑，显著提升了大型应用的开发体验和可维护性。</p>
<p>虽然 Mixin 在 Vue 2 中发挥了重要作用，但其固有的缺点在复杂场景下变得日益明显。在 Vue 3 中，Composition API 已经成为官方推荐的逻辑复用解决方案，它代表了未来 Vue 开发的方向。拥抱 Composition API，将有助于开发者构建更健壮、更易于管理和扩展的 Vue 应用程序。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/f67db260675a/">https://blog.tbf1211.xx.kg/f67db260675a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f19c839c8b2e/" title="BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解</div></div><div class="info-2"><div class="info-item-1"> BBR (Bottleneck Bandwidth and Round-trip Propagation Time) 是由 Google 开发的一种 TCP 拥塞控制算法。与传统的基于丢包的拥塞控制算法（如 Cubic, Reno）不同，BBR 专注于测量网络瓶颈带宽 (Bottleneck Bandwidth) 和往返传播时间 (Round-trip Propagation Time)，并以此为基础来控制发送速率，旨在达到高吞吐量和低延迟的最佳平衡。  核心思想：基于带宽和 RTT 测量，而不是丢包，来探知网络的实际容量，从而更精准地控制发送速率，避免不必要的丢包，并充分利用带宽。   一、为什么需要 BBR？传统的 TCP 拥塞控制算法（如 Cubic、Reno）主要依赖于丢包作为网络拥塞的信号。它们的工作原理是：  不断增加发送窗口，直到出现丢包。 丢包发生后，认为网络拥塞，降低发送窗口。 循环往复，形成“锯齿状”的发送速率。  这种基于丢包的机制存在以下问题：  “缓冲区膨胀” (Bufferbloat)： 现代网络设备通常拥有较大的缓冲区。当网络开始拥塞时，数据包不会...</div></div></div></a><a class="pagination-related" href="/f1fc37edcc9c/" title="TUN 隧道详解与 HTTP/SOCKS 代理对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TUN 隧道详解与 HTTP/SOCKS 代理对比</div></div><div class="info-2"><div class="info-item-1"> TUN (Tunnel) 隧道 是一种操作系统内核模块提供的虚拟网络接口，它允许用户空间的应用程序注入和接收 IP 数据包。与传统的网络接口不同，TUN 接口没有物理硬件与之对应，而是纯软件实现的。它在 OSI 模型的网络层（第三层）进行操作，因此能够处理 IP 协议栈的完整功能。  核心思想：TUN 接口模拟了一个点对点连接的网络设备，允许应用程序以编程方式像操作物理网卡一样，来处理 IP 层的数据包。 它使得在用户空间实现复杂的网络协议栈成为可能，是构建 VPN (Virtual Private Network) 等虚拟网络技术的基石。   一、TUN 隧道概述TUN 隧道，全称为 “Tunnel” 虚拟网络接口，是一个 Linux&#x2F;Unix 系统内核提供的一个机制，用于创建虚拟网络设备。这些虚拟设备允许用户空间的程序读取和写入网络层（IP 层）的数据包。当数据包被写入 TUN 接口时，它会被传递给关联的用户空间应用程序；反之，当用户空间应用程序将数据包写入 TUN 接口时，这些数据包会被内核视为从网络中接收的 IP 数据包，并根据路由表进行进一步处理。 1.1 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ab44062dd349/" title="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="info-item-2">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</div></div><div class="info-2"><div class="info-item-1"> 现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：patch(), patchVnode(), 和 updateChildren()，并辅以 Mermaid 流程图进行可视化说明。  “虚拟 DOM 是前端性能优化的基石，而 Vue 的 patch() 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”   一、虚拟 DOM (Virtual DOM) 再探1.1 什么是虚拟 DOM？虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：  tag：标签名（如 d...</div></div></div></a><a class="pagination-related" href="/8258d22937ed/" title="Vue3 ref和reactive对比解析：深入理解响应式数据"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-04</div><div class="info-item-2">Vue3 ref和reactive对比解析：深入理解响应式数据</div></div><div class="info-2"><div class="info-item-1"> 在 Vue 3 的 Composition API 中，ref 和 reactive 是创建响应式状态的两个核心函数。它们都旨在将普通 JavaScript 数据转换为响应式数据，以便在数据变化时自动触发视图更新。然而，它们在处理数据类型、访问方式和底层机制上存在显著差异。理解这些差异对于有效地使用 Composition API 至关重要。  核心思想：ref 用于处理原始值和对象，通过 .value 访问其内部值，而 reactive 专门用于处理对象，直接访问对象的属性，且底层基于 Proxy 实现。   一、ref：处理原始值和对象ref 函数接受一个内部值（inner value），并返回一个响应式的 ref 对象。这个 ref 对象只有一个 value 属性，用来指向内部值。 1.1 定义和用法 定义：ref 可以接收任何类型的值作为参数：原始值 (string, number, boolean, null, undefined, Symbol) 或对象 (Object, Array)。 访问：在 JavaScript 中访问 ref 对象时，需要通过其 .valu...</div></div></div></a><a class="pagination-related" href="/b4cf2900f9ab/" title="CommonJS 与 ES Modules 对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-27</div><div class="info-item-2">CommonJS 与 ES Modules 对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 JavaScript 生态系统中，模块化是组织和重用代码的核心机制。随着 Web 应用复杂度的不断提升，以及 Node.js 等服务端 JavaScript 平台的兴起，对模块化方案的需求也日益增长。目前主流的两种模块化规范是 CommonJS (CJS) 和 ES Modules (ESM)。理解它们的异同对于现代 JavaScript 开发至关重要。  核心思想：CommonJS 诞生于服务端，采用同步加载，适用于 Node.js 的文件系统特性；ES Modules 是 JavaScript 官方标准，支持异步加载，同时适用于浏览器和 Node.js，具有静态分析、Tree Shaking 等高级特性。 它们代表了 JavaScript 模块化的两种不同哲学和演进路径。   一、模块化简史与背景在模块化规范出现之前，JavaScript 主要通过以下方式组织代码：  全局变量：所有脚本共享全局命名空间，容易造成命名冲突和污染。 立即执行函数表达式 (IIFE)：通过创建私有作用域来避免命名冲突，但依然需要手动管理依赖顺序。  随着前端应用变得复杂，以及 Node.js...</div></div></div></a><a class="pagination-related" href="/8d32c59da40a/" title="Vitest 详解：下一代前端测试框架"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-29</div><div class="info-item-2">Vitest 详解：下一代前端测试框架</div></div><div class="info-2"><div class="info-item-1"> Vitest 是一个由 Vite 驱动的下一代单元测试框架，旨在提供一个快速、现代且极具效率的测试体验。它与 Vite 深度集成，共享相同的配置、转换和解析器，从而为使用 Vite 构建的前端项目提供了无缝的测试解决方案。Vitest 的诞生，部分是为了解决传统前端测试工具（如 Jest）在大型项目中启动慢、HMR（热模块替换）支持不足等痛点。  核心思想：Vitest 利用 Vite 的 ESM-first 开发服务器和闪电般的 HMR 能力，为 JavaScript&#x2F;TypeScript 项目带来前所未有的快速测试体验，尤其适合基于 Vite 的现代前端项目。   一、为什么选择 Vitest？在前端开发日益复杂的今天，测试是保证代码质量和项目稳定性的关键环节。传统的测试框架，如 Jest，尽管功能强大，但在面对现代前端构建工具（如 ESM、TypeScript、JSX&#x2F;TSX 转换）时，往往需要额外的配置和转换步骤，导致测试启动慢、HMR 效率不高。Vitest 应运而生，旨在解决这些问题。 1.1 核心优势 Vite 驱动，极致速度：  直接利用 V...</div></div></div></a><a class="pagination-related" href="/b25babd84514/" title="Vue3 defineModel详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-03</div><div class="info-item-2">Vue3 defineModel详解</div></div><div class="info-2"><div class="info-item-1"> defineModel 是 Vue 3.4 版本中引入的一个新的宏 (macro)，旨在简化组件中双向绑定 v-model 的实现。在 Composition API 的 setup 语法糖 (&lt;script setup&gt;) 中使用时，它极大地减少了为组件实现 v-model 所需的样板代码，使其更加直观和便捷。  核心思想：defineModel 是 defineProps 和 defineEmits 的语法糖，它声明了一个可双向绑定的 props，并自动处理了 modelValue prop 的接收和相应的 update:modelValue 事件的触发，让自定义组件的 v-model 用法变得和原生表单元素一样简洁。   一、为什么需要 defineModel？在 defineModel 出现之前，如果你想在 Vue 3 的自定义组件中实现 v-model 双向绑定，你需要手动完成以下步骤：  通过 defineProps 声明一个名为 modelValue 的 prop 来接收父组件传递的值。 通过 defineEmits 声明一个名为 update:mod...</div></div></div></a><a class="pagination-related" href="/2b166435d59a/" title="函数式编程详解：从概念到实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-11</div><div class="info-item-2">函数式编程详解：从概念到实践</div></div><div class="info-2"><div class="info-item-1"> 函数式编程 (Functional Programming, FP) 是一种编程范式，它将计算视为函数评估，避免了状态改变和可变数据。它强调使用纯函数、不可变数据和表达式而不是语句来构建程序。近年来，随着多核处理器和分布式系统的普及，函数式编程因其固有的并发优势和代码的易于测试、推理的特点，在许多领域（如大数据、并行计算、前端）重新获得了广泛关注。  核心思想：程序即数学函数，数据不可变，无副作用，关注“做什么”而非“怎么做”。   一、编程范式回顾在深入函数式编程之前，我们先简单回顾一下几种常见的编程范式：  命令式编程 (Imperative Programming)：关注于“如何做”，通过改变程序状态的指令序列来表达计算。 过程式编程 (Procedural Programming)：将程序组织成一系列过程（函数），强调步骤和顺序。 面向对象编程 (Object-Oriented Programming, OOP)：将数据和操作封装成对象，通过对象之间的交互来完成任务，强调状态和行为。   声明式编程 (Declarative Programming)：关注于“做什么”，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E7%90%86%E8%A7%A3-Vue-%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8"><span class="toc-text">一、 理解 Vue 中的逻辑复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-Mixin-%E6%B7%B7%E5%85%A5-%E8%AF%A6%E8%A7%A3"><span class="toc-text">二、 Mixin (混入) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B"><span class="toc-text">2. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E7%82%B9"><span class="toc-text">3. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%BA%E7%82%B9-Vue-3-%E5%BC%95%E5%85%A5-Composition-API-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0"><span class="toc-text">4. 缺点 (Vue 3 引入 Composition API 的主要原因)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81-Composition-API-%E7%BB%84%E5%90%88%E5%BC%8F-API-Vue-3-Hook-%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、 Composition API (组合式 API &#x2F; Vue 3 Hook) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5-1"><span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">2. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E7%82%B9-1"><span class="toc-text">3. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%BA%E7%82%B9"><span class="toc-text">4. 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-Hook-%E7%BB%84%E5%90%88%E5%BC%8F-API-%E4%B8%8E-Mixin-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">四、 Hook (组合式 API) 与 Mixin 对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">五、 如何选择？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81-%E6%80%BB%E7%BB%93"><span class="toc-text">六、 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-17.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>