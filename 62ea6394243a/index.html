<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RPC(Remote Procedure Call)远程过程调用详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RPC (Remote Procedure Call)，即远程过程调用，是一种分布式计算技术，它允许程序调用位于不同地址空间（通常是不同计算机上）的子程序或函数，就像调用本地子程序一样。RPC 屏蔽了底层网络通信的复杂性，让开发者可以专注于业务逻辑，提高开发效率。  核心思想： RPC 的目标是透明化 (Transparency) 远程服务的调用过程，让客户端感觉就像在调用本地方法，而实际上调用">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC(Remote Procedure Call)远程过程调用详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/62ea6394243a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="RPC (Remote Procedure Call)，即远程过程调用，是一种分布式计算技术，它允许程序调用位于不同地址空间（通常是不同计算机上）的子程序或函数，就像调用本地子程序一样。RPC 屏蔽了底层网络通信的复杂性，让开发者可以专注于业务逻辑，提高开发效率。  核心思想： RPC 的目标是透明化 (Transparency) 远程服务的调用过程，让客户端感觉就像在调用本地方法，而实际上调用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg">
<meta property="article:published_time" content="2024-05-02T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-21T01:29:47.875Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="RPC">
<meta property="article:tag" content="微服务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RPC(Remote Procedure Call)远程过程调用详解",
  "url": "https://blog.tbf1211.xx.kg/62ea6394243a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg",
  "datePublished": "2024-05-02T22:24:00.000Z",
  "dateModified": "2026-01-21T01:29:47.875Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/62ea6394243a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RPC(Remote Procedure Call)远程过程调用详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">507</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-19.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">RPC(Remote Procedure Call)远程过程调用详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RPC(Remote Procedure Call)远程过程调用详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-05-02T22:24:00.000Z" title="发表于 2024-05-03 06:24:00">2024-05-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>RPC (Remote Procedure Call)</strong>，即<strong>远程过程调用</strong>，是一种分布式计算技术，它允许程序调用位于不同地址空间（通常是不同计算机上）的子程序或函数，就像调用本地子程序一样。RPC 屏蔽了底层网络通信的复杂性，让开发者可以专注于业务逻辑，提高开发效率。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想：</strong> RPC 的目标是<strong>透明化 (Transparency)</strong> 远程服务的调用过程，让客户端感觉就像在调用本地方法，而实际上调用的请求被序列化并通过网络传输到远程服务，远程服务执行后将结果序列化并返回给客户端。</p>
</div>
<hr>
<h2 id="一、为什么需要-RPC？"><a href="#一、为什么需要-RPC？" class="headerlink" title="一、为什么需要 RPC？"></a>一、为什么需要 RPC？</h2><p>在传统的单体应用中，所有功能都运行在同一个进程中，方法调用直接发生在内存中。然而，随着业务复杂性和系统规模的增长，单体应用面临诸多挑战：</p>
<ul>
<li><strong>扩展性差</strong>：难以针对不同模块的负载压力独立扩展。</li>
<li><strong>开发效率低</strong>：团队协作困难，代码冲突多。</li>
<li><strong>容错性差</strong>：单个模块故障可能导致整个系统崩溃。</li>
<li><strong>技术栈限制</strong>：难以在不同模块中使用最佳技术栈。</li>
</ul>
<p>为了解决这些问题，系统架构逐渐向<strong>分布式系统</strong>和<strong>微服务架构</strong>演进。在这种架构中，一个大型应用被拆分成多个独立的服务，每个服务运行在不同的进程中，甚至不同的物理机器上。这些服务之间需要进行通信和协作，这时就引出了<strong>跨进程&#x2F;跨机器通信</strong>的问题。</p>
<p><strong>传统的跨进程通信方式：</strong></p>
<ol>
<li><strong>基于 HTTP&#x2F;RESTful API</strong>：<ul>
<li><strong>优点</strong>：简单易懂，浏览器原生支持，无状态，跨语言。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>效率相对较低</strong>：HTTP 协议头部信息较多，通常使用 JSON&#x2F;XML 等文本协议，序列化和反序列化开销较大。</li>
<li><strong>语义不够丰富</strong>：主要是 CRUD 操作，难以表达复杂业务逻辑。</li>
<li><strong>性能开销</strong>：TCP 三次握手、四次挥手、SSL&#x2F;TLS 握手等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>消息队列 (MQ)</strong>：<ul>
<li><strong>优点</strong>：解耦，异步，削峰填谷，高可用。</li>
<li><strong>缺点</strong>：引入复杂性，不适合实时、同步的请求-响应模式。</li>
</ul>
</li>
</ol>
<p><strong>RPC 的优势在于：</strong></p>
<ul>
<li><strong>高性能</strong>：通常基于 TCP 协议，使用二进制序列化协议（如 Protobuf、Kryo），数据传输效率高，减少网络开销。</li>
<li><strong>透明性</strong>：客户端调用远程服务就像调用本地方法一样，无需关心底层网络细节。</li>
<li><strong>强类型接口</strong>：通常通过接口定义语言 (IDL) 约定服务接口，生成多语言代码，保证类型安全。</li>
<li><strong>更适合服务间调用</strong>：相较于 HTTP&#x2F;RESTful，RPC 更专注于服务之间的内部通信，强调效率和低延迟。</li>
</ul>
<h2 id="二、RPC-的基本原理"><a href="#二、RPC-的基本原理" class="headerlink" title="二、RPC 的基本原理"></a>二、RPC 的基本原理</h2><p>RPC 的核心在于<strong>隐藏网络通信细节，模拟本地调用</strong>。其工作流程通常涉及以下几个关键组件：</p>
<ol>
<li><strong>客户端 (Client)</strong>：发起远程调用的程序。</li>
<li><strong>客户端存根 (Client Stub)</strong>：<ul>
<li><strong>职责</strong>：负责将客户端的本地方法调用转化为网络请求。</li>
<li><strong>工作</strong>：接收客户端参数，对其进行<strong>序列化</strong>（将对象转换为字节流），并通过网络传输发送给服务器。</li>
</ul>
</li>
<li><strong>网络传输层 (Network Transport)</strong>：负责实际的数据传输，通常基于 TCP&#x2F;IP 协议。</li>
<li><strong>服务器 (Server)</strong>：提供远程服务的程序。</li>
<li><strong>服务器存根 (Server Stub)</strong>：<ul>
<li><strong>职责</strong>：负责接收网络请求，并将其转化为服务器本地的方法调用。</li>
<li><strong>工作</strong>：接收客户端发送的字节流，对其进行<strong>反序列化</strong>（将字节流恢复为对象），然后调用实际的服务实现。</li>
</ul>
</li>
<li><strong>服务实现 (Service Implementation)</strong>：服务器端真正执行业务逻辑的代码。</li>
</ol>
<p><strong>RPC 调用的详细流程：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant C as 客户端
    participant CS as 客户端存根 (Stub)
    participant N as 网络传输
    participant SS as 服务器存根 (Stub)
    participant S as 服务实现

    C-&gt;&gt;CS: 1. 调用本地方法 (args)
    CS-&gt;&gt;CS: 2. 序列化参数 (args -&gt; bytes)
    CS-&gt;&gt;N: 3. 发送请求 (bytes)
    N-&gt;&gt;SS: 4. 接收请求 (bytes)
    SS-&gt;&gt;SS: 5. 反序列化参数 (bytes -&gt; args)
    SS-&gt;&gt;S: 6. 调用服务方法 (args)
    S-&gt;&gt;SS: 7. 返回结果 (result)
    SS-&gt;&gt;SS: 8. 序列化结果 (result -&gt; bytes)
    SS-&gt;&gt;N: 9. 发送响应 (bytes)
    N-&gt;&gt;CS: 10. 接收响应 (bytes)
    CS-&gt;&gt;CS: 11. 反序列化结果 (bytes -&gt; result)
    CS-&gt;&gt;C: 12. 返回结果 (result)
  </pre></div>

<h2 id="三、RPC-的核心组件与技术"><a href="#三、RPC-的核心组件与技术" class="headerlink" title="三、RPC 的核心组件与技术"></a>三、RPC 的核心组件与技术</h2><h3 id="3-1-接口定义语言-IDL-Interface-Definition-Language"><a href="#3-1-接口定义语言-IDL-Interface-Definition-Language" class="headerlink" title="3.1 接口定义语言 (IDL - Interface Definition Language)"></a>3.1 接口定义语言 (IDL - Interface Definition Language)</h3><ul>
<li><strong>作用</strong>：为了实现跨语言的服务调用，RPC 框架需要一种中立的语言来定义服务接口、方法签名和数据结构。IDL 文件定义了服务的契约。</li>
<li><strong>常见 IDL</strong>：<ul>
<li><strong>Protocol Buffers (Protobuf)</strong>：Google 开发的一种语言无关、平台无关、可扩展的序列化机制。</li>
<li><strong>Apache Thrift</strong>：Facebook 开发的跨语言 RPC 框架，包含 IDL 和代码生成器。</li>
<li><strong>Apache Avro</strong>：Hadoop 生态系统中的数据序列化系统，也支持 IDL。</li>
</ul>
</li>
<li><strong>代码生成</strong>：IDL 工具会根据 <code>.proto</code> 或 <code>.thrift</code> 文件生成客户端存根和服务器端存根代码，供不同语言使用。</li>
</ul>
<h3 id="3-2-序列化与反序列化-Serialization-Deserialization"><a href="#3-2-序列化与反序列化-Serialization-Deserialization" class="headerlink" title="3.2 序列化与反序列化 (Serialization&#x2F;Deserialization)"></a>3.2 序列化与反序列化 (Serialization&#x2F;Deserialization)</h3><ul>
<li><strong>作用</strong>：将内存中的对象转换为字节流，以便通过网络传输，以及将接收到的字节流恢复为对象。</li>
<li><strong>原则</strong>：<ul>
<li><strong>高效</strong>：序列化&#x2F;反序列化速度快。</li>
<li><strong>紧凑</strong>：序列化后的字节流大小尽可能小，减少网络传输量。</li>
<li><strong>跨语言</strong>：支持多种编程语言。</li>
<li><strong>可扩展</strong>：能够兼容协议升级，不影响老版本服务。</li>
</ul>
</li>
<li><strong>常见序列化协议</strong>：<ul>
<li><strong>Protobuf</strong>：性能和压缩率非常优秀。</li>
<li><strong>Apache Thrift</strong>：提供多种序列化方式 (Binary, Compact, JSON 等)。</li>
<li><strong>Kryo</strong>：Java 生态中高性能的二进制序列化库。</li>
<li><strong>FST</strong>：Fast Java Serialization。</li>
<li><strong>JSON&#x2F;XML</strong>：虽然 RPC 很少直接使用，但作为对比，它们是文本协议，开销较大。</li>
</ul>
</li>
</ul>
<h3 id="3-3-网络传输-Network-Transport"><a href="#3-3-网络传输-Network-Transport" class="headerlink" title="3.3 网络传输 (Network Transport)"></a>3.3 网络传输 (Network Transport)</h3><ul>
<li><strong>作用</strong>：负责底层的数据包发送和接收。</li>
<li><strong>常见方案</strong>：<ul>
<li><strong>TCP&#x2F;IP</strong>：最常用的传输层协议，提供可靠的字节流传输。</li>
<li><strong>UDP</strong>：主要用于对实时性要求高、允许少量丢包的场景（如音视频传输），RPC 中较少使用。</li>
<li><strong>HTTP&#x2F;2</strong>：支持多路复用、头部压缩等特性，提高了传输效率，许多现代 RPC 框架（如 gRPC）基于 HTTP&#x2F;2 构建。</li>
</ul>
</li>
<li><strong>I&#x2F;O 模型</strong>：异步非阻塞 I&#x2F;O (NIO) 通常用于提高并发处理能力，如 Java 的 Netty 框架。</li>
</ul>
<h3 id="3-4-服务注册与发现-Service-Registration-and-Discovery"><a href="#3-4-服务注册与发现-Service-Registration-and-Discovery" class="headerlink" title="3.4 服务注册与发现 (Service Registration and Discovery)"></a>3.4 服务注册与发现 (Service Registration and Discovery)</h3><p>在分布式系统中，服务实例的地址是动态变化的。客户端如何找到服务提供者？</p>
<ul>
<li><strong>服务注册</strong>：服务提供者启动时，将自己的服务名称、IP 地址、端口号等信息注册到注册中心。</li>
<li><strong>服务发现</strong>：客户端在调用服务前，向注册中心查询服务提供者的地址列表，然后选择一个实例进行调用。</li>
<li><strong>常见注册中心</strong>：<ul>
<li><strong>Zookeeper</strong></li>
<li><strong>Consul</strong></li>
<li><strong>Etcd</strong></li>
<li><strong>Eureka</strong> (Spring Cloud)</li>
</ul>
</li>
</ul>
<h3 id="3-5-负载均衡-Load-Balancing"><a href="#3-5-负载均衡-Load-Balancing" class="headerlink" title="3.5 负载均衡 (Load Balancing)"></a>3.5 负载均衡 (Load Balancing)</h3><p>当一个服务有多个提供者实例时，客户端需要选择一个实例进行调用，以分散请求压力。</p>
<ul>
<li><strong>常见负载均衡策略</strong>：<ul>
<li><strong>轮询 (Round Robin)</strong></li>
<li><strong>随机 (Random)</strong></li>
<li><strong>最少活跃调用 (Least Active Calls)</strong></li>
<li><strong>一致性哈希 (Consistent Hashing)</strong></li>
<li><strong>加权轮询&#x2F;随机 (Weighted Round Robin&#x2F;Random)</strong></li>
</ul>
</li>
</ul>
<h3 id="3-6-容错处理-Fault-Tolerance"><a href="#3-6-容错处理-Fault-Tolerance" class="headerlink" title="3.6 容错处理 (Fault Tolerance)"></a>3.6 容错处理 (Fault Tolerance)</h3><p>分布式系统的复杂性决定了故障不可避免。RPC 框架需要提供容错机制：</p>
<ul>
<li><strong>超时与重试</strong>：设置调用超时时间，超时后可进行重试。</li>
<li><strong>熔断 (Circuit Breaker)</strong>：当服务提供者出现故障时，客户端不再向其发送请求，避免雪崩效应。</li>
<li><strong>限流 (Rate Limiting)</strong>：限制客户端对服务提供者的请求速率，防止服务过载。</li>
<li><strong>降级 (Degradation)</strong>：当服务不可用或响应缓慢时，提供备用方案或返回默认值。</li>
</ul>
<h2 id="四、常见的-RPC-框架"><a href="#四、常见的-RPC-框架" class="headerlink" title="四、常见的 RPC 框架"></a>四、常见的 RPC 框架</h2><ul>
<li><strong>gRPC (Google RPC)</strong>：<ul>
<li>基于 <strong>HTTP&#x2F;2</strong> 协议。</li>
<li>使用 <strong>Protocol Buffers</strong> 作为 IDL 和序列化协议。</li>
<li>支持多种语言，提供双向流式传输。</li>
<li><strong>优点</strong>：性能高，跨语言，支持流式 RPC。</li>
<li><strong>缺点</strong>：生态不如 RESTful 丰富，缺乏浏览器原生支持（需要 gRPC-Web 代理）。</li>
</ul>
</li>
<li><strong>Apache Thrift</strong>：<ul>
<li>Facebook 开源的跨语言 RPC 框架。</li>
<li>提供自己的 IDL 和代码生成器，支持多种传输协议和序列化协议。</li>
<li><strong>优点</strong>：灵活性高，跨语言支持好。</li>
<li><strong>缺点</strong>：社区活跃度不如 gRPC。</li>
</ul>
</li>
<li><strong>Dubbo</strong>：<ul>
<li>阿里巴巴开源的高性能 Java RPC 框架。</li>
<li>与 Spring 框架集成紧密，提供丰富的服务治理功能（注册中心、负载均衡、容错等）。</li>
<li><strong>优点</strong>：功能强大，生态成熟（Java 生态）。</li>
<li><strong>缺点</strong>：主要聚焦于 Java 生态，跨语言支持相对弱。</li>
</ul>
</li>
<li><strong>Tars</strong>：<ul>
<li>腾讯开源的微服务平台，包含 RPC 框架。</li>
<li>提供完整的服务治理能力。</li>
</ul>
</li>
<li><strong>Hessian</strong>：<ul>
<li>轻量级的 Java RPC 框架，基于 HTTP 协议但使用二进制序列化。</li>
</ul>
</li>
</ul>
<h2 id="五、RPC-与-RESTful-的对比"><a href="#五、RPC-与-RESTful-的对比" class="headerlink" title="五、RPC 与 RESTful 的对比"></a>五、RPC 与 RESTful 的对比</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">RPC</th>
<th align="left">RESTful (HTTP&#x2F;JSON)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层协议</strong></td>
<td align="left">通常是 TCP (或 HTTP&#x2F;2)</td>
<td align="left">HTTP&#x2F;HTTPS</td>
</tr>
<tr>
<td align="left"><strong>传输格式</strong></td>
<td align="left">二进制协议 (Protobuf, Thrift Binary)</td>
<td align="left">文本协议 (JSON, XML)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">通常更高 (更小的传输数据，更少的协议开销)</td>
<td align="left">相对较低 (较大的传输数据，HTTP 协议头部开销)</td>
</tr>
<tr>
<td align="left"><strong>接口定义</strong></td>
<td align="left">强类型 IDL (Protobuf, Thrift)</td>
<td align="left">弱类型或无明确 IDL (OpenAPI&#x2F;Swagger)</td>
</tr>
<tr>
<td align="left"><strong>语义</strong></td>
<td align="left">面向方法 (Method-Oriented)，动词丰富</td>
<td align="left">面向资源 (Resource-Oriented)，动词受 HTTP 限制</td>
</tr>
<tr>
<td align="left"><strong>跨语言</strong></td>
<td align="left">IDL 自动生成多语言代码</td>
<td align="left">天然跨语言 (通用 HTTP 客户端和 JSON 解析库)</td>
</tr>
<tr>
<td align="left"><strong>易用性</strong></td>
<td align="left">客户端代码由工具生成，调用透明</td>
<td align="left">简单易懂，浏览器原生支持</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>微服务间高并发、低延迟的内部通信</strong></td>
<td align="left"><strong>对外暴露 API、前后端通信、跨系统集成</strong></td>
</tr>
<tr>
<td align="left"><strong>浏览器支持</strong></td>
<td align="left">差 (需要代理如 gRPC-Web)</td>
<td align="left">好 (浏览器原生支持)</td>
</tr>
</tbody></table>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>RPC 作为一种高效的分布式通信机制，在构建高性能、可伸缩的微服务架构中扮演着关键角色。它通过引入存根、序列化、传输协议和一系列服务治理组件，成功地将远程调用透明化，使开发者能够专注于业务逻辑。虽然其在易用性、浏览器兼容性方面不如 RESTful，但其在性能和类型安全方面的优势使其成为服务间通信的首选。在实际项目中，通常会根据具体需求，将 RPC 和 RESTful API 结合使用，发挥各自的优势。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/62ea6394243a/">https://blog.tbf1211.xx.kg/62ea6394243a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/RPC/">RPC</a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-19.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/3286b8aa1630/" title="The Elm Architecture (TEA) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">The Elm Architecture (TEA) 详解</div></div><div class="info-2"><div class="info-item-1"> The Elm Architecture (TEA) 是一种用于构建交互式 Web 应用程序的函数式架构模式。它最初由 Elm 语言社区设计和推广，但其核心思想和模式因其可预测性、可测试性和易于理解性而非常成功，并被广泛借鉴和应用于其他前端框架和语言，如 React (特别是 Redux)、Vue (Vuex)、ReasonML (Redux-Like)、甚至 Swift (The Composable Architecture) , Rust (Relm) 和 Golang (bubbletea) 等。  核心思想：将应用程序状态、状态更新逻辑和 UI 渲染逻辑清晰地分离为三个核心部分：Model、Update 和 View，并通过一个单向数据流进行管理。   一、为什么需要 The Elm Architecture？在传统的命令式或面向对象编程中，UI 应用程序的状态管理往往是复杂且容易出错的部分：  状态分散：应用程序状态可能散布在各个组件中，难以追踪和同步。 多向数据流：数据可以在组件之间以多种方式流动，导致难以预测状态变化。 调试困难：当出现 bug 时，很难确定是哪...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-03</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a><a class="pagination-related" href="/19a6c2b992d7/" title="IPv6 (Internet Protocol Version 6) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">IPv6 (Internet Protocol Version 6) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv6 (Internet Protocol Version 6) 是互联网协议 (IP) 的最新版本，旨在取代其前身 IPv4。它解决了 IPv4 长期存在的地址枯竭问题，并引入了多项设计改进，以更好地适应现代互联网的需求，包括支持更简单的头部处理、增强的安全性、更好的服务质量 (QoS) 和更强大的移动性功能。  核心思想：从根本上解决 IPv4 地址短缺问题，同时优化协议设计，为万物互联 (IoT)、5G 和未来网络应用提供坚实基础。    一、为什么需要 IPv6？IPv4 (Internet Protocol Version 4) 作为互联网的核心协议已成功运行数十年，但随着互联网的爆炸式增长，其固有的设计局限性日益凸显：  地址枯竭 (Address Exhaustion)：IPv4 地址空间为 32 位，最多有约 43 亿个地址。尽管采取了无类别域间路由 (CIDR) 和网络地址转换 (NAT) 等技术来延缓地址枯竭，但根源问题并未解决。全球各区域的 IPv4 地址池已基本分配完毕，成为互联网进一步发展的瓶颈。 NAT 的复杂性与限制：网络地址转换 (NAT) ...</div></div></div></a><a class="pagination-related" href="/b8edc2276249/" title="雪花算法 (Snowflake Algorithm) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-19</div><div class="info-item-2">雪花算法 (Snowflake Algorithm) 详解</div></div><div class="info-2"><div class="info-item-1"> 雪花算法 (Snowflake Algorithm) 是 Twitter 公司开源的一种分布式唯一 ID 生成算法。它旨在解决在分布式系统中生成全局唯一、递增（但非严格递增）且高性能 ID 的需求。其生成的 ID 是一个 64 位的整数，具有时间有序性，并且不依赖于数据库，易于扩展。  核心思想：将 64 位的 Long 型 ID 拆分为多个字段，分别存储时间戳、数据中心 ID、机器 ID 和序列号，通过位运算拼接以保证全局唯一性和大致的时间有序性。   一、为什么需要雪花算法？在分布式系统中，传统的单点自增 ID 方案面临巨大挑战：  唯一性问题：不同的数据库实例或服务节点可能生成相同的 ID。 性能瓶颈：为了保证唯一性，可能需要引入中心化的 ID 生成服务或数据库锁，成为系统瓶颈。 可用性问题：中心化服务一旦宕机，整个系统的 ID 生成将受影响。  虽然 UUID 能够保证全局唯一性，但它存在一些缺点：  存储和传输效率低：128 位，比 64 位 ID 更占用空间，索引性能较差。 无序性：UUID 是无序的，插入数据库时会导致 B+ 树索引频繁分裂和重建，影响数据库性能。...</div></div></div></a><a class="pagination-related" href="/f7642a181610/" title="CDN (内容分发网络) 服务详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">CDN (内容分发网络) 服务详解</div></div><div class="info-2"><div class="info-item-1"> CDN (Content Delivery Network)，即内容分发网络，是一种构建在现有网络基础之上的智能虚拟网络。它通过将站点内容发布到离用户最近的全球边缘节点，使用户在请求内容时，能够从距离自己最近的服务器获取数据，从而显著加速内容传输、减轻源站负载、提高用户体验和保障服务可用性。  核心思想：将内容缓存到离用户近的地方，让用户就近获取，缩短物理距离，从而缩短加载时间。   一、为什么需要 CDN？在没有 CDN 的情况下，用户访问网站的所有请求都会直接发送到源服务器。这存在几个问题：  访问速度慢：当用户与源服务器之间地理距离较远时，数据传输路径长，网络延迟高，导致页面加载缓慢，尤其是对于图片、视频等大文件。 网络拥堵：跨国或跨洲际网络传输容易受到骨干网带宽限制和拥堵的影响。 源站负载高：所有用户的请求都直接冲击源服务器，在高并发场景下可能导致源服务器过载、响应变慢甚至崩溃。 单点故障风险：源服务器一旦出现故障或遭受攻击，整个网站将无法访问。 安全性弱：源站直接暴露在公网，容易成为 DDoS 攻击的目标。  CDN 旨在解决上述问题，提供以下核心价值：  加速访问：...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">507</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-RPC%EF%BC%9F"><span class="toc-text">一、为什么需要 RPC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81RPC-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">二、RPC 的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81RPC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%8A%80%E6%9C%AF"><span class="toc-text">三、RPC 的核心组件与技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80-IDL-Interface-Definition-Language"><span class="toc-text">3.1 接口定义语言 (IDL - Interface Definition Language)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Serialization-Deserialization"><span class="toc-text">3.2 序列化与反序列化 (Serialization&#x2F;Deserialization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93-Network-Transport"><span class="toc-text">3.3 网络传输 (Network Transport)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-Service-Registration-and-Discovery"><span class="toc-text">3.4 服务注册与发现 (Service Registration and Discovery)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Load-Balancing"><span class="toc-text">3.5 负载均衡 (Load Balancing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%AE%B9%E9%94%99%E5%A4%84%E7%90%86-Fault-Tolerance"><span class="toc-text">3.6 容错处理 (Fault Tolerance)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84-RPC-%E6%A1%86%E6%9E%B6"><span class="toc-text">四、常见的 RPC 框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81RPC-%E4%B8%8E-RESTful-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">五、RPC 与 RESTful 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-19.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>