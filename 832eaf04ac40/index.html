<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python多线程实现生产者-消费者模式详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模">
<meta property="og:type" content="article">
<meta property="og:title" content="Python多线程实现生产者-消费者模式详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/832eaf04ac40/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg">
<meta property="article:published_time" content="2023-03-20T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-26T11:17:13.302Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="编码规范">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="程序设计">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python多线程实现生产者-消费者模式详解",
  "url": "https://blog.tbf1211.xx.kg/832eaf04ac40/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg",
  "datePublished": "2023-03-20T22:24:00.000Z",
  "dateModified": "2026-01-26T11:17:13.302Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/832eaf04ac40/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python多线程实现生产者-消费者模式详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">521</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-09.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python多线程实现生产者-消费者模式详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python多线程实现生产者-消费者模式详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-20T22:24:00.000Z" title="发表于 2023-03-21 06:24:00">2023-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 <code>threading</code> 模块和 <code>queue</code> 模块实现多线程版的生产者-消费者模式。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>利用线程安全的共享队列作为缓冲，实现生产者与消费者解耦，并通过队列自带的互斥锁和条件变量进行同步，避免数据不一致和资源竞争。</strong></p>
</div>
<hr>
<h2 id="一、生产者-消费者模式与多线程概述"><a href="#一、生产者-消费者模式与多线程概述" class="headerlink" title="一、生产者-消费者模式与多线程概述"></a>一、生产者-消费者模式与多线程概述</h2><h3 id="1-1-生产者-消费者模式"><a href="#1-1-生产者-消费者模式" class="headerlink" title="1.1 生产者-消费者模式"></a>1.1 生产者-消费者模式</h3><p>参考 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://your-previous-article-link.md/">Python 多进程生产者-消费者模式详解</a> 中的概述，其核心构成和解决的问题在多线程场景下是相同的：</p>
<ul>
<li><strong>生产者 (Producer)</strong>：生成数据并放入队列。</li>
<li><strong>消费者 (Consumer)</strong>：从队列取出数据并处理。</li>
<li><strong>缓冲区 (Queue)</strong>：共享的、线程安全的数据容器。</li>
</ul>
<h3 id="1-2-Python-多线程与-GIL"><a href="#1-2-Python-多线程与-GIL" class="headerlink" title="1.2 Python 多线程与 GIL"></a>1.2 Python 多线程与 GIL</h3><ul>
<li><strong><code>threading</code> 模块</strong>：Python 标准库提供，用于创建和管理线程。</li>
<li><strong><code>queue</code> 模块</strong>：提供线程安全的队列实现，如 <code>Queue</code>、<code>LifoQueue</code>、<code>PriorityQueue</code>。</li>
<li><strong>全局解释器锁 (Global Interpreter Lock, GIL)</strong>：Python 在任何时刻只允许一个线程执行字节码。这意味着在 CPU 密集型任务中，多线程并不能带来并行计算的优势，因为只有一个线程能真正运行。然而，当线程执行 I&#x2F;O 操作（如文件读写、网络请求、打印）时，GIL 会被释放，允许其他线程运行。因此，多线程在 I&#x2F;O 密集型任务中非常有用。</li>
</ul>
<h2 id="二、Python-多线程实现的关键模块"><a href="#二、Python-多线程实现的关键模块" class="headerlink" title="二、Python 多线程实现的关键模块"></a>二、Python 多线程实现的关键模块</h2><h3 id="2-1-threading-模块"><a href="#2-1-threading-模块" class="headerlink" title="2.1 threading 模块"></a>2.1 <code>threading</code> 模块</h3><p>用于创建和管理线程。主要类和方法：</p>
<ul>
<li><code>threading.Thread</code>：用于创建线程。<ul>
<li><code>target</code>：指定线程要执行的函数。</li>
<li><code>args</code>：传递给函数的参数元组。</li>
<li><code>start()</code>：启动线程。</li>
<li><code>join()</code>：等待线程执行完毕。</li>
</ul>
</li>
<li><code>threading.Lock</code>：互斥锁，用于保护共享资源。</li>
<li><code>threading.Condition</code>：条件变量，用于线程间的协作（等待&#x2F;通知）。</li>
</ul>
<h3 id="2-2-queue-模块"><a href="#2-2-queue-模块" class="headerlink" title="2.2 queue 模块"></a>2.2 <code>queue</code> 模块</h3><p>提供线程安全的队列实现，内部已经集成了锁和条件变量，极大地简化了生产者-消费者模式的实现。</p>
<ul>
<li><strong><code>queue.Queue(maxsize=0)</code></strong>：先进先出 (FIFO) 队列。<ul>
<li><code>put(item, block=True, timeout=None)</code>：将 <code>item</code> 放入队列。<code>block=True</code> 表示如果队列已满，则阻塞等待；<code>timeout</code> 可以设置等待超时时间。</li>
<li><code>get(block=True, timeout=None)</code>：从队列中取出 <code>item</code>。<code>block=True</code> 表示如果队列为空，则阻塞等待。</li>
<li><code>qsize()</code>：返回队列当前大小。</li>
<li><code>empty()</code>：判断队列是否为空。</li>
<li><code>full()</code>：判断队列是否已满。</li>
<li><code>task_done()</code>：用于通知队列，指定的任务已经完成。通常在消费者处理完一个 <code>get()</code> 到的 item 后调用。</li>
<li><code>join()</code>：阻塞，直到队列中的所有任务都已处理完毕（即，<code>put()</code> 进队列的所有 item 都被 <code>get()</code> 并且对应的 <code>task_done()</code> 被调用）。</li>
</ul>
</li>
</ul>
<p><strong>对于多线程的生产者-消费者模式，<code>queue.Queue</code> 是最常用、最推荐的工具。</strong> 它内部已经处理了所有复杂的同步细节，无需手动管理锁和条件变量。</p>
<h2 id="三、多线程生产者-消费者模式的实现步骤"><a href="#三、多线程生产者-消费者模式的实现步骤" class="headerlink" title="三、多线程生产者-消费者模式的实现步骤"></a>三、多线程生产者-消费者模式的实现步骤</h2><ol>
<li><strong>创建共享队列</strong>：使用 <code>queue.Queue()</code> 创建一个线程安全的队列作为生产者和消费者之间的数据缓冲区。</li>
<li><strong>定义生产者函数</strong>：<ul>
<li>接收队列作为参数。</li>
<li>循环生成数据。</li>
<li>使用 <code>queue.put()</code> 将数据放入队列。</li>
<li>生产完成后，可以不发送特殊信号，而是依赖 <code>queue.join()</code> 和 <code>queue.task_done()</code> 来协调（见高级示例）。或者仍然使用特殊信号。</li>
</ul>
</li>
<li><strong>定义消费者函数</strong>：<ul>
<li>接收队列作为参数。</li>
<li>在一个循环中，使用 <code>queue.get()</code> 从队列中取出数据。</li>
<li>处理数据。</li>
<li>处理完成后，调用 <code>queue.task_done()</code> 通知队列该任务已完成。</li>
<li>接收到停止信号后，终止循环。</li>
</ul>
</li>
<li><strong>创建并启动线程</strong>：<ul>
<li>使用 <code>threading.Thread</code> 创建生产者和消费者线程实例。</li>
<li>使用 <code>thread.start()</code> 启动所有线程。</li>
</ul>
</li>
<li><strong>等待线程结束</strong>：<ul>
<li>使用 <code>thread.join()</code> 等待所有线程执行完毕。</li>
<li>如果使用 <code>queue.join()</code> 和 <code>queue.task_done()</code> 机制，则等待所有任务完成。</li>
</ul>
</li>
</ol>
<h2 id="四、代码示例：多线程生产者-消费者-使用-STOP-SIGNAL"><a href="#四、代码示例：多线程生产者-消费者-使用-STOP-SIGNAL" class="headerlink" title="四、代码示例：多线程生产者-消费者 (使用 STOP_SIGNAL)"></a>四、代码示例：多线程生产者-消费者 (使用 STOP_SIGNAL)</h2><p>首先，我们实现一个常见的版本，通过发送特殊停止信号来控制消费者的退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义队列中用于终止消费者的特殊值</span></span><br><span class="line">STOP_SIGNAL = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q, producer_id, num_items</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_items):</span><br><span class="line">        item = <span class="string">f&quot;生产商<span class="subst">&#123;producer_id&#125;</span>_产品_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.5</span>)) <span class="comment"># 模拟生产时间</span></span><br><span class="line">        q.put(item) <span class="comment"># put() 是线程安全的，如果队列满了会阻塞</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产了: <span class="subst">&#123;item&#125;</span>, 队列当前大小: <span class="subst">&#123;q.qsize()&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 生产完成后，向队列发送停止信号。</span></span><br><span class="line">    <span class="comment"># 这里的做法是，一个生产者的任务完成后发送一个 STOP_SIGNAL。</span></span><br><span class="line">    <span class="comment"># 如果有多个生产者，通常需要考虑如何协调发送停止信号的数量。</span></span><br><span class="line">    <span class="comment"># 如果有多个消费者，并希望它们都停止，那么每个消费者在收到 STOP_SIGNAL 后</span></span><br><span class="line">    <span class="comment"># 应该将其重新放回队列，以便其他消费者也能接收到。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产完毕。&quot;</span>)</span><br><span class="line">    q.put(STOP_SIGNAL) <span class="comment"># 发送停止信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q, consumer_id</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># get() 是线程安全的，如果队列为空会阻塞</span></span><br><span class="line">        item = q.get() </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> STOP_SIGNAL:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 收到停止信号，退出。&quot;</span>)</span><br><span class="line">            <span class="comment"># 将停止信号重新放回队列，确保其他消费者也能接收到</span></span><br><span class="line">            q.put(STOP_SIGNAL) </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>)) <span class="comment"># 模拟消费时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 消费了: <span class="subst">&#123;item&#125;</span>, 队列当前大小: <span class="subst">&#123;q.qsize()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 当使用 STOP_SIGNAL 机制时，通常不需要 q.task_done() 和 q.join()</span></span><br><span class="line">        <span class="comment"># q.task_done() </span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 1. 创建共享队列</span></span><br><span class="line">    <span class="comment"># maxsize 可以指定队列的最大容量。如果为 0 或负数，则表示队列大小无限制。</span></span><br><span class="line">    <span class="comment"># 有界队列有助于控制内存使用和实现更好的流量控制。</span></span><br><span class="line">    <span class="comment"># 这里设置为 5，便于观察队列满和空的阻塞行为。</span></span><br><span class="line">    q = queue.Queue(maxsize=<span class="number">5</span>) </span><br><span class="line">  </span><br><span class="line">    num_producers = <span class="number">1</span></span><br><span class="line">    num_consumers = <span class="number">2</span></span><br><span class="line">    items_per_producer = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    producers = []</span><br><span class="line">    consumers = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建并启动生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_producers):</span><br><span class="line">        p_thread = threading.Thread(target=producer, args=(q, i + <span class="number">1</span>, items_per_producer))</span><br><span class="line">        producers.append(p_thread)</span><br><span class="line">        p_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建并启动消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers):</span><br><span class="line">        c_thread = threading.Thread(target=consumer, args=(q, i + <span class="number">1</span>))</span><br><span class="line">        consumers.append(c_thread)</span><br><span class="line">        c_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 等待所有生产者线程结束</span></span><br><span class="line">    <span class="keyword">for</span> p_thread <span class="keyword">in</span> producers:</span><br><span class="line">        p_thread.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有生产者线程完成。\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 等待所有消费者线程结束</span></span><br><span class="line">    <span class="comment"># 补充：确保所有消费者都能收到停止信号</span></span><br><span class="line">    <span class="comment"># 在这个 STOP_SIGNAL 传递的场景中，如果最初只有一个生产者发送了一个None，</span></span><br><span class="line">    <span class="comment"># 并且有多个消费者，那么第一个消费者收到None后，把它放回队列，然后退出。</span></span><br><span class="line">    <span class="comment"># 这样第二个消费者才能收到None并退出。</span></span><br><span class="line">    <span class="comment"># 如果生产者能提前知道消费者数量，可以直接发送 N 个None。</span></span><br><span class="line">    <span class="comment"># 但一般情况下，让消费者传递None是更灵活的做法。</span></span><br><span class="line">    <span class="keyword">for</span> c_thread <span class="keyword">in</span> consumers:</span><br><span class="line">        c_thread.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有消费者线程完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序执行完毕。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>代码解析：</strong></p>
<ol>
<li><strong><code>queue.Queue(maxsize=5)</code></strong>：创建一个线程安全的队列，最大容量为 5。</li>
<li><strong><code>STOP_SIGNAL = None</code></strong>：特殊的停止信号。</li>
<li><strong><code>producer</code> 函数</strong>：模拟生产数据，然后 <code>q.put()</code> 放入队列。完成后发送一个 <code>STOP_SIGNAL</code>。</li>
<li><strong><code>consumer</code> 函数</strong>：在一个无限循环中 <code>q.get()</code> 获取数据。如果获取到 <code>STOP_SIGNAL</code>，则将其重新 <code>q.put()</code> 回队列，然后退出循环。<strong>重新放回队列是关键</strong>，确保其他消费者也能收到停止信号。</li>
<li><strong>主程序 (<code>if __name__ == &quot;__main__&quot;:</code>)</strong>：创建并启动线程，然后使用 <code>thread.join()</code> 等待所有线程完成。</li>
</ol>
<h2 id="五、更优雅的终止方式：使用-queue-join-和-queue-task-done"><a href="#五、更优雅的终止方式：使用-queue-join-和-queue-task-done" class="headerlink" title="五、更优雅的终止方式：使用 queue.join() 和 queue.task_done()"></a>五、更优雅的终止方式：使用 <code>queue.join()</code> 和 <code>queue.task_done()</code></h2><p><code>queue</code> 模块提供的 <code>task_done()</code> 和 <code>join()</code> 方法提供了一种更优雅、更健壮的方式来终止消费者线程，尤其是在多生产者、多消费者场景下。这种方式不需要显式地发送特殊停止信号。</p>
<ul>
<li><strong>生产者</strong>：<ul>
<li><code>q.put(item)</code> 之后不需要做额外操作。</li>
</ul>
</li>
<li><strong>消费者</strong>：<ul>
<li><code>item = q.get()</code> 之后，处理完数据。</li>
<li><strong>必须</strong>调用 <code>q.task_done()</code> 通知队列该任务已完成。</li>
</ul>
</li>
<li><strong>主线程</strong>：<ul>
<li>在所有生产者线程启动完毕且不再生产新任务后，可以调用 <code>q.join()</code>。<code>q.join()</code> 会阻塞直到队列中的所有任务都被 <code>get()</code> 并且对应的 <code>task_done()</code> 都被调用。</li>
</ul>
</li>
</ul>
<p>这种方式的缺点是，消费者线程本身不会自动停止。它们会在 <code>q.join()</code> 完成后，因为队列中没有更多任务而继续阻塞在 <code>q.get()</code> 处。为了让它们停止，主线程在 <code>q.join()</code> 之后，仍然需要向队列中放入 <code>num_consumers</code> 个 <code>STOP_SIGNAL</code>。</p>
<p><strong>改进的代码示例 (结合 <code>task_done</code> 和 <code>STOP_SIGNAL</code> 终止消费者)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义队列中用于终止消费者的特殊值</span></span><br><span class="line">STOP_SIGNAL = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer_advanced</span>(<span class="params">q, producer_id, num_items</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_items):</span><br><span class="line">        item = <span class="string">f&quot;生产商<span class="subst">&#123;producer_id&#125;</span>_产品_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.3</span>)) <span class="comment"># 模拟生产时间</span></span><br><span class="line">        q.put(item)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产了: <span class="subst">&#123;item&#125;</span>, 队列当前大小: <span class="subst">&#123;q.qsize()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产完毕。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer_advanced</span>(<span class="params">q, consumer_id</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get() <span class="comment"># 阻塞等待数据</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> STOP_SIGNAL:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 收到停止信号，退出。&quot;</span>)</span><br><span class="line">            q.task_done() <span class="comment"># 标记这个停止信号任务已完成</span></span><br><span class="line">            <span class="comment"># 无需将 STOP_SIGNAL 重新放回队列，因为主线程会发送足够多的 STOP_SIGNAL</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.3</span>, <span class="number">0.8</span>)) <span class="comment"># 模拟消费时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 消费了: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">        q.task_done() <span class="comment"># 标记当前数据项已处理完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    q_adv = queue.Queue(maxsize=<span class="number">10</span>) <span class="comment"># 队列容量设置为 10</span></span><br><span class="line">  </span><br><span class="line">    num_producers_adv = <span class="number">2</span></span><br><span class="line">    num_consumers_adv = <span class="number">3</span></span><br><span class="line">    items_per_producer_adv = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    producers_adv = []</span><br><span class="line">    consumers_adv = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 创建并启动生产者线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_producers_adv):</span><br><span class="line">        p_thread = threading.Thread(target=producer_advanced, args=(q_adv, i + <span class="number">1</span>, items_per_producer_adv))</span><br><span class="line">        producers_adv.append(p_thread)</span><br><span class="line">        p_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建并启动消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers_adv):</span><br><span class="line">        c_thread = threading.Thread(target=consumer_advanced, args=(q_adv, i + <span class="number">1</span>))</span><br><span class="line">        consumers_adv.append(c_thread)</span><br><span class="line">        c_thread.start()</span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 3. 等待所有生产者线程完成</span></span><br><span class="line">    <span class="keyword">for</span> p_thread <span class="keyword">in</span> producers_adv:</span><br><span class="line">        p_thread.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有生产者线程完成。\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 阻塞主线程，直到队列中的所有“真实”任务 (=生产者放入的item) 都被处理完毕</span></span><br><span class="line">    <span class="comment"># q_adv.join() 会等待 put() 的所有 item 都被 get() 和 task_done()</span></span><br><span class="line">    q_adv.join() </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;队列中所有生产任务已被处理完毕。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 现在所有数据都处理完了，向队列中放入与消费者数量相等的 None 信号</span></span><br><span class="line">    <span class="comment"># 以确保所有消费者都能接收到终止信号并安全退出</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers_adv):</span><br><span class="line">        q_adv.put(STOP_SIGNAL) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 6. 等待所有消费者线程完成 (收到 STOP_SIGNAL 并退出)</span></span><br><span class="line">    <span class="keyword">for</span> c_thread <span class="keyword">in</span> consumers_adv:</span><br><span class="line">        c_thread.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有消费者线程完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n多生产者多消费者程序 (task_done/join 结合 STOP_SIGNAL) 执行完毕。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>这种组合方式是多线程生产者-消费者模式较为健壮的实现：</strong></p>
<ul>
<li><code>q.join()</code> 确保了所有数据都被处理，避免了数据丢失。</li>
<li>主线程在数据处理完成后，统一发送停止信号，确保所有消费者都能优雅退出。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Python 的 <code>threading</code> 和 <code>queue</code> 模块提供了一套完善的工具来实现多线程生产者-消费者模式。利用 <code>queue.Queue</code> 的线程安全特性，我们可以很容易地构建出高效且避免竞争条件的并发程序。</p>
<p><strong>选择多线程还是多进程：</strong></p>
<ul>
<li><strong>多线程 (threading)</strong>：适用于 I&#x2F;O 密集型任务（如网络请求、文件读写），因为 GIL 会在 I&#x2F;O 期间释放，允许其他线程运行。程序的启动开销较小，线程间共享数据方便（通过线程安全队列或其他同步原语）。</li>
<li><strong>多进程 (multiprocessing)</strong>：适用于 CPU 密集型任务，因为它能绕过 GIL，真正实现并行计算。进程间通信需要额外的 IPC 机制（如 <code>multiprocessing.Queue</code>），启动开销相对较大。</li>
</ul>
<p>理解并应用生产者-消费者模式，结合 Python 的并发工具，能帮助我们构建出结构清晰、高效且易于维护的并发应用程序。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/832eaf04ac40/">https://blog.tbf1211.xx.kg/832eaf04ac40/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">编码规范</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-09.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/10b74b4460f9/" title="Python 异步编程详解：从并发到协程"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python 异步编程详解：从并发到协程</div></div><div class="info-2"><div class="info-item-1"> Python 异步编程 是一种处理并发任务的编程范式，它允许程序在等待某些操作（如 I&#x2F;O 操作、网络请求、数据库查询）完成时，切换到执行其他任务，从而提高程序的吞吐量和响应速度。与传统的多线程&#x2F;多进程并发模型不同，异步编程通常使用协程 (Coroutines) 和事件循环 (Event Loop) 来实现，避免了线程&#x2F;进程切换的开销，也绕开了 Python 的全局解释器锁 (GIL) 对 CPU 密集型任务的限制（尽管异步编程主要适用于 I&#x2F;O 密集型任务）。  核心思想：异步编程通过在等待 I&#x2F;O 完成时“暂停”当前任务，并“切换”到其他可执行任务，从而在单线程内实现并发和最大化 I&#x2F;O 利用率。   一、为什么需要异步编程？传统的 Python 程序（同步阻塞式）在执行 I&#x2F;O 操作时会阻塞整个程序，直到 I&#x2F;O 完成。例如，一个 Web 服务器在处理一个耗时的网络请求时，就无法处理其他用户的请求，导致性能低下。 1.1 同步阻塞 (Synchronous Blocking)123456789...</div></div></div></a><a class="pagination-related" href="/65edca489ee4/" title="DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS over TLS (DoT) 和 DNS over HTTPS (DoH) 是旨在增强 DNS (Domain Name System) 查询和响应隐私性 (Privacy) 与安全性 (Security) 的两种协议。它们通过对 DNS 流量进行加密，防止网络中间方（如 ISP、政府机构或恶意攻击者）窥探用户的域名解析请求或篡改 DNS 响应，从而解决了传统 DNS 协议固有的安全和隐私缺陷。  核心思想：将明文传输的 DNS 查询封装到加密的传输层安全 (TLS) 或超文本传输安全 (HTTPS) 连接中，以保护用户隐私、防止 DNS 劫持和对抗网络审查。   一、传统 DNS 的隐私与安全痛点传统的 DNS 协议通常通过 UDP (User Datagram Protocol) 或 TCP (Transmission Control Protocol) 的 53 号端口进行通信。这种通信方式存在以下固有的安全和隐私缺陷：  明文传输 (Plaintext Transmission)：DNS 查询和响应在网络上以明文形式传输。  隐私泄露：任何能够嗅探网络流量的中间...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/a1d408b2ddbe/" title="Python多进程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="info-item-2">Python多进程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式概述模式构成：  生产者 (Producer)：负责生成数据，并将其放入共享的缓冲区（队列）中。 消费者 (Consumer)：负责从共享的缓冲区（队列）中取出数据进行处理。 缓冲区 (Buffer &#x2F; Queue)：一个共享的数据结构，通常是一个队列，用于存储生产者生产的数据和消费者消费的数据。它充当了生产者和消费者之间的桥梁。  解决的问题：  解耦：生产者和消费者可以独立运行，互不干扰，提高系统的灵活性。 并发：允许多个生产者和多个消费者同时存在，提高处理效率。 削峰填谷：当生产速度快于消费速度时，缓冲区可以存储多余的数据，防止数...</div></div></div></a><a class="pagination-related" href="/10b74b4460f9/" title="Python 异步编程详解：从并发到协程"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-22</div><div class="info-item-2">Python 异步编程详解：从并发到协程</div></div><div class="info-2"><div class="info-item-1"> Python 异步编程 是一种处理并发任务的编程范式，它允许程序在等待某些操作（如 I&#x2F;O 操作、网络请求、数据库查询）完成时，切换到执行其他任务，从而提高程序的吞吐量和响应速度。与传统的多线程&#x2F;多进程并发模型不同，异步编程通常使用协程 (Coroutines) 和事件循环 (Event Loop) 来实现，避免了线程&#x2F;进程切换的开销，也绕开了 Python 的全局解释器锁 (GIL) 对 CPU 密集型任务的限制（尽管异步编程主要适用于 I&#x2F;O 密集型任务）。  核心思想：异步编程通过在等待 I&#x2F;O 完成时“暂停”当前任务，并“切换”到其他可执行任务，从而在单线程内实现并发和最大化 I&#x2F;O 利用率。   一、为什么需要异步编程？传统的 Python 程序（同步阻塞式）在执行 I&#x2F;O 操作时会阻塞整个程序，直到 I&#x2F;O 完成。例如，一个 Web 服务器在处理一个耗时的网络请求时，就无法处理其他用户的请求，导致性能低下。 1.1 同步阻塞 (Synchronous Blocking)123456789...</div></div></div></a><a class="pagination-related" href="/90492206afee/" title="Java BIO、NIO、AIO 对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-14</div><div class="info-item-2">Java BIO、NIO、AIO 对比详解</div></div><div class="info-2"><div class="info-item-1"> Java I&#x2F;O (Input&#x2F;Output) 是应用程序与外部设备之间进行数据传输的桥梁。随着并发编程和高性能网络应用的需求日益增长，Java 提供了多种 I&#x2F;O 模型，以适应不同的使用场景。其中，最核心的三种模型是 BIO (Blocking I&#x2F;O)、NIO (Non-blocking I&#x2F;O) 和 AIO (Asynchronous I&#x2F;O)，它们在处理数据流和网络通信方面有着显著的区别。  核心思想：理解 BIO、NIO 和 AIO 的根本差异在于它们对 I&#x2F;O 操作的阻塞特性、线程管理方式 以及 事件通知机制 的处理。这直接影响着应用在并发、吞吐量和资源利用率方面的表现。   一、同步与异步，阻塞与非阻塞在深入探讨 BIO、NIO、AIO 之前，我们首先明确两个基本概念：  同步 (Synchronous) vs 异步 (Asynchronous)：  同步：发起一个 I&#x2F;O 操作后，调用者需要等待操作完成才能继续执行后续任务。 异步：发起一个 I&#x2F;O 操作后，调用者可以立即返...</div></div></div></a><a class="pagination-related" href="/ad010eef8c35/" title="Java 多线程编程详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-29</div><div class="info-item-2">Java 多线程编程详解</div></div><div class="info-2"><div class="info-item-1"> Java 多线程编程 是指在一个 Java 应用程序中同时执行多个独立的任务（或代码路径）。线程是操作系统调度的最小执行单元，而多线程编程允许程序更有效地利用 CPU 资源，提高程序的响应性和吞吐量，尤其是在现代多核处理器环境中。  核心思想：将一个程序分解为多个独立的执行流，并发地运行以提高效率和响应性。这要求开发者妥善处理线程间的协作与资源竞争，以避免数据不一致、死锁等问题。    一、为什么需要多线程编程？在单线程环境中，程序任务按顺序执行。如果一个任务耗时较长（例如 I&#x2F;O 操作、复杂计算），整个程序就会“卡住”，直到该任务完成。多线程编程旨在解决这些问题：  提高程序响应性：在图形用户界面 (GUI) 应用程序中，可以将耗时操作放在后台线程执行，主线程（UI 线程）保持响应，提升用户体验。 提高系统吞吐量：在服务器端应用中，可以同时处理多个客户端请求，从而提高服务器的处理能力。 充分利用多核 CPU 资源：现代处理器普遍拥有多核。多线程允许程序将计算任务分解为可并行执行的部分，从而利用所有可用的 CPU 核心，显著缩短总执行时间。 简化编程模型：对于某些复杂...</div></div></div></a><a class="pagination-related" href="/c0ed8953ea7d/" title="Python 编码规范详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="info-item-2">Python 编码规范详解</div></div><div class="info-2"><div class="info-item-1"> Python 编码规范 旨在提供一套指导原则和最佳实践，以确保 Python 代码的一致性、可读性、可维护性、可协作性和**“Pythonic”**（符合 Python 语言哲学）风格。Python 社区的核心编码规范是 PEP 8 (Python Enhancement Proposal 8)，它定义了 Python 代码的风格指南。遵循 PEP 8 不仅能让你的代码更容易被其他 Python 开发者理解，也能提高代码本身的质量和减少潜在错误。  核心思想：一致性至关重要。代码是写给人看的，不是机器。清晰、简洁、可读的代码能够极大地提高开发效率和项目成功率。   一、Python 编码哲学与 PEP 8Python 语言的设计哲学（可在 import this 中查看“The Zen of Python”）强调简洁、明确和可读性。PEP 8 是将这些哲学转化为具体编码实践的基石。 PEP 8 是什么？PEP 8 是 Python 官方的风格指南，由 Guido van Rossum (Python 创始人)、Barry Warsaw 和 Nick Coghlan 共同撰写。它...</div></div></div></a><a class="pagination-related" href="/f6307a80c973/" title="Python 防止循环依赖 (Circular Dependencies) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-07</div><div class="info-item-2">Python 防止循环依赖 (Circular Dependencies) 详解</div></div><div class="info-2"><div class="info-item-1"> 循环依赖 (Circular Dependency) 指的是两个或多个模块（在 Python 中通常是文件或包）之间相互直接或间接地导入对方。例如，moduleA.py 导入了 moduleB.py，而 moduleB.py 也导入了 moduleA.py。与 Golang 等语言在编译时直接报错不同，Python 在运行时才处理导入，因此循环依赖通常不会立即导致语法错误，但会在运行时触发 ImportError 或导致不可预测的行为，使代码难以理解、测试和维护。  核心思想：Python 允许在运行时灵活处理导入，但循环依赖是一个设计缺陷的信号，会导致运行时错误或维护噩梦。解决它的关键在于重构代码以建立单向依赖。   一、为什么循环依赖是一个问题？尽管 Python 不像 Go 那样在编译时严格禁止循环依赖，但它依然是需要极力避免的设计缺陷：  运行时 ImportError:这是最常见的直接问题。当 Python 解释器遇到循环导入时，某个模块在被完全初始化之前可能就被另一个模块尝试导入，导致模块中的对象、函数或类尚未定义而引发 ImportError。 示例：module...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">521</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">一、生产者-消费者模式与多线程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.1 生产者-消费者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E-GIL"><span class="toc-text">1.2 Python 多线程与 GIL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%A8%A1%E5%9D%97"><span class="toc-text">二、Python 多线程实现的关键模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-threading-%E6%A8%A1%E5%9D%97"><span class="toc-text">2.1 threading 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-queue-%E6%A8%A1%E5%9D%97"><span class="toc-text">2.2 queue 模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">三、多线程生产者-消费者模式的实现步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85-%E4%BD%BF%E7%94%A8-STOP-SIGNAL"><span class="toc-text">四、代码示例：多线程生产者-消费者 (使用 STOP_SIGNAL)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8-queue-join-%E5%92%8C-queue-task-done"><span class="toc-text">五、更优雅的终止方式：使用 queue.join() 和 queue.task_done()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-09.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>