<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Tomcat、Jetty 和 Undertow 对比详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Tomcat、Jetty 和 Undertow 都是流行的 Java Web 服务器和 Servlet 容器，它们实现了 Java Servlet 规范、JavaServer Pages (JSP) 规范、Java Expression Language (EL) 规范以及 WebSocket 规范。在 Java 企业级应用开发中，特别是在 Spring Boot 等框架盛行的微服务时代，选择一">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat、Jetty 和 Undertow 对比详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/793b1126e524/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Tomcat、Jetty 和 Undertow 都是流行的 Java Web 服务器和 Servlet 容器，它们实现了 Java Servlet 规范、JavaServer Pages (JSP) 规范、Java Expression Language (EL) 规范以及 WebSocket 规范。在 Java 企业级应用开发中，特别是在 Spring Boot 等框架盛行的微服务时代，选择一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-29.jpg">
<meta property="article:published_time" content="2023-06-27T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-13T08:28:22.715Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Server">
<meta property="article:tag" content="开发工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-29.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tomcat、Jetty 和 Undertow 对比详解",
  "url": "https://blog.tbf1211.xx.kg/793b1126e524/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-29.jpg",
  "datePublished": "2023-06-27T22:24:00.000Z",
  "dateModified": "2026-01-13T08:28:22.715Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/793b1126e524/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tomcat、Jetty 和 Undertow 对比详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">489</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-29.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Tomcat、Jetty 和 Undertow 对比详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Tomcat、Jetty 和 Undertow 对比详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-27T22:24:00.000Z" title="发表于 2023-06-28 06:24:00">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Server/">Server</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Tomcat、Jetty 和 Undertow</strong> 都是流行的 <strong>Java Web 服务器和 Servlet 容器</strong>，它们实现了 Java Servlet 规范、JavaServer Pages (JSP) 规范、Java Expression Language (EL) 规范以及 WebSocket 规范。在 Java 企业级应用开发中，特别是在 Spring Boot 等框架盛行的微服务时代，选择一个合适的内嵌或独立 Web 服务器变得尤为重要。虽然它们功能相似，但在架构设计、性能特点、内存占用、灵活性和社区支持等方面各有侧重。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：理解这些 Web 服务器的内部机制和特点，有助于在不同场景下做出最优选择。Tomcat 以稳定和功能全面闻名，Jetty 以轻量和可嵌入性见长，而 Undertow 则以高性能和低资源消耗脱颖而出。</p>
</div>
<hr>
<h2 id="一、基本概念和共通性"><a href="#一、基本概念和共通性" class="headerlink" title="一、基本概念和共通性"></a>一、基本概念和共通性</h2><p>在深入对比之前，我们先明确一些基本概念：</p>
<ul>
<li><strong>Web 服务器</strong>：能够响应 HTTP 请求，提供静态内容（如 HTML, CSS, JavaScript, 图片）。</li>
<li><strong>Servlet 容器</strong>：实现了 Java Servlet 规范，能够运行和管理 Java Servlet 组件。它将客户端请求转换为 Servlet 可处理的格式，并将 Servlet 生成的响应转换回 HTTP 响应。</li>
<li><strong>应用服务器 (Application Server)</strong>：功能更全面，除了 Servlet 容器，还提供 EJB、JMS、JTA 等更广泛的企业级服务（例如 JBoss EAP, WebLogic, WebSphere）。Tomcat、Jetty 和 Undertow 通常被归类为<strong>轻量级 Web 服务器&#x2F;Servlet 容器</strong>。</li>
<li><strong>JSP 引擎</strong>：负责将 JSP 文件转换为 Servlet。</li>
<li><strong>WebSocket 支持</strong>：支持双向通信协议，用于实时应用。</li>
<li><strong>HTTP&#x2F;2 支持</strong>：现代 Web 服务器普遍支持。</li>
</ul>
<h2 id="二、Apache-Tomcat"><a href="#二、Apache-Tomcat" class="headerlink" title="二、Apache Tomcat"></a>二、Apache Tomcat</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><ul>
<li><strong>官方</strong>：Apache Tomcat <a target="_blank" rel="noopener external nofollow noreferrer" href="https://tomcat.apache.org/"><sup>1</sup></a></li>
<li><strong>类型</strong>：开源，由 Apache 软件基金会开发和维护。</li>
<li><strong>历史</strong>：Java Web 领域最老牌、最成熟、最广泛使用的 Servlet 容器。</li>
<li><strong>使用场景</strong>：从小型网站到大型企业级应用，独立部署和作为 Spring Boot 的默认内嵌服务器。</li>
</ul>
<h3 id="2-2-架构特点"><a href="#2-2-架构特点" class="headerlink" title="2.2 架构特点"></a>2.2 架构特点</h3><ul>
<li><strong>模块化程度较低</strong>：虽然有组件概念，但相对 Jetty 和 Undertow，其内部模块化和可嵌入性稍弱。</li>
<li><strong>连接器 (Connectors)</strong>：负责与客户端通信，如 <code>Http11NioProtocol</code> (默认，非阻塞 I&#x2F;O)、<code>AjpProtocol</code> (与 Apache HTTP Server 集成)。</li>
<li><strong>容器等级结构</strong>：<code>Engine</code> -&gt; <code>Host</code> -&gt; <code>Context</code>。<ul>
<li><code>Engine</code>：处理所有请求的顶层容器。</li>
<li><code>Host</code>：虚拟主机，可部署多个 Web 应用。</li>
<li><code>Context</code>：代表一个独立的 Web 应用 (<code>.war</code> 文件)。</li>
</ul>
</li>
<li><strong>默认 I&#x2F;O 模型</strong>：从 Tomcat 8.x 开始，默认使用 NIO 或 NIO2 (非阻塞 I&#x2F;O)。早期版本默认是 BIO (阻塞 I&#x2F;O)。</li>
<li><strong>线程模型</strong>：每个请求由一个工作线程处理，通过线程池管理这些线程。</li>
</ul>
<h3 id="2-3-性能与资源"><a href="#2-3-性能与资源" class="headerlink" title="2.3 性能与资源"></a>2.3 性能与资源</h3><ul>
<li><strong>性能</strong>：整体性能良好，在大多数场景下都能满足需求。但在高并发、短连接场景下，由于其线程模型和默认配置，可能不如 NIO 纯并发模型（如 Undertow）表现极端出色。</li>
<li><strong>启动速度</strong>：相对 Jetty 和 Undertow 稍慢，因为需要初始化更多的组件。</li>
<li><strong>内存占用</strong>：相对较高，但随着版本迭代，Tomcat 在内存优化方面也做了很多工作。</li>
</ul>
<h3 id="2-4-优缺点"><a href="#2-4-优缺点" class="headerlink" title="2.4 优缺点"></a>2.4 优缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li><strong>社区庞大</strong>：资料丰富，遇到问题容易找到解决方案。</li>
<li><strong>功能全面</strong>：支持所有 Servlet 规范版本，功能丰富。</li>
<li><strong>稳定成熟</strong>：经过长时间的市场验证，企业级应用广泛使用。</li>
<li><strong>管理工具</strong>：提供了管理界面。</li>
<li><strong>生态完善</strong>：与各种 Java EE&#x2F;Jakarta EE 技术栈和 IDE 集成良好。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>启动速度相对慢</strong>：在一些快速开发和测试场景下可能不太理想。</li>
<li><strong>内存占用相对高</strong>：在资源受限的环境下需要谨慎考虑。</li>
<li><strong>可嵌入性相对复杂</strong>：虽然可以嵌入，但其模块化程度和 API 友好性不如 Jetty&#x2F;Undertow。</li>
</ul>
</li>
</ul>
<h3 id="2-5-示例-Spring-Boot"><a href="#2-5-示例-Spring-Boot" class="headerlink" title="2.5 示例 (Spring Boot)"></a>2.5 示例 (Spring Boot)</h3><p>Spring Boot 默认内嵌了 Tomcat。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你在 <code>pom.xml</code> 中引入 <code>spring-boot-starter-web</code>，Spring Boot 就会自动引入和配置 Tomcat。</p>
<h2 id="三、Eclipse-Jetty"><a href="#三、Eclipse-Jetty" class="headerlink" title="三、Eclipse Jetty"></a>三、Eclipse Jetty</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><ul>
<li><strong>官方</strong>：Eclipse Jetty <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.eclipse.org/jetty/"><sup>2</sup></a></li>
<li><strong>类型</strong>：开源，由 Eclipse 基金会开发和维护（最初由 Mort Bay Consulting 开发）。</li>
<li><strong>历史</strong>：从早期版本就强调<strong>轻量级、可嵌入性</strong>和高并发。</li>
<li><strong>使用场景</strong>：传统 Web 应用、嵌入式设备、桌面应用、高并发微服务。许多开源项目和工具（如 Hadoop、Maven、Eclipse 等）内部都使用了 Jetty。</li>
</ul>
<h3 id="3-2-架构特点"><a href="#3-2-架构特点" class="headerlink" title="3.2 架构特点"></a>3.2 架构特点</h3><ul>
<li><strong>高度模块化</strong>：完全基于组件化思想设计，每个功能都是一个独立的组件，易于裁剪和嵌入。</li>
<li><strong>事件驱动 &#x2F; NIO</strong>：从设计之初就采用了事件驱动和非阻塞 I&#x2F;O 模型，这使其在高并发场景下表现出色。</li>
<li><strong>轻量级 API</strong>：提供非常瘦的 API，方便直接在代码中启动和配置。</li>
<li><strong>线程模型</strong>：使用 Jetty 的 <code>ThreadPool</code> 管理请求处理线程。一个请求处理线程通常会从 <code>Selector</code> 获取事件，然后处理请求。</li>
</ul>
<h3 id="3-3-性能与资源"><a href="#3-3-性能与资源" class="headerlink" title="3.3 性能与资源"></a>3.3 性能与资源</h3><ul>
<li><strong>性能</strong>：在高并发、长时间连接（如 WebSocket）场景下表现优异。</li>
<li><strong>启动速度</strong>：非常快，通常比 Tomcat 快。</li>
<li><strong>内存占用</strong>：非常低，是三者中内存占用最小的之一，非常适合内存受限的环境。</li>
</ul>
<h3 id="3-4-优缺点"><a href="#3-4-优缺点" class="headerlink" title="3.4 优缺点"></a>3.4 优缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li><strong>极致轻量</strong>：核心包非常小，体积小，内存占用低。</li>
<li><strong>高度可嵌入</strong>：提供简洁的 API，非常容易在任何 Java 应用中以编程方式启动和配置。</li>
<li><strong>高并发和低延迟</strong>：得益于其事件驱动和 NIO 架构，在处理大量并发连接时表现出色。</li>
<li><strong>快速启动</strong>：极快的启动速度，适合开发和测试环境。</li>
<li><strong>WebSocket支持</strong>：其 WebSocket 实现被许多开发者认为是最好的之一。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>社区相对较小</strong>：相对于 Tomcat，社区和资料不如其丰富。</li>
<li><strong>功能相对精简</strong>：默认提供的管理界面和高级功能不如 Tomcat 丰富，可能需要额外配置。</li>
<li><strong>学习曲线</strong>：对于习惯了传统 Tomcat 配置的开发者，需要适应 Jetty 的组件化和 API 式配置。</li>
</ul>
</li>
</ul>
<h3 id="3-5-示例-Spring-Boot"><a href="#3-5-示例-Spring-Boot" class="headerlink" title="3.5 示例 (Spring Boot)"></a>3.5 示例 (Spring Boot)</h3><p>在 Spring Boot 中可以轻松切换到 Jetty：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、Red-Hat-Undertow"><a href="#四、Red-Hat-Undertow" class="headerlink" title="四、Red Hat Undertow"></a>四、Red Hat Undertow</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h3><ul>
<li><strong>官方</strong>：Undertow <a target="_blank" rel="noopener external nofollow noreferrer" href="http://undertow.io/"><sup>3</sup></a></li>
<li><strong>类型</strong>：开源，由 Red Hat 开发，是 WildFly (原 JBoss AS) 应用服务器的默认 Web 服务器。</li>
<li><strong>历史</strong>：相对年轻，但发展迅速，设计之初就以高性能、灵活性和对 Java EE&#x2F;Jakarta EE 的最新支持为目标。</li>
<li><strong>使用场景</strong>：高吞吐量、低延迟要求、微服务、响应式编程。</li>
</ul>
<h3 id="4-2-架构特点"><a href="#4-2-架构特点" class="headerlink" title="4.2 架构特点"></a>4.2 架构特点</h3><ul>
<li><strong>全异步、非阻塞</strong>：整个服务器都是基于 NIO (XNIO) 构建的，默认情况下所有请求都是非阻塞的。</li>
<li><strong>多线程模型优化</strong>：采用更高效的基于 <strong>Event Loop (事件循环)</strong> 和 <strong>IO Worker</strong> 的线程模型，类似于 Node.js。IO 线程负责接受连接并调度请求，工作线程负责执行实际业务逻辑。</li>
<li><strong>极其灵活</strong>：可以通过编程方式构建 Handler 链，甚至直接通过 <code>ByteBuffer</code> API 来处理请求，提供非常细粒度的控制。</li>
<li><strong>Servlet 3.1+ 支持</strong>：完全支持最新的 Servlet 规范，以及 WebSocket。</li>
<li><strong>设计理念</strong>：轻量级、高性能、可嵌入性、模块化。</li>
</ul>
<h3 id="4-3-性能与资源"><a href="#4-3-性能与资源" class="headerlink" title="4.3 性能与资源"></a>4.3 性能与资源</h3><ul>
<li><strong>性能</strong>：在吞吐量和并发连接方面通常是三者中表现最好的，尤其是在高并发、大量短连接或长连接混合的场景下。</li>
<li><strong>启动速度</strong>：非常快，与 Jetty 相当，甚至更快。</li>
<li><strong>内存占用</strong>：非常低，与 Jetty 相当。</li>
</ul>
<h3 id="4-4-优缺点"><a href="#4-4-优缺点" class="headerlink" title="4.4 优缺点"></a>4.4 优缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li><strong>卓越的性能和吞吐量</strong>：在并发处理和响应速度方面表现非常出色。</li>
<li><strong>极低资源占用</strong>：内存和 CPU 占用率都很低。</li>
<li><strong>全异步非阻塞</strong>：更适用于响应式编程和高并发场景。</li>
<li><strong>高度可编程和灵活性</strong>：提供的 API 允许非常精细的控制，可以构建定制的 Web Server。</li>
<li><strong>快速启动</strong>：非常适合微服务和快速开发场景。</li>
<li><strong>支持 HTTP&#x2F;2</strong>：开箱即用。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>相对年轻，社区较小</strong>：相对于 Tomcat 和 Jetty，社区活跃度和资料相对较少。</li>
<li><strong>学习曲线稍陡峭</strong>：对于习惯了传统 Servlet 模型或 Tomcat 配置的开发者，其全异步和 Handler 链的编程方式需要适应。</li>
<li><strong>配置相对底层</strong>：虽然灵活，但有时也意味着你需要更多地关注底层细节。</li>
</ul>
</li>
</ul>
<h3 id="4-5-示例-Spring-Boot"><a href="#4-5-示例-Spring-Boot" class="headerlink" title="4.5 示例 (Spring Boot)"></a>4.5 示例 (Spring Boot)</h3><p>在 Spring Boot 中可以轻松切换到 Undertow：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、对比总结与选择建议"><a href="#五、对比总结与选择建议" class="headerlink" title="五、对比总结与选择建议"></a>五、对比总结与选择建议</h2><p>下表总结了 Tomcat、Jetty 和 Undertow 的关键特性对比：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Apache Tomcat</th>
<th align="left">Eclipse Jetty</th>
<th align="left">Red Hat Undertow</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>I&#x2F;O 模型</strong></td>
<td align="left">默认 NIO&#x2F;NIO2 (从 8.x 开始)</td>
<td align="left">事件驱动, NIO</td>
<td align="left">全异步, NIO2 (基于 XNIO)</td>
</tr>
<tr>
<td align="left"><strong>启动速度</strong></td>
<td align="left">中等</td>
<td align="left">快</td>
<td align="left">快 (甚至更快)</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">中等偏高</td>
<td align="left">低</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left"><strong>性能表现</strong></td>
<td align="left">稳定良好，传统 Servlet 应用优选</td>
<td align="left">高并发&#x2F;长连接表现优异</td>
<td align="left">超高性能&#x2F;高吞吐量，响应式支持好</td>
</tr>
<tr>
<td align="left"><strong>模块化</strong></td>
<td align="left">一般，相对集成化</td>
<td align="left">高度模块化，组件化设计</td>
<td align="left">极其模块化和可编程</td>
</tr>
<tr>
<td align="left"><strong>可嵌入性</strong></td>
<td align="left">可嵌入，但 API 相对繁琐</td>
<td align="left">极佳，API 精简且友好</td>
<td align="left">极佳，API 灵活且强大</td>
</tr>
<tr>
<td align="left"><strong>社区支持</strong></td>
<td align="left">巨大，资料丰富，生态完善</td>
<td align="left">较大，广泛使用于开源工具</td>
<td align="left">相对较小，主要由 Red Hat 和 WildFly 社区推动</td>
</tr>
<tr>
<td align="left"><strong>设计理念</strong></td>
<td align="left">稳定、全面、传统企业应用</td>
<td align="left">轻量、可嵌入、高并发</td>
<td align="left">高性能、异步、灵活、可定制</td>
</tr>
<tr>
<td align="left"><strong>主要应用</strong></td>
<td align="left">Spring Boot 默认，各种 Java Web 应用</td>
<td align="left">Hadoop, Maven, Eclipse, 小型&#x2F;嵌入式系统</td>
<td align="left">WildFly 应用服务器默认，高并发&#x2F;微服务</td>
</tr>
</tbody></table>
<h3 id="5-1-如何选择？"><a href="#5-1-如何选择？" class="headerlink" title="5.1 如何选择？"></a>5.1 如何选择？</h3><p>在实际项目中选择合适的 Web 服务器，通常需要考虑以下因素：</p>
<ol>
<li><p><strong>项目规模和需求</strong>：</p>
<ul>
<li><strong>传统大型企业应用，追求极致稳定和成熟生态</strong>：Tomcat 依然是稳妥的选择。</li>
<li><strong>微服务架构，需要快速启动、低资源消耗，或高并发&#x2F;长连接</strong>：Jetty 或 Undertow 是更好的选择。</li>
<li><strong>对性能有极致要求，或倾向于响应式编程</strong>：Undertow 更具优势。</li>
</ul>
</li>
<li><p><strong>团队熟练度</strong>：</p>
<ul>
<li>如果团队对 Tomcat 最熟悉，并且项目需求不是特别苛刻，继续使用 Tomcat 能够减少学习成本。</li>
</ul>
</li>
<li><p><strong>资源限制</strong>：</p>
<ul>
<li>在内存和 CPU 资源受限的环境（如小型设备、低配云服务器），Jetty 和 Undertow 的低资源占用是重要优势。</li>
</ul>
</li>
<li><p><strong>可嵌入性需求</strong>：</p>
<ul>
<li>如果需要将 Web 服务器嵌入到独立应用、桌面应用或测试工具中：Jetty 是传统最佳选择，Undertow 也非常出色。</li>
</ul>
</li>
<li><p><strong>特定功能支持</strong>：</p>
<ul>
<li>某些高级功能或与特定规范的紧密集成，可能某些服务器支持得更好。例如，Undertow 对最新的 Servlet 规范和 HTTP&#x2F;2 有很好的支持。</li>
</ul>
</li>
</ol>
<p><strong>经验法则</strong>：</p>
<ul>
<li><strong>大多数 Spring Boot 应用</strong>：默认使用 <strong>Tomcat</strong> 即可，除非有明确的理由需要切换。</li>
<li><strong>追求极致性能和响应式编程</strong>：考虑使用 <strong>Undertow</strong>。</li>
<li><strong>需要低内存占用和高可嵌入性</strong>：考虑使用 <strong>Jetty</strong> 或 <strong>Undertow</strong>。</li>
</ul>
<p>在 Spring Boot 中，切换内嵌服务器非常方便，通常只需要修改 Maven&#x2F;Gradle 依赖即可，因此也可以根据项目不同阶段的需求进行尝试和调整。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Tomcat、Jetty 和 Undertow 各自拥有独特的优势和设计哲学。Tomcat 以其无与伦比的成熟度、稳定性和庞大社区，仍然是 Java Web 服务器领域的基石。Jetty 以其轻量级、可嵌入性和在高并发场景下的出色表现赢得了一席之地。而 Undertow 作为后起之秀，则以其卓越的性能、全异步架构和极高的灵活性，在高吞吐量和微服务场景下展现出强大潜力。了解它们的差异有助于开发者在构建现代 Java 应用程序时，做出更明智、更符合项目需求的服务器选型决策。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/793b1126e524/">https://blog.tbf1211.xx.kg/793b1126e524/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Server/">Server</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-29.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/be930ce35928/" title="Java 常用设计模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java 常用设计模式详解</div></div><div class="info-2"><div class="info-item-1"> 设计模式 (Design Patterns) 是在软件工程中，针对特定问题场景提出的一套经过验证的、可复用的解决方案。它们是从实践中总结出来的，是软件开发过程中的最佳实践。学习和应用设计模式，可以帮助开发者构建出结构清晰、可维护、可扩展、复用性强的软件系统，同时也能促进团队成员之间的沟通。  核心思想：设计模式的目标是提升软件的灵活性 (Flexibility)、可重用性 (Reusability) 和可扩展性 (Extensibility)，同时降低维护成本 (Maintainability)。它们不是代码，而是解决特定问题的思想和方法。   一、设计模式的分类根据 GoF (Gang of Four，《设计模式：可复用面向对象软件的基础》的四位作者) 的经典分类，设计模式主要分为三类：  创建型模式 (Creational Patterns)： 关注对象的创建机制，目标是解耦对象的创建与使用，从而提供更大的灵活性。 包括：单例 (Singleton)、工厂方法 (Factory Method)、抽象工厂 (Abstract Factory)、建造者 (Builder)、原型...</div></div></div></a><a class="pagination-related" href="/bfc3178a0093/" title="FRP (Fast Reverse Proxy) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">FRP (Fast Reverse Proxy) 详解</div></div><div class="info-2"><div class="info-item-1"> FRP (Fast Reverse Proxy) 是一个高性能的内网穿透和反向代理工具，它允许您将位于内网（局域网）中的服务（如 Web 服务器、SSH、数据库等）通过一台具有公网 IP 的服务器暴露给公网用户访问。在当前 IPv4 地址资源日益紧张，许多家庭和小型办公室难以获取公网 IP 的背景下，FRP 提供了便捷、高效的解决方案。  核心思想：FRP 通过在公网服务器上运行一个 frps (服务端) 和在内网机器上运行一个 frpc (客户端) 来建立连接。内网流量经由 frpc 转发到 frps，再由 frps 转发到公网用户，实现内网服务的公网访问。   一、为什么需要 FRP？在许多场景下，我们需要从外部网络访问位于内网的服务，但常常面临以下问题：  没有公网 IP：大多数家庭宽带用户和一些小型企业用户不再拥有独立的公网 IPv4 地址。他们处于运营商的 NAT (Network Address Translation) 之后，无法直接从外部访问内网设备。 端口转发困难：即使有公网 IP，也可能需要手动在路由器上配置端口转发规则，这对于不熟悉网络配置的用户来说可能比...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/334a7af73894/" title="Nginx 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-26</div><div class="info-item-2">Nginx 深度解析</div></div><div class="info-2"><div class="info-item-1"> Nginx (发音为 “engine-x”) 是一个高性能的 HTTP 和反向代理服务器，也可以用作 邮件代理服务器 和通用的 TCP&#x2F;UDP 代理服务器。它最初由 Igor Sysoev 为俄罗斯最大的门户网站和搜索引擎 Rambler 开发，并于 2004 年公开发布。Nginx 因其卓越的性能、稳定性、丰富的功能集和低资源消耗而广受欢迎，是构建现代高并发 Web 应用程序和微服务架构不可或缺的组件。  核心思想：Nginx 采用事件驱动 (event-driven)、异步非阻塞 (asynchronous, non-blocking) 架构，使其在处理大量并发连接时表现出色，远超传统的基于进程&#x2F;线程模型的服务器。   一、为什么选择 Nginx？ (优势)Nginx 之所以成为众多高流量网站和云服务提供商的首选，主要得益于以下优势：  高性能高并发： 事件驱动架构：Nginx 的核心是其事件驱动的异步非阻塞架构。这意味着单个工作进程可以处理数千个并发连接，而无需为每个连接创建单独的进程或线程。这大大减少了上下文切换的开销和内存消耗。 低内存消耗：相较于...</div></div></div></a><a class="pagination-related" href="/bd9bce873bad/" title="Node.js 本地静态服务详解：http-server 与 live-server"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-24</div><div class="info-item-2">Node.js 本地静态服务详解：http-server 与 live-server</div></div><div class="info-2"><div class="info-item-1"> 在前端开发中，我们经常需要一个简单的本地 Web 服务器来预览静态文件，或者在开发 SPA (单页应用) 时提供必要的 HTTP 服务。Node.js 生态系统提供了许多这样的命令行工具，其中最常用和便捷的当属 http-server 和 live-server。本文将详细介绍这两个工具的安装、使用、特性以及它们之间的区别，帮助开发者根据需求选择合适的本地服务器。  核心思想：利用 Node.js 提供的便捷命令行工具，快速搭建本地静态文件服务器，其中 live-server 更进一步提供了实时重载功能以优化开发体验。   一、http-server 详解http-server 是一个简单、零配置的命令行 HTTP 服务器。它适用于快速提供本地文件服务，非常适合静态网站的预览、API 模拟等场景。 1.1 安装http-server 是一个 Node.js 包，通过 npm (Node Package Manager) 全局安装即可。 1npm install -g http-server  1.2 基本使用安装完成后，在任何包含静态文件的目录下运行 http-server 命...</div></div></div></a><a class="pagination-related" href="/4749d07931d6/" title="Java Lambda 表达式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-25</div><div class="info-item-2">Java Lambda 表达式详解</div></div><div class="info-2"><div class="info-item-1"> Java Lambda 表达式 是 Java 8 引入的一个核心特性，它提供了一种简洁的方式来表示匿名函数 (Anonymous Function)。Lambda 表达式主要用于实现函数式接口 (Functional Interface)，极大地简化了代码，尤其是在处理集合、事件监听器和并发编程时，使 Java 代码更具表达力和可读性。  核心思想：将行为（一段代码逻辑）作为参数传递给方法。它实际上是函数式接口的“语法糖”，使得函数式接口的实现变得异常简洁。    一、为什么需要 Lambda 表达式？在 Java 8 之前，如果我们需要将一段行为（代码逻辑）作为参数传递给方法，通常需要依赖匿名内部类 (Anonymous Inner Class)。这种方式在某些场景下会导致代码冗长且可读性差。 例如，一个简单的 Runnable 接口的实现： 1234567// Java 8 之前：使用匿名内部类new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out...</div></div></div></a><a class="pagination-related" href="/a50cc05145ea/" title="Java 内部类详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-23</div><div class="info-item-2">Java 内部类详解</div></div><div class="info-2"><div class="info-item-1"> Java 内部类 (Inner Class) 是定义在另一个类（称为外部类或外围类，Outer Class）内部的类。内部类与外部类之间存在一种特殊的关联，它能够访问其外部类的所有成员，包括 private 成员。这种机制增强了封装性，并允许创建更紧密耦合的组件。  核心思想：将逻辑上紧密相关的类封装在一起，以提高代码的组织性、可读性和安全性。内部类可以访问外部类的成员，而外部类也可以直接访问内部类的成员（如果内部类是 public 或 protected）。    一、为什么需要内部类？在 Java 中，引入内部类主要有以下几个原因：  增强封装性 (Encapsulation)：内部类可以访问外部类的 private 成员，这使得它们可以更紧密地与外部类进行协作，同时将一些只与外部类相关的类隐藏起来，避免污染包命名空间。 代码组织与可读性 (Code Organization and Readability)：当一个类只对另一个类有意义时，将它定义为内部类可以使代码结构更清晰，逻辑上更紧密地联系在一起。例如，一个 Map 接口的 Entry 内部接口就逻辑上属于 Map。 ...</div></div></div></a><a class="pagination-related" href="/3e9097743fd8/" title="Java Lombok 库详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-20</div><div class="info-item-2">Java Lombok 库详解</div></div><div class="info-2"><div class="info-item-1"> Project Lombok (Lombok) 是一个 Java 库，旨在通过注解处理器 (Annotation Processor) 自动生成 Java 类中的样板代码，例如 getter、setter、equals、hashCode、toString 等方法，以及构造函数。它的目标是减少代码的冗余，提升开发效率和代码的可读性、简洁性。  核心思想：Lombok 在编译阶段通过注解处理器介入，在 .java 文件编译成 .class 文件之前，根据我们代码中的 Lombok 注解自动插入对应的 Java 代码，然后才交给编译器编译。因此，它不是在运行时通过反射生成代码。   一、为什么需要 Lombok？在传统的 Java 开发中，尤其是在数据模型类 (POJOs &#x2F; DTOs) 中，我们常常需要编写大量的重复性代码：  Getter 和 Setter：每个字段通常都需要对应的 getter 和 setter 方法。 构造函数：无参构造函数、全参构造函数或部分参数构造函数。 equals() 和 hashCode()：为了正确地比较对象和在集合中存储对象。 toSt...</div></div></div></a><a class="pagination-related" href="/70a4fee407c8/" title="Spring 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-19</div><div class="info-item-2">Spring 框架详解</div></div><div class="info-2"><div class="info-item-1"> Spring Framework 是一个开源的、轻量级的 Java 企业级开发框架，旨在简化企业级应用程序的开发。它提供了一个全面的编程和配置模型，用于构建现代的、基于 Java 的企业应用。Spring 的核心思想是控制反转 (IoC) 和面向切面编程 (AOP)，通过这些机制，它促进了松耦合、模块化、易于测试的代码结构，并提供了对各种技术（如事务管理、Web 应用程序、数据访问、安全性等）的广泛支持。  核心思想：Spring 致力于通过 IoC (控制反转) 机制来管理对象及其依赖关系，实现组件间的松耦合；通过 AOP (面向切面编程) 来分离横切关注点，提高代码的模块化和复用性。它提供了一个强大的容器来管理应用的生命周期，并提供了丰富的模块来支持企业级开发的各个方面。   一、核心理念Spring Framework 的成功建立在两大核心理念之上：控制反转 (Inversion of Control - IoC) 和面向切面编程 (Aspect-Oriented Programming - AOP)。 1.1 控制反转 (Inversion of Control - I...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">489</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%85%B1%E9%80%9A%E6%80%A7"><span class="toc-text">一、基本概念和共通性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Apache-Tomcat"><span class="toc-text">二、Apache Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%9E%B6%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.2 架构特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%80%A7%E8%83%BD%E4%B8%8E%E8%B5%84%E6%BA%90"><span class="toc-text">2.3 性能与资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.4 优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%A4%BA%E4%BE%8B-Spring-Boot"><span class="toc-text">2.5 示例 (Spring Boot)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Eclipse-Jetty"><span class="toc-text">三、Eclipse Jetty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">3.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9E%B6%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-text">3.2 架构特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%80%A7%E8%83%BD%E4%B8%8E%E8%B5%84%E6%BA%90"><span class="toc-text">3.3 性能与资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3.4 优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%A4%BA%E4%BE%8B-Spring-Boot"><span class="toc-text">3.5 示例 (Spring Boot)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Red-Hat-Undertow"><span class="toc-text">四、Red Hat Undertow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">4.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9E%B6%E6%9E%84%E7%89%B9%E7%82%B9"><span class="toc-text">4.2 架构特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%80%A7%E8%83%BD%E4%B8%8E%E8%B5%84%E6%BA%90"><span class="toc-text">4.3 性能与资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4.4 优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%A4%BA%E4%BE%8B-Spring-Boot"><span class="toc-text">4.5 示例 (Spring Boot)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-text">五、对比总结与选择建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">5.1 如何选择？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"/></a><div class="content"><a class="title" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</a><time datetime="2025-12-31T22:24:00.000Z" title="发表于 2026-01-01 06:24:00">2026-01-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-29.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>