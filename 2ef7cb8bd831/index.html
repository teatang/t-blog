<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LangChain Text Splitters 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LangChain Text Splitters 是 LangChain 框架中的一个核心模块，用于将长文档或文本智能地分割成更小、更易于管理和处理的块 (chunks)。这个过程对于大语言模型 (LLM) 相关的应用至关重要，特别是当处理的文本长度超出 LLM 的上下文窗口限制时。  核心思想：将长文本分割成大小适中、语义连贯且包含一定重叠的块，以便 LLM 能够有效处理这些块，同时保持上下文">
<meta property="og:type" content="article">
<meta property="og:title" content="LangChain Text Splitters 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2ef7cb8bd831/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="LangChain Text Splitters 是 LangChain 框架中的一个核心模块，用于将长文档或文本智能地分割成更小、更易于管理和处理的块 (chunks)。这个过程对于大语言模型 (LLM) 相关的应用至关重要，特别是当处理的文本长度超出 LLM 的上下文窗口限制时。  核心思想：将长文本分割成大小适中、语义连贯且包含一定重叠的块，以便 LLM 能够有效处理这些块，同时保持上下文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg">
<meta property="article:published_time" content="2025-11-02T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-30T03:20:58.372Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="LangChain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LangChain Text Splitters 详解",
  "url": "https://blog.tbf1211.xx.kg/2ef7cb8bd831/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg",
  "datePublished": "2025-11-02T22:24:00.000Z",
  "dateModified": "2026-01-30T03:20:58.372Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2ef7cb8bd831/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LangChain Text Splitters 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-31.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">LangChain Text Splitters 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">LangChain Text Splitters 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-11-02T22:24:00.000Z" title="发表于 2025-11-03 06:24:00">2025-11-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">开发框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>LangChain Text Splitters</strong> 是 LangChain 框架中的一个核心模块，用于将长文档或文本智能地分割成更小、更易于管理和处理的块 (chunks)。这个过程对于大语言模型 (LLM) 相关的应用至关重要，特别是当处理的文本长度超出 LLM 的上下文窗口限制时。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将长文本分割成大小适中、语义连贯且包含一定重叠的块，以便 LLM 能够有效处理这些块，同时保持上下文完整性。LangChain 提供多种具有不同策略的 Text Splitters，以适应不同的文本结构和应用场景。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-Text-Splitters？"><a href="#一、为什么需要-Text-Splitters？" class="headerlink" title="一、为什么需要 Text Splitters？"></a>一、为什么需要 Text Splitters？</h2><p>在构建基于 LLM 的应用程序（尤其是问答 RAG (Retrieval Augmented Generation) 系统、文档摘要、聊天机器人等）时，我们经常遇到以下问题：</p>
<ol>
<li><strong>LLM 上下文窗口限制 (Context Window Limit)</strong>：大语言模型（如 GPT-3.5, GPT-4, Llama）通常有一个固定的最大输入长度。如果输入文本太长，会超出这个限制，导致模型无法处理。</li>
<li><strong>性能和成本</strong>：即使模型支持很长的上下文窗口，处理非常长的文本也会显著增加推理时间、降低效率，并提高 API 调用成本。</li>
<li><strong>信息密度和噪音</strong>：过长的文本可能包含大量无关信息，稀释了关键上下文，从而降低 LLM 响应的质量。</li>
<li><strong>分块检索 (Chunking for Retrieval)</strong>：在 RAG 系统中，我们需要在向量数据库中存储文档的小块，以便在接收到用户查询时，能够快速准确地检索到最相关的、大小合适的文本片段，而不是整个冗长的文档。</li>
<li><strong>语义完整性</strong>：简单地按固定字符数截断文本会破坏句子、段落甚至代码块的语义完整性，导致 LLM 无法理解片段的真实含义。</li>
</ol>
<p>Text Splitters 的目标就是以一种智能的方式解决这些问题，确保每个文本块：</p>
<ul>
<li><strong>大小合适</strong>：符合 LLM 的上下文窗口或 embedding 模型的输入限制。</li>
<li><strong>语义连贯</strong>：尽量不切断一个完整的句子或段落，避免破坏上下文。</li>
<li><strong>包含重叠</strong>：通过块之间的重叠 (overlap)，在块边界处提供额外的上下文，避免关键信息被切断在两个不相关的块之间。</li>
</ul>
<h2 id="二、Text-Splitters-的核心策略"><a href="#二、Text-Splitters-的核心策略" class="headerlink" title="二、Text Splitters 的核心策略"></a>二、Text Splitters 的核心策略</h2><p>LangChain 的 Text Splitters 通常遵循以下核心策略：</p>
<ol>
<li><p><strong>基于分隔符 (Delimiter-based Splitting)</strong>：</p>
<ul>
<li><strong>概念</strong>：尝试使用一组预定义的分隔符（如换行符 <code>\n\n</code>, <code>\n</code>, 空格 <code> </code>）来切割文本。</li>
<li><strong>优先级</strong>：通常会尝试从更强烈的语义分隔符（如段落分隔符）开始，逐级向下尝试更细粒度的分隔符，直到满足块大小要求。</li>
<li><strong>优点</strong>：能较好地保留语义结构。</li>
<li><strong>缺点</strong>：如果分隔符不存在或分隔符旁边的文本过长，仍然可能需要进一步切割长段落。</li>
</ul>
</li>
<li><p><strong>字符计数 (Character Counting)</strong>：</p>
<ul>
<li><strong>概念</strong>：指定每个块的最大字符数 (<code>chunk_size</code>)。</li>
<li><strong>优点</strong>：简单直接。</li>
<li><strong>缺点</strong>：可能在句子或词语中间强行截断，破坏语义。</li>
</ul>
</li>
<li><p><strong>重叠 (Overlapping Chunks)</strong>：</p>
<ul>
<li><strong>概念</strong>：在切割文本时，让相邻的块之间共享一部分文本 (<code>chunk_overlap</code>)。</li>
<li><strong>作用</strong>：<ul>
<li><strong>保留上下文</strong>：当一个概念或句子跨越两个块的边界时，重叠部分可以帮助模型从两个块中都能获取到相关上下文。</li>
<li><strong>提高召回率</strong>：在 RAG 场景中，即使查询只命中了一个块的重叠部分，也能帮助找到完整的语义块。</li>
</ul>
</li>
<li><strong>重要性</strong>：一个良好定义的 <code>chunk_overlap</code> 对于 RAG 系统至关重要。</li>
</ul>
</li>
</ol>
<h3 id="关键参数："><a href="#关键参数：" class="headerlink" title="关键参数："></a>关键参数：</h3><ul>
<li><code>chunk_size</code>：每个文本块的最大长度（通常以字符数或token数计）。</li>
<li><code>chunk_overlap</code>：相邻文本块之间的重叠长度。</li>
<li><code>separator</code>：用于分割文本的字符串或字符串列表。</li>
<li><code>length_function</code>：一个自定义函数，用于计算文本块的长度（默认是 <code>len</code> 计算字符数，也可以用 <code>tokenizer.encode</code> 计算 token 数）。</li>
</ul>
<h2 id="三、LangChain-提供的主要-Text-Splitters"><a href="#三、LangChain-提供的主要-Text-Splitters" class="headerlink" title="三、LangChain 提供的主要 Text Splitters"></a>三、LangChain 提供的主要 Text Splitters</h2><p>LangChain 提供了多种 Text Splitters，每种都有其特定的设计目的和最佳实践。<br>安装<code>langchain-text-splitters</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U langchain-text-splitters</span><br></pre></td></tr></table></figure>

<h3 id="3-1-RecursiveCharacterTextSplitter"><a href="#3-1-RecursiveCharacterTextSplitter" class="headerlink" title="3.1 RecursiveCharacterTextSplitter"></a>3.1 <code>RecursiveCharacterTextSplitter</code></h3><p>这是 LangChain 中<strong>最通用、最推荐</strong>的文本分割器。它会递归地尝试使用一组分隔符进行分割。</p>
<ul>
<li><strong>工作原理</strong>：它维护一个分隔符列表（例如：<code>[&quot;\n\n&quot;, &quot;\n&quot;, &quot; &quot;, &quot;&quot;]</code>）。<ol>
<li>首先尝试使用第一个分隔符分割文本。</li>
<li>如果分割后的任一文本块仍然超过 <code>chunk_size</code>，则对该长块递归地使用下一个分隔符进行分割。</li>
<li>如果所有分隔符都尝试过了，并且块仍然过长，它会回退到按字符进行分割。</li>
</ol>
</li>
<li><strong>优点</strong>：灵活且智能，能够很好地保持文本的语义结构。</li>
<li><strong>适用场景</strong>：绝大多数通用文本，如文章、报告、书籍等。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">LangChain 是一个强大的框架，用于开发基于大语言模型的应用程序。</span></span><br><span class="line"><span class="string">它提供了构建LLM应用的模块化组件。这些应用包括问答、摘要、聊天机器人等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用LangChain，我们可以轻松地将大型复杂文档分割成小块。</span></span><br><span class="line"><span class="string">这对于将文档嵌入到向量数据库中进行检索增强生成（RAG）至关重要。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">例如，一个长篇研究报告可能包含多个章节和段落。</span></span><br><span class="line"><span class="string">如果我们不进行智能分割，直接将整个报告输入给LLM，可能会超出其上下文窗口限制。</span></span><br><span class="line"><span class="string">而RecursiveCharacterTextSplitter能够优雅地处理这类问题。它会优先根据段落、句子进行分割，并考虑重叠。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化分割器</span></span><br><span class="line">splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    chunk_size=<span class="number">100</span>,  <span class="comment"># 每个块的最大字符数</span></span><br><span class="line">    chunk_overlap=<span class="number">20</span>, <span class="comment"># 块之间的重叠字符数</span></span><br><span class="line">    separators=[<span class="string">&quot;\n\n&quot;</span>, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>] <span class="comment"># 默认分隔符，可以自定义</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割文本</span></span><br><span class="line">chunks = splitter.split_text(text)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;原始文本长度: <span class="subst">&#123;<span class="built_in">len</span>(text)&#125;</span> 字符&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;分割成 <span class="subst">&#123;<span class="built_in">len</span>(chunks)&#125;</span> 个块&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, chunk <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunks):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- 块 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> (长度: <span class="subst">&#123;<span class="built_in">len</span>(chunk)&#125;</span>) ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-CharacterTextSplitter"><a href="#3-2-CharacterTextSplitter" class="headerlink" title="3.2 CharacterTextSplitter"></a>3.2 <code>CharacterTextSplitter</code></h3><p>最基础的分割器。它只使用一个指定的字符作为分隔符，如果分隔后块仍然过大，会直接在任意位置截断。</p>
<ul>
<li><strong>工作原理</strong>：首先根据一个指定的 <code>separator</code> 进行分割。然后，如果任何一个分割后的块超过 <code>chunk_size</code>，它会将其直接截断为多个块。</li>
<li><strong>优点</strong>：简单，易于理解和控制。</li>
<li><strong>缺点</strong>：如果 <code>separator</code> 没有有效地分割文本，可能导致语义被破坏。</li>
<li><strong>适用场景</strong>：当你知道文本结构非常规则，例如每行都是一个独立记录时。通常不推荐用于通用文本。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;这是一段非常长的文本。它没有任何换行符或段落分隔。所以我们看它如何被切割。&quot;</span></span><br><span class="line"></span><br><span class="line">splitter = CharacterTextSplitter(</span><br><span class="line">    separator=<span class="string">&quot;。&quot;</span>, <span class="comment"># 以句号作为分隔符</span></span><br><span class="line">    chunk_size=<span class="number">20</span>,</span><br><span class="line">    chunk_overlap=<span class="number">5</span>,</span><br><span class="line">    length_function=<span class="built_in">len</span>,</span><br><span class="line">    is_separator_regex=<span class="literal">False</span>, <span class="comment"># 分隔符是否是正则表达式</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chunks = splitter.split_text(text)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;分割成 <span class="subst">&#123;<span class="built_in">len</span>(chunks)&#125;</span> 个块&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, chunk <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunks):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- 块 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> (长度: <span class="subst">&#123;<span class="built_in">len</span>(chunk)&#125;</span>) ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-TokenTextSplitter"><a href="#3-3-TokenTextSplitter" class="headerlink" title="3.3 TokenTextSplitter"></a>3.3 <code>TokenTextSplitter</code></h3><p>将文本分割成由模型 token 长度控制的块，而不是字符长度。</p>
<ul>
<li><strong>工作原理</strong>：使用预训练模型的<code>tokenizer</code>来计算文本的长度，确保每个块的 token 数量不超过 <code>chunk_size</code> 的限制。</li>
<li><strong>优点</strong>：更精确地匹配 LLM 或 Embedding 模型的输入限制，因为它们通常以 token 而非字符进行计数。</li>
<li><strong>缺点</strong>：需要加载一个 tokenizer，可能引入额外的依赖。</li>
<li><strong>适用场景</strong>：当你的 <code>chunk_size</code> 严格指代 token 数量，且需要精准控制 token 长度时。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> TokenTextSplitter</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer <span class="comment"># 使用Hugging Face tokenizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载一个Hugging Face tokenizer</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;BEEGYM/bge-small-zh-v1.5&quot;</span>) <span class="comment"># 示例，可以换成你用的embedding模型对应的tokenizer</span></span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;这是使用 token 长度而不是字符长度进行切割的例子。它能够更精确地控制每个文本块的大小。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个长度函数，使用tokenizer计算token数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_tokens</span>(<span class="params">text: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(tokenizer.encode(text))</span><br><span class="line"></span><br><span class="line">splitter = TokenTextSplitter(</span><br><span class="line">    chunk_size=<span class="number">10</span>, <span class="comment"># 每个块的最大token数</span></span><br><span class="line">    chunk_overlap=<span class="number">2</span>, <span class="comment"># 块之间重叠的token数</span></span><br><span class="line">    encoding_name=<span class="string">&quot;cl100k_base&quot;</span> <span class="comment"># OpenAI tokenizers使用的编码名称，仅用于OAI模型</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 注意：TokenTextSplitter默认使用ticktoken库，对于其他模型需要传递自定义length_function。</span></span><br><span class="line"><span class="comment"># 或者直接使用 RecursiveCharacterTextSplitter 并传入自定义length_function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于通用HuggingFace tokenizer，更推荐以下方式结合RecursiveCharacterTextSplitter</span></span><br><span class="line">splitter_with_hf_tokenizer = RecursiveCharacterTextSplitter(</span><br><span class="line">    chunk_size=<span class="number">20</span>, <span class="comment"># 字符数 (或其他长度单位，取决于length_function)</span></span><br><span class="line">    chunk_overlap=<span class="number">5</span>,</span><br><span class="line">    length_function=count_tokens, <span class="comment"># 使用自定义的token长度函数</span></span><br><span class="line">    separators=[<span class="string">&quot;。&quot;</span>, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">chunks_hf = splitter_with_hf_tokenizer.split_text(text)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;原始文本的token长度: <span class="subst">&#123;count_tokens(text)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;分割成 <span class="subst">&#123;<span class="built_in">len</span>(chunks_hf)&#125;</span> 个块 (由Hugging Face tokenizer计数)&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, chunk <span class="keyword">in</span> <span class="built_in">enumerate</span>(chunks_hf):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- 块 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> (长度: <span class="subst">&#123;count_tokens(chunk)&#125;</span> tokens) ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(chunk)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-HTMLHeaderTextSplitter"><a href="#3-4-HTMLHeaderTextSplitter" class="headerlink" title="3.4 HTMLHeaderTextSplitter"></a>3.4 <code>HTMLHeaderTextSplitter</code></h3><p>专门用于解析 HTML 文档，并根据 HTML 标题标签（如 <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>）进行分割，同时保留标题信息。</p>
<ul>
<li><strong>工作原理</strong>：它会解析 HTML 结构，并根据你提供的标题标签 (如 <code>h1</code>, <code>h2</code>, <code>h3</code>) 作为分隔符。分割后的块会自动将相关的标题信息作为元数据包含进来。</li>
<li><strong>优点</strong>：非常适合结构化的 HTML 文档，能更好地捕获语义层次。</li>
<li><strong>适用场景</strong>：网页内容、Markdown 转换的 HTML 文档等。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> TextLoader</span><br><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> HTMLHeaderTextSplitter</span><br><span class="line"></span><br><span class="line">html_document = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Llamas&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Llamas are members of the camelid family native to South America.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Description&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;They are well-known for their wool and as pack animals.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;h3&gt;Size and Weight&lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Adult llamas typically stand 1.7 to 1.8 meters (5.6 to 5.9 ft) tall at the top of the head.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;Habitat&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Llamas are found in the Andes mountains.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要分割的标题标签及其级别</span></span><br><span class="line">headers_to_split_on = [</span><br><span class="line">    (<span class="string">&quot;h1&quot;</span>, <span class="string">&quot;Header 1&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;h2&quot;</span>, <span class="string">&quot;Header 2&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;h3&quot;</span>, <span class="string">&quot;Header 3&quot;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">html_splitter = HTMLHeaderTextSplitter(headers_to_split_on=headers_to_split_on)</span><br><span class="line"></span><br><span class="line">docs = html_splitter.split_text(html_document)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;分割成 <span class="subst">&#123;<span class="built_in">len</span>(docs)&#125;</span> 个文档块&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, doc <span class="keyword">in</span> <span class="built_in">enumerate</span>(docs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- 文档块 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;内容:\n<span class="subst">&#123;doc.page_content[:<span class="number">100</span>]&#125;</span>...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;元数据: <span class="subst">&#123;doc.metadata&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-5-MarkdownHeaderTextSplitter"><a href="#3-5-MarkdownHeaderTextSplitter" class="headerlink" title="3.5 MarkdownHeaderTextSplitter"></a>3.5 <code>MarkdownHeaderTextSplitter</code></h3><p>类似 <code>HTMLHeaderTextSplitter</code>，但专门用于 Markdown 文档，根据 Markdown 标题 (<code>#</code>, <code>##</code>) 进行分割。</p>
<ul>
<li><strong>工作原理</strong>：解析 Markdown 语法，使用 Markdown 标题作为分隔符。</li>
<li><strong>优点</strong>：适用于Markdown文档，能保持其结构。</li>
<li><strong>适用场景</strong>：GitHub README、技术文档、博客文章等 Markdown 格式内容。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_text_splitters <span class="keyword">import</span> MarkdownHeaderTextSplitter</span><br><span class="line"></span><br><span class="line">markdown_document = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># LangChain 中的文本分割器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 为什么需要文本分割器？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*   LLM上下文窗口限制</span></span><br><span class="line"><span class="string">*   性能和成本</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 主要文本分割器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### RecursiveCharacterTextSplitter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这是最推荐的一个。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### MarkdownHeaderTextSplitter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">专门用于Markdown文件。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">headers_to_split_on = [</span><br><span class="line">    (<span class="string">&quot;#&quot;</span>, <span class="string">&quot;Header1&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;##&quot;</span>, <span class="string">&quot;Header2&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;###&quot;</span>, <span class="string">&quot;Header3&quot;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">markdown_splitter = MarkdownHeaderTextSplitter(headers_to_split_on=headers_to_split_on)</span><br><span class="line"></span><br><span class="line">docs = markdown_splitter.split_text(markdown_document)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;分割成 <span class="subst">&#123;<span class="built_in">len</span>(docs)&#125;</span> 个文档块&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i, doc <span class="keyword">in</span> <span class="built_in">enumerate</span>(docs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- 文档块 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;内容:\n<span class="subst">&#123;doc.page_content.strip()&#125;</span>...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;元数据: <span class="subst">&#123;doc.metadata&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h3 id="其他-Text-Splitters"><a href="#其他-Text-Splitters" class="headerlink" title="其他 Text Splitters:"></a>其他 Text Splitters:</h3><ul>
<li><strong><code>Language</code> 特定分割器</strong>：如 <code>PythonCodeTextSplitter</code>, <code>JSCodeTextSplitter</code> 等，它们针对特定编程语言的代码结构进行分割，例如按函数、类定义分割，这对于代码理解和生成任务非常有用。</li>
<li><strong><code>SemanticChunker</code></strong>：一种更高级的、基于嵌入和聚类的方法，旨在根据语义相似性而不是简单的分隔符来分割文本。这可以创建出语义上更连贯的块，但计算成本也更高。</li>
</ul>
<h2 id="四、选择合适的-Text-Splitter"><a href="#四、选择合适的-Text-Splitter" class="headerlink" title="四、选择合适的 Text Splitter"></a>四、选择合适的 Text Splitter</h2><p>选择正确的 Text Splitter 对于 RAG 系统的性能至关重要。以下是一些指导原则：</p>
<ol>
<li><strong>了解你的文本结构</strong>：<ul>
<li><strong>通用散文 (文章、报告)</strong>：<code>RecursiveCharacterTextSplitter</code> 是首选。</li>
<li><strong>HTML&#x2F;XML 文档</strong>：<code>HTMLHeaderTextSplitter</code>。</li>
<li><strong>Markdown 文档</strong>：<code>MarkdownHeaderTextSplitter</code>。</li>
<li><strong>代码文件</strong>：<code>PythonCodeTextSplitter</code> 等 <code>Language</code> 特定分割器。</li>
<li><strong>高度结构化，且知道固定分隔符</strong>：<code>CharacterTextSplitter</code> (配合合适的 <code>separator</code>)。</li>
</ul>
</li>
<li><strong>考虑 LLM 或 Embedding 模型的输入限制</strong>：<ul>
<li><code>chunk_size</code> 应该根据你的下游模型（LLM 或 Embedding 模型）的上下文窗口和性能要求来设定。通常，Embedding 模型的输入限制比 LLM 小。</li>
<li>如果需要严格控制 Token 数，可以结合 <code>length_function</code> 自定义 token 计数器。</li>
</ul>
</li>
<li><strong>合理设置 <code>chunk_overlap</code></strong>：<ul>
<li><code>chunk_overlap</code> 通常设置为 <code>chunk_size</code> 的 10%-20% 左右。过小的重叠可能导致上下文丢失，过大的重叠会增加冗余和计算成本。</li>
<li>对于非常概念密集型或语义关联紧密的文本，可以适当增加重叠。</li>
</ul>
</li>
<li><strong>实验和评估</strong>：<ul>
<li>没有通用的“最佳”分割器和参数组合。针对你的具体数据和任务，进行实验和评估至关重要。</li>
<li>可以通过查看分割后的块、进行问答测试、或衡量 RAG 系统的召回率和准确率来评估效果。</li>
</ul>
</li>
</ol>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>LangChain 的 Text Splitters 模块为处理长文本数据提供了强大而灵活的解决方案。通过智能地将长文档分解为适宜大小、语义连贯且具有良好重叠的块，它们能够有效克服 LLM 的上下文窗口限制，优化 RAG 系统的检索效率和质量。</p>
<p>理解不同 Text Splitters 的工作原理、适用场景以及 <code>chunk_size</code> 和 <code>chunk_overlap</code> 等关键参数的设置，是构建高性能 LLM 应用，特别是 RAG 系统的基石。在实际开发中，应根据文本的特点和具体的应用需求，选择最合适的分割策略，并通过迭代和评估来优化分割效果。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2ef7cb8bd831/">https://blog.tbf1211.xx.kg/2ef7cb8bd831/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/AI/">AI</a><a class="post-meta__tags" href="/tags/LLM/">LLM</a><a class="post-meta__tags" href="/tags/LangChain/">LangChain</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Claude Code 详解：Anthropic 的代码智能模型</div></div><div class="info-2"><div class="info-item-1"> Claude Code 是 Anthropic 公司推出的官方 CLI 工具，专为软件工程设计。它将 Claude 的强大 AI 能力带入终端，帮助开发者完成代码编写、调试、重构、测试等各类编程任务。作为一款专业的 AI 编程助手，Claude Code 特别强调安全性，仅协助处理授权的安全测试、CTF 挑战等合法场景。  核心特性：Claude Code 通过自然语言对话完成复杂编程任务，支持多文件编辑、智能体任务、代码库探索等功能，是提升开发效率的利器。    一、Claude Code 概述1.1 什么是 Claude Code？Claude Code 是 Anthropic 推出的官方命令行界面 (CLI) 工具，它将 Claude AI 模型的能力带入开发者的终端环境。与传统的代码补全工具不同，Claude Code 是一个完整的 AI 编程助手，能够理解项目上下文、执行复杂任务、与文件系统交互，并生成高质量的代码。 作为 Claude Agent SDK 的官方实现，Claude Code 采用了专业的软件工程方法论，强调：  安全性优先：仅协助授权的安全测试和防御...</div></div></div></a><a class="pagination-related" href="/a92b9122509b/" title="Ubuntu UFW (Uncomplicated Firewall) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Ubuntu UFW (Uncomplicated Firewall) 详解</div></div><div class="info-2"><div class="info-item-1"> UFW (Uncomplicated Firewall) 是 Ubuntu Linux 及其衍生发行版中一个简化且易于使用的防火墙配置工具。它作为 iptables 的前端，提供了一个用户友好的命令行界面，让普通用户和系统管理员能够更轻松地管理 Linux 内核的 Netfilter 防火墙规则。UFW 的目标是“不复杂”，即简化防火墙的管理，使其不再令人生畏。  核心思想： UFW 提供了一种高级抽象，将复杂的 iptables 命令封装成少数直观的指令，使得用户无需深入理解 iptables 规则链即可实现基本的防火墙配置。   一、为什么选择 UFW？Linux 系统内置了强大的 Netfilter 框架和 iptables 工具，但 iptables 的语法复杂，规则众多，对于初学者来说学习曲线陡峭。UFW 旨在解决以下问题：  简化防火墙管理：  易于上手：通过简单的命令即可配置常见的防火墙规则，无需掌握复杂的 iptables 语法。 减少错误：简化后的命令减少了因语法错误导致配置失误的风险。   增强系统安全性：  默认拒绝策略：UFW 默认采用“默认拒绝所有传入...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/fdb8a5195f3e/" title="知识图谱 (Knowledge Graph) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-09</div><div class="info-item-2">知识图谱 (Knowledge Graph) 详解</div></div><div class="info-2"><div class="info-item-1"> 知识图谱 (Knowledge Graph, KG) 是一种结构化的知识表示形式，它以图 (Graph) 的形式来描述客观世界中存在的各种实体 (Entities)、概念 (Concepts) 及其之间的关系 (Relations)。通过将离散、异构的信息链接起来，知识图谱构建了一个庞大且相互关联的“知识网络”，使得机器能够像人类一样理解、组织和利用知识，从而支持复杂的推理和智能应用。  核心思想：将现实世界的知识抽象为“实体-关系-实体”或“实体-属性-属性值”的三元组结构，并通过图的形式直观地表示和存储这些知识，从而实现知识的机器可读、可理解和可推理。 它旨在解决传统关系型数据库在表示复杂、动态、多源异构数据时存在的语义鸿沟问题。   一、知识图谱的基本构成知识图谱的核心是其图结构中的基本元素：  实体 (Entities)  定义：指现实世界中具有明确指代和区分度的“事物”或“概念”，可以是具象的（如“苹果公司”、“埃菲尔铁塔”、“约翰·F·肯尼迪”）或抽象的（如“人工智能”、“经济学”、“创新”）。 表示：在知识图谱中，每个实体通常有一个唯一的标识符 (URI&#x2F...</div></div></div></a><a class="pagination-related" href="/c1c3c8b5b003/" title="LangChain Model I&#x2F;O 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-13</div><div class="info-item-2">LangChain Model I&#x2F;O 详解</div></div><div class="info-2"><div class="info-item-1"> LangChain Model I&#x2F;O 是 LangChain 框架的核心组成部分之一，它提供了一套标准化的接口和工具，用于与各种大型语言模型 (LLMs) 和聊天模型 (Chat Models) 进行交互，并对其输入和输出进行有效的管理和结构化。这是构建任何基于 LLM 的应用程序的基础。  核心思想：将与 LLM 的“对话”分解为可管理、可组合的组件：输入 (Prompt Templates)、模型调用 (LLM&#x2F;Chat Models) 和输出处理 (Output Parsers)。   一、为什么 Model I&#x2F;O 至关重要？在没有 LangChain Model I&#x2F;O 的情况下，直接与 LLM 交互通常意味着：  手动拼接 Prompt: 需要手动构建复杂的字符串，其中包含指令、上下文、示例和用户输入。这既繁琐又容易出错。 硬编码模型调用: 每次更换模型或供应商时，都需要修改底层代码。 非结构化的输出: LLM 的原始输出通常是自由文本，需要编写复杂的字符串解析逻辑来提取所需信息。 缺乏可复用性: 不同应用场景下的 Prom...</div></div></div></a><a class="pagination-related" href="/e9adc93372f4/" title="LangChain Expression Language (LCEL) 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-29</div><div class="info-item-2">LangChain Expression Language (LCEL) 深度详解</div></div><div class="info-2"><div class="info-item-1"> LangChain Expression Language (LCEL) 是 LangChain 框架中一种强大、灵活且声明式的编程范式，用于构建和编排复杂的链 (Chains) 和代理 (Agents)。它提供了一种简洁、易读且高性能的方式来组合 LangChain 的各种组件（如提示模板、大语言模型、输出解析器、检索器、自定义函数等），从而构建出端到端的 LLM 应用程序。  核心思想：LCEL 的核心在于提供一个统一的 Runnable 接口和管道操作符 (|)，允许开发者以类似 Unix 管道的方式将不同的组件连接起来。这种声明式组合方式不仅提高了代码的可读性和可维护性，还带来了自动化的并行处理、流式传输、异步支持、类型安全以及与 LangSmith 等调试工具的深度集成等诸多优势。   一、为什么选择 LCEL？在 LCEL 出现之前，LangChain 主要通过传统的 Chain 类来构建应用程序。虽然这些 Chain 也有效，但 LCEL 解决了它们的一些局限性，并带来了显著的改进：  更简洁的语法和可读性：LCEL 使用管道操作符 (|)，使得链式调用直观，像数...</div></div></div></a><a class="pagination-related" href="/51de73c05326/" title="LangGraph 库核心组件与调用方法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-15</div><div class="info-item-2">LangGraph 库核心组件与调用方法详解</div></div><div class="info-2"><div class="info-item-1"> LangGraph 是 LangChain 生态系统中的一个高级库，它允许开发者使用有向无环图 (DAG) 的方式构建健壮、有状态且可控的 LLM 应用。它特别适用于需要多步骤推理、代理 (Agent) 行为、循环和人工干预的复杂工作流。LangGraph 的核心优势在于其明确的状态管理和对图结构的直接建模能力，使得构建和调试复杂代理系统变得更加直观和可靠。  核心思想：将多步骤的 LLM 应用程序建模为状态机，其中每个节点代表一个操作（LLM 调用、工具调用、函数等），边代表状态转换。通过在节点之间传递和修改状态，实现复杂、有循环的工作流。它解决了传统 LangChain Chain 在处理复杂逻辑（特别是循环和条件分支）时的局限性。    一、LangGraph 核心概念LangGraph 的设计基于图论和状态机的思想。理解以下核心概念是使用 LangGraph 的基础：  State (状态)：  表示整个应用程序在某个时间点的数据快照。 通过 StateDict 对象传递，它是一个字典或类似字典的结构。 节点操作通常会接收当前状态，并返回一个表示状态更新的 StateD...</div></div></div></a><a class="pagination-related" href="/3201b8057954/" title="LangChain 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-12</div><div class="info-item-2">LangChain 详解</div></div><div class="info-2"><div class="info-item-1"> LangChain 是一个用于开发由大型语言模型 (LLMs) 驱动的应用程序的框架。它提供了一套模块化、灵活的工具和抽象，使得开发者能够将 LLMs 与外部数据源、计算逻辑以及其他工具进行结合，从而构建出更复杂、更强大的应用程序。LangChain 的核心思想是链式化 (Chaining) 不同的组件，以实现复杂的逻辑。  核心思想：将大型语言模型 (LLMs) 的能力与其他数据源和计算逻辑解耦、模块化，并通过链 (Chains)、代理 (Agents) 等机制进行编排，以创建高度智能且可扩展的应用程序。 Python 作为 AI 和数据科学领域的主流语言，提供了功能全面且易于使用的 LangChain 库实现。   一、LangChain 核心概念与组件LangChain 的设计是围绕一系列可组合的抽象组件构建的，这些组件可以独立使用，也可以通过“链”的方式连接起来，形成复杂的工作流。以下是 LangChain 的主要核心组件：  Models (模型)：与各种大型语言模型 (LLMs) 进行交互的接口。 LLMs (Large Language Models)：用于文本生...</div></div></div></a><a class="pagination-related" href="/aacac0039d65/" title="LangChain Chains 深度详解与应用实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-30</div><div class="info-item-2">LangChain Chains 深度详解与应用实践</div></div><div class="info-2"><div class="info-item-1"> LangChain 是一个强大的框架，旨在帮助开发者使用大语言模型（LLM）构建端到端的应用程序。在其众多核心模块中，Chains (链) 是最基础也是最重要的概念之一。它允许开发者将多个组件（如 LLM、提示模板、解析器、其他链）以逻辑顺序连接起来，形成一个完整的、可执行的流程，从而实现复杂的任务。  核心思想：Chains 的核心思想是将一系列操作（比如准备提示、调用 LLM、处理输出）串联起来，形成一个连贯的工作流。这使得开发者能够构建超越单一 LLM 调用的复杂应用程序，实现模块化、可组合和可扩展的 AI 应用。   一、为什么需要 Chains？大语言模型 (LLM) 固然强大，但直接调用 LLM 的 API 往往只能解决单一的、相对简单的问题。在实际应用中，我们面临的任务通常更加复杂：  多步骤任务：一个任务可能需要多次调用 LLM，每次调用基于上一次的输出。 输入预处理：可能需要根据用户输入动态地生成 LLM 提示。 输出后处理：LLM 的原始输出可能需要结构化、格式化或进一步处理才能使用。 数据检索：LLM 可能需要结合外部数据源（如数据库、文档）才能给出准确答...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Text-Splitters%EF%BC%9F"><span class="toc-text">一、为什么需要 Text Splitters？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Text-Splitters-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5"><span class="toc-text">二、Text Splitters 的核心策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">关键参数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81LangChain-%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%BB%E8%A6%81-Text-Splitters"><span class="toc-text">三、LangChain 提供的主要 Text Splitters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-RecursiveCharacterTextSplitter"><span class="toc-text">3.1 RecursiveCharacterTextSplitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-CharacterTextSplitter"><span class="toc-text">3.2 CharacterTextSplitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-TokenTextSplitter"><span class="toc-text">3.3 TokenTextSplitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-HTMLHeaderTextSplitter"><span class="toc-text">3.4 HTMLHeaderTextSplitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-MarkdownHeaderTextSplitter"><span class="toc-text">3.5 MarkdownHeaderTextSplitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-Text-Splitters"><span class="toc-text">其他 Text Splitters:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84-Text-Splitter"><span class="toc-text">四、选择合适的 Text Splitter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-31.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>