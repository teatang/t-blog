<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="BBR (Bottleneck Bandwidth and Round-trip Propagation Time) 是由 Google 开发的一种 TCP 拥塞控制算法。与传统的基于丢包的拥塞控制算法（如 Cubic, Reno）不同，BBR 专注于测量网络瓶颈带宽 (Bottleneck Bandwidth) 和往返传播时间 (Round-trip Propagation Time)，并以此">
<meta property="og:type" content="article">
<meta property="og:title" content="BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/f19c839c8b2e/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="BBR (Bottleneck Bandwidth and Round-trip Propagation Time) 是由 Google 开发的一种 TCP 拥塞控制算法。与传统的基于丢包的拥塞控制算法（如 Cubic, Reno）不同，BBR 专注于测量网络瓶颈带宽 (Bottleneck Bandwidth) 和往返传播时间 (Round-trip Propagation Time)，并以此">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg">
<meta property="article:published_time" content="2023-12-06T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-18T06:51:26.826Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="代理协议">
<meta property="article:tag" content="拥塞控制算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解",
  "url": "https://blog.tbf1211.xx.kg/f19c839c8b2e/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg",
  "datePublished": "2023-12-06T22:24:00.000Z",
  "dateModified": "2025-12-18T06:51:26.826Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/f19c839c8b2e/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">388</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">213</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">76</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-12-06T22:24:00.000Z" title="发表于 2023-12-07 06:24:00">2023-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE/">代理协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/f19c839c8b2e/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>BBR (Bottleneck Bandwidth and Round-trip Propagation Time)</strong> 是由 Google 开发的一种 TCP 拥塞控制算法。与传统的基于丢包的拥塞控制算法（如 Cubic, Reno）不同，BBR 专注于<strong>测量网络瓶颈带宽 (Bottleneck Bandwidth) 和往返传播时间 (Round-trip Propagation Time)</strong>，并以此为基础来控制发送速率，旨在达到高吞吐量和低延迟的最佳平衡。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>基于带宽和 RTT 测量，而不是丢包，来探知网络的实际容量，从而更精准地控制发送速率，避免不必要的丢包，并充分利用带宽。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-BBR？"><a href="#一、为什么需要-BBR？" class="headerlink" title="一、为什么需要 BBR？"></a>一、为什么需要 BBR？</h2><p>传统的 TCP 拥塞控制算法（如 Cubic、Reno）主要依赖于<strong>丢包</strong>作为网络拥塞的信号。它们的工作原理是：</p>
<ol>
<li>不断增加发送窗口，直到出现丢包。</li>
<li>丢包发生后，认为网络拥塞，降低发送窗口。</li>
<li>循环往复，形成“锯齿状”的发送速率。</li>
</ol>
<p>这种基于丢包的机制存在以下问题：</p>
<ol>
<li>“<strong>缓冲区膨胀” (Bufferbloat)</strong>：<ul>
<li>现代网络设备通常拥有较大的缓冲区。当网络开始拥塞时，数据包不会立即被丢弃，而是先在这些缓冲区中排队。</li>
<li>传统的 TCP 算法会继续填充这些缓冲区，导致队列越来越长，从而显著增加数据包的<strong>延迟 (latency)</strong>。虽然最终没有丢包，但用户体验却变差了。</li>
<li>只有当缓冲区完全填满后，数据包才会被丢弃，此时传统算法才感知到拥塞。</li>
</ul>
</li>
<li><strong>不公平竞争</strong>：在某些场景下，丢包率高但实际带宽充足的网络中，传统算法会过早地降低发送速率，导致带宽利用率不足。</li>
<li><strong>对新型网络适应性差</strong>：传统算法在低丢包、高带宽、长延迟的网络（如数据中心内部、跨洋光纤）中表现不佳。</li>
</ol>
<p>BBR 旨在解决这些问题，它将拥塞的信号从<strong>丢包</strong>转换为<strong>更高的 RTT (round-trip time 往返时间)</strong> 和<strong>更低的带宽利用率</strong>。</p>
<h2 id="二、BBR-的核心概念与原理"><a href="#二、BBR-的核心概念与原理" class="headerlink" title="二、BBR 的核心概念与原理"></a>二、BBR 的核心概念与原理</h2><p>BBR 的核心在于持续动态地估计网络的两个关键参数：</p>
<ol>
<li><strong>瓶颈带宽 (Bottleneck Bandwidth, <code>BtlBw</code>)</strong>：<ul>
<li>路径上最慢链路的实际传输速率。VBR 通过测量发送的数据量和传输这些数据所需的时间来估算。它不是瞬时带宽，而是持续一段时间内的最大传输速率。</li>
</ul>
</li>
<li><strong>往返传播时间 (Round-trip Propagation Time, <code>RTT_min</code>)</strong>：<ul>
<li>路径上数据包的最小往返时间，不包含排队延迟。这是纯粹的信号传输时间。</li>
</ul>
</li>
</ol>
<p>BBR 的目标是将发送速率调整到 <code>BtlBw</code>，同时保持在 <code>RTT_min</code> 附近，以避免在网络缓冲区中排队，从而实现高吞吐量和低延迟。</p>
<h3 id="2-1-BBR-的数学模型-理论发送限制"><a href="#2-1-BBR-的数学模型-理论发送限制" class="headerlink" title="2.1 BBR 的数学模型 (理论发送限制)"></a>2.1 BBR 的数学模型 (理论发送限制)</h3><p>根据网络流量控制的经典模型，一个TCP连接在理想状态下，其在途数据量（<code>Inflight</code>）应等于 <code>BtlBw * RTT_min</code>，这被称为<strong>带宽延迟积 (Bandwidth-Delay Product, BDP)</strong>。</p>
<ul>
<li>如果 <code>Inflight &lt; BDP</code>：连接并没有完全利用带宽，发送窗口可以增加。</li>
<li>如果 <code>Inflight &gt; BDP</code>：连接将导致排队延迟增加，可能会导致拥塞，发送窗口应该减小。</li>
</ul>
<p>BBR 就是根据实时测量到的 <code>BtlBw</code> 和 <code>RTT_min</code> 来动态地维持 <code>Inflight</code> 接近 <code>BDP</code>。</p>
<h3 id="2-2-BBR-的四个阶段-Probe"><a href="#2-2-BBR-的四个阶段-Probe" class="headerlink" title="2.2 BBR 的四个阶段 (Probe)"></a>2.2 BBR 的四个阶段 (Probe)</h3><p>BBR 拥塞控制算法通过在四个不同的探测阶段（<code>Startup</code>, <code>Drain</code>, <code>ProbeBandwidth</code>, <code>ProbeRTT</code>）之间循环切换，来持续测量和维护 <code>BtlBw</code> 和 <code>RTT_min</code> 的估计值，并调整发送速率：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[Idle] --&gt; B[Startup]
    B -- Bandwidth growth slows --&gt; C[Drain]
    C -- Inflight at BDP --&gt; D[ProbeBandwidth]
    D -- Periodically, to refresh RTT_min --&gt; E[ProbeRTT]
    E -- RTT_min refreshed --&gt; D
    D -- High loss &#x2F; Congestion --&gt; D
  </pre></div>

<ol>
<li><p><strong>Startup (启动阶段)</strong>：</p>
<ul>
<li>目标：快速增加发送速率以探测网络的实际 <code>BtlBw</code>。</li>
<li>行为：类似传统 TCP 的慢启动，但<code>cwnd</code>和<code>pacing_rate</code>（发送速率）呈指数级增长，直到 <code>BtlBw</code> 的增长出现停滞。</li>
<li>判断：当 <code>BtlBw</code> 的增长率低于某个阈值（例如 1.25 倍）时，认为已经达到瓶颈带宽边缘，进入 <code>Drain</code> 阶段。</li>
</ul>
</li>
<li><p><strong>Drain (排空阶段)</strong>：</p>
<ul>
<li>目标：在 <code>Startup</code> 阶段快速填充缓冲区后，快速排空网络队列，使在途数据量回到 <code>BDP</code>，从而降低延迟。</li>
<li>行为：<code>pacing_rate</code> 被设置为 <code>BtlBw</code> 的很小一部分（例如 0.75倍），持续发送直到在途数据量降至 <code>BDP</code>。</li>
<li>判断：当在途数据量接近 <code>BDP</code> 时，进入 <code>ProbeBandwidth</code> 阶段。</li>
</ul>
</li>
<li><p><strong>ProbeBandwidth (探测带宽阶段)</strong>：</p>
<ul>
<li>目标：这是 BBR 的主要工作阶段。在此阶段，BBR 保持发送速率在 <code>BtlBw</code> 附近，并且周期性地轻微提升发送速率，以探测是否有新的可用带宽。</li>
<li>行为：<code>pacing_rate</code> 以一个周期性的模式在 <code>BtlBw</code> 的 5&#x2F;4 倍和 3&#x2F;4 倍之间波动，同时跟踪新的 <code>BtlBw</code>。这种波动称为<strong>增益周期 (gain cycle)</strong>，通常持续 8 个 RTT 周期。<ul>
<li><strong>高增益 (High Gain)</strong>：以高于 <code>BtlBw</code> 的速率发送，尝试填充潜在的额外带宽。</li>
<li><strong>低增益 (Low Gain)</strong>：以低于 <code>BtlBw</code> 的速率发送，有助于排出之前高增益阶段可能积累的队列，并探测<code>RTT_min</code>。</li>
</ul>
</li>
<li>判断：根据是否有新的更快的 <code>BtlBw</code> 估计值，调整 <code>pacing_rate</code>。</li>
</ul>
</li>
<li><p><strong>ProbeRTT (探测 RTT 阶段)</strong>：</p>
<ul>
<li>目标：周期性地测量真实的 <code>RTT_min</code>，因为网络路径中的 <code>RTT</code> 可能会随时间变化。</li>
<li>行为：当 <code>RTT</code> 在一段时间内 (例如 10 秒) 没有达到其历史最小值时，BBR 会强制性地将发送窗口<code>cwnd</code>降低到 4 个数据包，持续至少一个 <code>RTT_min</code> 的时间。</li>
<li>结果：通过这种方式，BBR 排空了所有网络队列，从而可以精确地测量到当前的纯粹 <code>RTT_min</code>。完成后，返回 <code>ProbeBandwidth</code> 阶段。</li>
</ul>
</li>
</ol>
<h2 id="三、BBR-的优势与不足"><a href="#三、BBR-的优势与不足" class="headerlink" title="三、BBR 的优势与不足"></a>三、BBR 的优势与不足</h2><h3 id="3-1-优势："><a href="#3-1-优势：" class="headerlink" title="3.1 优势："></a>3.1 优势：</h3><ol>
<li><strong>更高的吞吐量</strong>：在高带宽、高延迟或一定丢包率的网络中，BBR 能更好地利用可用带宽，实现更快的传输速度。</li>
<li><strong>更低的延迟</strong>：BBR 避免了过度填充缓冲区，从而显著减少了网络排队延迟 (<code>queueing delay</code>)，提升了交互式应用的响应速度。</li>
<li><strong>对丢包的鲁棒性</strong>：BBR 不完全依赖丢包作为拥塞信号，因此在适度丢包但带宽充足的网络中，表现优于传统算法。</li>
<li><strong>对带宽探测更精准</strong>：通过持续测量 <code>BtlBw</code> 和 <code>RTT_min</code>，更准确地匹配网络实际容量。</li>
<li><strong>公平性改善</strong>：BBR 旨在获取其应有的带宽份额，而不会像传统算法那样在共享瓶颈时过度让步。</li>
</ol>
<h3 id="3-2-不足："><a href="#3-2-不足：" class="headerlink" title="3.2 不足："></a>3.2 不足：</h3><ol>
<li><strong>公平性问题 (BBRv1)</strong>：在 BBRv1 中，如果与大量传统的 Cubic 连接共存，BBR 可能会表现得过于“激进”，抢占更多带宽，导致 Cubic 连接性能下降。这是因为 Cubic 看到丢包会退让，而 BBR 不太会因丢包而退让。BBRv2 在这方面有所改进。</li>
<li><strong>TCP Overhead (开销)</strong>：BBR 算法需要持续的测量和状态维护，这可能引入轻微的 CPU 开销，但通常可以忽略不计。</li>
<li><strong>部署</strong>：需要内核支持，目前主要在 Linux 内核上广泛使用（版本 4.9 及更高）。</li>
<li><strong>对短连接可能效果不明显</strong>：BBR 的优势主要体现在长连接和持续传输任务上。对于大量短连接，握手和慢启动阶段依然占据主要时间。</li>
</ol>
<h2 id="四、如何启用-BBR？"><a href="#四、如何启用-BBR？" class="headerlink" title="四、如何启用 BBR？"></a>四、如何启用 BBR？</h2><p>BBR 算法在 Linux 内核 4.9 及以上版本中可用。</p>
<h3 id="4-1-检查内核版本"><a href="#4-1-检查内核版本" class="headerlink" title="4.1 检查内核版本"></a>4.1 检查内核版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>
<p>如果版本低于 4.9，则需要升级内核。</p>
<h3 id="4-2-启用-BBR"><a href="#4-2-启用-BBR" class="headerlink" title="4.2 启用 BBR"></a>4.2 启用 BBR</h3><p>在 <code>/etc/sysctl.conf</code> 文件中添加以下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.core.default_qdisc=fq</span><br><span class="line">net.ipv4.tcp_congestion_control=bbr</span><br></pre></td></tr></table></figure>

<ul>
<li><code>net.core.default_qdisc=fq</code>：<code>fq</code> (Fair Queue) 是 BBR 推荐的队列调度算法，它有助于 BBR 更准确地进行带宽测量和速率控制。</li>
<li><code>net.ipv4.tcp_congestion_control=bbr</code>：将 TCP 拥塞控制算法设置为 BBR。</li>
</ul>
<p>保存文件后，执行以下命令使配置生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="4-3-验证-BBR-是否启用成功"><a href="#4-3-验证-BBR-是否启用成功" class="headerlink" title="4.3 验证 BBR 是否启用成功"></a>4.3 验证 BBR 是否启用成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>
<p>如果输出是 <code>net.ipv4.tcp_congestion_control = bbr</code>，则表示 BBR 已成功启用。</p>
<p>还可以通过以下命令查看当前活跃的 TCP 连接正在使用的拥塞控制算法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -afi | grep bbr</span><br></pre></td></tr></table></figure>
<p>如果看到 <code>bbr</code> 字样，说明连接正在使用 BBR。</p>
<h2 id="五、BBRv2-的改进"><a href="#五、BBRv2-的改进" class="headerlink" title="五、BBRv2 的改进"></a>五、BBRv2 的改进</h2><p>Google 认识到 BBRv1 在与传统拥塞控制算法共存时的公平性问题，以及对丢包的适应性有时不足。因此，他们开发了 BBRv2，主要改进包括：</p>
<ol>
<li><strong>更强的公平性</strong>：BBRv2 在遇到严重丢包或瓶颈带宽被其他 Cubic 流量完全占据时，能够更合理地降低发送速率，实现与其他算法的更公平共存。</li>
<li><strong>丢包敏感度提升</strong>：BBRv2 在高丢包率下能够更积极地降低 Inflight，防止不必要的丢包。</li>
<li><strong>更优的主动探测</strong>：改进了 <code>ProbeBandwidth</code> 阶段的逻辑，使其在探测新带宽时更加稳定和高效。</li>
<li><strong>更智能的 <code>RTT_min</code> 探测</strong>：改进了 <code>ProbeRTT</code> 阶段，使其能够更准确地判断是否需要重置 <code>RTT_min</code>。</li>
</ol>
<p>BBRv2 仍在积极开发和部署中，逐渐取代 BBRv1 成为默认选择。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>BBR 算法是 TCP 拥塞控制领域的一项重大创新，它通过基于带宽和 RTT 测量而非丢包信号，极大地改善了网络传输的吞吐量和延迟，尤其在长距离、高带宽、低丢包的网络环境中表现卓越。它的出现有效缓解了“缓冲区膨胀”问题，为用户提供了更流畅、更迅速的网络体验。随着 BBRv2 的不断完善，BBR 将在未来的互联网中扮演越来越重要的角色。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/f19c839c8b2e/">https://blog.tbf1211.xx.kg/f19c839c8b2e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE/">代理协议</a><a class="post-meta__tags" href="/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/">拥塞控制算法</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/5d5f7c78ff8d/" title="五层因特网协议栈深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">五层因特网协议栈深度详解</div></div><div class="info-2"><div class="info-item-1"> 五层因特网协议栈 (Five-Layer Internet Protocol Stack) 是现代因特网使用的核心架构模型。它是在 OSI 七层模型和早期 ARPANET 四层模型（即经典的 TCP&#x2F;IP 模型）的基础上，结合实际应用和教学的便利性而形成的一种常用分层模型。这个模型将复杂的网络通信过程划分为五个相对独立的层次，每一层都负责特定的功能，并向上层提供服务。  核心思想：分而治之，各司其职。将复杂的网络通信过程分解为易于管理和理解的模块化层次，每个层次只关注自己的功能，并通过协议与对等层通信，同时向相邻层提供服务。   一、为什么需要分层模型？网络通信系统极其复杂，涉及硬件设备、软件协议、数据编码、路由选择等诸多方面。如果不进行分层，整个系统将难以设计、实现、维护和扩展。分层模型带来了以下显著优势：  模块化 (Modularity)：每层实现特定功能，层次之间相对独立，便于开发和调试。 灵活性 (Flexibility)：可以替换或升级某个层次的协议，而不影响其他层次。例如，可以从 IPv4 升级到 IPv6 而不改变传输层和应用层协议。 标准化 (Sta...</div></div></div></a><a class="pagination-related" href="/f67db260675a/" title="Vue3 Hook(组合式 API)与Mixin对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Vue3 Hook(组合式 API)与Mixin对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin 两种逻辑复用模式，从多方面进行对比分析，帮助开发者理解它们各自的优缺点，并选择最适合自己项目和团队的模式。   一、 理解 Vue 中的逻辑复用在 Vue 组件开发中，我们经常会遇到需要在多个组件中共享相同的逻辑（例如：处理鼠标位置、计时器、表单验证、主题切换等）。如果没有有效的复用机制，这些逻辑就会在不同组件中重复编写，导致代码冗余、难以维护。  Vue 提供了以下主要方式来解决逻辑复用问题：  Mixin (混入)：Vue 2 的主要逻辑复用方式，也在 Vue 3 中继续支持。 Composition API (组合式 API &#x2F; Vue 3 Hook)：Vue 3 引入...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/a133c3b31f23/" title="Shadowsocks(SS)详解：轻量级加密代理协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-03</div><div class="info-item-2">Shadowsocks(SS)详解：轻量级加密代理协议</div></div><div class="info-2"><div class="info-item-1"> Shadowsocks (SS) 是一个开源的SOCKS5 代理协议，由 @clowwindy 于 2012 年开发。它专门设计用于穿透网络审查，并保护用户隐私。与传统 VPN 不同，Shadowsocks 采取了轻量级的加密和混淆机制，旨在让代理流量看起来不那么“突出”，从而避免被网络防火墙识别和阻断。其简洁高效的设计概念，使其一度成为最流行的科学上网工具之一。  核心思想：Shadowsocks 通过特定的加密算法对SOCKS5代理流量进行加密，并通常通过在TCP层提供一个“看起来像随机数据”的加密层，来隐藏其代理本质，而非像 VPN 那样建立一个完整的隧道。   一、为什么需要 Shadowsocks？传统的 VPN 协议，如 PPTP、L2TP&#x2F;IPSec 等，虽然能提供加密和匿名性，但在严格的网络审查环境下，其协议特征容易被防火墙识别和阻断。许多早期 VPN 服务商采用的 PPTP 协议甚至因为安全性弱点而不再被推荐。 Shadowsocks 旨在解决以下问题：  协议特征明显：传统 VPN 协议的握手和数据包结构特征明显，容易被防火墙识别。 性能开销：完整...</div></div></div></a><a class="pagination-related" href="/6d2713973946/" title="SOCKS5协议详解：网络代理的基础与通用协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-22</div><div class="info-item-2">SOCKS5协议详解：网络代理的基础与通用协议</div></div><div class="info-2"><div class="info-item-1"> SOCKS5 是一种网络传输协议，它允许客户端通过一个“代理服务器”间接地连接到其他服务器。SOCKS 是 “SOCKet Secure” 的缩写，版本 5 是目前最常用的 SOCKS 协议版本。SOCKS5 协议工作在 OSI 模型中的会话层 (第五层)，能够处理TCP 和 UDP 两种流量，并且支持多种认证方式。它本身不提供加密功能，主要用于路由流量和隐藏真实 IP 地址，是许多更高级代理协议（如 Shadowsocks、V2Ray 客户端的本地监听）的基础。  核心思想：SOCKS5 是一个通用的网络代理协议，它实现了在客户端和目标服务器之间建立连接的中间转发机制。它不关心应用层数据，只负责转发 TCP 连接和 UDP 数据包，并提供认证功能。   一、为什么需要 SOCKS5 代理？在没有代理的情况下，应用程序直接连接到目标服务器。SOCKS5 代理的出现，主要解决了以下问题：  突破网络限制：当直接访问某个服务受阻时，可以通过 SOCKS5 代理服务器进行中转，绕过本地网络限制。 隐藏真实 IP 地址：客户端的真实 IP 地址对目标服务器隐藏，保护用户隐私。 负载均衡...</div></div></div></a><a class="pagination-related" href="/14fbc43cdbd2/" title="Trojan协议详解：伪装为 HTTPS 的无状态代理协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="info-item-2">Trojan协议详解：伪装为 HTTPS 的无状态代理协议</div></div><div class="info-2"><div class="info-item-1"> Trojan 是一个开源的代理协议，其核心设计理念是“伪装为最常见的 HTTPS 流量”。它通过模仿 HTTPS 流量的特征，并利用 TLS (Transport Layer Security) 的加密和认证机制，旨在实现几乎无法被识别和阻断的代理连接。Trojan 协议放弃了传统代理协议常见的复杂头部和混淆算法，转而直接将代理数据封装在 TLS 中，并强制要求使用 443 端口和合法 TLS 证书，以最大化其隐蔽性。  核心思想：将代理流量深度伪装为 HTTPS 流量，通过在 443 端口上直接利用 TLS 协议的加密会话来传输代理数据，从而使其在外部看来与正常的 HTTPS 流量几乎无异。   一、Trojan 协议的诞生背景与目标Trojan 协议的出现，是对传统代理协议（如 Shadowsocks、VMess 等）在对抗深度包检测 (DPI) 和主动探测时的局限性的一种回应。主要背景如下：  协议特征识别：许多代理协议，即使经过混淆，仍可能因其特定的协议头部、握手流程、流量模式或不符合 TLS 规范的行为而被识别。 主动探测：审查系统可能会主动连接代理服务器，发送探测包...</div></div></div></a><a class="pagination-related" href="/2fad5fce89b5/" title="VLESS+WS+TLS 代理方式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-02</div><div class="info-item-2">VLESS+WS+TLS 代理方式详解</div></div><div class="info-2"><div class="info-item-1"> VLESS+WS+TLS 是一种高效、安全且隐蔽的代理组合方案，广泛应用于突破网络审查和实现隐私保护。它结合了 VLESS 协议的轻量和高性能、WebSocket (WS) 的伪装能力以及 TLS 的加密和流量混淆特性。这种组合使得代理流量在网络传输中难以被检测和干扰，提供了良好的稳定性和抗封锁能力。  核心思想：VLESS 负责高效数据传输，WebSocket 将代理流量伪装成正常的网页浏览流量，TLS 提供端到端加密和证书认证，三者结合形成一个难以被识别、安全且高性能的代理通道。   一、各组件详解1.1 VLESS 协议VLESS 是一种由 Xray-core 开发的轻量级代理协议。它旨在提供比 VMess 更简单、更高效的数据传输，并减少协议开销。  特点：  无状态 (Stateless)：与 VMess 不同，VLESS 不包含复杂的握手和会话管理，减少了协议开销。 高性能 (High Performance)：由于协议简单，数据传输效率高。 透明性 (Transparency)：VLESS 可以相对透明地传输数据，不进行额外的加密或混淆（通常与 TLS 或 XTL...</div></div></div></a><a class="pagination-related" href="/e0277d8d795d/" title="XTLS (eXtended TLS) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-03</div><div class="info-item-2">XTLS (eXtended TLS) 详解</div></div><div class="info-2"><div class="info-item-1"> XTLS (eXtended TLS) 是 Xray-core 提出的一种创新性传输协议，旨在解决传统代理方案中 TLS 双重加密带来的性能损耗，同时保持甚至增强流量的隐蔽性。XTLS 的核心思想是优化 TLS 加密过程，只对必要的数据进行加密，避免重复加密，从而提高代理的性能和降低资源占用。  核心思想：避免 TLS 双重加密，直接复用 TLS 握手后的加密会话，将代理协议数据直接封装在 TLS Payload 中，从而实现高性能且隐蔽的传输。   一、为什么需要 XTLS？在 VLESS+WS+TLS 或 VMess+WS+TLS 等传统代理方案中，数据流通常会经历双重加密：  代理协议自身加密：例如，VMess 协议会对数据进行加密（VLESS 自身不加密，但通常会与其他加密方案结合）。 传输层 TLS 加密：WebSocket 流量再通过 TLS 进行加密，形成 代理协议数据 -&gt; WS 帧 -&gt; TLS 记录 的封装。  这种双重加密虽然增强了安全性，但带来了以下问题：  性能损耗：加密和解密操作是 CPU 密集型的，双重加密会显著增加 CPU 负担，尤其...</div></div></div></a><a class="pagination-related" href="/718e2134a185/" title="TUIC (Trojan-compatible UDP over ICMP&#x2F;TCP) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-25</div><div class="info-item-2">TUIC (Trojan-compatible UDP over ICMP&#x2F;TCP) 协议详解</div></div><div class="info-2"><div class="info-item-1"> TUIC (TCP User Datagram Internet Connections) 是一个创新的代理协议，旨在结合 TCP 的稳定性和 UDP 的灵活性及高效率。它基于 QUIC 协议的思想，但在用户空间实现了一套自定义的拥塞控制和可靠传输机制，运行在 UDP 端口上，并利用 TLS 1.3 进行加密。TUIC 的核心目标是提供一个高性能、低延迟、抗审查且在各种网络环境下（尤其是高丢包、高延迟）表现优异的代理解决方案，同时保持极高的隐蔽性。  核心思想：在 UDP 端口上模拟 TCP 的可靠传输和拥塞控制（但拥有更强的灵活性和性能），并融入 QUIC 的多路复用优势，所有流量均通过 TLS 1.3 加密，以实现高性能、高隐蔽性和强抗审查能力。   一、为什么需要 TUIC？在代理协议的发展历程中，TCP 和 UDP 各有优劣：  TCP 协议： 优点：可靠传输、有序交付、广泛兼容性、穿越 NAT 能力强。 缺点：队头阻塞 (Head-of-Line Blocking)、拥塞控制在高丢包&#x2F;高延迟环境下效率低下、握手开销大。   UDP 协议： 优点：无连接、低延...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">388</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">213</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">76</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-BBR%EF%BC%9F"><span class="toc-text">一、为什么需要 BBR？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81BBR-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-text">二、BBR 的核心概念与原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-BBR-%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B-%E7%90%86%E8%AE%BA%E5%8F%91%E9%80%81%E9%99%90%E5%88%B6"><span class="toc-text">2.1 BBR 的数学模型 (理论发送限制)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-BBR-%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5-Probe"><span class="toc-text">2.2 BBR 的四个阶段 (Probe)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81BBR-%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E4%B8%8D%E8%B6%B3"><span class="toc-text">三、BBR 的优势与不足</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-text">3.1 优势：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%8D%E8%B6%B3%EF%BC%9A"><span class="toc-text">3.2 不足：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8-BBR%EF%BC%9F"><span class="toc-text">四、如何启用 BBR？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A3%80%E6%9F%A5%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="toc-text">4.1 检查内核版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%90%AF%E7%94%A8-BBR"><span class="toc-text">4.2 启用 BBR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%AA%8C%E8%AF%81-BBR-%E6%98%AF%E5%90%A6%E5%90%AF%E7%94%A8%E6%88%90%E5%8A%9F"><span class="toc-text">4.3 验证 BBR 是否启用成功</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81BBRv2-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-text">五、BBRv2 的改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能体 (Agent) 详解：深入 LangChain 开发实践"/></a><div class="content"><a class="title" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践">智能体 (Agent) 详解：深入 LangChain 开发实践</a><time datetime="2025-12-10T22:24:00.000Z" title="发表于 2025-12-11 06:24:00">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go Jaeger 深度解析：分布式追踪实践"/></a><div class="content"><a class="title" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践">Go Jaeger 深度解析：分布式追踪实践</a><time datetime="2025-12-04T22:24:00.000Z" title="发表于 2025-12-05 06:24:00">2025-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/15920229f914/" title="Supabase 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supabase 深度解析"/></a><div class="content"><a class="title" href="/15920229f914/" title="Supabase 深度解析">Supabase 深度解析</a><time datetime="2025-12-02T22:24:00.000Z" title="发表于 2025-12-03 06:24:00">2025-12-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-21.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}&path=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews) {
            pagePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors) {
            siteUV.textContent = typeof data.visitors.value !== 'undefined' ? data.visitors.value : data.visitors
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews) {
            sitePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>