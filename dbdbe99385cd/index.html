<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python Pandas详解：数据处理与分析的瑞士军刀 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Pandas 是 Python 中用于数据分析和处理的核心库。它提供了一套高性能、易于使用的数据结构，最主要的是 DataFrame（二维表格数据）和 Series（一维带标签数组），用于快速处理和分析结构化数据（如 CSV、Excel、数据库表格数据）。Pandas 以其直观的语法和强大的功能，成为数据科学家和数据工程师的首选工具。  核心思想：Pandas 将表格数据抽象为 DataFram">
<meta property="og:type" content="article">
<meta property="og:title" content="Python Pandas详解：数据处理与分析的瑞士军刀">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/dbdbe99385cd/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Pandas 是 Python 中用于数据分析和处理的核心库。它提供了一套高性能、易于使用的数据结构，最主要的是 DataFrame（二维表格数据）和 Series（一维带标签数组），用于快速处理和分析结构化数据（如 CSV、Excel、数据库表格数据）。Pandas 以其直观的语法和强大的功能，成为数据科学家和数据工程师的首选工具。  核心思想：Pandas 将表格数据抽象为 DataFram">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg">
<meta property="article:published_time" content="2023-02-20T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-08T10:08:49.268Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="NumPy">
<meta property="article:tag" content="Pandas">
<meta property="article:tag" content="数据处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python Pandas详解：数据处理与分析的瑞士军刀",
  "url": "https://blog.tbf1211.xx.kg/dbdbe99385cd/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg",
  "datePublished": "2023-02-20T22:24:00.000Z",
  "dateModified": "2025-12-08T10:08:49.268Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/dbdbe99385cd/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python Pandas详解：数据处理与分析的瑞士军刀',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">356</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">208</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">74</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python Pandas详解：数据处理与分析的瑞士军刀</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python Pandas详解：数据处理与分析的瑞士军刀</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-20T22:24:00.000Z" title="发表于 2023-02-21 06:24:00">2023-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E5%BA%93/">库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/dbdbe99385cd/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Pandas</strong> 是 Python 中用于数据分析和处理的核心库。它提供了一套高性能、易于使用的数据结构，最主要的是 <strong><code>DataFrame</code></strong>（二维表格数据）和 <strong><code>Series</code></strong>（一维带标签数组），用于快速处理和分析结构化数据（如 CSV、Excel、数据库表格数据）。Pandas 以其直观的语法和强大的功能，成为数据科学家和数据工程师的首选工具。</p>
</blockquote>
<div class="note info flat"><p>核心思想：Pandas 将表格数据抽象为 <code>DataFrame</code> 和 <code>Series</code> 对象，提供类似 SQL 和 Excel 的操作，通过向量化和 C&#x2F;Cython 实现的底层优化，极大提升了数据处理效率。</p>
</div>
<hr>
<h2 id="一、为什么选择-Pandas？"><a href="#一、为什么选择-Pandas？" class="headerlink" title="一、为什么选择 Pandas？"></a>一、为什么选择 Pandas？</h2><p>在数据驱动的时代，我们经常需要处理各种形式的表格数据。Python 原生的数据结构（如列表、字典）虽然灵活，但在处理大量、复杂、异构的表格数据时显得力不从心。Pandas 解决了这些痛点：</p>
<ol>
<li><strong>直观的数据结构</strong>：<code>DataFrame</code> 和 <code>Series</code> 提供了强大的标签索引功能，使得数据操作更加直观，无需关注底层实现。</li>
<li><strong>高效的数据操作</strong>：底层基于 NumPy 优化，利用 C 和 Cython 实现，对于大规模数据操作性能优异。</li>
<li><strong>丰富的数据处理能力</strong>：<ul>
<li><strong>数据清洗</strong>：缺失值处理、重复值处理、异常值检测。</li>
<li><strong>数据转换</strong>：重塑 (reshape)、透视 (pivot)、合并 (merge)、连接 (join)。</li>
<li><strong>数据选择</strong>：强大的基于标签、位置、布尔值的索引和切片。</li>
<li><strong>时间序列分析</strong>：强大的日期时间处理功能。</li>
</ul>
</li>
<li><strong>易于与文件交互</strong>：轻松读写各种数据格式，如 CSV, Excel, SQL 数据库, JSON, HDF5 等。</li>
<li><strong>与主流科学计算库集成</strong>：无缝对接 NumPy, SciPy, Matplotlib, Scikit-learn 等。</li>
</ol>
<h2 id="二、安装-Pandas"><a href="#二、安装-Pandas" class="headerlink" title="二、安装 Pandas"></a>二、安装 Pandas</h2><p>Pandas 并非 Python 的内置库，需要通过 <code>pip</code> 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure>

<p>安装完成后，通常会将其导入为 <code>pd</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># Pandas 依赖 NumPy</span></span><br></pre></td></tr></table></figure>

<h2 id="三、Pandas-数据结构"><a href="#三、Pandas-数据结构" class="headerlink" title="三、Pandas 数据结构"></a>三、Pandas 数据结构</h2><p>Pandas 主要有两种核心数据结构：<code>Series</code> 和 <code>DataFrame</code>。</p>
<h3 id="3-1-Series-一维带标签数组"><a href="#3-1-Series-一维带标签数组" class="headerlink" title="3.1 Series (一维带标签数组)"></a>3.1 <code>Series</code> (一维带标签数组)</h3><p><code>Series</code> 类似于一维数组（NumPy <code>ndarray</code>），但它带有一个索引（标签）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从列表创建 Series</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;从列表创建 Series:\n&quot;</span>, s)</span><br><span class="line"><span class="comment"># 0    1.0</span></span><br><span class="line"><span class="comment"># 1    3.0</span></span><br><span class="line"><span class="comment"># 2    5.0</span></span><br><span class="line"><span class="comment"># 3    NaN</span></span><br><span class="line"><span class="comment"># 4    6.0</span></span><br><span class="line"><span class="comment"># 5    8.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建带指定索引的 Series</span></span><br><span class="line">s2 = pd.Series([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n带索引的 Series:\n&quot;</span>, s2)</span><br><span class="line"><span class="comment"># a    10</span></span><br><span class="line"><span class="comment"># b    20</span></span><br><span class="line"><span class="comment"># c    30</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字典创建 Series</span></span><br><span class="line">data_dict = &#123;<span class="string">&#x27;Math&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;Science&#x27;</span>: <span class="number">85</span>, <span class="string">&#x27;English&#x27;</span>: <span class="number">92</span>&#125;</span><br><span class="line">s3 = pd.Series(data_dict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n从字典创建 Series:\n&quot;</span>, s3)</span><br><span class="line"><span class="comment"># Math       90</span></span><br><span class="line"><span class="comment"># Science    85</span></span><br><span class="line"><span class="comment"># English    92</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Series 的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\ns2 的索引: <span class="subst">&#123;s2.index&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s2 的值: <span class="subst">&#123;s2.values&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s2 的数据类型: <span class="subst">&#123;s2.dtype&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Series</code> 支持类似 NumPy 数组的索引和切片，以及基于标签的访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于位置索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s[0]: <span class="subst">&#123;s[<span class="number">0</span>]&#125;</span>&quot;</span>)     <span class="comment"># 1.0</span></span><br><span class="line"><span class="comment"># 基于标签索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s2[&#x27;b&#x27;]: <span class="subst">&#123;s2[<span class="string">&#x27;b&#x27;</span>]&#125;</span>&quot;</span>)   <span class="comment"># 20</span></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s[:3]:\n<span class="subst">&#123;s[:<span class="number">3</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># s[(&#x27;a&#x27;, &#x27;c&#x27;)]: 多个标签索引</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s2[[&#x27;a&#x27;, &#x27;c&#x27;]]:\n<span class="subst">&#123;s2[[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-DataFrame-二维表格数据"><a href="#3-2-DataFrame-二维表格数据" class="headerlink" title="3.2 DataFrame (二维表格数据)"></a>3.2 <code>DataFrame</code> (二维表格数据)</h3><p><code>DataFrame</code> 是 Pandas 最重要的数据结构，可以看作是由 Series 组成的字典（共享同一个索引），或具有行和列的二维表格。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从字典创建 DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">28</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;London&#x27;</span>, <span class="string">&#x27;Paris&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Salary&#x27;</span>: [<span class="number">70000</span>, <span class="number">80000</span>, <span class="number">90000</span>, np.nan] <span class="comment"># np.nan 表示缺失值</span></span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;从字典创建 DataFrame:\n&quot;</span>, df)</span><br><span class="line"><span class="comment">#       Name  Age      City   Salary</span></span><br><span class="line"><span class="comment"># 0    Alice   25  New York  70000.0</span></span><br><span class="line"><span class="comment"># 1      Bob   30    London  80000.0</span></span><br><span class="line"><span class="comment"># 2  Charlie   35     Paris  90000.0</span></span><br><span class="line"><span class="comment"># 3    David   28  New York      NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引和列</span></span><br><span class="line">df2 = pd.DataFrame(data, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">                   columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Salary&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n指定索引和列的 DataFrame:\n&quot;</span>, df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 NumPy 数组创建 DataFrame</span></span><br><span class="line">dates = pd.date_range(<span class="string">&#x27;20230101&#x27;</span>, periods=<span class="number">6</span>)</span><br><span class="line">df3 = pd.DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">4</span>), index=dates, columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n从 NumPy 数组创建 DataFrame:\n&quot;</span>, df3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataFrame 的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\ndf 的索引: <span class="subst">&#123;df.index&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df 的列: <span class="subst">&#123;df.columns&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df 的形状 (行, 列): <span class="subst">&#123;df.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df 的数据类型:\n<span class="subst">&#123;df.dtypes&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="四、数据输入-输出-I-O"><a href="#四、数据输入-输出-I-O" class="headerlink" title="四、数据输入&#x2F;输出 (I&#x2F;O)"></a>四、数据输入&#x2F;输出 (I&#x2F;O)</h2><p>Pandas 支持多种数据格式的读写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CSV 文件</span></span><br><span class="line"><span class="comment"># df.to_csv(&#x27;my_data.csv&#x27;, index=False) # 保存为 CSV</span></span><br><span class="line"><span class="comment"># df_from_csv = pd.read_csv(&#x27;my_data.csv&#x27;) # 读取 CSV</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Excel 文件</span></span><br><span class="line"><span class="comment"># df.to_excel(&#x27;my_data.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;, index=False)</span></span><br><span class="line"><span class="comment"># df_from_excel = pd.read_excel(&#x27;my_data.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON 文件</span></span><br><span class="line"><span class="comment"># df.to_json(&#x27;my_data.json&#x27;, orient=&#x27;records&#x27;)</span></span><br><span class="line"><span class="comment"># df_from_json = pd.read_json(&#x27;my_data.json&#x27;, orient=&#x27;records&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL 数据库 (需要安装相应的数据库连接驱动，如 psycopg2, pymysql)</span></span><br><span class="line"><span class="comment"># from sqlalchemy import create_engine</span></span><br><span class="line"><span class="comment"># engine = create_engine(&#x27;postgresql://user:password@host:port/database&#x27;)</span></span><br><span class="line"><span class="comment"># df.to_sql(&#x27;my_table&#x27;, engine, if_exists=&#x27;replace&#x27;, index=False)</span></span><br><span class="line"><span class="comment"># df_from_sql = pd.read_sql_table(&#x27;my_table&#x27;, engine)</span></span><br></pre></td></tr></table></figure>

<h2 id="五、数据选择与索引"><a href="#五、数据选择与索引" class="headerlink" title="五、数据选择与索引"></a>五、数据选择与索引</h2><h3 id="5-1-基本选择"><a href="#5-1-基本选择" class="headerlink" title="5.1 基本选择"></a>5.1 基本选择</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择单列 (返回 Series)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df[&#x27;Name&#x27;]:\n<span class="subst">&#123;df[<span class="string">&#x27;Name&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 选择多列 (返回 DataFrame)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df[[&#x27;Name&#x27;, &#x27;Age&#x27;]]:\n<span class="subst">&#123;df[[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-loc-和-iloc"><a href="#5-2-loc-和-iloc" class="headerlink" title="5.2 loc 和 iloc"></a>5.2 <code>loc</code> 和 <code>iloc</code></h3><ul>
<li><strong><code>loc</code></strong>: 基于<strong>标签</strong>进行索引和切片。</li>
<li><strong><code>iloc</code></strong>: 基于<strong>位置</strong>（整数）进行索引和切片。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df_idx = pd.DataFrame(data, index=[<span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;r2&#x27;</span>, <span class="string">&#x27;r3&#x27;</span>, <span class="string">&#x27;r4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n带自定义索引的 DataFrame:\n&quot;</span>, df_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loc:</span></span><br><span class="line"><span class="comment"># 单行单列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df_idx.loc[&#x27;r1&#x27;, &#x27;Name&#x27;]: <span class="subst">&#123;df_idx.loc[<span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>]&#125;</span>&quot;</span>) <span class="comment"># Alice</span></span><br><span class="line"><span class="comment"># 多行多列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df_idx.loc[[&#x27;r1&#x27;, &#x27;r3&#x27;], [&#x27;Name&#x27;, &#x27;City&#x27;]]:\n<span class="subst">&#123;df_idx.loc[[<span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;r3&#x27;</span>], [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;City&#x27;</span>]]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 切片 (包含结束标签)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df_idx.loc[&#x27;r1&#x27;:&#x27;r3&#x27;, &#x27;Name&#x27;:&#x27;City&#x27;]:\n<span class="subst">&#123;df_idx.loc[<span class="string">&#x27;r1&#x27;</span>:<span class="string">&#x27;r3&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>:<span class="string">&#x27;City&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># iloc:</span></span><br><span class="line"><span class="comment"># 单行单列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df_idx.iloc[0, 0]: <span class="subst">&#123;df_idx.iloc[<span class="number">0</span>, <span class="number">0</span>]&#125;</span>&quot;</span>) <span class="comment"># Alice</span></span><br><span class="line"><span class="comment"># 多行多列</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df_idx.iloc[[0, 2], [0, 2]]:\n<span class="subst">&#123;df_idx.iloc[[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">2</span>]]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 切片 (不包含结束位置)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;df_idx.iloc[0:3, 0:3]:\n<span class="subst">&#123;df_idx.iloc[<span class="number">0</span>:<span class="number">3</span>, <span class="number">0</span>:<span class="number">3</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-3-布尔索引"><a href="#5-3-布尔索引" class="headerlink" title="5.3 布尔索引"></a>5.3 布尔索引</h3><p>使用条件表达式选择数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择年龄大于 30 的行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;年龄大于 30 的记录:\n<span class="subst">&#123;df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合条件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;年龄大于 28 且城市是 New York 的记录:\n<span class="subst">&#123;df[(df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">28</span>) &amp; (df[<span class="string">&#x27;City&#x27;</span>] == <span class="string">&#x27;New York&#x27;</span>)]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 isin() 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;城市在 [&#x27;New York&#x27;, &#x27;London&#x27;] 中的记录:\n<span class="subst">&#123;df[df[<span class="string">&#x27;City&#x27;</span>].isin([<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;London&#x27;</span>])]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="六、数据清洗与准备"><a href="#六、数据清洗与准备" class="headerlink" title="六、数据清洗与准备"></a>六、数据清洗与准备</h2><h3 id="6-1-缺失值处理"><a href="#6-1-缺失值处理" class="headerlink" title="6.1 缺失值处理"></a>6.1 缺失值处理</h3><ul>
<li><code>isnull()</code> &#x2F; <code>isna()</code>: 检测缺失值（返回布尔型 DataFrame）。</li>
<li><code>notnull()</code>: 检测非缺失值。</li>
<li><code>dropna()</code>: 删除含有缺失值的行或列。</li>
<li><code>fillna()</code>: 填充缺失值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始 DataFrame (含缺失值):\n&quot;</span>, df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测缺失值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n缺失值检测:\n<span class="subst">&#123;df.isnull()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n每列缺失值数量:\n<span class="subst">&#123;df.isnull().<span class="built_in">sum</span>()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除含有缺失值的行 (至少有一个缺失值)</span></span><br><span class="line">df_dropped_rows = df.dropna()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n删除含有缺失值的行:\n&quot;</span>, df_dropped_rows)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有为 NaN 的行</span></span><br><span class="line">df_dropped_all = df.dropna(how=<span class="string">&#x27;all&#x27;</span>) <span class="comment"># 只删除所有值都是 NaN 的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充缺失值</span></span><br><span class="line">df_filled_na = df.fillna(<span class="number">0</span>) <span class="comment"># 将所有 NaN 填充为 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n填充 NaN 为 0:\n&quot;</span>, df_filled_na)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充缺失值，使用指定列的平均值</span></span><br><span class="line">df[<span class="string">&#x27;Salary&#x27;</span>] = df[<span class="string">&#x27;Salary&#x27;</span>].fillna(df[<span class="string">&#x27;Salary&#x27;</span>].mean())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n使用 Salary 列平均值填充:\n&quot;</span>, df)</span><br></pre></td></tr></table></figure>

<h3 id="6-2-重复值处理"><a href="#6-2-重复值处理" class="headerlink" title="6.2 重复值处理"></a>6.2 重复值处理</h3><ul>
<li><code>duplicated()</code>: 检测重复行。</li>
<li><code>drop_duplicates()</code>: 删除重复行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df_dup = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;col1&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;col2&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n含有重复值的 DataFrame:\n&quot;</span>, df_dup)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n检测重复行:\n<span class="subst">&#123;df_dup.duplicated()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 0    False</span></span><br><span class="line"><span class="comment"># 1    False</span></span><br><span class="line"><span class="comment"># 2     True</span></span><br><span class="line"><span class="comment"># 3    False</span></span><br><span class="line"><span class="comment"># dtype: bool</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n删除重复行:\n<span class="subst">&#123;df_dup.drop_duplicates()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-数据类型转换"><a href="#6-3-数据类型转换" class="headerlink" title="6.3 数据类型转换"></a>6.3 数据类型转换</h3><p><code>astype()</code> 方法用于改变 Series 或 DataFrame 列的数据类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Age&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].astype(<span class="built_in">float</span>) <span class="comment"># 将 Age 列转换为浮点型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nAge 列数据类型转换后:\n<span class="subst">&#123;df.dtypes&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="七、数据操作与转换"><a href="#七、数据操作与转换" class="headerlink" title="七、数据操作与转换"></a>七、数据操作与转换</h2><h3 id="7-1-应用函数-apply"><a href="#7-1-应用函数-apply" class="headerlink" title="7.1 应用函数 (apply)"></a>7.1 应用函数 (<code>apply</code>)</h3><p><code>apply()</code> 方法可以在 Series 或 DataFrame 的行&#x2F;列上应用函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 Series 应用函数</span></span><br><span class="line">df[<span class="string">&#x27;Name_Upper&#x27;</span>] = df[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x.upper())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n应用 upper() 函数:\n<span class="subst">&#123;df[[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Name_Upper&#x27;</span>]]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 DataFrame 的行或列应用函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">categorize_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">30</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Young&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Adult&#x27;</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;Age_Category&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].apply(categorize_age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n应用自定义函数:\n<span class="subst">&#123;df[[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Age_Category&#x27;</span>]]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-2-分组与聚合-groupby"><a href="#7-2-分组与聚合-groupby" class="headerlink" title="7.2 分组与聚合 (groupby)"></a>7.2 分组与聚合 (<code>groupby</code>)</h3><p><code>groupby()</code> 是 Pandas 中最强大的功能之一，用于按一个或多个键对 DataFrame 进行分组，然后对每个组执行聚合操作（如求和、均值、计数等）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按 &#x27;City&#x27; 列分组，并计算每个城市的平均年龄和薪水</span></span><br><span class="line">city_group = df.groupby(<span class="string">&#x27;City&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n按城市分组并计算平均值:\n<span class="subst">&#123;city_group.mean(numeric_only=<span class="literal">True</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#           Age     Salary</span></span><br><span class="line"><span class="comment"># City</span></span><br><span class="line"><span class="comment"># London   30.0  80000.000</span></span><br><span class="line"><span class="comment"># New York 26.5  70000.000</span></span><br><span class="line"><span class="comment"># Paris    35.0  90000.000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个聚合函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n按城市分组，计算年龄的均值和最大值:\n<span class="subst">&#123;df.groupby(<span class="string">&#x27;City&#x27;</span>)[<span class="string">&#x27;Age&#x27;</span>].agg([<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多列分组</span></span><br><span class="line">df_multi_group = df.groupby([<span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;Age_Category&#x27;</span>])[<span class="string">&#x27;Salary&#x27;</span>].mean()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n按城市和年龄类别计算平均薪水:\n<span class="subst">&#123;df_multi_group&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-3-合并、连接、拼接-merge-join-concat"><a href="#7-3-合并、连接、拼接-merge-join-concat" class="headerlink" title="7.3 合并、连接、拼接 (merge, join, concat)"></a>7.3 合并、连接、拼接 (<code>merge</code>, <code>join</code>, <code>concat</code>)</h3><ul>
<li><strong><code>concat</code></strong>: 沿着某个轴（行或列）堆叠 (<code>stack</code>) 多个 DataFrame 或 Series。</li>
<li><strong><code>merge</code></strong>: 类似于 SQL 的 JOIN 操作，根据一个或多个键合并 DataFrame。</li>
<li><strong><code>join</code></strong>: 类似于 <code>merge</code>，但默认是根据索引进行连接。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>, <span class="string">&#x27;K3&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K4&#x27;</span>, <span class="string">&#x27;K5&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C4&#x27;</span>, <span class="string">&#x27;C5&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D4&#x27;</span>, <span class="string">&#x27;D5&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># concat (行堆叠)</span></span><br><span class="line">df_concat = pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nconcat 示例 (按行堆叠):\n&quot;</span>, df_concat)</span><br><span class="line"><span class="comment">#   key    A    B    C    D</span></span><br><span class="line"><span class="comment"># 0  K0   A0   B0  NaN  NaN</span></span><br><span class="line"><span class="comment"># 1  K1   A1   B1  NaN  NaN</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge (内连接)</span></span><br><span class="line">df_merge_inner = pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nmerge 示例 (内连接):\n&quot;</span>, df_merge_inner)</span><br><span class="line"><span class="comment">#   key   A   B   C   D</span></span><br><span class="line"><span class="comment"># 0  K0  A0  B0  C0  D0</span></span><br><span class="line"><span class="comment"># 1  K1  A1  B1  C1  D1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># merge (左连接)</span></span><br><span class="line">df_merge_left = pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nmerge 示例 (左连接):\n&quot;</span>, df_merge_left)</span><br><span class="line"><span class="comment">#   key   A   B    C    D</span></span><br><span class="line"><span class="comment"># 0  K0  A0  B0   C0   D0</span></span><br><span class="line"><span class="comment"># 1  K1  A1  B1   C1   D1</span></span><br><span class="line"><span class="comment"># 2  K2  A2  B2  NaN  NaN</span></span><br><span class="line"><span class="comment"># 3  K3  A3  B3  NaN  NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-透视表-pivot-table"><a href="#7-4-透视表-pivot-table" class="headerlink" title="7.4 透视表 (pivot_table)"></a>7.4 透视表 (<code>pivot_table</code>)</h3><p>创建电子表格风格的透视表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">df_sales = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;Date&#x27;</span>: pd.to_datetime([<span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="string">&#x27;2023-01-02&#x27;</span>, <span class="string">&#x27;2023-01-02&#x27;</span>, <span class="string">&#x27;2023-01-03&#x27;</span>]),</span><br><span class="line">    <span class="string">&#x27;Region&#x27;</span>: [<span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;East&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Product&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Sales&#x27;</span>: [<span class="number">100</span>, <span class="number">150</span>, <span class="number">120</span>, <span class="number">180</span>, <span class="number">200</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n原始销售数据:\n&quot;</span>, df_sales)</span><br><span class="line"></span><br><span class="line">pivot_table = df_sales.pivot_table(</span><br><span class="line">    values=<span class="string">&#x27;Sales&#x27;</span>, <span class="comment"># 聚合的值</span></span><br><span class="line">    index=<span class="string">&#x27;Date&#x27;</span>,   <span class="comment"># 行索引</span></span><br><span class="line">    columns=<span class="string">&#x27;Region&#x27;</span>, <span class="comment"># 列索引</span></span><br><span class="line">    aggfunc=<span class="string">&#x27;sum&#x27;</span>   <span class="comment"># 聚合函数</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n销售透视表 (按日期和区域汇总销售额):\n&quot;</span>, pivot_table)</span><br><span class="line"><span class="comment"># Region      East    West</span></span><br><span class="line"><span class="comment"># Date</span></span><br><span class="line"><span class="comment"># 2023-01-01   100.0   150.0</span></span><br><span class="line"><span class="comment"># 2023-01-02   120.0   180.0</span></span><br><span class="line"><span class="comment"># 2023-01-03   200.0     NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="八、时间序列处理"><a href="#八、时间序列处理" class="headerlink" title="八、时间序列处理"></a>八、时间序列处理</h2><p>Pandas 对时间序列数据有非常强大的支持。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建日期范围索引</span></span><br><span class="line">time_series_index = pd.date_range(<span class="string">&#x27;2023-01-01&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="number">10</span>), index=time_series_index)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n时间序列 Series:\n&quot;</span>, ts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间序列切片</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n2023-01-03 到 2023-01-07 的数据:\n<span class="subst">&#123;ts[<span class="string">&#x27;2023-01-03&#x27;</span>:<span class="string">&#x27;2023-01-07&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重采样 (Resampling)</span></span><br><span class="line"><span class="comment"># 按周求和 &#x27;W&#x27; -&gt; Week</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n按周重采样求和:\n<span class="subst">&#123;ts.resample(<span class="string">&#x27;W&#x27;</span>).<span class="built_in">sum</span>()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 按月求平均 &#x27;M&#x27; -&gt; Month</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n按月重采样求平均:\n<span class="subst">&#123;ts.resample(<span class="string">&#x27;M&#x27;</span>).mean()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[数据源: CSV, Excel, DB, JSON] --&gt; B(pd.read_csv&#x2F;excel&#x2F;sql&#x2F;json)
    B --&gt; C[DataFrame&#x2F;Series]
    C -- 探索性数据分析 (EDA) --&gt; D[&quot;df.head(), df.info(), &lt;br&gt;df.describe(), nunique(), &lt;br&gt;value_counts()&quot;]
    C -- 数据选择 &amp; 过滤 --&gt; E[&quot;df[], df.loc[], df.iloc[], &lt;br&gt;布尔索引, query()&quot;]
    C -- 数据清洗 --&gt; F[&quot;df.fillna(), df.dropna(), &lt;br&gt;df.drop_duplicates(), replace(), &lt;br&gt;rename()&quot;]
    C -- 数据转换 &amp; 特征工程 --&gt; G[&quot;df.apply(), df.astype(), &lt;br&gt;df.groupby(), df.merge(), &lt;br&gt;df.pivot_table(), pd.concat(), &lt;br&gt;pd.get_dummies()&quot;]
    G --&gt; H{分析结果&#x2F;处理后的数据}
    H -- 可视化 --&gt; I[Matplotlib, Seaborn, Plotly]
    H -- 存储 --&gt; J[&quot;df.to_csv&#x2F;excel&#x2F;sql&#x2F;json, &lt;br&gt;to_pickle()&quot;]
    J --&gt; K[报告&#x2F;模型训练&#x2F;进一步分析]

  </pre></div>


<h2 id="九、性能优化"><a href="#九、性能优化" class="headerlink" title="九、性能优化"></a>九、性能优化</h2><p>虽然 Pandas 已经非常高效，但在处理非常大的数据集时，仍需注意性能：</p>
<ul>
<li><strong>避免 Python 循环</strong>：尽可能使用 Pandas 内置的向量化操作，如 <code>df[&#39;col&#39;] * 2</code> 而非 <code>for x in df[&#39;col&#39;]: ...</code>。</li>
<li><strong>使用 <code>apply</code> 的替代方案</strong>：对于简单的函数，<code>map</code>, <code>apply</code>, <code>assign</code> 或直接的向量化操作通常比 <code>for</code> 循环快。对于复杂的行操作，考虑 <code>df.iterrows()</code> (慢) 或 <code>df.itertuples()</code> (稍快)。</li>
<li><strong>选择合适的数据类型</strong>：使用更精确的（例如 <code>int8</code> 而非 <code>int64</code>）或分类 (<code>category</code>) 类型可以节省内存和加速操作。</li>
<li><strong>优化 <code>groupby</code> 操作</strong>：<code>groupby</code> 结合 <code>agg</code> 可以一次性执行多个聚合函数。</li>
<li><strong>分块处理</strong>：对于内存无法容纳的超大数据集，可以分块读取和处理。</li>
</ul>
<h2 id="十、总结与进阶"><a href="#十、总结与进阶" class="headerlink" title="十、总结与进阶"></a>十、总结与进阶</h2><p>Pandas 是 Python 数据科学生态系统中不可或缺的工具。它以其直观的 API 和强大的功能，极大地简化了数据的加载、清洗、转换和分析过程。</p>
<p><strong>进阶方向：</strong></p>
<ul>
<li><strong>多级索引 (MultiIndex)</strong>：处理更复杂的分层数据。</li>
<li><strong>窗口函数 (Rolling &#x2F; Expanding)</strong>：进行移动平均、累计和等时间序列分析。</li>
<li><strong>Categorical 类型</strong>：优化内存使用和加速分类数据处理。</li>
<li><strong>高效内存管理</strong>：了解 Pandas 内部如何存储数据以及如何优化内存使用。</li>
<li><strong>时间序列高级操作</strong>：偏移 (shift), 滞后 (lag) 等。</li>
<li><strong>与 Matplotlib&#x2F;Seaborn 结合</strong>：深入学习数据可视化。</li>
<li><strong>使用 Pandarallel&#x2F;Dask</strong>：处理更大规模的数据集，实现并行计算。</li>
</ul>
<p>掌握 Pandas，你将拥有强大的数据处理能力，为数据分析、机器学习和数据工程任务打下坚实基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/dbdbe99385cd/">https://blog.tbf1211.xx.kg/dbdbe99385cd/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/NumPy/">NumPy</a><a class="post-meta__tags" href="/tags/Pandas/">Pandas</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">数据处理</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/109739b91598/" title="Python Matplotlib 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python Matplotlib 详解</div></div><div class="info-2"><div class="info-item-1"> Matplotlib 是一个用于创建静态、动态和交互式可视化在 Python 中的综合库。它提供了强大的工具集，用于生成各种出版质量级别的图表，从简单的线图、散点图到复杂的3D图表和动画。它是 Python 科学计算生态系统（如 NumPy, SciPy, Pandas）中不可或缺的一部分。  核心思想：提供一个灵活、可高度定制的绘图框架，让开发者能够精确控制图表的每一个细节，以满足从数据探索到学术出版的各种可视化需求。   一、为什么需要 Matplotlib？在数据分析、科学研究、工程计算等领域，数据可视化是理解数据、发现模式和传达洞察的关键。然而，手动绘制图表或使用通用工具往往效率低下且难以定制。Matplotlib 旨在解决以下问题：  数据理解：海量数据以表格形式呈现时难以理解，通过图表能够直观展示数据的分布、趋势和关系。 报告与演示：需要高质量、专业级的图表用于学术论文、商业报告或演示文稿。 定制化需求：通用绘图工具可能无法满足特定的可视化需求，需要能够对图表的每个元素（颜色、字体、线条、布局等）进行精确控制。 编程集成：希望在 Python 程序中直接生成和操作图...</div></div></div></a><a class="pagination-related" href="/0c202b3d53be/" title="前端文件下载的各种方式的详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">前端文件下载的各种方式的详解</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，文件下载是一个常见且重要的功能。无论是下载用户生成的数据、报告、图片，还是静态资源，前端开发者都需要掌握多种实现文件下载的方法。本文将详细探讨前端实现文件下载的各种技术，包括 HTML 原生方式、JavaScript 编程方式以及涉及服务器端配合的场景。  核心思想：前端文件下载的核心在于如何将文件数据（无论是服务器传输的还是客户端生成的）转化为可供浏览器识别并触发下载操作的格式（如 Blob 对象或直接的 URL），并通过特定的机制（如 &lt;a&gt; 标签的 download 属性或服务器响应头）来提示浏览器进行下载而非直接显示。   一、文件下载的基础概念在深入具体方法之前，我们先理解文件下载的一些基本概念：  下载 vs. 显示：浏览器在处理文件时，会根据 Content-Type 和 Content-Disposition 等 HTTP 响应头来决定是下载文件（保存到本地）还是在浏览器中直接显示（如图片、PDF）。 文件来源： 服务器端文件：文件存储在服务器上，前端通过 URL 请求获取。 客户端生成文件：文件内容由前端 JavaScript ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cb923ba84dd9/" title="Python NumPy详解：科学计算的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="info-item-2">Python NumPy详解：科学计算的基石</div></div><div class="info-2"><div class="info-item-1"> NumPy (Numerical Python) 是 Python 中用于科学计算的核心库。它提供了一个高性能的多维数组对象 ndarray，以及用于处理这些数组的工具。NumPy 是 Python 数据科学和机器学习生态系统的基石，许多其他库（如 SciPy, Pandas, Matplotlib, Scikit-learn）都建立在 NumPy 数组之上。  核心思想：NumPy 引入了高效的 ndarray 数据结构，通过向量化操作显著提升了 Python 处理数值数据的性能。   一、为什么选择 NumPy？Python 语言本身处理列表等数据结构时效率较高，但对于大规模数值计算而言，原生的 Python 列表效率低下。NumPy 通过以下方式解决了这个问题：  高性能 ndarray 对象：ndarray 存储同类型数据，在内存中连续存储，相比 Python 列表，占用的内存更少，访问速度更快。 向量化操作：NumPy 允许对整个数组进行操作，而无需编写显式的循环。这些操作通常在 C 或 Fortran 中实现，执行速度远超 Python 循环。 广播 (Broadc...</div></div></div></a><a class="pagination-related" href="/109739b91598/" title="Python Matplotlib 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-22</div><div class="info-item-2">Python Matplotlib 详解</div></div><div class="info-2"><div class="info-item-1"> Matplotlib 是一个用于创建静态、动态和交互式可视化在 Python 中的综合库。它提供了强大的工具集，用于生成各种出版质量级别的图表，从简单的线图、散点图到复杂的3D图表和动画。它是 Python 科学计算生态系统（如 NumPy, SciPy, Pandas）中不可或缺的一部分。  核心思想：提供一个灵活、可高度定制的绘图框架，让开发者能够精确控制图表的每一个细节，以满足从数据探索到学术出版的各种可视化需求。   一、为什么需要 Matplotlib？在数据分析、科学研究、工程计算等领域，数据可视化是理解数据、发现模式和传达洞察的关键。然而，手动绘制图表或使用通用工具往往效率低下且难以定制。Matplotlib 旨在解决以下问题：  数据理解：海量数据以表格形式呈现时难以理解，通过图表能够直观展示数据的分布、趋势和关系。 报告与演示：需要高质量、专业级的图表用于学术论文、商业报告或演示文稿。 定制化需求：通用绘图工具可能无法满足特定的可视化需求，需要能够对图表的每个元素（颜色、字体、线条、布局等）进行精确控制。 编程集成：希望在 Python 程序中直接生成和操作图...</div></div></div></a><a class="pagination-related" href="/3226a64cc8bb/" title="Python元类(Metaclass)深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="info-item-2">Python元类(Metaclass)深度解析</div></div><div class="info-2"><div class="info-item-1"> 元类 (Metaclass) 在 Python 中是一个非常高级且强大的概念，它是创建类的类。在 Python 中，一切皆对象，包括类本身。当我们定义一个类时，这个类实际上也是一个对象，而创建这个类对象的“类”就是元类。换句话说，元类是 Python 类型系统中最深层次的抽象之一，它允许开发者在类被创建时对其行为进行拦截和修改。  核心思想：如果你想在创建类时自动修改或定制类的行为（例如，添加方法、强制继承特定接口、实现单例模式等），那么元类就是你的工具。它提供了一个钩子，让你能在类定义完成后、但类对象实际实例化之前介入。   一、Python 中的“一切皆对象”与 type理解元类，首先要牢记 Python 的核心哲学：“一切皆对象”。  基本数据类型是对象：数字、字符串、列表、字典等都是对象。 123x = 10         # 10 是一个 int 对象s = &quot;hello&quot;    # &quot;hello&quot; 是一个 str 对象l = [1, 2]     # [1, 2] 是一个 list 对象  函数是对象：函数可以像其他对象一样...</div></div></div></a><a class="pagination-related" href="/1b5035114ad1/" title="Python Requests库详解：HTTP请求的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="info-item-2">Python Requests库详解：HTTP请求的艺术</div></div><div class="info-2"><div class="info-item-1"> requests 库 是 Python 生态系统中最流行、最强大、也是最优雅的 HTTP 客户端库之一。它简化了复杂的 HTTP 请求操作，让开发者能够以极少量的代码发送各种类型的 HTTP 请求，并轻松处理响应。与 Python 内置的 urllib 模块相比，requests 提供了更友好、更直观的 API，被誉为“面向人类的 HTTP 服务”。  核心思想：requests 封装了底层 HTTP 协议的复杂性，提供简洁的 API，让开发者专注于业务逻辑而非网络通信的细节。   一、为什么选择 Requests？在 Python 中进行 HTTP 请求有多种方式，例如内置的 urllib 模块。但 requests 库之所以广受欢迎，主要得益于以下优势：  友好的 API：设计直观，易学易用，代码可读性高。 功能强大：支持几乎所有 HTTP 功能，包括 GET, POST, PUT, DELETE 等方法，以及请求头、数据、文件上传、Cookie、身份认证、代理、SSL 验证等。 自动处理：自动处理 URL 编码、重定向、会话管理等常见任务。 JSON 支持：内置 JSON...</div></div></div></a><a class="pagination-related" href="/a1d408b2ddbe/" title="Python多进程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="info-item-2">Python多进程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式概述模式构成：  生产者 (Producer)：负责生成数据，并将其放入共享的缓冲区（队列）中。 消费者 (Consumer)：负责从共享的缓冲区（队列）中取出数据进行处理。 缓冲区 (Buffer &#x2F; Queue)：一个共享的数据结构，通常是一个队列，用于存储生产者生产的数据和消费者消费的数据。它充当了生产者和消费者之间的桥梁。  解决的问题：  解耦：生产者和消费者可以独立运行，互不干扰，提高系统的灵活性。 并发：允许多个生产者和多个消费者同时存在，提高处理效率。 削峰填谷：当生产速度快于消费速度时，缓冲区可以存储多余的数据，防止数...</div></div></div></a><a class="pagination-related" href="/832eaf04ac40/" title="Python多线程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="info-item-2">Python多线程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模块实现多线程版的生产者-消费者模式。  核心思想：利用线程安全的共享队列作为缓冲，实现生产者与消费者解耦，并通过队列自带的互斥锁和条件变量进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式与多线程概述1.1 生产者-消费者模式参考 Python 多进程生产者-消费者模式详解 中的概述，其核心构成和解决的问题在多线程场景下是相同的：  生产者 (Producer)：生成数据并放入队列。 消费者 (Consumer)：从队列取出数据并处理。 缓冲区 (Queue)：共享的、线程安全的数据容器。  1.2 Python 多线程与 GIL threading 模块：Python 标...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">356</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">208</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">74</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-Pandas%EF%BC%9F"><span class="toc-text">一、为什么选择 Pandas？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85-Pandas"><span class="toc-text">二、安装 Pandas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Pandas-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">三、Pandas 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Series-%E4%B8%80%E7%BB%B4%E5%B8%A6%E6%A0%87%E7%AD%BE%E6%95%B0%E7%BB%84"><span class="toc-text">3.1 Series (一维带标签数组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-DataFrame-%E4%BA%8C%E7%BB%B4%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE"><span class="toc-text">3.2 DataFrame (二维表格数据)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-I-O"><span class="toc-text">四、数据输入&#x2F;输出 (I&#x2F;O)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E4%B8%8E%E7%B4%A2%E5%BC%95"><span class="toc-text">五、数据选择与索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9"><span class="toc-text">5.1 基本选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-loc-%E5%92%8C-iloc"><span class="toc-text">5.2 loc 和 iloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95"><span class="toc-text">5.3 布尔索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E5%87%86%E5%A4%87"><span class="toc-text">六、数据清洗与准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-text">6.1 缺失值处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%87%8D%E5%A4%8D%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-text">6.2 重复值处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.3 数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">七、数据操作与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0-apply"><span class="toc-text">7.1 应用函数 (apply)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%88%86%E7%BB%84%E4%B8%8E%E8%81%9A%E5%90%88-groupby"><span class="toc-text">7.2 分组与聚合 (groupby)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%90%88%E5%B9%B6%E3%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E6%8B%BC%E6%8E%A5-merge-join-concat"><span class="toc-text">7.3 合并、连接、拼接 (merge, join, concat)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E9%80%8F%E8%A7%86%E8%A1%A8-pivot-table"><span class="toc-text">7.4 透视表 (pivot_table)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%A4%84%E7%90%86"><span class="toc-text">八、时间序列处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">九、性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E8%BF%9B%E9%98%B6"><span class="toc-text">十、总结与进阶</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go Jaeger 深度解析：分布式追踪实践"/></a><div class="content"><a class="title" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践">Go Jaeger 深度解析：分布式追踪实践</a><time datetime="2025-12-04T22:24:00.000Z" title="发表于 2025-12-05 06:24:00">2025-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/15920229f914/" title="Supabase 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supabase 深度解析"/></a><div class="content"><a class="title" href="/15920229f914/" title="Supabase 深度解析">Supabase 深度解析</a><time datetime="2025-12-02T22:24:00.000Z" title="发表于 2025-12-03 06:24:00">2025-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1ae20d2726d8/" title="MiniRTC 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MiniRTC 详解"/></a><div class="content"><a class="title" href="/1ae20d2726d8/" title="MiniRTC 详解">MiniRTC 详解</a><time datetime="2025-11-28T22:24:00.000Z" title="发表于 2025-11-29 06:24:00">2025-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/be24ef88e59a/" title="WebRTC 技术详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebRTC 技术详解"/></a><div class="content"><a class="title" href="/be24ef88e59a/" title="WebRTC 技术详解">WebRTC 技术详解</a><time datetime="2025-11-27T22:24:00.000Z" title="发表于 2025-11-28 06:24:00">2025-11-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>