<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机网络中，数据包从一个源发送到多个目的地的策略被称为通信模式。理解这些模式——单播 (Unicast)、组播 (Multicast)、广播 (Broadcast) 和任播 (Anycast)——对于网络设计、数据传输优化以及故障排除至关重要。它们定义了数据如何寻址和如何在网络中传播，各自适用于不同的应用场景，并对网络性能和资源消耗有着显著影响。  核心思想：根据数据包的目的地数量和选择策略">
<meta property="og:type" content="article">
<meta property="og:title" content="单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/dec2dcdddd31/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在计算机网络中，数据包从一个源发送到多个目的地的策略被称为通信模式。理解这些模式——单播 (Unicast)、组播 (Multicast)、广播 (Broadcast) 和任播 (Anycast)——对于网络设计、数据传输优化以及故障排除至关重要。它们定义了数据如何寻址和如何在网络中传播，各自适用于不同的应用场景，并对网络性能和资源消耗有着显著影响。  核心思想：根据数据包的目的地数量和选择策略">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg">
<meta property="article:published_time" content="2024-11-13T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:41:47.057Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解",
  "url": "https://blog.tbf1211.xx.kg/dec2dcdddd31/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg",
  "datePublished": "2024-11-13T22:24:00.000Z",
  "dateModified": "2026-02-01T09:41:47.057Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/dec2dcdddd31/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-27.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-11-13T22:24:00.000Z" title="发表于 2024-11-14 06:24:00">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在计算机网络中，数据包从一个源发送到多个目的地的策略被称为<strong>通信模式</strong>。理解这些模式——<strong>单播 (Unicast)、组播 (Multicast)、广播 (Broadcast) 和任播 (Anycast)</strong>——对于网络设计、数据传输优化以及故障排除至关重要。它们定义了数据如何寻址和如何在网络中传播，各自适用于不同的应用场景，并对网络性能和资源消耗有着显著影响。</p>
</blockquote>
<div class="note info flat"><p>核心思想：根据数据包的目的地数量和选择策略，将网络通信划分为四种基本模式，每种模式都有其独特的传输效率、资源利用和应用场景。</p>
</div>
<hr>
<h2 id="一、传输模式概述"><a href="#一、传输模式概述" class="headerlink" title="一、传输模式概述"></a>一、传输模式概述</h2><table>
<thead>
<tr>
<th align="left">传输模式</th>
<th align="left">描述</th>
<th align="left">接收方数量</th>
<th align="left">IP 地址类型</th>
<th align="left">传输效率</th>
<th align="left">主要应用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>单播</strong></td>
<td align="left">一对一传输。最常见的模式。</td>
<td align="left">1</td>
<td align="left">普通 IP 地址</td>
<td align="left">高 (点对点)</td>
<td align="left">HTTP, TCP, Telnet, SSH, FTP</td>
</tr>
<tr>
<td align="left"><strong>广播</strong></td>
<td align="left">一对所有传输，限于<strong>同一广播域</strong>内。</td>
<td align="left">所有</td>
<td align="left">广播地址 (<code>255.255.255.255</code>)</td>
<td align="left">低 (网络泛洪)</td>
<td align="left">ARP, DHCP, OLPC, 唤醒局域网</td>
</tr>
<tr>
<td align="left"><strong>组播</strong></td>
<td align="left">一对多传输，发送给<strong>特定组</strong>中的成员。</td>
<td align="left">多个</td>
<td align="left">组播地址 (<code>224.0.0.0/4</code>)</td>
<td align="left">高 (路由支持)</td>
<td align="left">视频直播, 在线游戏, OSPF, PIM</td>
</tr>
<tr>
<td align="left"><strong>任播</strong></td>
<td align="left">一对最近传输，发送给<strong>最近的一个副本</strong>。</td>
<td align="left">1 (最近的)</td>
<td align="left">多个服务器共享同一个 IP 地址</td>
<td align="left">高 (路由优化)</td>
<td align="left">DNS, CDN, DDoS 防护</td>
</tr>
</tbody></table>
<h2 id="二、单播-Unicast"><a href="#二、单播-Unicast" class="headerlink" title="二、单播 (Unicast)"></a>二、单播 (Unicast)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>单播</strong>是一种“一对一”的网络通信模式。数据包从一个发送方（源主机）传输到网络上的一个特定接收方（目的主机）。它是互联网上最基本和最常见的通信方式。</p>
<h3 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a>2.2 特点</h3><ul>
<li><strong>精确寻址</strong>：通过唯一的目的 IP 地址（和 MAC 地址）找到唯一的接收方。</li>
<li><strong>点对点</strong>：每一份数据包都只发送到一个特定的目的地。</li>
<li><strong>应用广泛</strong>：几乎所有 TCP&#x2F;IP 应用层协议都基于单播。</li>
</ul>
<h3 id="2-3-工作原理"><a href="#2-3-工作原理" class="headerlink" title="2.3 工作原理"></a>2.3 工作原理</h3><p>当一台设备要与另一台设备进行单播通信时，它会将目的设备的 IP 地址放入数据包的头部。如果目的设备在同一局域网内，源设备会通过 ARP 协议解析出目的设备的 MAC 地址，然后直接将数据包发送到该 MAC 地址。如果目的设备在不同的网络，数据包会被发送到默认网关（路由器），路由器会根据路由表将数据包转发到目标网络，直到到达目的设备。</p>
<h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul>
<li><strong>网页浏览 (HTTP&#x2F;HTTPS)</strong>：客户端请求网页服务器，服务器响应请求。</li>
<li><strong>文件传输 (FTP&#x2F;SFTP)</strong>：客户端与服务器间传输文件。</li>
<li><strong>电子邮件 (SMTP&#x2F;POP3&#x2F;IMAP)</strong>：邮件客户端与邮件服务器间的通信。</li>
<li><strong>远程登录 (SSH&#x2F;Telnet)</strong>：用户远程管理服务器。</li>
<li><strong>数据库访问</strong>：应用程序连接数据库服务器。</li>
<li><strong>VoIP (点对点通话)</strong>：两个 IP 电话之间的语音通信。</li>
</ul>
<h3 id="2-5-优点与缺点"><a href="#2-5-优点与缺点" class="headerlink" title="2.5 优点与缺点"></a>2.5 优点与缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li>简单易实现，应用范围广。</li>
<li>提供端到端的可靠性（结合 TCP）。</li>
<li>保证了通信的私密性。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>如果需要向多个接收方发送相同的数据，发送方必须为每个接收方发送一份单独的数据包副本。这会消耗发送方大量的带宽和 CPU 资源，效率低下。</li>
</ul>
</li>
</ul>
<h3 id="2-6-代码示例-Python-TCP-Simple-Unicast"><a href="#2-6-代码示例-Python-TCP-Simple-Unicast" class="headerlink" title="2.6 代码示例 (Python - TCP Simple Unicast)"></a>2.6 代码示例 (Python - TCP Simple Unicast)</h3><p><strong>Server (接收方):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span>  <span class="comment"># Standard loopback interface address (localhost)</span></span><br><span class="line">PORT = <span class="number">65432</span>        <span class="comment"># Port to listen on (non-privileged ports are &gt; 1023)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.bind((HOST, PORT))</span><br><span class="line">    s.listen()</span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="keyword">with</span> conn:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected by <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Received from client: <span class="subst">&#123;data.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">            conn.sendall(data) <span class="comment"># Echo back</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Server stopped.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Client (发送方):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span>  <span class="comment"># The server&#x27;s hostname or IP address</span></span><br><span class="line">PORT = <span class="number">65432</span>        <span class="comment"># The port used by the server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">    s.connect((HOST, PORT))</span><br><span class="line">    message = <span class="string">&quot;Hello, Unicast!&quot;</span></span><br><span class="line">    s.sendall(message.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Received from server (echo): <span class="subst">&#123;data.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Client stopped.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="三、广播-Broadcast"><a href="#三、广播-Broadcast" class="headerlink" title="三、广播 (Broadcast)"></a>三、广播 (Broadcast)</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p><strong>广播</strong>是一种“一对所有”的网络通信模式。数据包从一个发送方传输到其所在的<strong>局域网 (LAN) 内</strong>或<strong>同一广播域内</strong>的所有可达设备。</p>
<h3 id="3-2-特点"><a href="#3-2-特点" class="headerlink" title="3.2 特点"></a>3.2 特点</h3><ul>
<li><strong>网络内全体</strong>：所有接收方都必须在同一个广播域。</li>
<li><strong>路由器隔离</strong>：路由器通常会阻止广播数据包跨越子网边界，防止广播风暴。</li>
<li><strong>特殊地址</strong>：使用特殊的广播 IP 地址 (<code>255.255.255.255</code> 或特定子网的广播地址) 和广播 MAC 地址 (<code>FF:FF:FF:FF:FF:FF</code>)。</li>
</ul>
<h3 id="3-3-工作原理"><a href="#3-3-工作原理" class="headerlink" title="3.3 工作原理"></a>3.3 工作原理</h3><p>当设备发送广播数据包时，它会将目的 IP 地址设置为 <code>255.255.255.255</code> （称为受限广播地址）或其所在子网的特定广播地址（例如 <code>192.168.1.255/24</code> 的 <code>192.168.1.255</code>），并将目的 MAC 地址设置为 <code>FF:FF:FF:FF:FF:FF</code>。交换机收到广播帧后，会将其复制并转发到除了接收端口之外的所有其他端口，从而使得同一广播域内的所有设备都能收到该数据包。</p>
<h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h3><ul>
<li><strong>ARP (Address Resolution Protocol - 地址解析协议)</strong>：用于将 IP 地址解析为 MAC 地址。</li>
<li><strong>DHCP (Dynamic Host Configuration Protocol)</strong>：客户端设备在网络中寻找 DHCP 服务器以获取 IP 地址。</li>
<li><strong>Wake-on-LAN (WOL)</strong>：通过发送特殊的“魔术包”来唤醒局域网内的计算机。</li>
<li><strong>某些老旧的路由协议或服务发现协议</strong>。</li>
</ul>
<h3 id="3-5-优点与缺点"><a href="#3-5-优点与缺点" class="headerlink" title="3.5 优点与缺点"></a>3.5 优点与缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li><strong>发现服务</strong>：无需预先知道接收方的地址即可发现网络中的服务或设备。</li>
<li><strong>简单</strong>：无需复杂的路由或组成员管理。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>高网络开销</strong>：所有设备都必须处理广播数据包，即使它们不是目标。</li>
<li><strong>广播风暴</strong>：过多的广播可能导致网络拥塞和性能下降。</li>
<li><strong>安全风险</strong>：广播数据包对所有设备可见，容易被窃听。</li>
<li><strong>不可路由</strong>：广播通常被路由器隔离，无法跨越广域网。</li>
</ul>
</li>
</ul>
<h3 id="3-6-代码示例-Go-UDP-Simple-Broadcast"><a href="#3-6-代码示例-Go-UDP-Simple-Broadcast" class="headerlink" title="3.6 代码示例 (Go - UDP Simple Broadcast)"></a>3.6 代码示例 (Go - UDP Simple Broadcast)</h3><p><strong>Receiver (接收方):</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addr, err := net.ResolveUDPAddr(<span class="string">&quot;udp&quot;</span>, <span class="string">&quot;:broadcast_port&quot;</span>) <span class="comment">// Replace broadcast_port with an actual port, e.g., &quot;:8000&quot;</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error resolving UDP address:&quot;</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error listening UDP:&quot;</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Listening for broadcast messages on UDP port %s\n&quot;</span>, addr.Port)</span><br><span class="line"></span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, senderAddr, err := conn.ReadFromUDP(buffer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error reading from UDP:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Received broadcast from %s: %s\n&quot;</span>, senderAddr.String(), <span class="type">string</span>(buffer[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Sender (发送方):</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Use broadcast address and an actual port, e.g., &quot;255.255.255.255:8000&quot;</span></span><br><span class="line">	addr, err := net.ResolveUDPAddr(<span class="string">&quot;udp&quot;</span>, <span class="string">&quot;255.255.255.255:broadcast_port&quot;</span>) </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error resolving UDP address:&quot;</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error dialing UDP:&quot;</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Sending broadcast messages to %s...\n&quot;</span>, addr.String())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;Hello everyone! Message %d&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		_, err := conn.Write([]<span class="type">byte</span>(message))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Error writing to UDP:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Sent: \&quot;%s\&quot;\n&quot;</span>, message)</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>: 运行以上 Go 广播示例时，需要替换 <code>broadcast_port</code> 为一个实际的端口号，例如 <code>8000</code>。同时，发送方可能还需要在操作系统层面配置允许 UDP 广播（例如在 Linux 上设置 <code>sysctl -w net.ipv4.conf.all.rp_filter=0</code> 或 <code>net.ipv4.icmp_echo_ignore_broadcasts=0</code>，但具体取决于您的网络环境和安全策略，通常不推荐在生产环境开放）。</p>
<h2 id="四、组播-Multicast"><a href="#四、组播-Multicast" class="headerlink" title="四、组播 (Multicast)"></a>四、组播 (Multicast)</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p><strong>组播</strong>是一种“一对多”的网络通信模式。数据包从一个发送方传输到网络上一个<strong>特定组</strong>中的所有成员。只有加入了该组的设备才能接收并处理组播数据。</p>
<h3 id="4-2-特点"><a href="#4-2-特点" class="headerlink" title="4.2 特点"></a>4.2 特点</h3><ul>
<li><strong>选择性接收</strong>：只有对数据感兴趣并主动加入组播组的设备才能接收数据。</li>
<li><strong>高效性</strong>：发送方只需发送一份数据包，网络设备（路由器、支持 IGMP Snooping 的交换机）会负责将数据包智能地复制并转发给组内成员，而不是全网泛洪。</li>
<li><strong>IP 地址范围</strong>：使用特殊的 D 类 IP 地址 (<code>224.0.0.0</code> 到 <code>239.255.255.255</code>) 作为组播组的标识符。</li>
</ul>
<h3 id="4-3-工作原理"><a href="#4-3-工作原理" class="headerlink" title="4.3 工作原理"></a>4.3 工作原理</h3><p>组播的实现依赖于多项协议和机制：</p>
<ol>
<li><strong>组播组 (Multicast Group)</strong>：由一个 D 类 IP 地址标识。发送者将数据包发送到这个组播组地址，而不是特定的单播地址。</li>
<li><strong>IGMP (Internet Group Management Protocol)</strong>：<strong>接收方</strong>使用 IGMP 协议向其直连的路由器通告，表达加入或离开某个组播组的意愿。路由器根据这些报告维护每个接口上的组播组成员列表。</li>
<li><strong>组播路由协议 (Multicast Routing Protocols, 如 PIM - Protocol Independent Multicast)</strong>：<strong>路由器</strong>之间通过组播路由协议相互通信，共享组播组成员信息，并构建高效的组播分发树，以确保组播数据包沿着最佳路径从源路由到所有组内成员。路由器只将数据包转发到有组内成员的下游接口。</li>
<li><strong>IGMP Snooping (交换机)</strong>：支持 IGMP Snooping 的二层交换机可以“侦听”IGMP 报文，智能地只将组播数据流转发到连接有组成员的端口，而不是像广播一样发送到所有端口，进一步提升二层网络的效率。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    Sender[发送方] --&gt; RouterA[路由器 A]

    RouterA --- MulticastNetwork[&quot;组播网络 (IP组播路由)&quot;]

    MulticastNetwork --&gt; RouterB[路由器 B]
    MulticastNetwork --&gt; RouterC[路由器 C]
    MulticastNetwork --&gt; RouterD[路由器 D]

    RouterB -- IGMP --&gt; SwitchB[交换机 B]
    RouterC -- IGMP --&gt; SwitchC[交换机 C]
    RouterD -- IGMP --&gt; SwitchD[交换机 D]

    SwitchB --&gt; Receiver1[&quot;接收方 1 (加入组)&quot;]
    SwitchB --- PC_NotInGroup[未加入组的PC]

    SwitchC --&gt; Receiver2[&quot;接收方 2 (加入组)&quot;]
    SwitchC --&gt; Receiver3[&quot;接收方 3 (加入组)&quot;]

    SwitchD --- PC_NotInGroup2[未加入组的PC2]
  </pre></div>

<h3 id="4-4-应用场景"><a href="#4-4-应用场景" class="headerlink" title="4.4 应用场景"></a>4.4 应用场景</h3><ul>
<li><strong>IPTV&#x2F;网络直播</strong>：高效分发音视频流给大量观众。</li>
<li><strong>在线游戏</strong>：将游戏状态更新发送给多名玩家。</li>
<li><strong>股票行情信息分发</strong>：实时向大量用户推送市场数据。</li>
<li><strong>视频会议</strong>：多方参与的音视频通信。</li>
<li><strong>路由协议更新</strong>：如 OSPF、EIGRP 使用组播地址发送路由更新。</li>
<li><strong>分布式应用程序</strong>：在集群中进行服务发现和状态同步。</li>
</ul>
<h3 id="4-5-优点与缺点"><a href="#4-5-优点与缺点" class="headerlink" title="4.5 优点与缺点"></a>4.5 优点与缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li><strong>节省带宽</strong>：发送方只需发送一次数据，网络只在必要时复制数据，大大减少了网络流量。</li>
<li><strong>高效</strong>：减少了发送方和网络设备的负载。</li>
<li><strong>可扩展性</strong>：支持大规模多点传输，接收方数量对发送方影响小。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>复杂性</strong>：部署和管理比单播和广播复杂，需要网络设备（路由器、交换机）支持组播。</li>
<li><strong>无内置可靠性</strong>：组播通常基于 UDP，不保证数据包的到达顺序或可靠传输（可靠性需在应用层实现）。</li>
<li><strong>安全管理</strong>：管理组员（尤其是离开组员的清理）可能较复杂。</li>
</ul>
</li>
</ul>
<h3 id="4-6-代码示例-Python-UDP-Simple-Multicast"><a href="#4-6-代码示例-Python-UDP-Simple-Multicast" class="headerlink" title="4.6 代码示例 (Python - UDP Simple Multicast)"></a>4.6 代码示例 (Python - UDP Simple Multicast)</h3><p><strong>Receiver (接收方):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">MCAST_GRP = <span class="string">&#x27;224.1.1.1&#x27;</span> <span class="comment"># A valid multicast address</span></span><br><span class="line">MCAST_PORT = <span class="number">5007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receiver</span>():</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Allow multiple sockets to bind to the same address and port</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="comment"># SO_REUSEPORT isn&#x27;t available everywhere</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    sock.bind((<span class="string">&#x27;&#x27;</span>, MCAST_PORT)) <span class="comment"># Bind to all interfaces</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Tell the OS to add the socket to the multicast group</span></span><br><span class="line">    <span class="comment"># struct.pack(&quot;=4sl&quot;, socket.inet_aton(MCAST_GRP), socket.INADDR_ANY) </span></span><br><span class="line">    <span class="comment"># For IPv4, specify the interface to join the group</span></span><br><span class="line">    <span class="comment"># Check your local IP address for the interface you want to use</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Python 3.x with socket for IP_ADD_MEMBERSHIP</span></span><br><span class="line">    mreq = struct.pack(<span class="string">&quot;=4s4s&quot;</span>, socket.inet_aton(MCAST_GRP), socket.inet_aton(<span class="string">&quot;0.0.0.0&quot;</span>)) <span class="comment"># 0.0.0.0 means bind to &#x27;all interfaces&#x27;</span></span><br><span class="line">    sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Listening for multicast messages on <span class="subst">&#123;MCAST_GRP&#125;</span>:<span class="subst">&#123;MCAST_PORT&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data, addr = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Received multicast from <span class="subst">&#123;addr&#125;</span>: <span class="subst">&#123;data.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.timeout:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Socket timeout (no data).&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error receiving data: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    receiver()</span><br></pre></td></tr></table></figure>

<p><strong>Sender (发送方):</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">MCAST_GRP = <span class="string">&#x27;224.1.1.1&#x27;</span></span><br><span class="line">MCAST_PORT = <span class="number">5007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sender</span>():</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, <span class="number">2</span>) <span class="comment"># TTL for multicast</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sending multicast messages to <span class="subst">&#123;MCAST_GRP&#125;</span>:<span class="subst">&#123;MCAST_PORT&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        message = <span class="string">f&quot;Multicast message <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> at <span class="subst">&#123;time.ctime()&#125;</span>&quot;</span></span><br><span class="line">        sock.sendto(message.encode(<span class="string">&#x27;utf-8&#x27;</span>), (MCAST_GRP, MCAST_PORT))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sent: \&quot;<span class="subst">&#123;message&#125;</span>\&quot;&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sender()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>: 在某些系统上，<code>socket.inet_aton(&quot;0.0.0.0&quot;)</code> 可能无法正确指定接口。如果遇到问题，可以尝试将 <code>0.0.0.0</code> 替换为接收方特定网络接口的 IP 地址，例如 <code>socket.inet_aton(&quot;192.168.1.100&quot;)</code>。</p>
<h2 id="五、任播-Anycast"><a href="#五、任播-Anycast" class="headerlink" title="五、任播 (Anycast)"></a>五、任播 (Anycast)</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p><strong>任播</strong>是一种“一对最近”的网络通信模式。它允许多个独立的服务器拥有和宣告<strong>相同的 IP 地址</strong>。当客户端发送数据包到这个 IP 地址时，网络路由系统会将其引向<strong>距离最近或者路由成本最低</strong>的一个可用服务器。</p>
<h3 id="5-2-特点"><a href="#5-2-特点" class="headerlink" title="5.2 特点"></a>5.2 特点</h3><ul>
<li><strong>相同 IP，多个副本</strong>：多个服务器实例共享同一个 IP 地址。</li>
<li><strong>路由决策</strong>：路由协议 (通常是 BGP) 决定哪个服务器是“最近”的。</li>
<li><strong>无状态服务</strong>：最适合无状态或会话状态可以轻松同步的服务。</li>
<li><strong>高可用性与负载均衡</strong>：天然地提供了高可用性和粗粒度的负载均衡。</li>
</ul>
<h3 id="5-3-工作原理"><a href="#5-3-工作原理" class="headerlink" title="5.3 工作原理"></a>5.3 工作原理</h3><p>任播的实现主要依赖于路由协议（特别是 BGP）。</p>
<ol>
<li><strong>Multiple Sites Advertising Same IP</strong>: 多个地理位置分散的服务器（或服务器集群）都配置了相同的公共 Anycast IP 地址。</li>
<li><strong>Routing Protocol (BGP)</strong>: 这些服务器通过 BGP 向其各自的本地路由器宣告它们拥有这个 Anycast IP 地址段。</li>
<li><strong>Route Propagation</strong>: 本地路由器将这些路由信息传递给上游路由器和互联网骨干网。</li>
<li><strong>Client Request</strong>: 当客户端发起一个到这个 Anycast IP 地址的连接请求时，互联网的路由系统会根据路由协议的度量（如跳数、延迟、AS 路径长度等），自动将客户端的请求路由到网络拓扑结构上“最近”的那个服务器实例。</li>
<li><strong>Traffic Direction</strong>: 客户端并不知道它连接到的是哪一个具体的服务器实例，它只知道这个 IP 地址是可达的，并且流量会被导向路由选择的最近那个实例。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    Client[客户端]

    subgraph Internet
        ISP_Router1[ISP 路由器 1]
        ISP_Router2[ISP 路由器 2]
        ISP_Router3[ISP 路由器 3]
    end

    Client --&gt; ISP_Router1

    ISP_Router1 -- 路由到最近的 --&gt; ServerA[&quot;Anycast 服务器 A (共享 IP)&quot;]
    ISP_Router2 -- 路由到最近的 --&gt; ServerB[&quot;Anycast 服务器 B (共享 IP)&quot;]
    ISP_Router3 -- 路由到最近的 --&gt; ServerC[&quot;Anycast 服务器 C (共享 IP)&quot;]
  </pre></div>

<h3 id="5-4-应用场景"><a href="#5-4-应用场景" class="headerlink" title="5.4 应用场景"></a>5.4 应用场景</h3><ul>
<li><strong>DNS 根服务器和顶级域 (TLD) 服务器</strong>：部署在全球各地，Anycast 确保用户查询最近的 DNS 服务器，提高解析速度和弹性。</li>
<li><strong>CDN (Content Delivery Network - 内容分发网络)</strong>：内容提供商通过 Anycast 将用户请求导向离用户最近的 POP (Point of Presence)，加速内容传输。</li>
<li><strong>DDoS 攻击缓解</strong>：攻击流量被分散到多个 Anycast 节点，所有节点共同承受攻击，而不是集中到一个点。</li>
<li><strong>全局负载均衡</strong>：无需额外的负载均衡设备，依靠路由协议实现粗粒度的负载均衡。</li>
<li><strong>IPv6 过渡</strong>：路由器使用 Anycast 地址进行自动配置。</li>
</ul>
<h3 id="5-5-优点与缺点"><a href="#5-5-优点与缺点" class="headerlink" title="5.5 优点与缺点"></a>5.5 优点与缺点</h3><ul>
<li><strong>优点</strong>：<ul>
<li><strong>高可用性</strong>：如果一个 Anycast 节点故障，路由会自动将流量导向另一个健康的节点。</li>
<li><strong>负载均衡</strong>：将流量分散到最近的服务器，提高了系统的整体吞吐量。</li>
<li><strong>降低延迟</strong>：用户连接到物理上更近的服务器，减少了网络延迟。</li>
<li><strong>DDoS 防护</strong>：分散攻击流量，增强了抵御分布式拒绝服务攻击的能力。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>状态会话管理</strong>：如果客户端在一个 Anycast 会话中，路由发生变化导致流量被路由到另一个 Anycast 实例，并且该实例没有之前的会话状态，可能会导致会话中断（这要求 Anycast 服务通常是无状态的，或通过其他方式同步会话）。</li>
<li><strong>复杂性</strong>：部署和管理需要深入了解 BGP 路由和全球网络拓扑。</li>
<li><strong>调试困难</strong>：由于流量动态转发，调试特定实例的问题可能较复杂。</li>
</ul>
</li>
</ul>
<h3 id="5-6-代码示例-Python-连接-Anycast-IP"><a href="#5-6-代码示例-Python-连接-Anycast-IP" class="headerlink" title="5.6 代码示例 (Python - 连接 Anycast IP)"></a>5.6 代码示例 (Python - 连接 Anycast IP)</h3><p>直接编写 Anycast 的代码比较困难，因为它是一个网络基础设施层面的概念，更多发生在路由器之间。但我们可以演示客户端如何“连接”到一个 Anycast 服务，例如一个DNS服务器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ANYCAST_DNS_IP = <span class="string">&#x27;8.8.8.8&#x27;</span> <span class="comment"># Google Public DNS, often implemented with Anycast</span></span><br><span class="line">DNS_PORT = <span class="number">53</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_dns</span>(<span class="params">domain, dns_ip</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Create a UDP socket for DNS query</span></span><br><span class="line">        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        sock.settimeout(<span class="number">5</span>) <span class="comment"># Set a timeout for the response</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Simple DNS query packet (for example, requesting A record for &#x27;example.com&#x27;)</span></span><br><span class="line">        <span class="comment"># This is a very basic example; full DNS query involves more complex packet structure</span></span><br><span class="line">        dns_query_packet = <span class="string">b&#x27;\x12\x34\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07example\x03com\x00\x00\x01\x00\x01&#x27;</span></span><br><span class="line">      </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sending DNS query to <span class="subst">&#123;dns_ip&#125;</span>:<span class="subst">&#123;DNS_PORT&#125;</span> for <span class="subst">&#123;domain&#125;</span>...&quot;</span>)</span><br><span class="line">        sock.sendto(dns_query_packet, (dns_ip, DNS_PORT))</span><br><span class="line"></span><br><span class="line">        response, server_addr = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Received response from DNS server <span class="subst">&#123;server_addr&#125;</span>:&quot;</span>)</span><br><span class="line">        <span class="comment"># In a real scenario, you would parse the DNS response</span></span><br><span class="line">        <span class="comment"># For simplicity, we just print a portion of it</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Response size: <span class="subst">&#123;<span class="built_in">len</span>(response)&#125;</span> bytes&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  First 50 bytes: <span class="subst">&#123;response[:<span class="number">50</span>]&#125;</span>&quot;</span>) <span class="comment"># Show raw bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> socket.timeout:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: DNS query to <span class="subst">&#123;dns_ip&#125;</span> timed out.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 假设 8.8.8.8 是一个 Anycast IP 地址</span></span><br><span class="line">    <span class="comment"># 你的请求会被路由到离你最近的 Google DNS 服务器副本</span></span><br><span class="line">    query_dns(<span class="string">&quot;example.com&quot;</span>, ANYCAST_DNS_IP)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 也可以尝试另一个 Anycast DNS IP</span></span><br><span class="line">    <span class="comment"># query_dns(&quot;example.com&quot;, &#x27;1.1.1.1&#x27;) # Cloudflare DNS</span></span><br></pre></td></tr></table></figure>

<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>单播、组播、广播和任播是网络传输的四种基本模式，每种模式都有其独特的优点和应用场景。</p>
<ul>
<li><strong>单播</strong>是互联网通信的基石，适用于点对点、私密且可靠的连接。</li>
<li><strong>广播</strong>则在局域网内提供简单的发现和一次性通知，但其低效性限制了其用途。</li>
<li><strong>组播</strong>通过智能路由实现了高效的一对多传输，是直播、游戏和实时数据分发的理想选择。</li>
<li><strong>任播</strong>则利用路由协议提供了高可用性、低延迟和负载均衡，是 DNS 和 CDN 等全球性服务的关键技术。</li>
</ul>
<p>在设计和管理网络时，根据实际需求选择合适的传输模式至关重要，这不仅能优化网络性能、节约带宽，还能提高应用程序的可用性和用户体验。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/dec2dcdddd31/">https://blog.tbf1211.xx.kg/dec2dcdddd31/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-27.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/6b3b0892e720/" title="IPv4 (Internet Protocol version 4) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">IPv4 (Internet Protocol version 4) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv4 (Internet Protocol version 4) 是互联网协议家族（TCP&#x2F;IP 协议族）中最核心的协议之一，也是当前互联网上使用最广泛的协议。它位于 OSI 模型的网络层（第三层），负责在复杂的互联网中数据包的寻址和路由。IPv4 定义了数据包的格式以及在网络中传输和转发的机制，使得不同网络中的设备能够相互通信。尽管其地址耗尽问题催生了 IPv6，但 IPv4 仍是支撑全球互联网运行的基石。  核心思想：在互联网这个异构网络中，为每个连接的设备提供一个唯一的逻辑地址，并设计一种数据包转发机制，确保数据能从源头准确无误地传输到目的地。   一、什么是 IPv4？IPv4 是互联网协议的第四个版本。它是一种无连接的协议，意味着每个数据包都独立发送，不保证顺序或可靠性（这些由上层协议如 TCP 负责）。IPv4 的主要职责包括：  寻址 (Addressing)：为网络上的每个设备分配一个唯一的 32 位数字地址（IP 地址），用于标识设备。 路由 (Routing)：根据数据包的目的 IP 地址，决定数据包在网络中传输的最佳路径，并将其转发到下一个路...</div></div></div></a><a class="pagination-related" href="/5f39b91cbb70/" title="Golang flag 包详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang flag 包详解</div></div><div class="info-2"><div class="info-item-1"> Golang flag 包 是 Go 语言标准库中的一个核心组件，用于解析命令行参数（或称命令行标志）。它提供了一种简单且标准化的方式，让开发者能够为应用程序定义并处理各种类型的命令行选项，从而允许用户在执行程序时自定义其行为。  核心思想：通过注册预期接受的命令行标志及其默认值和使用说明，然后调用 flag.Parse() 函数，flag 包会自动解析命令行输入，并将标志值赋给对应的变量。   一、为什么需要 flag 包？在命令行环境中，应用程序经常需要接受用户提供的参数来改变其执行逻辑或配置。例如：  ./myprogram -port 8080 -verbose ./compiler -o output.exe source.go  手动解析这些参数（例如，通过 os.Args 数组）会涉及大量的字符串操作、类型转换和错误处理，这不仅繁琐且容易出错。flag 包就是为了解决这个问题而设计的：  标准化解析：遵循 POSIX 或 GNU 风格的命令行标志约定（如 -flag 或 --flag）。 类型安全：支持 string, int, bool, time.Durati...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-03</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a><a class="pagination-related" href="/b8edc2276249/" title="雪花算法 (Snowflake Algorithm) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-19</div><div class="info-item-2">雪花算法 (Snowflake Algorithm) 详解</div></div><div class="info-2"><div class="info-item-1"> 雪花算法 (Snowflake Algorithm) 是 Twitter 公司开源的一种分布式唯一 ID 生成算法。它旨在解决在分布式系统中生成全局唯一、递增（但非严格递增）且高性能 ID 的需求。其生成的 ID 是一个 64 位的整数，具有时间有序性，并且不依赖于数据库，易于扩展。  核心思想：将 64 位的 Long 型 ID 拆分为多个字段，分别存储时间戳、数据中心 ID、机器 ID 和序列号，通过位运算拼接以保证全局唯一性和大致的时间有序性。   一、为什么需要雪花算法？在分布式系统中，传统的单点自增 ID 方案面临巨大挑战：  唯一性问题：不同的数据库实例或服务节点可能生成相同的 ID。 性能瓶颈：为了保证唯一性，可能需要引入中心化的 ID 生成服务或数据库锁，成为系统瓶颈。 可用性问题：中心化服务一旦宕机，整个系统的 ID 生成将受影响。  虽然 UUID 能够保证全局唯一性，但它存在一些缺点：  存储和传输效率低：128 位，比 64 位 ID 更占用空间，索引性能较差。 无序性：UUID 是无序的，插入数据库时会导致 B+ 树索引频繁分裂和重建，影响数据库性能。...</div></div></div></a><a class="pagination-related" href="/da4a047de713/" title="中国电信 CN2 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="info-item-2">中国电信 CN2 网络详解</div></div><div class="info-2"><div class="info-item-1"> CN2 (ChinaNet Next Generation Carrying Network)，即中国电信下一代承载网络，是中国电信于 2005 年推出的新一代骨干网络。它旨在提供高质量、高可靠、低延迟的网络服务，主要面向政府、企业和高端个人用户。CN2 与传统的 ChinaNet (AS4134，163骨干网) 在架构和技术上都有显著区别，以提供更优质的国际互联体验。  核心思想：将互联网流量分为“优质”和“普通”两类通道，CN2 提供优质通道，通过更少的跳数、更小的丢包率和更低的延迟，显著提升国际互联的稳定性和速度。   一、为什么需要 CN2？1.1 ChinaNet (163骨干网) 的局限性传统的中国电信互联网骨干网，通常被称为 163 网（因其 AS 号为 4134，而 163 是其常用接入号），是国内用户最广泛使用的网络。然而，163 网在国际互联方面存在一些固有的问题：  链路拥堵：作为最常用的骨干网，163 网承载了大量流量，尤其在国际出口处容易出现拥堵，导致延迟高、丢包率大。 路由跳数多：在国际互联时，163 网的路由路径通常较长，经过的中间节点和运营商较多...</div></div></div></a><a class="pagination-related" href="/6b3b0892e720/" title="IPv4 (Internet Protocol version 4) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-16</div><div class="info-item-2">IPv4 (Internet Protocol version 4) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv4 (Internet Protocol version 4) 是互联网协议家族（TCP&#x2F;IP 协议族）中最核心的协议之一，也是当前互联网上使用最广泛的协议。它位于 OSI 模型的网络层（第三层），负责在复杂的互联网中数据包的寻址和路由。IPv4 定义了数据包的格式以及在网络中传输和转发的机制，使得不同网络中的设备能够相互通信。尽管其地址耗尽问题催生了 IPv6，但 IPv4 仍是支撑全球互联网运行的基石。  核心思想：在互联网这个异构网络中，为每个连接的设备提供一个唯一的逻辑地址，并设计一种数据包转发机制，确保数据能从源头准确无误地传输到目的地。   一、什么是 IPv4？IPv4 是互联网协议的第四个版本。它是一种无连接的协议，意味着每个数据包都独立发送，不保证顺序或可靠性（这些由上层协议如 TCP 负责）。IPv4 的主要职责包括：  寻址 (Addressing)：为网络上的每个设备分配一个唯一的 32 位数字地址（IP 地址），用于标识设备。 路由 (Routing)：根据数据包的目的 IP 地址，决定数据包在网络中传输的最佳路径，并将其转发到下一个路...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-text">一、传输模式概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E6%92%AD-Unicast"><span class="toc-text">二、单播 (Unicast)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%89%B9%E7%82%B9"><span class="toc-text">2.2 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.3 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.4 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">2.5 优点与缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Python-TCP-Simple-Unicast"><span class="toc-text">2.6 代码示例 (Python - TCP Simple Unicast)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B9%BF%E6%92%AD-Broadcast"><span class="toc-text">三、广播 (Broadcast)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%89%B9%E7%82%B9"><span class="toc-text">3.2 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">3.3 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.4 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">3.5 优点与缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Go-UDP-Simple-Broadcast"><span class="toc-text">3.6 代码示例 (Go - UDP Simple Broadcast)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%84%E6%92%AD-Multicast"><span class="toc-text">四、组播 (Multicast)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">4.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%89%B9%E7%82%B9"><span class="toc-text">4.2 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.3 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4.4 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">4.5 优点与缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Python-UDP-Simple-Multicast"><span class="toc-text">4.6 代码示例 (Python - UDP Simple Multicast)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BB%BB%E6%92%AD-Anycast"><span class="toc-text">五、任播 (Anycast)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">5.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%89%B9%E7%82%B9"><span class="toc-text">5.2 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">5.3 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5.4 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">5.5 优点与缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Python-%E8%BF%9E%E6%8E%A5-Anycast-IP"><span class="toc-text">5.6 代码示例 (Python - 连接 Anycast IP)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-27.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>