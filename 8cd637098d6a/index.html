<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Makefile 详解与使用技巧 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Makefile 是一个强大的工具，用于自动化管理和编译 C&#x2F;C++ 项目。它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者高效地构建应用程序、库等。对于 C&#x2F;C++ 项目而言，Makefile 不仅能简化复杂的编译链接过程，还能实现增量编译，大大提高开发效率。  核心思想：跟踪文件的时间戳，仅重新编译自上次构建以来发生更改的源文件及其依赖项。   一、C&amp;#x2">
<meta property="og:type" content="article">
<meta property="og:title" content="Makefile 详解与使用技巧">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/8cd637098d6a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Makefile 是一个强大的工具，用于自动化管理和编译 C&#x2F;C++ 项目。它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者高效地构建应用程序、库等。对于 C&#x2F;C++ 项目而言，Makefile 不仅能简化复杂的编译链接过程，还能实现增量编译，大大提高开发效率。  核心思想：跟踪文件的时间戳，仅重新编译自上次构建以来发生更改的源文件及其依赖项。   一、C&amp;#x2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg">
<meta property="article:published_time" content="2025-02-15T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-25T07:28:35.493Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="CI&#x2F;CD">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Makefile">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Makefile 详解与使用技巧",
  "url": "https://blog.tbf1211.xx.kg/8cd637098d6a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg",
  "datePublished": "2025-02-15T22:24:00.000Z",
  "dateModified": "2025-11-25T07:28:35.493Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/8cd637098d6a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Makefile 详解与使用技巧',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">319</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">200</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">70</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Makefile 详解与使用技巧</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Makefile 详解与使用技巧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-02-15T22:24:00.000Z" title="发表于 2025-02-16 06:24:00">2025-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/CI-CD/">CI/CD</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/8cd637098d6a/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Makefile</strong> 是一个强大的工具，用于自动化管理和编译 C&#x2F;C++ 项目。它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者高效地构建应用程序、库等。对于 C&#x2F;C++ 项目而言，Makefile 不仅能简化复杂的编译链接过程，还能实现增量编译，大大提高开发效率。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>跟踪文件的时间戳，仅重新编译自上次构建以来发生更改的源文件及其依赖项。</strong></p>
</div>
<hr>
<h2 id="一、C-C-项目构建概述"><a href="#一、C-C-项目构建概述" class="headerlink" title="一、C&#x2F;C++ 项目构建概述"></a>一、C&#x2F;C++ 项目构建概述</h2><p>在深入 Makefile 之前，理解 C&#x2F;C++ 代码的构建流程至关重要。一个典型的 C&#x2F;C++ 编译链接过程包括以下四个主要阶段：</p>
<ol>
<li><strong>预处理 (Preprocessing)</strong>：处理器根据预处理指令（如 <code>#include</code>, <code>#define</code>）对源代码进行文本替换，宏展开，并移除注释。生成的文件通常是 <code>.i</code> (C) 或 <code>.ii</code> (C++)。</li>
<li><strong>编译 (Compilation)</strong>：编译器将预处理后的代码翻译成汇编代码。此阶段会进行语法分析、类型检查等。生成的文件是 <code>.s</code>。</li>
<li><strong>汇编 (Assembly)</strong>：汇编器将汇编代码转换成机器码，生成目标文件 (Object File)。这些文件是平台特定的二进制文件，但尚未完全链接，例如函数调用和全局变量的地址尚未确定。生成的文件是 <code>.o</code> (Linux&#x2F;macOS) 或 <code>.obj</code> (Windows)。</li>
<li><strong>链接 (Linking)</strong>：链接器将所有目标文件（包括程序自身的目标文件和引用的库文件）合并，解析所有的符号引用，生成最终的可执行文件或库文件。</li>
</ol>
<p><strong>为什么需要 Makefile？</strong></p>
<ul>
<li><strong>简化重复工作</strong>：手动输入复杂的编译命令既繁琐又容易出错，特别是对于包含多个源文件的项目。</li>
<li><strong>增量编译</strong>：当项目中只有一个或几个文件发生改变时，Makefile 可以智能地只重新编译这些改变的文件及其直接依赖项，而不是每次都编译整个项目，从而节省大量时间。</li>
<li><strong>项目管理</strong>：Makefile 提供了一种标准化的方式来定义项目的构建步骤，便于团队协作和项目维护。</li>
<li><strong>平台适应性</strong>：尽管 Makefile 本身是通用的，但通过变量和条件语句，可以适应不同的编译器、操作系统和构建环境。</li>
</ul>
<h2 id="二、Makefile-基本语法回顾"><a href="#二、Makefile-基本语法回顾" class="headerlink" title="二、Makefile 基本语法回顾"></a>二、Makefile 基本语法回顾</h2><p>Makefile 的核心是<strong>规则 (Rules)</strong>。一个规则定义了如何生成一个或多个<strong>目标 (Target)</strong> 文件，这些目标依赖于哪些<strong>依赖 (Prerequisites)</strong> 文件，以及如何执行<strong>命令 (Commands)</strong> 来生成目标。</p>
<h3 id="2-1-规则-Rules-：目标、依赖、命令"><a href="#2-1-规则-Rules-：目标、依赖、命令" class="headerlink" title="2.1 规则 (Rules)：目标、依赖、命令"></a>2.1 规则 (Rules)：目标、依赖、命令</h3><p>基本语法结构：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>target (目标)</strong>：通常是要生成的文件，如可执行文件 (<code>program</code>) 或目标文件 (<code>main.o</code>)。也可以是伪目标 (Phony Target)，如 <code>all</code> 或 <code>clean</code>。</li>
<li><strong>prerequisites (依赖)</strong>：生成目标文件所需要的文件列表。如果任何一个依赖文件比目标文件新，或者目标文件不存在，则需要执行命令重新生成目标。</li>
<li><strong>command (命令)</strong>：生成目标文件所执行的 shell 命令。<strong>注意：命令前必须使用 Tab 键缩进，而不是空格。</strong></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">program: main.o utils.o</span></span><br><span class="line">    gcc main.o utils.o -o program</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c utils.h</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>program</code> 依赖于 <code>main.o</code> 和 <code>utils.o</code>。</li>
<li><code>main.o</code> 依赖于 <code>main.c</code> 和 <code>utils.h</code>。</li>
</ul>
<h3 id="2-2-变量-Variables"><a href="#2-2-变量-Variables" class="headerlink" title="2.2 变量 (Variables)"></a>2.2 变量 (Variables)</h3><p>变量用于在 Makefile 中存储和重用字符串。</p>
<ul>
<li><strong>递归扩展变量 (<code>=</code>)</strong>：最常见的变量类型。它的值会在变量被使用时才进行扩展。这意味着如果变量的值中引用了其他变量，那些变量也会在此时被扩展。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOO = <span class="variable">$(BAR)</span></span><br><span class="line">BAR = Hello</span><br><span class="line"><span class="comment"># FOO 在使用时才扩展，结果为 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>简单扩展变量 (<code>:=</code>)</strong>：变量在定义时立即扩展。如果变量的值中引用了其他变量，那些变量必须在此之前定义。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BAR := Hello</span><br><span class="line">FOO := <span class="variable">$(BAR)</span> World</span><br><span class="line"><span class="comment"># FOO 立即扩展为 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>条件赋值变量 (<code>?=</code>)</strong>：如果变量没有被定义过，则将其赋值。如果已经定义过，则保持原有值不变。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS ?= -O2 -Wall</span><br><span class="line"><span class="comment"># 如果 CFLAGS 未定义，则赋值为 &quot;-O2 -Wall&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>export</code> 变量</strong>：用于将 Makefile 中的变量传递给其执行的 shell 命令或子 Make 进程。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> CFLAGS = -Wall -g</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -O2</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-自动变量-Automatic-Variables"><a href="#2-3-自动变量-Automatic-Variables" class="headerlink" title="2.3 自动变量 (Automatic Variables)"></a>2.3 自动变量 (Automatic Variables)</h3><p>自动变量是 Make 在执行规则命令时自动设置的特殊变量，它们的值取决于当前规则的上下文。</p>
<ul>
<li><strong><code>$@</code></strong>：规则的目标文件的完整名称。</li>
<li><strong><code>$&lt;</code></strong>：规则的第一个依赖文件的名称。</li>
<li><strong><code>$^</code></strong>：规则的所有依赖文件的名称，以空格分隔，且不重复。</li>
<li><strong><code>$+</code></strong>：规则的所有依赖文件的名称，以空格分隔，允许重复（当依赖列表中有模式规则的展开时有用）。</li>
<li><strong><code>$?</code></strong>：所有比目标文件新的依赖文件的名称，以空格分隔。</li>
<li><strong><code>$*</code></strong>：模式规则中，<code>%</code> 匹配到的部分（stem）。例如，在 <code>%.o: %.c</code> 的规则中，如果目标是 <code>main.o</code>，则 <code>$*</code> 为 <code>main</code>。</li>
</ul>
<h3 id="2-4-伪目标-Phony-Targets"><a href="#2-4-伪目标-Phony-Targets" class="headerlink" title="2.4 伪目标 (Phony Targets)"></a>2.4 伪目标 (Phony Targets)</h3><p>伪目标是那些不对应实际文件的目标。它们通常用于执行特定的操作，如 <code>clean</code> (清理文件) 或 <code>all</code> (构建所有)。为了避免与实际文件名冲突，应使用 <code>.PHONY</code> 声明它们。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: program # &#x27;all&#x27; 依赖于 &#x27;program&#x27;，通常作为默认目标</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f program *.o *.d <span class="comment"># 删除可执行文件、目标文件和依赖文件</span></span><br></pre></td></tr></table></figure>
<p>声明为伪目标后，即使当前目录下存在名为 <code>all</code> 或 <code>clean</code> 的文件，Make 也总是会执行与伪目标关联的命令。</p>
<h3 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h3><p>使用 <code>#</code> 符号来添加注释。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个 Makefile 注释</span></span><br><span class="line">CC = gcc <span class="comment"># 定义 C 编译器</span></span><br></pre></td></tr></table></figure>

<h2 id="三、C-C-项目构建的-Makefile-核心要素"><a href="#三、C-C-项目构建的-Makefile-核心要素" class="headerlink" title="三、C&#x2F;C++ 项目构建的 Makefile 核心要素"></a>三、C&#x2F;C++ 项目构建的 Makefile 核心要素</h2><h3 id="3-1-定义编译器和编译选项"><a href="#3-1-定义编译器和编译选项" class="headerlink" title="3.1 定义编译器和编译选项"></a>3.1 定义编译器和编译选项</h3><p>这是 C&#x2F;C++ 项目 Makefile 的基石。</p>
<ul>
<li><strong><code>CC</code></strong>：C 编译器 (<code>gcc</code>, <code>clang</code>)</li>
<li><strong><code>CXX</code></strong>：C++ 编译器 (<code>g++</code>, <code>clang++</code>)</li>
<li><strong><code>CFLAGS</code></strong>：C 语言编译器的标志 (Flags)，如 <code>-Wall</code> (开启所有警告), <code>-O2</code> (优化级别2), <code>-g</code> (生成调试信息), <code>-std=c11</code> (C语言标准)。</li>
<li><strong><code>CXXFLAGS</code></strong>：C++ 语言编译器的标志，与 <code>CFLAGS</code> 类似，但针对 C++ 特性，如 <code>-std=c++17</code>。</li>
<li><strong><code>LDFLAGS</code></strong>：链接器的标志，如 <code>-L/path/to/lib</code> (指定库文件搜索路径), <code>-lm</code> (链接数学库)。</li>
<li><strong><code>CPPFLAGS</code></strong>：预处理器标志，通常用于定义宏 (<code>-DDEBUG</code>) 或指定头文件搜索路径 (<code>-I/path/to/include</code>)。<strong>注意：这与 <code>CXXFLAGS</code> 不同。</strong></li>
<li><strong><code>INCLUDE_DIRS</code></strong>：额外的头文件搜索路径，方便管理。</li>
<li><strong><code>LIB_DIRS</code></strong>：额外的库文件搜索路径。</li>
<li><strong><code>LIBS</code></strong>：需要链接的库文件，如 <code>-lprotobuf -lpthread</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译标志</span></span><br><span class="line">CFLAGS = -Wall -Wextra -g</span><br><span class="line">CXXFLAGS = -Wall -Wextra -g -std=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理器标志 (用于头文件路径)</span></span><br><span class="line">CPPFLAGS = -I./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接器标志 (用于库文件路径)</span></span><br><span class="line">LDFLAGS = -L./lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要链接的库</span></span><br><span class="line">LIBS = -lm -lpthread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试模式 (通过命令行 make DEBUG=1 开启)</span></span><br><span class="line"><span class="keyword">ifdef</span> DEBUG</span><br><span class="line">    CFLAGS += -DDEBUG</span><br><span class="line">    CXXFLAGS += -DDEBUG</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-源码和目标文件管理"><a href="#3-2-源码和目标文件管理" class="headerlink" title="3.2 源码和目标文件管理"></a>3.2 源码和目标文件管理</h3><p>为了方便管理大量源文件，通常使用变量来存储源文件列表，并自动生成对应的目标文件列表。</p>
<ul>
<li><strong><code>SRCS</code></strong>：源文件列表。</li>
<li><strong><code>OBJS</code></strong>：目标文件列表。</li>
</ul>
<p><strong>方法一：使用 <code>wildcard</code> 和 <code>patsubst</code> 函数</strong><br><code>wildcard</code>：查找匹配指定模式的文件。<br><code>patsubst</code>：进行模式替换。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下所有 .c 和 .cpp 源文件</span></span><br><span class="line">C_SRCS := <span class="variable">$(<span class="built_in">wildcard</span> src/*.c)</span></span><br><span class="line">CXX_SRCS := <span class="variable">$(<span class="built_in">wildcard</span> src/*.cpp)</span></span><br><span class="line">SRCS := <span class="variable">$(C_SRCS)</span> <span class="variable">$(CXX_SRCS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 .c 和 .cpp 替换为 .o</span></span><br><span class="line">C_OBJS := <span class="variable">$(<span class="built_in">patsubst</span> src/%.c, obj/%.o, <span class="variable">$(C_SRCS)</span>)</span></span><br><span class="line">CXX_OBJS := <span class="variable">$(<span class="built_in">patsubst</span> src/%.cpp, obj/%.o, <span class="variable">$(CXX_SRCS)</span>)</span></span><br><span class="line">OBJS := <span class="variable">$(C_OBJS)</span> <span class="variable">$(CXX_OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 obj 目录存在</span></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p obj)</span> <span class="comment"># 在 Make 执行前创建目录</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用变量替换 (适用于简单的文件路径)</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRCS := main.c utils.c helper.c</span><br><span class="line">OBJS := $(SRCS:.c=.o) <span class="comment"># 将所有 .c 替换为 .o</span></span><br></pre></td></tr></table></figure>
<p>此方法仅适用于单一后缀替换，且不会改变目录结构。</p>
<h3 id="3-3-编译规则-c-到-o-cpp-到-o"><a href="#3-3-编译规则-c-到-o-cpp-到-o" class="headerlink" title="3.3 编译规则 (.c 到 .o &#x2F; .cpp 到 .o)"></a>3.3 编译规则 (<code>.c</code> 到 <code>.o</code> &#x2F; <code>.cpp</code> 到 <code>.o</code>)</h3><p>这是 Makefile 中最重要的部分，定义了如何将源文件编译成目标文件。</p>
<ul>
<li><p><strong>模式规则 (Pattern Rules)</strong>：使用 <code>%</code> 作为通配符来定义一组相似的规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># C 文件的编译规则</span></span><br><span class="line"><span class="section">obj/%.o: src/%.c <span class="variable">$(CPPFLAGS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C++ 文件的编译规则</span></span><br><span class="line"><span class="section">obj/%.o: src/%.cpp <span class="variable">$(CPPFLAGS)</span></span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>这条规则表示：任何位于 <code>obj/</code> 目录下的 <code>.o</code> 文件，如果其对应的 <code>src/</code> 目录下的 <code>.c</code> (或 <code>.cpp</code>) 文件更新，就执行相应的编译命令。<code>$&lt;</code> 会自动替换为 <code>src/%.c</code> (或 <code>src/%.cpp</code>)，<code>$@</code> 会自动替换为 <code>obj/%.o</code>。</p>
</li>
</ul>
<h3 id="3-4-链接规则-生成可执行文件"><a href="#3-4-链接规则-生成可执行文件" class="headerlink" title="3.4 链接规则 (生成可执行文件)"></a>3.4 链接规则 (生成可执行文件)</h3><p>最后一步是将所有目标文件链接成一个可执行文件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TARGET = my_program</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIBS)</span> -o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>my_program</code> 依赖于所有的目标文件 <code>$(OBJS)</code>。当任何一个目标文件更新时，<code>my_program</code> 都将被重新链接。</p>
<h3 id="3-5-静态库和动态库"><a href="#3-5-静态库和动态库" class="headerlink" title="3.5 静态库和动态库"></a>3.5 静态库和动态库</h3><p>在 C&#x2F;C++ 项目中，经常需要构建和使用库。</p>
<ul>
<li><strong>静态库 (<code>.a</code> &#x2F; <code>.lib</code>)</strong>：在链接时将库中的代码直接拷贝到可执行文件中。优点是部署简单，无需担心库文件缺失；缺点是文件较大，且更新库需要重新链接。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STATIC_LIB = libfoo.a</span><br><span class="line">LIB_SRCS = foo1.c foo2.c</span><br><span class="line">LIB_OBJS = $(LIB_SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(STATIC_LIB)</span>: <span class="variable">$(LIB_OBJS)</span></span><br><span class="line">    ar rcs <span class="variable">$@</span> <span class="variable">$^</span> <span class="comment"># ar 是归档工具，rcs 参数用于创建或更新静态库</span></span><br></pre></td></tr></table></figure></li>
<li><strong>动态库&#x2F;共享库 (<code>.so</code> &#x2F; <code>.dylib</code> &#x2F; <code>.dll</code>)</strong>：在程序运行时才加载。优点是节省磁盘空间，多个程序可以共享同一个库实例，更新库无需重新链接程序；缺点是部署时需要确保库文件存在。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DYNAMIC_LIB = libbar.so</span><br><span class="line">LIB_SRCS = bar1.c bar2.c</span><br><span class="line">LIB_OBJS = $(LIB_SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时需要生成位置无关代码 (PIC)</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -fPIC -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DYNAMIC_LIB)</span>: <span class="variable">$(LIB_OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -shared -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四、高级特性与最佳实践"><a href="#四、高级特性与最佳实践" class="headerlink" title="四、高级特性与最佳实践"></a>四、高级特性与最佳实践</h2><h3 id="4-1-自动生成依赖文件-Dependency-Generation"><a href="#4-1-自动生成依赖文件-Dependency-Generation" class="headerlink" title="4.1 自动生成依赖文件 (Dependency Generation)"></a>4.1 自动生成依赖文件 (Dependency Generation)</h3><p>手动维护头文件依赖非常麻烦且容易出错。<code>gcc</code>&#x2F;<code>g++</code> 提供了一个强大的功能，可以自动生成 <code>.d</code> (dependency) 文件，其中包含了源文件所依赖的所有头文件。</p>
<ul>
<li><strong><code>gcc -MMD -MP</code></strong>：<ul>
<li><code>-MMD</code>：生成依赖文件，格式适合包含到 Makefile 中。</li>
<li><code>-MP</code>：为每个头文件生成一个伪目标，确保在头文件被删除时 Make 不会报错。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -Wextra -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件和目标文件</span></span><br><span class="line">SRCS := main.c utils.c</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖文件 (例如 main.d, utils.d)</span></span><br><span class="line">DEPS := $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = my_program</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 C 文件并生成依赖文件</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -MMD -MP -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含所有的依赖文件。当 Make 读取到 `include` 语句时，</span></span><br><span class="line"><span class="comment"># 它会去查找 `.d` 文件，并将其内容（即依赖关系）合并到当前 Makefile 中。</span></span><br><span class="line"><span class="comment"># `-include` 会忽略不存在的依赖文件，在首次编译时非常有用。</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>现在，当 <code>utils.h</code> 发生变化时，<code>main.o</code> (如果 <code>main.c</code> 包含了 <code>utils.h</code>) 将会自动重新编译，即使 <code>main.c</code> 本身没有改动。</p>
<h3 id="4-2-递归-Make-Recursive-Make"><a href="#4-2-递归-Make-Recursive-Make" class="headerlink" title="4.2 递归 Make (Recursive Make)"></a>4.2 递归 Make (Recursive Make)</h3><p>对于大型项目，如果将其划分为多个子目录，每个子目录有自己的 Makefile，可以使用递归 Make 来管理。</p>
<p><strong>项目结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── src</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── tests</span><br><span class="line">│   └── Makefile</span><br></pre></td></tr></table></figure>

<p><strong>顶层 <code>Makefile</code></strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SUBDIRS = src tests</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @for dir in <span class="variable">$(SUBDIRS)</span>; do \</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C $$dir; \</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    @for dir in <span class="variable">$(SUBDIRS)</span>; do \</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C $$dir clean; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$(MAKE) -C $$dir</code>：在 <code>$$dir</code> 目录下执行 <code>make</code> 命令。</li>
<li><code>@</code>：在执行命令时，不打印命令本身。</li>
</ul>
<h3 id="4-3-条件语句-Conditional-Directives"><a href="#4-3-条件语句-Conditional-Directives" class="headerlink" title="4.3 条件语句 (Conditional Directives)"></a>4.3 条件语句 (Conditional Directives)</h3><p>根据变量的值或是否定义，包含或排除部分 Makefile 内容。</p>
<ul>
<li><strong><code>ifeq</code> &#x2F; <code>ifneq</code></strong>：判断两个参数是否相等&#x2F;不相等。</li>
<li><strong><code>ifdef</code> &#x2F; <code>ifndef</code></strong>：判断一个变量是否已定义&#x2F;未定义。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设通过命令行 make DEBUG=1 来切换调试模式</span></span><br><span class="line"><span class="keyword">ifdef</span> DEBUG</span><br><span class="line">    CFLAGS += -DDEBUG -g</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CFLAGS += -O2</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Make-内置函数"><a href="#4-4-Make-内置函数" class="headerlink" title="4.4 Make 内置函数"></a>4.4 Make 内置函数</h3><p>Make 提供了丰富的函数来处理字符串和文件列表。</p>
<ul>
<li><code>$(wildcard PATTERN)</code>：查找与 <code>PATTERN</code> 匹配的文件。</li>
<li><code>$(patsubst PATTERN,REPLACEMENT,TEXT)</code>：在 <code>TEXT</code> 中查找 <code>PATTERN</code>，并替换为 <code>REPLACEMENT</code>。</li>
<li><code>$(shell COMMAND)</code>：执行 shell 命令并返回其输出。</li>
</ul>
<h3 id="4-5-并行构建"><a href="#4-5-并行构建" class="headerlink" title="4.5 并行构建"></a>4.5 并行构建</h3><p>使用 <code>make -j N</code> 可以并行执行 <code>N</code> 个编译任务，显著加快大型项目的构建速度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 8 <span class="comment"># 使用 8 个并行任务</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：并行构建要求 Makefile 中的依赖关系必须正确无误，否则可能导致构建失败。自动生成依赖文件 (<code>-MMD -MP</code>) 对此非常有帮助。</p>
<h2 id="五、C-C-Makefile-完整示例"><a href="#五、C-C-Makefile-完整示例" class="headerlink" title="五、C&#x2F;C++ Makefile 完整示例"></a>五、C&#x2F;C++ Makefile 完整示例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======================================================================</span></span><br><span class="line"><span class="comment"># C/C++ 项目的 Makefile 模板</span></span><br><span class="line"><span class="comment"># ======================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 项目配置 ---</span></span><br><span class="line">TARGET = my_application</span><br><span class="line">BUILD_DIR = build</span><br><span class="line">SRC_DIR = src</span><br><span class="line">INCLUDE_DIR = <span class="keyword">include</span></span><br><span class="line">LIB_DIR = lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 编译器和编译选项 ---</span></span><br><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用编译标志</span></span><br><span class="line">COMMON_CFLAGS = -Wall -Wextra -MMD -MP <span class="comment"># -MMD -MP 自动生成依赖</span></span><br><span class="line">COMMON_CXXFLAGS = -Wall -Wextra -MMD -MP -std=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试模式 (默认关闭)</span></span><br><span class="line">DEBUG ?= 0</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, 1)</span><br><span class="line">    COMMON_CFLAGS += -g -DDEBUG</span><br><span class="line">    COMMON_CXXFLAGS += -g -DDEBUG</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    COMMON_CFLAGS += -O2</span><br><span class="line">    COMMON_CXXFLAGS += -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理器标志 (头文件路径)</span></span><br><span class="line">CPPFLAGS = -I<span class="variable">$(INCLUDE_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接器标志 (库文件路径)</span></span><br><span class="line">LDFLAGS = -L<span class="variable">$(LIB_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要链接的库</span></span><br><span class="line">LIBS = -lm -lpthread</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 文件管理 ---</span></span><br><span class="line"><span class="comment"># 查找所有的 C 和 C++ 源文件</span></span><br><span class="line">C_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br><span class="line">CXX_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.cpp)</span></span><br><span class="line">SRCS = <span class="variable">$(C_SRCS)</span> <span class="variable">$(CXX_SRCS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对应的目标文件路径</span></span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(C_SRCS)</span>)</span></span><br><span class="line">CXX_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.cpp, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(CXX_SRCS)</span>)</span></span><br><span class="line">OBJS = <span class="variable">$(C_OBJS)</span> <span class="variable">$(CXX_OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对应的依赖文件路径</span></span><br><span class="line">C_DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c, <span class="variable">$(BUILD_DIR)</span>/%.d, <span class="variable">$(C_SRCS)</span>)</span></span><br><span class="line">CXX_DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.cpp, <span class="variable">$(BUILD_DIR)</span>/%.d, <span class="variable">$(CXX_SRCS)</span>)</span></span><br><span class="line">DEPS = <span class="variable">$(C_DEPS)</span> <span class="variable">$(CXX_DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 伪目标 ---</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean rebuild run</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标：构建整个项目</span></span><br><span class="line"><span class="section">all: <span class="variable">$(BUILD_DIR)</span> <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新构建 (先清理再构建)</span></span><br><span class="line"><span class="section">rebuild: clean all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序</span></span><br><span class="line"><span class="section">run: <span class="variable">$(TARGET)</span></span></span><br><span class="line">    ./<span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    @echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">    @rm -rf <span class="variable">$(BUILD_DIR)</span> <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 规则 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建构建目录</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>:</span><br><span class="line">    @mkdir -p <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 链接可执行文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    @echo <span class="string">&quot;Linking <span class="variable">$(TARGET)</span>...&quot;</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(LIBS)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 编译 C 源文件到目标文件</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">    @echo <span class="string">&quot;Compiling C: <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(COMMON_CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 编译 C++ 源文件到目标文件</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.cpp</span><br><span class="line">    @echo <span class="string">&quot;Compiling C++: <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(COMMON_CXXFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 包含自动生成的依赖文件</span></span><br><span class="line"><span class="comment"># -include 使得在依赖文件不存在时不会报错，在首次编译时非常重要</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================================================================</span></span><br><span class="line"><span class="comment"># 举例项目文件结构:</span></span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ├── Makefile</span></span><br><span class="line"><span class="comment"># ├── src/</span></span><br><span class="line"><span class="comment"># │   ├── main.cpp</span></span><br><span class="line"><span class="comment"># │   └── utils.c</span></span><br><span class="line"><span class="comment"># └── include/</span></span><br><span class="line"><span class="comment">#     └── utils.h</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># main.cpp:</span></span><br><span class="line"><span class="comment"># #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment"># #include &quot;utils.h&quot;</span></span><br><span class="line"><span class="comment"># int main() &#123;</span></span><br><span class="line"><span class="comment">#     std::cout &lt;&lt; &quot;Hello from C++!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">#     c_function();</span></span><br><span class="line"><span class="comment">#     return 0;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># utils.c:</span></span><br><span class="line"><span class="comment"># #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"># #include &quot;utils.h&quot;</span></span><br><span class="line"><span class="comment"># void c_function() &#123;</span></span><br><span class="line"><span class="comment">#     printf(&quot;Hello from C!\n&quot;);</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># utils.h:</span></span><br><span class="line"><span class="comment"># #ifndef UTILS_H</span></span><br><span class="line"><span class="comment"># #define UTILS_H</span></span><br><span class="line"><span class="comment"># #ifdef __cplusplus</span></span><br><span class="line"><span class="comment"># extern &quot;C&quot; &#123;</span></span><br><span class="line"><span class="comment"># #endif</span></span><br><span class="line"><span class="comment"># void c_function();</span></span><br><span class="line"><span class="comment"># #ifdef __cplusplus</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment"># #endif</span></span><br><span class="line"><span class="comment"># #endif</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用方式:</span></span><br><span class="line"><span class="comment"># make          # 编译应用程序</span></span><br><span class="line"><span class="comment"># make clean    # 清理生成的文件</span></span><br><span class="line"><span class="comment"># make rebuild  # 清理并重新编译</span></span><br><span class="line"><span class="comment"># make run      # 编译并运行程序</span></span><br><span class="line"><span class="comment"># make DEBUG=1  # 编译调试版本</span></span><br><span class="line"><span class="comment"># ======================================================================</span></span><br></pre></td></tr></table></figure>

<h2 id="六、Makefile-与其他-C-C-构建工具"><a href="#六、Makefile-与其他-C-C-构建工具" class="headerlink" title="六、Makefile 与其他 C&#x2F;C++ 构建工具"></a>六、Makefile 与其他 C&#x2F;C++ 构建工具</h2><p>虽然 Makefile 强大且灵活，但在大型、复杂的 C&#x2F;C++ 项目中，手动编写和维护 Makefile 可能会变得非常困难。因此，出现了许多高级构建工具来简化这一过程：</p>
<ul>
<li><strong>CMake</strong>：一个跨平台的开源构建系统生成器。它允许开发者编写平台独立的 <code>CMakeLists.txt</code> 文件，然后 CMake 会根据这些文件生成特定平台的构建脚本 (如 Makefiles, Visual Studio 项目文件, Xcode 项目文件等)。这是目前 C&#x2F;C++ 项目中最流行的构建工具之一。</li>
<li><strong>Meson</strong>：一个现代、快速且易于使用的构建系统。它使用 Python 编写的配置语言，专注于高性能和用户友好性，同样可以生成 Makefiles 或 Ninja 构建文件。</li>
<li><strong>Ninja</strong>：一个专注于速度的小型构建系统。它被设计成由其他高级构建系统（如 CMake 和 Meson）生成，而不是手动编写。Ninja 的构建文件非常简洁，解析速度极快。</li>
<li><strong>Autotools (GNU Build System)</strong>：一套历史悠久的 GNU 工具链，包括 Autoconf、Automake 和 Libtool。它提供了非常强大的可移植性，能够处理各种 Unix-like 系统上的差异，但其配置过程相对复杂。</li>
</ul>
<p>选择哪种构建工具取决于项目规模、团队熟悉度以及对可移植性、性能和配置复杂度的需求。对于小型到中型项目，或需要精细控制构建过程的场景，手动编写 Makefile 仍然是一个极佳的选择。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Makefile 是 C&#x2F;C++ 开发者的必备工具，它通过自动化编译、链接和管理依赖关系，极大地提高了开发效率和项目可维护性。深入理解 Makefile 的规则、变量、伪目标以及 C&#x2F;C++ 项目的特定构建需求，将使您能够编写出高效、灵活的构建脚本。虽然现代构建系统如 CMake 提供了更高级的抽象，但 Makefile 作为底层构建机制的基石，其原理和实践对于任何 C&#x2F;C++ 开发者都具有长期价值。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/8cd637098d6a/">https://blog.tbf1211.xx.kg/8cd637098d6a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/CI-CD/">CI/CD</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Makefile/">Makefile</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/18a421861554/" title="Golang 项目的 Makefile 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang 项目的 Makefile 详解</div></div><div class="info-2"><div class="info-item-1"> Makefile 是一种自动化构建工具，它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者管理和自动化项目中的各种任务。尽管 Golang 自身提供了强大的内置工具链 (go build, go test, go run 等)，Makefile 在 Go 项目中依然扮演着重要角色，尤其是在需要协调多个任务、管理复杂构建流程、实现跨平台编译、集成外部工具或自动化部署脚本的场景下。  核心思想：将一系列 go 命令、Shell 脚本以及其他工具的调用封装成可复用的、有依赖关系的任务，实现一键式项目管理和自动化。   一、为什么 Go 项目需要 Makefile？Go 语言的工具链设计得非常出色，go build 能够自动处理依赖，go test 能够运行测试，go run 可以直接运行源代码。那么，为什么我们还需要 Makefile 呢？  任务编排与自动化： 一个 Go 项目通常不仅仅是编译代码。它可能涉及代码格式化 (go fmt)、静态分析 (go vet, golangci-lint)、代码生成 (go generate)、测试、构建 Docker 镜像、部署、清...</div></div></div></a><a class="pagination-related" href="/1beef2825d33/" title="CMake 与 Make：构建系统之辨"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CMake 与 Make：构建系统之辨</div></div><div class="info-2"><div class="info-item-1"> 在 C&#x2F;C++ 等编译型语言的开发中，构建系统 (Build System) 是将源代码转换成可执行程序、库或其他目标文件的核心环节。CMake 和 Make 是其中两个最常用但职责不同的工具。简单来说，CMake 是一个高级的构建系统生成器 (Build System Generator)，而 Make 是一个低级的构建工具 (Build Tool)，用于执行构建任务。  核心思想：CMake 负责“生成”跨平台的构建配置 (如 Makefile)，而 Make 负责“执行”这些配置来实际编译代码。   一、Make：低级构建工具1.1 什么是 Make？Make 是一个自动化构建工具 (Build Automation Tool)，它的核心职责是读取一个名为 Makefile 的文件，根据文件中定义的规则和依赖关系，执行相应的命令来构建项目。Make 在 Unix&#x2F;Linux 系统上历史悠久且广泛应用，是构建 C&#x2F;C++ 项目的基础工具之一。 1.2 MakefileMakefile 是 Make 工具的配置文件，它定义了：  目标 (Targ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1beef2825d33/" title="CMake 与 Make：构建系统之辨"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="info-item-2">CMake 与 Make：构建系统之辨</div></div><div class="info-2"><div class="info-item-1"> 在 C&#x2F;C++ 等编译型语言的开发中，构建系统 (Build System) 是将源代码转换成可执行程序、库或其他目标文件的核心环节。CMake 和 Make 是其中两个最常用但职责不同的工具。简单来说，CMake 是一个高级的构建系统生成器 (Build System Generator)，而 Make 是一个低级的构建工具 (Build Tool)，用于执行构建任务。  核心思想：CMake 负责“生成”跨平台的构建配置 (如 Makefile)，而 Make 负责“执行”这些配置来实际编译代码。   一、Make：低级构建工具1.1 什么是 Make？Make 是一个自动化构建工具 (Build Automation Tool)，它的核心职责是读取一个名为 Makefile 的文件，根据文件中定义的规则和依赖关系，执行相应的命令来构建项目。Make 在 Unix&#x2F;Linux 系统上历史悠久且广泛应用，是构建 C&#x2F;C++ 项目的基础工具之一。 1.2 MakefileMakefile 是 Make 工具的配置文件，它定义了：  目标 (Targ...</div></div></div></a><a class="pagination-related" href="/18a421861554/" title="Golang 项目的 Makefile 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-17</div><div class="info-item-2">Golang 项目的 Makefile 详解</div></div><div class="info-2"><div class="info-item-1"> Makefile 是一种自动化构建工具，它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者管理和自动化项目中的各种任务。尽管 Golang 自身提供了强大的内置工具链 (go build, go test, go run 等)，Makefile 在 Go 项目中依然扮演着重要角色，尤其是在需要协调多个任务、管理复杂构建流程、实现跨平台编译、集成外部工具或自动化部署脚本的场景下。  核心思想：将一系列 go 命令、Shell 脚本以及其他工具的调用封装成可复用的、有依赖关系的任务，实现一键式项目管理和自动化。   一、为什么 Go 项目需要 Makefile？Go 语言的工具链设计得非常出色，go build 能够自动处理依赖，go test 能够运行测试，go run 可以直接运行源代码。那么，为什么我们还需要 Makefile 呢？  任务编排与自动化： 一个 Go 项目通常不仅仅是编译代码。它可能涉及代码格式化 (go fmt)、静态分析 (go vet, golangci-lint)、代码生成 (go generate)、测试、构建 Docker 镜像、部署、清...</div></div></div></a><a class="pagination-related" href="/4b5b30fd759e/" title="U8g2lib 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-14</div><div class="info-item-2">U8g2lib 详解</div></div><div class="info-2"><div class="info-item-1"> U8g2lib 是一个用于单色图形显示器 (monochrome graphics displays) 的开源嵌入式图形库。它支持各种 OLED 和 LCD 显示器，例如经典的 128x64 SSD1306 OLED 显示器。U8g2lib 以其广泛的硬件支持、丰富的字体集、高效的内存使用以及强大的图形绘制功能而闻名。它是 U8glib 的继任者，相比 U8glib，U8g2lib 在内存效率和功能上进行了优化和扩展，支持帧缓冲模式 (full buffer) 和页缓冲模式 (page buffer)。  核心思想：提供一个统一的 API 接口，驱动各种单色图形显示器，并提供一套完整的图形绘制和字体渲染功能，同时兼顾嵌入式设备的资源限制。 开发者无需关心底层显示器的驱动细节，专注于界面设计。   一、为什么需要 U8g2lib？嵌入式显示器的痛点在嵌入式系统中集成单色图形显示器时，开发者常常面临以下挑战：  硬件驱动复杂：不同的显示器控制器 (如 SSD1306, SH1106, ST7920) 有不同的初始化序列、命令集和数据传输协议（SPI, I2C, 并行）。手动编写驱动...</div></div></div></a><a class="pagination-related" href="/bd9bce873bad/" title="Node.js 本地静态服务详解：http-server 与 live-server"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-24</div><div class="info-item-2">Node.js 本地静态服务详解：http-server 与 live-server</div></div><div class="info-2"><div class="info-item-1"> 在前端开发过程中，我们经常需要一个本地服务器来预览 HTML、CSS、JavaScript 等静态文件。虽然许多现代前端框架（如 React, Vue, Angular）都自带了开发服务器，但对于一些简单的项目、纯静态网站或快速原型开发，使用 Node.js 提供轻量级的本地静态服务器会更加方便快捷。本文将详细介绍两个广受欢迎的 Node.js 静态服务器工具：http-server 和 live-server。  “好的本地开发服务器，让你的前端工作流如丝般顺滑。”   一、为什么需要本地静态服务？在浏览器中直接打开本地的 HTML 文件（file:/// 协议）通常会有一些限制和问题：  AJAX&#x2F;Fetch 请求受限：浏览器出于安全考虑（同源策略），不允许 file:/// 协议下的页面进行跨域 AJAX 请求，甚至无法加载本地其他文件的 AJAX 请求。 动态加载问题：某些 JavaScript 模块加载器（如 ES Module import 语句）在 file:/// 协议下可能无法正常工作。 开发工具功能不全：一些浏览器扩展或开发工具可能依赖于 HTTP...</div></div></div></a><a class="pagination-related" href="/84d87a2eca4d/" title="Caddy Web Server详解：现代Web服务器的优雅选择"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">Caddy Web Server详解：现代Web服务器的优雅选择</div></div><div class="info-2"><div class="info-item-1"> Caddy 是一款用 Go 语言编写的开源 Web 服务器，以其自动 HTTPS 功能、简洁的配置以及强大的功能而闻名。它被设计成现代 Web 的瑞士军刀，能够胜任静态文件服务、反向代理、负载均衡、API 网关等多种任务，并且在安全性和易用性方面表现出色。  “Caddy 是未来 Web 服务器的样子：默认安全、易于管理、功能强大，并且能够自动处理 HTTPS 证书的申请和续期，让你的网站在几秒钟内上线并享受加密连接。”   一、Caddy 简介1.1 什么是 Caddy？Caddy 是一个高性能、可扩展的 Web 服务器，其核心特性包括：  自动 HTTPS：这是 Caddy 最吸引人的特性之一。对于绝大多数公共可访问的域名，Caddy 可以自动从 Let’s Encrypt 申请、配置和续期 SSL&#x2F;TLS 证书，无需手动干预。 配置简洁：Caddyfile 配置文件语法非常直观易懂，相比 Nginx 和 Apache 更加简洁。 HTTP&#x2F;2 和 HTTP&#x2F;3 支持：Caddy 默认启用 HTTP&#x2F;2，并且是首批支持 QUIC (H...</div></div></div></a><a class="pagination-related" href="/d1dbcd98dd73/" title="LazyGit使用解析：你的Git命令行效率神器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">LazyGit使用解析：你的Git命令行效率神器</div></div><div class="info-2"><div class="info-item-1"> 本文将带你深入了解 LazyGit，一个简单直观的终端 UI Git 客户端。如果你厌倦了反复输入 Git 命令，又觉得 GUI 客户端不够灵活，那么 LazyGit 可能会成为你的新宠。它将终端的强大与 GUI 的便捷完美结合，让你的 Git 工作流变得前所未有的高效和愉悦。  对于开发者而言，Git 无疑是日常工作中不可或缺的工具。然而，即使是最熟练的 Git 用户，也可能被一些重复、繁琐的命令行操作所困扰，例如 git add ., git status, git commit -m &quot;...&quot;, git log --oneline 等等。虽然有各种图形化 Git 客户端，但它们往往意味着脱离终端环境，或多或少牺牲了速度和灵活性。LazyGit 正是为了解决这一痛点而生的——它提供了一个文本用户界面 (TUI)，让你在终端中就能以图形化的方式快速、直观地执行 Git 操作，大幅提升工作效率。   一、为什么选择 LazyGit？LazyGit 并不是简单的 Git 命令别名集合，它提供了一个交互式的视图，将 git status, git branch...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">319</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">200</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">70</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81C-C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%A6%82%E8%BF%B0"><span class="toc-text">一、C&#x2F;C++ 项目构建概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Makefile-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%9B%9E%E9%A1%BE"><span class="toc-text">二、Makefile 基本语法回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A7%84%E5%88%99-Rules-%EF%BC%9A%E7%9B%AE%E6%A0%87%E3%80%81%E4%BE%9D%E8%B5%96%E3%80%81%E5%91%BD%E4%BB%A4"><span class="toc-text">2.1 规则 (Rules)：目标、依赖、命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8F%98%E9%87%8F-Variables"><span class="toc-text">2.2 变量 (Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F-Automatic-Variables"><span class="toc-text">2.3 自动变量 (Automatic Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%AA%E7%9B%AE%E6%A0%87-Phony-Targets"><span class="toc-text">2.4 伪目标 (Phony Targets)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%B3%A8%E9%87%8A"><span class="toc-text">2.5 注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C-C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9A%84-Makefile-%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0"><span class="toc-text">三、C&#x2F;C++ 项目构建的 Makefile 核心要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">3.1 定义编译器和编译选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%BA%90%E7%A0%81%E5%92%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">3.2 源码和目标文件管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E8%AF%91%E8%A7%84%E5%88%99-c-%E5%88%B0-o-cpp-%E5%88%B0-o"><span class="toc-text">3.3 编译规则 (.c 到 .o &#x2F; .cpp 到 .o)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%93%BE%E6%8E%A5%E8%A7%84%E5%88%99-%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-text">3.4 链接规则 (生成可执行文件)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">3.5 静态库和动态库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">四、高级特性与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6-Dependency-Generation"><span class="toc-text">4.1 自动生成依赖文件 (Dependency Generation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%80%92%E5%BD%92-Make-Recursive-Make"><span class="toc-text">4.2 递归 Make (Recursive Make)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-Conditional-Directives"><span class="toc-text">4.3 条件语句 (Conditional Directives)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Make-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">4.4 Make 内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%B9%B6%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="toc-text">4.5 并行构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81C-C-Makefile-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-text">五、C&#x2F;C++ Makefile 完整示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Makefile-%E4%B8%8E%E5%85%B6%E4%BB%96-C-C-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-text">六、Makefile 与其他 C&#x2F;C++ 构建工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/53e63dc49a04/" title="PyInstaller 深度解析与指令详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PyInstaller 深度解析与指令详解"/></a><div class="content"><a class="title" href="/53e63dc49a04/" title="PyInstaller 深度解析与指令详解">PyInstaller 深度解析与指令详解</a><time datetime="2025-11-24T22:24:00.000Z" title="发表于 2025-11-25 06:24:00">2025-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/61fddda6a7a8/" title="Go 语言 GC (Garbage Collection) 机制详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 语言 GC (Garbage Collection) 机制详解"/></a><div class="content"><a class="title" href="/61fddda6a7a8/" title="Go 语言 GC (Garbage Collection) 机制详解">Go 语言 GC (Garbage Collection) 机制详解</a><time datetime="2025-11-23T22:24:00.000Z" title="发表于 2025-11-24 06:24:00">2025-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"/></a><div class="content"><a class="title" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析">压缩字典树 (Radix Trie/Patricia Trie) 深度解析</a><time datetime="2025-11-17T22:24:00.000Z" title="发表于 2025-11-18 06:24:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c28be5a597e1/" title="Golang 内存对齐详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 内存对齐详解"/></a><div class="content"><a class="title" href="/c28be5a597e1/" title="Golang 内存对齐详解">Golang 内存对齐详解</a><time datetime="2025-11-12T22:24:00.000Z" title="发表于 2025-11-13 06:24:00">2025-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 空结构体 (struct{}) 详解"/></a><div class="content"><a class="title" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解">Golang 空结构体 (struct{}) 详解</a><time datetime="2025-11-10T22:24:00.000Z" title="发表于 2025-11-11 06:24:00">2025-11-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-17.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>