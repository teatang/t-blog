<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Makefile 详解与使用技巧 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Makefile 是一个强大的工具，用于自动化管理和编译 C&#x2F;C++ 项目。它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者高效地构建应用程序、库等。对于 C&#x2F;C++ 项目而言，Makefile 不仅能简化复杂的编译链接过程，还能实现增量编译，大大提高开发效率。  核心思想：跟踪文件的时间戳，仅重新编译自上次构建以来发生更改的源文件及其依赖项。   一、C&amp;#x2">
<meta property="og:type" content="article">
<meta property="og:title" content="Makefile 详解与使用技巧">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/8cd637098d6a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Makefile 是一个强大的工具，用于自动化管理和编译 C&#x2F;C++ 项目。它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者高效地构建应用程序、库等。对于 C&#x2F;C++ 项目而言，Makefile 不仅能简化复杂的编译链接过程，还能实现增量编译，大大提高开发效率。  核心思想：跟踪文件的时间戳，仅重新编译自上次构建以来发生更改的源文件及其依赖项。   一、C&amp;#x2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg">
<meta property="article:published_time" content="2025-02-15T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-02T09:49:14.609Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="CI&#x2F;CD">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Makefile">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Makefile 详解与使用技巧",
  "url": "https://blog.tbf1211.xx.kg/8cd637098d6a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg",
  "datePublished": "2025-02-15T22:24:00.000Z",
  "dateModified": "2026-02-02T09:49:14.609Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/8cd637098d6a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Makefile 详解与使用技巧',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">538</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-07.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Makefile 详解与使用技巧</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Makefile 详解与使用技巧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-02-15T22:24:00.000Z" title="发表于 2025-02-16 06:24:00">2025-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/CI-CD/">CI/CD</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Makefile</strong> 是一个强大的工具，用于自动化管理和编译 C&#x2F;C++ 项目。它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者高效地构建应用程序、库等。对于 C&#x2F;C++ 项目而言，Makefile 不仅能简化复杂的编译链接过程，还能实现增量编译，大大提高开发效率。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>跟踪文件的时间戳，仅重新编译自上次构建以来发生更改的源文件及其依赖项。</strong></p>
</div>
<hr>
<h2 id="一、C-C-项目构建概述"><a href="#一、C-C-项目构建概述" class="headerlink" title="一、C&#x2F;C++ 项目构建概述"></a>一、C&#x2F;C++ 项目构建概述</h2><p>在深入 Makefile 之前，理解 C&#x2F;C++ 代码的构建流程至关重要。一个典型的 C&#x2F;C++ 编译链接过程包括以下四个主要阶段：</p>
<ol>
<li><strong>预处理 (Preprocessing)</strong>：处理器根据预处理指令（如 <code>#include</code>, <code>#define</code>）对源代码进行文本替换，宏展开，并移除注释。生成的文件通常是 <code>.i</code> (C) 或 <code>.ii</code> (C++)。</li>
<li><strong>编译 (Compilation)</strong>：编译器将预处理后的代码翻译成汇编代码。此阶段会进行语法分析、类型检查等。生成的文件是 <code>.s</code>。</li>
<li><strong>汇编 (Assembly)</strong>：汇编器将汇编代码转换成机器码，生成目标文件 (Object File)。这些文件是平台特定的二进制文件，但尚未完全链接，例如函数调用和全局变量的地址尚未确定。生成的文件是 <code>.o</code> (Linux&#x2F;macOS) 或 <code>.obj</code> (Windows)。</li>
<li><strong>链接 (Linking)</strong>：链接器将所有目标文件（包括程序自身的目标文件和引用的库文件）合并，解析所有的符号引用，生成最终的可执行文件或库文件。</li>
</ol>
<p><strong>为什么需要 Makefile？</strong></p>
<ul>
<li><strong>简化重复工作</strong>：手动输入复杂的编译命令既繁琐又容易出错，特别是对于包含多个源文件的项目。</li>
<li><strong>增量编译</strong>：当项目中只有一个或几个文件发生改变时，Makefile 可以智能地只重新编译这些改变的文件及其直接依赖项，而不是每次都编译整个项目，从而节省大量时间。</li>
<li><strong>项目管理</strong>：Makefile 提供了一种标准化的方式来定义项目的构建步骤，便于团队协作和项目维护。</li>
<li><strong>平台适应性</strong>：尽管 Makefile 本身是通用的，但通过变量和条件语句，可以适应不同的编译器、操作系统和构建环境。</li>
</ul>
<h2 id="二、Makefile-基本语法回顾"><a href="#二、Makefile-基本语法回顾" class="headerlink" title="二、Makefile 基本语法回顾"></a>二、Makefile 基本语法回顾</h2><p>Makefile 的核心是<strong>规则 (Rules)</strong>。一个规则定义了如何生成一个或多个<strong>目标 (Target)</strong> 文件，这些目标依赖于哪些<strong>依赖 (Prerequisites)</strong> 文件，以及如何执行<strong>命令 (Commands)</strong> 来生成目标。</p>
<h3 id="2-1-规则-Rules-：目标、依赖、命令"><a href="#2-1-规则-Rules-：目标、依赖、命令" class="headerlink" title="2.1 规则 (Rules)：目标、依赖、命令"></a>2.1 规则 (Rules)：目标、依赖、命令</h3><p>基本语法结构：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>target (目标)</strong>：通常是要生成的文件，如可执行文件 (<code>program</code>) 或目标文件 (<code>main.o</code>)。也可以是伪目标 (Phony Target)，如 <code>all</code> 或 <code>clean</code>。</li>
<li><strong>prerequisites (依赖)</strong>：生成目标文件所需要的文件列表。如果任何一个依赖文件比目标文件新，或者目标文件不存在，则需要执行命令重新生成目标。</li>
<li><strong>command (命令)</strong>：生成目标文件所执行的 shell 命令。<strong>注意：命令前必须使用 Tab 键缩进，而不是空格。</strong></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">program: main.o utils.o</span></span><br><span class="line">    gcc main.o utils.o -o program</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c utils.h</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>program</code> 依赖于 <code>main.o</code> 和 <code>utils.o</code>。</li>
<li><code>main.o</code> 依赖于 <code>main.c</code> 和 <code>utils.h</code>。</li>
</ul>
<h3 id="2-2-变量-Variables"><a href="#2-2-变量-Variables" class="headerlink" title="2.2 变量 (Variables)"></a>2.2 变量 (Variables)</h3><p>变量用于在 Makefile 中存储和重用字符串。</p>
<ul>
<li><strong>递归扩展变量 (<code>=</code>)</strong>：最常见的变量类型。它的值会在变量被使用时才进行扩展。这意味着如果变量的值中引用了其他变量，那些变量也会在此时被扩展。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOO = <span class="variable">$(BAR)</span></span><br><span class="line">BAR = Hello</span><br><span class="line"><span class="comment"># FOO 在使用时才扩展，结果为 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>简单扩展变量 (<code>:=</code>)</strong>：变量在定义时立即扩展。如果变量的值中引用了其他变量，那些变量必须在此之前定义。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BAR := Hello</span><br><span class="line">FOO := <span class="variable">$(BAR)</span> World</span><br><span class="line"><span class="comment"># FOO 立即扩展为 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>条件赋值变量 (<code>?=</code>)</strong>：如果变量没有被定义过，则将其赋值。如果已经定义过，则保持原有值不变。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS ?= -O2 -Wall</span><br><span class="line"><span class="comment"># 如果 CFLAGS 未定义，则赋值为 &quot;-O2 -Wall&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>export</code> 变量</strong>：用于将 Makefile 中的变量传递给其执行的 shell 命令或子 Make 进程。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> CFLAGS = -Wall -g</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -O2</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-自动变量-Automatic-Variables"><a href="#2-3-自动变量-Automatic-Variables" class="headerlink" title="2.3 自动变量 (Automatic Variables)"></a>2.3 自动变量 (Automatic Variables)</h3><p>自动变量是 Make 在执行规则命令时自动设置的特殊变量，它们的值取决于当前规则的上下文。</p>
<ul>
<li><strong><code>$@</code></strong>：规则的目标文件的完整名称。</li>
<li><strong><code>$&lt;</code></strong>：规则的第一个依赖文件的名称。</li>
<li><strong><code>$^</code></strong>：规则的所有依赖文件的名称，以空格分隔，且不重复。</li>
<li><strong><code>$+</code></strong>：规则的所有依赖文件的名称，以空格分隔，允许重复（当依赖列表中有模式规则的展开时有用）。</li>
<li><strong><code>$?</code></strong>：所有比目标文件新的依赖文件的名称，以空格分隔。</li>
<li><strong><code>$*</code></strong>：模式规则中，<code>%</code> 匹配到的部分（stem）。例如，在 <code>%.o: %.c</code> 的规则中，如果目标是 <code>main.o</code>，则 <code>$*</code> 为 <code>main</code>。</li>
</ul>
<h3 id="2-4-伪目标-Phony-Targets"><a href="#2-4-伪目标-Phony-Targets" class="headerlink" title="2.4 伪目标 (Phony Targets)"></a>2.4 伪目标 (Phony Targets)</h3><p>伪目标是那些不对应实际文件的目标。它们通常用于执行特定的操作，如 <code>clean</code> (清理文件) 或 <code>all</code> (构建所有)。为了避免与实际文件名冲突，应使用 <code>.PHONY</code> 声明它们。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: program # &#x27;all&#x27; 依赖于 &#x27;program&#x27;，通常作为默认目标</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f program *.o *.d <span class="comment"># 删除可执行文件、目标文件和依赖文件</span></span><br></pre></td></tr></table></figure>
<p>声明为伪目标后，即使当前目录下存在名为 <code>all</code> 或 <code>clean</code> 的文件，Make 也总是会执行与伪目标关联的命令。</p>
<h3 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h3><p>使用 <code>#</code> 符号来添加注释。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个 Makefile 注释</span></span><br><span class="line">CC = gcc <span class="comment"># 定义 C 编译器</span></span><br></pre></td></tr></table></figure>

<h2 id="三、C-C-项目构建的-Makefile-核心要素"><a href="#三、C-C-项目构建的-Makefile-核心要素" class="headerlink" title="三、C&#x2F;C++ 项目构建的 Makefile 核心要素"></a>三、C&#x2F;C++ 项目构建的 Makefile 核心要素</h2><h3 id="3-1-定义编译器和编译选项"><a href="#3-1-定义编译器和编译选项" class="headerlink" title="3.1 定义编译器和编译选项"></a>3.1 定义编译器和编译选项</h3><p>这是 C&#x2F;C++ 项目 Makefile 的基石。</p>
<ul>
<li><strong><code>CC</code></strong>：C 编译器 (<code>gcc</code>, <code>clang</code>)</li>
<li><strong><code>CXX</code></strong>：C++ 编译器 (<code>g++</code>, <code>clang++</code>)</li>
<li><strong><code>CFLAGS</code></strong>：C 语言编译器的标志 (Flags)，如 <code>-Wall</code> (开启所有警告), <code>-O2</code> (优化级别2), <code>-g</code> (生成调试信息), <code>-std=c11</code> (C语言标准)。</li>
<li><strong><code>CXXFLAGS</code></strong>：C++ 语言编译器的标志，与 <code>CFLAGS</code> 类似，但针对 C++ 特性，如 <code>-std=c++17</code>。</li>
<li><strong><code>LDFLAGS</code></strong>：链接器的标志，如 <code>-L/path/to/lib</code> (指定库文件搜索路径), <code>-lm</code> (链接数学库)。</li>
<li><strong><code>CPPFLAGS</code></strong>：预处理器标志，通常用于定义宏 (<code>-DDEBUG</code>) 或指定头文件搜索路径 (<code>-I/path/to/include</code>)。<strong>注意：这与 <code>CXXFLAGS</code> 不同。</strong></li>
<li><strong><code>INCLUDE_DIRS</code></strong>：额外的头文件搜索路径，方便管理。</li>
<li><strong><code>LIB_DIRS</code></strong>：额外的库文件搜索路径。</li>
<li><strong><code>LIBS</code></strong>：需要链接的库文件，如 <code>-lprotobuf -lpthread</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译标志</span></span><br><span class="line">CFLAGS = -Wall -Wextra -g</span><br><span class="line">CXXFLAGS = -Wall -Wextra -g -std=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理器标志 (用于头文件路径)</span></span><br><span class="line">CPPFLAGS = -I./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接器标志 (用于库文件路径)</span></span><br><span class="line">LDFLAGS = -L./lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要链接的库</span></span><br><span class="line">LIBS = -lm -lpthread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试模式 (通过命令行 make DEBUG=1 开启)</span></span><br><span class="line"><span class="keyword">ifdef</span> DEBUG</span><br><span class="line">    CFLAGS += -DDEBUG</span><br><span class="line">    CXXFLAGS += -DDEBUG</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-源码和目标文件管理"><a href="#3-2-源码和目标文件管理" class="headerlink" title="3.2 源码和目标文件管理"></a>3.2 源码和目标文件管理</h3><p>为了方便管理大量源文件，通常使用变量来存储源文件列表，并自动生成对应的目标文件列表。</p>
<ul>
<li><strong><code>SRCS</code></strong>：源文件列表。</li>
<li><strong><code>OBJS</code></strong>：目标文件列表。</li>
</ul>
<p><strong>方法一：使用 <code>wildcard</code> 和 <code>patsubst</code> 函数</strong><br><code>wildcard</code>：查找匹配指定模式的文件。<br><code>patsubst</code>：进行模式替换。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下所有 .c 和 .cpp 源文件</span></span><br><span class="line">C_SRCS := <span class="variable">$(<span class="built_in">wildcard</span> src/*.c)</span></span><br><span class="line">CXX_SRCS := <span class="variable">$(<span class="built_in">wildcard</span> src/*.cpp)</span></span><br><span class="line">SRCS := <span class="variable">$(C_SRCS)</span> <span class="variable">$(CXX_SRCS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 .c 和 .cpp 替换为 .o</span></span><br><span class="line">C_OBJS := <span class="variable">$(<span class="built_in">patsubst</span> src/%.c, obj/%.o, <span class="variable">$(C_SRCS)</span>)</span></span><br><span class="line">CXX_OBJS := <span class="variable">$(<span class="built_in">patsubst</span> src/%.cpp, obj/%.o, <span class="variable">$(CXX_SRCS)</span>)</span></span><br><span class="line">OBJS := <span class="variable">$(C_OBJS)</span> <span class="variable">$(CXX_OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 obj 目录存在</span></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> mkdir -p obj)</span> <span class="comment"># 在 Make 执行前创建目录</span></span><br></pre></td></tr></table></figure>

<p><strong>方法二：使用变量替换 (适用于简单的文件路径)</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRCS := main.c utils.c helper.c</span><br><span class="line">OBJS := $(SRCS:.c=.o) <span class="comment"># 将所有 .c 替换为 .o</span></span><br></pre></td></tr></table></figure>
<p>此方法仅适用于单一后缀替换，且不会改变目录结构。</p>
<h3 id="3-3-编译规则-c-到-o-cpp-到-o"><a href="#3-3-编译规则-c-到-o-cpp-到-o" class="headerlink" title="3.3 编译规则 (.c 到 .o &#x2F; .cpp 到 .o)"></a>3.3 编译规则 (<code>.c</code> 到 <code>.o</code> &#x2F; <code>.cpp</code> 到 <code>.o</code>)</h3><p>这是 Makefile 中最重要的部分，定义了如何将源文件编译成目标文件。</p>
<ul>
<li><p><strong>模式规则 (Pattern Rules)</strong>：使用 <code>%</code> 作为通配符来定义一组相似的规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># C 文件的编译规则</span></span><br><span class="line"><span class="section">obj/%.o: src/%.c <span class="variable">$(CPPFLAGS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C++ 文件的编译规则</span></span><br><span class="line"><span class="section">obj/%.o: src/%.cpp <span class="variable">$(CPPFLAGS)</span></span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>这条规则表示：任何位于 <code>obj/</code> 目录下的 <code>.o</code> 文件，如果其对应的 <code>src/</code> 目录下的 <code>.c</code> (或 <code>.cpp</code>) 文件更新，就执行相应的编译命令。<code>$&lt;</code> 会自动替换为 <code>src/%.c</code> (或 <code>src/%.cpp</code>)，<code>$@</code> 会自动替换为 <code>obj/%.o</code>。</p>
</li>
</ul>
<h3 id="3-4-链接规则-生成可执行文件"><a href="#3-4-链接规则-生成可执行文件" class="headerlink" title="3.4 链接规则 (生成可执行文件)"></a>3.4 链接规则 (生成可执行文件)</h3><p>最后一步是将所有目标文件链接成一个可执行文件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TARGET = my_program</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIBS)</span> -o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>my_program</code> 依赖于所有的目标文件 <code>$(OBJS)</code>。当任何一个目标文件更新时，<code>my_program</code> 都将被重新链接。</p>
<h3 id="3-5-静态库和动态库"><a href="#3-5-静态库和动态库" class="headerlink" title="3.5 静态库和动态库"></a>3.5 静态库和动态库</h3><p>在 C&#x2F;C++ 项目中，经常需要构建和使用库。</p>
<ul>
<li><strong>静态库 (<code>.a</code> &#x2F; <code>.lib</code>)</strong>：在链接时将库中的代码直接拷贝到可执行文件中。优点是部署简单，无需担心库文件缺失；缺点是文件较大，且更新库需要重新链接。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STATIC_LIB = libfoo.a</span><br><span class="line">LIB_SRCS = foo1.c foo2.c</span><br><span class="line">LIB_OBJS = $(LIB_SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(STATIC_LIB)</span>: <span class="variable">$(LIB_OBJS)</span></span><br><span class="line">    ar rcs <span class="variable">$@</span> <span class="variable">$^</span> <span class="comment"># ar 是归档工具，rcs 参数用于创建或更新静态库</span></span><br></pre></td></tr></table></figure></li>
<li><strong>动态库&#x2F;共享库 (<code>.so</code> &#x2F; <code>.dylib</code> &#x2F; <code>.dll</code>)</strong>：在程序运行时才加载。优点是节省磁盘空间，多个程序可以共享同一个库实例，更新库无需重新链接程序；缺点是部署时需要确保库文件存在。<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DYNAMIC_LIB = libbar.so</span><br><span class="line">LIB_SRCS = bar1.c bar2.c</span><br><span class="line">LIB_OBJS = $(LIB_SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时需要生成位置无关代码 (PIC)</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -fPIC -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(DYNAMIC_LIB)</span>: <span class="variable">$(LIB_OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -shared -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四、高级特性与最佳实践"><a href="#四、高级特性与最佳实践" class="headerlink" title="四、高级特性与最佳实践"></a>四、高级特性与最佳实践</h2><h3 id="4-1-自动生成依赖文件-Dependency-Generation"><a href="#4-1-自动生成依赖文件-Dependency-Generation" class="headerlink" title="4.1 自动生成依赖文件 (Dependency Generation)"></a>4.1 自动生成依赖文件 (Dependency Generation)</h3><p>手动维护头文件依赖非常麻烦且容易出错。<code>gcc</code>&#x2F;<code>g++</code> 提供了一个强大的功能，可以自动生成 <code>.d</code> (dependency) 文件，其中包含了源文件所依赖的所有头文件。</p>
<ul>
<li><strong><code>gcc -MMD -MP</code></strong>：<ul>
<li><code>-MMD</code>：生成依赖文件，格式适合包含到 Makefile 中。</li>
<li><code>-MP</code>：为每个头文件生成一个伪目标，确保在头文件被删除时 Make 不会报错。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -Wextra -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件和目标文件</span></span><br><span class="line">SRCS := main.c utils.c</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖文件 (例如 main.d, utils.d)</span></span><br><span class="line">DEPS := $(SRCS:.c=.d)</span><br><span class="line"></span><br><span class="line">TARGET = my_program</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 C 文件并生成依赖文件</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -MMD -MP -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含所有的依赖文件。当 Make 读取到 `include` 语句时，</span></span><br><span class="line"><span class="comment"># 它会去查找 `.d` 文件，并将其内容（即依赖关系）合并到当前 Makefile 中。</span></span><br><span class="line"><span class="comment"># `-include` 会忽略不存在的依赖文件，在首次编译时非常有用。</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
<p>现在，当 <code>utils.h</code> 发生变化时，<code>main.o</code> (如果 <code>main.c</code> 包含了 <code>utils.h</code>) 将会自动重新编译，即使 <code>main.c</code> 本身没有改动。</p>
<h3 id="4-2-递归-Make-Recursive-Make"><a href="#4-2-递归-Make-Recursive-Make" class="headerlink" title="4.2 递归 Make (Recursive Make)"></a>4.2 递归 Make (Recursive Make)</h3><p>对于大型项目，如果将其划分为多个子目录，每个子目录有自己的 Makefile，可以使用递归 Make 来管理。</p>
<p><strong>项目结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── src</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── tests</span><br><span class="line">│   └── Makefile</span><br></pre></td></tr></table></figure>

<p><strong>顶层 <code>Makefile</code></strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SUBDIRS = src tests</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @for dir in <span class="variable">$(SUBDIRS)</span>; do \</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C $$dir; \</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    @for dir in <span class="variable">$(SUBDIRS)</span>; do \</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C $$dir clean; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$(MAKE) -C $$dir</code>：在 <code>$$dir</code> 目录下执行 <code>make</code> 命令。</li>
<li><code>@</code>：在执行命令时，不打印命令本身。</li>
</ul>
<h3 id="4-3-条件语句-Conditional-Directives"><a href="#4-3-条件语句-Conditional-Directives" class="headerlink" title="4.3 条件语句 (Conditional Directives)"></a>4.3 条件语句 (Conditional Directives)</h3><p>根据变量的值或是否定义，包含或排除部分 Makefile 内容。</p>
<ul>
<li><strong><code>ifeq</code> &#x2F; <code>ifneq</code></strong>：判断两个参数是否相等&#x2F;不相等。</li>
<li><strong><code>ifdef</code> &#x2F; <code>ifndef</code></strong>：判断一个变量是否已定义&#x2F;未定义。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设通过命令行 make DEBUG=1 来切换调试模式</span></span><br><span class="line"><span class="keyword">ifdef</span> DEBUG</span><br><span class="line">    CFLAGS += -DDEBUG -g</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CFLAGS += -O2</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Make-内置函数"><a href="#4-4-Make-内置函数" class="headerlink" title="4.4 Make 内置函数"></a>4.4 Make 内置函数</h3><p>Make 提供了丰富的函数来处理字符串和文件列表。</p>
<ul>
<li><code>$(wildcard PATTERN)</code>：查找与 <code>PATTERN</code> 匹配的文件。</li>
<li><code>$(patsubst PATTERN,REPLACEMENT,TEXT)</code>：在 <code>TEXT</code> 中查找 <code>PATTERN</code>，并替换为 <code>REPLACEMENT</code>。</li>
<li><code>$(shell COMMAND)</code>：执行 shell 命令并返回其输出。</li>
</ul>
<h3 id="4-5-并行构建"><a href="#4-5-并行构建" class="headerlink" title="4.5 并行构建"></a>4.5 并行构建</h3><p>使用 <code>make -j N</code> 可以并行执行 <code>N</code> 个编译任务，显著加快大型项目的构建速度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 8 <span class="comment"># 使用 8 个并行任务</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：并行构建要求 Makefile 中的依赖关系必须正确无误，否则可能导致构建失败。自动生成依赖文件 (<code>-MMD -MP</code>) 对此非常有帮助。</p>
<h2 id="五、C-C-Makefile-完整示例"><a href="#五、C-C-Makefile-完整示例" class="headerlink" title="五、C&#x2F;C++ Makefile 完整示例"></a>五、C&#x2F;C++ Makefile 完整示例</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======================================================================</span></span><br><span class="line"><span class="comment"># C/C++ 项目的 Makefile 模板</span></span><br><span class="line"><span class="comment"># ======================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 项目配置 ---</span></span><br><span class="line">TARGET = my_application</span><br><span class="line">BUILD_DIR = build</span><br><span class="line">SRC_DIR = src</span><br><span class="line">INCLUDE_DIR = <span class="keyword">include</span></span><br><span class="line">LIB_DIR = lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 编译器和编译选项 ---</span></span><br><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通用编译标志</span></span><br><span class="line">COMMON_CFLAGS = -Wall -Wextra -MMD -MP <span class="comment"># -MMD -MP 自动生成依赖</span></span><br><span class="line">COMMON_CXXFLAGS = -Wall -Wextra -MMD -MP -std=c++17</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试模式 (默认关闭)</span></span><br><span class="line">DEBUG ?= 0</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, 1)</span><br><span class="line">    COMMON_CFLAGS += -g -DDEBUG</span><br><span class="line">    COMMON_CXXFLAGS += -g -DDEBUG</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    COMMON_CFLAGS += -O2</span><br><span class="line">    COMMON_CXXFLAGS += -O2</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理器标志 (头文件路径)</span></span><br><span class="line">CPPFLAGS = -I<span class="variable">$(INCLUDE_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接器标志 (库文件路径)</span></span><br><span class="line">LDFLAGS = -L<span class="variable">$(LIB_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要链接的库</span></span><br><span class="line">LIBS = -lm -lpthread</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 文件管理 ---</span></span><br><span class="line"><span class="comment"># 查找所有的 C 和 C++ 源文件</span></span><br><span class="line">C_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.c)</span></span><br><span class="line">CXX_SRCS = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(SRC_DIR)</span>/*.cpp)</span></span><br><span class="line">SRCS = <span class="variable">$(C_SRCS)</span> <span class="variable">$(CXX_SRCS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对应的目标文件路径</span></span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(C_SRCS)</span>)</span></span><br><span class="line">CXX_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.cpp, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(CXX_SRCS)</span>)</span></span><br><span class="line">OBJS = <span class="variable">$(C_OBJS)</span> <span class="variable">$(CXX_OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对应的依赖文件路径</span></span><br><span class="line">C_DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.c, <span class="variable">$(BUILD_DIR)</span>/%.d, <span class="variable">$(C_SRCS)</span>)</span></span><br><span class="line">CXX_DEPS = <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(SRC_DIR)</span>/%.cpp, <span class="variable">$(BUILD_DIR)</span>/%.d, <span class="variable">$(CXX_SRCS)</span>)</span></span><br><span class="line">DEPS = <span class="variable">$(C_DEPS)</span> <span class="variable">$(CXX_DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 伪目标 ---</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean rebuild run</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认目标：构建整个项目</span></span><br><span class="line"><span class="section">all: <span class="variable">$(BUILD_DIR)</span> <span class="variable">$(TARGET)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新构建 (先清理再构建)</span></span><br><span class="line"><span class="section">rebuild: clean all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序</span></span><br><span class="line"><span class="section">run: <span class="variable">$(TARGET)</span></span></span><br><span class="line">    ./<span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    @echo <span class="string">&quot;Cleaning up...&quot;</span></span><br><span class="line">    @rm -rf <span class="variable">$(BUILD_DIR)</span> <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 规则 ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建构建目录</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>:</span><br><span class="line">    @mkdir -p <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 链接可执行文件</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    @echo <span class="string">&quot;Linking <span class="variable">$(TARGET)</span>...&quot;</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(LIBS)</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 编译 C 源文件到目标文件</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.c</span><br><span class="line">    @echo <span class="string">&quot;Compiling C: <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(COMMON_CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 编译 C++ 源文件到目标文件</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.o: <span class="variable">$(SRC_DIR)</span>/%.cpp</span><br><span class="line">    @echo <span class="string">&quot;Compiling C++: <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(COMMON_CXXFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 包含自动生成的依赖文件</span></span><br><span class="line"><span class="comment"># -include 使得在依赖文件不存在时不会报错，在首次编译时非常重要</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================================================================</span></span><br><span class="line"><span class="comment"># 举例项目文件结构:</span></span><br><span class="line"><span class="comment"># .</span></span><br><span class="line"><span class="comment"># ├── Makefile</span></span><br><span class="line"><span class="comment"># ├── src/</span></span><br><span class="line"><span class="comment"># │   ├── main.cpp</span></span><br><span class="line"><span class="comment"># │   └── utils.c</span></span><br><span class="line"><span class="comment"># └── include/</span></span><br><span class="line"><span class="comment">#     └── utils.h</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># main.cpp:</span></span><br><span class="line"><span class="comment"># #include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment"># #include &quot;utils.h&quot;</span></span><br><span class="line"><span class="comment"># int main() &#123;</span></span><br><span class="line"><span class="comment">#     std::cout &lt;&lt; &quot;Hello from C++!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">#     c_function();</span></span><br><span class="line"><span class="comment">#     return 0;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># utils.c:</span></span><br><span class="line"><span class="comment"># #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment"># #include &quot;utils.h&quot;</span></span><br><span class="line"><span class="comment"># void c_function() &#123;</span></span><br><span class="line"><span class="comment">#     printf(&quot;Hello from C!\n&quot;);</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># utils.h:</span></span><br><span class="line"><span class="comment"># #ifndef UTILS_H</span></span><br><span class="line"><span class="comment"># #define UTILS_H</span></span><br><span class="line"><span class="comment"># #ifdef __cplusplus</span></span><br><span class="line"><span class="comment"># extern &quot;C&quot; &#123;</span></span><br><span class="line"><span class="comment"># #endif</span></span><br><span class="line"><span class="comment"># void c_function();</span></span><br><span class="line"><span class="comment"># #ifdef __cplusplus</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment"># #endif</span></span><br><span class="line"><span class="comment"># #endif</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用方式:</span></span><br><span class="line"><span class="comment"># make          # 编译应用程序</span></span><br><span class="line"><span class="comment"># make clean    # 清理生成的文件</span></span><br><span class="line"><span class="comment"># make rebuild  # 清理并重新编译</span></span><br><span class="line"><span class="comment"># make run      # 编译并运行程序</span></span><br><span class="line"><span class="comment"># make DEBUG=1  # 编译调试版本</span></span><br><span class="line"><span class="comment"># ======================================================================</span></span><br></pre></td></tr></table></figure>

<h2 id="六、Makefile-与其他-C-C-构建工具"><a href="#六、Makefile-与其他-C-C-构建工具" class="headerlink" title="六、Makefile 与其他 C&#x2F;C++ 构建工具"></a>六、Makefile 与其他 C&#x2F;C++ 构建工具</h2><p>虽然 Makefile 强大且灵活，但在大型、复杂的 C&#x2F;C++ 项目中，手动编写和维护 Makefile 可能会变得非常困难。因此，出现了许多高级构建工具来简化这一过程：</p>
<ul>
<li><strong>CMake</strong>：一个跨平台的开源构建系统生成器。它允许开发者编写平台独立的 <code>CMakeLists.txt</code> 文件，然后 CMake 会根据这些文件生成特定平台的构建脚本 (如 Makefiles, Visual Studio 项目文件, Xcode 项目文件等)。这是目前 C&#x2F;C++ 项目中最流行的构建工具之一。</li>
<li><strong>Meson</strong>：一个现代、快速且易于使用的构建系统。它使用 Python 编写的配置语言，专注于高性能和用户友好性，同样可以生成 Makefiles 或 Ninja 构建文件。</li>
<li><strong>Ninja</strong>：一个专注于速度的小型构建系统。它被设计成由其他高级构建系统（如 CMake 和 Meson）生成，而不是手动编写。Ninja 的构建文件非常简洁，解析速度极快。</li>
<li><strong>Autotools (GNU Build System)</strong>：一套历史悠久的 GNU 工具链，包括 Autoconf、Automake 和 Libtool。它提供了非常强大的可移植性，能够处理各种 Unix-like 系统上的差异，但其配置过程相对复杂。</li>
</ul>
<p>选择哪种构建工具取决于项目规模、团队熟悉度以及对可移植性、性能和配置复杂度的需求。对于小型到中型项目，或需要精细控制构建过程的场景，手动编写 Makefile 仍然是一个极佳的选择。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Makefile 是 C&#x2F;C++ 开发者的必备工具，它通过自动化编译、链接和管理依赖关系，极大地提高了开发效率和项目可维护性。深入理解 Makefile 的规则、变量、伪目标以及 C&#x2F;C++ 项目的特定构建需求，将使您能够编写出高效、灵活的构建脚本。虽然现代构建系统如 CMake 提供了更高级的抽象，但 Makefile 作为底层构建机制的基石，其原理和实践对于任何 C&#x2F;C++ 开发者都具有长期价值。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/8cd637098d6a/">https://blog.tbf1211.xx.kg/8cd637098d6a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CI-CD/">CI/CD</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Makefile/">Makefile</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-07.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/18a421861554/" title="Golang 项目的 Makefile 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang 项目的 Makefile 详解</div></div><div class="info-2"><div class="info-item-1"> Makefile 是一种自动化构建工具，它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者管理和自动化项目中的各种任务。尽管 Golang 自身提供了强大的内置工具链 (go build, go test, go run 等)，Makefile 在 Go 项目中依然扮演着重要角色，尤其是在需要协调多个任务、管理复杂构建流程、实现跨平台编译、集成外部工具或自动化部署脚本的场景下。  核心思想：将一系列 go 命令、Shell 脚本以及其他工具的调用封装成可复用的、有依赖关系的任务，实现一键式项目管理和自动化。   一、为什么 Go 项目需要 Makefile？Go 语言的工具链设计得非常出色，go build 能够自动处理依赖，go test 能够运行测试，go run 可以直接运行源代码。那么，为什么我们还需要 Makefile 呢？  任务编排与自动化： 一个 Go 项目通常不仅仅是编译代码。它可能涉及代码格式化 (go fmt)、静态分析 (go vet, golangci-lint)、代码生成 (go generate)、测试、构建 Docker 镜像、部署、清...</div></div></div></a><a class="pagination-related" href="/1beef2825d33/" title="CMake 与 Make：构建系统之辨"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CMake 与 Make：构建系统之辨</div></div><div class="info-2"><div class="info-item-1"> 在 C&#x2F;C++ 等编译型语言的开发中，构建系统 (Build System) 是将源代码转换成可执行程序、库或其他目标文件的核心环节。CMake 和 Make 是其中两个最常用但职责不同的工具。简单来说，CMake 是一个高级的构建系统生成器 (Build System Generator)，而 Make 是一个低级的构建工具 (Build Tool)，用于执行构建任务。  核心思想：CMake 负责“生成”跨平台的构建配置 (如 Makefile)，而 Make 负责“执行”这些配置来实际编译代码。   一、Make：低级构建工具1.1 什么是 Make？Make 是一个自动化构建工具 (Build Automation Tool)，它的核心职责是读取一个名为 Makefile 的文件，根据文件中定义的规则和依赖关系，执行相应的命令来构建项目。Make 在 Unix&#x2F;Linux 系统上历史悠久且广泛应用，是构建 C&#x2F;C++ 项目的基础工具之一。 1.2 MakefileMakefile 是 Make 工具的配置文件，它定义了：  目标 (Targ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1beef2825d33/" title="CMake 与 Make：构建系统之辨"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="info-item-2">CMake 与 Make：构建系统之辨</div></div><div class="info-2"><div class="info-item-1"> 在 C&#x2F;C++ 等编译型语言的开发中，构建系统 (Build System) 是将源代码转换成可执行程序、库或其他目标文件的核心环节。CMake 和 Make 是其中两个最常用但职责不同的工具。简单来说，CMake 是一个高级的构建系统生成器 (Build System Generator)，而 Make 是一个低级的构建工具 (Build Tool)，用于执行构建任务。  核心思想：CMake 负责“生成”跨平台的构建配置 (如 Makefile)，而 Make 负责“执行”这些配置来实际编译代码。   一、Make：低级构建工具1.1 什么是 Make？Make 是一个自动化构建工具 (Build Automation Tool)，它的核心职责是读取一个名为 Makefile 的文件，根据文件中定义的规则和依赖关系，执行相应的命令来构建项目。Make 在 Unix&#x2F;Linux 系统上历史悠久且广泛应用，是构建 C&#x2F;C++ 项目的基础工具之一。 1.2 MakefileMakefile 是 Make 工具的配置文件，它定义了：  目标 (Targ...</div></div></div></a><a class="pagination-related" href="/18a421861554/" title="Golang 项目的 Makefile 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-17</div><div class="info-item-2">Golang 项目的 Makefile 详解</div></div><div class="info-2"><div class="info-item-1"> Makefile 是一种自动化构建工具，它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者管理和自动化项目中的各种任务。尽管 Golang 自身提供了强大的内置工具链 (go build, go test, go run 等)，Makefile 在 Go 项目中依然扮演着重要角色，尤其是在需要协调多个任务、管理复杂构建流程、实现跨平台编译、集成外部工具或自动化部署脚本的场景下。  核心思想：将一系列 go 命令、Shell 脚本以及其他工具的调用封装成可复用的、有依赖关系的任务，实现一键式项目管理和自动化。   一、为什么 Go 项目需要 Makefile？Go 语言的工具链设计得非常出色，go build 能够自动处理依赖，go test 能够运行测试，go run 可以直接运行源代码。那么，为什么我们还需要 Makefile 呢？  任务编排与自动化： 一个 Go 项目通常不仅仅是编译代码。它可能涉及代码格式化 (go fmt)、静态分析 (go vet, golangci-lint)、代码生成 (go generate)、测试、构建 Docker 镜像、部署、清...</div></div></div></a><a class="pagination-related" href="/55b69d9a9473/" title="Ruff 详解：极速 Python 代码检查与格式化工具"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-31</div><div class="info-item-2">Ruff 详解：极速 Python 代码检查与格式化工具</div></div><div class="info-2"><div class="info-item-1"> Ruff 是一个用 Rust 编写的极速 Python 代码检查 (Lint) 和格式化工具。它旨在提供一个高性能的替代方案，结合了 Flake8、isort、Black 等多种工具的功能，以显著提升 Python 项目的代码质量检查和格式化效率。  Ruff 的核心优势在于其极致的速度：由于底层使用 Rust 编写，它比传统的 Python 代码检查工具快 10 到 100 倍，这对于大型项目和 CI&#x2F;CD 流程来说是一个巨大的改进。   一、为什么选择 Ruff？在 Python 开发中，我们通常会使用一系列工具来维护代码质量和风格：  Linter (代码检查器)：如 Flake8、Pylint，用于发现潜在的 bug、代码异味、不遵循最佳实践的代码。 Formatter (代码格式化器)：如 Black、autopep8、YAPF，用于统一代码风格，使其符合 PEP 8 规范。 Import Sorter (导入排序器)：如 isort，用于自动排序和整理 import 语句。  管理和配置这些独立的工具会增加项目的复杂性。Ruff 的出现旨在简化这一过程，将...</div></div></div></a><a class="pagination-related" href="/c1538f7d98a1/" title="DevOps 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-27</div><div class="info-item-2">DevOps 深度解析</div></div><div class="info-2"><div class="info-item-1"> DevOps 是一种文化理念、一套实践和一套工具的集合，旨在缩短系统开发生命周期，同时高质量、持续不断地交付软件。它强调开发 (Development) 团队与运维 (Operations) 团队之间的协作与沟通，通过自动化流程、持续反馈和共享责任，打破传统上这两个团队之间的壁垒。  核心思想：DevOps 不仅仅是工具链，更是一种文化转型。它关注整个软件交付价值流的优化，从构思到最终用户，实现快速、可靠、高质量的软件交付。   一、为什么需要 DevOps？在传统的软件开发模式中（如瀑布模型），开发和运维团队通常是分离的，各自有不同的目标和激励机制：  开发团队：追求快速迭代、新功能发布，偏好频繁变更。 运维团队：追求系统稳定、高可用性，偏好减少变更。  这种分离导致了许多问题：  “推诿墙” (Wall of Confusion)：开发和运维之间缺乏沟通和协作，导致部署和维护阶段出现大量冲突和瓶颈。 发布周期长：软件从开发完成到最终上线需要漫长的测试、部署和配置过程。 部署风险高：由于变更频率低且批次大，每次发布都可能带来巨大的风险。 反馈回路慢：问题发现到解决的周期长，难...</div></div></div></a><a class="pagination-related" href="/fa69350b38ad/" title="Git Submodules 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-16</div><div class="info-item-2">Git Submodules 详解</div></div><div class="info-2"><div class="info-item-1"> Git Submodule (子模块) 是 Git 版本控制系统提供的一种机制，允许一个 Git 仓库 (称为主仓库或 superproject) 将另一个完整的 Git 仓库 (称为子模块) 作为其子目录嵌入。主仓库会记录子模块的特定提交 (specific commit)，而不是其最新的 HEAD 状态。这意味着，当你克隆主仓库时，你并不会自动获得子模块的所有历史，而是获得其在主仓库中被记录的那个确切版本。  核心思想：将一个独立的 Git 仓库作为另一个 Git 仓库的子目录进行管理，并追踪子模块的特定提交，以实现外部依赖管理、模块化或代码复用，同时保持各仓库的独立性。   一、为什么需要 Git Submodules？在软件开发中，经常会遇到以下场景：  管理外部依赖：你的项目依赖于一个由第三方维护的库或框架，你希望将其代码包含在自己的仓库中，但又不想复制粘贴或手动更新。 模块化大型项目：一个大型项目由多个相对独立的组件构成，这些组件各自有独立的开发生命周期和版本控制，但需要在一个主项目中统一协调。 代码复用：多个项目共享同一段代码或一个公共库，你希望这段共享代码能够独...</div></div></div></a><a class="pagination-related" href="/195d130ae5a4/" title="Ansible 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Ansible 深度解析</div></div><div class="info-2"><div class="info-item-1"> Ansible 是一个开源的自动化引擎，用于配置管理 (Configuration Management)、应用部署 (Application Deployment)、任务自动化 (Task Automation) 和编排 (Orchestration)。它以其无代理 (Agentless)、简单易用和人性化的特点而广受欢迎。Ansible 使用标准的 SSH 协议连接到目标机器，并使用 YAML 语法编写自动化任务，使得编写、理解和维护自动化脚本变得直观。  核心思想：Ansible 通过 SSH 远程执行操作，无需在被管理节点上安装任何客户端或代理程序。它采用声明式 YAML 语言描述期望的状态，并确保系统达到该状态，同时保证操作的幂等性。   一、为什么选择 Ansible？传统的服务器管理和应用部署往往涉及大量重复、手工且容易出错的任务。随着 IT 基础设施的规模不断扩大，这种手工操作的弊端日益凸显：  效率低下：手动操作耗时且重复。 易出错：人为失误在重复性任务中难以避免。 配置漂移 (Configuration Drift)：不同服务器的配置可能因手工操作而逐渐不一...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">538</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81C-C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%A6%82%E8%BF%B0"><span class="toc-text">一、C&#x2F;C++ 项目构建概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Makefile-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%9B%9E%E9%A1%BE"><span class="toc-text">二、Makefile 基本语法回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A7%84%E5%88%99-Rules-%EF%BC%9A%E7%9B%AE%E6%A0%87%E3%80%81%E4%BE%9D%E8%B5%96%E3%80%81%E5%91%BD%E4%BB%A4"><span class="toc-text">2.1 规则 (Rules)：目标、依赖、命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8F%98%E9%87%8F-Variables"><span class="toc-text">2.2 变量 (Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F-Automatic-Variables"><span class="toc-text">2.3 自动变量 (Automatic Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%AA%E7%9B%AE%E6%A0%87-Phony-Targets"><span class="toc-text">2.4 伪目标 (Phony Targets)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%B3%A8%E9%87%8A"><span class="toc-text">2.5 注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C-C-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%9A%84-Makefile-%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0"><span class="toc-text">三、C&#x2F;C++ 项目构建的 Makefile 核心要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">3.1 定义编译器和编译选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%BA%90%E7%A0%81%E5%92%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">3.2 源码和目标文件管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E8%AF%91%E8%A7%84%E5%88%99-c-%E5%88%B0-o-cpp-%E5%88%B0-o"><span class="toc-text">3.3 编译规则 (.c 到 .o &#x2F; .cpp 到 .o)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%93%BE%E6%8E%A5%E8%A7%84%E5%88%99-%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-text">3.4 链接规则 (生成可执行文件)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">3.5 静态库和动态库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">四、高级特性与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6-Dependency-Generation"><span class="toc-text">4.1 自动生成依赖文件 (Dependency Generation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%80%92%E5%BD%92-Make-Recursive-Make"><span class="toc-text">4.2 递归 Make (Recursive Make)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-Conditional-Directives"><span class="toc-text">4.3 条件语句 (Conditional Directives)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Make-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">4.4 Make 内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%B9%B6%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="toc-text">4.5 并行构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81C-C-Makefile-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-text">五、C&#x2F;C++ Makefile 完整示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Makefile-%E4%B8%8E%E5%85%B6%E4%BB%96-C-C-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7"><span class="toc-text">六、Makefile 与其他 C&#x2F;C++ 构建工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-07.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>