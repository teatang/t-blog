<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TUN 隧道详解与 HTTP/SOCKS 代理对比 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TUN (Tunnel) 隧道 是一种操作系统内核模块提供的虚拟网络接口，它允许用户空间的应用程序注入和接收 IP 数据包。与传统的网络接口不同，TUN 接口没有物理硬件与之对应，而是纯软件实现的。它在 OSI 模型的网络层（第三层）进行操作，因此能够处理 IP 协议栈的完整功能。  核心思想：TUN 接口模拟了一个点对点连接的网络设备，允许应用程序以编程方式像操作物理网卡一样，来处理 IP 层">
<meta property="og:type" content="article">
<meta property="og:title" content="TUN 隧道详解与 HTTP&#x2F;SOCKS 代理对比">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/f1fc37edcc9c/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="TUN (Tunnel) 隧道 是一种操作系统内核模块提供的虚拟网络接口，它允许用户空间的应用程序注入和接收 IP 数据包。与传统的网络接口不同，TUN 接口没有物理硬件与之对应，而是纯软件实现的。它在 OSI 模型的网络层（第三层）进行操作，因此能够处理 IP 协议栈的完整功能。  核心思想：TUN 接口模拟了一个点对点连接的网络设备，允许应用程序以编程方式像操作物理网卡一样，来处理 IP 层">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg">
<meta property="article:published_time" content="2023-11-30T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-17T08:09:09.091Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="代理协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TUN 隧道详解与 HTTP/SOCKS 代理对比",
  "url": "https://blog.tbf1211.xx.kg/f1fc37edcc9c/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-27.jpg",
  "datePublished": "2023-11-30T22:24:00.000Z",
  "dateModified": "2026-01-17T08:09:09.091Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/f1fc37edcc9c/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TUN 隧道详解与 HTTP/SOCKS 代理对比',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-27.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">TUN 隧道详解与 HTTP/SOCKS 代理对比</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TUN 隧道详解与 HTTP/SOCKS 代理对比</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-30T22:24:00.000Z" title="发表于 2023-12-01 06:24:00">2023-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE/">代理协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>TUN (Tunnel) 隧道</strong> 是一种操作系统内核模块提供的虚拟网络接口，它允许用户空间的应用程序注入和接收 IP 数据包。与传统的网络接口不同，TUN 接口没有物理硬件与之对应，而是纯软件实现的。它在 OSI 模型的网络层（第三层）进行操作，因此能够处理 IP 协议栈的完整功能。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>TUN 接口模拟了一个点对点连接的网络设备，允许应用程序以编程方式像操作物理网卡一样，来处理 IP 层的数据包。</strong> 它使得在用户空间实现复杂的网络协议栈成为可能，是构建 VPN (Virtual Private Network) 等虚拟网络技术的基石。</p>
</div>
<hr>
<h2 id="一、TUN-隧道概述"><a href="#一、TUN-隧道概述" class="headerlink" title="一、TUN 隧道概述"></a>一、TUN 隧道概述</h2><p>TUN 隧道，全称为 “Tunnel” 虚拟网络接口，是一个 Linux&#x2F;Unix 系统内核提供的一个机制，用于创建虚拟网络设备。这些虚拟设备允许用户空间的程序读取和写入网络层（IP 层）的数据包。当数据包被写入 TUN 接口时，它会被传递给关联的用户空间应用程序；反之，当用户空间应用程序将数据包写入 TUN 接口时，这些数据包会被内核视为从网络中接收的 IP 数据包，并根据路由表进行进一步处理。</p>
<h3 id="1-1-TAP-与-TUN"><a href="#1-1-TAP-与-TUN" class="headerlink" title="1.1 TAP 与 TUN"></a>1.1 TAP 与 TUN</h3><p>在 Linux 系统中，除了 TUN 之外，还有一个类似的虚拟网络接口 <strong>TAP (Tap Device)</strong>。它们的主要区别在于操作的 OSI 模型层次：</p>
<ul>
<li><strong>TUN (Tunnel Device)</strong>：操作在网络层（L3），处理 IP 数据包。它是一个虚拟的点对点设备，只处理 IP 包，不关心以太网帧头。</li>
<li><strong>TAP (Tap Device)</strong>：操作在数据链路层（L2），处理以太网帧。它是一个虚拟以太网设备，可以像物理网卡一样接收和发送以太网帧，包括 MAC 地址、ARP 等数据链路层协议。</li>
</ul>
<p>本文主要聚焦于 TUN 隧道。</p>
<h3 id="1-2-TUN-隧道的用途"><a href="#1-2-TUN-隧道的用途" class="headerlink" title="1.2 TUN 隧道的用途"></a>1.2 TUN 隧道的用途</h3><p>TUN 隧道的典型应用场景包括：</p>
<ul>
<li><strong>构建 VPN (Virtual Private Network)</strong>：VPN Client 软件通过创建一个 TUN 接口，将所有或部分网络流量重定向到该接口，然后对其进行加密并通过物理网络发送到 VPN Server。</li>
<li><strong>网络虚拟化</strong>：在容器或虚拟机环境中，为每个实例提供独立的网络接口。</li>
<li><strong>网络流量捕获和分析</strong>：通过将流量引入 TUN 接口，用户空间程序可以对 IP 数据包进行深度分析。</li>
<li><strong>透明代理</strong>：通过配置路由表，将特定流量导入 TUN 接口，实现对所有或特定应用的流量代理，即使它们本身不支持代理。</li>
</ul>
<h2 id="二、TUN-隧道工作原理"><a href="#二、TUN-隧道工作原理" class="headerlink" title="二、TUN 隧道工作原理"></a>二、TUN 隧道工作原理</h2><p>TUN 隧道的工作原理可以概括为以下步骤：</p>
<ol>
<li><strong>创建 TUN 接口</strong>：用户空间应用程序通过特定的系统调用打开 <code>/dev/net/tun</code> 设备文件，创建一个新的 TUN 虚拟网络接口。</li>
<li><strong>配置 IP 地址与路由</strong>：应用程序为新创建的 TUN 接口配置 IP 地址和子网掩码，并可能添加新的路由规则，以将特定的网络流量引导到该 TUN 接口。</li>
<li><strong>数据包转发</strong>：<ul>
<li><strong>发送数据包</strong>：当应用程序（或系统中的其他进程）试图向因配置路由而被定向到 TUN 接口的 IP 地址发送数据包时，内核不会将其通过物理网卡发送，而是将这些 IP 数据包传递给与 TUN 接口关联的用户空间应用程序。</li>
<li><strong>接收数据包</strong>：用户空间应用程序将处理后的（例如加密、封装）数据包写入到 TUN 接口的文件描述符中。内核收到这些数据包后，会将其视为从“网络”中传入的 IP 数据包，并根据其目标 IP 地址和路由表进行转发处理（例如通过物理网卡发送出去）。</li>
</ul>
</li>
</ol>
<h3 id="2-1-示例：创建-TUN-接口（Python）"><a href="#2-1-示例：创建-TUN-接口（Python）" class="headerlink" title="2.1 示例：创建 TUN 接口（Python）"></a>2.1 示例：创建 TUN 接口（Python）</h3><p>在 Unix-like 系统中，通常通过打开 <code>/dev/net/tun</code> 文件并使用 <code>ioctl</code> 系统调用来创建和配置 TUN 接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> fcntl</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一些常数，通常在 &lt;linux/if_tun.h&gt; 中定义</span></span><br><span class="line">TUNSETIFF = <span class="number">0x400454c2</span></span><br><span class="line">IFF_TUN = <span class="number">0x0001</span></span><br><span class="line">IFF_NO_PI = <span class="number">0x1000</span>  <span class="comment"># 不要包信息头 (packet information header)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_tun_interface</span>(<span class="params">if_name=<span class="string">&quot;mytun0&quot;</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 打开 TUN 设备文件</span></span><br><span class="line">        tun_fd = os.<span class="built_in">open</span>(<span class="string">&quot;/dev/net/tun&quot;</span>, os.O_RDWR)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造 ifreq 结构体，设置接口名称和类型</span></span><br><span class="line">        <span class="comment"># ifr_name 长度最多为 IFNAMSIZ (16字节)，需要用字节填充</span></span><br><span class="line">        ifr = struct.pack(<span class="string">&quot;16sH&quot;</span>, if_name.encode(<span class="string">&#x27;ascii&#x27;</span>), IFF_TUN | IFF_NO_PI)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用 ioctl 创建 TUN 接口</span></span><br><span class="line">        <span class="comment"># TUNSETIFF 命令用于设置接口标志和名称</span></span><br><span class="line">        fcntl.ioctl(tun_fd, TUNSETIFF, ifr)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;TUN interface &#x27;<span class="subst">&#123;if_name&#125;</span>&#x27; created successfully.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;File descriptor: <span class="subst">&#123;tun_fd&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回文件描述符，应用程序将通过它读写数据包</span></span><br><span class="line">        <span class="keyword">return</span> tun_fd, if_name</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error creating TUN interface: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">configure_tun_interface</span>(<span class="params">if_name, ip_address, netmask</span>):</span><br><span class="line">    <span class="comment"># 这部分通常需要 root 权限，并且通过调用外部命令完成</span></span><br><span class="line">    <span class="comment"># 或者使用更底层的 netlink 库</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Configuring IP address <span class="subst">&#123;ip_address&#125;</span> with netmask <span class="subst">&#123;netmask&#125;</span> for <span class="subst">&#123;if_name&#125;</span>...&quot;</span>)</span><br><span class="line">    os.system(<span class="string">f&quot;ip link set dev <span class="subst">&#123;if_name&#125;</span> up&quot;</span>)</span><br><span class="line">    os.system(<span class="string">f&quot;ip addr add <span class="subst">&#123;ip_address&#125;</span> peer <span class="subst">&#123;ip_address&#125;</span> dev <span class="subst">&#123;if_name&#125;</span>&quot;</span>) <span class="comment"># peer IP 通常设为自身</span></span><br><span class="line">    os.system(<span class="string">f&quot;ip route add <span class="subst">&#123;ip_address&#125;</span>/32 dev <span class="subst">&#123;if_name&#125;</span>&quot;</span>) <span class="comment"># 确保路由可达</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tun_fd, tun_name = create_tun_interface(<span class="string">&quot;tun0&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> tun_fd:</span><br><span class="line">        configure_tun_interface(tun_name, <span class="string">&quot;10.0.0.1&quot;</span>, <span class="string">&quot;255.255.255.0&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Now you can read/write IP packets from/to file descriptor <span class="subst">&#123;tun_fd&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Example: Ping 10.0.0.1 (self) or other configured peer IP.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这是一个简化的循环，实际应用中会更复杂</span></span><br><span class="line">        <span class="comment"># 应用程序会监听此 FD，并处理收到的 IP 数据包</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                packet = os.read(tun_fd, <span class="number">2048</span>) <span class="comment"># 读取一个 IP 数据包</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Received <span class="subst">&#123;<span class="built_in">len</span>(packet)&#125;</span> bytes from <span class="subst">&#123;tun_name&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 在这里处理 packet，例如解密、转发</span></span><br><span class="line">                <span class="comment"># os.write(tun_fd, processed_packet) # 将处理后的数据写回 TUN 接口</span></span><br><span class="line">            <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">                <span class="comment"># print(&quot;No packet yet.&quot;)</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        os.close(tun_fd)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;TUN interface <span class="subst">&#123;tun_name&#125;</span> closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 注意：运行此脚本需要 root 权限</span></span><br><span class="line">    <span class="comment"># sudo python your_script_name.py</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数据包流向示例"><a href="#2-2-数据包流向示例" class="headerlink" title="2.2 数据包流向示例"></a>2.2 数据包流向示例</h3><p>假设客户端通过 TUN 隧道访问远程服务器：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph Client Application
        A[App Sends Data to Remote Server IP]
    end

    subgraph Client OS Kernel
        B[IP Packet Generated] --&gt; C{Routing Table}
        C -- Route via TUN0 --&gt; D[TUN0 Interface]
    end

    subgraph User Space VPN Client
        E[Reads IP Packet from TUN0] --&gt; F[Encrypts&#x2F;Encapsulates Packet] --&gt; G[Sends Encapsulated Packet via Physical NIC]
    end

    subgraph Internet
        H[Encapsulated Packet Travels Across Internet]
    end

    subgraph VPN Server
        I[Receives Encapsulated Packet] --&gt; J[Decrypts&#x2F;Decapsulates Packet] --&gt; K[Writes Decapsulated IP Packet to Server&#39;s TUN Interface]
    end

    subgraph Server OS Kernel
        L[Receives IP Packet from Server&#39;s TUN] --&gt; M{Routing Table}
        M -- Route to Remote Server --&gt; N[Remote Server]
    end

    A --&gt; B
    D --&gt; E
    G --&gt; H
    H --&gt; I
    K --&gt; L
    N -- Response --&gt; M
    M -- Route back via Server&#39;s TUN --&gt; K
    K -- Encrypts&#x2F;Encapsulates Response --&gt; J
    J -- Sends Encapsulated Response via Server&#39;s Physical NIC --&gt; H
    H -- Encapsulated Response Travels Across Internet --&gt; G
    G -- Decrypts&#x2F;Decapsulates Response --&gt; E
    E -- Writes Decapsulated Response to TUN0 --&gt; D
    D -- Receives Response from TUN0 --&gt; B
    B -- Passes Response to App --&gt; A
  </pre></div>

<h2 id="三、HTTP-SOCKS-代理详解"><a href="#三、HTTP-SOCKS-代理详解" class="headerlink" title="三、HTTP&#x2F;SOCKS 代理详解"></a>三、HTTP&#x2F;SOCKS 代理详解</h2><p>在对比 TUN 隧道之前，我们先回顾一下 HTTP 和 SOCKS 代理。这两种代理通常工作在应用层或会话层，与 TUN 隧道工作的网络层有显著区别。</p>
<h3 id="3-1-HTTP-代理"><a href="#3-1-HTTP-代理" class="headerlink" title="3.1 HTTP 代理"></a>3.1 HTTP 代理</h3><ul>
<li><strong>工作层次</strong>：主要工作在 OSI 模型的应用层 (L7)。</li>
<li><strong>协议特性</strong>：专门为 HTTP (和 HTTPS) 协议设计。</li>
<li><strong>工作方式</strong>：<ul>
<li><strong>GET&#x2F;POST 请求</strong>：客户端向代理服务器发送 HTTP 请求时，会在请求行中包含完整的 URL，例如 <code>GET http://example.com/index.html HTTP/1.1</code>。代理服务器解析这个请求，代为访问目标网站，然后将响应返回给客户端。</li>
<li><strong>CONNECT 请求</strong>：对于 HTTPS 或其他需要建立隧道连接的协议，客户端会发送 <code>CONNECT example.com:443 HTTP/1.1</code> 请求。代理服务器收到后，会尝试与目标服务器建立 TCP 连接。一旦连接成功，代理服务器会通知客户端，之后客户端和目标服务器之间的数据流就直接通过代理进行转发，代理只负责字节流的透传，不对内容进行解析。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>实现简单，广泛支持。</li>
<li>可以缓存网页内容，加速访问。</li>
<li>可以根据 URL 进行过滤和内容修改。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>通常只支持 HTTP&#x2F;HTTPS 协议，对其他协议的支持有限（除非使用 CONNECT 方法）。</li>
<li>需要应用程序明确支持代理配置。</li>
<li>无法代理非 TCP&#x2F;UDP 的 IP 流量。</li>
</ul>
</li>
</ul>
<h3 id="3-2-SOCKS-代理"><a href="#3-2-SOCKS-代理" class="headerlink" title="3.2 SOCKS 代理"></a>3.2 SOCKS 代理</h3><ul>
<li><strong>工作层次</strong>：工作在会话层 (L5)，比 HTTP 代理更底层。</li>
<li><strong>协议特性</strong>：是一种通用代理协议，不限于特定的应用层协议。它有 SOCKS4, SOCKS4a 和 SOCKS5 等版本。SOCKS5 是最新和最常用的版本，支持 TCP 和 UDP 协议，以及认证和 IPv6。</li>
<li><strong>工作方式</strong>：<ul>
<li>客户端首先与 SOCKS 代理建立连接，并发送一个“握手”请求，告诉代理它想要连接的目标地址和端口。</li>
<li>SOCKS 代理接收请求并尝试与目标服务器建立连接。</li>
<li>连接成功后，代理将客户端和目标服务器之间的数据流进行透明转发，不对应用层协议内容进行解析。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>通用性强，支持各种 TCP 和 UDP 协议，如 FTP, SMTP, RDP 等。</li>
<li>比 HTTP 代理更灵活，可以在不修改应用层协议的情况下转发流量。</li>
<li>同样需要应用程序明确支持代理配置。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>不能进行应用层内容解析和过滤。</li>
<li>仍需应用程序支持代理配置。</li>
<li>无法代理非 TCP&#x2F;UDP 的 IP 流量（SOCKS5 虽然支持 UDP，但通常是 UDP 转发，而不是直接处理任意 IP 包）。</li>
</ul>
</li>
</ul>
<h2 id="四、TUN-隧道与-HTTP-SOCKS-代理对比"><a href="#四、TUN-隧道与-HTTP-SOCKS-代理对比" class="headerlink" title="四、TUN 隧道与 HTTP&#x2F;SOCKS 代理对比"></a>四、TUN 隧道与 HTTP&#x2F;SOCKS 代理对比</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">TUN 隧道 (L3)</th>
<th align="left">HTTP 代理 (L7)</th>
<th align="left">SOCKS 代理 (L5)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>操作层级</strong></td>
<td align="left">网络层 (OSI L3)</td>
<td align="left">应用层 (OSI L7)</td>
<td align="left">会话层 (OSI L5)</td>
</tr>
<tr>
<td align="left"><strong>处理数据</strong></td>
<td align="left">IP 数据包 (包括各种协议，如 TCP, UDP, ICMP 等)</td>
<td align="left">HTTP&#x2F;HTTPS 请求和响应</td>
<td align="left">TCP 连接和 UDP 数据报</td>
</tr>
<tr>
<td align="left"><strong>透明性</strong></td>
<td align="left"><strong>高透明</strong>：一旦配置路由，所有匹配流量自动进入隧道，应用程序无需感知。</td>
<td align="left"><strong>低透明</strong>：应用程序需要显式配置代理。</td>
<td align="left"><strong>中等透明</strong>：应用程序需要显式配置代理。</td>
</tr>
<tr>
<td align="left"><strong>代理范围</strong></td>
<td align="left"><strong>全局&#x2F;路由驱动</strong>：可以代理所有 IP 流量，实现真正的网络层转发。</td>
<td align="left"><strong>应用层协议限定</strong>：主要用于 HTTP&#x2F;HTTPS。</td>
<td align="left"><strong>传输层协议限定</strong>：支持 TCP 和 UDP，但不是任意 IP 包。</td>
</tr>
<tr>
<td align="left"><strong>配置方式</strong></td>
<td align="left">操作系统层面的网络接口配置和路由表修改。</td>
<td align="left">应用程序内部或系统网络设置中的代理配置。</td>
<td align="left">应用程序内部或系统网络设置中的代理配置。</td>
</tr>
<tr>
<td align="left"><strong>加密能力</strong></td>
<td align="left">自身不提供加密，但结合 VPN 协议（如 OpenVPN, WireGuard）可以提供强大的端到端加密。</td>
<td align="left">自身不加密，HTTPS 代理通过 CONNECT 方法建立 TLS 隧道。</td>
<td align="left">SOCKS5 自身可以支持认证但不提供流量加密，需要上层协议加密。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">VPN、全局流量重定向、透明代理、虚拟化网络、网络协议调试。</td>
<td align="left">网页浏览、文件下载、Web 服务 API 访问。</td>
<td align="left">通用网络应用程序代理、游戏、即时通讯、SSH。</td>
</tr>
<tr>
<td align="left"><strong>性能开销</strong></td>
<td align="left">封装&#x2F;解封装 IP 包，可能引入头部开销，但处理效率高。</td>
<td align="left">解析 HTTP&#x2F;SOCKS 协议，可能引入应用层开销。</td>
<td align="left">解析 SOCKS 协议，相对较小。</td>
</tr>
<tr>
<td align="left"><strong>防火墙&#x2F;NAT 穿透</strong></td>
<td align="left">通常需要外围协议（如 UDP over IP）帮助穿透。</td>
<td align="left">HTTP 代理可以指定代理地址和端口，SOCKS5 也可以。</td>
<td align="left">SOCKS5 代理可以指定代理地址和端口。</td>
</tr>
</tbody></table>
<p><strong>总结差异可视化：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph OSI Reference Model
        A[Application Layer L7]
        B[Presentation Layer L6]
        C[Session Layer L5]
        D[Transport Layer L4]
        E[Network Layer L3]
        F[Data Link Layer L2]
        G[Physical Layer L1]
    end

    subgraph TUN Tunnel
        H[VPN Client&#x2F;Server App]
        I[IP Packet]
        J[Virtual TUN Interface]
    end

    subgraph HTTP&#x2F;SOCKS Proxy
        K[&quot;Application (e.g., Browser)&quot;]
        L[HTTP or SOCKS Protocol]
        M[Proxy Server]
    end

    A --- K
    C --- L
    E --- J

    K --&gt; L
    L --&gt; M

    I --&gt; J
    J -- Routes IP Traffic --&gt; H
    H -- Encapsulates&#x2F;Encrypts --&gt; E

    E -- Data Flow --&gt; D
    D -- Data Flow --&gt; C
    C -- Data Flow --&gt; B
    B -- Data Flow --&gt; A

    M -- Application-level Proxying --&gt; A
    M -- Session-level Proxying --&gt; C
  </pre></div>

<h2 id="五、安全性考虑"><a href="#五、安全性考虑" class="headerlink" title="五、安全性考虑"></a>五、安全性考虑</h2><ul>
<li><strong>TUN 隧道</strong>：自身不提供加密，但作为 VPN 的底层机制，其安全性高度依赖于上层 VPN 协议（如 OpenVPN, WireGuard）的加密和认证强度。由于其在 IP 层操作，可以实现更全面的系统级流量加密和隐藏真实 IP。</li>
<li><strong>HTTP&#x2F;SOCKS 代理</strong>：<ul>
<li>HTTP 代理：对于明文 HTTP 流量，代理可以看到并修改内容。对于 HTTPS (CONNECT 方法)，代理只转发加密隧道，无法解密内容（除非使用中间人攻击）。</li>
<li>SOCKS 代理：通常不对流量进行加密，只负责转发。数据安全依赖于应用层自身的加密（如 TLS&#x2F;SSL）。SOCKS5 提供了认证机制，但主要是防止未经授权的使用。</li>
</ul>
</li>
</ul>
<p>在任何使用隧道或代理的场景中，确保传输路径的加密和认证是至关重要的，尤其是在不可信网络环境下。HTTPS 或 VPN 结合 TUN 隧道是实现端到端数据机密性和完整性的有效手段。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>TUN 隧道、HTTP 代理和 SOCKS 代理在网络通信中各有其独特的定位和应用场景。</p>
<p><strong>TUN 隧道</strong> 因其在网络层操作的特性，提供了对 IP 数据包的底层控制能力。它能够实现高度透明的系统级流量管理和重定向，是构建 VPN、实现全局透明代理和复杂网络虚拟化的核心技术。它的优势在于其<strong>无感透明性</strong>和对<strong>任意 IP 协议的全面支持</strong>。</p>
<p>相比之下，<strong>HTTP 代理</strong> 和 <strong>SOCKS 代理</strong> 更专注于应用层或会话层。HTTP 代理在处理 HTTP&#x2F;HTTPS 流量时功能强大，支持内容缓存和过滤。SOCKS 代理则更为通用，能够代理各种 TCP 和 UDP 协议，但需要应用程序的显式支持。它们的优势在于<strong>易于应用层集成</strong>和<strong>颗粒度更细的协议控制</strong>（HTTP 代理）。</p>
<p>选择哪种技术取决于具体的应用需求：</p>
<ul>
<li>如果需要<strong>系统级、透明地处理所有 IP 流量</strong>，实现路由重定向、加密整个网络连接，那么 TUN 隧道（通常作为 VPN 的一部分）是首选。</li>
<li>如果仅需要<strong>代理特定应用程序的网页浏览流量</strong>，HTTP 代理足够。</li>
<li>如果需要<strong>代理各种 TCP&#x2F;UDP 应用（非 HTTP&#x2F;SOCKS 协议）</strong>，且应用程序支持代理配置，SOCKS 代理则是更灵活的选择。</li>
</ul>
<p>理解这些技术的区别和工作原理，对于构建健壮、安全和高效的网络解决方案至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/f1fc37edcc9c/">https://blog.tbf1211.xx.kg/f1fc37edcc9c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE/">代理协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-27.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f67db260675a/" title="Vue3 Hook(组合式 API)与Mixin对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Vue3 Hook(组合式 API)与Mixin对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin 两种逻辑复用模式，从多方面进行对比分析，帮助开发者理解它们各自的优缺点，并选择最适合自己项目和团队的模式。   一、 理解 Vue 中的逻辑复用在 Vue 组件开发中，我们经常会遇到需要在多个组件中共享相同的逻辑（例如：处理鼠标位置、计时器、表单验证、主题切换等）。如果没有有效的复用机制，这些逻辑就会在不同组件中重复编写，导致代码冗余、难以维护。  Vue 提供了以下主要方式来解决逻辑复用问题：  Mixin (混入)：Vue 2 的主要逻辑复用方式，也在 Vue 3 中继续支持。 Composition API (组合式 API &#x2F; Vue 3 Hook)：Vue 3 引入...</div></div></div></a><a class="pagination-related" href="/8d32c59da40a/" title="Vitest 详解：下一代前端测试框架"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Vitest 详解：下一代前端测试框架</div></div><div class="info-2"><div class="info-item-1"> Vitest 是一个由 Vite 驱动的下一代单元测试框架，旨在提供一个快速、现代且极具效率的测试体验。它与 Vite 深度集成，共享相同的配置、转换和解析器，从而为使用 Vite 构建的前端项目提供了无缝的测试解决方案。Vitest 的诞生，部分是为了解决传统前端测试工具（如 Jest）在大型项目中启动慢、HMR（热模块替换）支持不足等痛点。  核心思想：Vitest 利用 Vite 的 ESM-first 开发服务器和闪电般的 HMR 能力，为 JavaScript&#x2F;TypeScript 项目带来前所未有的快速测试体验，尤其适合基于 Vite 的现代前端项目。   一、为什么选择 Vitest？在前端开发日益复杂的今天，测试是保证代码质量和项目稳定性的关键环节。传统的测试框架，如 Jest，尽管功能强大，但在面对现代前端构建工具（如 ESM、TypeScript、JSX&#x2F;TSX 转换）时，往往需要额外的配置和转换步骤，导致测试启动慢、HMR 效率不高。Vitest 应运而生，旨在解决这些问题。 1.1 核心优势 Vite 驱动，极致速度：  直接利用 V...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dcf2aa7d0d13/" title="REALITY 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-26</div><div class="info-item-2">REALITY 协议详解</div></div><div class="info-2"><div class="info-item-1"> REALITY 是 Xray-core 团队在 2022 年底推出的一种创新型传输协议，旨在彻底解决传统代理协议在 TLS 流量伪装上面临的主动探测和 TLS 指纹识别问题。REALITY 的核心思想是“无服务器指纹，无 TLS 握手特征，无需伪装域名和证书”，它通过重用目标网站的 TLS 证书和握手，将代理流量伪装成访问真实网站的流量，从而达到前所未有的隐蔽性。  核心思想：服务器不再持有自己的 TLS 证书和域名，而是被动地作为中继，复用一个真实存在且受欢迎的 HTTPS 网站的 TLS 证书和握手，将代理流量伪装成访问该网站的流量，从而达到极高的隐蔽性，并且不再需要自签证书和伪装域名。   一、为什么需要 REALITY？尽管 VLESS+XTLS 和 Trojan 等协议已经提供了很强的隐蔽性，但它们仍面临一些挑战：  TLS 指纹识别 (TLS Fingerprinting)：即使使用合法证书，客户端（如 Xray 客户端）在进行 TLS 握手时，其行为模式（支持的密码套件、扩展顺序、记录大小等）可能与主流浏览器存在细微差异，形成独特的“TLS 指纹”。审查者可以分析...</div></div></div></a><a class="pagination-related" href="/f32c05ed494f/" title="VLESS协议详解：下一代无状态加密传输协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-29</div><div class="info-item-2">VLESS协议详解：下一代无状态加密传输协议</div></div><div class="info-2"><div class="info-item-1"> VLESS 是一种由 Xray-core 团队设计和实现的代理协议，旨在提供一种简洁、透明且高性能的传输方式。与 VMess 等协议不同，VLESS 自身不包含任何加密或混淆功能，它将这些任务委托给传输层（如 TLS, WebSocket）来完成。VLESS 的核心理念是“不加密，不混淆，只传输”，它极大地减少了协议自身的开销，从而带来了更快的速度和更低的资源占用。  核心思想：将协议开销降到最低，只负责将客户端的流量“透明”地转发给目标服务器，而将加密和混淆的重任完全交给底层的传输协议（如 TLS、WebSocket）。   一、VLESS 协议的诞生背景与目标VLESS 协议的诞生，是对 VMess 协议以及其他一些传统代理协议的反思和改进。它主要为了解决以下问题：  双重加密的性能损耗： 许多代理协议（如 VMess）自身会进行数据加密和混淆。 当这些协议再叠加 TLS（HTTPS）等传输层加密时，就会形成“双重加密”，导致不必要的 CPU 消耗和延迟。   协议特征暴露： 复杂的协议自身往往会产生固定的“指纹”或特征，可能被深度包检测 (DPI) 识别并封锁。 协议越简...</div></div></div></a><a class="pagination-related" href="/85efaf3bfadb/" title="Hysteria2 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-30</div><div class="info-item-2">Hysteria2 详解</div></div><div class="info-2"><div class="info-item-1"> Hysteria2 是 Hysteria 协议的下一代版本，它是一种高性能、抗审查的代理协议，专注于在高丢包、高延迟、带宽受限的网络环境下提供稳定快速的连接。Hysteria2 在其前身的基础上进行了多项重大改进，将底层传输协议从 QUIC 升级为基于自定义 UDP 的协议栈，并引入了更灵活的流量控制和更强大的抗审查特性。其核心理念是通过高效的 UDP 传输、TCP BBR 拥塞控制算法和 TLS 加密，在恶劣网络条件下最大化可用带宽，同时保持高度的隐蔽性。  核心思想：在不可靠的 UDP 传输之上构建一个可靠的、高性能的、基于 TCP BBR 算法的传输层，并结合 TLS 加密和流量伪装，以应对高丢包、高延迟和严格审查的网络环境。   一、为什么需要 Hysteria2？传统的代理协议，无论是基于 TCP (如 Shadowsocks TCP, VLESS&#x2F;Trojan over TCP+TLS) 还是基于 QUIC (如 Hysteria1)，在高丢包率、高延迟的网络环境中（例如跨国长距离传输、卫星网络、受到干扰的网络）都可能表现不佳：  TCP 协议的固有局限性...</div></div></div></a><a class="pagination-related" href="/e0277d8d795d/" title="XTLS (eXtended TLS) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-03</div><div class="info-item-2">XTLS (eXtended TLS) 详解</div></div><div class="info-2"><div class="info-item-1"> XTLS (eXtended TLS) 是 Xray-core 提出的一种创新性传输协议，旨在解决传统代理方案中 TLS 双重加密带来的性能损耗，同时保持甚至增强流量的隐蔽性。XTLS 的核心思想是优化 TLS 加密过程，只对必要的数据进行加密，避免重复加密，从而提高代理的性能和降低资源占用。  核心思想：避免 TLS 双重加密，直接复用 TLS 握手后的加密会话，将代理协议数据直接封装在 TLS Payload 中，从而实现高性能且隐蔽的传输。   一、为什么需要 XTLS？在 VLESS+WS+TLS 或 VMess+WS+TLS 等传统代理方案中，数据流通常会经历双重加密：  代理协议自身加密：例如，VMess 协议会对数据进行加密（VLESS 自身不加密，但通常会与其他加密方案结合）。 传输层 TLS 加密：WebSocket 流量再通过 TLS 进行加密，形成 代理协议数据 -&gt; WS 帧 -&gt; TLS 记录 的封装。  这种双重加密虽然增强了安全性，但带来了以下问题：  性能损耗：加密和解密操作是 CPU 密集型的，双重加密会显著增加 CPU 负担，尤其...</div></div></div></a><a class="pagination-related" href="/14fbc43cdbd2/" title="Trojan协议详解：伪装为 HTTPS 的无状态代理协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="info-item-2">Trojan协议详解：伪装为 HTTPS 的无状态代理协议</div></div><div class="info-2"><div class="info-item-1"> Trojan 是一个开源的代理协议，其核心设计理念是“伪装为最常见的 HTTPS 流量”。它通过模仿 HTTPS 流量的特征，并利用 TLS (Transport Layer Security) 的加密和认证机制，旨在实现几乎无法被识别和阻断的代理连接。Trojan 协议放弃了传统代理协议常见的复杂头部和混淆算法，转而直接将代理数据封装在 TLS 中，并强制要求使用 443 端口和合法 TLS 证书，以最大化其隐蔽性。  核心思想：将代理流量深度伪装为 HTTPS 流量，通过在 443 端口上直接利用 TLS 协议的加密会话来传输代理数据，从而使其在外部看来与正常的 HTTPS 流量几乎无异。   一、Trojan 协议的诞生背景与目标Trojan 协议的出现，是对传统代理协议（如 Shadowsocks、VMess 等）在对抗深度包检测 (DPI) 和主动探测时的局限性的一种回应。主要背景如下：  协议特征识别：许多代理协议，即使经过混淆，仍可能因其特定的协议头部、握手流程、流量模式或不符合 TLS 规范的行为而被识别。 主动探测：审查系统可能会主动连接代理服务器，发送探测包...</div></div></div></a><a class="pagination-related" href="/a9313d4ed6e2/" title="Dokodemo-door 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="info-item-2">Dokodemo-door 协议详解</div></div><div class="info-2"><div class="info-item-1"> Dokodemo-door (任意门) 是 V2Ray (Project V) 中一个特殊的 Inbound (入站) 代理协议。它的设计灵感来源于哆啦A梦的“任意门”，主要作用是将指定端口或 IP&#x2F;端口范围的所有流量透明地转发到预设的目标地址。与 SOCKS、HTTP 等常见的代理协议不同，Dokodemo-door 不期望客户端发送任何代理协议头信息，而是直接捕获并处理原始的 TCP&#x2F;UDP 流量。  核心思想：透明地拦截并重定向指定端口&#x2F;IP 的网络流量，无需客户端配置代理，实现“强制代理”或“透明代理”的效果。   一、Dokodemo-door 的工作原理与用途Dokodemo-door 协议本身并不是一个用于客户端与 V2Ray 服务端通信的“伪装”或“加密”协议（如 VMess、VLESS、Trojan）。它是一个入站协议 (Inbound Protocol)，这意味着它在 V2Ray 的服务器端或本地代理端接收流量。 1.1 工作原理当配置了 Dokodemo-door Inbound 时，V2Ray 会监听指定的端口和&#x2F;...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">499</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81TUN-%E9%9A%A7%E9%81%93%E6%A6%82%E8%BF%B0"><span class="toc-text">一、TUN 隧道概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-TAP-%E4%B8%8E-TUN"><span class="toc-text">1.1 TAP 与 TUN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-TUN-%E9%9A%A7%E9%81%93%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-text">1.2 TUN 隧道的用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TUN-%E9%9A%A7%E9%81%93%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、TUN 隧道工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA-TUN-%E6%8E%A5%E5%8F%A3%EF%BC%88Python%EF%BC%89"><span class="toc-text">2.1 示例：创建 TUN 接口（Python）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B5%81%E5%90%91%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.2 数据包流向示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP-SOCKS-%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、HTTP&#x2F;SOCKS 代理详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-HTTP-%E4%BB%A3%E7%90%86"><span class="toc-text">3.1 HTTP 代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-SOCKS-%E4%BB%A3%E7%90%86"><span class="toc-text">3.2 SOCKS 代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81TUN-%E9%9A%A7%E9%81%93%E4%B8%8E-HTTP-SOCKS-%E4%BB%A3%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-text">四、TUN 隧道与 HTTP&#x2F;SOCKS 代理对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">五、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-27.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>