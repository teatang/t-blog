<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RESTful API 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RESTful API 是一种遵循 REST (Representational State Transfer) 架构风格的应用编程接口。它定义了一组约束和原则，旨在创建可伸缩、易于集成且高效的Web服务。RESTful API 的核心思想是将网络上的事物抽象为资源，并通过统一的接口对这些资源进行操作。  REST 原则最初由 Roy Fielding 在其 2000 年的博士论文中提出，主要用">
<meta property="og:type" content="article">
<meta property="og:title" content="RESTful API 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/31b72f75a47a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="RESTful API 是一种遵循 REST (Representational State Transfer) 架构风格的应用编程接口。它定义了一组约束和原则，旨在创建可伸缩、易于集成且高效的Web服务。RESTful API 的核心思想是将网络上的事物抽象为资源，并通过统一的接口对这些资源进行操作。  REST 原则最初由 Roy Fielding 在其 2000 年的博士论文中提出，主要用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg">
<meta property="article:published_time" content="2024-04-22T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-26T03:25:52.149Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="API">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RESTful API 详解",
  "url": "https://blog.tbf1211.xx.kg/31b72f75a47a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-26.jpg",
  "datePublished": "2024-04-22T22:24:00.000Z",
  "dateModified": "2026-02-26T03:25:52.149Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/31b72f75a47a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RESTful API 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">557</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-26.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">RESTful API 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RESTful API 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-04-22T22:24:00.000Z" title="发表于 2024-04-23 06:24:00">2024-04-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/API/">API</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>RESTful API</strong> 是一种遵循 <strong>REST (Representational State Transfer)</strong> 架构风格的应用编程接口。它定义了一组约束和原则，旨在创建可伸缩、易于集成且高效的Web服务。RESTful API 的核心思想是将网络上的事物抽象为资源，并通过统一的接口对这些资源进行操作。</p>
</blockquote>
<div class="note info flat"><p>REST 原则最初由 Roy Fielding 在其 2000 年的博士论文中提出，主要用于指导分布式超媒体系统的设计，如万维网。它不是一个标准，而是一种架构风格。</p>
</div>

<hr>
<h2 id="一、为什么需要-RESTful-API？"><a href="#一、为什么需要-RESTful-API？" class="headerlink" title="一、为什么需要 RESTful API？"></a>一、为什么需要 RESTful API？</h2><p>在互联网早期，Web 应用多以动态页面为主，前后端耦合度高。随着互联网和移动设备的快速发展，客户端类型日益多样化（Web 浏览器、移动 App、小程序等），前后端分离成为主流。 此时，一个结构清晰、符合标准、易于理解和扩展的接口规范显得尤为重要，RESTful API 正是为了满足这一需求而兴起。</p>
<p><strong>RESTful API 的优势包括：</strong></p>
<ul>
<li><strong>客户端-服务器分离 (Separation of Concerns)</strong>：客户端和服务器端可以独立开发和部署，互不依赖，提高了开发效率和系统的可维护性。</li>
<li><strong>无状态 (Statelessness)</strong>：服务器不保存任何客户端上下文信息或会话状态。每个请求都包含处理该请求所需的所有信息，这简化了服务器设计并提高了可伸缩性。</li>
<li><strong>可缓存性 (Cacheability)</strong>：服务器响应可以被客户端或中间代理缓存，减少了服务器负载，提高了性能。</li>
<li><strong>统一接口 (Uniform Interface)</strong>：通过使用标准 HTTP 方法和 URI 标识资源，使 API 易于理解和使用，提高了互操作性。</li>
<li><strong>可伸缩性 (Scalability)</strong>：由于无状态特性和客户端-服务器分离，RESTful API 更容易进行水平扩展以应对高并发请求。</li>
<li><strong>灵活性和可移植性 (Flexibility and Portability)</strong>：数据可以在不同服务器之间轻松转移，支持多种数据格式（如 JSON、XML），且不依赖特定平台或编程语言。</li>
</ul>
<p><strong>然而，RESTful API 也存在一些挑战：</strong></p>
<ul>
<li><strong>过度获取 (Over-fetching) &#x2F; 获取不足 (Under-fetching)</strong>：客户端可能获取到比所需更多的数据，或者需要发起多次请求才能获取到所有必需的数据，这可能导致效率低下。</li>
<li><strong>版本管理 (Versioning)</strong>：随着 API 演进，管理不同版本的 API 可能会变得复杂。</li>
<li><strong>复杂查询 (Complex Queries)</strong>：对于复杂的查询，可能需要多个端点，增加了客户端逻辑的复杂性。</li>
<li><strong>HATEOAS 的实现复杂性</strong>：虽然 HATEOAS 是 REST 的核心原则之一，但实际实现可能增加API的复杂性。</li>
<li><strong>缺乏标准化错误处理</strong>：RESTful API 没有一个标准化的错误处理方式，这可能使开发者难以理解和解决问题。</li>
</ul>
<h2 id="二、REST-架构原则-Roy-Fielding-的六大约束"><a href="#二、REST-架构原则-Roy-Fielding-的六大约束" class="headerlink" title="二、REST 架构原则 (Roy Fielding 的六大约束)"></a>二、REST 架构原则 (Roy Fielding 的六大约束)</h2><p>REST (Representational State Transfer) 是一种架构风格，它基于以下六个核心约束来设计分布式系统，以实现高性能、可靠性和可伸缩性。</p>
<h3 id="2-1-客户端-服务器分离-Client-Server-Separation"><a href="#2-1-客户端-服务器分离-Client-Server-Separation" class="headerlink" title="2.1 客户端-服务器分离 (Client-Server Separation)"></a>2.1 客户端-服务器分离 (Client-Server Separation)</h3><p>此原则强调客户端和服务器之间的职责分离。客户端负责用户界面和用户状态管理，而服务器负责数据存储、处理和提供资源。这种分离使得客户端和服务器可以独立发展、更新和部署，不受彼此技术栈或平台的影响。</p>
<h3 id="2-2-无状态-Statelessness"><a href="#2-2-无状态-Statelessness" class="headerlink" title="2.2 无状态 (Statelessness)"></a>2.2 无状态 (Statelessness)</h3><p>RESTful API 的服务器必须是无状态的。这意味着每个来自客户端的请求都必须包含服务器处理该请求所需的所有信息，服务器不会存储任何客户端的会话状态。 客户端在发出请求时会携带身份验证、会话或其他必要的上下文信息。这种设计提高了系统的可见性、可靠性和可伸缩性。</p>
<h3 id="2-3-可缓存性-Cacheability"><a href="#2-3-可缓存性-Cacheability" class="headerlink" title="2.3 可缓存性 (Cacheability)"></a>2.3 可缓存性 (Cacheability)</h3><p>服务器的响应必须显式或隐式地声明它是否可被缓存。如果响应是可缓存的，客户端可以将该响应存储起来，并在后续对相同资源的请求中重用它，从而减少网络往返次数和服务器负载。这极大地提高了 API 的性能和可伸缩性。</p>
<h3 id="2-4-统一接口-Uniform-Interface"><a href="#2-4-统一接口-Uniform-Interface" class="headerlink" title="2.4 统一接口 (Uniform Interface)"></a>2.4 统一接口 (Uniform Interface)</h3><p>统一接口是 REST 架构最核心的原则，它简化了整个系统架构，提高了所有组件的通用性和交互效率。它由以下四个子约束组成：</p>
<h4 id="2-4-1-资源标识-Identification-of-Resources"><a href="#2-4-1-资源标识-Identification-of-Resources" class="headerlink" title="2.4.1 资源标识 (Identification of Resources)"></a>2.4.1 资源标识 (Identification of Resources)</h4><p>所有资源都应通过统一资源标识符 (URI) 唯一标识。URI 类似于网站地址，明确指明客户端请求的内容。在 RESTful API 中，URI 通常使用名词来表示资源，避免使用动词。</p>
<ul>
<li><strong>示例:</strong><ul>
<li>获取所有用户：<code>/users</code></li>
<li>获取 ID 为 <code>123</code> 的用户：<code>/users/123</code></li>
<li>获取 ID 为 <code>123</code> 的用户的订单：<code>/users/123/orders</code></li>
</ul>
</li>
</ul>
<h4 id="2-4-2-通过表述来操作资源-Manipulation-of-Resources-Through-Representations"><a href="#2-4-2-通过表述来操作资源-Manipulation-of-Resources-Through-Representations" class="headerlink" title="2.4.2 通过表述来操作资源 (Manipulation of Resources Through Representations)"></a>2.4.2 通过表述来操作资源 (Manipulation of Resources Through Representations)</h4><p>客户端通过获取资源的表述 (Representation) 来操作资源。资源的表述是其当前状态的快照，常见的格式包括 JSON、XML、HTML 等。客户端可以修改接收到的资源表述，并通过将其发送回服务器来改变资源的状态。</p>
<ul>
<li><strong>示例:</strong> 客户端通过发送一个包含 JSON 格式用户数据的 PUT 请求来更新一个用户。</li>
</ul>
<h4 id="2-4-3-自描述消息-Self-descriptive-Messages"><a href="#2-4-3-自描述消息-Self-descriptive-Messages" class="headerlink" title="2.4.3 自描述消息 (Self-descriptive Messages)"></a>2.4.3 自描述消息 (Self-descriptive Messages)</h4><p>每个消息都应该包含足够的信息来描述如何处理该消息。这意味着客户端和服务器之间的每次通信都应该包含请求或响应的上下文信息，而无需额外的元数据或带外信息。HTTP 头部和状态码在其中扮演着重要角色。</p>
<ul>
<li><strong>示例:</strong> HTTP 响应头 <code>Content-Type: application/json</code> 告诉客户端响应体是 JSON 格式。HTTP 状态码（如 200 OK, 404 Not Found）直接指示了请求的结果。</li>
</ul>
<h4 id="2-4-4-超媒体作为应用状态的引擎-Hypermedia-as-the-Engine-of-Application-State-HATEOAS"><a href="#2-4-4-超媒体作为应用状态的引擎-Hypermedia-as-the-Engine-of-Application-State-HATEOAS" class="headerlink" title="2.4.4 超媒体作为应用状态的引擎 (Hypermedia as the Engine of Application State - HATEOAS)"></a>2.4.4 超媒体作为应用状态的引擎 (Hypermedia as the Engine of Application State - HATEOAS)</h4><p>HATEOAS 是 REST 架构中一个非常重要的约束，但常常被忽视或实现不完整。它要求 API 响应不仅包含数据，还应包含引导客户端进行下一步操作的超媒体链接。 客户端无需预先硬编码所有的 API 端点，而是通过这些动态提供的链接来发现和导航 API 的功能。这提高了 API 的可发现性、灵活性和解耦性。</p>
<ul>
<li><p><strong>示例 (不含 HATEOAS):</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>客户端需要事先知道如何更新或删除该用户。</p>
</li>
<li><p><strong>示例 (含 HATEOAS):</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan@example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;self&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/users/1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/users/1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;delete&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/users/1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;orders&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/users/1/orders&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>响应中包含了指向相关操作的链接，客户端可以根据这些链接动态地与资源进行交互。</p>
</li>
</ul>
<h3 id="2-5-分层系统-Layered-System"><a href="#2-5-分层系统-Layered-System" class="headerlink" title="2.5 分层系统 (Layered System)"></a>2.5 分层系统 (Layered System)</h3><p>客户端通常无法分辨它究竟是直接连接到最终服务器，还是连接到中间代理、负载均衡器或网关。在分层系统中，客户端可以直接连接到任何中间层，这些中间层可以用来提供安全、缓存、负载均衡等服务，而对客户端是透明的。</p>
<h3 id="2-6-按需代码-Code-On-Demand-可选"><a href="#2-6-按需代码-Code-On-Demand-可选" class="headerlink" title="2.6 按需代码 (Code-On-Demand) (可选)"></a>2.6 按需代码 (Code-On-Demand) (可选)</h3><p>此约束是可选的。它允许服务器暂时扩展或自定义客户端的功能，通过向客户端发送可执行代码（如 JavaScript），从而减少客户端对预部署功能的依赖。</p>
<h2 id="三、RESTful-API-的关键组成部分"><a href="#三、RESTful-API-的关键组成部分" class="headerlink" title="三、RESTful API 的关键组成部分"></a>三、RESTful API 的关键组成部分</h2><h3 id="3-1-资源-Resources-和-URI-Uniform-Resource-Identifier"><a href="#3-1-资源-Resources-和-URI-Uniform-Resource-Identifier" class="headerlink" title="3.1 资源 (Resources) 和 URI (Uniform Resource Identifier)"></a>3.1 资源 (Resources) 和 URI (Uniform Resource Identifier)</h3><p>RESTful API 的核心是资源。资源可以是任何信息，如用户、产品、订单、文档等。 每个资源都通过唯一的 URI 来标识。URI 是资源的地址，类似于您在浏览器中输入的网址。</p>
<ul>
<li><strong>命名约定:</strong><ul>
<li><strong>使用名词而不是动词</strong>：URI 应表示资源本身，操作通过 HTTP 方法来定义。</li>
<li><strong>使用复数名词表示集合</strong>：例如 <code>/users</code> (用户集合)，<code>/products</code> (产品集合)。</li>
<li><strong>保持层级结构清晰</strong>：嵌套资源应反映其关系，但避免过深的嵌套。<ul>
<li>正确示例: <code>/users/&#123;id&#125;/orders</code> </li>
<li>避免示例: <code>/getAllUsers</code> (<code>GET /users</code> 即可)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-HTTP-方法-HTTP-Methods"><a href="#3-2-HTTP-方法-HTTP-Methods" class="headerlink" title="3.2 HTTP 方法 (HTTP Methods)"></a>3.2 HTTP 方法 (HTTP Methods)</h3><p>HTTP 方法（或谓词）是您对资源执行操作的“动词”。RESTful API 严格遵循 HTTP 协议定义的标准方法来执行 CRUD (Create, Read, Update, Delete) 操作，确保了一致性和可预测性。</p>
<ul>
<li><strong>GET</strong>：从服务器检索一个或多个资源的表示。GET 请求应该是安全的（不修改服务器状态）和幂等的（重复执行多次与执行一次效果相同）。<ul>
<li>示例: <code>GET /users</code> (获取所有用户), <code>GET /users/123</code> (获取 ID 为 123 的用户)</li>
</ul>
</li>
<li><strong>POST</strong>：在集合资源下创建新资源。POST 请求通常不是幂等的。<ul>
<li>示例: <code>POST /users</code> (创建一个新用户)</li>
</ul>
</li>
<li><strong>PUT</strong>：用请求体中提供的数据<em>完整替换</em>现有资源，或者在 URI 指定的资源不存在时创建新资源。PUT 请求是幂等的。<ul>
<li>示例: <code>PUT /users/123</code> (更新 ID 为 123 的用户的所有信息)</li>
</ul>
</li>
<li><strong>PATCH</strong>：对现有资源进行<em>部分修改</em>。PATCH 请求通常不是幂等的。<ul>
<li>示例: <code>PATCH /users/123</code> (更新 ID 为 123 的用户的部分属性，例如只修改姓名)</li>
</ul>
</li>
<li><strong>DELETE</strong>：删除 URI 指定的资源。DELETE 请求是幂等的。<ul>
<li>示例: <code>DELETE /users/123</code> (删除 ID 为 123 的用户)</li>
</ul>
</li>
</ul>
<h3 id="3-3-资源表述-Resource-Representations"><a href="#3-3-资源表述-Resource-Representations" class="headerlink" title="3.3 资源表述 (Resource Representations)"></a>3.3 资源表述 (Resource Representations)</h3><p>客户端和服务器之间传输的数据是资源的“表述”，而不是资源本身。最常见的表述格式是 <strong>JSON (JavaScript Object Notation)</strong>，因为它轻量、人类可读且易于被编程语言解析。 其他格式如 XML、HTML、纯文本等也可以使用。</p>
<h3 id="3-4-HTTP-状态码-HTTP-Status-Codes"><a href="#3-4-HTTP-状态码-HTTP-Status-Codes" class="headerlink" title="3.4 HTTP 状态码 (HTTP Status Codes)"></a>3.4 HTTP 状态码 (HTTP Status Codes)</h3><p>HTTP 状态码是服务器对请求结果的反馈，是 RESTful API 约定的一部分。它们清晰地指示请求是否成功、客户端是否有误、或服务器发生了什么问题。</p>
<ul>
<li><strong>1xx (信息响应)</strong>：请求已接收，继续处理。</li>
<li><strong>2xx (成功)</strong>：请求已成功被接收、理解、并接受处理。<ul>
<li><code>200 OK</code>：请求成功，并返回数据。</li>
<li><code>201 Created</code>：请求成功，并在服务器上创建了新资源。通常用于 <code>POST</code> 请求的成功响应。</li>
<li><code>202 Accepted</code>：请求已接受处理，但尚未完成。</li>
<li><code>204 No Content</code>：请求成功，但没有返回响应体（例如 <code>DELETE</code> 请求）。</li>
</ul>
</li>
<li><strong>3xx (重定向)</strong>：需要采取进一步的操作才能完成请求。</li>
<li><strong>4xx (客户端错误)</strong>：请求包含语法错误或无法完成请求。<ul>
<li><code>400 Bad Request</code>：客户端发送的请求有语法错误或请求参数无效。</li>
<li><code>401 Unauthorized</code>：请求需要用户身份验证。</li>
<li><code>403 Forbidden</code>：服务器理解请求，但拒绝执行。通常是权限不足。</li>
<li><code>404 Not Found</code>：服务器找不到请求的资源。</li>
<li><code>409 Conflict</code>：请求与服务器的当前状态冲突。</li>
<li><code>422 Unprocessable Entity</code>：请求的格式正确，但由于语义错误无法处理。</li>
</ul>
</li>
<li><strong>5xx (服务器错误)</strong>：服务器在处理请求时发生错误。<ul>
<li><code>500 Internal Server Error</code>：服务器遇到了一个意外情况，阻止了其完成请求。</li>
<li><code>503 Service Unavailable</code>：服务器目前无法处理请求，通常是由于服务器过载或停机维护。</li>
</ul>
</li>
</ul>
<h2 id="四、RESTful-API-设计最佳实践"><a href="#四、RESTful-API-设计最佳实践" class="headerlink" title="四、RESTful API 设计最佳实践"></a>四、RESTful API 设计最佳实践</h2><h3 id="4-1-资源命名规范"><a href="#4-1-资源命名规范" class="headerlink" title="4.1 资源命名规范"></a>4.1 资源命名规范</h3><ul>
<li><strong>使用名词，避免动词</strong>：如前所述，URI 应表示资源本身，操作意图通过 HTTP 方法表达。<ul>
<li>推荐: <code>GET /users</code>, <code>POST /products</code></li>
<li>避免: <code>GET /getAllUsers</code>, <code>POST /createNewProduct</code></li>
</ul>
</li>
<li><strong>使用复数名词表示集合</strong>： <code>/users</code>, <code>/orders</code>。对于某个特定资源，则使用其唯一标识符，例如 <code>/users/123</code>。</li>
<li><strong>保持 URI 简洁、直观</strong>：避免过长或难以理解的 URI。</li>
<li><strong>小写字母</strong>：统一使用小写字母。</li>
<li><strong>使用 <code>resources</code> 来表示子资源，例如 <code>/users/&#123;userId&#125;/addresses</code></strong>。</li>
</ul>
<h3 id="4-2-HTTP-方法的正确使用"><a href="#4-2-HTTP-方法的正确使用" class="headerlink" title="4.2 HTTP 方法的正确使用"></a>4.2 HTTP 方法的正确使用</h3><p>严格按照 HTTP 方法的语义进行操作，保持 API 行为的一致性和可预测性。</p>
<ul>
<li><code>GET</code>：只用于读取数据，不应改变服务器状态。</li>
<li><code>POST</code>：用于创建新资源或执行非幂等操作。</li>
<li><code>PUT</code>：用于完整替换资源。</li>
<li><code>PATCH</code>：用于部分更新资源。</li>
<li><code>DELETE</code>：用于删除资源。</li>
</ul>
<h3 id="4-3-版本控制-Versioning"><a href="#4-3-版本控制-Versioning" class="headerlink" title="4.3 版本控制 (Versioning)"></a>4.3 版本控制 (Versioning)</h3><p>随着 API 的演进，不可避免地会出现需要修改 API 的情况。为了避免破坏现有客户端，进行版本控制至关重要。</p>
<ul>
<li><strong>URL 版本控制 (Path Versioning)</strong>：在 URI 中包含版本号。<ul>
<li><code>GET /v1/users</code></li>
<li>优点：直观、易于部署。</li>
<li>缺点：URI 不够“纯粹”，违反了 URI 标识资源的单一性。</li>
</ul>
</li>
<li><strong>Header 版本控制</strong>：通过自定义 HTTP Header 来指定 API 版本。<ul>
<li><code>Accept-Version: v1</code></li>
<li>优点：URI 保持不变，符合 REST 原则。</li>
<li>缺点：客户端调试不如 URL 直观。</li>
</ul>
</li>
</ul>
<h3 id="4-4-认证与授权-Authentication-Authorization"><a href="#4-4-认证与授权-Authentication-Authorization" class="headerlink" title="4.4 认证与授权 (Authentication &amp; Authorization)"></a>4.4 认证与授权 (Authentication &amp; Authorization)</h3><p>保护 API 免受未经授权的访问至关重要。</p>
<ul>
<li><strong>认证 (Authentication)</strong>：验证客户端的身份。<ul>
<li><strong>OAuth 2.0</strong>：广泛使用的授权框架，用于第三方应用访问用户资源。</li>
<li><strong>Bearer Token&#x2F;JWT (JSON Web Token)</strong>：通过在 <code>Authorization</code> 头中发送一个令牌来认证客户端，服务器通过解密令牌来验证身份。</li>
<li><strong>API Key</strong>：简单的身份验证机制，通过在请求头或查询参数中发送一个密钥。</li>
</ul>
</li>
<li><strong>授权 (Authorization)</strong>：确定已认证的客户端是否有权执行请求的操作。这通常在服务器端通过角色、权限等机制实现。</li>
</ul>
<h3 id="4-5-错误处理-Error-Handling"><a href="#4-5-错误处理-Error-Handling" class="headerlink" title="4.5 错误处理 (Error Handling)"></a>4.5 错误处理 (Error Handling)</h3><p>提供清晰、一致、机器可读的错误响应，帮助客户端开发者快速定位和解决问题。</p>
<ul>
<li><p><strong>使用标准的 HTTP 状态码</strong>：如 <code>400 Bad Request</code>、<code>401 Unauthorized</code>、<code>404 Not Found</code>、<code>500 Internal Server Error</code> 等。</p>
</li>
<li><p><strong>提供详细的错误信息</strong>：在响应体中包含错误码、错误消息和可选的详细信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">40001</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Invalid input provided&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The &#x27;name&#x27; field is required.&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-6-分页、过滤和排序"><a href="#4-6-分页、过滤和排序" class="headerlink" title="4.6 分页、过滤和排序"></a>4.6 分页、过滤和排序</h3><p>对于返回大量数据的集合资源，应支持分页、过滤和排序以提高效率。</p>
<ul>
<li><strong>分页参数</strong>：通常使用 <code>page</code>、<code>limit</code>、<code>offset</code> 等查询参数。<ul>
<li>示例: <code>GET /users?page=2&amp;limit=10</code></li>
</ul>
</li>
<li><strong>过滤参数</strong>：可根据资源的属性进行过滤。<ul>
<li>示例: <code>GET /products?category=electronics&amp;price_lt=100</code></li>
</ul>
</li>
<li><strong>排序参数</strong>：根据一个或多个字段进行排序。<ul>
<li>示例: <code>GET /users?sort=name_asc</code></li>
</ul>
</li>
</ul>
<h2 id="五、RESTful-API-架构示意图"><a href="#五、RESTful-API-架构示意图" class="headerlink" title="五、RESTful API 架构示意图"></a>五、RESTful API 架构示意图</h2><p>RESTful API 的核心在于客户端与服务器之间的无状态通信和对资源的统一操作。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph Client [客户端层]
        Browser[浏览器]
        Mobile_App[移动应用]
        Other_Service[第三方服务]
    end

    subgraph API_Gateway_Load_Balancer [网关与负载均衡]
        LB[Load Balancer]
    end

    subgraph Server_APIs [API 服务层]
        API_A[API Service A - 用户]
        API_B[API Service B - 产品]
        API_C[API Service C - 订单]
    end

    subgraph Databases [数据库层]
        DB_A[(Database A)]
        DB_B[(Database B)]
        DB_C[(Database C)]
    end

    %% 流程连接
    Browser &amp; Mobile_App &amp; Other_Service -- &quot;HTTPS 请求&quot; --&gt; LB

    LB -- &quot;路由分发&quot; --&gt; API_A
    LB -- &quot;路由分发&quot; --&gt; API_B
    LB -- &quot;路由分发&quot; --&gt; API_C

    %% API 与 数据库双向交互
    API_A &lt;--&gt; DB_A
    API_B &lt;--&gt; DB_B
    API_C &lt;--&gt; DB_C

    %% 响应返回
    API_A &amp; API_B &amp; API_C -- &quot;HTTP 响应&quot; --&gt; LB
    LB -- &quot;返回数据&quot; --&gt; Client
  </pre></div>

<p><strong>说明:</strong></p>
<ul>
<li><strong>客户端 (Client)</strong>：可以是任何能够发送 HTTP 请求的应用程序，如 Web 浏览器、移动应用、桌面应用或其他服务。</li>
<li><strong>API 网关&#x2F;负载均衡器 (API Gateway&#x2F;Load Balancer)</strong>：作为客户端和后端服务之间的入口点。负载均衡器负责将请求分发到多个服务器实例，提高可用性和伸缩性。API 网关可以提供认证、授权、限流、日志等功能，对后端服务进行统一管理。</li>
<li><strong>服务器 API (Server APIs)</strong>：一组独立的微服务或模块，每个负责管理特定的资源。它们遵循 RESTful 原则，对外暴露资源端点。</li>
<li><strong>数据库 (Databases)</strong>：存储资源数据的后端存储。可以是关系型数据库、NoSQL 数据库等。</li>
<li><strong>通信协议</strong>：主要通过 HTTP&#x2F;HTTPS 进行通信，HTTPS 提供加密和安全性。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>RESTful API 作为一种强大的架构风格，已经成为构建现代 Web 服务的首选。它通过强调资源的抽象、统一的接口、无状态通信和标准化的 HTTP 方法，极大地简化了客户端与服务器之间的交互，提高了系统的可伸缩性、可维护性和互操作性。</p>
<p>理解并遵循 REST 的六大核心原则（客户端-服务器分离、无状态、可缓存性、统一接口、分层系统、按需代码）以及最佳实践（资源命名、HTTP 方法的使用、版本控制、认证授权、错误处理等）对于设计和实现高质量的 RESTful API 至关重要。虽然 RESTful API 也存在一些挑战，如过度&#x2F;不足获取或 HATEOAS 的实现复杂性，但其带来的诸多优势使其在绝大多数分布式系统设计中依然占据主导地位。随着技术发展，新的 API 风格（如 GraphQL）也在特定场景下提供了更灵活的选择，但 RESTful API 的基本思想和原则仍是理解现代 API 生态的基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/31b72f75a47a/">https://blog.tbf1211.xx.kg/31b72f75a47a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/API/">API</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-26.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/4ab77d7b3a4c/" title="GraphQL 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">GraphQL 详解</div></div><div class="info-2"><div class="info-item-1"> GraphQL 是一种用于 API 的查询语言 (Query Language)，也是一个满足这些查询的运行时 (Runtime)。它由 Facebook 于 2012 年内部开发，并于 2015 年开源。与 RESTful API 不同，GraphQL 允许客户端精确地请求所需数据，解决了传统 REST API 中常见的“过度获取 (over-fetching)”和“获取不足 (under-fetching)”问题。  核心思想：由客户端定义它需要什么数据，而不是由服务器定义提供什么数据。    一、为什么需要 GraphQL？传统的 RESTful API 通常通过一系列固定的端点 (endpoints) 来提供服务。例如，/users 可能返回所有用户，/users/&#123;id&#125; 返回特定用户。然而，这种模式在以下场景中会遇到挑战：  过度获取 (Over-fetching)：客户端可能只需要用户的部分信息（例如姓名和邮箱），但 RESTful API 的 /users/&#123;id&#125; 端点可能返回用户的全部信息（包括地址、电话、创建时间等）...</div></div></div></a><a class="pagination-related" href="/9c9de7393330/" title="PM2 (Process Manager 2) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">PM2 (Process Manager 2) 详解</div></div><div class="info-2"><div class="info-item-1"> PM2 (Process Manager 2) 是一个功能丰富的、生产就绪的 Node.js 应用进程管理器，它专注于提供高可用性、简化部署和自动化运维。它通过监控应用状态、自动重启崩溃进程、实现零停机重新加载和内置负载均衡来确保 Node.js 应用的健壮运行。PM2 是部署 Node.js 应用到生产环境的推荐工具之一。  核心思想：PM2 将 Node.js 应用作为一个守护进程 (daemon) 托管，负责其生命周期管理。它能够自动处理应用崩溃、实现多核 CPU 利用 (集群模式)、简化日志管理和提供实时监控，从而保证应用服务的持续稳定运行。   一、为什么需要 PM2？传统的 Node.js 应用启动方式通常是 node app.js。这种方式在生产环境中存在诸多问题：  单点故障 (Single Point of Failure)：如果应用进程因为未捕获的异常崩溃，整个服务将停止，用户无法访问。 资源利用不足：Node.js 默认是单线程模型，即使服务器有多个 CPU 核心，一个 node app.js 进程也只能利用其中一个核心，无法充分利用硬件资源来处理高并发请...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/4ab77d7b3a4c/" title="GraphQL 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-25</div><div class="info-item-2">GraphQL 详解</div></div><div class="info-2"><div class="info-item-1"> GraphQL 是一种用于 API 的查询语言 (Query Language)，也是一个满足这些查询的运行时 (Runtime)。它由 Facebook 于 2012 年内部开发，并于 2015 年开源。与 RESTful API 不同，GraphQL 允许客户端精确地请求所需数据，解决了传统 REST API 中常见的“过度获取 (over-fetching)”和“获取不足 (under-fetching)”问题。  核心思想：由客户端定义它需要什么数据，而不是由服务器定义提供什么数据。    一、为什么需要 GraphQL？传统的 RESTful API 通常通过一系列固定的端点 (endpoints) 来提供服务。例如，/users 可能返回所有用户，/users/&#123;id&#125; 返回特定用户。然而，这种模式在以下场景中会遇到挑战：  过度获取 (Over-fetching)：客户端可能只需要用户的部分信息（例如姓名和邮箱），但 RESTful API 的 /users/&#123;id&#125; 端点可能返回用户的全部信息（包括地址、电话、创建时间等）...</div></div></div></a><a class="pagination-related" href="/0d9a05a8aba6/" title="MCU 与 SoC 对比与详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="info-item-2">MCU 与 SoC 对比与详解</div></div><div class="info-2"><div class="info-item-1"> MCU (Microcontroller Unit) 和 SoC (System on Chip) 是嵌入式系统设计中常用的两种核心集成电路（IC）。它们都旨在将多个功能集成到单个芯片上，以实现更紧凑、更高效的电子设备。然而，它们在设计理念、集成度、复杂度和应用场景上存在显著差异。理解这些差异对于选择合适的芯片进行产品开发至关重要。  核心思想：MCU是高度集成的专用微型计算机，强调自给自足和实时控制；SoC是高度集成的系统级芯片，旨在将整个电子系统所需的大多数甚至所有组件集成在一个芯片上，提供更强大的处理能力和更广泛的功能。   一、MCU (Microcontroller Unit) 微控制器1.1 定义与核心特点MCU 是一种将中央处理器 (CPU)、存储器 (RAM、ROM&#x2F;Flash)、定时器、输入&#x2F;输出 (I&#x2F;O) 端口以及各种外设接口 (如UART、SPI、I2C、ADC、DAC) 等功能模块集成在单一芯片上的微型计算机。 核心特点：  高度集成性：一个芯片即可构成一个完整的计算机系统，无需大量外部元件。 自给自足 (Self-con...</div></div></div></a><a class="pagination-related" href="/4d4d04e1eb80/" title="脉冲信号详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-15</div><div class="info-item-2">脉冲信号详解</div></div><div class="info-2"><div class="info-item-1"> 脉冲信号 (Pulse Signal) 是一种在短时间内快速变化并随后迅速恢复到初始状态的非连续信号。它通常由一个或多个短暂的电压或电流“突变”组成，这些突变相对于其持续的背景状态具有显著的幅值。脉冲信号是数字电路、通信、控制系统、雷达、医疗设备等众多领域的基础，承载着信息、控制时序或触发事件。  核心思想： 脉冲信号通过其幅值、宽度、周期、频率、占空比等特性来编码信息、驱动操作或提供时间基准。   一、脉冲信号的基本特性理想的脉冲信号是矩形的，但在实际中，脉冲往往具有一定的上升和下降时间。      graph TD     subgraph 理想脉冲特性         A[低电平] --&gt; B{上升沿}         B --&gt; C[&quot;高电平 (脉冲幅值)&quot;]         C --&gt; D{下降沿}         D --&gt; A     end     1.1 幅值 (Amplitude) 定义：脉冲信号从基准电平（通常是低电平）到峰值电平的电压或电流差。 作用：决定了脉冲的“强度”，在数字电路中通常对应逻辑高电平电压。 ...</div></div></div></a><a class="pagination-related" href="/876a758cde0d/" title=".gitignore 与 .gitattributes 文件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="info-item-2">.gitignore 与 .gitattributes 文件详解</div></div><div class="info-2"><div class="info-item-1"> .gitignore 和 .gitattributes 是 Git 版本控制系统中两个重要的配置文件，它们帮助开发者精细地控制 Git 如何处理工作目录中的文件。gitignore 主要用于忽略不应该被版本控制的文件，而 gitattributes 则用于定义不同文件的属性，影响 Git 存储和比较文件的方式。理解和正确使用这两个文件对于维护干净、高效且一致的 Git 仓库至关重要。  核心思想：  .gitignore 告诉 Git 哪些文件或目录应该被忽略，不纳入版本控制。 .gitattributes 告诉 Git 如何对待特定类型的文件，例如行尾符、合并策略、文本转换等。    一、.gitignore 文件详解.gitignore 文件用于指定 Git 应该忽略哪些文件或目录。 这些被忽略的文件不会被 Git 跟踪，也不会被添加到仓库中。这对于排除构建产物、日志文件、敏感配置、IDE 特定文件等内容非常有用，可以保持仓库的整洁，避免提交不必要的文件，并减少仓库大小。 1.1 工作原理Git 在执行 git add 或 git commit 等命令时，会检查工作目录中是...</div></div></div></a><a class="pagination-related" href="/6b2944831266/" title="Nginx 与 API Gateway 对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">Nginx 与 API Gateway 对比详解</div></div><div class="info-2"><div class="info-item-1"> 在现代的分布式系统和微服务架构中，处理客户端请求、路由流量、提供安全性和管理 API 是至关重要的。Nginx 和 API Gateway 是解决这些问题的两种主要技术。虽然它们在某些功能上有所重叠，但其核心设计理念、功能范畴和适用场景却有着显著差异。  核心概念：  Nginx：一个高性能的 HTTP 和反向代理服务器、邮件代理服务器以及通用 TCP&#x2F;UDP 代理服务器，以其轻量、高并发和低内存消耗而闻名。 API Gateway：一个处于客户端和一组后端服务之间的“单一入口点”，负责处理所有 API 请求的入口，并提供 API 管理、安全、限流、监控、日志等高级功能。     一、概述与核心定义1.1 NginxNginx (发音为 “engine-x”) 是一个高性能的 HTTP 和反向代理服务器、邮件代理服务器以及通用 TCP&#x2F;UDP 代理服务器。它以其卓越的性能、稳定性、丰富的功能集和低资源消耗而闻名。Nginx 最初是为解决 C10k 问题而设计，即在单个服务器上处理大量并发连接。 核心功能:  Web 服务器: 提供静态文件服务。 反向代理: ...</div></div></div></a><a class="pagination-related" href="/d89aa974f51f/" title="ESP32 Arduino 舵机详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="info-item-2">ESP32 Arduino 舵机详解</div></div><div class="info-2"><div class="info-item-1"> 舵机 (Servo Motor) 是一种集成了直流电机、减速齿轮组、电位器和控制电路的微型直流电机。它能够精确地控制输出轴的角度位置，通常在 0 到 180 度之间旋转（标准舵机），或者实现连续旋转（连续旋转舵机）。在机器人、航模、自动化控制等领域，舵机因其小巧、控制简单、定位精确而广受欢迎。  核心思想：通过调整 PWM (脉冲宽度调制) 信号的脉冲宽度来控制舵机的角度。ESP32 凭借其强大的 LEDC (LED Controller) 模块，能够轻松、精确地驱动多个舵机。   一、舵机工作原理舵机通过接收一个PWM (脉冲宽度调制) 信号来确定其旋转角度。  供电：舵机通常需要 5V 的电源供电。请注意，单个舵机在工作时可能会消耗数百毫安的电流，多个舵机同时工作时电流需求会更大，因此需要一个外部电源为舵机供电，而不是直接由 ESP32 的 3.3V 或 5V 引脚供电（除非是微型舵机且数量极少）。 控制信号：舵机的控制线接收一个周期为 20 毫秒（即 50 Hz）的 PWM 信号。 脉冲宽度决定角度： 1.5 毫秒的脉冲宽度通常对应舵机的中心位置 (90 度)。 1 毫秒...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">557</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-RESTful-API%EF%BC%9F"><span class="toc-text">一、为什么需要 RESTful API？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81REST-%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99-Roy-Fielding-%E7%9A%84%E5%85%AD%E5%A4%A7%E7%BA%A6%E6%9D%9F"><span class="toc-text">二、REST 架构原则 (Roy Fielding 的六大约束)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%86%E7%A6%BB-Client-Server-Separation"><span class="toc-text">2.1 客户端-服务器分离 (Client-Server Separation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%97%A0%E7%8A%B6%E6%80%81-Statelessness"><span class="toc-text">2.2 无状态 (Statelessness)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8F%AF%E7%BC%93%E5%AD%98%E6%80%A7-Cacheability"><span class="toc-text">2.3 可缓存性 (Cacheability)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3-Uniform-Interface"><span class="toc-text">2.4 统一接口 (Uniform Interface)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86-Identification-of-Resources"><span class="toc-text">2.4.1 资源标识 (Identification of Resources)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E9%80%9A%E8%BF%87%E8%A1%A8%E8%BF%B0%E6%9D%A5%E6%93%8D%E4%BD%9C%E8%B5%84%E6%BA%90-Manipulation-of-Resources-Through-Representations"><span class="toc-text">2.4.2 通过表述来操作资源 (Manipulation of Resources Through Representations)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E8%87%AA%E6%8F%8F%E8%BF%B0%E6%B6%88%E6%81%AF-Self-descriptive-Messages"><span class="toc-text">2.4.3 自描述消息 (Self-descriptive Messages)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E8%B6%85%E5%AA%92%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%BA%94%E7%94%A8%E7%8A%B6%E6%80%81%E7%9A%84%E5%BC%95%E6%93%8E-Hypermedia-as-the-Engine-of-Application-State-HATEOAS"><span class="toc-text">2.4.4 超媒体作为应用状态的引擎 (Hypermedia as the Engine of Application State - HATEOAS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%86%E5%B1%82%E7%B3%BB%E7%BB%9F-Layered-System"><span class="toc-text">2.5 分层系统 (Layered System)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%8C%89%E9%9C%80%E4%BB%A3%E7%A0%81-Code-On-Demand-%E5%8F%AF%E9%80%89"><span class="toc-text">2.6 按需代码 (Code-On-Demand) (可选)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81RESTful-API-%E7%9A%84%E5%85%B3%E9%94%AE%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">三、RESTful API 的关键组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%B5%84%E6%BA%90-Resources-%E5%92%8C-URI-Uniform-Resource-Identifier"><span class="toc-text">3.1 资源 (Resources) 和 URI (Uniform Resource Identifier)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-HTTP-%E6%96%B9%E6%B3%95-HTTP-Methods"><span class="toc-text">3.2 HTTP 方法 (HTTP Methods)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%B5%84%E6%BA%90%E8%A1%A8%E8%BF%B0-Resource-Representations"><span class="toc-text">3.3 资源表述 (Resource Representations)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81-HTTP-Status-Codes"><span class="toc-text">3.4 HTTP 状态码 (HTTP Status Codes)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81RESTful-API-%E8%AE%BE%E8%AE%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">四、RESTful API 设计最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%B5%84%E6%BA%90%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">4.1 资源命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-HTTP-%E6%96%B9%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2 HTTP 方法的正确使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-Versioning"><span class="toc-text">4.3 版本控制 (Versioning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83-Authentication-Authorization"><span class="toc-text">4.4 认证与授权 (Authentication &amp; Authorization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-Error-Handling"><span class="toc-text">4.5 错误处理 (Error Handling)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%88%86%E9%A1%B5%E3%80%81%E8%BF%87%E6%BB%A4%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">4.6 分页、过滤和排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81RESTful-API-%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">五、RESTful API 架构示意图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e3b0c5d197a/" title="Web Components 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Components 详解"/></a><div class="content"><a class="title" href="/4e3b0c5d197a/" title="Web Components 详解">Web Components 详解</a><time datetime="2026-02-07T22:24:00.000Z" title="发表于 2026-02-08 06:24:00">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-26.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>