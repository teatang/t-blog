<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python 异步编程详解：从并发到协程 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python 异步编程 是一种处理并发任务的编程范式，它允许程序在等待某些操作（如 I&#x2F;O 操作、网络请求、数据库查询）完成时，切换到执行其他任务，从而提高程序的吞吐量和响应速度。与传统的多线程&#x2F;多进程并发模型不同，异步编程通常使用协程 (Coroutines) 和事件循环 (Event Loop) 来实现，避免了线程&#x2F;进程切换的开销，也绕开了 Python 的全局">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 异步编程详解：从并发到协程">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2023/2023-03-22_Python%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%B9%B6%E5%8F%91%E5%88%B0%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Python 异步编程 是一种处理并发任务的编程范式，它允许程序在等待某些操作（如 I&#x2F;O 操作、网络请求、数据库查询）完成时，切换到执行其他任务，从而提高程序的吞吐量和响应速度。与传统的多线程&#x2F;多进程并发模型不同，异步编程通常使用协程 (Coroutines) 和事件循环 (Event Loop) 来实现，避免了线程&#x2F;进程切换的开销，也绕开了 Python 的全局">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg">
<meta property="article:published_time" content="2023-03-21T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-27T04:01:59.276Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="异步编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python 异步编程详解：从并发到协程",
  "url": "https://blog.tbf1211.xx.kg/2023/2023-03-22_Python%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%B9%B6%E5%8F%91%E5%88%B0%E5%8D%8F%E7%A8%8B/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg",
  "datePublished": "2023-03-21T22:24:00.000Z",
  "dateModified": "2025-10-27T04:01:59.276Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2023/2023-03-22_Python%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%B9%B6%E5%8F%91%E5%88%B0%E5%8D%8F%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python 异步编程详解：从并发到协程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">176</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">165</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-16.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python 异步编程详解：从并发到协程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python 异步编程详解：从并发到协程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-21T22:24:00.000Z" title="发表于 2023-03-22 06:24:00">2023-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2023/2023-03-22_Python%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%B9%B6%E5%8F%91%E5%88%B0%E5%8D%8F%E7%A8%8B/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Python 异步编程</strong> 是一种处理并发任务的编程范式，它允许程序在等待某些操作（如 I&#x2F;O 操作、网络请求、数据库查询）完成时，切换到执行其他任务，从而提高程序的吞吐量和响应速度。与传统的多线程&#x2F;多进程并发模型不同，异步编程通常使用<strong>协程 (Coroutines)</strong> 和<strong>事件循环 (Event Loop)</strong> 来实现，避免了线程&#x2F;进程切换的开销，也绕开了 Python 的<strong>全局解释器锁 (GIL)</strong> 对 CPU 密集型任务的限制（尽管异步编程主要适用于 I&#x2F;O 密集型任务）。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：异步编程通过在等待 I&#x2F;O 完成时“暂停”当前任务，并“切换”到其他可执行任务，从而在单线程内实现并发和最大化 I&#x2F;O 利用率。</p>
</div>

<h2 id="一、为什么需要异步编程？"><a href="#一、为什么需要异步编程？" class="headerlink" title="一、为什么需要异步编程？"></a>一、为什么需要异步编程？</h2><p>传统的 Python 程序（同步阻塞式）在执行 I&#x2F;O 操作时会阻塞整个程序，直到 I&#x2F;O 完成。例如，一个 Web 服务器在处理一个耗时的网络请求时，就无法处理其他用户的请求，导致性能低下。</p>
<h3 id="1-1-同步阻塞-Synchronous-Blocking"><a href="#1-1-同步阻塞-Synchronous-Blocking" class="headerlink" title="1.1 同步阻塞 (Synchronous Blocking)"></a>1.1 同步阻塞 (Synchronous Blocking)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_url_sync</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Start fetching <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">    response = requests.get(url) <span class="comment"># 阻塞式I/O操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Finished fetching <span class="subst">&#123;url&#125;</span> in <span class="subst">&#123;response.elapsed.total_seconds():<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/3&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    fetch_url_sync(url)</span><br><span class="line">end_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total sync time: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br><span class="line"><span class="comment"># 假设每个请求耗时 0.2s，则总耗时约 0.6s</span></span><br></pre></td></tr></table></figure>
<p>这段代码会逐个执行 URL 请求，每个请求都会阻塞程序的执行，直到响应返回。</p>
<h3 id="1-2-多线程-Multithreading"><a href="#1-2-多线程-Multithreading" class="headerlink" title="1.2 多线程 (Multithreading)"></a>1.2 多线程 (Multithreading)</h3><p>多线程可以实现并行执行任务，但 Python 的 GIL 限制了同一时刻只有一个线程能在 CPU 上执行 Python 字节码。对于计算密集型任务，多线程并不能真正并行加速。对于 I&#x2F;O 密集型任务，线程在等待 I&#x2F;O 时会释放 GIL，所以多线程在 I&#x2F;O 密集型场景下确实能提高并发度。然而，线程的创建和上下文切换有开销，且存在数据竞争和锁的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_url_thread</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Start fetching <span class="subst">&#123;url&#125;</span> in thread <span class="subst">&#123;threading.current_thread().name&#125;</span>&quot;</span>)</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Finished fetching <span class="subst">&#123;url&#125;</span> in <span class="subst">&#123;response.elapsed.total_seconds():<span class="number">.2</span>f&#125;</span>s in thread <span class="subst">&#123;threading.current_thread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/3&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    thread = threading.Thread(target=fetch_url_thread, args=(url,), name=<span class="string">f&quot;Thread-<span class="subst">&#123;url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join() <span class="comment"># 等待所有线程完成</span></span><br><span class="line">end_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total multithread time: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br><span class="line"><span class="comment"># 假设每个请求耗时 0.2s，多个请求并行，但受GIL和线程开销影响，总耗时可能接近最慢的那个请求，比如0.25s</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-异步编程-Asynchronous-Programming"><a href="#1-3-异步编程-Asynchronous-Programming" class="headerlink" title="1.3 异步编程 (Asynchronous Programming)"></a>1.3 异步编程 (Asynchronous Programming)</h3><p>异步编程是一种单线程并发模型。它通过在高延迟操作（如网络请求、磁盘 I&#x2F;O）发生时，将 CPU 资源让给其他任务，从而在单个线程内实现高并发。当 I&#x2F;O 操作完成后，程序会“恢复”之前暂停的任务。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>高并发、高性能 (I&#x2F;O 密集型)</strong>：避免了线程&#x2F;进程切换的开销，以及 GIL 的限制（因为 I&#x2F;O 操作时 Python 代码并没有运行）。</li>
<li><strong>资源消耗低</strong>：协程比线程&#x2F;进程更轻量级。</li>
<li><strong>代码结构清晰</strong>：<code>async/await</code> 语法使得异步代码看起来像同步代码，易于理解和维护。</li>
<li><strong>避免死锁问题</strong>：由于是单线程，不存在多线程&#x2F;多进程的资源竞争和死锁问题。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>不适合计算密集型任务</strong>：由于是单线程，无法利用多核 CPU，计算密集型任务仍会阻塞事件循环。</li>
<li><strong>传染性 (“Async&#x2F;Await is Contagious”)</strong>：一旦引入异步，相关的函数和库也需要是异步的，否则同步阻塞调用会阻塞整个事件循环。</li>
<li><strong>调试难度稍高</strong>：异步程序的错误栈跟踪可能比同步程序复杂。</li>
</ul>
<h2 id="二、Python-异步编程的核心概念"><a href="#二、Python-异步编程的核心概念" class="headerlink" title="二、Python 异步编程的核心概念"></a>二、Python 异步编程的核心概念</h2><p>Python 异步编程主要由 <code>asyncio</code> 库提供支持，并围绕以下核心概念展开：</p>
<h3 id="2-1-协程-Coroutines"><a href="#2-1-协程-Coroutines" class="headerlink" title="2.1 协程 (Coroutines)"></a>2.1 协程 (Coroutines)</h3><ul>
<li><strong>定义</strong>：协程是一种用户态的轻量级线程，它允许函数在执行过程中暂停，并在稍后从暂停点恢复执行。在 Python 中，通过 <code>async def</code> 定义的函数就是协程函数，调用它会返回一个协程对象。</li>
<li><strong>关键字</strong>：<ul>
<li><code>async def</code>：定义一个<strong>协程函数</strong>。</li>
<li><code>await</code>：用于等待一个<strong>可等待对象 (Awaitable)</strong> 的完成。当 <code>await</code> 一个 I&#x2F;O 操作时，协程会暂停执行，并将控制权交还给事件循环，从而允许事件循环去运行其他协程。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_coroutine</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Coroutine started&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 模拟一个耗时1秒的I/O操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Coroutine finished&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-可等待对象-Awaitables"><a href="#2-2-可等待对象-Awaitables" class="headerlink" title="2.2 可等待对象 (Awaitables)"></a>2.2 可等待对象 (Awaitables)</h3><p>可等待对象是可以在 <code>await</code> 表达式中使用的对象。主要有三种可等待对象：<br>    *   <strong>协程 (Coroutines)</strong>：通过 <code>async def</code> 定义的函数被调用后返回的对象。<br>    *   <strong>任务 (Tasks)</strong>：<code>asyncio.Task</code> 对象，用于在事件循环中调度和运行协程。<br>    *   <strong>Future (未来对象)</strong>：<code>asyncio.Future</code> 对象，表示一个尚未完成的操作的结果，可以被 <code>await</code>。</p>
<h3 id="2-3-事件循环-Event-Loop"><a href="#2-3-事件循环-Event-Loop" class="headerlink" title="2.3 事件循环 (Event Loop)"></a>2.3 事件循环 (Event Loop)</h3><ul>
<li><strong>定义</strong>：事件循环是异步编程的核心。它是一个无限循环，负责监听事件（如 I&#x2F;O 完成、定时器到期等），并将这些事件分派给相应的协程来处理。</li>
<li><strong>作用</strong>：当一个协程 <code>await</code> 一个阻塞操作时，它会暂停并把控制权交还给事件循环。事件循环会去执行其他已准备好的协程。当原先的阻塞操作完成时，事件循环会通知并重新调度对应的协程继续执行。</li>
<li><strong>获取和运行</strong>：<ul>
<li><code>asyncio.get_event_loop()</code>：获取当前线程的事件循环。</li>
<li><code>loop.run_until_complete(coro)</code>：运行一个协程直到它完成。</li>
<li><code>asyncio.run(coro)</code> (Python 3.7+ 推荐)：一个更高级的函数，负责创建和关闭事件循环，运行协程，并处理一些细节。</li>
</ul>
</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    subgraph Event Loop
        A[Start Event Loop] --&gt; B{Check for ready tasks}
        B -- Yes --&gt; C[&quot;Run ready task (Coroutine)&quot;]
        C -- Await I&#x2F;O --&gt; D[Task pauses,&lt;br&gt;Event released]
        D --&gt; E{Wait for I&#x2F;O completion &#x2F; Other events}
        E -- I&#x2F;O completed --&gt; F[I&#x2F;O Done Event]
        F --&gt; B
        C -- Task finishes --&gt; G[Task removed]
        G --&gt; B
    end
  </pre></div>

<h3 id="2-4-任务-Tasks"><a href="#2-4-任务-Tasks" class="headerlink" title="2.4 任务 (Tasks)"></a>2.4 任务 (Tasks)</h3><ul>
<li><strong>定义</strong>：<code>asyncio.Task</code> 是 <code>asyncio</code> 中包装协程的可等待对象。它用于在事件循环中<strong>并发地</strong>调度和运行协程。通过 <code>asyncio.create_task(coro)</code> 创建一个任务，并将其注册到事件循环中。</li>
<li><strong>作用</strong>：如果你创建了多个任务，事件循环会在它们之间切换执行，从而实现并发。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_func</span>(<span class="params">name, duration</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: Starting, will run for <span class="subst">&#123;duration&#125;</span> seconds.&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(duration) <span class="comment"># 模拟I/O操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Task <span class="subst">&#123;name&#125;</span>: Finished.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main: Creating tasks...&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建任务，并让事件循环调度它们</span></span><br><span class="line">    task1 = asyncio.create_task(task_func(<span class="string">&quot;One&quot;</span>, <span class="number">2</span>))</span><br><span class="line">    task2 = asyncio.create_task(task_func(<span class="string">&quot;Two&quot;</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main: Waiting for tasks to complete...&quot;</span>)</span><br><span class="line">    <span class="comment"># await 任务，等待它们完成</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main: All tasks completed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><strong>运行结果可能如下 (具体时间点由调度决定)：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Main: Creating tasks...</span><br><span class="line">Main: Waiting for tasks to complete...</span><br><span class="line">Task One: Starting, will run for 2 seconds.</span><br><span class="line">Task Two: Starting, will run for 1 second.</span><br><span class="line">Task Two: Finished.</span><br><span class="line">Task One: Finished.</span><br><span class="line">Main: All tasks completed.</span><br></pre></td></tr></table></figure>
<p>可以看到，”Task Two: Finished.” 比 “Task One: Finished.” 先输出，说明它们是并发执行的。总耗时接近最长的任务（2秒），而不是它们的总和（3秒）。</p>
<h2 id="三、asyncio-模块的使用"><a href="#三、asyncio-模块的使用" class="headerlink" title="三、asyncio 模块的使用"></a>三、<code>asyncio</code> 模块的使用</h2><p><code>asyncio</code> 是 Python 用于编写并发代码的基础库，使用 <code>async/await</code> 语法。</p>
<h3 id="3-1-基本的-async-await-示例"><a href="#3-1-基本的-async-await-示例" class="headerlink" title="3.1 基本的 async/await 示例"></a>3.1 基本的 <code>async/await</code> 示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay) <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 协程对象并不会立即执行，需要用await或者任务来驱动</span></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">&#x27;world&#x27;</span>) <span class="comment"># 这个会阻塞上面hello的完成</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"><span class="comment"># 预期输出：</span></span><br><span class="line"><span class="comment"># started at 00:00:00 (示例时间)</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world</span></span><br><span class="line"><span class="comment"># finished at 00:00:03 (示例时间)</span></span><br><span class="line"><span class="comment"># 总耗时约 3 秒，因为是顺序 await</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-实现并发-使用-asyncio-create-task-或-asyncio-gather"><a href="#3-2-实现并发-使用-asyncio-create-task-或-asyncio-gather" class="headerlink" title="3.2 实现并发 (使用 asyncio.create_task 或 asyncio.gather)"></a>3.2 实现并发 (使用 <code>asyncio.create_task</code> 或 <code>asyncio.gather</code>)</h3><p>要真正实现并发而非顺序执行，需要将协程包装成任务。</p>
<h4 id="a-使用-asyncio-create-task"><a href="#a-使用-asyncio-create-task" class="headerlink" title="a. 使用 asyncio.create_task"></a>a. 使用 <code>asyncio.create_task</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_concurrent_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建任务，让事件循环调度它们</span></span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&#x27;world&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># await 任务，等待它们完成。它们是并发运行的</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main_concurrent_task())</span><br><span class="line"><span class="comment"># 预期输出：</span></span><br><span class="line"><span class="comment"># started at 00:00:00 (示例时间)</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world</span></span><br><span class="line"><span class="comment"># finished at 00:00:02 (示例时间)</span></span><br><span class="line"><span class="comment"># 总耗时约 2 秒 (取最耗时任务的时间)，因为是并发执行</span></span><br></pre></td></tr></table></figure>

<h4 id="b-使用-asyncio-gather"><a href="#b-使用-asyncio-gather" class="headerlink" title="b. 使用 asyncio.gather"></a>b. 使用 <code>asyncio.gather</code></h4><p><code>asyncio.gather</code> 是一个更方便的方式来同时运行多个可等待对象，并收集它们的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> what <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_gather</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同时运行多个可等待对象，并等待所有完成</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">&#x27;world&#x27;</span>),</span><br><span class="line">        say_after(<span class="number">0.5</span>, <span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;results: <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main_gather())</span><br><span class="line"><span class="comment"># 预期输出：</span></span><br><span class="line"><span class="comment"># started at 00:00:00</span></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># world</span></span><br><span class="line"><span class="comment"># results: [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span></span><br><span class="line"><span class="comment"># finished at 00:00:02</span></span><br><span class="line"><span class="comment"># 总耗时约 2 秒</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-异步网络请求示例"><a href="#3-3-异步网络请求示例" class="headerlink" title="3.3 异步网络请求示例"></a>3.3 异步网络请求示例</h3><p>结合 <code>aiohttp</code>（一个异步 HTTP 客户端&#x2F;服务器库）进行异步网络请求，相比 <code>requests</code> 性能更高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_url_async</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Start fetching <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response: <span class="comment"># 异步HTTP GET请求</span></span><br><span class="line">        content = <span class="keyword">await</span> response.text() <span class="comment"># 异步读取响应体</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Finished fetching <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_async_fetch</span>():</span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://jsonplaceholder.typicode.com/todos/3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://jsonplaceholder.typicode.com/posts/2&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">  </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session: <span class="comment"># 异步HTTP客户端会话</span></span><br><span class="line">        tasks = [fetch_url_async(session, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        <span class="comment"># 同时运行所有任务，等待它们完成</span></span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">  </span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Total async fetch time: <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span>s&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Results (content lengths): <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main_async_fetch())</span><br><span class="line"><span class="comment"># 假设每个请求耗时 0.2s，5个请求并发，总耗时可能在 0.25s 左右</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-异步迭代器和异步生成器"><a href="#3-4-异步迭代器和异步生成器" class="headerlink" title="3.4 异步迭代器和异步生成器"></a>3.4 异步迭代器和异步生成器</h3><ul>
<li><strong>异步迭代器 (<code>async for</code>)</strong>：允许你在异步地获取元素时暂停。</li>
<li><strong>异步生成器 (<code>async yield</code>)</strong>：允许你创建一个生成器，其生成值的过程可以是异步的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncCounter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, limit</span>):</span><br><span class="line">        <span class="variable language_">self</span>.limit = limit</span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>): <span class="comment"># 异步迭代器协议</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>): <span class="comment"># 异步迭代器协议</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="variable language_">self</span>.limit:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>) <span class="comment"># 模拟异步操作</span></span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.current</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_generator_example</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.05</span>)</span><br><span class="line">        <span class="keyword">yield</span> i * <span class="number">2</span> <span class="comment"># 异步生成值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_async_iter_gen</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- Async Iterator ---&quot;</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> count <span class="keyword">in</span> AsyncCounter(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Count: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- Async Generator ---&quot;</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> value <span class="keyword">in</span> async_generator_example():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Generated: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main_async_iter_gen())</span><br></pre></td></tr></table></figure>

<h2 id="四、异步编程的挑战与注意事项"><a href="#四、异步编程的挑战与注意事项" class="headerlink" title="四、异步编程的挑战与注意事项"></a>四、异步编程的挑战与注意事项</h2><ol>
<li><p><strong>同步阻塞函数会阻塞事件循环</strong>：如果在异步代码中调用了普通的同步阻塞函数，那么整个事件循环都会被阻塞，导致其他协程无法执行。</p>
<ul>
<li><strong>解决方案</strong>：对于 I&#x2F;O 密集型的同步阻塞函数，可以使用 <code>loop.run_in_executor()</code> 将其放到单独的线程池或进程池中运行，避免阻塞主事件循环。</li>
<li>对于 CPU 密集型的同步阻塞函数，也应使用 <code>run_in_executor()</code> 放到进程池中运行，以充分利用多核 CPU 并绕过 GIL。</li>
</ul>
</li>
<li><p><strong>错误处理</strong>：异步代码中的异常处理与同步代码类似，使用 <code>try...except</code> 块。对于 <code>asyncio.gather</code>，如果 <code>return_exceptions=True</code>，则异常会被作为结果返回；否则，第一个发生的异常会立即传播。</p>
</li>
<li><p><strong>取消任务 (Canceling Tasks)</strong>：</p>
<ul>
<li><code>task.cancel()</code> 可以尝试取消一个正在运行的任务。</li>
<li>任务应该优雅地处理取消请求，通常在 <code>try...finally</code> 块中使用 <code>asyncio.CancelledError</code> 进行捕获。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">cancelable_task</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cancelable task: Starting...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cancelable task: Finished.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cancelable task: Was cancelled!&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> <span class="comment"># 重新抛出以表明任务被取消</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_cancel</span>():</span><br><span class="line">    task = asyncio.create_task(cancelable_task())</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 等待任务启动</span></span><br><span class="line">    task.cancel() <span class="comment"># 取消任务</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task <span class="comment"># 等待任务真正结束 (或取消)</span></span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Main: Task was indeed cancelled.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main: Done.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main_cancel())</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>死锁和竞争条件 (避免)</strong>：由于 <code>asyncio</code> 是单线程模型，理论上不会有传统多线程的死锁问题。但如果使用 <code>asyncio.Lock</code> 等同步原语时，仍需小心编写逻辑以避免程序逻辑上的死锁（例如，一直等待一个不会被释放的锁）。</p>
</li>
</ol>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Python 的异步编程，特别是基于 <code>asyncio</code> 库和 <code>async/await</code> 语法的协程模型，为处理 I&#x2F;O 密集型任务提供了一种高效、轻量级的解决方案。</p>
<ul>
<li><strong>核心优势</strong>：通过单线程内的任务切换，实现高并发、低资源消耗，特别适用于网络服务、爬虫等场景。</li>
<li><strong>关键概念</strong>：<ul>
<li><strong>协程 (<code>async def</code>, <code>await</code>)</strong>：可暂停和恢复的函数。</li>
<li><strong>事件循环 (<code>asyncio.run</code>, <code>asyncio.get_event_loop</code>)</strong>：调度和管理协程执行的核心。</li>
<li><strong>任务 (<code>asyncio.create_task</code>)</strong>：将协程包装成可由事件循环调度的并发单位。</li>
</ul>
</li>
<li><strong>常用工具</strong>：<code>asyncio.gather</code> 用于并发运行多个任务并收集结果；<code>aiohttp</code> 等第三方库提供异步 I&#x2F;O 功能。</li>
<li><strong>注意事项</strong>：避免同步阻塞代码阻塞事件循环；正确处理异常和任务取消；异步代码具有“传染性”。</li>
</ul>
<p>随着 Python 3.7+ 对 <code>asyncio.run()</code> 的引入，异步编程的入门门槛已大大降低。掌握异步编程，将能极大地拓宽 Python 在高性能网络应用领域的应用范围。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2023/2023-03-22_Python%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%B9%B6%E5%8F%91%E5%88%B0%E5%8D%8F%E7%A8%8B/">https://blog.tbf1211.xx.kg/2023/2023-03-22_Python%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%B9%B6%E5%8F%91%E5%88%B0%E5%8D%8F%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-16.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/2023-03-23_HTTP%201.1%20%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWeb%20%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E7%9F%B3/" title="HTTP/1.1 协议深度详解：Web 通信的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTTP/1.1 协议深度详解：Web 通信的基石</div></div><div class="info-2"><div class="info-item-1"> HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。  核心思想：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于请求-响应模型，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。   一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：  短连接 (Short Connection)：HTTP&#x2F;1.0 默认每个请求&#x2F;响应...</div></div></div></a><a class="pagination-related" href="/2023/2023-03-21_Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" title="Python多线程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python多线程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模块实现多线程版的生产者-消费者模式。  核心思想：利用线程安全的共享队列作为缓冲，实现生产者与消费者解耦，并通过队列自带的互斥锁和条件变量进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式与多线程概述1.1 生产者-消费者模式参考 Python 多进程生产者-消费者模式详解 中的概述，其核心构成和解决的问题在多线程场景下是相同的：  生产者 (Producer)：生成数据并放入队列。 消费者 (Consumer)：从队列取出数据并处理。 缓冲区 (Queue)：共享的、线程安全的数据容器。  1.2 Python 多线程与 GIL threading 模块：Python 标...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Python元类(Metaclass)深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="info-item-2">Python元类(Metaclass)深度解析</div></div><div class="info-2"><div class="info-item-1">Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，它允许我们在类被创建时对其行为进行定制，是 Python 中进行高级面向对象编程的强大工具。 1. 什么是元类？在 Python 中，当你定义一个类 class MyClass: pass 的时候，Python 解释器会自动执行以下步骤：  定义一个类对象：解释器读取 MyClass 的定义，并创建一个名为 MyClass 的类对象。 将类对象绑定到命名空间：这个 MyClass 类对象被绑定到当前的命名空间中。  然后，当你通过 my_instance = MyClass() 来创建实例时，MyClass 这个类对象就会被调用，从而创建并返回一个实例对象。 元类就是用来创建这些类对象的...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-15_Python%20NumPy%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%9A%84%E5%9F%BA%E7%9F%B3/" title="Python NumPy详解：科学计算的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="info-item-2">Python NumPy详解：科学计算的基石</div></div><div class="info-2"><div class="info-item-1"> NumPy (Numerical Python) 是 Python 中用于科学计算的核心库。它提供了一个高性能的多维数组对象 ndarray，以及用于处理这些数组的工具。NumPy 是 Python 数据科学和机器学习生态系统的基石，许多其他库（如 SciPy, Pandas, Matplotlib, Scikit-learn）都建立在 NumPy 数组之上。  核心思想：NumPy 引入了高效的 ndarray 数据结构，通过向量化操作显著提升了 Python 处理数值数据的性能。   一、为什么选择 NumPy？Python 语言本身处理列表等数据结构时效率较高，但对于大规模数值计算而言，原生的 Python 列表效率低下。NumPy 通过以下方式解决了这个问题：  高性能 ndarray 对象：ndarray 存储同类型数据，在内存中连续存储，相比 Python 列表，占用的内存更少，访问速度更快。 向量化操作：NumPy 允许对整个数组进行操作，而无需编写显式的循环。这些操作通常在 C 或 Fortran 中实现，执行速度远超 Python 循环。 广播 (Broadc...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-21_Python%20Pandas%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80/" title="Python Pandas详解：数据处理与分析的瑞士军刀"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="info-item-2">Python Pandas详解：数据处理与分析的瑞士军刀</div></div><div class="info-2"><div class="info-item-1"> Pandas 是 Python 中用于数据分析和处理的核心库。它提供了一套高性能、易于使用的数据结构，最主要的是 DataFrame（二维表格数据）和 Series（一维带标签数组），用于快速处理和分析结构化数据（如 CSV、Excel、数据库表格数据）。Pandas 以其直观的语法和强大的功能，成为数据科学家和数据工程师的首选工具。  核心思想：Pandas 将表格数据抽象为 DataFrame 和 Series 对象，提供类似 SQL 和 Excel 的操作，通过向量化和 C&#x2F;Cython 实现的底层优化，极大提升了数据处理效率。   一、为什么选择 Pandas？在数据驱动的时代，我们经常需要处理各种形式的表格数据。Python 原生的数据结构（如列表、字典）虽然灵活，但在处理大量、复杂、异构的表格数据时显得力不从心。Pandas 解决了这些痛点：  直观的数据结构：DataFrame 和 Series 提供了强大的标签索引功能，使得数据操作更加直观，无需关注底层实现。 高效的数据操作：底层基于 NumPy 优化，利用 C 和 Cython 实现，对于大规模数据...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-28_Python%20Requests%E5%BA%93%E8%AF%A6%E8%A7%A3%EF%BC%9AHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E8%89%BA%E6%9C%AF/" title="Python Requests库详解：HTTP请求的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="info-item-2">Python Requests库详解：HTTP请求的艺术</div></div><div class="info-2"><div class="info-item-1"> requests 库 是 Python 生态系统中最流行、最强大、也是最优雅的 HTTP 客户端库之一。它简化了复杂的 HTTP 请求操作，让开发者能够以极少量的代码发送各种类型的 HTTP 请求，并轻松处理响应。与 Python 内置的 urllib 模块相比，requests 提供了更友好、更直观的 API，被誉为“面向人类的 HTTP 服务”。  核心思想：requests 封装了底层 HTTP 协议的复杂性，提供简洁的 API，让开发者专注于业务逻辑而非网络通信的细节。   一、为什么选择 Requests？在 Python 中进行 HTTP 请求有多种方式，例如内置的 urllib 模块。但 requests 库之所以广受欢迎，主要得益于以下优势：  友好的 API：设计直观，易学易用，代码可读性高。 功能强大：支持几乎所有 HTTP 功能，包括 GET, POST, PUT, DELETE 等方法，以及请求头、数据、文件上传、Cookie、身份认证、代理、SSL 验证等。 自动处理：自动处理 URL 编码、重定向、会话管理等常见任务。 JSON 支持：内置 JSON...</div></div></div></a><a class="pagination-related" href="/2023/2023-03-15_Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" title="Python多进程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="info-item-2">Python多进程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式概述模式构成：  生产者 (Producer)：负责生成数据，并将其放入共享的缓冲区（队列）中。 消费者 (Consumer)：负责从共享的缓冲区（队列）中取出数据进行处理。 缓冲区 (Buffer &#x2F; Queue)：一个共享的数据结构，通常是一个队列，用于存储生产者生产的数据和消费者消费的数据。它充当了生产者和消费者之间的桥梁。  解决的问题：  解耦：生产者和消费者可以独立运行，互不干扰，提高系统的灵活性。 并发：允许多个生产者和多个消费者同时存在，提高处理效率。 削峰填谷：当生产速度快于消费速度时，缓冲区可以存储多余的数据，防止数...</div></div></div></a><a class="pagination-related" href="/2023/2023-03-21_Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" title="Python多线程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="info-item-2">Python多线程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模块实现多线程版的生产者-消费者模式。  核心思想：利用线程安全的共享队列作为缓冲，实现生产者与消费者解耦，并通过队列自带的互斥锁和条件变量进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式与多线程概述1.1 生产者-消费者模式参考 Python 多进程生产者-消费者模式详解 中的概述，其核心构成和解决的问题在多线程场景下是相同的：  生产者 (Producer)：生成数据并放入队列。 消费者 (Consumer)：从队列取出数据并处理。 缓冲区 (Queue)：共享的、线程安全的数据容器。  1.2 Python 多线程与 GIL threading 模块：Python 标...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">176</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">165</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-text">一、为什么需要异步编程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E-Synchronous-Blocking"><span class="toc-text">1.1 同步阻塞 (Synchronous Blocking)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B-Multithreading"><span class="toc-text">1.2 多线程 (Multithreading)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-Asynchronous-Programming"><span class="toc-text">1.3 异步编程 (Asynchronous Programming)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Python-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Python 异步编程的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8D%8F%E7%A8%8B-Coroutines"><span class="toc-text">2.1 协程 (Coroutines)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8F%AF%E7%AD%89%E5%BE%85%E5%AF%B9%E8%B1%A1-Awaitables"><span class="toc-text">2.2 可等待对象 (Awaitables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop"><span class="toc-text">2.3 事件循环 (Event Loop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%BB%E5%8A%A1-Tasks"><span class="toc-text">2.4 任务 (Tasks)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81asyncio-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">三、asyncio 模块的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E7%9A%84-async-await-%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.1 基本的 async&#x2F;await 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91-%E4%BD%BF%E7%94%A8-asyncio-create-task-%E6%88%96-asyncio-gather"><span class="toc-text">3.2 实现并发 (使用 asyncio.create_task 或 asyncio.gather)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E4%BD%BF%E7%94%A8-asyncio-create-task"><span class="toc-text">a. 使用 asyncio.create_task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BD%BF%E7%94%A8-asyncio-gather"><span class="toc-text">b. 使用 asyncio.gather</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.3 异步网络请求示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%BC%82%E6%AD%A5%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">3.4 异步迭代器和异步生成器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">四、异步编程的挑战与注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-16.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>