<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL 索引详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I&#x2F;O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。  “好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言   一、什么是索引？索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 索引详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I&#x2F;O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。  “好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言   一、什么是索引？索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg">
<meta property="article:published_time" content="2023-01-26T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-27T04:01:59.275Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="中间件">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL 索引详解",
  "url": "https://blog.tbf1211.xx.kg/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg",
  "datePublished": "2023-01-26T22:24:00.000Z",
  "dateModified": "2025-10-27T04:01:59.275Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL 索引详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">176</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">165</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-13.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL 索引详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL 索引详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-01-26T22:24:00.000Z" title="发表于 2023-01-27 06:24:00">2023-01-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I&#x2F;O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。</p>
</blockquote>
<div class="note info flat"><p>“好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言</p>
</div>

<h2 id="一、什么是索引？"><a href="#一、什么是索引？" class="headerlink" title="一、什么是索引？"></a>一、什么是索引？</h2><p>索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用它来快速定位数据。可以将其类比为一本书的目录，通过目录我们可以快速找到感兴趣的章节，而不需要通读整本书。</p>
<p>在数据库中，没有索引的查询需要全表扫描，即逐行检查每条记录，直到找到符合条件的记录。当数据量非常大时，这种操作的效率会非常低下。索引通过创建指向数据物理位置的指针，使得数据库在查询时能够直接跳转到相关记录，从而大大加快查询速度。</p>
<h2 id="二、索引的优缺点"><a href="#二、索引的优缺点" class="headerlink" title="二、索引的优缺点"></a>二、索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><strong>显著提高数据检索速度</strong>：这是索引最核心、最主要的优点。</li>
<li><strong>加快表与表之间的连接速度</strong>：对于 <code>JOIN</code> 操作，索引可以加速连接条件的匹配。</li>
<li><strong>加快分组和排序操作</strong>：<code>GROUP BY</code> 和 <code>ORDER BY</code> 操作通常通过消除临时表和对文件进行排序来提高效率。</li>
<li><strong>保证数据的唯一性</strong>：唯一索引（Unique Index）可以强制列的数据不重复。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><strong>占用磁盘空间</strong>：索引本身也是一种数据结构，需要存储在磁盘上。</li>
<li><strong>降低更新速度</strong>：当对表中的数据进行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作时，除了修改数据本身，还需要同时更新索引，这会增加数据库的写操作负担。</li>
<li><strong>维护成本</strong>：索引越多，维护成本越高，查询优化器选择索引的代价也可能增加。</li>
</ol>
<h2 id="三、索引的分类"><a href="#三、索引的分类" class="headerlink" title="三、索引的分类"></a>三、索引的分类</h2><p>MySQL 中索引可以从不同的维度进行分类：</p>
<h3 id="1-按数据结构分类"><a href="#1-按数据结构分类" class="headerlink" title="1. 按数据结构分类"></a>1. 按数据结构分类</h3><p>MySQL 主要支持两种索引结构，<code>B+Tree</code> 和 <code>Hash</code>。</p>
<h4 id="1-B-Tree-索引-默认，常用"><a href="#1-B-Tree-索引-默认，常用" class="headerlink" title="(1) B+Tree 索引 (默认，常用)"></a>(1) B+Tree 索引 (默认，常用)</h4><ul>
<li><strong>特点</strong>:<ul>
<li><code>B+Tree</code> 是一种多路平衡查找树，所有数据都存储在叶子节点，并且叶子节点之间通过指针连接，形成一个有序链表。</li>
<li>非叶子节点只存储索引键，不存储数据，减少了树的高度，提高了查询效率。</li>
<li>适合范围查询、模糊查询（前缀匹配）、排序等。</li>
<li>MySQL 的 InnoDB 存储引擎默认使用 <code>B+Tree</code> 索引。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 几乎所有类型的查询，包括等值查询、范围查询、排序和分组操作。</li>
</ul>
<h4 id="2-Hash-索引"><a href="#2-Hash-索引" class="headerlink" title="(2) Hash 索引"></a>(2) Hash 索引</h4><ul>
<li><strong>特点</strong>:<ul>
<li>基于哈希表实现，通过哈希算法将索引列的值映射到哈希表中，存储行指针。</li>
<li>查询速度极快，只需要进行一次哈希计算和一次指针查找。</li>
<li>仅支持精确匹配查询（等值查询），不支持范围查询和排序。</li>
<li>哈希冲突处理会影响性能。</li>
<li>MySQL 的 Memory 存储引擎默认支持，InnoDB 存储引擎不支持显式创建 Hash 索引，但有自适应哈希索引 (Adaptive Hash Index)。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 等值查询，例如 <code>WHERE id = 123</code>。</li>
</ul>
<h3 id="2-按物理存储分类-InnoDB-存储引擎"><a href="#2-按物理存储分类-InnoDB-存储引擎" class="headerlink" title="2. 按物理存储分类 (InnoDB 存储引擎)"></a>2. 按物理存储分类 (InnoDB 存储引擎)</h3><h4 id="1-聚集索引-Clustered-Index"><a href="#1-聚集索引-Clustered-Index" class="headerlink" title="(1) 聚集索引 (Clustered Index)"></a>(1) 聚集索引 (Clustered Index)</h4><ul>
<li><strong>特点</strong>:<ul>
<li><strong>一个表只有一个聚集索引</strong>。</li>
<li><strong>将数据行存储在索引的叶子节点中</strong>。也就是说，数据和索引是存储在一起的。</li>
<li>InnoDB 存储引擎会自动为主键列创建聚集索引。如果表没有主键，MySQL 会选择第一个非空的唯一索引。如果也没有非空的唯一索引，InnoDB 会隐式地生成一个行 ID 作为聚集索引。</li>
<li>查询效率极高，因为找到索引就意味着找到了数据。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 查询主键或按主键范围查询。</li>
</ul>
<h4 id="2-非聚集索引-Secondary-Index-Auxiliary-Index"><a href="#2-非聚集索引-Secondary-Index-Auxiliary-Index" class="headerlink" title="(2) 非聚集索引 (Secondary Index &#x2F; Auxiliary Index)"></a>(2) 非聚集索引 (Secondary Index &#x2F; Auxiliary Index)</h4><ul>
<li><strong>特点</strong>:<ul>
<li>一个表可以有多个非聚集索引。</li>
<li><strong>索引的叶子节点存储的是主键值</strong>，而不是数据行本身。</li>
<li>当通过非聚集索引查询时，首先在非聚集索引中找到对应的主键值，然后（通过主键值）再去聚集索引中找到完整的数据行。这个过程称为<strong>回表查询</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 除了主键以外的所有索引，包括普通索引、唯一索引等。</li>
<li><strong>覆盖索引 (Covering Index)</strong>: 当非聚集索引中包含查询所需的所有列时，就不需要回表查询完整数据行，这种索引被称为覆盖索引。覆盖索引能极大地提高查询性能。</li>
</ul>
<h3 id="3-按逻辑分类"><a href="#3-按逻辑分类" class="headerlink" title="3. 按逻辑分类"></a>3. 按逻辑分类</h3><h4 id="1-普通索引-Normal-Non-Unique-Index"><a href="#1-普通索引-Normal-Non-Unique-Index" class="headerlink" title="(1) 普通索引 (Normal &#x2F; Non-Unique Index)"></a>(1) 普通索引 (Normal &#x2F; Non-Unique Index)</h4><ul>
<li><strong>特点</strong>: 最基本的索引，没有任何限制，可重复。</li>
<li><strong>创建</strong>: <code>CREATE INDEX index_name ON table_name (column_name);</code></li>
</ul>
<h4 id="2-唯一索引-Unique-Index"><a href="#2-唯一索引-Unique-Index" class="headerlink" title="(2) 唯一索引 (Unique Index)"></a>(2) 唯一索引 (Unique Index)</h4><ul>
<li><strong>特点</strong>: 要求索引列的值必须唯一，但允许有 <code>NULL</code> 值（且 <code>NULL</code> 值可以有多个）。</li>
<li><strong>创建</strong>: <code>CREATE UNIQUE INDEX index_name ON table_name (column_name);</code> 或 <code>ALTER TABLE table_name ADD UNIQUE (column_name);</code></li>
</ul>
<h4 id="3-主键索引-Primary-Key-Index"><a href="#3-主键索引-Primary-Key-Index" class="headerlink" title="(3) 主键索引 (Primary Key Index)"></a>(3) 主键索引 (Primary Key Index)</h4><ul>
<li><strong>特点</strong>: 一种特殊的唯一索引，一个表只能有一个主键。主键列的值必须唯一，且不能为 <code>NULL</code>。</li>
<li><strong>创建</strong>: <code>ALTER TABLE table_name ADD PRIMARY KEY (column_name);</code> 或在创建表时定义。</li>
<li>在 InnoDB 中，主键索引就是<strong>聚集索引</strong>。</li>
</ul>
<h4 id="4-全文索引-Full-Text-Index"><a href="#4-全文索引-Full-Text-Index" class="headerlink" title="(4) 全文索引 (Full-Text Index)"></a>(4) 全文索引 (Full-Text Index)</h4><ul>
<li><strong>特点</strong>: 用于在文本列（如 <code>VARCHAR</code>, <code>TEXT</code>）中进行关键词查找，支持自然语言查询。</li>
<li><strong>创建</strong>: <code>CREATE FULLTEXT INDEX index_name ON table_name (column_name);</code></li>
<li><strong>适用场景</strong>: 博客文章内容搜索、商品描述搜索等。</li>
</ul>
<h4 id="5-复合索引-Composite-Combination-Index"><a href="#5-复合索引-Composite-Combination-Index" class="headerlink" title="(5) 复合索引 (Composite &#x2F; Combination Index)"></a>(5) 复合索引 (Composite &#x2F; Combination Index)</h4><ul>
<li><strong>特点</strong>: 在多个列上创建的索引。遵循“<strong>最左前缀原则</strong>”。</li>
<li><strong>最左前缀原则</strong>: 如果在一个 <code>(col1, col2, col3)</code> 的复合索引上，查询条件可以使用 <code>col1</code>、<code>(col1, col2)</code>、<code>(col1, col2, col3)</code> 来匹配索引，但不能直接使用 <code>col2</code> 或 <code>col3</code>。</li>
<li><strong>创建</strong>: <code>CREATE INDEX index_name ON table_name (col1, col2, col3);</code></li>
</ul>
<h2 id="四、索引的创建与删除"><a href="#四、索引的创建与删除" class="headerlink" title="四、索引的创建与删除"></a>四、索引的创建与删除</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><ol>
<li><p><strong>创建表时指定</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    status TINYINT,</span><br><span class="line">    INDEX idx_status (status)  <span class="comment">-- 普通索引</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>CREATE INDEX</code> 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_email <span class="keyword">ON</span> users (email);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uidx_username <span class="keyword">ON</span> users (username);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_username_email <span class="keyword">ON</span> users (username, email); <span class="comment">-- 复合索引</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>ALTER TABLE</code> 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> INDEX idx_email (email);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX uidx_username (username);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> (id); <span class="comment">-- 添加主键（如果是新表）</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> articles <span class="keyword">ADD</span> FULLTEXT INDEX ft_content (content);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name; <span class="comment">-- 如果是唯一索引/普通索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">PRIMARY KEY</span>;     <span class="comment">-- 如果是主键索引</span></span><br></pre></td></tr></table></figure>

<h2 id="五、索引优化策略"><a href="#五、索引优化策略" class="headerlink" title="五、索引优化策略"></a>五、索引优化策略</h2><h3 id="1-选择合适的列创建索引"><a href="#1-选择合适的列创建索引" class="headerlink" title="1. 选择合适的列创建索引"></a>1. 选择合适的列创建索引</h3><ul>
<li><strong>WHERE 条件中经常使用的列</strong>：等值查询、范围查询的列。</li>
<li><strong>JOIN 连接条件中使用的列</strong>：<code>ON</code> 子句中的列。</li>
<li><strong>ORDER BY 和 GROUP BY 子句中使用的列</strong>：可以避免文件排序。</li>
<li><strong>选择性高的列</strong>：列中值的重复率越低，索引的效果越好。例如，性别这种只有两种值的列，选择性很低，不适合单独建立索引。</li>
<li><strong>不为 NULL 的列</strong>：如果列可以为 <code>NULL</code>，索引可能会失效。</li>
</ul>
<h3 id="2-避免索引失效"><a href="#2-避免索引失效" class="headerlink" title="2. 避免索引失效"></a>2. 避免索引失效</h3><ul>
<li><strong>不要在 <code>WHERE</code> 子句中使用 <code>OR</code> 连接条件</strong>：除非 <code>OR</code> 连接的所有列都创建了索引。</li>
<li><strong>避免在索引列上进行函数操作</strong>：<code>WHERE YEAR(create_time) = 2023</code> 会导致索引失效。</li>
<li><strong>避免在索引列上进行类型转换</strong>：例如，将字符串与数字进行比较。</li>
<li><strong><code>LIKE</code> 查询中，通配符 <code>%</code> 不要放在开头</strong>：<code>WHERE column_name LIKE &#39;prefix%&#39;</code> 会使用索引，而 <code>WHERE column_name LIKE &#39;%suffix&#39;</code> 或 <code>&#39;%pattern%&#39;</code> 不会。</li>
<li><strong>避免使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符</strong>：这些操作符通常会导致全表扫描。</li>
<li><strong><code>IS NULL</code> 和 <code>IS NOT NULL</code></strong>：在某些情况下可能使索引失效，取决于 MySQL 版本和优化器。通常最好让列始终有值。</li>
<li><strong>复合索引的“最左前缀原则”</strong>：查询条件必须从复合索引的最左边列开始使用，才能利用到该索引。</li>
</ul>
<h3 id="3-优化索引设计"><a href="#3-优化索引设计" class="headerlink" title="3. 优化索引设计"></a>3. 优化索引设计</h3><ul>
<li><strong>考虑使用覆盖索引</strong>：如果查询只需要索引中的列，就不需要回表，效率极高。</li>
<li><strong>创建短索引&#x2F;前缀索引</strong>：对于很长的字符串列，可以只索引其前缀。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_long_text <span class="keyword">ON</span> your_table (long_text(<span class="number">20</span>)); <span class="comment">-- 只索引前20个字符</span></span><br></pre></td></tr></table></figure>
这样可以节省磁盘空间，提高索引效率，但可能会降低索引的选择性。</li>
<li><strong>利用联合索引</strong>：将经常一起查询的列创建为联合索引，并注意列的顺序（将选择性高的列放在前面）。</li>
<li><strong>考虑 InnoDB 的主键选择</strong>：如果业务 ID 是自增的，设为主键会减少页分裂和数据移动，提升性能。如果业务 ID 是UUID等随机值，考虑使用一个自增代理主键，业务 UUID 则作为唯一索引。</li>
<li><strong>定期维护索引</strong>：对索引进行优化和重建，例如 <code>OPTIMIZE TABLE</code>。</li>
</ul>
<h3 id="4-观察和分析"><a href="#4-观察和分析" class="headerlink" title="4. 观察和分析"></a>4. 观察和分析</h3><ul>
<li><strong>使用 <code>EXPLAIN</code> 分析查询语句</strong>：这是最重要的工具，可以查看 MySQL 如何执行查询，是否使用了索引，使用了哪个索引，以及回表情况等。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure>
重点关注 <code>type</code>（访问类型）、<code>key</code>（实际使用的索引）、<code>rows</code>（大概扫描的行数）、<code>Extra</code> 等信息。</li>
<li><strong>慢查询日志</strong>：记录执行时间超过阈值的查询语句，方便定位性能瓶颈。</li>
<li><strong>监控数据库性能指标</strong>：如磁盘 I&#x2F;O、CPU 使用率、缓存命中率等。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>MySQL 索引是数据库性能优化的基石。正确理解和使用不同类型的索引，结合实际业务场景进行设计，并根据 <code>EXPLAIN</code> 等工具的分析结果进行迭代优化，才能真正发挥索引的威力。索引并非越多越好，它是一个需要合理权衡的过程，旨在在查询速度和写入速度之间取得最佳平衡。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/2023-02-01_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%9A%E6%89%93%E9%80%A0%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/" title="Docker镜像构建与管理：打造标准化、可复用的容器镜像"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker镜像构建与管理：打造标准化、可复用的容器镜像</div></div><div class="info-2"><div class="info-item-1"> 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  Docker 镜像构建与管理：打造标准化、可复用的容器镜像开篇：你是否也在镜像管理上栽过跟头？凌晨 2 点，生产环境突然告警，新部署的容器启动失败。排查后发现：开发环境用的镜像 800MB，生产环境的却有 3.2GB，里面塞满了编译工具、测试数据，甚至还有开发同学的 SSH 私钥… 这种 “镜像肥胖症” 你遇到过吗？或者更糟糕的：  同一个服务，测试环境能跑，生产环境启动就报错 镜像仓库里堆满了 latest、v1、v1-final、v1-final-final 这种让人崩溃的标签 构建一次镜像要等 20 分钟，因为每次都要重新下载依赖包  今天这篇文章，我会基于 5 年运维实战经验，教你构建一套标准化的镜像管理体系：从多阶段构建优化到镜像安全扫描，从版本管理策略到自动化构建流程，让你的镜像体积缩小 70%、构建速度提升 5 倍，并且永远不会再出现 “这个镜像到底能不能用” 的灵魂拷问。 一、镜像构建的三大核心原则（90% 的人都忽略了）1. 最小化原则：镜像里只放 “必需品”很多人写 Doc...</div></div></div></a><a class="pagination-related" href="/2023/2023-01-26_%E4%BB%8E%E5%8D%95%E6%9C%BA%E5%88%B0%E5%93%A8%E5%85%B5%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85redis%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="从单机到哨兵，一张图理清redis架构演进！"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">从单机到哨兵，一张图理清redis架构演进！</div></div><div class="info-2"><div class="info-item-1">Redis 的架构是逐步演进而来的，正所谓“罗马不是一天建成的”。   2010 年：单机版 Redis  当 Redis1.0在 2010 年首次发布时，整体架构非常简单，通常作为业务系统的缓存使用。不过，Redis 的数据是存储在内存中的，一旦重启，数据就会全部丢失，导致请求会直接打到数据库上，带来较大的压力。  2013 年：持久化机制上线  2013 年，Redis2.8版本发布，解决了之前“重启就丢数据”的问题。Redis 引入了 RDB（内存快照）机制，用于定时将内存中的数据持久化到磁盘。同时还支持 AOF（只追加文件）方式，将每一次写操作都记录到日志文件中，实现更高级别的持久化保障。  2013 年：主从复制机制  同样在 Redis2.8中，官方引入了主从复制功能，提升了系统的高可用性。主节点负责处理实时的读写请求，从节点则负责同步主节点的数据，起到备份和读扩展的作用。  2013 年：Sentinel 哨兵机制上线  在 Redis2.8版本中，引入了 Sentinel（哨兵）机制，用于实时监控 Redis 实例的运行状态。它主要负责以下几个方面的工作：   监...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-06-01_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL EXPLAIN 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="info-item-2">MySQL EXPLAIN 详解</div></div><div class="info-2"><div class="info-item-1"> EXPLAIN 是 MySQL 提供的一个非常强大的工具，用于分析 SELECT 语句的执行计划。通过 EXPLAIN 的输出结果，我们可以了解查询是如何执行的，包括使用了哪些索引、扫描了多少行、是否进行了文件排序等信息。这是数据库性能调优不可或缺的一环，能够帮助我们发现 SQL 语句中的性能瓶颈并进行优化。  “优化前，先 EXPLAIN。没有 EXPLAIN 的优化都是盲人摸象。” - 数据库优化格言   一、什么是 EXPLAIN？EXPLAIN 命令实际上是用来获取 MySQL 执行查询语句的执行计划的。执行计划描述了 MySQL 如何处理 SQL 语句，包括：  表的连接顺序 每个表使用的索引 是否使用了临时表 是否进行了文件排序 扫描的行数预估  通过分析这些信息，我们可以判断查询是否高效，是否可以进一步优化。 二、如何使用 EXPLAIN？使用 EXPLAIN 非常简单，只需将 EXPLAIN 关键字放在任何 SELECT 语句的前面。 1234EXPLAIN SELECT * FROM users WHERE username = &#x27;Alice&#x2...</div></div></div></a><a class="pagination-related" href="/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/" title="MySQL B+树索引原理详解与对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-11</div><div class="info-item-2">MySQL B+树索引原理详解与对比</div></div><div class="info-2"><div class="info-item-1"> 数据库索引是提升查询性能的关键，而 MySQL 中最常见的索引结构就是 B+树。理解 B+树的原理对于优化数据库性能至关重要。本文将详细解析 B+树索引的内部工作机制，并将其与二叉查找树、平衡二二叉查找树、红黑树和 B 树进行对比，阐明 B+树在磁盘存储和数据库查询场景下的优势。  “索引的本质是空间换时间，而 B+树是这种理念在磁盘存储场景下的极致优化。”   一、为什么需要索引？想象一下，你有一本几百页的字典，如果要查找一个词，没有目录（索引）的话，你可能需要从头到尾翻阅。而有了目录（索引），你可以快速定位到词语的大致位置，大大提高查找效率。 在数据库中，表是按照某种顺序（不一定是逻辑顺序）存储在磁盘上的。当数据量巨大时，如果没有索引，每次查询都需要进行全表扫描（Full Table Scan），这意味着数据库需要读取磁盘上的每一行数据并进行比较，效率极低。 索引通过创建一种特殊的数据结构，可以快速定位到数据记录的位置，从而显著减少磁盘 I&#x2F;O 次数，提高查询速度。 二、各种树结构简述与对比在深入 B+树之前，我们先回顾一下几种常见的树形数据结构，了解它们的优缺点...</div></div></div></a><a class="pagination-related" href="/2023/2023-01-26_%E4%BB%8E%E5%8D%95%E6%9C%BA%E5%88%B0%E5%93%A8%E5%85%B5%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85redis%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="从单机到哨兵，一张图理清redis架构演进！"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-26</div><div class="info-item-2">从单机到哨兵，一张图理清redis架构演进！</div></div><div class="info-2"><div class="info-item-1">Redis 的架构是逐步演进而来的，正所谓“罗马不是一天建成的”。   2010 年：单机版 Redis  当 Redis1.0在 2010 年首次发布时，整体架构非常简单，通常作为业务系统的缓存使用。不过，Redis 的数据是存储在内存中的，一旦重启，数据就会全部丢失，导致请求会直接打到数据库上，带来较大的压力。  2013 年：持久化机制上线  2013 年，Redis2.8版本发布，解决了之前“重启就丢数据”的问题。Redis 引入了 RDB（内存快照）机制，用于定时将内存中的数据持久化到磁盘。同时还支持 AOF（只追加文件）方式，将每一次写操作都记录到日志文件中，实现更高级别的持久化保障。  2013 年：主从复制机制  同样在 Redis2.8中，官方引入了主从复制功能，提升了系统的高可用性。主节点负责处理实时的读写请求，从节点则负责同步主节点的数据，起到备份和读扩展的作用。  2013 年：Sentinel 哨兵机制上线  在 Redis2.8版本中，引入了 Sentinel（哨兵）机制，用于实时监控 Redis 实例的运行状态。它主要负责以下几个方面的工作：   监...</div></div></div></a><a class="pagination-related" href="/2023/2023-05-08_Redis%20%E5%90%84%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/" title="Redis 各类数据结构指令详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-08</div><div class="info-item-2">Redis 各类数据结构指令详解</div></div><div class="info-2"><div class="info-item-1"> Redis 是一个开源（BSD 许可）的内存数据结构存储，可用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。理解并熟练使用这些数据结构及其相关指令，是高效利用 Redis 的关键。  Redis 的强大之处在于其在内存中操作这些丰富的数据结构，使得读写速度极快。掌握每个数据结构的使用场景和对应指令，是进行高性能应用开发的基础。   一、通用键指令 (Generic Commands)这些指令适用于所有数据类型的键。    指令 描述 示例    DEL key [key ...] 删除一个或多个键。 DEL mykey mylist   EXISTS key [key ...] 检查给定键是否存在。返回存在的键的数量。 EXISTS mykey   EXPIRE key seconds 设置键的过期时间（秒）。 EXPIRE mykey 60 (60秒后过期)   TTL key 获取键的剩余过期时间（秒）。-1 表示永久，-2 表示键不存在或已过...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-01_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%9A%E6%89%93%E9%80%A0%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/" title="Docker镜像构建与管理：打造标准化、可复用的容器镜像"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">Docker镜像构建与管理：打造标准化、可复用的容器镜像</div></div><div class="info-2"><div class="info-item-1"> 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  Docker 镜像构建与管理：打造标准化、可复用的容器镜像开篇：你是否也在镜像管理上栽过跟头？凌晨 2 点，生产环境突然告警，新部署的容器启动失败。排查后发现：开发环境用的镜像 800MB，生产环境的却有 3.2GB，里面塞满了编译工具、测试数据，甚至还有开发同学的 SSH 私钥… 这种 “镜像肥胖症” 你遇到过吗？或者更糟糕的：  同一个服务，测试环境能跑，生产环境启动就报错 镜像仓库里堆满了 latest、v1、v1-final、v1-final-final 这种让人崩溃的标签 构建一次镜像要等 20 分钟，因为每次都要重新下载依赖包  今天这篇文章，我会基于 5 年运维实战经验，教你构建一套标准化的镜像管理体系：从多阶段构建优化到镜像安全扫描，从版本管理策略到自动化构建流程，让你的镜像体积缩小 70%、构建速度提升 5 倍，并且永远不会再出现 “这个镜像到底能不能用” 的灵魂拷问。 一、镜像构建的三大核心原则（90% 的人都忽略了）1. 最小化原则：镜像里只放 “必需品”很多人写 Doc...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-05_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8EDockerfile%E5%88%B0%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">176</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">165</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">一、什么是索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">二、索引的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">三、索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-text">1. 按数据结构分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-B-Tree-%E7%B4%A2%E5%BC%95-%E9%BB%98%E8%AE%A4%EF%BC%8C%E5%B8%B8%E7%94%A8"><span class="toc-text">(1) B+Tree 索引 (默认，常用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Hash-%E7%B4%A2%E5%BC%95"><span class="toc-text">(2) Hash 索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%89%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB-InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">2. 按物理存储分类 (InnoDB 存储引擎)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-Clustered-Index"><span class="toc-text">(1) 聚集索引 (Clustered Index)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-Secondary-Index-Auxiliary-Index"><span class="toc-text">(2) 非聚集索引 (Secondary Index &#x2F; Auxiliary Index)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%89%E9%80%BB%E8%BE%91%E5%88%86%E7%B1%BB"><span class="toc-text">3. 按逻辑分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-Normal-Non-Unique-Index"><span class="toc-text">(1) 普通索引 (Normal &#x2F; Non-Unique Index)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-Unique-Index"><span class="toc-text">(2) 唯一索引 (Unique Index)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-Primary-Key-Index"><span class="toc-text">(3) 主键索引 (Primary Key Index)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95-Full-Text-Index"><span class="toc-text">(4) 全文索引 (Full-Text Index)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95-Composite-Combination-Index"><span class="toc-text">(5) 复合索引 (Composite &#x2F; Combination Index)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-text">四、索引的创建与删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-text">五、索引优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%88%97%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-text">1. 选择合适的列创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">2. 避免索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">3. 优化索引设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%82%E5%AF%9F%E5%92%8C%E5%88%86%E6%9E%90"><span class="toc-text">4. 观察和分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-13.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>