<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren() | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg">
<meta property="article:published_time" content="2023-11-14T22:24:00.000Z">
<meta property="article:modified_time" content="2025-09-29T10:19:23.470Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()",
  "url": "https://blog.tbf1211.xx.kg/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg",
  "datePublished": "2023-11-14T22:24:00.000Z",
  "dateModified": "2025-09-29T10:19:23.470Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-25.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-14T22:24:00.000Z" title="发表于 2023-11-15 06:24:00">2023-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/Vue/">Vue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 <strong>虚拟 DOM (Virtual DOM)</strong> 及其配套的 <strong>Diff 算法 (补丁机制)</strong>。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：<code>patch()</code>, <code>patchVnode()</code>, 和 <code>updateChildren()</code>，并辅以 Mermaid 流程图进行可视化说明。</p>
</blockquote>
<div class="note info flat"><p>“虚拟 DOM 是前端性能优化的基石，而 Vue 的 <code>patch()</code> 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”</p>
</div>

<h2 id="一、虚拟-DOM-Virtual-DOM-再探"><a href="#一、虚拟-DOM-Virtual-DOM-再探" class="headerlink" title="一、虚拟 DOM (Virtual DOM) 再探"></a>一、虚拟 DOM (Virtual DOM) 再探</h2><h3 id="1-1-什么是虚拟-DOM？"><a href="#1-1-什么是虚拟-DOM？" class="headerlink" title="1.1 什么是虚拟 DOM？"></a>1.1 什么是虚拟 DOM？</h3><p>虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：</p>
<ul>
<li><code>tag</code>：标签名（如 <code>div</code>、<code>p</code>，或者组件的配置对象）。</li>
<li><code>data</code>：一个对象，包含 DOM 元素的属性（<code>attrs</code>）、样式（<code>style</code>）、事件（<code>on</code>）、<code>key</code>、<code>class</code> 等。</li>
<li><code>children</code>：一个 VNode 数组，表示当前 VNode 的子节点。</li>
<li><code>text</code>：如果 VNode 是一个文本节点，则为文本内容。</li>
<li><code>elm</code>：对实际 DOM 元素的引用（在补丁 (<code>patch</code>) 过程中会被赋值）。</li>
</ul>
<h3 id="1-2-为什么需要虚拟-DOM？"><a href="#1-2-为什么需要虚拟-DOM？" class="headerlink" title="1.2 为什么需要虚拟 DOM？"></a>1.2 为什么需要虚拟 DOM？</h3><ol>
<li><strong>性能优化</strong>：直接操作真实 DOM 是非常耗费性能的。虚拟 DOM 将频繁的 DOM 操作集中起来，通过 Diff 算法计算出最小的变更集，然后一次性（批量）地更新真实 DOM，显著减少了重绘和回流的次数。</li>
<li><strong>开发体验</strong>：开发者只需关注数据的变化和组件状态，无需手动操作复杂的 DOM API，提高了开发效率。</li>
<li><strong>跨平台能力</strong>：因为虚拟 DOM 只是 JavaScript 对象，它可以被渲染到不同的平台（如 Web 浏览器、Native 应用、小程序等），而不仅仅是浏览器环境。</li>
</ol>
<h3 id="1-3-虚拟-DOM-到真实-DOM-的过程"><a href="#1-3-虚拟-DOM-到真实-DOM-的过程" class="headerlink" title="1.3 虚拟 DOM 到真实 DOM 的过程"></a>1.3 虚拟 DOM 到真实 DOM 的过程</h3><div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    A[Vue 组件数据&#x2F;状态变化] --&gt; B(render 函数生成新的 VNode 树)
    B --&gt; C{Diff 算法 &#x2F; patch 函数}
    D[旧的 VNode 树 （上次渲染结果）] --&gt; C
    C --&gt; E[生成补丁集 （最小差异）]
    E --&gt; F[更新真实 DOM]
  </pre></div>

<h2 id="二、Vue-补丁机制核心函数解析"><a href="#二、Vue-补丁机制核心函数解析" class="headerlink" title="二、Vue 补丁机制核心函数解析"></a>二、Vue 补丁机制核心函数解析</h2><p>当 Vue 的响应式数据发生变化时，如果组件被标记为需要重新渲染，它会重新执行 <code>render</code> 函数生成一颗新的 VNode 树。接下来，Vue 的渲染器会调用 <code>patch()</code> 函数，负责比较新旧 VNode 树并更新真实 DOM。</p>
<h3 id="2-1-patch-oldVnode-newVnode-：差异发现与更新的入口"><a href="#2-1-patch-oldVnode-newVnode-：差异发现与更新的入口" class="headerlink" title="2.1 patch(oldVnode, newVnode)：差异发现与更新的入口"></a>2.1 <code>patch(oldVnode, newVnode)</code>：差异发现与更新的入口</h3><p><code>patch()</code> 函数是整个渲染更新过程的入口。它的主要职责是根据 <code>oldVnode</code> 和 <code>newVnode</code> 的不同情形，执行相应的 DOM 操作，包括创建、更新或删除元素。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    start(&quot;patch（oldVnode, newVnode）&quot;) --&gt; A{oldVnode是真实DOM元素?&lt;br&gt;（如 #app 首次挂载）};
    A -- 是, 首次挂载 --&gt; B[创建 newVnode.elm 并替换真实DOM];
    A -- 否 --&gt; C{newVnode 存在?};
    C -- 否, oldVnode需删除 --&gt; D[移除 oldVnode.elm];
    C -- 是 --&gt; E{newVnode是文本VNode?};
    E -- 是, 文本节点 --&gt; F[更新 oldVnode.elm.textContent &#x3D; newVnode.text];
    E -- 否 --&gt; G{sameVnode（oldVnode, newVnode）相同VNode?};
    G -- 是, 相同VNode --&gt; H(patchVnode（oldVnode, newVnode）);
    G -- 否, 不同VNode --&gt; I[销毁 oldVnode.elm, 创建并插入 newVnode.elm];
    B --&gt; K[返回 newVnode.elm];
    F --&gt; K;
    H --&gt; K;
    I --&gt; K;
  </pre></div>

<p><strong>关键逻辑点</strong>：</p>
<ol>
<li><strong>首次渲染 (Initial Mount)</strong>：<ul>
<li>如果 <code>oldVnode</code> 是一个真实 DOM 元素（通常是 <code>el</code> 选项提供的挂载点，如 <code>document.querySelector(&#39;#app&#39;)</code>），则 <code>newVnode</code> 会被完全创建并插入到 DOM 中，替换掉 <code>oldVnode</code>，并建立 <code>newVnode.elm</code> 对真实 DOM 的引用。</li>
</ul>
</li>
<li><strong>更新 (Update)</strong>：<ul>
<li>如果发现 <code>sameVnode(oldVnode, newVnode)</code> 返回 <code>true</code>（即它们代表同一个元素，主要通过 <code>key</code> 和 <code>tag</code> 判断），则进入 <code>patchVnode()</code> 进行更细致的比较和更新。</li>
<li>如果返回 <code>false</code>（它们不是 <code>sameVnode</code>），说明它们是完全不同的元素。此时，<code>oldVnode</code> 对应的真实 DOM 会被销毁，然后创建并插入 <code>newVnode</code> 对应的真实 DOM。</li>
</ul>
</li>
<li><code>newVnode</code> 不存在（<code>undefined</code>）：这意味着 <code>oldVnode</code> 对应的元素需要被移除。</li>
</ol>
<h3 id="2-2-patchVnode-oldVnode-newVnode-：同类节点的深度比对与更新"><a href="#2-2-patchVnode-oldVnode-newVnode-：同类节点的深度比对与更新" class="headerlink" title="2.2 patchVnode(oldVnode, newVnode)：同类节点的深度比对与更新"></a>2.2 <code>patchVnode(oldVnode, newVnode)</code>：同类节点的深度比对与更新</h3><p><code>patchVnode()</code> 是 <code>patch()</code> 函数中用于处理<strong>被认为是相同 VNode</strong> 的深度比较和更新的函数。它会对比两个 VNode 的属性、事件、子节点等，并执行最小化的 DOM 操作。</p>
<p><strong>Mermaid 流程图</strong>：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    start(&quot;patchVnode（oldVnode，newVnode）开始&quot;) --&gt; A[newVnode.elm &#x3D; oldVnode.elm（复用真实DOM）];
    A --&gt; B{oldVnode与newVnode的data（如props&#x2F;style&#x2F;event）不同?};
    B -- 是 --&gt; C[更新oldVnode.elm上的属性和事件];
    B -- 否 --&gt; D;
    C --&gt; D;

    D{newVnode有子节点?};
    D -- 是 --&gt; E{oldVnode有子节点?};
    E -- 是, 新旧都有子节点 --&gt; F(updateChildren（oldVnode.children, newVnode.children）);
    E -- 否, 旧只有文本或空 --&gt; G[清空oldVnode.elm内容, 添加newVnode的所有子节点];
    F --&gt; O(&quot;结束&quot;);
    G --&gt; O;

    D -- 否, newVnode无子节点 --&gt; H{oldVnode有子节点?};
    H -- 是, 旧有子节点需移除 --&gt; I[移除oldVnode.elm的所有子节点];
    H -- 否 --&gt; J;
    I --&gt; J;

    J{newVnode有文本内容?};
    J -- 是 --&gt; K[设置 oldVnode.elm.textContent &#x3D; newVnode.text];
    J -- 否 --&gt; L{oldVnode有文本内容?};
    L -- 是 --&gt; M[清空 oldVnode.elm.textContent];
    L -- 否 --&gt; O;
    K --&gt; O;
    M --&gt; O;
  </pre></div>

<p><strong>关键逻辑点</strong>：</p>
<ol>
<li><strong>复用 DOM 元素</strong>：<code>newVnode.elm = oldVnode.elm</code>。由于它们是 <code>sameVnode</code>，所以它们对应的真实 DOM 元素可以被复用。</li>
<li><strong>更新 VNode 的数据 (Props, Style, Class, Event Listener 等)</strong>：<code>updateAttrs(oldVnode, newVnode)</code> 等方法会对比 <code>oldVnode.data</code> 和 <code>newVnode.data</code>，只更新变化的属性，移除不再存在的属性，并重新绑定事件。</li>
<li><strong>处理子节点</strong>：这是最复杂也是最重要的部分。<ul>
<li><strong>新旧 VNode 都有子节点</strong>：调用 <code>updateChildren(oldVnode.children, newVnode.children)</code> 进行子节点列表的 Diff 比较。</li>
<li><strong>新 VNode 有子节点，旧 VNode 没有</strong>：清空旧的 DOM 元素内容，然后将 <code>newVnode.children</code> 全部添加到 DOM 中。</li>
<li><strong>新 VNode 没有子节点，旧 VNode 却有</strong>：则直接移除 <code>oldVnode</code> 的所有子节点对应的真实 DOM。</li>
<li><strong>处理文本节点</strong>：如果新 VNode 有文本内容 (<code>newVnode.text</code> 存在)，则将 DOM 元素的 <code>textContent</code> 设置为 <code>newVnode.text</code>。如果旧 VNode 有文本内容 (<code>oldVnode.text</code> 存在) 但新 VNode 既没有子节点也没有文本内容，则清空 DOM 元素的 <code>textContent</code>。</li>
</ul>
</li>
</ol>
<h3 id="2-3-updateChildren-oldChildren-newChildren-：子节点列表的-Diff-算法核心"><a href="#2-3-updateChildren-oldChildren-newChildren-：子节点列表的-Diff-算法核心" class="headerlink" title="2.3 updateChildren(oldChildren, newChildren)：子节点列表的 Diff 算法核心"></a>2.3 <code>updateChildren(oldChildren, newChildren)</code>：子节点列表的 Diff 算法核心</h3><p><code>updateChildren()</code> 是 Vue 2 Diff 算法的核心，它采用<strong>双端比较算法 (Two-Pointer Diff Algorithm)</strong> 来高效地比对新旧子 VNode 列表，最大限度地复用和移动 DOM 元素，减少不必要的创建和销毁。</p>
<p><strong>Mermaid 流程图</strong>：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    start(&quot;开始&quot;) --&gt; A[初始化四个指针:&lt;br&gt;oldStartIdx, oldEndIdx&lt;br&gt;newStartIdx, newEndIdx];
    A --&gt; B{while （oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx）};
    B -- 是 （循环中） --&gt; CurrentOldStart[获取 VNode: oldChildren【oldStartIdx】];
    CurrentOldStart --&gt; CurrentOldEnd[获取 VNode: oldChildren【oldEndIdx】];
    CurrentOldEnd --&gt; CurrentNewStart[获取 VNode: newChildren【newStartIdx】];
    CurrentNewStart --&gt; CurrentNewEnd[获取 VNode: newChildren【newEndIdx】];

    CurrentNewEnd --&gt; C{currentOldStartVnode为空值?&lt;br&gt;（跳过已处理或空的旧节点）};
    C -- 是 --&gt; D[oldStartIdx++ （跳过）];
    C -- 否 --&gt; E{currentOldEndVnode为空值?&lt;br&gt;（跳过已处理或空的旧节点）};
    E -- 是 --&gt; F[oldEndIdx-- （跳过）];
    E -- 否 --&gt; G{sameVnode（currentOldStartVnode, currentNewStartVnode）?&lt;br&gt;（头头匹配）};
    G -- 是 （匹配） --&gt; H[patchVnode（头头）, oldStartIdx++, newStartIdx++];
    G -- 否 --&gt; I{sameVnode（currentOldEndVnode, currentNewEndVnode）?&lt;br&gt;（尾尾匹配）};
    I -- 是 （匹配） --&gt; J[patchVnode（尾尾）, oldEndIdx--, newEndIdx--];
    I -- 否 --&gt; K{sameVnode（currentOldStartVnode, currentNewEndVnode）?&lt;br&gt;（旧头新尾）};
    K -- 是 （匹配） --&gt; L[patchVnode（旧头新尾）, 移动DOM到oldEndVnode之后, oldStartIdx++, newEndIdx--];
    K -- 否 --&gt; M{sameVnode（currentOldEndVnode, currentNewStartVnode）?&lt;br&gt;（旧尾新头）};
    M -- 是 （匹配） --&gt; N[patchVnode（旧尾新头）, 移动DOM到oldStartVnode之前, oldEndIdx--, newStartIdx++];
    M -- 否 （四种快速匹配失败） --&gt; Fallback[Fallback（通用匹配）:&lt;br&gt;1. 查找 newStartVnode 在 oldChildren 中是否有相同key的VNode&lt;br&gt;2. 如果找到: patchVnode, 移动DOM, 标记旧VNode已处理&lt;br&gt;3. 否则: 创建新VNode对应的真实DOM并插入&lt;br&gt;4. newStartIdx++];
    
    D --&gt; B;
    F --&gt; B;
    H --&gt; B;
    J --&gt; B;
    L --&gt; B;
    N --&gt; B;
    Fallback --&gt; B;

    B -- 否 （循环结束） --&gt; O{newStartIdx &lt;&#x3D; newEndIdx?&lt;br&gt;（新数组还有剩余节点，说明是新增的）};
    O -- 是 --&gt; P[批量插入剩余的新节点];
    O -- 否 --&gt; Q{oldStartIdx &lt;&#x3D; oldEndIdx?&lt;br&gt;（旧数组还有剩余节点，说明是被删除的）};
    Q -- 是 --&gt; R[批量移除剩余的旧节点];
    Q -- 否 --&gt; S(&quot;结束&quot;);
    P --&gt; S;
    R --&gt; S;
  </pre></div>

<p><strong>关键逻辑点</strong>：</p>
<ol>
<li><strong>双端四向比较</strong>：<ul>
<li>Vue 的 Diff 算法会维护 <code>oldStartIdx</code> (旧开始索引), <code>oldEndIdx</code> (旧结束索引), <code>newStartIdx</code> (新开始索引), <code>newEndIdx</code> (新结束索引) 四个指针。</li>
<li>在循环中，它优先尝试从新旧子节点列表的头部和尾部进行四种快速匹配：<ul>
<li><strong>头头匹配 (<code>oldStart</code> vs <code>newStart</code>)</strong>：如果匹配，就地更新，两者指针都向右移动。</li>
<li><strong>尾尾匹配 (<code>oldEnd</code> vs <code>newEnd</code>)</strong>：如果匹配，就地更新，两者指针都向左移动。</li>
<li><strong>旧头新尾匹配 (<code>oldStart</code> vs <code>newEnd</code>)</strong>：如果匹配，说明旧的头节点移动到了新的尾部，更新后将对应的真实 DOM 移动到 <code>oldEndVnode</code> 对应的 DOM 之后。</li>
<li><strong>旧尾新头匹配 (<code>oldEnd</code> vs <code>newStart</code>)</strong>：如果匹配，说明旧的尾节点移动到了新的头部，更新后将对应的真实 DOM 移动到 <code>oldStartVnode</code> 对应的 DOM 之前。</li>
</ul>
</li>
<li>一旦匹配成功，就调用 <code>patchVnode</code> 更新节点，并根据匹配类型移动真实 DOM，同时移动相应的指针。</li>
</ul>
</li>
<li><strong>Fallback 策略（通过 <code>key</code> 查找）</strong>：<ul>
<li>如果上述四种情况都未匹配，Vue 会为 <code>oldChildren</code> 中未处理的节点建立一个 <code>key</code> 到索引的映射表。</li>
<li>然后尝试在新列表的 <code>newStartVnode</code> 中查找其 <code>key</code> 是否在旧列表中存在。</li>
<li>如果找到相同 <code>key</code> 且是 <code>sameVnode</code> 的旧节点：就 <code>patchVnode</code>，并将其对应的真实 DOM 移动到正确的位置。旧节点会被标记为已处理。</li>
<li>如果没找到或 <code>key</code> 不同但 <code>isSameVnode</code> 失败，则说明 <code>newStartVnode</code> 是一个全新的节点，需要创建并插入其对应的真实 DOM。</li>
</ul>
</li>
<li><strong>循环结束后的处理</strong>：<ul>
<li><strong>新增节点</strong>：如果循环结束后，<code>newChildren</code> 中仍有未处理的节点（<code>newStartIdx &lt;= newEndIdx</code>），说明它们是新添加的，需要创建并插入到 DOM 中。</li>
<li><strong>删除节点</strong>：如果循环结束后，<code>oldChildren</code> 中仍有未处理的节点（<code>oldStartIdx &lt;= oldEndIdx</code>），说明它们在 <code>newChildren</code> 中不存在，需要从 DOM 中移除。</li>
</ul>
</li>
</ol>
<h3 id="2-4-key-属性的决定性作用"><a href="#2-4-key-属性的决定性作用" class="headerlink" title="2.4 key 属性的决定性作用"></a>2.4 <code>key</code> 属性的决定性作用</h3><p>在 <code>updateChildren()</code> 中，<code>key</code> 属性起着至关重要的作用。它为每个 VNode 提供了唯一的身份标识。</p>
<ul>
<li><strong>唯一性</strong>：<code>key</code> 在同级 VNode 中必须是唯一的。</li>
<li><strong>稳定性</strong>：<code>key</code> 值应保持稳定，不应随机生成或使用数组索引（除非列表是静态的且永不变化）。</li>
<li><strong>作用</strong>：<ul>
<li><strong>精确识别</strong>：Vue 能够利用 <code>key</code> 精准地判断哪些 VNode 是同一个元素，只是位置变了，哪些是新增或删除的。</li>
<li><strong>高效复用</strong>：当 VNode 顺序变化时，拥有相同 <code>key</code> 的真实 DOM 元素和组件实例能够被尽可能地复用、移动，而不是销毁重建，从而保持组件内部状态（如输入框的焦点、滚动位置等）。</li>
<li><strong>性能优化</strong>：避免不必要的 DOM 操作，特别是在列表数据发生增删改排序时。</li>
</ul>
</li>
</ul>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>虚拟 DOM 和 Vue 的 <code>patch()</code> 机制是其高性能和良好开发体验的基石。</p>
<ul>
<li><code>**patch()**</code> 是整个更新流程的入口，负责根据新旧 VNode 的不同类型和关系，决定是创建、更新还是删除 DOM 节点。</li>
<li><code>**patchVnode()**</code> 专注处理被认为是同一元素的 VNode 之间的深度比较，更新它们的属性、样式和事件，并递归处理它们的子节点。</li>
<li><code>**updateChildren()**</code> 作为 Diff 算法的核心，通过巧妙的双端比较和 <code>key</code> 属性的辅助，高效地比对子节点列表，并执行最小化的 DOM 移动、插入和删除操作。</li>
</ul>
<p>理解这些核心函数的工作原理，不仅有助于深入掌握 Vue 的渲染机制，更能帮助我们写出更高效、更健壮的 Vue 应用。 Vue 3 虽然在细节上有所优化（如引入 PatchFlag 和 LIS 算法），但其核心的 Diff&#x2F;Patch 理念和 <code>sameVnode</code>、深度比较与子节点处理的模式是一脉相承的。Mermaid 图为理解这些复杂流程提供了直观的视觉辅助。</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/">https://blog.tbf1211.xx.kg/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-25.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/2023-12-21_JWT%20(JSON%20Web%20Tokens)%20%E8%AF%A6%E8%A7%A3/" title="JWT (JSON Web Tokens) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JWT (JSON Web Tokens) 详解</div></div><div class="info-2"><div class="info-item-1"> JWT (JSON Web Tokens) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为 JSON 对象。此信息可以通过数字签名进行验证，可以保证信息的完整性和真实性。JWT 通常用于认证和授权。  “JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.” —— JWT.io   一、为什么需要 JWT？在无状态的 Web 应用程序中，用户认证和授权是一个常见但复杂的问题。传统的基于 Session 的认证方式，在分布式系统（如微服务）和移动应用场景下遇到了挑战：  跨域问题: Session 通常依赖 Cookie，而 Cookie 在跨域时有严格的限制。 水平扩展性: Session 需要服务器端存储用户状态。当应用需要水平扩展时，Se...</div></div></div></a><a class="pagination-related" href="/2023/2023-11-02_Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="Git命令详解与实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Git命令详解与实践</div></div><div class="info-2"><div class="info-item-1"> Git 是一款免费、开源的分布式版本控制系统，旨在快速、高效地处理从小规模到超大规模的所有项目。它由 Linux 内核的创建者 Linus Torvalds 于 2005 年创建。Git 的核心理念是跟踪内容而非文件，并支持非线性开发（即多人并行开发，合并不同的工作流）。  本文将深入介绍 Git 的核心概念、常用命令、工作流程、分支管理策略以及一些最佳实践。 “Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.” —— Git 官方 Slogan   一、Git 核心概念在使用 Git 命令之前，理解其核心概念至关重要。 1. 工作区 (Working Directory) 你电脑上当前可见的目录，包含你项目的所有文件。 你正在进行修改和编辑的地方。  2. 暂存区 (Staging Area &#x2F; Index)...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-03-01_React%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/" title="React入门教程：快速构建交互式用户界面"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="info-item-2">React入门教程：快速构建交互式用户界面</div></div><div class="info-2"><div class="info-item-1"> React (通常称为 React.js 或 ReactJS) 是一个由 Facebook 开发并维护的用于构建用户界面 (UI) 的 JavaScript 库。它以其组件化、声明式的编程范式和高效的 虚拟 DOM (Virtual DOM) 机制而闻名。本入门教程将带你领略 React 的核心概念，并指导你搭建第一个 React 应用，让你快速掌握构建交互式前端应用的基础。  “React 并不是一个完整的框架，而是一个专注于 UI 层面的库。它鼓励你将 UI 拆分成独立、可复用的小块（组件），从而让代码更易于管理、开发和测试。学习 React，就是学习如何思考和构建组件。”   一、React 的核心理念1.1 组件化 (Component-Based)React 的核心是组件 (Component)。你可以将复杂的 UI 拆分为独立的、可复用的、封装性良好的小组件。每个组件都有自己的逻辑和外观，它们可以组合起来形成更复杂的 UI。  示例：一个电商网站可以分解为：Header 组件、ProductList 组件、ProductCard 组件、Button 组件、Shopp...</div></div></div></a><a class="pagination-related" href="/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Vue3响应式原理深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-11</div><div class="info-item-2">Vue3响应式原理深度解析</div></div><div class="info-2"><div class="info-item-1"> Vue 3 响应式系统是其 MVVM 框架的核心基石，它让前端开发者能够以声明式的方式构建用户界面，而无需手动操作 DOM。与 Vue 2 基于 Object.defineProperty 的实现不同，Vue 3 借助 ES6 的 Proxy 对象，彻底重构了响应式系统，带来了更高性能、更强大的功能和更灵活的 API。  “Vue 3 的响应式系统是一个优雅而强大的解决方案，它通过 Proxy 和一套高效的依赖追踪机制，实现了数据与视图的紧密双向绑定，极大地提升了开发体验。”   一、响应式系统的核心概念在深入 Vue 3 响应式原理之前，我们需要理解几个核心概念：  数据劫持 (Data Interception)：当访问或修改数据时，能够执行自定义逻辑。 依赖收集 (Dependency Collection)：追踪哪些组件或函数正在使用哪些响应式数据。 派发更新 (Trigger Update)：当响应式数据发生变化时，通知所有依赖于该数据的组件或函数进行更新。  二、Vue 2 与 Vue 3 响应式原理对比理解 Vue 3 的优势，最好从对比 Vue 2 开始。 2....</div></div></div></a><a class="pagination-related" href="/2025/2025-08-03_Vue3%20defineModel%E8%AF%A6%E8%A7%A3/" title="Vue3 defineModel详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-03</div><div class="info-item-2">Vue3 defineModel详解</div></div><div class="info-2"><div class="info-item-1"> defineModel 是 Vue 3.4+ 版本中引入的一个新的 &lt;script setup&gt; 宏，旨在简化 v-model 的实现。它将组件的 props 和 emit 事件的复杂性抽象化，使得声明和使用双向绑定属性变得前所未有的直观和简洁。本篇将详细解释 defineModel 的用法、原理以及它带来的优势。  “The defineModel macro simplifies the implementation of two-way binding props, providing idiomatic and easier-to-understand syntax for both child components and their parent components.” —— Vue.js Documentation   一、什么是 defineModel？在 Vue 中，v-model 是一个强大的语法糖，用于在表单输入元素或者组件上实现双向数据绑定。在 Vue 3 (以及 defineModel 之前)，组件要支持 v-model，需要手动声明一个...</div></div></div></a><a class="pagination-related" href="/2023/2023-05-01_%E5%9F%BA%E4%BA%8ETypeScript%E5%B0%81%E8%A3%85Axios%E6%88%90%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="基于TypeScript封装Axios成通用工具类"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-01</div><div class="info-item-2">基于TypeScript封装Axios成通用工具类</div></div><div class="info-2"><div class="info-item-1"> 在现代前端开发中，网络请求是任何应用不可或缺的一部分。Axios 作为一款流行的基于 Promise 的 HTTP 客户端，因其易用性和强大的功能而广受欢迎。然而，在大型项目中直接使用 Axios 可能会导致代码冗余、维护困难。结合 TypeScript 的类型优势，我们可以将 Axios 封装成一个强大且类型安全的通用工具类，从而提高代码的可维护性、可扩展性和开发效率。  “好的封装，是为了在自由和约束之间找到平衡，让开发更高效，代码更健壮。”   一、为什么需要封装 Axios？直接使用 Axios 固然方便，但在实际项目中，我们通常面临以下问题：  公共请求配置： baseURL、超时时间、请求头（如 Authorization Token）等在多个请求中重复设置。 请求&#x2F;响应拦截器：统一处理请求发送前的参数加密、Token 携带，以及响应返回后的状态码处理、错误提示、数据格式化等。 错误处理：统一的错误捕获和提示机制，避免每个请求都写 try...catch。 数据类型定义：使用 TypeScript 时，请求参数和响应数据的类型定义需要贯穿整个请求周期，直接...</div></div></div></a><a class="pagination-related" href="/2023/2023-06-01_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL EXPLAIN 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="info-item-2">MySQL EXPLAIN 详解</div></div><div class="info-2"><div class="info-item-1"> EXPLAIN 是 MySQL 提供的一个非常强大的工具，用于分析 SELECT 语句的执行计划。通过 EXPLAIN 的输出结果，我们可以了解查询是如何执行的，包括使用了哪些索引、扫描了多少行、是否进行了文件排序等信息。这是数据库性能调优不可或缺的一环，能够帮助我们发现 SQL 语句中的性能瓶颈并进行优化。  “优化前，先 EXPLAIN。没有 EXPLAIN 的优化都是盲人摸象。” - 数据库优化格言   一、什么是 EXPLAIN？EXPLAIN 命令实际上是用来获取 MySQL 执行查询语句的执行计划的。执行计划描述了 MySQL 如何处理 SQL 语句，包括：  表的连接顺序 每个表使用的索引 是否使用了临时表 是否进行了文件排序 扫描的行数预估  通过分析这些信息，我们可以判断查询是否高效，是否可以进一步优化。 二、如何使用 EXPLAIN？使用 EXPLAIN 非常简单，只需将 EXPLAIN 关键字放在任何 SELECT 语句的前面。 1234EXPLAIN SELECT * FROM users WHERE username = &#x27;Alice&#x2...</div></div></div></a><a class="pagination-related" href="/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/" title="MySQL B+树索引原理详解与对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-11</div><div class="info-item-2">MySQL B+树索引原理详解与对比</div></div><div class="info-2"><div class="info-item-1"> 数据库索引是提升查询性能的关键，而 MySQL 中最常见的索引结构就是 B+树。理解 B+树的原理对于优化数据库性能至关重要。本文将详细解析 B+树索引的内部工作机制，并将其与二叉查找树、平衡二二叉查找树、红黑树和 B 树进行对比，阐明 B+树在磁盘存储和数据库查询场景下的优势。  “索引的本质是空间换时间，而 B+树是这种理念在磁盘存储场景下的极致优化。”   一、为什么需要索引？想象一下，你有一本几百页的字典，如果要查找一个词，没有目录（索引）的话，你可能需要从头到尾翻阅。而有了目录（索引），你可以快速定位到词语的大致位置，大大提高查找效率。 在数据库中，表是按照某种顺序（不一定是逻辑顺序）存储在磁盘上的。当数据量巨大时，如果没有索引，每次查询都需要进行全表扫描（Full Table Scan），这意味着数据库需要读取磁盘上的每一行数据并进行比较，效率极低。 索引通过创建一种特殊的数据结构，可以快速定位到数据记录的位置，从而显著减少磁盘 I&#x2F;O 次数，提高查询速度。 二、各种树结构简述与对比在深入 B+树之前，我们先回顾一下几种常见的树形数据结构，了解它们的优缺点...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%99%9A%E6%8B%9F-DOM-Virtual-DOM-%E5%86%8D%E6%8E%A2"><span class="toc-text">一、虚拟 DOM (Virtual DOM) 再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-DOM%EF%BC%9F"><span class="toc-text">1.1 什么是虚拟 DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM%EF%BC%9F"><span class="toc-text">1.2 为什么需要虚拟 DOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%99%9A%E6%8B%9F-DOM-%E5%88%B0%E7%9C%9F%E5%AE%9E-DOM-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">1.3 虚拟 DOM 到真实 DOM 的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Vue-%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">二、Vue 补丁机制核心函数解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-patch-oldVnode-newVnode-%EF%BC%9A%E5%B7%AE%E5%BC%82%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-text">2.1 patch(oldVnode, newVnode)：差异发现与更新的入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-patchVnode-oldVnode-newVnode-%EF%BC%9A%E5%90%8C%E7%B1%BB%E8%8A%82%E7%82%B9%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%AF%94%E5%AF%B9%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">2.2 patchVnode(oldVnode, newVnode)：同类节点的深度比对与更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-updateChildren-oldChildren-newChildren-%EF%BC%9A%E5%AD%90%E8%8A%82%E7%82%B9%E5%88%97%E8%A1%A8%E7%9A%84-Diff-%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83"><span class="toc-text">2.3 updateChildren(oldChildren, newChildren)：子节点列表的 Diff 算法核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-key-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%B3%E5%AE%9A%E6%80%A7%E4%BD%9C%E7%94%A8"><span class="toc-text">2.4 key 属性的决定性作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">三、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2详解：在Windows运行Linux的新标准"/></a><div class="content"><a class="title" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准">WSL2详解：在Windows运行Linux的新标准</a><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GoLang Wails 框架详解：用 Web 技术构建桌面应用"/></a><div class="content"><a class="title" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用">GoLang Wails 框架详解：用 Web 技术构建桌面应用</a><time datetime="2025-09-17T22:24:00.000Z" title="发表于 2025-09-18 06:24:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"/></a><div class="content"><a class="title" href="/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化">Redis持久化深度解析：RDB与AOF的终极对决与实战优化</a><time datetime="2025-09-13T22:24:00.000Z" title="发表于 2025-09-14 06:24:00">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-05_Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title="Go 语言协程设计与调度原理"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 语言协程设计与调度原理"/></a><div class="content"><a class="title" href="/2025/2025-09-05_Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title="Go 语言协程设计与调度原理">Go 语言协程设计与调度原理</a><time datetime="2025-09-04T22:24:00.000Z" title="发表于 2025-09-05 06:24:00">2025-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"/></a><div class="content"><a class="title" href="/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用">Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用</a><time datetime="2025-09-03T22:24:00.000Z" title="发表于 2025-09-04 06:24:00">2025-09-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-25.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2022 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>