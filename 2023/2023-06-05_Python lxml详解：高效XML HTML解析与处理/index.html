<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python lxml详解：高效XML/HTML解析与处理 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="lxml 是 Python 的一个强大且功能丰富的库，用于解析和处理 XML 和 HTML 文档。它结合了 C 语言库 libxml2 和 libxslt 的速度和功能，以及 Python 的简洁和灵活性。lxml 提供了多种解析方式（如 ElementTree API 和 SAX），并支持强大的 XPath 和 CSS 选择器进行数据提取。在高性能要求的场景下，lxml 往往是处理大型 XML">
<meta property="og:type" content="article">
<meta property="og:title" content="Python lxml详解：高效XML&#x2F;HTML解析与处理">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2023/2023-06-05_Python%20lxml%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88XML%20HTML%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="lxml 是 Python 的一个强大且功能丰富的库，用于解析和处理 XML 和 HTML 文档。它结合了 C 语言库 libxml2 和 libxslt 的速度和功能，以及 Python 的简洁和灵活性。lxml 提供了多种解析方式（如 ElementTree API 和 SAX），并支持强大的 XPath 和 CSS 选择器进行数据提取。在高性能要求的场景下，lxml 往往是处理大型 XML">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg">
<meta property="article:published_time" content="2023-06-04T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-29T09:53:34.720Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="lxml">
<meta property="article:tag" content="网络爬虫">
<meta property="article:tag" content="XML">
<meta property="article:tag" content="XPath">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python lxml详解：高效XML/HTML解析与处理",
  "url": "https://blog.tbf1211.xx.kg/2023/2023-06-05_Python%20lxml%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88XML%20HTML%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg",
  "datePublished": "2023-06-04T22:24:00.000Z",
  "dateModified": "2025-10-29T09:53:34.720Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2023/2023-06-05_Python%20lxml%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88XML%20HTML%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python lxml详解：高效XML/HTML解析与处理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">185</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">168</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python lxml详解：高效XML/HTML解析与处理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python lxml详解：高效XML/HTML解析与处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-04T22:24:00.000Z" title="发表于 2023-06-05 06:24:00">2023-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E5%BA%93/">库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2023/2023-06-05_Python%20lxml%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88XML%20HTML%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>lxml</strong> 是 Python 的一个强大且功能丰富的库，用于解析和处理 XML 和 HTML 文档。它结合了 C 语言库 <code>libxml2</code> 和 <code>libxslt</code> 的速度和功能，以及 Python 的简洁和灵活性。lxml 提供了多种解析方式（如 ElementTree API 和 SAX），并支持强大的 XPath 和 CSS 选择器进行数据提取。在高性能要求的场景下，lxml 往往是处理大型 XML&#x2F;HTML 文档的首选。</p>
</blockquote>
<div class="note info flat"><p>核心思想：lxml 利用底层的 C 库，提供了比纯 Python 解析器快得多的性能，同时通过 Pythonic 的接口，使得 XML&#x2F;HTML 的解析、导航和数据提取变得高效而直观。</p>
</div>
<hr>
<h2 id="一、为什么选择-lxml？"><a href="#一、为什么选择-lxml？" class="headerlink" title="一、为什么选择 lxml？"></a>一、为什么选择 lxml？</h2><p>在 Python 处理 XML&#x2F;HTML 文档时，我们有多种选择，例如 Python 标准库中的 <code>xml.etree.ElementTree</code>、<code>minidom</code>，以及 <code>Beautiful Soup</code>。然而，lxml 在性能和功能上提供了独特的优势：</p>
<ol>
<li><strong>极高的性能</strong>：由于其核心解析引擎是用 C 语言实现的 <code>libxml2</code> 和 <code>libxslt</code>，lxml 在处理大型文档时比纯 Python 解析器（如 <code>html.parser</code> 或 <code>ElementTree</code>）快得多，尤其是在内存使用方面也更高效。</li>
<li><strong>功能全面</strong>：<ul>
<li><strong>支持 XPath</strong>：提供强大而灵活的 XPath 表达式，用于在文档中精确查找元素。</li>
<li><strong>支持 CSS Selector</strong>：通过 <code>lxml.cssselect</code> 模块提供熟悉的 CSS 选择器语法。</li>
<li><strong>XML Schema&#x2F;DTD 验证</strong>：支持对 XML 文档进行结构验证。</li>
<li><strong>XSLT 转换</strong>：实现 XML 文档的转换。</li>
<li><strong>XML 片段解析</strong>：能解析不完整的 XML&#x2F;HTML 片段。</li>
</ul>
</li>
<li><strong>容错性好</strong>：在解析 HTML 文档时，lxml 表现出与浏览器类似的容错性，能够处理不规范的 HTML 标签结构。</li>
<li><strong>Pythonic API</strong>：虽然底层是 C 库，但 lxml 提供了非常 Pythonic 和直观的 API，易于学习和使用。</li>
<li><strong>与 Beautiful Soup 结合</strong>：Beautiful Soup 可以使用 lxml 作为其底层解析器 (<code>BeautifulSoup(html_content, &#39;lxml&#39;)</code>)，以兼顾 Beautiful Soup 的易用性和 lxml 的解析速度。</li>
</ol>
<h2 id="二、安装-lxml"><a href="#二、安装-lxml" class="headerlink" title="二、安装 lxml"></a>二、安装 lxml</h2><p>lxml 可以通过 <code>pip</code> 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure>

<h2 id="三、基本使用：解析-XML-HTML-文档"><a href="#三、基本使用：解析-XML-HTML-文档" class="headerlink" title="三、基本使用：解析 XML&#x2F;HTML 文档"></a>三、基本使用：解析 XML&#x2F;HTML 文档</h2><p>lxml 提供了 <strong><code>etree</code></strong> 模块，它是其核心，用于 Tree API 相关操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree, html</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 解析 XML 字符串</span></span><br><span class="line">xml_string = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;root&gt;</span></span><br><span class="line"><span class="string">    &lt;country name=&quot;Liechtenstein&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;rank&gt;1&lt;/rank&gt;</span></span><br><span class="line"><span class="string">        &lt;year&gt;2008&lt;/year&gt;</span></span><br><span class="line"><span class="string">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span></span><br><span class="line"><span class="string">        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/country&gt;</span></span><br><span class="line"><span class="string">    &lt;country name=&quot;Singapore&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;rank&gt;4&lt;/rank&gt;</span></span><br><span class="line"><span class="string">        &lt;year&gt;2011&lt;/year&gt;</span></span><br><span class="line"><span class="string">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span></span><br><span class="line"><span class="string">        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/country&gt;</span></span><br><span class="line"><span class="string">&lt;/root&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 fromstring 解析 XML 字符串</span></span><br><span class="line">xml_root = etree.fromstring(xml_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 解析 XML 字符串 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;根元素标签: <span class="subst">&#123;xml_root.tag&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个国家名称: <span class="subst">&#123;xml_root.find(<span class="string">&#x27;country&#x27;</span>).get(<span class="string">&#x27;name&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析 HTML 字符串</span></span><br><span class="line">html_string = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;My Awesome Page&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Welcome&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;ul id=&quot;menu&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/products&quot;&gt;Products&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About Us&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;This is a paragraph with some &lt;b class=&quot;highlight&quot;&gt;bold text&lt;/b&gt;.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;Another paragraph.&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- This is a comment --&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 html.fromstring 解析 HTML 字符串</span></span><br><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 解析 HTML 字符串 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;HTML 根元素标签: <span class="subst">&#123;html_root.tag&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;页面标题: <span class="subst">&#123;html_root.xpath(<span class="string">&#x27;//title/text()&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>) <span class="comment"># 使用 XPath 提取标题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 从文件或 URL 加载 (推荐使用 requests 获取内容再解析)</span></span><br><span class="line"><span class="comment"># 以加载 example.com 为例</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&quot;http://www.example.com&quot;</span>)</span><br><span class="line">    response.raise_for_status() <span class="comment"># 检查请求是否成功</span></span><br><span class="line">    remote_html_root = html.fromstring(response.text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 解析 www.example.com ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;远程页面标题: <span class="subst">&#123;remote_html_root.xpath(<span class="string">&#x27;//title/text()&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n无法访问 www.example.com: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># etree.parse() 可以直接从文件路径或文件对象加载</span></span><br><span class="line"><span class="comment"># tree = etree.parse(&#x27;my_document.xml&#x27;)</span></span><br><span class="line"><span class="comment"># root = tree.getroot()</span></span><br></pre></td></tr></table></figure>

<h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li><strong><code>etree.fromstring()</code></strong>: 用于从<strong>字符串</strong>解析 XML。</li>
<li><strong><code>html.fromstring()</code></strong>: 用于从<strong>字符串</strong>解析 HTML。它会自动处理 HTML 的容错性。</li>
<li><strong><code>etree.parse()</code></strong>: 用于从<strong>文件路径或文件对象</strong>解析 XML&#x2F;HTML 文件。</li>
</ul>
<p>一旦文档被解析，它就变成了一个 <code>Element</code> 对象（通常是根元素），你可以像操作树一样遍历和查询它。</p>
<h2 id="四、导航文档树"><a href="#四、导航文档树" class="headerlink" title="四、导航文档树"></a>四、导航文档树</h2><p>lxml 的元素对象提供了多种属性和方法来导航文档树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新解析 HTML 文档</span></span><br><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 子元素 (children)</span></span><br><span class="line"><span class="comment"># 获取 body 标签</span></span><br><span class="line">body = html_root.find(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 导航子元素 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;body 的子元素标签:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> body:</span><br><span class="line">    <span class="comment"># 过滤掉非 Element 类型的子节点（如 NavigableString 或 Comment），这些默认会被忽略</span></span><br><span class="line">    <span class="comment"># 如果要包含文本节点，需要特定处理，后面会提到</span></span><br><span class="line">    <span class="built_in">print</span>(child.tag)</span><br><span class="line"><span class="comment"># h1</span></span><br><span class="line"><span class="comment"># ul</span></span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># div</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 父元素 (parent)</span></span><br><span class="line">first_li = html_root.find(<span class="string">&#x27;.//li&#x27;</span>) <span class="comment"># 找到第一个 li</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n--- 导航父元素 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个 li 的父级是: <span class="subst">&#123;first_li.getparent().tag&#125;</span>&quot;</span>) <span class="comment"># ul</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 兄弟元素 (siblings)</span></span><br><span class="line">first_li = html_root.xpath(<span class="string">&quot;//li&quot;</span>)[<span class="number">0</span>] <span class="comment"># 获取第一个 li 标签</span></span><br><span class="line">next_li = first_li.getnext()</span><br><span class="line">prev_li = next_li.getprevious()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 导航兄弟元素 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个 li: <span class="subst">&#123;first_li.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个 li 的下一个兄弟: <span class="subst">&#123;next_li.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第二个 li 的上一个兄弟: <span class="subst">&#123;prev_li.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：lxml 的 .text 属性只会获取当前标签的直接文本内容，不包括子标签的文本。</span></span><br><span class="line"><span class="comment"># 如果标签内部有文本和子标签，.text 只获取标签开头到第一个子标签之间的文本。</span></span><br><span class="line"><span class="comment"># 例如 &lt;p&gt;Hello &lt;b&gt;World&lt;/b&gt;!&lt;/p&gt;，p.text 得到 &#x27;Hello &#x27;</span></span><br><span class="line">p_tag = html_root.xpath(<span class="string">&quot;//p&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nP 标签的文本内容: <span class="subst">&#123;p_tag.text&#125;</span>&quot;</span>) <span class="comment"># &#x27;This is a paragraph with some &#x27;</span></span><br><span class="line"></span><br><span class="line">bold_tag = p_tag.find(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Bold 标签的文本内容: <span class="subst">&#123;bold_tag.text&#125;</span>&quot;</span>) <span class="comment"># &#x27;bold text&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有文本内容（包括子标签的）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P 标签及其子标签的完整文本内容: <span class="subst">&#123;<span class="string">&#x27;&#x27;</span>.join(p_tag.xpath(<span class="string">&#x27;.//text()&#x27;</span>))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="五、搜索文档树：XPath-和-CSS-Selector"><a href="#五、搜索文档树：XPath-和-CSS-Selector" class="headerlink" title="五、搜索文档树：XPath 和 CSS Selector"></a>五、搜索文档树：XPath 和 CSS Selector</h2><p>lxml 最强大的功能之一是使用 XPath 和 CSS 选择器进行数据提取。</p>
<h3 id="5-1-XPath-XML-Path-Language"><a href="#5-1-XPath-XML-Path-Language" class="headerlink" title="5.1 XPath (XML Path Language)"></a>5.1 XPath (XML Path Language)</h3><p>XPath 是一种在 XML 文档中查找信息的语言。lxml 完全支持 XPath 1.0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- XPath 搜索 ---&quot;</span>)</span><br><span class="line"><span class="comment"># 1. 查找所有 &lt;a&gt; 标签</span></span><br><span class="line">all_a = html_root.xpath(<span class="string">&#x27;//a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;所有 &lt;a&gt; 标签数量: <span class="subst">&#123;<span class="built_in">len</span>(all_a)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> all_a:</span><br><span class="line">    <span class="built_in">print</span>(a.get(<span class="string">&#x27;href&#x27;</span>), a.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查找 id=&quot;menu&quot; 的 ul 标签下的所有 li 标签</span></span><br><span class="line">menu_items = html_root.xpath(<span class="string">&#x27;//ul[@id=&quot;menu&quot;]/li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n菜单项数量: <span class="subst">&#123;<span class="built_in">len</span>(menu_items)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> menu_items:</span><br><span class="line">    <span class="built_in">print</span>(li.text.strip(), li.find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>)) <span class="comment"># li.text 可能会包含换行符和空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查找 class=&quot;active&quot; 的 li 标签</span></span><br><span class="line">active_item = html_root.xpath(<span class="string">&#x27;//li[@class=&quot;active&quot;]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n活跃菜单项: <span class="subst">&#123;active_item[<span class="number">0</span>].find(<span class="string">&#x27;a&#x27;</span>).text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 获取所有文本内容</span></span><br><span class="line">all_text = html_root.xpath(<span class="string">&#x27;//body//text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nBody 内所有文本内容:&quot;</span>)</span><br><span class="line"><span class="comment"># print(&#x27;&#x27;.join(all_text)) # 可能会包含多余的换行和空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 带相对路径的 XPath</span></span><br><span class="line">some_p = html_root.xpath(<span class="string">&quot;//p&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">bold_in_p = some_p.xpath(<span class="string">&#x27;.//b&#x27;</span>)[<span class="number">0</span>] <span class="comment"># 在 p 标签的子节点中查找 b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nP 标签内的粗体文本: <span class="subst">&#123;bold_in_p.text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>常用 XPath 表达式：</strong></p>
<ul>
<li><code>//tagname</code>: 查找文档中所有指定标签名的元素。</li>
<li><code>/root/child</code>: 查找根元素下的直接子元素。</li>
<li><code>//tagname[@attribute=&quot;value&quot;]</code>: 查找具有特定属性值的标签。</li>
<li><code>//tagname[condition]</code>: 查找满足条件的标签。</li>
<li><code>//tagname[position()]</code>: 根据位置查找（如 <code>[1]</code> 第一个，<code>[last()]</code> 最后一个）。</li>
<li><code>//tagname/text()</code>: 提取标签内的直接文本内容。</li>
<li><code>//tagname/@attribute</code>: 提取标签的属性值。</li>
<li><code>.</code>: 当前节点。</li>
<li><code>..</code>: 父节点。</li>
</ul>
<h3 id="5-2-CSS-Selector"><a href="#5-2-CSS-Selector" class="headerlink" title="5.2 CSS Selector"></a>5.2 CSS Selector</h3><p>lxml 通过 <code>lxml.cssselect</code> 模块支持 CSS 选择器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.cssselect <span class="keyword">import</span> CSSSelector</span><br><span class="line"></span><br><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- CSS Selector 搜索 ---&quot;</span>)</span><br><span class="line"><span class="comment"># 1. 查找所有 li 标签</span></span><br><span class="line">sel_li = CSSSelector(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">all_li = sel_li(html_root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;所有 li 标签数量 (CSS): <span class="subst">&#123;<span class="built_in">len</span>(all_li)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查找 id 为 menu 的 ul 标签下的直接子 li 标签</span></span><br><span class="line">sel_menu_li = CSSSelector(<span class="string">&#x27;ul#menu &gt; li&#x27;</span>)</span><br><span class="line">menu_items_css = sel_menu_li(html_root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n菜单项数量 (CSS): <span class="subst">&#123;<span class="built_in">len</span>(menu_items_css)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> menu_items_css:</span><br><span class="line">    <span class="built_in">print</span>(li.find(<span class="string">&#x27;a&#x27;</span>).text, li.find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查找 class 为 highlight 的 b 标签</span></span><br><span class="line">sel_bold = CSSSelector(<span class="string">&#x27;b.highlight&#x27;</span>)</span><br><span class="line">bold_text = sel_bold(html_root)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n高亮粗体文本 (CSS): <span class="subst">&#123;bold_text.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接在 Element 对象上使用 .cssselect()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n使用 Element.cssselect() 查找 P 标签下的 b 标签: <span class="subst">&#123;html_root.cssselect(<span class="string">&#x27;p b&#x27;</span>)[<span class="number">0</span>].text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>常用 CSS Selector 表达式：</strong></p>
<ul>
<li><code>tagname</code>: 匹配所有指定标签名的元素。</li>
<li><code>.classname</code>: 匹配所有具有指定 class 的元素。</li>
<li><code>#id</code>: 匹配指定 id 的元素。</li>
<li><code>tagname.classname</code>: 匹配同时具有标签名和 class 的元素。</li>
<li><code>tagname#id</code>: 匹配同时具有标签名和 id 的元素。</li>
<li><code>element[attribute=&quot;value&quot;]</code>: 匹配具有特定属性值的元素。</li>
<li><code>parent &gt; child</code>: 匹配作为 <code>parent</code> 直接子元素的 <code>child</code>。</li>
<li><code>ancestor descendant</code>: 匹配作为 <code>ancestor</code> 子孙元素的 <code>descendant</code>。</li>
<li><code>element:nth-child(n)</code>: 匹配第 n 个子元素。</li>
</ul>
<h2 id="六、修改文档树"><a href="#六、修改文档树" class="headerlink" title="六、修改文档树"></a>六、修改文档树</h2><p>lxml 也允许修改文档树，例如添加、删除或修改元素和属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 添加属性</span></span><br><span class="line">h1_tag = html_root.find(<span class="string">&#x27;body/h1&#x27;</span>)</span><br><span class="line">h1_tag.<span class="built_in">set</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;main-title&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n添加 ID 属性后的 h1 标签: <span class="subst">&#123;h1_tag.xpath(<span class="string">&#x27;@id&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>) <span class="comment"># main-title</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 修改文本</span></span><br><span class="line">first_a = html_root.xpath(<span class="string">&#x27;//ul//a&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">first_a.text = <span class="string">&quot;Homepage&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n修改文本后的第一个链接: <span class="subst">&#123;first_a.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加子元素</span></span><br><span class="line">new_li = etree.Element(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">new_a = etree.SubElement(new_li, <span class="string">&#x27;a&#x27;</span>, href=<span class="string">&quot;/contact&quot;</span>)</span><br><span class="line">new_a.text = <span class="string">&quot;Contact&quot;</span></span><br><span class="line">menu_ul = html_root.find(<span class="string">&#x27;.//ul&#x27;</span>)</span><br><span class="line">menu_ul.append(new_li)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n添加新菜单项后的 UL 标签 (部分):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> menu_ul:</span><br><span class="line">    <span class="built_in">print</span>(item.text.strip(), item.find(<span class="string">&#x27;a&#x27;</span>).text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除元素</span></span><br><span class="line">p_to_remove = html_root.xpath(<span class="string">&quot;//p&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">p_to_remove.getparent().remove(p_to_remove) <span class="comment"># 从父节点移除</span></span><br><span class="line"><span class="comment"># 此时文档中的第一个 &lt;p&gt; 标签已被删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 序列化回字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 修改后的 HTML (prettify) ---&quot;</span>)</span><br><span class="line"><span class="comment"># etree.tostring 可以将 Element 对象序列化为字节串</span></span><br><span class="line"><span class="comment"># etree.tostring(html_root, pretty_print=True).decode()</span></span><br><span class="line"><span class="comment"># html.tostring 更适用于 HTML 文档的序列化</span></span><br><span class="line"><span class="built_in">print</span>(html.tostring(html_root, pretty_print=<span class="literal">True</span>, encoding=<span class="string">&#x27;unicode&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="七、性能与内存考虑"><a href="#七、性能与内存考虑" class="headerlink" title="七、性能与内存考虑"></a>七、性能与内存考虑</h2><p>lxml 的核心优势在于性能，尤其是在处理大型文件时。</p>
<ul>
<li><strong>高效解析</strong>：由于 C 语言底层实现，解析速度快，内存占用低。</li>
<li><strong>SAX 解析</strong>：对于超大型 XML 文件（GB 级别），如果无法一次性加载到内存中，可以使用 lxml 提供的 SAX（Simple API for XML）解析器进行事件驱动解析，逐块处理数据而无需构建整个 DOM 树。</li>
<li><strong>增量解析</strong>：lxml 还支持增量解析，在接收到部分数据时即可开始解析。</li>
</ul>
<h2 id="八、lxml-vs-Beautiful-Soup"><a href="#八、lxml-vs-Beautiful-Soup" class="headerlink" title="八、lxml vs Beautiful Soup"></a>八、lxml vs Beautiful Soup</h2><p>Lxml 和 Beautiful Soup 各有优势，通常在项目选择时需要权衡：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">lxml</th>
<th align="left">Beautiful Soup</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>极佳</strong> (C 语言底层)</td>
<td align="left">相对较慢 (纯 Python)</td>
</tr>
<tr>
<td align="left"><strong>容错性</strong></td>
<td align="left">很好 (对于 HTML 解析)</td>
<td align="left"><strong>极佳</strong> (专为不规范 HTML 设计)</td>
</tr>
<tr>
<td align="left"><strong>API</strong></td>
<td align="left">更偏向标准 XML&#x2F;HTML API (<mark>XPath, CSS选择器</mark>)</td>
<td align="left">更 Pythonic，易用性强 (<code>.</code>, <code>.find_all()</code>)</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">需要 C 库 <code>libxml2</code>, <code>libxslt</code></td>
<td align="left">纯 Python 实现，无需外部依赖</td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left"><strong>全面</strong> (XPath, XSLT, Schema 验证)</td>
<td align="left">侧重数据提取</td>
</tr>
<tr>
<td align="left"><strong>上手难度</strong></td>
<td align="left">XPath&#x2F;CSS 选择器语法有一定学习成本</td>
<td align="left">API 直观，快速上手</td>
</tr>
<tr>
<td align="left"><strong>典型使用</strong></td>
<td align="left">高性能爬虫、XML 处理、Web API 响应解析</td>
<td align="left">数据清洗、原型开发、非结构化网页解析</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>：<br>很多情况下，可以<strong>结合使用</strong>两者。Beautiful Soup 可以将 lxml 作为其后端解析器，既享受到 lxml 的高性能，又利用 Beautiful Soup 更友好的 API。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree <span class="comment"># 只需要 lxml 安装，BeautifulSoup 自动使用</span></span><br><span class="line"></span><br><span class="line">html_doc = <span class="string">&quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;</span></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;lxml&#x27;</span>) <span class="comment"># 指定使用 lxml 解析器</span></span><br><span class="line"><span class="built_in">print</span>(soup.title.string) <span class="comment"># 使用 Beautiful Soup 的 API</span></span><br></pre></td></tr></table></figure>

<h2 id="九、总结与进阶"><a href="#九、总结与进阶" class="headerlink" title="九、总结与进阶"></a>九、总结与进阶</h2><p>lxml 是 Python 数据抓取和 XML&#x2F;HTML 处理领域不可小觑的利器。它的卓越性能和强大的 XPath&#x2F;CSS 选择器支持，使其成为处理大型复杂文档的高效解决方案。</p>
<p><strong>进阶方向：</strong></p>
<ul>
<li><strong>XSLT 转换</strong>：学习如何使用 <code>lxml.etree.XSLT</code> 进行 XML 文档转换。</li>
<li><strong>XML Schema&#x2F;DTD 验证</strong>：利用 lxml 进行 XML 文档的结构验证。</li>
<li><strong>命名空间处理</strong>：在处理包含 XML 命名空间的文档时，正确使用 XPath 表达式。</li>
<li><strong>错误处理</strong>：学习如何处理解析过程中可能出现的各种错误。</li>
<li><strong>与 Web 框架集成</strong>：在 Flask、Django 等 Web 框架中处理 XML&#x2F;HTML 输入输出。</li>
<li><strong>异步抓取与 lxml</strong>：结合 <code>httpx</code> 或 <code>aiohttp</code> 进行异步网页抓取和解析。</li>
</ul>
<p>掌握 lxml，你将能够更高效、更精准地从各种结构化和半结构化文档中提取所需信息，为复杂的数据处理任务奠定坚实基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2023/2023-06-05_Python%20lxml%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88XML%20HTML%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86/">https://blog.tbf1211.xx.kg/2023/2023-06-05_Python%20lxml%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88XML%20HTML%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%A4%84%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/lxml/">lxml</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/">网络爬虫</a><a class="post-meta__tags" href="/tags/XML/">XML</a><a class="post-meta__tags" href="/tags/XPath/">XPath</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/2023-06-09_Python%20Beautiful%20Soup%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E5%88%A9%E5%99%A8/" title="Python Beautiful Soup详解：高效网页数据抓取与解析利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python Beautiful Soup详解：高效网页数据抓取与解析利器</div></div><div class="info-2"><div class="info-item-1"> Beautiful Soup 是一个 Python 库，用于从 HTML 或 XML 文件中提取数据。它通过解析文档并提供用于导航、搜索和修改解析树的 Pythonic 接口，将复杂的 HTML&#x2F;XML 文档转化为易于处理的数据结构。Beautiful Soup 与 requests 等 HTTP 库结合使用，是构建网络爬虫进行数据抓取的强大工具。  核心思想：Beautiful Soup 将杂乱的 HTML&#x2F;XML 文档“煲成一锅美味的汤”，让你能够轻松地在其中挑选出你需要的数据元素，如同在厨房里筛选食材一样简单。   一、为什么需要 Beautiful Soup？在网络上，大量有价值的信息以 HTML 页面的形式存在。如果我们需要从这些页面中获取结构化数据（例如，产品信息、新闻标题、评论内容），直接操作原始的 HTML 字符串是非常困难和脆弱的。传统的字符串查找和正则表达式虽然可行，但存在以下问题：  HTML 结构复杂：HTML 标签嵌套层级深，结构不规则，使用正则表达式难以精确匹配。 HTML 容错性：浏览器会自动纠正不规范的 HTML 结构，但正则...</div></div></div></a><a class="pagination-related" href="/2023/2023-06-01_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL EXPLAIN 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySQL EXPLAIN 详解</div></div><div class="info-2"><div class="info-item-1"> EXPLAIN 是 MySQL 提供的一个非常强大的工具，用于分析 SELECT 语句的执行计划。通过 EXPLAIN 的输出结果，我们可以了解查询是如何执行的，包括使用了哪些索引、扫描了多少行、是否进行了文件排序等信息。这是数据库性能调优不可或缺的一环，能够帮助我们发现 SQL 语句中的性能瓶颈并进行优化。  “优化前，先 EXPLAIN。没有 EXPLAIN 的优化都是盲人摸象。” - 数据库优化格言   一、什么是 EXPLAIN？EXPLAIN 命令实际上是用来获取 MySQL 执行查询语句的执行计划的。执行计划描述了 MySQL 如何处理 SQL 语句，包括：  表的连接顺序 每个表使用的索引 是否使用了临时表 是否进行了文件排序 扫描的行数预估  通过分析这些信息，我们可以判断查询是否高效，是否可以进一步优化。 二、如何使用 EXPLAIN？使用 EXPLAIN 非常简单，只需将 EXPLAIN 关键字放在任何 SELECT 语句的前面。 1234EXPLAIN SELECT * FROM users WHERE username = &#x27;Alice&#x2...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-06-09_Python%20Beautiful%20Soup%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%95%88%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%8A%93%E5%8F%96%E4%B8%8E%E8%A7%A3%E6%9E%90%E5%88%A9%E5%99%A8/" title="Python Beautiful Soup详解：高效网页数据抓取与解析利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-09</div><div class="info-item-2">Python Beautiful Soup详解：高效网页数据抓取与解析利器</div></div><div class="info-2"><div class="info-item-1"> Beautiful Soup 是一个 Python 库，用于从 HTML 或 XML 文件中提取数据。它通过解析文档并提供用于导航、搜索和修改解析树的 Pythonic 接口，将复杂的 HTML&#x2F;XML 文档转化为易于处理的数据结构。Beautiful Soup 与 requests 等 HTTP 库结合使用，是构建网络爬虫进行数据抓取的强大工具。  核心思想：Beautiful Soup 将杂乱的 HTML&#x2F;XML 文档“煲成一锅美味的汤”，让你能够轻松地在其中挑选出你需要的数据元素，如同在厨房里筛选食材一样简单。   一、为什么需要 Beautiful Soup？在网络上，大量有价值的信息以 HTML 页面的形式存在。如果我们需要从这些页面中获取结构化数据（例如，产品信息、新闻标题、评论内容），直接操作原始的 HTML 字符串是非常困难和脆弱的。传统的字符串查找和正则表达式虽然可行，但存在以下问题：  HTML 结构复杂：HTML 标签嵌套层级深，结构不规则，使用正则表达式难以精确匹配。 HTML 容错性：浏览器会自动纠正不规范的 HTML 结构，但正则...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Python元类(Metaclass)深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="info-item-2">Python元类(Metaclass)深度解析</div></div><div class="info-2"><div class="info-item-1">Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，它允许我们在类被创建时对其行为进行定制，是 Python 中进行高级面向对象编程的强大工具。 1. 什么是元类？在 Python 中，当你定义一个类 class MyClass: pass 的时候，Python 解释器会自动执行以下步骤：  定义一个类对象：解释器读取 MyClass 的定义，并创建一个名为 MyClass 的类对象。 将类对象绑定到命名空间：这个 MyClass 类对象被绑定到当前的命名空间中。  然后，当你通过 my_instance = MyClass() 来创建实例时，MyClass 这个类对象就会被调用，从而创建并返回一个实例对象。 元类就是用来创建这些类对象的...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-15_Python%20NumPy%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%9A%84%E5%9F%BA%E7%9F%B3/" title="Python NumPy详解：科学计算的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="info-item-2">Python NumPy详解：科学计算的基石</div></div><div class="info-2"><div class="info-item-1"> NumPy (Numerical Python) 是 Python 中用于科学计算的核心库。它提供了一个高性能的多维数组对象 ndarray，以及用于处理这些数组的工具。NumPy 是 Python 数据科学和机器学习生态系统的基石，许多其他库（如 SciPy, Pandas, Matplotlib, Scikit-learn）都建立在 NumPy 数组之上。  核心思想：NumPy 引入了高效的 ndarray 数据结构，通过向量化操作显著提升了 Python 处理数值数据的性能。   一、为什么选择 NumPy？Python 语言本身处理列表等数据结构时效率较高，但对于大规模数值计算而言，原生的 Python 列表效率低下。NumPy 通过以下方式解决了这个问题：  高性能 ndarray 对象：ndarray 存储同类型数据，在内存中连续存储，相比 Python 列表，占用的内存更少，访问速度更快。 向量化操作：NumPy 允许对整个数组进行操作，而无需编写显式的循环。这些操作通常在 C 或 Fortran 中实现，执行速度远超 Python 循环。 广播 (Broadc...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-17_Pug(%E5%89%8DJade)%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/" title="Pug(前Jade)模板引擎详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="info-item-2">Pug(前Jade)模板引擎详解</div></div><div class="info-2"><div class="info-item-1"> Pug（发音 &#x2F;pʌɡ&#x2F;），前身为 Jade，是一个高性能的 Node.js 模板引擎。它以其简洁、富有表现力的语法而闻名，旨在让 HTML 编写变得更加高效和愉快。Pug 摒弃了传统 HTML 的尖括号和闭合标签，转而使用缩进和基于文本的语法，这使得模板文件更小、更易读、也更不易出错。  核心思想：Pug 通过简洁的缩进语法替代冗长的 HTML 标签，提供强大的动态数据渲染、代码重用和条件逻辑功能。   一、Pug 简介1.1 什么是模板引擎？模板引擎是一种将数据填充到预定义模板中以生成最终输出（通常是 HTML 字符串）的工具。它将页面的结构（模板）与数据分离，使得前端开发更加模块化和可维护。 1.2 Pug 的特点 独特语法：使用缩进表示嵌套关系，无需关闭标签。 简洁明了：代码量显著少于对应的 HTML。 强大功能：支持变量、循环、条件判断、Mixin（类似于函数或组件）、包含（文件复用）、布局继承等高级特性。 编译到 HTML：Pug 模板最终会被编译成标准的 HTML。 Node.js 支持：作为 Node.js 的模板引擎，Pug 完美集成于 E...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-21_Python%20Pandas%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80/" title="Python Pandas详解：数据处理与分析的瑞士军刀"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="info-item-2">Python Pandas详解：数据处理与分析的瑞士军刀</div></div><div class="info-2"><div class="info-item-1"> Pandas 是 Python 中用于数据分析和处理的核心库。它提供了一套高性能、易于使用的数据结构，最主要的是 DataFrame（二维表格数据）和 Series（一维带标签数组），用于快速处理和分析结构化数据（如 CSV、Excel、数据库表格数据）。Pandas 以其直观的语法和强大的功能，成为数据科学家和数据工程师的首选工具。  核心思想：Pandas 将表格数据抽象为 DataFrame 和 Series 对象，提供类似 SQL 和 Excel 的操作，通过向量化和 C&#x2F;Cython 实现的底层优化，极大提升了数据处理效率。   一、为什么选择 Pandas？在数据驱动的时代，我们经常需要处理各种形式的表格数据。Python 原生的数据结构（如列表、字典）虽然灵活，但在处理大量、复杂、异构的表格数据时显得力不从心。Pandas 解决了这些痛点：  直观的数据结构：DataFrame 和 Series 提供了强大的标签索引功能，使得数据操作更加直观，无需关注底层实现。 高效的数据操作：底层基于 NumPy 优化，利用 C 和 Cython 实现，对于大规模数据...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-28_Python%20Requests%E5%BA%93%E8%AF%A6%E8%A7%A3%EF%BC%9AHTTP%E8%AF%B7%E6%B1%82%E7%9A%84%E8%89%BA%E6%9C%AF/" title="Python Requests库详解：HTTP请求的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="info-item-2">Python Requests库详解：HTTP请求的艺术</div></div><div class="info-2"><div class="info-item-1"> requests 库 是 Python 生态系统中最流行、最强大、也是最优雅的 HTTP 客户端库之一。它简化了复杂的 HTTP 请求操作，让开发者能够以极少量的代码发送各种类型的 HTTP 请求，并轻松处理响应。与 Python 内置的 urllib 模块相比，requests 提供了更友好、更直观的 API，被誉为“面向人类的 HTTP 服务”。  核心思想：requests 封装了底层 HTTP 协议的复杂性，提供简洁的 API，让开发者专注于业务逻辑而非网络通信的细节。   一、为什么选择 Requests？在 Python 中进行 HTTP 请求有多种方式，例如内置的 urllib 模块。但 requests 库之所以广受欢迎，主要得益于以下优势：  友好的 API：设计直观，易学易用，代码可读性高。 功能强大：支持几乎所有 HTTP 功能，包括 GET, POST, PUT, DELETE 等方法，以及请求头、数据、文件上传、Cookie、身份认证、代理、SSL 验证等。 自动处理：自动处理 URL 编码、重定向、会话管理等常见任务。 JSON 支持：内置 JSON...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">185</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">168</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-lxml%EF%BC%9F"><span class="toc-text">一、为什么选择 lxml？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85-lxml"><span class="toc-text">二、安装 lxml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A%E8%A7%A3%E6%9E%90-XML-HTML-%E6%96%87%E6%A1%A3"><span class="toc-text">三、基本使用：解析 XML&#x2F;HTML 文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-text">关键点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AF%BC%E8%88%AA%E6%96%87%E6%A1%A3%E6%A0%91"><span class="toc-text">四、导航文档树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%90%9C%E7%B4%A2%E6%96%87%E6%A1%A3%E6%A0%91%EF%BC%9AXPath-%E5%92%8C-CSS-Selector"><span class="toc-text">五、搜索文档树：XPath 和 CSS Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-XPath-XML-Path-Language"><span class="toc-text">5.1 XPath (XML Path Language)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-CSS-Selector"><span class="toc-text">5.2 CSS Selector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3%E6%A0%91"><span class="toc-text">六、修改文档树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E5%86%85%E5%AD%98%E8%80%83%E8%99%91"><span class="toc-text">七、性能与内存考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81lxml-vs-Beautiful-Soup"><span class="toc-text">八、lxml vs Beautiful Soup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E8%BF%9B%E9%98%B6"><span class="toc-text">九、总结与进阶</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-02.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>