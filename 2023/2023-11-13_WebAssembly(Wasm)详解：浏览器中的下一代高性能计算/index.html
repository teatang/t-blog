<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WebAssembly(Wasm)详解：浏览器中的下一代高性能计算 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在 Web 浏览器中运行高性能代码的方式。它是一种可移植、大小紧凑、加载快、与 Web 生态系统兼容的技术，旨在作为 Web 的编译目标。简单来说，Wasm 允许你用 C&#x2F;C++, Rust, Go 等多种语言编写代码，然后编译成 Wasm 格式，并在浏览器中以接近原生性能的速度运行。  核心思想：WebAssem">
<meta property="og:type" content="article">
<meta property="og:title" content="WebAssembly(Wasm)详解：浏览器中的下一代高性能计算">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2023/2023-11-13_WebAssembly(Wasm)%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在 Web 浏览器中运行高性能代码的方式。它是一种可移植、大小紧凑、加载快、与 Web 生态系统兼容的技术，旨在作为 Web 的编译目标。简单来说，Wasm 允许你用 C&#x2F;C++, Rust, Go 等多种语言编写代码，然后编译成 Wasm 格式，并在浏览器中以接近原生性能的速度运行。  核心思想：WebAssem">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg">
<meta property="article:published_time" content="2023-11-12T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-17T05:52:50.169Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="WebAssembly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WebAssembly(Wasm)详解：浏览器中的下一代高性能计算",
  "url": "https://blog.tbf1211.xx.kg/2023/2023-11-13_WebAssembly(Wasm)%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg",
  "datePublished": "2023-11-12T22:24:00.000Z",
  "dateModified": "2025-10-17T05:52:50.169Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2023/2023-11-13_WebAssembly(Wasm)%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WebAssembly(Wasm)详解：浏览器中的下一代高性能计算',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">146</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">144</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-25.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">WebAssembly(Wasm)详解：浏览器中的下一代高性能计算</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-12T22:24:00.000Z" title="发表于 2023-11-13 06:24:00">2023-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/WebAssembly/">WebAssembly</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2023/2023-11-13_WebAssembly(Wasm)%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>WebAssembly (Wasm) 是一种二进制指令格式，它提供了一种在 Web 浏览器中运行高性能代码的方式。它是一种可移植、大小紧凑、加载快、与 Web 生态系统兼容的技术，旨在作为 Web 的编译目标。简单来说，Wasm 允许你用 C&#x2F;C++, Rust, Go 等多种语言编写代码，然后编译成 Wasm 格式，并在浏览器中以接近原生性能的速度运行。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>WebAssembly 是一种高效的、可移植的二进制指令格式，作为编译目标，使得 C&#x2F;C++, Rust 等宿主语言编写的代码能在浏览器、服务器等 WebAssembly 运行时中以接近原生性能执行，弥补了 JavaScript 在计算密集型任务上的短板，并扩展了 Web 应用的能力边界。</strong></p>
</div>

<h2 id="一、WebAssembly-简介"><a href="#一、WebAssembly-简介" class="headerlink" title="一、WebAssembly 简介"></a>一、WebAssembly 简介</h2><h3 id="1-1-什么是-WebAssembly？"><a href="#1-1-什么是-WebAssembly？" class="headerlink" title="1.1 什么是 WebAssembly？"></a>1.1 什么是 WebAssembly？</h3><p>WebAssembly，通常缩写为 Wasm，是一种设计为在 Web 浏览器中执行的字节码格式。它并不是一种编程语言，而是一种编译目标。你可以把 C、C++、Rust 等高级语言编译成 Wasm 模块，然后在支持 Wasm 的环境中运行这些模块。</p>
<p><strong>关键特性：</strong></p>
<ul>
<li><strong>高性能</strong>：Wasm 是一种低级字节码，可以被现代浏览器引擎快速解析、编译和执行，性能接近原生代码。</li>
<li><strong>可移植</strong>：Wasm 模块是平台无关的，可以在任何支持 WebAssembly 运行时的环境中运行（包括浏览器和一些非浏览器环境）。</li>
<li><strong>安全</strong>：Wasm 运行在一个沙盒环境中，与外界隔离，具有与 JavaScript 相同的安全模型。</li>
<li><strong>大小紧凑</strong>：Wasm 模块采用二进制格式，通常比 JavaScript 源文件更小，加载更快。</li>
<li><strong>与 JavaScript 互操作</strong>：Wasm 模块可以与 JavaScript 代码无缝集成，互相调用函数，共享数据。</li>
</ul>
<h3 id="1-2-WebAssembly-的起源和目标"><a href="#1-2-WebAssembly-的起源和目标" class="headerlink" title="1.2 WebAssembly 的起源和目标"></a>1.2 WebAssembly 的起源和目标</h3><p>WebAssembly 起源于对 Web 上高性能应用的需求。JavaScript 虽然在 Web 开发中占据主导地位，但在图像处理、视频编辑、3D 游戏、科学计算等计算密集型场景下，其性能瓶颈明显。在此之前，有 asm.js (JavaScript 的一个子集，通过 AOT 优化提供更佳性能) 作为过渡技术，为 Wasm 奠定了基础。</p>
<p><strong>WebAssembly 的最终目标是：</strong></p>
<ol>
<li><strong>在 Web 上实现高性能代码</strong>：使 Web 应用程序能够达到原生应用级别的性能。</li>
<li><strong>提供更广的语言支持</strong>：让开发者可以使用自己熟悉的语言（C&#x2F;C++, Rust, Go, Python 等）来开发 Web 应用。</li>
<li><strong>标准化</strong>：成为 W3C 的开放标准，确保跨浏览器兼容性。</li>
<li><strong>在非浏览器环境运行</strong>：WebAssembly 也在积极扩展到服务器、桌面应用、物联网等非浏览器场景，形成 WebAssembly Runtime (Wasmtime, Wasmer 等)。</li>
</ol>
<h3 id="1-3-WebAssembly-与-JavaScript-的关系"><a href="#1-3-WebAssembly-与-JavaScript-的关系" class="headerlink" title="1.3 WebAssembly 与 JavaScript 的关系"></a>1.3 WebAssembly 与 JavaScript 的关系</h3><p>Wasm <strong>不是</strong>要取代 JavaScript，而是要<strong>补充</strong> JavaScript。</p>
<ul>
<li><strong>JavaScript</strong>：是 Web 的主要脚本语言，擅长 DOM 操作、事件处理、网络请求和大多数业务逻辑。它具有动态、灵活、易于学习的特点。</li>
<li><strong>WebAssembly</strong>：是 Web 的<strong>汇编语言</strong>，专注于执行计算密集型任务，提供高性能。它在浏览器中通常通过 JavaScript 加载和控制。</li>
</ul>
<p>两者可以完美协作：JavaScript 负责 UI 交互和高层业务逻辑，而 Wasm 负责底层算法、图形渲染、物理引擎等对性能要求高的模块。</p>
<h2 id="二、WebAssembly-的核心概念与工作原理"><a href="#二、WebAssembly-的核心概念与工作原理" class="headerlink" title="二、WebAssembly 的核心概念与工作原理"></a>二、WebAssembly 的核心概念与工作原理</h2><h3 id="2-1-Wasm-模块-Module"><a href="#2-1-Wasm-模块-Module" class="headerlink" title="2.1 Wasm 模块 (Module)"></a>2.1 Wasm 模块 (Module)</h3><p>Wasm 模块是 WebAssembly 的部署单元。它类似于一个可执行文件或一个共享库。</p>
<ul>
<li>它包含编译后的 Wasm 二进制代码 (<code>.wasm</code> 文件)。</li>
<li>它定义了<strong>导入 (imports)</strong>：模块执行时需要的函数、全局变量或内存（由宿主环境提供，通常是 JavaScript）。</li>
<li>它定义了<strong>导出 (exports)</strong>：模块提供给宿主环境调用的函数、内存或表。</li>
</ul>
<h3 id="2-2-Wasm-实例-Instance"><a href="#2-2-Wasm-实例-Instance" class="headerlink" title="2.2 Wasm 实例 (Instance)"></a>2.2 Wasm 实例 (Instance)</h3><p>Wasm 实例是 Wasm 模块在运行时的一个具体实例。每个实例都有自己的内存、表和全局变量。你可以从同一个模块创建多个实例。</p>
<h3 id="2-3-内存-Linear-Memory"><a href="#2-3-内存-Linear-Memory" class="headerlink" title="2.3 内存 (Linear Memory)"></a>2.3 内存 (Linear Memory)</h3><p>Wasm 模块操作的是一块连续的、可增长的字节数组，称为<strong>线性内存 (Linear Memory)</strong>。</p>
<ul>
<li>这块内存由 Wasm 实例和 JavaScript 共享。</li>
<li>JavaScript 可以通过 <code>WebAssembly.Memory</code> 对象访问和操作这块内存。</li>
<li>Wasm 代码通过内存地址和大小直接读写这块内存。</li>
<li>这使得 Wasm 和 JavaScript 之间可以通过直接读写内存来高效地传递结构化数据，而不是通过序列化&#x2F;反序列化。</li>
</ul>
<h3 id="2-4-表-Table"><a href="#2-4-表-Table" class="headerlink" title="2.4 表 (Table)"></a>2.4 表 (Table)</h3><p>Wasm 表是可调整大小的、类型化的引用数组。它的主要用途是存储间接函数引用，这使得 Wasm 模块可以实现动态调度、回调函数等高级编程模式。</p>
<h3 id="2-5-编译和执行流程"><a href="#2-5-编译和执行流程" class="headerlink" title="2.5 编译和执行流程"></a>2.5 编译和执行流程</h3><ol>
<li><strong>编写源代码</strong>：使用 C&#x2F;C++, Rust 等高级语言编写程序。</li>
<li><strong>编译到 Wasm</strong>：使用 Emscripten (C&#x2F;C++), wasm-pack (Rust) 等工具链将源代码编译成 <code>.wasm</code> 二进制文件。</li>
<li><strong>加载和实例化</strong> (在浏览器中通常通过 JavaScript)：<ul>
<li><strong>获取 <code>.wasm</code> 文件</strong>：通过 <code>fetch</code> API 或其他方式获取 Wasm 模块的二进制数据。</li>
<li><strong>编译</strong>：浏览器引擎解析 <code>.wasm</code> 二进制数据，并将其编译成机器码。这一步通常是流式编译 (streaming compilation)，可以在下载文件的同时进行编译。</li>
<li><strong>实例化</strong>：创建 Wasm 模块的实例，包括初始化其内存、表和全局变量，并解析其导入和导出。</li>
</ul>
</li>
<li><strong>执行</strong>：JavaScript 调用 Wasm 实例的导出函数，或 Wasm 内部函数自行执行。</li>
</ol>
<h2 id="三、WebAssembly-的使用方式-C-示例"><a href="#三、WebAssembly-的使用方式-C-示例" class="headerlink" title="三、WebAssembly 的使用方式 (C++ 示例)"></a>三、WebAssembly 的使用方式 (C++ 示例)</h2><p>这里以 C++ 为例，展示如何编译和在 Web 中使用 Wasm。</p>
<h3 id="3-1-编写-C-代码-add-cpp"><a href="#3-1-编写-C-代码-add-cpp" class="headerlink" title="3.1 编写 C++ 代码 (add.cpp)"></a>3.1 编写 C++ 代码 (<code>add.cpp</code>)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="comment">// 确保函数名不被 C++ Name Mangling 改变</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; from WebAssembly!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用-Emscripten-编译"><a href="#3-2-使用-Emscripten-编译" class="headerlink" title="3.2 使用 Emscripten 编译"></a>3.2 使用 Emscripten 编译</h3><p>Emscripten 是一个将 C&#x2F;C++ 代码编译到 WebAssembly 的工具链。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Emscripten (如果尚未安装)</span></span><br><span class="line"><span class="comment"># git clone https://github.com/emscripten-core/emsdk.git</span></span><br><span class="line"><span class="comment"># cd emsdk</span></span><br><span class="line"><span class="comment"># ./emsdk install latest</span></span><br><span class="line"><span class="comment"># ./emsdk activate latest</span></span><br><span class="line"><span class="comment"># source ./emsdk_env.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 add.cpp 为 Wasm 模块</span></span><br><span class="line"><span class="comment"># -o add.html: 生成 HTML 文件、JS 胶水代码和 Wasm 模块</span></span><br><span class="line"><span class="comment"># -O3: 优化等级</span></span><br><span class="line"><span class="comment"># -s EXPORTED_FUNCTIONS=[&#x27;_add&#x27;, &#x27;_greet&#x27;]: 导出这两个 C 函数</span></span><br><span class="line"><span class="comment"># -s EXPORT_ES6=1: 生成ES6模块格式，方便在JS中import</span></span><br><span class="line"><span class="comment"># -s MODULARIZE=1: 将 Emscripten 运行时封装成模块</span></span><br><span class="line"><span class="comment"># -s WASM=1: 强制生成 Wasm 而不是 asm.js</span></span><br><span class="line"><span class="comment"># -s ALLOW_MEMORY_GROWTH=1: 允许内存自动增长</span></span><br><span class="line"></span><br><span class="line">emcc add.cpp -o add.html -O3 -s EXPORTED_FUNCTIONS=[<span class="string">&#x27;_add&#x27;</span>,<span class="string">&#x27;_greet&#x27;</span>] -s EXPORT_ES6=1 -s MODULARIZE=1 -s WASM=1 -s ALLOW_MEMORY_GROWTH=1</span><br></pre></td></tr></table></figure>
<p>这将生成 <code>add.html</code> (一个简单的示例页面), <code>add.js</code> (JavaScript 胶水代码) 和 <code>add.wasm</code> (Wasm 二进制模块)。</p>
<h3 id="3-3-在-JavaScript-中加载和使用-Wasm"><a href="#3-3-在-JavaScript-中加载和使用-Wasm" class="headerlink" title="3.3 在 JavaScript 中加载和使用 Wasm"></a>3.3 在 JavaScript 中加载和使用 Wasm</h3><h4 id="方式一：使用-Emscripten-生成的胶水代码-add-js"><a href="#方式一：使用-Emscripten-生成的胶水代码-add-js" class="headerlink" title="方式一：使用 Emscripten 生成的胶水代码 (add.js)"></a>方式一：使用 Emscripten 生成的胶水代码 (<code>add.js</code>)</h4><p><code>add.js</code> 是 Emscripten 自动生成的，它处理了 Wasm 模块的加载、编译和实例化，并提供了统一的 Module 对象。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebAssembly C++ Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">import</span> <span class="title class_">Module</span> <span class="keyword">from</span> <span class="string">&#x27;./add.js&#x27;</span>; <span class="comment">// 导入胶水代码</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Module</span>().<span class="title function_">then</span>(<span class="function"><span class="params">wasmModule</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// exports 是 Wasm 模块导出的所有函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebAssembly module loaded!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = wasmModule.<span class="title function_">_add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用导出的 add 函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;10 + 20 =&quot;</span>, result); <span class="comment">// Output: 10 + 20 = 30</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 调用 greet 函数，注意 C 字符串需要在 Wasm 内存中处理</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> name = <span class="string">&quot;Wasm User&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> namePtr = wasmModule.<span class="title function_">stringToUTF8</span>(name, wasmModule.<span class="title function_">_malloc</span>(name.<span class="property">length</span> + <span class="number">1</span>), name.<span class="property">length</span> + <span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">            wasmModule.<span class="title function_">_greet</span>(namePtr); <span class="comment">// Output: Hello, Wasm User from WebAssembly!</span></span></span><br><span class="line"><span class="language-javascript">            wasmModule.<span class="title function_">_free</span>(namePtr);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式二：直接使用-WebAssembly-JavaScript-API-更底层"><a href="#方式二：直接使用-WebAssembly-JavaScript-API-更底层" class="headerlink" title="方式二：直接使用 WebAssembly JavaScript API (更底层)"></a>方式二：直接使用 WebAssembly JavaScript API (更底层)</h4><p>如果你不想用 Emscripten 的胶水代码，或使用 Rust&#x2F;Go 等其他工具链，可以直接使用 <code>WebAssembly</code> API。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebAssembly Raw API Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadWasm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取 Wasm 模块</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;add.wasm&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> bytes = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 定义导入对象 (如果 Wasm 模块需要导入一些 JS 函数或内存)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> importObject = &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">env</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// Wasm 模块可能会导入一些函数，例如 Emscripten 的打印函数</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">_emscripten_memcpy_js</span>: <span class="function">(<span class="params">dest, src, len</span>) =&gt;</span> &#123;&#125;, <span class="comment">// 占位符或实现它</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 如果 C++ 代码使用了标准库，可能需要更多导入</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 例如，对于 std::cout，你需要提供一个 JS 函数来接收输出</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 通常 Emscripten 胶水代码替你处理了这些</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">__cxa_throw</span>: <span class="function">() =&gt;</span> &#123;&#125; <span class="comment">// 错误处理占位符</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// ... 更多由编译工具链决定的导入</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">          </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 编译和实例化 Wasm 模块</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> &#123; instance, <span class="variable language_">module</span> &#125; = <span class="keyword">await</span> <span class="title class_">WebAssembly</span>.<span class="title function_">instantiate</span>(bytes, importObject);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 访问导出的函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> add = instance.<span class="property">exports</span>.<span class="property">_add</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;10 + 20 =&quot;</span>, <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// Output: 10 + 20 = 30</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 访问并操作 Wasm 内存来传递字符串 (更复杂)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 需要获取 Wasm 实例的内存 export，并手动管理内存分配</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 这一步通常由胶水代码或更高级的库处理</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// const greetFn = instance.exports._greet;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// const memory = instance.exports.memory;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ... 手动将字符串写入内存</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// greetFn(ptr);</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">loadWasm</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：直接使用原生 WebAssembly API 在处理字符串、复杂数据结构和 C++ 标准库导入时会比较复杂，因为你需要手动管理 Wasm 的线性内存。Emscripten 胶水代码就是为了简化这些复杂性。</p>
<h2 id="四、WebAssembly-的应用场景"><a href="#四、WebAssembly-的应用场景" class="headerlink" title="四、WebAssembly 的应用场景"></a>四、WebAssembly 的应用场景</h2><ul>
<li><strong>高性能计算任务</strong>：<ul>
<li><strong>图像&#x2F;视频处理</strong>：滤镜、编码&#x2F;解码、实时编辑。</li>
<li><strong>3D 游戏引擎</strong>：将桌面游戏移植到 Web，或在浏览器中运行复杂 3D 渲染。</li>
<li><strong>科学计算&#x2F;模拟</strong>：物理引擎、机器学习推理、数据分析。</li>
<li><strong>加密&#x2F;解密</strong>：密码学算法。</li>
</ul>
</li>
<li><strong>富客户端应用&#x2F;桌面应用移植</strong>：<ul>
<li>将现有 C&#x2F;C++&#x2F;Rust 桌面应用（如 CAD 软件、IDE）移植到 Web。</li>
<li>例如，Figma、AutoCAD 等复杂应用都在部分使用 Wasm。</li>
</ul>
</li>
<li><strong>编解码器</strong>：音频&#x2F;视频编解码、文件压缩&#x2F;解压缩。</li>
<li><strong>编程语言运行时</strong>：在浏览器中运行 Python、Ruby 等语言的解释器。</li>
<li><strong>Web Workers 结合</strong>：在后台线程中运行 Wasm 模块，避免阻塞主线程，提升用户体验。</li>
<li><strong>服务器端 (Wasm outside browser)</strong>：作为轻量级、安全、高性能的通用运行时，用于 Serverless、插件系统、边缘计算等场景。例如 Wasmtime, Wasmer。</li>
</ul>
<h2 id="五、WebAssembly-的未来发展"><a href="#五、WebAssembly-的未来发展" class="headerlink" title="五、WebAssembly 的未来发展"></a>五、WebAssembly 的未来发展</h2><p>WebAssembly 仍在快速发展中，许多新特性正在提议和实现：</p>
<ul>
<li><strong>垃圾回收 (Garbage Collection, GC)</strong>：允许 Wasm 直接与宿主环境的 GC 交互，或拥有自己的 GC，从而更好地支持 Java, C# 等具有 GC 的语言。</li>
<li><strong>WebAssembly System Interface (WASI)</strong>：一套标准化的系统接口，使得 Wasm 模块可以在非浏览器环境（如服务器）下访问文件系统、网络等，而不依赖于特定的宿主。</li>
<li><strong>多线程</strong>：Wasm 模块能够利用多个线程进行并行计算。</li>
<li><strong>引用类型 (Reference Types)</strong>：改善 Wasm 与宿主环境（特别是 JavaScript）之间对象传递的效率和灵活性。</li>
<li><strong>组件模型 (Component Model)</strong>：提供更强大的互操作性和模块化能力，使得不同语言编译的 Wasm 模块更容易组合。</li>
<li><strong>调试工具</strong>：随着 Wasm 的普及，更强大的调试工具将是必然。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>WebAssembly 是 Web 技术的重大突破，它打破了 JavaScript 在性能和语言选择上的限制，将 Web 应用的边界扩展到前所未有的广度。它使得高性能的计算、复杂的算法、以及现有大量 C&#x2F;C++ 等代码库能够无缝地在浏览器中运行。Wasm 不仅增强了 Web 客户端的能力，其在服务器端和其他非浏览器环境中的潜力也使其成为通用运行时领域一颗冉冉升起的新星。对于追求极致性能、多语言支持以及跨平台能力的开发者来说，WebAssembly 无疑是一个值得深入学习和掌握的关键技术。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2023/2023-11-13_WebAssembly(Wasm)%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/">https://blog.tbf1211.xx.kg/2023/2023-11-13_WebAssembly(Wasm)%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/WebAssembly/">WebAssembly</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-25.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/" title="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</div></div><div class="info-2"><div class="info-item-1"> 现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：patch(), patchVnode(), 和 updateChildren()，并辅以 Mermaid 流程图进行可视化说明。  “虚拟 DOM 是前端性能优化的基石，而 Vue 的 patch() 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”   一、虚拟 DOM (Virtual DOM) 再探1.1 什么是虚拟 DOM？虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：  tag：标签名（如 d...</div></div></div></a><a class="pagination-related" href="/2023/2023-11-09_WebGL%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%843D%E5%9B%BE%E5%BD%A2%E9%AD%94%E6%B3%95/" title="WebGL详解：浏览器中的3D图形魔法"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">WebGL详解：浏览器中的3D图形魔法</div></div><div class="info-2"><div class="info-item-1"> WebGL (Web Graphics Library) 是一种 JavaScript API，用于在任何兼容的网页浏览器中渲染高性能的交互式 3D 和 2D 图形，而无需使用插件。它通过将 JavaScript 和 OpenGL ES 2.0 (或 3.0，对应 WebGL2) 的功能结合起来，直接在 HTML5 Canvas 元素中利用用户的 GPU 硬件加速进行渲染。  核心思想：WebGL 是一个基于 JavaScript 的浏览器 3D 图形 API，通过 HTML Canvas 元素将 OpenGL ES (2.0&#x2F;3.0) 硬件加速能力带到 Web 端，允许开发者直接与 GPU 交互，利用着色器程序渲染高性能、交互式的 3D 内容。   一、WebGL 简介1.1 什么是 WebGL？WebGL 是一种底层图形 API，它允许 Web 开发者在浏览器中直接访问和控制 GPU。简而言之，它是一个将 JavaScript 代码转换为 GPU 指令的桥梁。这意味着你可以用 JavaScript 编写程序来绘制复杂的 3D 模型、创建游戏、进行数据可视化等，而这...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-02-17_Pug(%E5%89%8DJade)%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/" title="Pug(前Jade)模板引擎详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="info-item-2">Pug(前Jade)模板引擎详解</div></div><div class="info-2"><div class="info-item-1"> Pug（发音 &#x2F;pʌɡ&#x2F;），前身为 Jade，是一个高性能的 Node.js 模板引擎。它以其简洁、富有表现力的语法而闻名，旨在让 HTML 编写变得更加高效和愉快。Pug 摒弃了传统 HTML 的尖括号和闭合标签，转而使用缩进和基于文本的语法，这使得模板文件更小、更易读、也更不易出错。  核心思想：Pug 通过简洁的缩进语法替代冗长的 HTML 标签，提供强大的动态数据渲染、代码重用和条件逻辑功能。   一、Pug 简介1.1 什么是模板引擎？模板引擎是一种将数据填充到预定义模板中以生成最终输出（通常是 HTML 字符串）的工具。它将页面的结构（模板）与数据分离，使得前端开发更加模块化和可维护。 1.2 Pug 的特点 独特语法：使用缩进表示嵌套关系，无需关闭标签。 简洁明了：代码量显著少于对应的 HTML。 强大功能：支持变量、循环、条件判断、Mixin（类似于函数或组件）、包含（文件复用）、布局继承等高级特性。 编译到 HTML：Pug 模板最终会被编译成标准的 HTML。 Node.js 支持：作为 Node.js 的模板引擎，Pug 完美集成于 E...</div></div></div></a><a class="pagination-related" href="/2023/2023-03-01_React%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/" title="React入门教程：快速构建交互式用户界面"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-01</div><div class="info-item-2">React入门教程：快速构建交互式用户界面</div></div><div class="info-2"><div class="info-item-1"> React (通常称为 React.js 或 ReactJS) 是一个由 Facebook 开发并维护的用于构建用户界面 (UI) 的 JavaScript 库。它以其组件化、声明式的编程范式和高效的 虚拟 DOM (Virtual DOM) 机制而闻名。本入门教程将带你领略 React 的核心概念，并指导你搭建第一个 React 应用，让你快速掌握构建交互式前端应用的基础。  “React 并不是一个完整的框架，而是一个专注于 UI 层面的库。它鼓励你将 UI 拆分成独立、可复用的小块（组件），从而让代码更易于管理、开发和测试。学习 React，就是学习如何思考和构建组件。”   一、React 的核心理念1.1 组件化 (Component-Based)React 的核心是组件 (Component)。你可以将复杂的 UI 拆分为独立的、可复用的、封装性良好的小组件。每个组件都有自己的逻辑和外观，它们可以组合起来形成更复杂的 UI。  示例：一个电商网站可以分解为：Header 组件、ProductList 组件、ProductCard 组件、Button 组件、Shopp...</div></div></div></a><a class="pagination-related" href="/2023/2023-04-17_%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%AF%A6%E8%A7%A3/" title="前端项目工程化详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="info-item-2">前端项目工程化详解</div></div><div class="info-2"><div class="info-item-1"> 随着前端应用的复杂度日益增加，单纯依靠人工管理和协作已经无法满足高效、高质量开发的需求。前端工程化应运而生，它旨在通过将软件工程的思想和方法引入前端开发，构建一套系统化、标准化、自动化、体系化的解决方案，以提高开发效率、保障代码质量、降低维护成本。  前端工程化的核心思想是：以自动化取代人力，以工具取代重复劳动，以规范约束散漫。   一、什么是前端工程化？前端工程化是构建、管理和维护前端项目的实践和工具集。它涵盖了从项目初始化、开发、构建、测试到部署的整个生命周期，目标是提升团队协作效率、统一代码风格、保证项目质量、优化产物性能以及实现快速迭代。 它不仅仅是使用几个构建工具，更是一种体系化的思维方式和工作流。 二、为什么需要前端工程化？在没有工程化的时代，前端开发面临诸多挑战：  开发效率低下：手动重复任务（如文件合并、压缩），环境搭建复杂。 代码质量参差不齐：缺乏统一的代码规范和质量检查机制，导致 Bug 增多，难以维护。 团队协作困难：不同成员的代码风格差异大，冲突频繁，交接成本高。 项目性能不佳：缺乏自动化优化手段（如图片压缩、按需加载），页面加载慢。 部署上线复杂：手动...</div></div></div></a><a class="pagination-related" href="/2023/2023-05-01_%E5%9F%BA%E4%BA%8ETypeScript%E5%B0%81%E8%A3%85Axios%E6%88%90%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="基于TypeScript封装Axios成通用工具类"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-01</div><div class="info-item-2">基于TypeScript封装Axios成通用工具类</div></div><div class="info-2"><div class="info-item-1"> 在现代前端开发中，网络请求是任何应用不可或缺的一部分。Axios 作为一款流行的基于 Promise 的 HTTP 客户端，因其易用性和强大的功能而广受欢迎。然而，在大型项目中直接使用 Axios 可能会导致代码冗余、维护困难。结合 TypeScript 的类型优势，我们可以将 Axios 封装成一个强大且类型安全的通用工具类，从而提高代码的可维护性、可扩展性和开发效率。  “好的封装，是为了在自由和约束之间找到平衡，让开发更高效，代码更健壮。”   一、为什么需要封装 Axios？直接使用 Axios 固然方便，但在实际项目中，我们通常面临以下问题：  公共请求配置： baseURL、超时时间、请求头（如 Authorization Token）等在多个请求中重复设置。 请求&#x2F;响应拦截器：统一处理请求发送前的参数加密、Token 携带，以及响应返回后的状态码处理、错误提示、数据格式化等。 错误处理：统一的错误捕获和提示机制，避免每个请求都写 try...catch。 数据类型定义：使用 TypeScript 时，请求参数和响应数据的类型定义需要贯穿整个请求周期，直接...</div></div></div></a><a class="pagination-related" href="/2023/2023-07-27_React%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A0%B8%E5%BF%83API%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB/" title="React 详解：核心 API 深度解读"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-27</div><div class="info-item-2">React 详解：核心 API 深度解读</div></div><div class="info-2"><div class="info-item-1"> React (也称为 React.js 或 ReactJS) 是一个由 Facebook 开发并维护的开源 JavaScript 库，用于构建用户界面 (User Interface)。本篇将深入剖析 React 的核心 API，涵盖了从组件定义到各种 Hooks 的详细用法，助您更全面地理解和运用 React。  “React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.” —— React Official Documentation   一、React 的核心模块与入口React 库被拆分为两个主要模块：react 和 react-dom。  react: 包含构建组件和定义其行为所需的核心 API（如 Component, use...</div></div></div></a><a class="pagination-related" href="/2023/2023-08-01_TypeScript%20React%E8%AF%A6%E8%A7%A3/" title="TypeScript React 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="info-item-2">TypeScript React 详解</div></div><div class="info-2"><div class="info-item-1"> TypeScript + React 是现代前端开发中最强大的组合之一。TypeScript 为 React 应用带来了强大的类型系统，显著提高了代码质量、可维护性和开发效率。它在开发阶段就能捕获许多常见的错误，并提供出色的编辑器支持，使得构建大型、复杂的 React 应用变得更加可靠和愉快。  “Adding TypeScript to your React project can feel like adding a safety net. It catches bugs early, improves code readability, and makes refactoring a breeze, especially as your application grows.”   一、为什么在 React 中使用 TypeScript？React 本身是 JavaScript 库。虽然 JavaScript 灵活性高，但对于大型项目或多人协作，缺乏类型检查可能导致以下问题：  难以发现的运行时错误: 许多类型相关的错误（例如，将一个字符串传递给期望数字的组件属性）只会在运...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">146</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">144</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81WebAssembly-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、WebAssembly 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-WebAssembly%EF%BC%9F"><span class="toc-text">1.1 什么是 WebAssembly？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-WebAssembly-%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-text">1.2 WebAssembly 的起源和目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-WebAssembly-%E4%B8%8E-JavaScript-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1.3 WebAssembly 与 JavaScript 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81WebAssembly-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、WebAssembly 的核心概念与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Wasm-%E6%A8%A1%E5%9D%97-Module"><span class="toc-text">2.1 Wasm 模块 (Module)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Wasm-%E5%AE%9E%E4%BE%8B-Instance"><span class="toc-text">2.2 Wasm 实例 (Instance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%86%85%E5%AD%98-Linear-Memory"><span class="toc-text">2.3 内存 (Linear Memory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%A1%A8-Table"><span class="toc-text">2.4 表 (Table)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.5 编译和执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81WebAssembly-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-C-%E7%A4%BA%E4%BE%8B"><span class="toc-text">三、WebAssembly 的使用方式 (C++ 示例)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BC%96%E5%86%99-C-%E4%BB%A3%E7%A0%81-add-cpp"><span class="toc-text">3.1 编写 C++ 代码 (add.cpp)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8-Emscripten-%E7%BC%96%E8%AF%91"><span class="toc-text">3.2 使用 Emscripten 编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%9C%A8-JavaScript-%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8-Wasm"><span class="toc-text">3.3 在 JavaScript 中加载和使用 Wasm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-Emscripten-%E7%94%9F%E6%88%90%E7%9A%84%E8%83%B6%E6%B0%B4%E4%BB%A3%E7%A0%81-add-js"><span class="toc-text">方式一：使用 Emscripten 生成的胶水代码 (add.js)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-WebAssembly-JavaScript-API-%E6%9B%B4%E5%BA%95%E5%B1%82"><span class="toc-text">方式二：直接使用 WebAssembly JavaScript API (更底层)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81WebAssembly-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、WebAssembly 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81WebAssembly-%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%8F%91%E5%B1%95"><span class="toc-text">五、WebAssembly 的未来发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言指向指针的指针(Pointer to Pointer)详解"/></a><div class="content"><a class="title" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解">Go语言指向指针的指针(Pointer to Pointer)详解</a><time datetime="2025-09-30T22:24:00.000Z" title="发表于 2025-10-01 06:24:00">2025-10-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-25.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><script src="/self/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>