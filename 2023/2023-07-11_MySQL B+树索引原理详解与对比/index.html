<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL B+树索引原理详解与对比 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库索引是提升查询性能的关键，而 MySQL 中最常见的索引结构就是 B+树。理解 B+树的原理对于优化数据库性能至关重要。本文将详细解析 B+树索引的内部工作机制，并将其与二叉查找树、平衡二二叉查找树、红黑树和 B 树进行对比，阐明 B+树在磁盘存储和数据库查询场景下的优势。  “索引的本质是空间换时间，而 B+树是这种理念在磁盘存储场景下的极致优化。”   一、为什么需要索引？想象一下，你">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL B+树索引原理详解与对比">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="数据库索引是提升查询性能的关键，而 MySQL 中最常见的索引结构就是 B+树。理解 B+树的原理对于优化数据库性能至关重要。本文将详细解析 B+树索引的内部工作机制，并将其与二叉查找树、平衡二二叉查找树、红黑树和 B 树进行对比，阐明 B+树在磁盘存储和数据库查询场景下的优势。  “索引的本质是空间换时间，而 B+树是这种理念在磁盘存储场景下的极致优化。”   一、为什么需要索引？想象一下，你">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg">
<meta property="article:published_time" content="2023-07-10T22:24:00.000Z">
<meta property="article:modified_time" content="2025-09-25T06:23:45.777Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="中间件">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL B+树索引原理详解与对比",
  "url": "https://blog.tbf1211.xx.kg/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg",
  "datePublished": "2023-07-10T22:24:00.000Z",
  "dateModified": "2025-09-25T06:23:45.777Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL B+树索引原理详解与对比',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-24.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL B+树索引原理详解与对比</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL B+树索引原理详解与对比</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-07-10T22:24:00.000Z" title="发表于 2023-07-11 06:24:00">2023-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>数据库索引是提升查询性能的关键，而 MySQL 中最常见的索引结构就是 <strong>B+树</strong>。理解 B+树的原理对于优化数据库性能至关重要。本文将详细解析 B+树索引的内部工作机制，并将其与二叉查找树、平衡二二叉查找树、红黑树和 B 树进行对比，阐明 B+树在磁盘存储和数据库查询场景下的优势。</p>
</blockquote>
<div class="note info flat"><p>“索引的本质是空间换时间，而 B+树是这种理念在磁盘存储场景下的极致优化。”</p>
</div>

<h2 id="一、为什么需要索引？"><a href="#一、为什么需要索引？" class="headerlink" title="一、为什么需要索引？"></a>一、为什么需要索引？</h2><p>想象一下，你有一本几百页的字典，如果要查找一个词，没有目录（索引）的话，你可能需要从头到尾翻阅。而有了目录（索引），你可以快速定位到词语的大致位置，大大提高查找效率。</p>
<p>在数据库中，表是按照某种顺序（不一定是逻辑顺序）存储在磁盘上的。当数据量巨大时，如果没有索引，每次查询都需要进行<strong>全表扫描</strong>（Full Table Scan），这意味着数据库需要读取磁盘上的每一行数据并进行比较，效率极低。</p>
<p>索引通过创建一种特殊的数据结构，可以快速定位到数据记录的位置，从而显著减少磁盘 I&#x2F;O 次数，提高查询速度。</p>
<h2 id="二、各种树结构简述与对比"><a href="#二、各种树结构简述与对比" class="headerlink" title="二、各种树结构简述与对比"></a>二、各种树结构简述与对比</h2><p>在深入 B+树之前，我们先回顾一下几种常见的树形数据结构，了解它们的优缺点，从而更好理解 B+树为何是数据库索引的优选。</p>
<h3 id="1-二叉查找树-Binary-Search-Tree-BST"><a href="#1-二叉查找树-Binary-Search-Tree-BST" class="headerlink" title="1. 二叉查找树 (Binary Search Tree - BST)"></a>1. 二叉查找树 (Binary Search Tree - BST)</h3><ul>
<li><strong>特点</strong>：左子树所有节点的值小于根节点，右子树所有节点的值大于根节点。</li>
<li><strong>查找效率</strong>：平均情况下 <code>O(logN)</code>。</li>
<li><strong>缺点</strong>：在极端情况下（如插入的元素有序），二叉查找树会退化成链表，查找效率变为 <code>O(N)</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       50</span><br><span class="line">      /  \</span><br><span class="line">    30    70</span><br><span class="line">   / \    / \</span><br><span class="line">  20 40  60 80</span><br><span class="line"></span><br><span class="line">// 退化情况 (左倾斜树)</span><br><span class="line">10</span><br><span class="line"> \</span><br><span class="line">  20</span><br><span class="line">   \</span><br><span class="line">    30</span><br><span class="line">     \</span><br><span class="line">      40</span><br></pre></td></tr></table></figure>

<h3 id="2-平衡二叉查找树-Balanced-Binary-Search-Tree-BBST"><a href="#2-平衡二叉查找树-Balanced-Binary-Search-Tree-BBST" class="headerlink" title="2. 平衡二叉查找树 (Balanced Binary Search Tree - BBST)"></a>2. 平衡二叉查找树 (Balanced Binary Search Tree - BBST)</h3><ul>
<li><strong>特点</strong>：为了解决 BST 退化问题，BBST 引入平衡因子，确保树的高度尽可能小。任意节点的左右子树高度差不超过 1。常见的实现有 AVL 树。</li>
<li><strong>查找效率</strong>：始终保持 <code>O(logN)</code>。</li>
<li><strong>缺点</strong>：插入和删除操作时，可能需要进行多次旋转来维护平衡，增加了操作的复杂度。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     40</span><br><span class="line">    /  \</span><br><span class="line">  20    60</span><br><span class="line"> / \    / \</span><br><span class="line">10 30  50 70</span><br></pre></td></tr></table></figure>

<h3 id="3-红黑树-Red-Black-Tree-RBT"><a href="#3-红黑树-Red-Black-Tree-RBT" class="headerlink" title="3. 红黑树 (Red-Black Tree - RBT)"></a>3. 红黑树 (Red-Black Tree - RBT)</h3><ul>
<li><strong>特点</strong>：一种自平衡二叉查找树，比 AVL 树的平衡条件更宽松，通过节点着色（红或黑）和旋转来保持平衡。</li>
<li><strong>查找效率</strong>：始终保持 <code>O(logN)</code>。</li>
<li><strong>优点</strong>：与 AVL 树相比，RBT 在插入和删除时进行旋转的次数更少，因此在读写混合的场景下表现更好。</li>
<li><strong>缺点</strong>：仍然是二叉树结构，每个节点只能有两个子节点。当数据量巨大时，树的高度依然会相对较高。</li>
</ul>
<h3 id="4-B-树-B-Tree"><a href="#4-B-树-B-Tree" class="headerlink" title="4. B 树 (B-Tree)"></a>4. B 树 (B-Tree)</h3><ul>
<li><strong>特点</strong>：<strong>多路平衡查找树</strong>。每个节点可以有多个子节点（通常是 2 个以上），而不仅仅是 2 个。节点内会存储多个关键字 (<code>key</code>)，并将搜索范围分割成多个子树。</li>
<li><strong>查找效率</strong>：<code>O(log(k)N)</code>，其中 <code>k</code> 是树的度（B 树中节点最大子节点数）。</li>
<li><strong>优点</strong>：<ul>
<li><strong>降低树的高度</strong>：由于一个节点可以存储多个关键字和子节点指针，B 树的高度远低于二叉树。这对于磁盘存储至关重要，因为树的高度决定了磁盘 I&#x2F;O 的次数。</li>
<li><strong>适应磁盘 I&#x2F;O</strong>：B 树的节点大小通常设计为磁盘页（Page）的大小（如 4KB、16KB），一次磁盘 I&#x2F;O 可以读取整个节点，减少 I&#x2F;O 次数。</li>
</ul>
</li>
<li><strong>缺点</strong>：每个节点既存储关键字又存储数据指针，数据指针可能分散在整个树中，导致范围查询效率相对较低。</li>
</ul>
<p><strong>B 树节点结构概览：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Pointer1 | Key1 | Pointer2 | Key2 | Pointer3 | ... | KeyN | PointerN+1 |</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Key</code>：索引值。</li>
<li><code>Pointer</code>：指向子节点的指针。</li>
</ul>
<h3 id="5-对比总结"><a href="#5-对比总结" class="headerlink" title="5. 对比总结"></a>5. 对比总结</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">二叉查找树</th>
<th align="left">平衡二叉查找树</th>
<th align="left">红黑树</th>
<th align="left">B 树</th>
</tr>
</thead>
<tbody><tr>
<td align="left">节点子节点数</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left"><strong>M (多于 2)</strong></td>
</tr>
<tr>
<td align="left">平衡机制</td>
<td align="left">无</td>
<td align="left">严格平衡（AVL）</td>
<td align="left">宽松平衡</td>
<td align="left">自平衡（分裂与合并）</td>
</tr>
<tr>
<td align="left">树高</td>
<td align="left"><code>O(N)</code>~&#96;O(logN)&#96;</td>
<td align="left"><code>O(logN)</code></td>
<td align="left"><code>O(logN)</code></td>
<td align="left"><strong><code>O(log(M)N)</code> (非常低)</strong></td>
</tr>
<tr>
<td align="left">磁盘 I&#x2F;O 次数</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left"><strong>低</strong></td>
</tr>
<tr>
<td align="left">优点</td>
<td align="left">实现简单</td>
<td align="left">查找稳定 <code>O(logN)</code></td>
<td align="left">读写均衡</td>
<td align="left">适合磁盘存储，降低 I&#x2F;O</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">易退化</td>
<td align="left">维护开销大</td>
<td align="left">仍然是二叉树结构</td>
<td align="left">范围查询效率略低</td>
</tr>
</tbody></table>
<p>从上表可以看出，对于数据库这种数据量大且存储在磁盘上的系统，B 树的多路、低高度特性使其比二叉树更具优势。但 B 树仍然有优化空间。</p>
<h2 id="三、B-树索引原理详解"><a href="#三、B-树索引原理详解" class="headerlink" title="三、B+树索引原理详解"></a>三、B+树索引原理详解</h2><p>B+树是 B 树的变种，专门为文件系统和数据库设计，进一步优化了磁盘 I&#x2F;O 和范围查询。</p>
<h3 id="1-B-树的特点"><a href="#1-B-树的特点" class="headerlink" title="1. B+树的特点"></a>1. B+树的特点</h3><ol>
<li><strong>所有关键字（索引值）都出现在叶子节点中</strong>：非叶子节点只存储关键字和指向子节点的指针，不存储真正的数据。</li>
<li><strong>叶子节点包含了所有数据记录的指针，且互相连接（链表结构）</strong>：所有叶子节点构成一个有序链表，方便范围查询。</li>
<li><strong>非叶子节点（内节点）仅作为索引和分路，不存储数据</strong>：也称为索引节点。每个内节点中的关键字都是其子树中的最大（或最小）关键字。</li>
</ol>
<p><strong>B+树节点结构概览：</strong></p>
<ul>
<li><strong>内节点 (非叶子节点)</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Pointer1 | Key1 | Pointer2 | Key2 | ... | KeyM-1 | PointerM |</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Key</code>：索引值，<strong>仅用于指向子树，本身不带数据</strong>。</li>
<li><code>Pointer</code>：指向子节点的指针。</li>
</ul>
</li>
<li><strong>叶子节点</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| Key1 | DataPointer1 | NextLeafPointer |</span><br><span class="line">| Key2 | DataPointer2 | NextLeafPointer |</span><br><span class="line">| ...                 | NextLeafPointer |</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Key</code>：索引值。</li>
<li><code>DataPointer</code>：指向磁盘上实际数据记录的指针（对于聚簇索引，就是数据本身）。</li>
<li><code>NextLeafPointer</code>：指向下一个叶子节点的指针，形成有序链表。</li>
</ul>
</li>
</ul>
<h3 id="2-B-树的查找过程"><a href="#2-B-树的查找过程" class="headerlink" title="2. B+树的查找过程"></a>2. B+树的查找过程</h3><ol>
<li><strong>从根节点开始</strong>：根据要查找的关键字，在根节点内存中进行<strong>二分查找</strong>（或线性查找，取决于节点内关键字数量），找到对应的区间。</li>
<li><strong>沿指针下溯</strong>：根据找到的区间，获得指向子节点的指针，加载子节点到内存。</li>
<li><strong>重复步骤 1 和 2</strong>：直到达到叶子节点。</li>
<li><strong>在叶子节点中查找</strong>：在叶子节点内存中进行二分查找，找到目标关键字。</li>
<li><strong>获取数据指针&#x2F;数据</strong>：通过叶子节点存储的数据指针，定位并读取磁盘上的实际数据记录。</li>
</ol>
<p><strong>示例：查找 Key &#x3D; 60</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        [50, 80]     (根节点，在内存中)</span><br><span class="line">       /    |    \</span><br><span class="line">      /     |     \</span><br><span class="line">   [1-40] [51-70] [81-100] (非叶子节点1，非叶子节点2，非叶子节点3)</span><br><span class="line">     |      |       |</span><br><span class="line">     V      V       V</span><br><span class="line">[10,20,30,40] [50,60,70] [80,90,100] (叶子节点，链表连接)</span><br></pre></td></tr></table></figure>

<p><strong>查找 60：</strong></p>
<ol>
<li>从根节点 <code>[50, 80]</code> 开始，<code>60 &gt; 50</code> 且 <code>60 &lt; 80</code>，走第二个指针。</li>
<li>加载非叶子节点 <code>[51-70]</code> 到内存，<code>60</code> 在这个范围内，走指向 <code>[50,60,70]</code> 叶子节点的指针。</li>
<li>加载叶子节点 <code>[50,60,70]</code> 到内存，找到 <code>60</code>。</li>
<li>根据 <code>60</code> 对应的数据指针，获取数据。</li>
</ol>
<h3 id="3-B-树的优势"><a href="#3-B-树的优势" class="headerlink" title="3. B+树的优势"></a>3. B+树的优势</h3><ol>
<li><strong>磁盘 I&#x2F;O 效率高</strong>：<ul>
<li><strong>树的高度低</strong>：每个节点可以保存大量的关键字，使得 B+树的高度非常矮。通常 3-4 层深的 B+树就可以索引几十亿的数据。</li>
<li><strong>节点与磁盘页对应</strong>：B+树的节点大小通常等于一个磁盘页（如 16KB），一次磁盘 I&#x2F;O 可以读取整个节点，减少 I&#x2F;O 次数。大多数查询只需 3-4 次磁盘 I&#x2F;O 即可找到目标数据。</li>
</ul>
</li>
<li><strong>范围查询友好</strong>：<ul>
<li>所有叶子节点组成一个有序链表。当查找完一个范围的起点后，只需沿着叶子节点的链表指针顺序遍历，而无需回溯到父节点，效率极高。</li>
</ul>
</li>
<li><strong>查询性能稳定</strong>：<ul>
<li>所有查询都必须从根节点走到叶子节点，查询路径长度基本一致，因此查询性能稳定。</li>
</ul>
</li>
<li><strong>有利于缓存</strong>：<ul>
<li>内节点只存储关键字和指针，占用空间小。当 B+树的内节点被加载到内存时，可以缓存更多的节点，进一步减少磁盘 I&#x2F;O。</li>
</ul>
</li>
</ol>
<h3 id="4-B-树的增删操作"><a href="#4-B-树的增删操作" class="headerlink" title="4. B+树的增删操作"></a>4. B+树的增删操作</h3><p>B+树的插入和删除操作相对复杂，需要保持树的平衡性、节点内关键字的有序性以及叶子节点链表的完整性。</p>
<ul>
<li><strong>插入</strong>：<ol>
<li>找到合适的叶子节点插入新关键字。</li>
<li>如果叶子节点未满，直接插入。</li>
<li>如果叶子节点已满，则进行<strong>分裂</strong>：将一半关键字移到新的叶子节点，并将中间关键字（或其拷贝）提升到父节点。</li>
<li>如果父节点也满了，则继续分裂，这个过程可能一直向上蔓延到根节点（导致树的高度增加）。</li>
</ol>
</li>
<li><strong>删除</strong>：<ol>
<li>找到并删除叶子节点中的关键字。</li>
<li>如果叶子节点关键字数量低于阈值，则尝试从兄弟节点<strong>借用</strong>关键字。</li>
<li>如果无法借用，则进行<strong>合并</strong>：将该叶子节点与兄弟节点合并，并从父节点移除对应的关键字。</li>
<li>合并过程也可能向上蔓延。</li>
</ol>
</li>
</ul>
<h2 id="四、MySQL-中的-B-树索引"><a href="#四、MySQL-中的-B-树索引" class="headerlink" title="四、MySQL 中的 B+树索引"></a>四、MySQL 中的 B+树索引</h2><p>MySQL 主要存储引擎 <code>InnoDB</code> 实现了 B+树索引。它分为两种类型：<strong>聚簇索引</strong>和<strong>辅助索引（非聚簇索引）</strong>。</p>
<h3 id="1-聚簇索引-Clustered-Index"><a href="#1-聚簇索引-Clustered-Index" class="headerlink" title="1. 聚簇索引 (Clustered Index)"></a>1. 聚簇索引 (Clustered Index)</h3><ul>
<li><strong>定义</strong>：数据行本身就是存储在 B+树的叶子节点中。每个表只能有一个聚簇索引。</li>
<li><strong>特性</strong>：<ul>
<li>通常是表的主键（PRIMARY KEY）。如果表没有主键，InnoDB 会自动选择一个唯一的非空索引。如果没有这样的索引，InnoDB 会隐式地定义一个隐藏的行 ID 作为聚簇索引。</li>
<li>数据的物理存储顺序与聚簇索引的逻辑顺序一致。</li>
<li>优点：对于主键的查找和范围查询非常快，因为数据就在索引旁边，一步到位。</li>
<li>缺点：数据插入顺序要尽可能和主键顺序一致，否则会造成大量的页分裂和数据挪动，导致性能下降和碎片化。</li>
</ul>
</li>
<li><strong>数据结构</strong>：<ul>
<li>B+树的叶子节点存储完整的数据行。</li>
<li>非叶子节点存储索引值和指向子节点的页指针。</li>
</ul>
</li>
</ul>
<h3 id="2-辅助索引-非聚簇索引-Secondary-Index-Non-clustered-Index"><a href="#2-辅助索引-非聚簇索引-Secondary-Index-Non-clustered-Index" class="headerlink" title="2. 辅助索引 &#x2F; 非聚簇索引 (Secondary Index &#x2F; Non-clustered Index)"></a>2. 辅助索引 &#x2F; 非聚簇索引 (Secondary Index &#x2F; Non-clustered Index)</h3><ul>
<li><strong>定义</strong>：除了聚簇索引之外的所有索引都是辅助索引。</li>
<li><strong>特性</strong>：<ul>
<li>不需要覆盖所有列，只包含索引列和<strong>聚簇索引的键值</strong>。</li>
<li>优点：可以为不同的列创建多个辅助索引来优化不同查询。</li>
<li>缺点：相比聚簇索引，它的查询过程是“回表”：<ol>
<li>通过辅助索引找到对应的聚簇索引键值。</li>
<li>再通过聚簇索引键值去聚簇索引树中找到完整的数据行。</li>
</ol>
</li>
</ul>
</li>
<li><strong>数据结构</strong>：<ul>
<li>B+树的叶子节点存储索引值和<strong>对应的聚簇索引键值（主键值）</strong>。</li>
<li>非叶子节点存储索引值和指向子节点的页指针。</li>
</ul>
</li>
</ul>
<p><strong>举例说明“回表”：</strong></p>
<p>假设 <code>users</code> 表有 <code>id (主键, 聚簇索引)</code>, <code>name (辅助索引)</code>, <code>age</code> 列。</p>
<ul>
<li><strong>查询 <code>SELECT * FROM users WHERE id = 100;</code></strong><ul>
<li>直接通过聚簇索引 B+树查找，一次定位到叶子节点，获取完整数据。</li>
</ul>
</li>
<li><strong>查询 <code>SELECT * FROM users WHERE name = &#39;Alice&#39;;</code></strong><ul>
<li>首先通过 <code>name</code> 辅助索引 B+树查找。</li>
<li>在 <code>name</code> 索引的叶子节点找到 <code>name=&#39;Alice&#39;</code> 对应的 <code>id</code> 值（例如 <code>id=100</code>）。</li>
<li>然后拿着 <code>id=100</code>，再去聚簇索引 B+树中查找，最终找到完整数据行。</li>
<li>这个过程就是“回表”。</li>
</ul>
</li>
</ul>
<p><strong>索引覆盖 (Covering Index)</strong>:</p>
<p>如果辅助索引的叶子节点包含了所有查询需要的列，那么就不需要“回表”了。例如：<br><code>SELECT id, name FROM users WHERE name = &#39;Alice&#39;;</code><br>如果 <code>name</code> 列上有一个辅助索引，其叶子节点存储了 <code>name</code> 和 <code>id</code>，那么查询可以直接从辅助索引中获取 <code>id</code> 和 <code>name</code>，而无需回表。这种情况下，辅助索引成为“覆盖索引”，查询效率得到极大提升。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>B+树作为 MySQL 最核心的索引结构，凭借其独特的性质完美契合了磁盘存储和数据库查询的需求：</p>
<ol>
<li><strong>多路结构、高度矮</strong>：极大地减少了磁盘 I&#x2F;O 次数，这是数据库性能的关键瓶颈。</li>
<li><strong>叶子节点链表</strong>：高效支持范围查询和全表扫描。</li>
<li><strong>内节点只存储索引</strong>：有助于将更多索引节点缓存在内存中。</li>
</ol>
<p>理解 B+树的这些原理，能够帮助我们：</p>
<ul>
<li><strong>正确选择索引列</strong>：将经常用于 <code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 的列作为索引。</li>
<li><strong>避免全表扫描</strong>：设计合适的索引以利用 B+树的快速查找能力。</li>
<li><strong>理解索引覆盖</strong>：通过创建覆盖索引来避免回表，进一步提高查询性能。</li>
<li><strong>优化插入顺序</strong>：对于聚簇索引，尽量使插入顺序与主键顺序一致，减少页分裂。</li>
</ul>
<p>总之，B+树是数据库查询性能的幕后英雄，深入理解其工作原理是数据库优化不可或缺的一环。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/">https://blog.tbf1211.xx.kg/2023/2023-07-11_MySQL%20B+%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-24.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/2023-07-27_React%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%A0%B8%E5%BF%83API%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB/" title="React 详解：核心 API 深度解读"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">React 详解：核心 API 深度解读</div></div><div class="info-2"><div class="info-item-1"> React (也称为 React.js 或 ReactJS) 是一个由 Facebook 开发并维护的开源 JavaScript 库，用于构建用户界面 (User Interface)。本篇将深入剖析 React 的核心 API，涵盖了从组件定义到各种 Hooks 的详细用法，助您更全面地理解和运用 React。  “React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.” —— React Official Documentation   一、React 的核心模块与入口React 库被拆分为两个主要模块：react 和 react-dom。  react: 包含构建组件和定义其行为所需的核心 API（如 Component, use...</div></div></div></a><a class="pagination-related" href="/2023/2023-06-15_Python%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/" title="Python装饰器详解：从基础到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python装饰器详解：从基础到高级应用</div></div><div class="info-2"><div class="info-item-1"> Python 装饰器 (Decorators) 是一种强大而优雅的语法糖，它允许你在不修改原函数代码的情况下，给函数添加额外的功能或修改其行为。装饰器本质上是一个接受函数作为参数并返回一个新函数的函数。它广泛应用于日志记录、性能测试、事务处理、权限验证等场景，是 Python 高级编程中不可或缺的工具。  “装饰器是 Python 的一项强大功能，它使得代码更加模块化、可读性更高，能够优雅地实现功能的扩展和复用，而无需侵入式地修改原有代码。”   一、理解装饰器前的预备知识要真正理解装饰器，我们需要先掌握几个 Python 核心概念： 1.1 函数是第一类对象 (First-Class Objects)在 Python 中，函数与其他数据类型（如整数、字符串）一样，是第一类对象。这意味着你可以：  将函数赋值给变量 将函数作为参数传递给其他函数 将函数作为另一个函数的返回值 在数据结构中存储函数  示例： 123456789101112131415161718192021def greet(name):    return f&quot;Hello, &#123;name&#1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-06-01_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL EXPLAIN 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="info-item-2">MySQL EXPLAIN 详解</div></div><div class="info-2"><div class="info-item-1"> EXPLAIN 是 MySQL 提供的一个非常强大的工具，用于分析 SELECT 语句的执行计划。通过 EXPLAIN 的输出结果，我们可以了解查询是如何执行的，包括使用了哪些索引、扫描了多少行、是否进行了文件排序等信息。这是数据库性能调优不可或缺的一环，能够帮助我们发现 SQL 语句中的性能瓶颈并进行优化。  “优化前，先 EXPLAIN。没有 EXPLAIN 的优化都是盲人摸象。” - 数据库优化格言   一、什么是 EXPLAIN？EXPLAIN 命令实际上是用来获取 MySQL 执行查询语句的执行计划的。执行计划描述了 MySQL 如何处理 SQL 语句，包括：  表的连接顺序 每个表使用的索引 是否使用了临时表 是否进行了文件排序 扫描的行数预估  通过分析这些信息，我们可以判断查询是否高效，是否可以进一步优化。 二、如何使用 EXPLAIN？使用 EXPLAIN 非常简单，只需将 EXPLAIN 关键字放在任何 SELECT 语句的前面。 1234EXPLAIN SELECT * FROM users WHERE username = &#x27;Alice&#x2...</div></div></div></a><a class="pagination-related" href="/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL 索引详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="info-item-2">MySQL 索引详解</div></div><div class="info-2"><div class="info-item-1"> 索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I&#x2F;O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。  “好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言   一、什么是索引？索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用它来快速定位数据。可以将其类比为一本书的目录，通过目录我们可以快速找到感兴趣的章节，而不需要通读整本书。 在数据库中，没有索引的查询需要全表扫描，即逐行检查每条记录，直到找到符合条件的记录。当数据量非常大时，这种操作的效率会非常低下。索引通过创建指向数据物理位置的指针，使得数据库在查询时能够直接跳转到相关记录，从而大大加快查询速度。 二、索引的优缺点优点 显著提高数据检索速度：这是索引最核心、最主要的优点。 加快表与表之间的连接速度：对于 JOIN 操作，索引可以加速连接条件的匹配。 加快分组和排序操作：GROUP BY 和 ORDER BY 操作通常通过消除临时表和对文件进行排序来提高...</div></div></div></a><a class="pagination-related" href="/2023/2023-01-26_%E4%BB%8E%E5%8D%95%E6%9C%BA%E5%88%B0%E5%93%A8%E5%85%B5%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85redis%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="从单机到哨兵，一张图理清redis架构演进！"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-26</div><div class="info-item-2">从单机到哨兵，一张图理清redis架构演进！</div></div><div class="info-2"><div class="info-item-1">Redis 的架构是逐步演进而来的，正所谓“罗马不是一天建成的”。   2010 年：单机版 Redis  当 Redis1.0在 2010 年首次发布时，整体架构非常简单，通常作为业务系统的缓存使用。不过，Redis 的数据是存储在内存中的，一旦重启，数据就会全部丢失，导致请求会直接打到数据库上，带来较大的压力。  2013 年：持久化机制上线  2013 年，Redis2.8版本发布，解决了之前“重启就丢数据”的问题。Redis 引入了 RDB（内存快照）机制，用于定时将内存中的数据持久化到磁盘。同时还支持 AOF（只追加文件）方式，将每一次写操作都记录到日志文件中，实现更高级别的持久化保障。  2013 年：主从复制机制  同样在 Redis2.8中，官方引入了主从复制功能，提升了系统的高可用性。主节点负责处理实时的读写请求，从节点则负责同步主节点的数据，起到备份和读扩展的作用。  2013 年：Sentinel 哨兵机制上线  在 Redis2.8版本中，引入了 Sentinel（哨兵）机制，用于实时监控 Redis 实例的运行状态。它主要负责以下几个方面的工作：   监...</div></div></div></a><a class="pagination-related" href="/2023/2023-05-08_Redis%20%E5%90%84%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/" title="Redis 各类数据结构指令详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-08</div><div class="info-item-2">Redis 各类数据结构指令详解</div></div><div class="info-2"><div class="info-item-1"> Redis 是一个开源（BSD 许可）的内存数据结构存储，可用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。理解并熟练使用这些数据结构及其相关指令，是高效利用 Redis 的关键。  Redis 的强大之处在于其在内存中操作这些丰富的数据结构，使得读写速度极快。掌握每个数据结构的使用场景和对应指令，是进行高性能应用开发的基础。   一、通用键指令 (Generic Commands)这些指令适用于所有数据类型的键。    指令 描述 示例    DEL key [key ...] 删除一个或多个键。 DEL mykey mylist   EXISTS key [key ...] 检查给定键是否存在。返回存在的键的数量。 EXISTS mykey   EXPIRE key seconds 设置键的过期时间（秒）。 EXPIRE mykey 60 (60秒后过期)   TTL key 获取键的剩余过期时间（秒）。-1 表示永久，-2 表示键不存在或已过...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-01_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%9A%E6%89%93%E9%80%A0%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/" title="Docker镜像构建与管理：打造标准化、可复用的容器镜像"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">Docker镜像构建与管理：打造标准化、可复用的容器镜像</div></div><div class="info-2"><div class="info-item-1"> 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  Docker 镜像构建与管理：打造标准化、可复用的容器镜像开篇：你是否也在镜像管理上栽过跟头？凌晨 2 点，生产环境突然告警，新部署的容器启动失败。排查后发现：开发环境用的镜像 800MB，生产环境的却有 3.2GB，里面塞满了编译工具、测试数据，甚至还有开发同学的 SSH 私钥… 这种 “镜像肥胖症” 你遇到过吗？或者更糟糕的：  同一个服务，测试环境能跑，生产环境启动就报错 镜像仓库里堆满了 latest、v1、v1-final、v1-final-final 这种让人崩溃的标签 构建一次镜像要等 20 分钟，因为每次都要重新下载依赖包  今天这篇文章，我会基于 5 年运维实战经验，教你构建一套标准化的镜像管理体系：从多阶段构建优化到镜像安全扫描，从版本管理策略到自动化构建流程，让你的镜像体积缩小 70%、构建速度提升 5 倍，并且永远不会再出现 “这个镜像到底能不能用” 的灵魂拷问。 一、镜像构建的三大核心原则（90% 的人都忽略了）1. 最小化原则：镜像里只放 “必需品”很多人写 Doc...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-05_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8EDockerfile%E5%88%B0%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">一、为什么需要索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-text">二、各种树结构简述与对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-Binary-Search-Tree-BST"><span class="toc-text">1. 二叉查找树 (Binary Search Tree - BST)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-Balanced-Binary-Search-Tree-BBST"><span class="toc-text">2. 平衡二叉查找树 (Balanced Binary Search Tree - BBST)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%A2%E9%BB%91%E6%A0%91-Red-Black-Tree-RBT"><span class="toc-text">3. 红黑树 (Red-Black Tree - RBT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-B-%E6%A0%91-B-Tree"><span class="toc-text">4. B 树 (B-Tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">5. 对比总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、B+树索引原理详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-B-%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1. B+树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-B-%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="toc-text">2. B+树的查找过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-B-%E6%A0%91%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">3. B+树的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-B-%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E6%93%8D%E4%BD%9C"><span class="toc-text">4. B+树的增删操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MySQL-%E4%B8%AD%E7%9A%84-B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-text">四、MySQL 中的 B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-Clustered-Index"><span class="toc-text">1. 聚簇索引 (Clustered Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-Secondary-Index-Non-clustered-Index"><span class="toc-text">2. 辅助索引 &#x2F; 非聚簇索引 (Secondary Index &#x2F; Non-clustered Index)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2详解：在Windows运行Linux的新标准"/></a><div class="content"><a class="title" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准">WSL2详解：在Windows运行Linux的新标准</a><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GoLang Wails 框架详解：用 Web 技术构建桌面应用"/></a><div class="content"><a class="title" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用">GoLang Wails 框架详解：用 Web 技术构建桌面应用</a><time datetime="2025-09-17T22:24:00.000Z" title="发表于 2025-09-18 06:24:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"/></a><div class="content"><a class="title" href="/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化">Redis持久化深度解析：RDB与AOF的终极对决与实战优化</a><time datetime="2025-09-13T22:24:00.000Z" title="发表于 2025-09-14 06:24:00">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-05_Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title="Go 语言协程设计与调度原理"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 语言协程设计与调度原理"/></a><div class="content"><a class="title" href="/2025/2025-09-05_Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title="Go 语言协程设计与调度原理">Go 语言协程设计与调度原理</a><time datetime="2025-09-04T22:24:00.000Z" title="发表于 2025-09-05 06:24:00">2025-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"/></a><div class="content"><a class="title" href="/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用">Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用</a><time datetime="2025-09-03T22:24:00.000Z" title="发表于 2025-09-04 06:24:00">2025-09-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-24.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2022 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>