<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python元类(Metaclass)深度解析 | T维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，">
<meta property="og:type" content="article">
<meta property="og:title" content="Python元类(Metaclass)深度解析">
<meta property="og:url" content="https://teatang.github.io/t-blog/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="T维度">
<meta property="og:description" content="Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://teatang.github.io/t-blog/img/cover/default_cover-07.jpg">
<meta property="article:published_time" content="2023-02-08T22:24:00.000Z">
<meta property="article:modified_time" content="2025-09-23T09:53:36.619Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://teatang.github.io/t-blog/img/cover/default_cover-07.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python元类(Metaclass)深度解析",
  "url": "https://teatang.github.io/t-blog/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/",
  "image": "https://teatang.github.io/t-blog/img/cover/default_cover-07.jpg",
  "datePublished": "2023-02-08T22:24:00.000Z",
  "dateModified": "2025-09-23T09:53:36.619Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://teatang.github.io/t-blog"
    }
  ]
}</script><link rel="shortcut icon" href="/t-blog/img/favicon.ico"><link rel="canonical" href="https://teatang.github.io/t-blog/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/t-blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/t-blog/',
  algolia: undefined,
  localSearch: {"path":"/t-blog/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: T维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python元类(Metaclass)深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/t-blog/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/t-blog/atom.xml" title="T维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/avatar.jpg" onerror="this.onerror=null;this.src='/t-blog/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/t-blog/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/t-blog/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/t-blog/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/t-blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/t-blog/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/t-blog/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/t-blog/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/t-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/t-blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/t-blog/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/t-blog/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/t-blog/img/cover/default_cover-07.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/t-blog/"><span class="site-name">T维度</span></a><a class="nav-page-title" href="/t-blog/"><span class="site-name">Python元类(Metaclass)深度解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/t-blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/t-blog/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/t-blog/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/t-blog/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/t-blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/t-blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/t-blog/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/t-blog/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python元类(Metaclass)深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-08T22:24:00.000Z" title="发表于 2023-02-09 06:24:00">2023-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/t-blog/categories/Python/">Python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/t-blog/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Python-元类深度解析：从概念到实战"><a href="#Python-元类深度解析：从概念到实战" class="headerlink" title="Python 元类深度解析：从概念到实战"></a>Python 元类深度解析：从概念到实战</h1><hr>
<blockquote>
<p>“Everything is an object.” - Python之禅<br>“Classes are objects too.” - 元类的核心思想</p>
</blockquote>
<p>在 Python 中，万物皆对象。你用 <code>class</code> 关键字定义的类，例如 <code>str</code>、<code>int</code>、<code>list</code>，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，它允许我们在类被创建时对其行为进行定制，是 Python 中进行高级面向对象编程的强大工具。</p>
<h2 id="1-什么是元类？"><a href="#1-什么是元类？" class="headerlink" title="1. 什么是元类？"></a>1. 什么是元类？</h2><p>在 Python 中，当你定义一个类 <code>class MyClass: pass</code> 的时候，Python 解释器会自动执行以下步骤：</p>
<ol>
<li><strong>定义一个类对象</strong>：解释器读取 <code>MyClass</code> 的定义，并创建一个名为 <code>MyClass</code> 的<strong>类对象</strong>。</li>
<li><strong>将类对象绑定到命名空间</strong>：这个 <code>MyClass</code> 类对象被绑定到当前的命名空间中。</li>
</ol>
<p>然后，当你通过 <code>my_instance = MyClass()</code> 来创建实例时，<code>MyClass</code> 这个类对象就会被调用，从而创建并返回一个实例对象。</p>
<p><strong>元类</strong>就是用来<strong>创建这些类对象</strong>的。或者说，元类是<strong>类的模板</strong>，它控制着类的创建过程，可以拦截类的定义，修改类的属性、方法，甚至完全改变类的行为。</p>
<p><strong>简而言之：</strong></p>
<ul>
<li><strong>实例</strong>是由<strong>类</strong>创建的。</li>
<li><strong>类</strong>是由<strong>元类</strong>创建的。</li>
</ul>
<p>默认情况下，Python 中所有类的元类都是 <code>type</code>。<code>type</code> 是 Python 内置的元类，也是最基本的元类。</p>
<h2 id="2-type-元类：你的第一个元类"><a href="#2-type-元类：你的第一个元类" class="headerlink" title="2. type 元类：你的第一个元类"></a>2. <code>type</code> 元类：你的第一个元类</h2><p><code>type</code> 不仅可以检查一个对象的类型（例如 <code>type(1)</code> 返回 <code>&lt;class &#39;int&#39;&gt;</code>），它更是一个功能强大的函数，可以<strong>动态地创建类</strong>。这是理解元类的关键。</p>
<p><code>type</code> 函数有三种形式：</p>
<ol>
<li><code>type(object)</code>：返回 <code>object</code> 的类型。</li>
<li><code>type(name, bases, dict)</code>：用于动态创建类。</li>
</ol>
<p>我们主要关注第二种形式：<code>type(name, bases, dict)</code>。</p>
<ul>
<li><code>name</code>: 类的名称（字符串）。</li>
<li><code>bases</code>: 基类（父类）组成的元组。如果没有任何父类，传入一个空元组 <code>()</code>。</li>
<li><code>dict</code>: 类的属性和方法组成的字典。键是属性&#x2F;方法名，值是属性值或方法函数。</li>
</ul>
<p><strong>示例：使用 <code>type</code> 动态创建类</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规方式定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassRegular</span>:</span><br><span class="line">    attr = <span class="number">100</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello from MyClassRegular!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 type 动态创建与 MyClassRegular 相同的类</span></span><br><span class="line">MyClassDynamic = <span class="built_in">type</span>(</span><br><span class="line">    <span class="string">&#x27;MyClassDynamic&#x27;</span>,  <span class="comment"># name: 类的名称</span></span><br><span class="line">    (),                <span class="comment"># bases: 基类元组，这里没有基类</span></span><br><span class="line">    &#123;                  <span class="comment"># dict: 类的属性和方法字典</span></span><br><span class="line">        <span class="string">&#x27;attr&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;method&#x27;</span>: <span class="keyword">lambda</span> <span class="variable language_">self</span>: <span class="built_in">print</span>(<span class="string">&quot;Hello from MyClassDynamic!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证两个类行为一致</span></span><br><span class="line"><span class="built_in">print</span>(MyClassRegular)       <span class="comment"># &lt;class &#x27;__main__.MyClassRegular&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(MyClassDynamic)       <span class="comment"># &lt;class &#x27;__main__.MyClassDynamic&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">instance_regular = MyClassRegular()</span><br><span class="line">instance_dynamic = MyClassDynamic()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instance_regular.attr)  <span class="comment"># 100</span></span><br><span class="line">instance_regular.method()     <span class="comment"># Hello from MyClassRegular!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instance_dynamic.attr)  <span class="comment"># 100</span></span><br><span class="line">instance_dynamic.method()     <span class="comment"># Hello from MyClassDynamic!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认它们的类型都是 type</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(MyClassRegular)) <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(MyClassDynamic)) <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子清晰地表明，<code>type</code> 函数正是幕后创建类的“元类”。当我们使用 <code>class</code> 关键字时，Python 解释器实际上就是通过 <code>type</code> 来创建这个类对象的。</p>
<h2 id="3-自定义元类：掌控类的创建过程"><a href="#3-自定义元类：掌控类的创建过程" class="headerlink" title="3. 自定义元类：掌控类的创建过程"></a>3. 自定义元类：掌控类的创建过程</h2><p>现在我们知道 <code>type</code> 是默认的元类。那么，我们能否创建自己的元类，来定制类的创建过程呢？当然可以！</p>
<p>一个自定义元类必须继承自 <code>type</code>。它的核心思想是：当你定义一个类时，如果你指定了一个自定义元类，那么 Python 不再调用 <code>type</code> 来创建你的类，而是会调用你指定的那个自定义元类。</p>
<p>自定义元类通常会重写 <code>__new__</code> 或 <code>__init__</code> 方法。</p>
<ul>
<li><p><strong><code>__new__(cls, name, bases, dct)</code></strong>:</p>
<ul>
<li>在类对象<strong>被创建之前</strong>调用。</li>
<li><code>cls</code>: 元类本身（例如，如果你自定义的元类叫 <code>MyMeta</code>，那么 <code>cls</code> 就是 <code>MyMeta</code>）。</li>
<li><code>name</code>: 即将被创建的类的名称。</li>
<li><code>bases</code>: 即将被创建的类的基类元组。</li>
<li><code>dct</code>: 即将被创建的类的属性字典（包括方法）。</li>
<li><strong>职责</strong>：创建并返回新的类对象。通常会调用 <code>super().__new__(cls, name, bases, dct)</code> 来完成实际的类创建。在这个方法里，你可以在类创建前修改 <code>name</code>、<code>bases</code> 或 <code>dct</code>。</li>
</ul>
</li>
<li><p><strong><code>__init__(cls, name, bases, dct)</code></strong>:</p>
<ul>
<li>在类对象<strong>被创建之后</strong>，但实例被创建之前调用。</li>
<li><code>cls</code>: 已经创建好的类对象（比如 <code>MyClass</code>）。</li>
<li><code>name</code>, <code>bases</code>, <code>dct</code>: 与 <code>__new__</code> 类似。</li>
<li><strong>职责</strong>：初始化已经创建好的类对象。通常用于在类创建后添加、修改或验证属性。</li>
</ul>
</li>
</ul>
<h3 id="3-1-定义一个简单的自定义元类"><a href="#3-1-定义一个简单的自定义元类" class="headerlink" title="3.1 定义一个简单的自定义元类"></a>3.1 定义一个简单的自定义元类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 定义一个自定义元类，它必须继承自 type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="comment"># __new__ 是在类对象创建之前被调用的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __new__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: Bases: <span class="subst">&#123;bases&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: Dict: <span class="subst">&#123;dct&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在这里可以修改 dct，例如添加一个属性</span></span><br><span class="line">        dct[<span class="string">&#x27;added_by_meta&#x27;</span>] = <span class="string">&quot;This was added by MyMeta&quot;</span></span><br><span class="line">        dct[<span class="string">&#x27;upper_name&#x27;</span>] = name.upper() <span class="comment"># 添加大写类名属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 必须调用父类(type)的 __new__ 方法来实际创建类对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, dct)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __init__ 是在类对象创建之后被调用的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls_obj, name, bases, dct</span>): <span class="comment"># 注意：这里用 cls_obj 避免和前面参数名混淆</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __init__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: Class object created: <span class="subst">&#123;cls_obj&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(cls_obj, name, bases, dct) <span class="comment"># 也要调用父类的 __init__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用自定义元类创建类</span></span><br><span class="line"><span class="comment"># 在 `class` 语句中，通过 `metaclass` 关键字参数指定元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdvancedClass</span>(metaclass=MyMeta):</span><br><span class="line">    version = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello from <span class="subst">&#123;self.__class__.__name__&#125;</span>, version <span class="subst">&#123;self.version&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证 MyAdvancedClass 的行为</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- After MyAdvancedClass definition ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MyAdvancedClass type is: <span class="subst">&#123;<span class="built_in">type</span>(MyAdvancedClass)&#125;</span>&quot;</span>) <span class="comment"># &lt;class &#x27;__main__.MyMeta&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认元类添加的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MyAdvancedClass.added_by_meta: <span class="subst">&#123;MyAdvancedClass.added_by_meta&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MyAdvancedClass.upper_name: <span class="subst">&#123;MyAdvancedClass.upper_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">instance = MyAdvancedClass()</span><br><span class="line">instance.greeting()</span><br></pre></td></tr></table></figure>

<p>运行上述代码，你会看到输出的顺序：</p>
<ol>
<li><code>MyMeta.__new__</code> 会在 <code>MyAdvancedClass</code> 类定义被处理时立即执行。</li>
<li><code>MyMeta.__init__</code> 紧接着执行，完成类对象的初始化。</li>
<li>最后才是 <code>MyAdvancedClass</code> 自身的使用。</li>
</ol>
<p>这证明了元类确实在类创建的早期阶段就介入了。</p>
<h3 id="3-2-prepare-方法-Python-3-6"><a href="#3-2-prepare-方法-Python-3-6" class="headerlink" title="3.2 __prepare__ 方法 (Python 3.6+)"></a>3.2 <code>__prepare__</code> 方法 (Python 3.6+)</h3><p>在 Python 3.6 引入了 <code>__prepare__(name, bases)</code> 这个元类方法。它在 <code>__new__</code> 和 <code>__init__</code> 之前被调用，用于创建类的命名空间字典。</p>
<ul>
<li><strong>职责</strong>：返回一个字典（或字典类对象），用于存储类的属性和方法。默认情况下，Python 使用普通的 <code>dict</code>。你可以返回一个 <code>OrderedDict</code> 等，确保属性的定义顺序得到保留。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedClassMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">metacls, name, bases</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __prepare__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> OrderedDict() <span class="comment"># 返回一个有序字典</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">metacls, name, bases, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __new__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: classdict type in __new__: <span class="subst">&#123;<span class="built_in">type</span>(classdict)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(metacls, name, bases, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, name, bases, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __init__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(cls, name, bases, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOrderedClass</span>(metaclass=OrderedClassMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_a</span>(<span class="params">self</span>): <span class="keyword">pass</span></span><br><span class="line">    _property_x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_b</span>(<span class="params">self</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 MyOrderedClass 的属性字典将保留定义顺序</span></span><br><span class="line"><span class="comment"># 虽然通过 dir() 或 __dict__ 仍然会看到默认的排序，</span></span><br><span class="line"><span class="comment"># 但在元类创建类时，__prepare__ 提供的有序字典确保了处理属性的顺序性。</span></span><br><span class="line"><span class="comment"># 实际的应用场景可能在需要反射或代码生成时，依赖定义的顺序。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-call-方法：控制实例创建"><a href="#4-call-方法：控制实例创建" class="headerlink" title="4. __call__ 方法：控制实例创建"></a>4. <code>__call__</code> 方法：控制实例创建</h2><p>我们已经看到元类的 <code>__new__</code> 和 <code>__init__</code> 控制着<strong>类的创建</strong>过程。<br>但当我们通过 <code>MyClass()</code> 来创建<strong>实例</strong>时，幕后发生了什么呢？</p>
<p>实际上，当你调用 <code>MyClass()</code> 时，Python 会调用 <code>MyClass</code> 这个<strong>类对象</strong>的 <code>__call__</code> 方法。由于 <code>MyClass</code> 是由元类创建的，所以它的 <code>__call__</code> 方法实际上继承自它的元类（<code>type</code> 或你的自定义元类）。</p>
<p><code>type</code> 的 <code>__call__</code> 方法做了三件事：</p>
<ol>
<li>调用 <code>MyClass.__new__</code>(cls, *args, **kwargs) 创建实例对象。</li>
<li>如果 <code>__new__</code> 返回的是 <code>cls</code> 的实例，则调用 <code>MyClass.__init__</code>(self, *args, **kwargs) 初始化实例。</li>
<li>返回实例对象。</li>
</ol>
<p>因此，如果你想控制<strong>实例的创建过程</strong>（例如，实现单例模式、延迟加载等），你应该在自定义元类中重写 <code>__call__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 如果类的实例尚未被创建</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            <span class="comment"># 调用 type.__call__ 来创建实例，并存储它</span></span><br><span class="line">            cls._instances[cls] = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls] <span class="comment"># 返回已有的实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = data</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;MySingleton instance <span class="subst">&#123;<span class="built_in">id</span>(self)&#125;</span> with data &#x27;<span class="subst">&#123;self.data&#125;</span>&#x27; created.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次创建实例</span></span><br><span class="line">s1 = MySingleton(<span class="string">&quot;first_data&quot;</span>) <span class="comment"># 会输出创建信息</span></span><br><span class="line">s2 = MySingleton(<span class="string">&quot;second_data&quot;</span>) <span class="comment"># 不会再次创建，直接返回s1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s1 is s2: <span class="subst">&#123;s1 <span class="keyword">is</span> s2&#125;</span>&quot;</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s1.data: <span class="subst">&#123;s1.data&#125;</span>&quot;</span>)   <span class="comment"># first_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s2.data: <span class="subst">&#123;s2.data&#125;</span>&quot;</span>)   <span class="comment"># first_data</span></span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何使用元类的 <code>__call__</code> 方法轻松实现单例模式。</p>
<h2 id="5-什么时候需要使用元类？"><a href="#5-什么时候需要使用元类？" class="headerlink" title="5. 什么时候需要使用元类？"></a>5. 什么时候需要使用元类？</h2><p>元类是一个高级工具，通常在以下场景中考虑使用：</p>
<ol>
<li><p><strong>框架级开发</strong>：在构建大型框架时，你可能需要对所有由该框架创建的类强制执行某些行为，例如：</p>
<ul>
<li><strong>自动注册类</strong>：所有继承自特定基类的类都被自动注册到一个列表中。</li>
<li><strong>注入通用方法&#x2F;属性</strong>：确保所有类都拥有某些特定的方法或属性（如ORM模型类自动拥有 <code>query</code> 方法）。</li>
<li><strong>接口&#x2F;抽象类的验证</strong>：在类定义时检查它是否实现了所有必须的方法。</li>
<li><strong>修改类的行为</strong>：如强制所有方法名以特定前缀开头。</li>
</ul>
</li>
<li><p><strong>API 定义</strong>：当你需要一个非常声明式的 API 时，元类能帮助你将一些“魔术”封装起来，让用户只需要声明性地定义类，而无需关心底层实现。</p>
</li>
<li><p><strong>ORM (Object-Relational Mapping)</strong>：ORM 中经常用到元类来将 Python 类映射到数据库表。例如，Django ORM 的 <code>models.Model</code> 就是通过元类实现的。当你定义 <code>class User(models.Model): ...</code> 时，元类会解析你的字段定义，并为其生成对应的数据库列以及 <code>save</code>, <code>filter</code> 等方法。</p>
</li>
<li><p><strong>单例模式</strong>：如上例所示，可以强制一个类只能有一个实例。</p>
</li>
<li><p><strong>插件系统</strong>：可以动态地发现并加载所有继承某个基类的插件。</p>
</li>
</ol>
<p><strong>然而，请记住：</strong></p>
<ul>
<li>元类是强大的，但也是复杂的。它们会增加代码的复杂性和理解难度。</li>
<li><strong>不要过度使用元类。</strong> 大部分情况下，继承、类装饰器甚至普通的函数就能解决问题。</li>
<li>只有当需要<strong>在类创建时修改类本身或其行为</strong>时，才考虑元类。</li>
</ul>
<h2 id="6-与类装饰器、继承的比较"><a href="#6-与类装饰器、继承的比较" class="headerlink" title="6. 与类装饰器、继承的比较"></a>6. 与类装饰器、继承的比较</h2><table>
<thead>
<tr>
<th align="left">特性&#x2F;功能</th>
<th align="left">元类 (Metaclass)</th>
<th align="left">类装饰器 (Class Decorator)</th>
<th align="left">继承 (Inheritance)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用时机</strong></td>
<td align="left"><strong>类创建时</strong>（在 <code>class</code> 语句执行时）</td>
<td align="left"><strong>类定义后</strong>（在类对象创建完成后）</td>
<td align="left">运行时，实例创建时</td>
</tr>
<tr>
<td align="left"><strong>影响范围</strong></td>
<td align="left">控制<strong>如何创建类</strong>本身，影响所有实例和类本身的行为</td>
<td align="left">接受一个已创建的类，返回一个新类或修改后的类</td>
<td align="left">改变子类的行为，通过方法重写、属性覆盖</td>
</tr>
<tr>
<td align="left"><strong>修改能力</strong></td>
<td align="left">可以修改 <code>类</code> 的 <code>__dict__</code>、基类、名称等，<strong>完全控制类创建过程</strong></td>
<td align="left">对已创建的类进行修改（如添加方法、属性）</td>
<td align="left">通过子类定义，增加或修改父类的属性和方法</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">框架级、ORM、自动注册、强制类结构、单例等</td>
<td align="left">常用工具、日志、权限、接口检查、添加 mixin</td>
<td align="left">代码复用、多态、LSP、组织代码结构</td>
</tr>
<tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left"><strong>高</strong>，引入了额外的抽象层</td>
<td align="left"><strong>中等</strong></td>
<td align="left"><strong>低-中等</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">仅在必要时使用（高级框架）</td>
<td align="left">常用，替代部分元类功能</td>
<td align="left">最常用，面向对象编程基石</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li><strong>继承</strong>是 Python 中最基本和常用的代码重用机制，用于定义“is-a”关系。</li>
<li><strong>类装饰器</strong>是在类已经完全创建之后，对其进行“包装”或“修改”。它比元类更简单，可以处理许多本需要元类才能解决的问题。</li>
<li><strong>元类</strong>则是在类诞生的那一刻就介入，控制着类的整个生产流程。</li>
</ul>
<p>如果你需要一个通用机制，让<strong>每个特定类或子类</strong>都能拥有一些额外的属性或方法，<strong>继承通常是最好的选择</strong>。<br>如果需要对<strong>某个特定的类</strong>进行非侵入性的修改或增强，<strong>类装饰器更简洁</strong>。<br>只有当你需要<strong>影响所有类的创建方式</strong>（无论它们是否通过继承共享基类，或是需要影响类的 <code>__dict__</code>、<code>bases</code> 等<strong>核心定义结构</strong>）时，才应该考虑元类。</p>
<h2 id="7-实例与类创建的流程回顾"><a href="#7-实例与类创建的流程回顾" class="headerlink" title="7. 实例与类创建的流程回顾"></a>7. 实例与类创建的流程回顾</h2><p>理解元类，最好回顾一下 Python 对象、类和元类之间的关系及创建流程：</p>
<ol>
<li><p><strong>定义一个类 <code>MyClass</code></strong>：</p>
<ul>
<li>Python 解释器发现 <code>class MyClass(metaclass=MyMeta): ...</code>。</li>
<li>它首先找到 <code>MyMeta</code> 这个元类。</li>
<li><strong>调用 <code>MyMeta.__prepare__</code></strong>：准备类的字典，默认是 <code>dict</code>。</li>
<li><strong>执行类体代码</strong>：将 <code>version = 1.0</code> 和 <code>greeting</code> 方法加入到准备好的字典中。</li>
<li><strong>调用 <code>MyMeta.__new__(MyMeta, &quot;MyClass&quot;, (object,), class_dict)</code></strong>：<code>MyMeta</code> 的 <code>__new__</code> 方法被调用。它会在此时创建 <code>MyClass</code> <strong>类对象</strong>。</li>
<li><strong>调用 <code>MyMeta.__init__(MyClass_obj, &quot;MyClass&quot;, (object,), class_dict)</code></strong>：<code>MyMeta</code> 的 <code>__init__</code> 方法被调用，用于初始化已经创建好的 <code>MyClass</code> 类对象。</li>
<li><strong>返回 <code>MyClass</code> 类对象</strong>。</li>
</ul>
</li>
<li><p><strong>创建 <code>MyClass</code> 的实例 <code>my_instance = MyClass()</code></strong>：</p>
<ul>
<li>Python 解释器发现 <code>MyClass()</code>，它会去调用 <code>MyClass</code> 这个类对象本身的 <code>__call__</code> 方法。</li>
<li>由于 <code>MyClass</code> 是由 <code>MyMeta</code> 创建的，<code>MyClass</code> 的 <code>__call__</code> 方法继承自 <code>MyMeta</code>（或 <code>type</code>）。</li>
<li><strong>调用 <code>MyMeta.__call__(MyClass, *args, **kwargs)</code></strong>：<ul>
<li>它首先会调用 <code>MyClass.__new__(MyClass, *args, **kwargs)</code> 来创建实例对象（<code>MyClass</code> 自己的 <code>__new__</code> 方法，如果定义了）。</li>
<li>如果 <code>MyClass.__new__</code> 返回的是 <code>MyClass</code> 的实例，它会接着调用 <code>MyClass.__init__(instance_obj, *args, **kwargs)</code> 来初始化实例对象。</li>
<li><strong>返回实例对象 <code>my_instance</code></strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这个流程图可以帮助你清晰地理解各个方法在哪个阶段发挥作用。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>元类是 Python 面向对象编程中最具魔力的特性之一，它将“一切皆对象”的哲学推向了极致。掌握元类，意味着你对 Python 对象的创建和生命周期有了更深层次的理解和掌控。然而，就像其他强大的工具一样，元类也需要谨慎使用。在决定使用元类之前，请始终评估是否可以通过继承或类装饰器来实现相同的功能。只有当你的需求确实落入元类的独特领域时，它才是你的最佳选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://teatang.github.io/t-blog">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://teatang.github.io/t-blog/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">https://teatang.github.io/t-blog/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://teatang.github.io/t-blog" target="_blank">T维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/t-blog/tags/2023/">2023</a><a class="post-meta__tags" href="/t-blog/tags/Python/">Python</a></div><div class="post-share"><div class="social-share" data-image="/t-blog/img/cover/default_cover-07.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/t-blog/2023/2023-02-10_Python%E7%A5%9E%E5%BA%93Pydantic%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%AE%BE%E7%BD%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/" title="Python神库Pydantic深度解析：数据验证与设置管理的利器"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/t-blog/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python神库Pydantic深度解析：数据验证与设置管理的利器</div></div><div class="info-2"><div class="info-item-1">Python Pydantic 库深度解析：数据验证与设置管理的利器 Pydantic 是一个功能强大且广受欢迎的 Python 库，它使用 Python 类型提示来进行数据验证、序列化和反序列化。Pydantic 强制执行类型提示，并在数据无效时提供友好的错误报告，极大地简化了数据处理、API 请求体验证和配置管理等任务。   1. 为什么选择 Pydantic？在现代 Python 应用开发中，数据从多种来源流入（API 请求、数据库查询、配置文件、第三方服务等），其结构和类型可能不完全符合预期。这导致了对数据验证的强烈需求。Pydantic 的出现，优雅地解决了这个问题：  强制类型提示：利用 Python 3.6+ 的类型提示，在运行时进行数据验证。 自动数据转换：在可能的情况下，Pydantic 会自动将数据转换为正确的类型（例如，将 &quot;123&quot; 转换为 123）。 清晰的错误报告：当数据验证失败时，Pydantic 会生成详细、易于理解的错误信息。 与 FastAPI 无缝集成：FastAPI 框架将 Pydantic 作为其核心组件，用于请求体、...</div></div></div></a><a class="pagination-related" href="/t-blog/2023/2023-02-05_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8EDockerfile%E5%88%B0%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-15.jpg" onerror="onerror=null;src='/t-blog/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/t-blog/2023/2023-02-10_Python%E7%A5%9E%E5%BA%93Pydantic%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%AE%BE%E7%BD%AE%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%A9%E5%99%A8/" title="Python神库Pydantic深度解析：数据验证与设置管理的利器"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-10</div><div class="info-item-2">Python神库Pydantic深度解析：数据验证与设置管理的利器</div></div><div class="info-2"><div class="info-item-1">Python Pydantic 库深度解析：数据验证与设置管理的利器 Pydantic 是一个功能强大且广受欢迎的 Python 库，它使用 Python 类型提示来进行数据验证、序列化和反序列化。Pydantic 强制执行类型提示，并在数据无效时提供友好的错误报告，极大地简化了数据处理、API 请求体验证和配置管理等任务。   1. 为什么选择 Pydantic？在现代 Python 应用开发中，数据从多种来源流入（API 请求、数据库查询、配置文件、第三方服务等），其结构和类型可能不完全符合预期。这导致了对数据验证的强烈需求。Pydantic 的出现，优雅地解决了这个问题：  强制类型提示：利用 Python 3.6+ 的类型提示，在运行时进行数据验证。 自动数据转换：在可能的情况下，Pydantic 会自动将数据转换为正确的类型（例如，将 &quot;123&quot; 转换为 123）。 清晰的错误报告：当数据验证失败时，Pydantic 会生成详细、易于理解的错误信息。 与 FastAPI 无缝集成：FastAPI 框架将 Pydantic 作为其核心组件，用于请求体、...</div></div></div></a><a class="pagination-related" href="/t-blog/2023/2023-01-26_%E4%BB%8E%E5%8D%95%E6%9C%BA%E5%88%B0%E5%93%A8%E5%85%B5%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85redis%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="从单机到哨兵，一张图理清redis架构演进！"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-26</div><div class="info-item-2">从单机到哨兵，一张图理清redis架构演进！</div></div><div class="info-2"><div class="info-item-1">Redis 的架构是逐步演进而来的，正所谓“罗马不是一天建成的”。   2010 年：单机版 Redis  当 Redis1.0在 2010 年首次发布时，整体架构非常简单，通常作为业务系统的缓存使用。不过，Redis 的数据是存储在内存中的，一旦重启，数据就会全部丢失，导致请求会直接打到数据库上，带来较大的压力。  2013 年：持久化机制上线  2013 年，Redis2.8版本发布，解决了之前“重启就丢数据”的问题。Redis 引入了 RDB（内存快照）机制，用于定时将内存中的数据持久化到磁盘。同时还支持 AOF（只追加文件）方式，将每一次写操作都记录到日志文件中，实现更高级别的持久化保障。  2013 年：主从复制机制  同样在 Redis2.8中，官方引入了主从复制功能，提升了系统的高可用性。主节点负责处理实时的读写请求，从节点则负责同步主节点的数据，起到备份和读扩展的作用。  2013 年：Sentinel 哨兵机制上线  在 Redis2.8版本中，引入了 Sentinel（哨兵）机制，用于实时监控 Redis 实例的运行状态。它主要负责以下几个方面的工作：   监...</div></div></div></a><a class="pagination-related" href="/t-blog/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL 索引详解"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="info-item-2">MySQL 索引详解</div></div><div class="info-2"><div class="info-item-1"> 索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I&#x2F;O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。  “好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言   一、什么是索引？索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用它来快速定位数据。可以将其类比为一本书的目录，通过目录我们可以快速找到感兴趣的章节，而不需要通读整本书。 在数据库中，没有索引的查询需要全表扫描，即逐行检查每条记录，直到找到符合条件的记录。当数据量非常大时，这种操作的效率会非常低下。索引通过创建指向数据物理位置的指针，使得数据库在查询时能够直接跳转到相关记录，从而大大加快查询速度。 二、索引的优缺点优点 显著提高数据检索速度：这是索引最核心、最主要的优点。 加快表与表之间的连接速度：对于 JOIN 操作，索引可以加速连接条件的匹配。 加快分组和排序操作：GROUP BY 和 ORDER BY 操作通常通过消除临时表和对文件进行排序来提高...</div></div></div></a><a class="pagination-related" href="/t-blog/2023/2023-02-01_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%9A%E6%89%93%E9%80%A0%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/" title="Docker镜像构建与管理：打造标准化、可复用的容器镜像"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">Docker镜像构建与管理：打造标准化、可复用的容器镜像</div></div><div class="info-2"><div class="info-item-1"> 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  Docker 镜像构建与管理：打造标准化、可复用的容器镜像开篇：你是否也在镜像管理上栽过跟头？凌晨 2 点，生产环境突然告警，新部署的容器启动失败。排查后发现：开发环境用的镜像 800MB，生产环境的却有 3.2GB，里面塞满了编译工具、测试数据，甚至还有开发同学的 SSH 私钥… 这种 “镜像肥胖症” 你遇到过吗？或者更糟糕的：  同一个服务，测试环境能跑，生产环境启动就报错 镜像仓库里堆满了 latest、v1、v1-final、v1-final-final 这种让人崩溃的标签 构建一次镜像要等 20 分钟，因为每次都要重新下载依赖包  今天这篇文章，我会基于 5 年运维实战经验，教你构建一套标准化的镜像管理体系：从多阶段构建优化到镜像安全扫描，从版本管理策略到自动化构建流程，让你的镜像体积缩小 70%、构建速度提升 5 倍，并且永远不会再出现 “这个镜像到底能不能用” 的灵魂拷问。 一、镜像构建的三大核心原则（90% 的人都忽略了）1. 最小化原则：镜像里只放 “必需品”很多人写 Doc...</div></div></div></a><a class="pagination-related" href="/t-blog/2023/2023-02-05_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8EDockerfile%E5%88%B0%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a><a class="pagination-related" href="/t-blog/2023/2023-03-04_%E5%8F%91%E9%9F%B3%E8%AE%B0%E5%BF%86%E6%B3%95%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%91%E9%9F%B3%E9%AB%98%E6%95%88%E8%AE%B0%E5%BF%86%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/" title="发音记忆法：如何通过发音高效记忆英语单词的详细教程"><img class="cover" src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="info-item-2">发音记忆法：如何通过发音高效记忆英语单词的详细教程</div></div><div class="info-2"><div class="info-item-1"> 许多人在学习英语单词时，习惯性地只看字母组合，导致背了就忘，而且容易拼写错误。这篇教程旨在改变这种低效的学习方式，教你如何以发音为核心，结合音标、自然拼读和听力，构建一套高效、持久的单词记忆策略。  英语作为一门拼音文字，其单词的拼写和发音之间存在着内在的规律。掌握这些规律，将单词的“形”、“音”、“义”紧密结合，可以大大提升记忆效率和准确性。通过发音来记忆单词，不仅能帮助你更好地拼写，还能提高听力理解和口语表达能力。   一、为什么只看字母记单词效率低下？传统的“死记硬背”方式通常关注字母顺序，例如：beautiful → B-E-A-U-T-I-F-U-L 美丽的 这种方法存在以下问题：  脱离语境：字母组合是抽象的，没有实际的语境或声音联系，大脑难以建立有效记忆。 效率低下：每个单词都需要单独记忆字母序列，记忆量大，复习周期长。 容易混淆：相似字母组合的单词（如 through, thorough, though）极易混淆。 发音障碍：不了解发音规律，见到生词不敢读，听力理解也受到影响。 拼写错误：由于不熟悉形音对应，拼写时容易出错。  而通过发音记忆，我们关注的是：be...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/avatar.jpg" onerror="this.onerror=null;this.src='/t-blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/t-blog/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/t-blog/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/t-blog/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>主題 GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/t-blog/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-%E5%85%83%E7%B1%BB%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E5%AE%9E%E6%88%98"><span class="toc-text">Python 元类深度解析：从概念到实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%B1%BB%EF%BC%9F"><span class="toc-text">1. 什么是元类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-type-%E5%85%83%E7%B1%BB%EF%BC%9A%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B1%BB"><span class="toc-text">2. type 元类：你的第一个元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%EF%BC%9A%E6%8E%8C%E6%8E%A7%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">3. 自定义元类：掌控类的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB"><span class="toc-text">3.1 定义一个简单的自定义元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-prepare-%E6%96%B9%E6%B3%95-Python-3-6"><span class="toc-text">3.2 __prepare__ 方法 (Python 3.6+)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-call-%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">4. __call__ 方法：控制实例创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB%EF%BC%9F"><span class="toc-text">5. 什么时候需要使用元类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%8E%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">6. 与类装饰器、继承的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E4%BE%8B%E4%B8%8E%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%9E%E9%A1%BE"><span class="toc-text">7. 实例与类创建的流程回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/t-blog/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准"><img src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/t-blog/img/404.jpg'" alt="WSL2详解：在Windows运行Linux的新标准"/></a><div class="content"><a class="title" href="/t-blog/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准">WSL2详解：在Windows运行Linux的新标准</a><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/t-blog/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/t-blog/img/404.jpg'" alt="GoLang Wails 框架详解：用 Web 技术构建桌面应用"/></a><div class="content"><a class="title" href="/t-blog/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用">GoLang Wails 框架详解：用 Web 技术构建桌面应用</a><time datetime="2025-09-17T22:24:00.000Z" title="发表于 2025-09-18 06:24:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/t-blog/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"><img src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/t-blog/img/404.jpg'" alt="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"/></a><div class="content"><a class="title" href="/t-blog/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化">Redis持久化深度解析：RDB与AOF的终极对决与实战优化</a><time datetime="2025-09-13T22:24:00.000Z" title="发表于 2025-09-14 06:24:00">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/t-blog/2025/2025-09-05_Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title="Go 语言协程设计与调度原理"><img src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/t-blog/img/404.jpg'" alt="Go 语言协程设计与调度原理"/></a><div class="content"><a class="title" href="/t-blog/2025/2025-09-05_Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title="Go 语言协程设计与调度原理">Go 语言协程设计与调度原理</a><time datetime="2025-09-04T22:24:00.000Z" title="发表于 2025-09-05 06:24:00">2025-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/t-blog/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"><img src="/t-blog/img/loading.gif" data-lazy-src="/t-blog/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/t-blog/img/404.jpg'" alt="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"/></a><div class="content"><a class="title" href="/t-blog/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用">Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用</a><time datetime="2025-09-03T22:24:00.000Z" title="发表于 2025-09-04 06:24:00">2025-09-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/t-blog/img/cover/default_cover-07.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/t-blog/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/t-blog/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/t-blog/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/t-blog/categories/" target="_blank" title="分类">分类</a><a href="/t-blog/tags/" target="_blank" title="标签">标签</a><a href="/t-blog/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/t-blog/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2022 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/t-blog/js/utils.js"></script><script src="/t-blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/t-blog/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/t-blog/404.html') : window.location.href = '/t-blog/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/t-blog/js/search/local-search.js"></script></div></div></body></html>