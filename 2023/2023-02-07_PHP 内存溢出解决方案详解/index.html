<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PHP 内存溢出解决方案详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PHP 内存溢出 (Memory Exhausted) 是 PHP 应用程序开发中一个常见的问题，通常表现为 Fatal error: Allowed memory size of X bytes exhausted。这意味着 PHP 脚本在执行过程中尝试分配的内存超出了配置允许的最大值。理解其原因并掌握有效的解决方案对于构建稳定、高性能的 PHP 应用至关重要。  核心思想：PHP 内存溢出通">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP 内存溢出解决方案详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2023/2023-02-07_PHP%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="PHP 内存溢出 (Memory Exhausted) 是 PHP 应用程序开发中一个常见的问题，通常表现为 Fatal error: Allowed memory size of X bytes exhausted。这意味着 PHP 脚本在执行过程中尝试分配的内存超出了配置允许的最大值。理解其原因并掌握有效的解决方案对于构建稳定、高性能的 PHP 应用至关重要。  核心思想：PHP 内存溢出通">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg">
<meta property="article:published_time" content="2023-02-06T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-31T09:32:56.289Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="PHP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PHP 内存溢出解决方案详解",
  "url": "https://blog.tbf1211.xx.kg/2023/2023-02-07_PHP%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg",
  "datePublished": "2023-02-06T22:24:00.000Z",
  "dateModified": "2025-10-31T09:32:56.289Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2023/2023-02-07_PHP%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PHP 内存溢出解决方案详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">170</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">PHP 内存溢出解决方案详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PHP 内存溢出解决方案详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-06T22:24:00.000Z" title="发表于 2023-02-07 06:24:00">2023-02-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PHP/">PHP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2023/2023-02-07_PHP%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>PHP 内存溢出 (Memory Exhausted)</strong> 是 PHP 应用程序开发中一个常见的问题，通常表现为 <code>Fatal error: Allowed memory size of X bytes exhausted</code>。这意味着 PHP 脚本在执行过程中尝试分配的内存超出了配置允许的最大值。理解其原因并掌握有效的解决方案对于构建稳定、高性能的 PHP 应用至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>PHP 内存溢出通常源于：1. 配置限制；2. 代码中大量数据处理或未释放的资源；3. 内存泄漏。解决的关键在于合理配置、优化代码和有效管理内存。</strong></p>
</div>
<hr>
<h2 id="一、理解-PHP-内存溢出的原因"><a href="#一、理解-PHP-内存溢出的原因" class="headerlink" title="一、理解 PHP 内存溢出的原因"></a>一、理解 PHP 内存溢出的原因</h2><p>PHP 内存溢出主要有以下几方面的原因：</p>
<ol>
<li><strong>PHP 配置限制</strong>：<ul>
<li><code>memory_limit</code> 配置项：这是 PHP 限制单个脚本可以使用的最大内存量。如果脚本尝试使用的内存超过这个值，就会触发内存溢出错误。</li>
<li>服务器资源限制：即使 <code>memory_limit</code> 很高，宿主机本身的内存资源也有限。</li>
</ul>
</li>
<li><strong>代码层面问题</strong>：<ul>
<li><strong>处理大量数据</strong>：一次性从数据库中查询大量记录、处理大型文件、或对大型数组&#x2F;字符串进行操作，都可能导致内存瞬时暴增。</li>
<li><strong>递归调用过深</strong>：无限或过深的递归调用会迅速耗尽栈内存。</li>
<li><strong>循环中不断累积数据</strong>：在循环中不断向数组添加元素，或不断创建新对象而没有及时释放，最终导致内存耗尽。</li>
<li><strong>内存泄漏 (Memory Leak)</strong>：指程序在运行过程中，分配的内存不再使用后，没有被及时释放，导致内存占用持续增长。在 PHP 中，虽然有垃圾回收机制，但在某些复杂场景下仍可能出现。</li>
<li><strong>对象循环引用</strong>：在 PHP 5.3+ 中，循环引用可以通过垃圾回收器（GC）处理，但在 GC 运行周期之间，内存可能暂时未被释放。</li>
<li><strong>不恰当的缓存</strong>：将大量数据永久缓存在内存中。</li>
</ul>
</li>
<li><strong>第三方库&#x2F;框架问题</strong>：<ul>
<li>某些第三方库可能存在内存优化不足或内存泄漏的问题。</li>
</ul>
</li>
</ol>
<h2 id="二、解决方案详解"><a href="#二、解决方案详解" class="headerlink" title="二、解决方案详解"></a>二、解决方案详解</h2><p>解决 PHP 内存溢出需要从配置、代码优化和内存管理多个层面入手。</p>
<h3 id="2-1-调整-PHP-配置-php-ini"><a href="#2-1-调整-PHP-配置-php-ini" class="headerlink" title="2.1 调整 PHP 配置 (php.ini)"></a>2.1 调整 PHP 配置 (<code>php.ini</code>)</h3><p>这是最直接但通常是治标不治本的方法。在确认代码本身没有严重问题后，可以适当调整。</p>
<ul>
<li><strong><code>memory_limit</code></strong>：<ul>
<li><strong>作用</strong>：设置单个 PHP 脚本允许使用的最大内存量。</li>
<li><strong>修改方式</strong>：<ol>
<li><strong><code>php.ini</code> 文件</strong>：找到 <code>memory_limit</code> 配置项，例如 <code>memory_limit = 256M</code>。</li>
<li><strong><code>httpd.conf</code> 或 <code>.htaccess</code></strong> (仅对 Apache)：<code>php_value memory_limit 256M</code>。</li>
<li><strong>代码中动态设置</strong>：<code>ini_set(&#39;memory_limit&#39;, &#39;256M&#39;);</code>（仅在允许 <code>ini_set</code> 的情况下有效，并且只能增加，不能减少已分配的内存）。</li>
</ol>
</li>
<li><strong>建议</strong>：根据应用程序的实际需求和服务器的物理内存，设置一个合理的值。<strong>不建议设置过高（如 -1 表示无限制）</strong>，因为这可能导致单个脚本耗尽整个服务器内存，影响其他应用甚至导致服务器崩溃。</li>
<li><strong>注意</strong>：修改 <code>php.ini</code> 后需要重启 PHP 服务（如 PHP-FPM, Apache）才能生效。</li>
</ul>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临时提高内存限制 (仅在当前脚本会话中有效)</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;memory_limit&#x27;</span>, <span class="string">&#x27;512M&#x27;</span>); </span><br></pre></td></tr></table></figure>

<h3 id="2-2-代码优化与内存管理"><a href="#2-2-代码优化与内存管理" class="headerlink" title="2.2 代码优化与内存管理"></a>2.2 代码优化与内存管理</h3><p>这是解决内存溢出的根本方法，也是最推荐的方案。</p>
<h4 id="2-2-1-分批处理-Batch-Processing"><a href="#2-2-1-分批处理-Batch-Processing" class="headerlink" title="2.2.1 分批处理 (Batch Processing)"></a>2.2.1 分批处理 (Batch Processing)</h4><p>当需要处理大量数据时，不要一次性加载所有数据到内存中，而是分批读取和处理。</p>
<ul>
<li><p><strong>数据库查询</strong>：</p>
<ul>
<li>使用 <code>LIMIT</code> 和 <code>OFFSET</code> 或游标 (Cursor) 进行分页查询。</li>
<li><strong>PDO</strong>：可以通过 <code>PDO::FETCH_ASSOC</code> 配合循环来逐行获取，避免 <code>fetchAll()</code> 一次性加载所有结果。对于 MySQL，使用 <code>PDO::MYSQL_ATTR_USE_BUFFERED_QUERY =&gt; false</code> 可以避免 PHP 缓冲区一次性读取所有结果集。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad (可能一次性加载所有结果)</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SELECT * FROM large_table&#x27;</span>);</span><br><span class="line"><span class="variable">$allData</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetchAll</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Good (分批处理)</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;SELECT * FROM large_table LIMIT :limit OFFSET :offset&#x27;</span>);</span><br><span class="line"><span class="variable">$limit</span> = <span class="number">1000</span>;</span><br><span class="line"><span class="variable">$offset</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&#x27;:limit&#x27;</span>, <span class="variable">$limit</span>, PDO::<span class="variable constant_">PARAM_INT</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&#x27;:offset&#x27;</span>, <span class="variable">$offset</span>, PDO::<span class="variable constant_">PARAM_INT</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">    <span class="variable">$rows</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetchAll</span>(PDO::<span class="variable constant_">FETCH_ASSOC</span>); <span class="comment">// 读取一批</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$rows</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$rows</span> <span class="keyword">as</span> <span class="variable">$row</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理每一行数据</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Processing row ID: &quot;</span> . <span class="variable">$row</span>[<span class="string">&#x27;id&#x27;</span>] . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$offset</span> += <span class="variable">$limit</span>;</span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$rows</span>); </span><br><span class="line">    <span class="title function_ invoke__">gc_collect_cycles</span>(); <span class="comment">// 强制垃圾回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Eloquent (Laravel)</strong>：使用 <code>cursor()</code> 或 <code>chunk()</code> 方法。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="variable">$users</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">all</span>(); <span class="comment">// 可能加载所有用户到内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good (使用 chunk 分批处理)</span></span><br><span class="line"><span class="title class_">User</span>::<span class="title function_ invoke__">chunk</span>(<span class="number">1000</span>, function (<span class="variable">$users</span>) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$users</span> <span class="keyword">as</span> <span class="variable">$user</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理每个用户</span></span><br><span class="line">        <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// $users 变量在每次迭代结束后会被重新赋值，旧的引用会减少。</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Best (使用 cursor 迭代器)</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="title class_">User</span>::<span class="title function_ invoke__">cursor</span>() <span class="keyword">as</span> <span class="variable">$user</span>) &#123;</span><br><span class="line">    <span class="comment">// 逐个处理用户，每次只加载一个用户对象到内存</span></span><br><span class="line">    <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件处理</strong>：使用 <code>fgets()</code> 或 <code>file()</code> 配合迭代器逐行读取大文件，而不是 <code>file_get_contents()</code> 一次性读取。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;large_file.txt&#x27;</span>);</span><br><span class="line"><span class="variable">$lines</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&quot;\n&quot;</span>, <span class="variable">$content</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="variable">$handle</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;large_file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$handle</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="variable">$line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$handle</span>)) !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理每一行</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Processing line: &quot;</span> . <span class="variable">$line</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$handle</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-2-及时释放变量和资源"><a href="#2-2-2-及时释放变量和资源" class="headerlink" title="2.2.2 及时释放变量和资源"></a>2.2.2 及时释放变量和资源</h4><ul>
<li><strong><code>unset()</code></strong>：当不再需要某个大变量时，使用 <code>unset()</code> 显式地解除变量绑定。这会减少变量的引用计数，使其有机会被垃圾回收器回收。<ul>
<li><strong>注意</strong>：<code>unset()</code> 只是解除变量绑定，并不直接释放内存。内存的实际释放由 PHP 的垃圾回收机制决定。</li>
</ul>
</li>
<li><strong>资源句柄</strong>：及时关闭文件句柄、数据库连接、图片资源等。<ul>
<li>文件：<code>fclose($handle)</code></li>
<li>数据库：<code>$pdo = null;</code> 或 <code>mysqli_close($conn);</code></li>
<li>图片：<code>imagedestroy($image)</code></li>
</ul>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processImages</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$imagePaths</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$imagePaths</span> <span class="keyword">as</span> <span class="variable">$path</span>) &#123;</span><br><span class="line">        <span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$path</span>);</span><br><span class="line">        <span class="comment">// ... 对图片进行操作 ...</span></span><br><span class="line">        <span class="title function_ invoke__">imagejpeg</span>(<span class="variable">$img</span>, <span class="string">&#x27;processed_&#x27;</span> . <span class="title function_ invoke__">basename</span>(<span class="variable">$path</span>));</span><br><span class="line">        <span class="title function_ invoke__">imagedestroy</span>(<span class="variable">$img</span>); <span class="comment">// 及时释放图片资源</span></span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable">$img</span>); <span class="comment">// 解除变量绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-避免不必要的数据复制"><a href="#2-2-3-避免不必要的数据复制" class="headerlink" title="2.2.3 避免不必要的数据复制"></a>2.2.3 避免不必要的数据复制</h4><ul>
<li><p><strong>传值与传引用</strong>：在函数参数传递时，如果需要处理大对象或大数组，考虑使用<strong>引用传递 <code>&amp;</code></strong> 来避免数据的复制（但需注意副作用）。</p>
<ul>
<li>PHP 7.0+ 版本在内部对函数参数的传值语义进行了优化，对于一些非标量值（如数组和对象），在函数内部不修改的情况下，通常不会立即进行复制（写时复制 Copy-on-Write）。但在修改时仍会复制。</li>
<li>对于超大数组或对象，引用传递依然可以节省内存。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">&amp;<span class="variable">$data</span></span>) </span>&#123; <span class="comment">// 引用传递</span></span><br><span class="line">    <span class="comment">// ... 修改 $data，不会创建副本 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-4-优化数据结构和算法"><a href="#2-2-4-优化数据结构和算法" class="headerlink" title="2.2.4 优化数据结构和算法"></a>2.2.4 优化数据结构和算法</h4><ul>
<li><p><strong>减少大数组&#x2F;对象的创建</strong>：仔细检查循环中是否有不必要的数组或对象创建。</p>
</li>
<li><p><strong>使用迭代器</strong>：对于需要遍历的数据集，使用迭代器 (Generator) 可以按需生成数据，而不是一次性生成所有数据。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad (一次性生成所有数据到内存)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateLargeArray</span>(<span class="params"><span class="variable">$n</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$arr</span> = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$arr</span>[] = <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good (使用生成器按需生成数据)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateLargeData</span>(<span class="params"><span class="variable">$n</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable">$i</span>; <span class="comment">// 每次只生成一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">generateLargeData</span>(<span class="number">1000000</span>) <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 $value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>哈希表 vs 数组</strong>：对于关联数组，如果键的类型和数量合适，哈希表的内存效率通常较高。</p>
</li>
</ul>
<h4 id="2-2-5-避免无限递归"><a href="#2-2-5-避免无限递归" class="headerlink" title="2.2.5 避免无限递归"></a>2.2.5 避免无限递归</h4><ul>
<li>确保所有递归函数都有明确的终止条件。</li>
<li>对于可能深度很大的递归，考虑将其转换为迭代形式，或者增加 PHP 配置中的 <code>xdebug.max_nesting_level</code> (仅限开发环境) 和 <code>pcre.recursion_limit</code>。</li>
</ul>
<h4 id="2-2-6-垃圾回收机制-Garbage-Collection"><a href="#2-2-6-垃圾回收机制-Garbage-Collection" class="headerlink" title="2.2.6 垃圾回收机制 (Garbage Collection)"></a>2.2.6 垃圾回收机制 (Garbage Collection)</h4><p>PHP 5.3+ 引入了垃圾回收机制来处理循环引用导致的内存泄漏。</p>
<ul>
<li><p><strong>工作原理</strong>：当变量的引用计数降为 0 时，其占用的内存会被立即释放。但对于循环引用（例如对象 A 引用对象 B，对象 B 引用对象 A），即使它们外部的引用都降为 0，它们内部的引用计数也不会降为 0，导致内存无法释放。GC 会周期性地检查这些“根缓冲区”中的变量，找出循环引用并回收。</p>
</li>
<li><p><strong>手动触发</strong>：<code>gc_collect_cycles()</code> 函数可以强制运行垃圾回收器。这在长运行脚本或循环中处理大量数据时非常有用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个大型循环的末尾，可以考虑手动触发垃圾回收</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">10000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$object</span> = <span class="keyword">new</span> <span class="title class_">MyLargeObject</span>();</span><br><span class="line">    <span class="comment">// ... 处理 $object ...</span></span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$object</span>); <span class="comment">// 解除引用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span> % <span class="number">1000</span> == <span class="number">0</span>) &#123; <span class="comment">// 每处理1000个对象，强制垃圾回收</span></span><br><span class="line">        <span class="title function_ invoke__">gc_collect_cycles</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-7-使用外部存储"><a href="#2-2-7-使用外部存储" class="headerlink" title="2.2.7 使用外部存储"></a>2.2.7 使用外部存储</h4><p>对于需要在脚本执行期间维护大量状态或缓存数据的场景，考虑使用：</p>
<ul>
<li><strong>缓存系统</strong>：Redis, Memcached 等内存数据库，将数据存储在外部，减少 PHP 脚本本身的内存占用。</li>
<li><strong>文件系统</strong>：将中间结果写入文件，避免在内存中积累。</li>
</ul>
<h3 id="2-3-调试和分析工具"><a href="#2-3-调试和分析工具" class="headerlink" title="2.3 调试和分析工具"></a>2.3 调试和分析工具</h3><p>当发生内存溢出时，定位问题代码至关重要。</p>
<ul>
<li><p><strong><code>memory_get_usage()</code> 和 <code>memory_get_peak_usage()</code></strong>：</p>
<ul>
<li>在代码的关键点使用这两个函数来记录当前的内存使用量和峰值内存使用量。</li>
<li>可以帮助你找出是哪段代码导致了内存的急剧增长。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Initial memory: &quot;</span> . <span class="title function_ invoke__">memory_get_usage</span>() / (<span class="number">1024</span> * <span class="number">1024</span>) . <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$largeArray</span> = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">100000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$largeArray</span>[] = <span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>); <span class="comment">// 制造一个大数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;After array creation: &quot;</span> . <span class="title function_ invoke__">memory_get_usage</span>() / (<span class="number">1024</span> * <span class="number">1024</span>) . <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Peak memory: &quot;</span> . <span class="title function_ invoke__">memory_get_peak_usage</span>() / (<span class="number">1024</span> * <span class="number">1024</span>) . <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$largeArray</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;After unset: &quot;</span> . <span class="title function_ invoke__">memory_get_usage</span>() / (<span class="number">1024</span> * <span class="number">1024</span>) . <span class="string">&quot; MB\n&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">gc_collect_cycles</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;After GC: &quot;</span> . <span class="title function_ invoke__">memory_get_usage</span>() / (<span class="number">1024</span> * <span class="number">1024</span>) . <span class="string">&quot; MB\n&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Xdebug 分析器 (Profiler)</strong>：</p>
<ul>
<li>Xdebug 提供了强大的性能分析功能，可以生成调用图和内存使用报告。</li>
<li>通过工具（如 WinCacheGrind, KCachegrind）分析这些报告，可以清晰地看到哪个函数调用了多少次、耗时多久、使用了多少内存，从而找出内存消耗的热点。</li>
<li>配置 <code>xdebug.profiler_enable = 1</code> 和 <code>xdebug.profiler_output_dir = /tmp</code>。</li>
</ul>
</li>
<li><p><strong>New Relic, Sentry 等 APM (Application Performance Monitoring) 工具</strong>：</p>
<ul>
<li>这些商业工具可以实时监控 PHP 应用的性能和内存使用情况，并提供详细的报告和警告。</li>
</ul>
</li>
</ul>
<h2 id="三、常见场景与应对策略"><a href="#三、常见场景与应对策略" class="headerlink" title="三、常见场景与应对策略"></a>三、常见场景与应对策略</h2><ol>
<li><strong>命令行脚本 (CLI)</strong>：<ul>
<li>CLI 脚本通常需要处理大量数据或长时间运行。</li>
<li>内存限制可以设置得比 Web 应用高，但仍然需要分批处理和内存管理。</li>
<li>使用 <code>gc_collect_cycles()</code> 是一个很好的实践。</li>
</ul>
</li>
<li><strong>Web 应用</strong>：<ul>
<li>每个请求都是独立的，内存通常在请求结束后释放。</li>
<li>但如果单个请求处理的数据量过大，仍然会内存溢出。</li>
<li>重点关注单次请求的内存峰值。</li>
<li>对于长连接（如 WebSocket 服务器），内存泄漏问题更为突出，需要更严格的内存管理。</li>
</ul>
</li>
<li><strong>ORM (Object-Relational Mapping)</strong>：<ul>
<li>使用 ORM 框架时，查询大量数据往往会将所有结果封装成对象，导致内存暴增。</li>
<li>务必使用 ORM 提供的分批加载 (chunk, cursor) 或延迟加载 (lazy loading) 机制。</li>
<li>例如，Laravel 的 <code>with(&#39;relation&#39;)</code> 会预加载关联数据，如果关联数据量也很大，也需要注意。</li>
</ul>
</li>
</ol>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>解决 PHP 内存溢出是一个综合性的任务，需要开发者从多个角度进行考虑：</p>
<ol>
<li><strong>先治本后治标</strong>：首先优化代码结构和数据处理逻辑，而不是盲目提高 <code>memory_limit</code>。</li>
<li><strong>分批处理是关键</strong>：对于任何可能涉及大量数据操作的场景，优先考虑分批处理或使用迭代器。</li>
<li><strong>及时释放资源</strong>：<code>unset()</code>、关闭文件句柄、断开数据库连接等操作有助于内存回收。</li>
<li><strong>善用工具</strong>：<code>memory_get_usage()</code> 和 Xdebug Profiler 是定位内存问题的利器。</li>
<li><strong>理解垃圾回收</strong>：了解 PHP 垃圾回收机制的工作方式，并在必要时手动触发 <code>gc_collect_cycles()</code>。</li>
</ol>
<p>通过上述方法，可以有效诊断和解决 PHP 内存溢出问题，提升应用程序的稳定性和性能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2023/2023-02-07_PHP%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2023/2023-02-07_PHP%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/PHP/">PHP</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Python元类(Metaclass)深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python元类(Metaclass)深度解析</div></div><div class="info-2"><div class="info-item-1">Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，它允许我们在类被创建时对其行为进行定制，是 Python 中进行高级面向对象编程的强大工具。 1. 什么是元类？在 Python 中，当你定义一个类 class MyClass: pass 的时候，Python 解释器会自动执行以下步骤：  定义一个类对象：解释器读取 MyClass 的定义，并创建一个名为 MyClass 的类对象。 将类对象绑定到命名空间：这个 MyClass 类对象被绑定到当前的命名空间中。  然后，当你通过 my_instance = MyClass() 来创建实例时，MyClass 这个类对象就会被调用，从而创建并返回一个实例对象。 元类就是用来创建这些类对象的...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-05_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8EDockerfile%E5%88%B0%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-02-24_PHP%20%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%20(Generators)%20%E8%AF%A6%E8%A7%A3/" title="PHP 惰性求值与生成器 (Generators) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-24</div><div class="info-item-2">PHP 惰性求值与生成器 (Generators) 详解</div></div><div class="info-2"><div class="info-item-1"> 惰性求值 (Lazy Evaluation) 是一种编程策略，它将表达式的计算延迟到真正需要其结果时才进行。在 PHP 中，实现惰性求值最主要的机制就是生成器 (Generators)。生成器允许开发者编写像迭代器一样遍历数据集合的函数，而无需将整个集合一次性加载到内存中。这对于处理大型数据集、无限序列或需要节省内存的场景至关重要。  核心思想：生成器通过 yield 关键字实现了惰性求值，它允许函数暂停执行并返回一个值，并在下次需要时从暂停的地方继续执行，从而按需生成数据，大幅减少内存占用。   一、理解惰性求值 (Lazy Evaluation)1.1 什么是惰性求值？传统的“饥饿求值 (Eager Evaluation)”或“及早求值”模式下，当一个函数或表达式被调用时，其所有参数都会在函数体执行前被完全计算。例如： 1234function sum(int $a, int $b): int &#123;    return $a + $b;&#125;$result = sum(expensiveCalculationA(), expensiveCalculationB...</div></div></div></a><a class="pagination-related" href="/2023/2023-03-06_PHP%20Fibers%20(%E5%8D%8F%E7%A8%8B)%20%E8%AF%A6%E8%A7%A3/" title="PHP Fibers (协程) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="info-item-2">PHP Fibers (协程) 详解</div></div><div class="info-2"><div class="info-item-1"> Fibers (协程) 是 PHP 8.1 引入的一个重要新特性，它为 PHP 带来了原生的用户空间并发能力。与传统的线程或进程不同，Fibers 允许代码在执行过程中暂停和恢复，而无需使用生成器 (Generators) 或复杂的事件循环回调。这使得开发者能够编写更具可读性和可维护性的异步非阻塞代码，从而更好地应对 I&#x2F;O 密集型任务，如网络请求、数据库查询等。  核心思想：Fibers 是一种轻量级的并发原语，允许 PHP 代码在用户空间中实现非阻塞操作，通过显式地暂停和恢复执行，简化了异步代码的编写。   一、为什么需要 Fibers？在 PHP 8.1 之前，实现异步非阻塞代码通常依赖于以下两种方式：  Callbacks (回调函数)： 优点：简单直接，适用于简单的异步操作。 缺点：容易陷入“回调地狱 (Callback Hell)”，代码可读性和维护性差，错误处理复杂。   Generators (生成器)： 优点：通过 yield 实现了伪协程，可以在一定程度上改善回调地狱，允许代码暂停和恢复。 缺点：生成器本质上是迭代器，其语义更偏向于数据生成。将生成...</div></div></div></a><a class="pagination-related" href="/2023/2023-01-26_%E4%BB%8E%E5%8D%95%E6%9C%BA%E5%88%B0%E5%93%A8%E5%85%B5%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85redis%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="从单机到哨兵，一张图理清redis架构演进！"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-26</div><div class="info-item-2">从单机到哨兵，一张图理清redis架构演进！</div></div><div class="info-2"><div class="info-item-1">Redis 的架构是逐步演进而来的，正所谓“罗马不是一天建成的”。    2010 年：单机版 Redis  当 Redis1.0在 2010 年首次发布时，整体架构非常简单，通常作为业务系统的缓存使用。不过，Redis 的数据是存储在内存中的，一旦重启，数据就会全部丢失，导致请求会直接打到数据库上，带来较大的压力。  2013 年：持久化机制上线  2013 年，Redis2.8版本发布，解决了之前“重启就丢数据”的问题。Redis 引入了 RDB（内存快照）机制，用于定时将内存中的数据持久化到磁盘。同时还支持 AOF（只追加文件）方式，将每一次写操作都记录到日志文件中，实现更高级别的持久化保障。  2013 年：主从复制机制  同样在 Redis2.8中，官方引入了主从复制功能，提升了系统的高可用性。主节点负责处理实时的读写请求，从节点则负责同步主节点的数据，起到备份和读扩展的作用。  2013 年：Sentinel 哨兵机制上线  在 Redis2.8版本中，引入了 Sentinel（哨兵）机制，用于实时监控 Redis 实例的运行状态。它主要负责以下几个方面的工作：   ...</div></div></div></a><a class="pagination-related" href="/2023/2023-01-27_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL 索引详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="info-item-2">MySQL 索引详解</div></div><div class="info-2"><div class="info-item-1"> 索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I&#x2F;O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。  “好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言   一、什么是索引？索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用它来快速定位数据。可以将其类比为一本书的目录，通过目录我们可以快速找到感兴趣的章节，而不需要通读整本书。 在数据库中，没有索引的查询需要全表扫描，即逐行检查每条记录，直到找到符合条件的记录。当数据量非常大时，这种操作的效率会非常低下。索引通过创建指向数据物理位置的指针，使得数据库在查询时能够直接跳转到相关记录，从而大大加快查询速度。 二、索引的优缺点优点 显著提高数据检索速度：这是索引最核心、最主要的优点。 加快表与表之间的连接速度：对于 JOIN 操作，索引可以加速连接条件的匹配。 加快分组和排序操作：GROUP BY 和 ORDER BY 操作通常通过消除临时表和对文件进行排序来提高...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-05_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8EDockerfile%E5%88%B0%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-01_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%9A%E6%89%93%E9%80%A0%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/" title="Docker镜像构建与管理：打造标准化、可复用的容器镜像"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">Docker镜像构建与管理：打造标准化、可复用的容器镜像</div></div><div class="info-2"><div class="info-item-1"> 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  Docker 镜像构建与管理：打造标准化、可复用的容器镜像开篇：你是否也在镜像管理上栽过跟头？凌晨 2 点，生产环境突然告警，新部署的容器启动失败。排查后发现：开发环境用的镜像 800MB，生产环境的却有 3.2GB，里面塞满了编译工具、测试数据，甚至还有开发同学的 SSH 私钥… 这种 “镜像肥胖症” 你遇到过吗？或者更糟糕的：  同一个服务，测试环境能跑，生产环境启动就报错 镜像仓库里堆满了 latest、v1、v1-final、v1-final-final 这种让人崩溃的标签 构建一次镜像要等 20 分钟，因为每次都要重新下载依赖包  今天这篇文章，我会基于 5 年运维实战经验，教你构建一套标准化的镜像管理体系：从多阶段构建优化到镜像安全扫描，从版本管理策略到自动化构建流程，让你的镜像体积缩小 70%、构建速度提升 5 倍，并且永远不会再出现 “这个镜像到底能不能用” 的灵魂拷问。 一、镜像构建的三大核心原则（90% 的人都忽略了）1. 最小化原则：镜像里只放 “必需品”很多人写 Doc...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">170</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%90%86%E8%A7%A3-PHP-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">一、理解 PHP 内存溢出的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3"><span class="toc-text">二、解决方案详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%B0%83%E6%95%B4-PHP-%E9%85%8D%E7%BD%AE-php-ini"><span class="toc-text">2.1 调整 PHP 配置 (php.ini)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">2.2 代码优化与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%88%86%E6%89%B9%E5%A4%84%E7%90%86-Batch-Processing"><span class="toc-text">2.2.1 分批处理 (Batch Processing)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%8F%8A%E6%97%B6%E9%87%8A%E6%94%BE%E5%8F%98%E9%87%8F%E5%92%8C%E8%B5%84%E6%BA%90"><span class="toc-text">2.2.2 及时释放变量和资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">2.2.3 避免不必要的数据复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-text">2.2.4 优化数据结构和算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E9%81%BF%E5%85%8D%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92"><span class="toc-text">2.2.5 避免无限递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-Garbage-Collection"><span class="toc-text">2.2.6 垃圾回收机制 (Garbage Collection)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-text">2.2.7 使用外部存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%B0%83%E8%AF%95%E5%92%8C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">2.3 调试和分析工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%BA%94%E5%AF%B9%E7%AD%96%E7%95%A5"><span class="toc-text">三、常见场景与应对策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-21.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>