<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Selenium (浏览器自动化工具) 深度解析 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Selenium 是一个功能强大的开源工具集，最初设计用于 Web 应用程序的自动化测试，但其能力远不止于此。它允许开发者像真实用户一样，直接控制浏览器执行各种操作，如点击按钮、填写表单、导航页面等。通过模拟用户与网页的交互，Selenium 成为了处理动态加载内容 (JavaScript 渲染)、实现 Web UI 自动化测试和进行高级网络爬取的关键工具。  核心思想：Selenium 通过">
<meta property="og:type" content="article">
<meta property="og:title" content="Selenium (浏览器自动化工具) 深度解析">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/51be17189d42/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Selenium 是一个功能强大的开源工具集，最初设计用于 Web 应用程序的自动化测试，但其能力远不止于此。它允许开发者像真实用户一样，直接控制浏览器执行各种操作，如点击按钮、填写表单、导航页面等。通过模拟用户与网页的交互，Selenium 成为了处理动态加载内容 (JavaScript 渲染)、实现 Web UI 自动化测试和进行高级网络爬取的关键工具。  核心思想：Selenium 通过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg">
<meta property="article:published_time" content="2025-03-28T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-31T14:22:27.355Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="测试">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="爬虫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Selenium (浏览器自动化工具) 深度解析",
  "url": "https://blog.tbf1211.xx.kg/51be17189d42/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg",
  "datePublished": "2025-03-28T22:24:00.000Z",
  "dateModified": "2025-12-31T14:22:27.355Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/51be17189d42/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Selenium (浏览器自动化工具) 深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">450</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Selenium (浏览器自动化工具) 深度解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Selenium (浏览器自动化工具) 深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-03-28T22:24:00.000Z" title="发表于 2025-03-29 06:24:00">2025-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E5%BA%93/">库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Selenium</strong> 是一个功能强大的开源工具集，最初设计用于 Web 应用程序的自动化测试，但其能力远不止于此。它允许开发者像真实用户一样，直接控制浏览器执行各种操作，如点击按钮、填写表单、导航页面等。通过模拟用户与网页的交互，Selenium 成为了处理动态加载内容 (JavaScript 渲染)、实现 Web UI 自动化测试和进行高级网络爬取的关键工具。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>Selenium 通过 WebDriver API 直接与浏览器进行通信，发送指令并接收浏览器执行结果，从而实现对浏览器的完全控制。</strong> 这使得它能够处理任何人类用户可以做到的网页交互。</p>
</div>
<hr>
<h2 id="一、为什么需要-Selenium？传统爬虫的局限性"><a href="#一、为什么需要-Selenium？传统爬虫的局限性" class="headerlink" title="一、为什么需要 Selenium？传统爬虫的局限性"></a>一、为什么需要 Selenium？传统爬虫的局限性</h2><p>传统的网页爬取工具（如 Python 的 <code>requests</code> + <code>BeautifulSoup</code> 或 Scrapy 框架）非常高效，适用于抓取静态 HTML 页面或 API 返回的结构化数据。然而，面对现代 Web 应用的复杂性时，它们会遇到显著的局限性：</p>
<ol>
<li><strong>JavaScript 渲染内容</strong>：许多网站使用 JavaScript 动态加载内容（AJAX 请求、SPA - Single Page Applications）。传统爬虫只获取初始 HTML，无法执行 JavaScript，因此无法看到或提取这些动态生成的内容。</li>
<li><strong>用户交互需求</strong>：某些数据或页面必须通过用户交互（如点击按钮、滚动页面、登录、填写表单）才能访问。传统爬虫无法模拟这些行为。</li>
<li><strong>验证码与反爬</strong>：虽然 Selenium 自身不能直接绕过复杂的验证码，但它可以通过模拟真人行为（如鼠标轨迹、输入速度）来降低被检测为机器人的风险，或者集成第三方验证码识别服务。</li>
<li><strong>UI 自动化测试</strong>：Web 应用程序的端到端测试需要模拟真实用户在浏览器中的操作，验证界面和功能的正确性。这是传统工具无法完成的任务。</li>
</ol>
<p>Selenium 正是为了克服这些挑战而生。它启动一个真实的浏览器实例，完全模拟用户的行为，从而能够处理任何动态内容和交互。</p>
<h2 id="二、Selenium-Suite-概览"><a href="#二、Selenium-Suite-概览" class="headerlink" title="二、Selenium Suite 概览"></a>二、Selenium Suite 概览</h2><p>Selenium 并非一个单一工具，而是一个由多个组件组成的套件：</p>
<ol>
<li><strong>Selenium WebDriver</strong>：这是 Selenium 的核心，也是最常用的组件。它提供了一组 API，用于通过编程方式直接控制浏览器。</li>
<li><strong>Selenium IDE</strong>：一个浏览器插件，用于录制和回放用户在浏览器中的操作，生成测试脚本。适用于快速原型开发和非程序员使用。</li>
<li><strong>Selenium Grid</strong>：一个分布式测试工具，允许在多台机器、多个浏览器、多个操作系统上并行运行 WebDriver 测试，大大提高测试效率。</li>
</ol>
<p>本文将重点深入讲解 <strong>Selenium WebDriver</strong>。</p>
<h2 id="三、Selenium-WebDriver-核心概念与工作原理"><a href="#三、Selenium-WebDriver-核心概念与工作原理" class="headerlink" title="三、Selenium WebDriver 核心概念与工作原理"></a>三、Selenium WebDriver 核心概念与工作原理</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p><strong>Selenium WebDriver</strong> 是一个基于接口的框架，它提供了一种标准化的方式来与不同的浏览器进行通信。它将浏览器视为一个黑盒，通过发送命令来控制它，并接收浏览器返回的响应。</p>
<h3 id="3-2-工作原理-Mermaid-Diagram"><a href="#3-2-工作原理-Mermaid-Diagram" class="headerlink" title="3.2 工作原理 (Mermaid Diagram)"></a>3.2 工作原理 (Mermaid Diagram)</h3><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[用户代码&#x2F;测试脚本] --调用 WebDriver API &lt;br&gt;(如 Python&#x2F;Java&#x2F;Go&#x2F;JS)--&gt; B{WebDriver 客户端库}
    B --通过 HTTP 请求 &lt;br&gt;(JSON Wire Protocol &lt;br&gt;&#x2F; W3C WebDriver)--&gt; C{浏览器驱动}
    C --原生协议--&gt; D[真实浏览器实例]

    D --页面加载&#x2F;交互--&gt; D
    D --浏览器状态&#x2F;执行结果--&gt; C
    C --HTTP 响应 (JSON)--&gt; B
    B --解析响应--&gt; A

    subgraph 示例: Python + Chrome
        B_Python[Python Selenium 库]
        C_ChromeDriver[ChromeDriver]
        D_Chrome[Google Chrome 浏览器]
        A --&gt; B_Python
        B_Python --&gt; C_ChromeDriver
        C_ChromeDriver --&gt; D_Chrome
    end
  </pre></div>

<p><strong>解释</strong>:</p>
<ol>
<li><strong>用户代码&#x2F;测试脚本</strong>：这是你用 Python、Java、Go、JavaScript 等语言编写的 Selenium 程序。</li>
<li><strong>WebDriver 客户端库</strong>：Selenium 提供了针对各种编程语言的客户端库。你的代码调用这些库中的方法。</li>
<li><strong>JSON Wire Protocol &#x2F; W3C WebDriver</strong>：WebDriver 客户端库将你的方法调用转换为遵循 WebDriver 协议的 HTTP 请求 (JSON 格式)。</li>
<li><strong>浏览器驱动 (Browser Driver)</strong>：这是一个独立的可执行程序 (如 ChromeDriver, GeckoDriver)。它充当 WebDriver 客户端库和浏览器之间的桥梁。它接收 HTTP 请求，将其翻译成浏览器能理解的原生命令，然后发送给浏览器。</li>
<li><strong>真实浏览器实例</strong>：这是你实际看到的 Chrome、Firefox 等浏览器窗口。浏览器驱动控制它执行指令，并获取执行结果。</li>
</ol>
<h3 id="3-3-核心概念"><a href="#3-3-核心概念" class="headerlink" title="3.3 核心概念"></a>3.3 核心概念</h3><ol>
<li><p><strong>浏览器驱动 (Browser Drivers)</strong>：</p>
<ul>
<li>WebDriver 本身是一个接口，具体实现由各个浏览器厂商提供。</li>
<li><strong>ChromeDriver</strong>: 驱动 Google Chrome。</li>
<li><strong>GeckoDriver</strong>: 驱动 Mozilla Firefox。</li>
<li><strong>EdgeDriver</strong>: 驱动 Microsoft Edge。</li>
<li><strong>SafariDriver</strong>: 驱动 Apple Safari。</li>
<li><strong>注意</strong>：浏览器驱动的版本必须与你使用的浏览器版本兼容。</li>
</ul>
</li>
<li><p><strong>元素定位 (Locators)</strong>：</p>
<ul>
<li>WebDriver 通过“定位器”找到页面上的特定元素 (按钮、输入框、文本等)。</li>
<li><strong><code>By.ID</code></strong>: 最可靠，ID 应该是唯一的。</li>
<li><strong><code>By.NAME</code></strong>: 通过元素的 <code>name</code> 属性。</li>
<li><strong><code>By.CLASS_NAME</code></strong>: 通过元素的 <code>class</code> 属性。</li>
<li><strong><code>By.TAG_NAME</code></strong>: 通过 HTML 标签名 (如 <code>div</code>, <code>a</code>, <code>input</code>)。</li>
<li><strong><code>By.LINK_TEXT</code> &#x2F; <code>By.PARTIAL_LINK_TEXT</code></strong>: 通过链接的可见文本。</li>
<li><strong><code>By.CSS_SELECTOR</code></strong>: 使用 CSS 选择器语法。</li>
<li><strong><code>By.XPATH</code></strong>: 使用 XPath 表达式，功能强大但可能复杂。</li>
</ul>
</li>
<li><p><strong>操作元素 (Actions)</strong>：</p>
<ul>
<li><code>click()</code>: 点击元素。</li>
<li><code>send_keys(&quot;text&quot;)</code>: 向输入框发送文本。</li>
<li><code>clear()</code>: 清除输入框中的文本。</li>
<li><code>submit()</code>: 提交表单。</li>
</ul>
</li>
<li><p><strong>获取信息 (Retrieval)</strong>：</p>
<ul>
<li><code>text</code>: 获取元素的可见文本。</li>
<li><code>get_attribute(&quot;attr_name&quot;)</code>: 获取元素的指定属性值。</li>
<li><code>current_url</code>: 获取当前页面的 URL。</li>
<li><code>title</code>: 获取当前页面的标题。</li>
</ul>
</li>
<li><p><strong>等待机制 (Waits)</strong>：</p>
<ul>
<li>在动态加载的网页中，元素可能不会立即可用。等待机制是避免 <code>NoSuchElementException</code> 的关键。</li>
<li><strong>隐式等待 (Implicit Wait)</strong>：设置一个全局的等待时间，WebDriver 会在这个时间内不断查找元素，直到找到为止或超时。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.implicitly_wait(<span class="number">10</span>) <span class="comment"># 设置10秒的隐式等待</span></span><br></pre></td></tr></table></figure></li>
<li><strong>显式等待 (Explicit Wait)</strong>：等待某个特定条件发生，直到条件满足或超时。更精确、推荐使用。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">    EC.presence_of_element_located((By.ID, <span class="string">&quot;myElement&quot;</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
常用 <code>ExpectedConditions</code>：<ul>
<li><code>presence_of_element_located</code>：元素出现在 DOM 中。</li>
<li><code>visibility_of_element_located</code>：元素出现在 DOM 中且可见。</li>
<li><code>element_to_be_clickable</code>：元素可见且可点击。</li>
<li><code>text_to_be_present_in_element</code>：元素包含特定文本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Headless Mode (无头模式)</strong>：</p>
<ul>
<li>在没有图形界面的服务器上运行浏览器，或在不需要显示浏览器窗口时提高效率。</li>
<li>通过浏览器 <code>Options</code> 配置。</li>
</ul>
</li>
</ol>
<h2 id="四、实战：使用-Python-Selenium-驱动-Chrome"><a href="#四、实战：使用-Python-Selenium-驱动-Chrome" class="headerlink" title="四、实战：使用 Python Selenium 驱动 Chrome"></a>四、实战：使用 Python Selenium 驱动 Chrome</h2><p><strong>(注意：虽然原要求中提到了Go语言示例，但Selenium在Python中的生态最为成熟和常用，其API设计也更符合直觉，故此处以Python为例进行讲解。Go语言的Selenium绑定如<code>github.com/tebeka/selenium</code>也提供了类似的功能，但配置和使用可能略显复杂，不适合作为入门示例。)</strong></p>
<h3 id="4-1-准备环境"><a href="#4-1-准备环境" class="headerlink" title="4.1 准备环境"></a>4.1 准备环境</h3><ol>
<li><strong>安装 Python 和 pip</strong> (如果未安装)。</li>
<li><strong>安装 Selenium 库</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure></li>
<li><strong>下载浏览器驱动</strong>：<ul>
<li>访问 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://chromedriver.chromium.org/downloads">ChromeDriver Downloads</a></li>
<li>访问 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/mozilla/geckodriver/releases">GeckoDriver Releases</a></li>
<li>选择与你本地浏览器版本对应的驱动，下载并将其可执行文件放到系统 PATH 中，或者指定其完整路径。</li>
</ul>
</li>
</ol>
<h3 id="4-2-基本爬取与交互示例"><a href="#4-2-基本爬取与交互示例" class="headerlink" title="4.2 基本爬取与交互示例"></a>4.2 基本爬取与交互示例</h3><p>目标：打开百度，搜索“Selenium”，并截图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service <span class="comment"># 用于指定 ChromeDriver 路径</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options <span class="comment"># 用于配置浏览器选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_selenium_example</span>():</span><br><span class="line">    <span class="comment"># 1. 配置 ChromeDriver (假设 chromedriver 在 PATH 中，否则需要指定路径)</span></span><br><span class="line">    <span class="comment"># 例如：service = Service(&#x27;/path/to/chromedriver&#x27;)</span></span><br><span class="line">    <span class="comment"># driver = webdriver.Chrome(service=service)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 也可以不指定 Service 路径，如果 chromedriver 在系统 PATH 中</span></span><br><span class="line">    <span class="comment"># 设置 Chrome 选项</span></span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    <span class="comment"># chrome_options.add_argument(&quot;--headless&quot;) # 启用无头模式 (不显示浏览器界面)</span></span><br><span class="line">    chrome_options.add_argument(<span class="string">&quot;--window-size=1920,1080&quot;</span>) <span class="comment"># 设置窗口大小</span></span><br><span class="line">    chrome_options.add_argument(<span class="string">&quot;--disable-gpu&quot;</span>) <span class="comment"># 禁用 GPU 加速，某些系统上无头模式可能需要</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 2. 启动 Chrome 浏览器</span></span><br><span class="line">        driver = webdriver.Chrome(options=chrome_options)</span><br><span class="line">        driver.implicitly_wait(<span class="number">10</span>) <span class="comment"># 设置隐式等待，最长10秒等待元素出现</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;浏览器已启动，准备访问百度...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 访问百度</span></span><br><span class="line">        driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;当前页面标题: <span class="subst">&#123;driver.title&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;当前页面URL: <span class="subst">&#123;driver.current_url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 查找搜索框元素并输入文本</span></span><br><span class="line">        <span class="comment"># 可以通过 ID, NAME, CSS Selector, XPath 等方式定位</span></span><br><span class="line">        search_box = driver.find_element(By.ID, <span class="string">&quot;kw&quot;</span>) <span class="comment"># 百度搜索框的 ID 是 &#x27;kw&#x27;</span></span><br><span class="line">        search_box.send_keys(<span class="string">&quot;Selenium&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已在搜索框输入 &#x27;Selenium&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 查找搜索按钮并点击</span></span><br><span class="line">        search_button = driver.find_element(By.ID, <span class="string">&quot;su&quot;</span>) <span class="comment"># 百度搜索按钮的 ID 是 &#x27;su&#x27;</span></span><br><span class="line">        search_button.click()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;已点击搜索按钮&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 6. 等待搜索结果加载 (显式等待一个搜索结果元素出现)</span></span><br><span class="line">        <span class="comment"># 这里假设搜索结果页面有一个ID为&#x27;content_left&#x27;的div</span></span><br><span class="line">        <span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line">        <span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line">        WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.ID, <span class="string">&quot;content_left&quot;</span>))</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;搜索结果页面已加载&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 7. 截图并保存</span></span><br><span class="line">        driver.save_screenshot(<span class="string">&quot;baidu_selenium_result.png&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;搜索结果页面已截图保存为 baidu_selenium_result.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 8. 获取并打印搜索结果的标题 (以第一个结果为例)</span></span><br><span class="line">        <span class="comment"># 使用 CSS Selector 定位第一个搜索结果的标题</span></span><br><span class="line">        first_result_title = driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;#content_left h3 a&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;第一个搜索结果标题: <span class="subst">&#123;first_result_title.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 9. 暂停一段时间观察 (如果不是无头模式)</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 10. 关闭浏览器</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;driver&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> driver:</span><br><span class="line">            driver.quit()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;浏览器已关闭。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run_selenium_example()</span><br></pre></td></tr></table></figure>

<h3 id="4-3-处理常见交互"><a href="#4-3-处理常见交互" class="headerlink" title="4.3 处理常见交互"></a>4.3 处理常见交互</h3><ol>
<li><p><strong>处理弹出框 (Alerts, Prompts, Confirmations)</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert = driver.switch_to.alert</span><br><span class="line"><span class="built_in">print</span>(alert.text) <span class="comment"># 获取弹出框文本</span></span><br><span class="line">alert.accept()    <span class="comment"># 接受 (点击确定)</span></span><br><span class="line"><span class="comment"># alert.dismiss() # 取消 (点击取消)</span></span><br><span class="line"><span class="comment"># alert.send_keys(&quot;input text&quot;) # 向 prompt 类型的弹出框输入文本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理框架 (Frames)</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.frame(<span class="string">&quot;frame_name_or_id&quot;</span>) <span class="comment"># 通过名称或 ID 切换到 frame</span></span><br><span class="line"><span class="comment"># driver.switch_to.frame(driver.find_element(By.TAG_NAME, &quot;iframe&quot;)) # 通过 WebElement 切换</span></span><br><span class="line"><span class="comment"># ... 在 frame 中操作元素 ...</span></span><br><span class="line">driver.switch_to.default_content() <span class="comment"># 切换回主文档</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理窗口&#x2F;标签页 (Windows&#x2F;Tabs)</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有窗口句柄</span></span><br><span class="line">original_window = driver.current_window_handle</span><br><span class="line">all_windows = driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到新窗口 (例如，弹出新窗口后的第二个窗口)</span></span><br><span class="line"><span class="keyword">for</span> window_handle <span class="keyword">in</span> all_windows:</span><br><span class="line">    <span class="keyword">if</span> window_handle != original_window:</span><br><span class="line">        driver.switch_to.window(window_handle)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># ... 在新窗口中操作 ...</span></span><br><span class="line">driver.close() <span class="comment"># 关闭当前窗口</span></span><br><span class="line">driver.switch_to.window(original_window) <span class="comment"># 切换回原始窗口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行 JavaScript</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滚动页面到底部</span></span><br><span class="line">driver.execute_script(<span class="string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)</span><br><span class="line"><span class="comment"># 获取某个元素的隐藏文本</span></span><br><span class="line">hidden_text = driver.execute_script(<span class="string">&quot;return document.getElementById(&#x27;myHiddenElement&#x27;).innerText;&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五、Selenium-Grid-分布式测试"><a href="#五、Selenium-Grid-分布式测试" class="headerlink" title="五、Selenium Grid (分布式测试)"></a>五、Selenium Grid (分布式测试)</h2><p>Selenium Grid 允许你在多台机器上并行运行测试，每台机器可以配置不同的浏览器和操作系统组合。</p>
<ul>
<li><strong>Hub (中心)</strong>：接收测试请求，并将其分发到合适的 Node。</li>
<li><strong>Node (节点)</strong>：注册到 Hub 的机器，运行一个或多个浏览器实例。</li>
</ul>
<p><strong>优势</strong>：显著减少测试执行时间，扩大测试覆盖范围 (跨浏览器&#x2F;OS)。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    UserClient[&quot;测试脚本 (Python&#x2F;Java等)&quot;] --&gt; Hub[Selenium Hub]
    Hub --分发请求--&gt; NodeA[&quot;Selenium Node A (Chrome, Win10)&quot;]
    Hub --分发请求--&gt; NodeB[&quot;Selenium Node B (Firefox, MacOS)&quot;]
    Hub --分发请求--&gt; NodeC[&quot;Selenium Node C (Edge, Linux)&quot;]

    NodeA --控制--&gt; BrowserA[Chrome 浏览器]
    NodeB --控制--&gt; BrowserB[Firefox 浏览器]
    NodeC --控制--&gt; BrowserC[Edge 浏览器]
  </pre></div>

<h2 id="六、Selenium-的优缺点与适用场景"><a href="#六、Selenium-的优缺点与适用场景" class="headerlink" title="六、Selenium 的优缺点与适用场景"></a>六、Selenium 的优缺点与适用场景</h2><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h3><ol>
<li><strong>模拟真实用户行为</strong>：启动真实浏览器，可以处理所有 JavaScript 渲染、CSS 样式和用户交互。</li>
<li><strong>跨浏览器&#x2F;平台</strong>：支持主流浏览器 (Chrome, Firefox, Edge, Safari) 和多种操作系统 (Windows, macOS, Linux)。</li>
<li><strong>多语言支持</strong>：提供了多种主流编程语言的客户端库 (Python, Java, C#, JavaScript, Ruby)。</li>
<li><strong>强大的定位能力</strong>：支持多种元素定位策略 (ID, XPath, CSS Selector 等)。</li>
<li><strong>丰富的生态系统</strong>：拥有庞大的社区、文档和第三方工具集成 (如 Grid、Page Object Model)。</li>
<li><strong>UI 自动化测试利器</strong>：是 Web UI 自动化测试领域的实际标准。</li>
</ol>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h3><ol>
<li><strong>执行速度较慢</strong>：相比传统 HTTP 请求库，Selenium 需要启动并控制一个完整的浏览器，因此执行速度会慢得多。</li>
<li><strong>资源消耗大</strong>：每个浏览器实例都会占用大量 CPU 和内存资源，不适合大规模、高并发的爬取任务。</li>
<li><strong>反爬虫难度</strong>：虽然模拟真实浏览器，但仍可能被网站检测到 (如通过 headless 模式、浏览器指纹、流量分析等)。需要结合代理、User-Agent 轮换、Cookie 管理等策略。</li>
<li><strong>学习曲线</strong>：需要了解 WebDriver 的 API、定位策略、等待机制等，入门比 <code>requests</code> 复杂。</li>
<li><strong>稳定性</strong>：浏览器更新、驱动不兼容、网络波动都可能导致测试不稳定。</li>
</ol>
<h3 id="6-3-适用场景"><a href="#6-3-适用场景" class="headerlink" title="6.3 适用场景"></a>6.3 适用场景</h3><ul>
<li><strong>Web UI 自动化测试</strong>：对 Web 应用程序进行端到端的测试，验证用户界面的功能和交互。</li>
<li><strong>动态网站数据抓取</strong>：抓取那些大量依赖 JavaScript 动态加载内容或需要登录、交互才能获取数据的网站。</li>
<li><strong>交互式数据监控</strong>：监控需要模拟用户操作才能获取的实时数据。</li>
<li><strong>自动化重复性任务</strong>：例如，自动化填写在线表格、批量上传文件、自动登录等。</li>
<li><strong>模拟用户行为的机器人</strong>：在特定网站上执行一系列模拟真人操作的自动化脚本。</li>
</ul>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Selenium 是 Web 自动化领域的基石，尤其在处理 JavaScript 渲染页面和实现 Web UI 自动化测试方面具有不可替代的优势。它通过直接控制真实浏览器，为开发者提供了一种强大的方式来模拟用户与网页的交互。尽管其执行速度和资源消耗相对较高，但对于那些传统爬虫无法企及的动态、交互式 Web 内容，Selenium 依然是首选工具。理解其核心工作原理、熟练掌握元素定位和等待机制，并结合适当的优化和反反爬虫策略，将能最大化地发挥 Selenium 的价值。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/51be17189d42/">https://blog.tbf1211.xx.kg/51be17189d42/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E6%B5%8B%E8%AF%95/">测试</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E7%88%AC%E8%99%AB/">爬虫</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ffc98223e029/" title="OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0 (Open Authorization 2.0) 是一种授权框架，允许第三方应用程序在不获取用户凭据的情况下访问用户在另一个服务商的受保护资源。然而，传统的 OAuth 2.0 授权码流在某些客户端类型（如公共客户端，Public Clients）中存在安全隐患。为了解决这些问题，PKCE（Proof Key for Code Exchange by OAuth Public Clients） 机制应运而生。  核心思想：PKCE 通过在授权码流中引入一个动态生成的密钥对，有效防止了授权码被恶意截取后被非法使用的风险，极大增强了公共客户端（如移动应用、单页应用）的安全性。    一、为什么需要 PKCE？公共客户端面临的挑战传统的 OAuth 2.0 授权码流 (Authorization Code Flow) 是最安全、最推荐的流程，它通过将授权码 (Authorization Code) 发送给客户端，然后客户端使用授权码和客户端秘钥 (Client Secret) 交换访问令牌 (Access Token)。 然而，这种传统的授权码流在用于公共客户端 ...</div></div></div></a><a class="pagination-related" href="/ca2038899eb8/" title="Scrapy (Python Web 爬虫框架) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Scrapy (Python Web 爬虫框架) 深度解析</div></div><div class="info-2"><div class="info-item-1"> Scrapy 是一个用 Python 编写的开源且功能强大的 Web 爬虫框架，它被设计用于快速、高效地从网站上提取结构化数据。Scrapy 不仅提供了完整的爬虫生命周期管理，包括请求调度、并发控制、数据解析和持久化，还通过其高度模块化的架构，允许开发者轻松扩展和定制爬虫行为。  核心思想：将 Web 爬取视为一个事件驱动的流程，通过异步 I&#x2F;O (基于 Twisted) 实现高并发，并提供一套可插拔的组件，以便开发者专注于数据提取逻辑。   一、为什么需要 Scrapy？在数据驱动的时代，从 Web 获取大量结构化信息的需求日益增长。虽然我们可以使用 requests 库发送 HTTP 请求并结合 BeautifulSoup 或 lxml 等库解析 HTML，但当面临以下挑战时，手动编写爬虫会变得复杂且低效：  并发与效率：需要同时发送大量请求以提高爬取速度，手动管理并发、线程或协程将非常繁琐。 请求调度与去重：爬虫需要跟踪哪些 URL 已访问、哪些待访问，并避免重复请求，这需要复杂的调度逻辑。 中间件处理：处理 User-Agent 轮换、代理 IP、Cookie...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ca2038899eb8/" title="Scrapy (Python Web 爬虫框架) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-27</div><div class="info-item-2">Scrapy (Python Web 爬虫框架) 深度解析</div></div><div class="info-2"><div class="info-item-1"> Scrapy 是一个用 Python 编写的开源且功能强大的 Web 爬虫框架，它被设计用于快速、高效地从网站上提取结构化数据。Scrapy 不仅提供了完整的爬虫生命周期管理，包括请求调度、并发控制、数据解析和持久化，还通过其高度模块化的架构，允许开发者轻松扩展和定制爬虫行为。  核心思想：将 Web 爬取视为一个事件驱动的流程，通过异步 I&#x2F;O (基于 Twisted) 实现高并发，并提供一套可插拔的组件，以便开发者专注于数据提取逻辑。   一、为什么需要 Scrapy？在数据驱动的时代，从 Web 获取大量结构化信息的需求日益增长。虽然我们可以使用 requests 库发送 HTTP 请求并结合 BeautifulSoup 或 lxml 等库解析 HTML，但当面临以下挑战时，手动编写爬虫会变得复杂且低效：  并发与效率：需要同时发送大量请求以提高爬取速度，手动管理并发、线程或协程将非常繁琐。 请求调度与去重：爬虫需要跟踪哪些 URL 已访问、哪些待访问，并避免重复请求，这需要复杂的调度逻辑。 中间件处理：处理 User-Agent 轮换、代理 IP、Cookie...</div></div></div></a><a class="pagination-related" href="/62acbead38d8/" title="Python 打包工具 uv 详解：下一代包管理器与构建器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-12</div><div class="info-item-2">Python 打包工具 uv 详解：下一代包管理器与构建器</div></div><div class="info-2"><div class="info-item-1"> uv 是由 Astral 公司开发的一款高性能 Rust 实现的 Python 包安装器和解析器，旨在全面替代 pip、pip-tools 和 virtualenv。它以其惊人的速度、严谨的兼容性和现代化功能，正迅速成为 Python 生态系统中的一个重要工具。  核心思想：提供一个单一、快速且可靠的命令行工具，覆盖 Python 包管理生命周期中的关键操作，从环境创建到依赖解析、安装和锁定。   一、引言：为什么需要 uv？Python 包管理长期以来面临着一些挑战，尤其是在性能和一致性方面：  pip 的局限性： 速度慢：pip 在解析大型项目或复杂依赖树时速度较慢，因为它每次都会重新计算依赖，且在网络请求和磁盘 I&#x2F;O 方面未高度优化。 依赖解析不确定性：pip 的解析器有时会出现非确定性行为，对于复杂的依赖冲突，不一定能给出最佳或唯一的解决方案。 缺乏锁定文件机制：pip 本身没有内置的锁定文件（requirements.txt 固然可以锁定，但不是通过 pip 自身的解析冲突机制而来）生成能力，需要 pip-tools 等额外工具。   virtualenv...</div></div></div></a><a class="pagination-related" href="/cac9fddb0534/" title="Python 3 各版本新特性详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-19</div><div class="info-item-2">Python 3 各版本新特性详解</div></div><div class="info-2"><div class="info-item-1"> Python 3.x 系列 自 2008 年首次发布以来，一直在持续发展和完善。每个小版本（如 3.6, 3.7, 3.8 等）都会引入一系列新的语言特性、标准库改进、性能优化以及重要的 bug 修复。理解这些新特性对于 Python 开发者来说至关重要，它能帮助我们编写更高效、更简洁、更现代的代码。  核心思想： Python 3 的版本迭代聚焦于提升开发效率、代码可读性、执行性能以及引入现代编程范式，同时保持语言的易用性。   一、Python 3.0 - 3.3：从 2.x 到 3.x 的演变Python 3.0 是一个里程碑式的版本，它引入了许多不兼容的改变，旨在解决 Python 2.x 的设计缺陷并为未来发展铺平道路。 1.1 Python 3.0 (2008-12-03) 字符串和字节分离：str 类型现在是 Unicode 字符串，bytes 类型是原始字节序列。这是最重要的改变，解决了 Python 2.x 中 Unicode 处理的混乱。 print 成为函数：print 语句被 print() 函数取代。 Python 2.x: print &quot;H...</div></div></div></a><a class="pagination-related" href="/13596be529bf/" title="Python神库Pydantic深度解析：数据验证与设置管理的利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-10</div><div class="info-item-2">Python神库Pydantic深度解析：数据验证与设置管理的利器</div></div><div class="info-2"><div class="info-item-1"> Pydantic 是一个 Python 库，用于数据验证和设置管理，它利用 Python 的类型提示 (type hints) 来定义数据模式。Pydantic 在运行时强制执行类型提示，并为您的数据提供友好的错误信息，使得数据模型更加健壮、可维护和自文档化。它广泛应用于 Web API (如 FastAPI)、数据科学、配置管理等领域。  核心思想：将 Python 的类型提示转化为强大的运行时数据验证和序列化工具，从而提高代码的健壮性和开发效率。   一、为什么需要 Pydantic？在现代 Python 应用开发中，数据从外部来源（如 JSON API、数据库、配置文件、用户输入）进入系统是常态。这些外部数据往往不可信，结构复杂且容易出错。传统的 Python 处理方式存在一些问题：  缺乏数据验证：直接使用字典或弱类型对象，无法保证数据的结构和类型正确性，容易导致运行时错误。 手动验证繁琐：编写大量的 if/else 语句进行数据类型检查和值验证，导致代码冗长、难以维护。 序列化&#x2F;反序列化复杂：将 Python 对象转换为 JSON&#x2F;XML 或反之，...</div></div></div></a><a class="pagination-related" href="/195d130ae5a4/" title="Ansible 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Ansible 深度解析</div></div><div class="info-2"><div class="info-item-1"> Ansible 是一个开源的自动化引擎，用于配置管理 (Configuration Management)、应用部署 (Application Deployment)、任务自动化 (Task Automation) 和编排 (Orchestration)。它以其无代理 (Agentless)、简单易用和人性化的特点而广受欢迎。Ansible 使用标准的 SSH 协议连接到目标机器，并使用 YAML 语法编写自动化任务，使得编写、理解和维护自动化脚本变得直观。  核心思想：Ansible 通过 SSH 远程执行操作，无需在被管理节点上安装任何客户端或代理程序。它采用声明式 YAML 语言描述期望的状态，并确保系统达到该状态，同时保证操作的幂等性。   一、为什么选择 Ansible？传统的服务器管理和应用部署往往涉及大量重复、手工且容易出错的任务。随着 IT 基础设施的规模不断扩大，这种手工操作的弊端日益凸显：  效率低下：手动操作耗时且重复。 易出错：人为失误在重复性任务中难以避免。 配置漂移 (Configuration Drift)：不同服务器的配置可能因手工操作而逐渐不一...</div></div></div></a><a class="pagination-related" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-24</div><div class="info-item-2">CFFI (C Foreign Function Interface for Python) 详解</div></div><div class="info-2"><div class="info-item-1"> CFFI (C Foreign Function Interface) 是一个用于 Python 的外部包，它提供了一种在 Python 代码中与几乎任何 C 代码进行交互的强大机制。它允许 Python 程序直接调用 C 库中的函数，并访问 C 语言的数据结构，从而实现高性能计算、利用现有 C 库或将 Python 代码暴露给 C&#x2F;C++ 应用程序等目的。  CFFI 旨在简化 Python 与 C 语言的集成，提供比标准库 ctypes 模块更丰富、更流畅的接口，且在许多情况下不需要 C 编译器即可工作。   一、为什么需要 CFFI？Python 语言以其简洁性和高效开发著称，但在某些场景下，由于其解释执行的特性，可能无法满足对极致性能的要求。此外，许多高性能或底层系统库都是用 C 或 C++ 编写的。为了解决这些问题，我们需要一种机制让 Python 代码能够调用这些 C&#x2F;C++ 库。 传统的 Python 与 C 交互方式包括：  编写 C 扩展模块 (C Extension Modules)：这是最全面、性能最高的集成方式，但开发复杂，需要深入理...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">450</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Selenium%EF%BC%9F%E4%BC%A0%E7%BB%9F%E7%88%AC%E8%99%AB%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">一、为什么需要 Selenium？传统爬虫的局限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Selenium-Suite-%E6%A6%82%E8%A7%88"><span class="toc-text">二、Selenium Suite 概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Selenium-WebDriver-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">三、Selenium WebDriver 核心概念与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-Mermaid-Diagram"><span class="toc-text">3.2 工作原理 (Mermaid Diagram)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">3.3 核心概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BD%BF%E7%94%A8-Python-Selenium-%E9%A9%B1%E5%8A%A8-Chrome"><span class="toc-text">四、实战：使用 Python Selenium 驱动 Chrome</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83"><span class="toc-text">4.1 准备环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%9F%BA%E6%9C%AC%E7%88%AC%E5%8F%96%E4%B8%8E%E4%BA%A4%E4%BA%92%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.2 基本爬取与交互示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E4%BA%A4%E4%BA%92"><span class="toc-text">4.3 处理常见交互</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Selenium-Grid-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%8B%E8%AF%95"><span class="toc-text">五、Selenium Grid (分布式测试)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Selenium-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">六、Selenium 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BC%98%E7%82%B9"><span class="toc-text">6.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">6.2 缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6.3 适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-17.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>