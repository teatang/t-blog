<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>FTP (File Transfer Protocol) 协议详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FTP (File Transfer Protocol) 是一个用于在网络上进行文件传输的标准网络协议，是 TCP&#x2F;IP 协议族中的一个应用层协议。它允许客户端和服务器之间传输文件，支持上传、下载、删除、重命名文件，以及创建和删除目录等操作。FTP 是最早期的互联网协议之一，设计初衷是为了在不同的操作系统和文件系统之间提供统一的文件传输服务。  核心思想：基于客户端-服务器模式，利用独">
<meta property="og:type" content="article">
<meta property="og:title" content="FTP (File Transfer Protocol) 协议详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/82faa099bd25/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="FTP (File Transfer Protocol) 是一个用于在网络上进行文件传输的标准网络协议，是 TCP&#x2F;IP 协议族中的一个应用层协议。它允许客户端和服务器之间传输文件，支持上传、下载、删除、重命名文件，以及创建和删除目录等操作。FTP 是最早期的互联网协议之一，设计初衷是为了在不同的操作系统和文件系统之间提供统一的文件传输服务。  核心思想：基于客户端-服务器模式，利用独">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg">
<meta property="article:published_time" content="2023-03-17T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-24T10:30:01.006Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FTP (File Transfer Protocol) 协议详解",
  "url": "https://blog.tbf1211.xx.kg/82faa099bd25/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg",
  "datePublished": "2023-03-17T22:24:00.000Z",
  "dateModified": "2026-02-24T10:30:01.006Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/82faa099bd25/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FTP (File Transfer Protocol) 协议详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">551</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">FTP (File Transfer Protocol) 协议详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">FTP (File Transfer Protocol) 协议详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-17T22:24:00.000Z" title="发表于 2023-03-18 06:24:00">2023-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>FTP (File Transfer Protocol)</strong> 是一个用于在网络上进行文件传输的标准网络协议，是 TCP&#x2F;IP 协议族中的一个应用层协议。它允许客户端和服务器之间传输文件，支持上传、下载、删除、重命名文件，以及创建和删除目录等操作。FTP 是最早期的互联网协议之一，设计初衷是为了在不同的操作系统和文件系统之间提供统一的文件传输服务。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>基于客户端-服务器模式，利用独立的控制连接和数据连接，高效可靠地传输文件。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-FTP？"><a href="#一、为什么需要-FTP？" class="headerlink" title="一、为什么需要 FTP？"></a>一、为什么需要 FTP？</h2><p>在二十世纪七十年代，互联网的前身 ARPANET 还在发展初期，用户需要一种可靠的方式在不同的计算机系统之间共享文件。FTP 因此被设计出来，解决了以下痛点：</p>
<ul>
<li><strong>跨平台文件传输</strong>：允许不同操作系统（如 Unix、Windows）之间传输文件，统一了文件传输的格式和控制命令。</li>
<li><strong>可靠性</strong>：基于 TCP 协议，保证文件传输的可靠性（数据不丢失、不重复、按序到达）。</li>
<li><strong>大文件传输</strong>：能够处理大文件的传输，并通过数据流控制确保传输效率。</li>
<li><strong>用户权限管理</strong>：支持用户认证，可以根据用户身份分配不同的文件访问权限。</li>
</ul>
<p>尽管 FTP 历史悠久、功能强大，但其在设计时没有考虑安全性，因此现代应用中，通常会使用更安全的替代方案。</p>
<h2 id="二、FTP-的基本工作原理"><a href="#二、FTP-的基本工作原理" class="headerlink" title="二、FTP 的基本工作原理"></a>二、FTP 的基本工作原理</h2><p>FTP 最显著的特点是它使用<strong>两个独立的 TCP 连接</strong>来传输文件：一个用于<strong>控制连接</strong>，另一个用于<strong>数据连接</strong>。</p>
<h3 id="2-1-控制连接-Control-Connection"><a href="#2-1-控制连接-Control-Connection" class="headerlink" title="2.1 控制连接 (Control Connection)"></a>2.1 控制连接 (Control Connection)</h3><ul>
<li><strong>用途</strong>：用于传输 FTP 客户端和服务器之间的<strong>命令和响应</strong>，例如用户认证信息（用户名、密码）、文件操作命令（上传、下载、列目录、删除等）和服务器的响应消息。</li>
<li><strong>端口</strong>：客户端连接服务器的 <strong>TCP 21 端口</strong>。</li>
<li><strong>生命周期</strong>：在整个 FTP 会话期间保持开启状态，直到客户端断开连接。</li>
<li><strong>传输内容</strong>：所有命令和响应都以 <strong>明文</strong> 形式传输，不加密。</li>
</ul>
<h3 id="2-2-数据连接-Data-Connection"><a href="#2-2-数据连接-Data-Connection" class="headerlink" title="2.2 数据连接 (Data Connection)"></a>2.2 数据连接 (Data Connection)</h3><ul>
<li><strong>用途</strong>：用于实际的<strong>文件数据传输</strong>，包括文件内容、目录列表等。</li>
<li><strong>端口</strong>：动态协商，有两种模式：<strong>主动模式 (Active Mode)</strong> 和 <strong>被动模式 (Passive Mode)</strong>。</li>
<li><strong>生命周期</strong>：每传输一个文件或目录列表时，都会建立一个新的数据连接，传输完成后关闭。</li>
</ul>
<h3 id="2-3-工作流程概述"><a href="#2-3-工作流程概述" class="headerlink" title="2.3 工作流程概述"></a>2.3 工作流程概述</h3><ol>
<li>客户端与 FTP 服务器的 21 端口建立<strong>控制连接</strong>。</li>
<li>客户端发送用户名和密码进行认证（明文传输）。</li>
<li>认证成功后，客户端发送文件操作命令（如 <code>LIST</code>、<code>RETR</code>、<code>STOR</code>）。</li>
<li>根据客户端选择的工作模式（主动&#x2F;被动），建立<strong>数据连接</strong>。</li>
<li>文件数据通过数据连接传输。</li>
<li>数据传输完成后，数据连接关闭。</li>
<li>客户端可以继续通过控制连接发送其他命令，或者发送 <code>QUIT</code> 命令关闭控制连接，结束会话。</li>
</ol>
<h2 id="三、FTP-传输模式-数据连接的建立"><a href="#三、FTP-传输模式-数据连接的建立" class="headerlink" title="三、FTP 传输模式 (数据连接的建立)"></a>三、FTP 传输模式 (数据连接的建立)</h2><p>数据连接的建立方式决定了 FTP 在防火墙和 NAT 环境下的兼容性。</p>
<h3 id="3-1-主动模式-Active-Mode"><a href="#3-1-主动模式-Active-Mode" class="headerlink" title="3.1 主动模式 (Active Mode)"></a>3.1 主动模式 (Active Mode)</h3><p>在主动模式下，<strong>客户端</strong> 通知服务器它将在一个随机端口上监听，<strong>服务器</strong> 主动连接客户端的数据端口。</p>
<ol>
<li>客户端与服务器的 21 端口建立控制连接。</li>
<li>客户端发送 <code>PORT X,X,X,X,A,B</code> 命令给服务器，告诉服务器它的 IP 地址和它正在监听的端口 (A * 256 + B)。</li>
<li>服务器收到 <code>PORT</code> 命令后，主动从它的 <strong>20 端口</strong> (FTP-DATA) 连接到客户端指定的 IP 地址和端口。</li>
<li>数据连接建立，开始传输数据。</li>
</ol>
<p><strong>主动模式的问题</strong>：<br>客户端的随机端口通常位于防火墙或 NAT 后面，服务器无法主动连接到客户端的数据端口，导致数据连接失败。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as FTP 客户端
    participant ClientFW as 客户端防火墙&#x2F;NAT
    participant Server as FTP 服务器
    participant ServerFW as 服务器防火墙

    Client-&gt;&gt;Server: 1. &#96;CONTROL_CONNECT&#96; (Client:&#96;N1&#96; -&gt; Server:&#96;21&#96;)
    Client-&gt;&gt;Server: 2. 用户名&#x2F;密码 (明文)
    Client-&gt;&gt;Server: 3. &#96;PORT client_ip,client_data_port&#96;
    Server-&gt;&gt;ServerFW: 4. 服务器尝试从端口 &#96;20&#96; 连接客户端 &#96;client_data_port&#96;
    ServerFW-&gt;&gt;ClientFW: 5. 客户端防火墙&#x2F;NAT 阻止服务器连接
    ClientFW--xServerFW: 连接失败
    ServerFW--xServer: 连接失败 (通常是超时)
    Server--&gt;&gt;Client: 6. 错误: 无法建立数据连接
  </pre></div>

<h3 id="3-2-被动模式-Passive-Mode"><a href="#3-2-被动模式-Passive-Mode" class="headerlink" title="3.2 被动模式 (Passive Mode)"></a>3.2 被动模式 (Passive Mode)</h3><p>为了解决主动模式在防火墙环境下遇到的问题，引入了被动模式。在被动模式下，<strong>客户端</strong> 告诉服务器进入被动模式，<strong>服务器</strong> 开启一个随机端口并通知客户端，<strong>客户端</strong> 再主动连接服务器的数据端口。这也是当前主流的 FTP 传输模式。</p>
<ol>
<li>客户端与服务器的 21 端口建立控制连接。</li>
<li>客户端发送 <code>PASV</code> 命令给服务器，请求进入被动模式。</li>
<li>服务器收到 <code>PASV</code> 命令后，开启一个随机端口进行监听，并回复 <code>227 Entering Passive Mode (X,X,X,X,A,B)</code> 消息，告诉客户端它的 IP 地址和监听的端口 (A * 256 + B)。</li>
<li>客户端收到服务器的响应后，主动从一个随机端口连接到服务器指定的 IP 地址和端口。</li>
<li>数据连接建立，开始传输数据。</li>
</ol>
<p><strong>被动模式的优点</strong>：<br>客户端主动连接服务器的随机端口，避免了服务器主动连接客户端被防火墙阻止的问题。需要注意的是，服务器的防火墙仍需要允许外部连接到服务器的随机数据端口范围。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as FTP 客户端
    participant ClientFW as 客户端防火墙&#x2F;NAT
    participant Server as FTP 服务器
    participant ServerFW as 服务器防火墙

    Client-&gt;&gt;Server: 1. &#96;CONTROL_CONNECT&#96; (Client:&#96;N1&#96; -&gt; Server:&#96;21&#96;)
    Client-&gt;&gt;Server: 2. 用户名&#x2F;密码 (明文)
    Client-&gt;&gt;Server: 3. &#96;PASV&#96;
    Server-&gt;&gt;Server: 4. 服务器打开一个随机端口 &#96;P2&#96; 进行监听
    Server--&gt;&gt;Client: 5. &#96;227 Entering Passive Mode (server_ip, server_data_port_P2)&#96;
    Client-&gt;&gt;ClientFW: 6. 客户端尝试从端口 &#96;N2&#96; 连接服务器 &#96;P2&#96;
    ClientFW-&gt;&gt;ServerFW: 7. 客户端请求连接
    ServerFW-&gt;&gt;Server: 8. 服务器接受连接
    ServerFW--&gt;&gt;ClientFW: 连接成功
    ClientFW--&gt;&gt;Client: 连接成功
    Client&lt;&lt;-&gt;&gt;Server: 9. &#96;DATA_TRANSFER&#96; (Client:&#96;N2&#96; &lt;-&gt; Server:&#96;P2&#96;)
    Client &lt;&lt;-&gt;&gt; Server: 10. &#96;CONTROL_DISCONNECT&#96;
  </pre></div>

<h2 id="四、FTP-认证与用户类型"><a href="#四、FTP-认证与用户类型" class="headerlink" title="四、FTP 认证与用户类型"></a>四、FTP 认证与用户类型</h2><p>FTP 支持两种主要的用户认证方式：</p>
<ol>
<li><p><strong>匿名 FTP (Anonymous FTP)</strong>：</p>
<ul>
<li>允许用户无需提供真实账户信息即可访问服务器上的公共文件。</li>
<li>用户通常使用 <code>anonymous</code> 作为用户名，并输入其电子邮件地址作为密码（尽管在实践中通常不验证）。</li>
<li>主要用于公开分发文件，如软件下载、文档共享等。</li>
</ul>
</li>
<li><p><strong>用户名&#x2F;密码认证 (Authenticated FTP)</strong>：</p>
<ul>
<li>用户必须提供有效的用户名和密码才能登录。</li>
<li>这些凭证通常与服务器操作系统上的用户账户关联，或者由 FTP 服务器软件自行维护。</li>
<li>提供更精细的权限控制，不同用户可以有不同的访问权限（读、写、删除等）。</li>
</ul>
</li>
</ol>
<h2 id="五、FTP-传输模式-文件内容"><a href="#五、FTP-传输模式-文件内容" class="headerlink" title="五、FTP 传输模式 (文件内容)"></a>五、FTP 传输模式 (文件内容)</h2><p>除了 TCP 连接模式，FTP 还有数据内容的传输模式：</p>
<ul>
<li><strong>ASCII 模式 (文本模式)</strong>：<ul>
<li>适用于传输文本文件。FTP 客户端和服务器会在传输过程中自动进行行结束符的转换（例如，在 Windows 和 Unix 系统之间转换 <code>CRLF</code> 和 <code>LF</code>）。</li>
<li>可能会对二进制文件造成破坏。</li>
</ul>
</li>
<li><strong>Binary 模式 (二进制模式)</strong>：<ul>
<li>适用于传输所有非文本文件，如图片、视频、压缩包、可执行文件等。</li>
<li>数据按字节流原样传输，不进行任何转换。</li>
<li>这是传输二进制文件时必须使用的模式。</li>
</ul>
</li>
</ul>
<h2 id="六、FTP-命令示例"><a href="#六、FTP-命令示例" class="headerlink" title="六、FTP 命令示例"></a>六、FTP 命令示例</h2><p>以下是一些常见的 FTP 命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>USER</code></td>
<td align="left">提供用户名。</td>
</tr>
<tr>
<td align="left"><code>PASS</code></td>
<td align="left">提供密码。</td>
</tr>
<tr>
<td align="left"><code>LIST</code></td>
<td align="left">列出远程服务器上的文件和目录。 (<code>ls</code> 命令的变种，如 <code>LIST -a</code> )</td>
</tr>
<tr>
<td align="left"><code>CWD</code></td>
<td align="left">改变远程服务器上的工作目录。 (<code>cd</code>)</td>
</tr>
<tr>
<td align="left"><code>PWD</code></td>
<td align="left">打印远程服务器上的当前工作目录。 (<code>pwd</code>)</td>
</tr>
<tr>
<td align="left"><code>RETR</code></td>
<td align="left">下载文件（从服务器获取文件到客户端）。</td>
</tr>
<tr>
<td align="left"><code>STOR</code></td>
<td align="left">上传文件（从客户端存储文件到服务器）。</td>
</tr>
<tr>
<td align="left"><code>DELE</code></td>
<td align="left">删除远程服务器上的文件。</td>
</tr>
<tr>
<td align="left"><code>RNFR</code></td>
<td align="left">重命名文件（提供旧文件名）。</td>
</tr>
<tr>
<td align="left"><code>RNTO</code></td>
<td align="left">重命名文件（提供新文件名）。</td>
</tr>
<tr>
<td align="left"><code>MKD</code></td>
<td align="left">在远程服务器上创建目录。 (<code>mkdir</code>)</td>
</tr>
<tr>
<td align="left"><code>RMD</code></td>
<td align="left">删除远程服务器上的目录。 (<code>rmdir</code>)</td>
</tr>
<tr>
<td align="left"><code>TYPE</code></td>
<td align="left">设置文件传输模式 (ASCII 或 BINARY)。</td>
</tr>
<tr>
<td align="left"><code>PASV</code></td>
<td align="left">进入被动模式。</td>
</tr>
<tr>
<td align="left"><code>PORT</code></td>
<td align="left">客户端通知服务器其数据连接端口 (主动模式)。</td>
</tr>
<tr>
<td align="left"><code>QUIT</code></td>
<td align="left">退出 FTP 会话。</td>
</tr>
</tbody></table>
<h2 id="七、FTP-的优缺点"><a href="#七、FTP-的优缺点" class="headerlink" title="七、FTP 的优缺点"></a>七、FTP 的优缺点</h2><h3 id="7-1-优点："><a href="#7-1-优点：" class="headerlink" title="7.1 优点："></a>7.1 优点：</h3><ul>
<li><strong>广泛支持</strong>：几乎所有的操作系统、服务器和网络设备都支持 FTP。</li>
<li><strong>功能全面</strong>：支持文件的上传、下载、删除、重命名、目录管理等。</li>
<li><strong>高效性（对大文件）</strong>：对于大文件传输，FTP 的两连接模式理论上可以实现较高的传输效率，因为它不涉及 HTTP 等协议的额外开销。</li>
<li><strong>恢复传输</strong>：部分 FTP 客户端和服务器支持断点续传。</li>
</ul>
<h3 id="7-2-缺点："><a href="#7-2-缺点：" class="headerlink" title="7.2 缺点："></a>7.2 缺点：</h3><ul>
<li><strong>安全性差 (核心问题)</strong>：<ul>
<li><strong>明文传输</strong>：用户名、密码和所有命令在控制连接中以明文传输，极易被嗅探。</li>
<li><strong>数据不加密</strong>：即使数据通过数据连接传输，默认情况下也没有加密。</li>
<li><strong>缺乏完整性校验</strong>：不提供内置的数据完整性校验机制，攻击者可能篡改传输中的文件。</li>
</ul>
</li>
<li><strong>防火墙和 NAT 兼容性问题</strong>：尤其是在主动模式下，穿越防火墙和 NAT 设备非常困难。被动模式缓解了这个问题，但服务器仍需要开放较大的端口范围。</li>
<li><strong>管理复杂</strong>：为每个文件传输建立和关闭数据连接，在大规模、小文件传输场景下效率不高。</li>
<li><strong>自动化脚本挑战</strong>：FTP 客户端通常是交互式的，通过脚本自动化控制相对复杂（尽管有第三方库和命令行工具可以实现）。</li>
</ul>
<h2 id="八、安全的替代方案"><a href="#八、安全的替代方案" class="headerlink" title="八、安全的替代方案"></a>八、安全的替代方案</h2><p>鉴于 FTP 的安全缺陷，在现代网络环境中，通常推荐使用以下更安全的替代协议：</p>
<ol>
<li><p><strong>SFTP (SSH File Transfer Protocol)</strong>：</p>
<ul>
<li>基于 <strong>SSH (Secure Shell)</strong> 协议，所有通信（包括认证凭证、命令和文件数据）都通过加密的 SSH 信道传输。</li>
<li>使用单一连接，简化了防火墙配置。</li>
<li>提供类似 FTP 的功能（上传、下载、删除、列目录等）。</li>
<li>被认为是 FTP 最安全的替代方案之一。</li>
</ul>
</li>
<li><p><strong>FTPS (FTP Secure)</strong>：</p>
<ul>
<li>通过在 FTP 的控制连接和&#x2F;或数据连接之上添加 <strong>SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security)</strong> 加密层来保护通信。</li>
<li>分为显式 FTPS (Explicit FTPS) 和隐式 FTPS (Implicit FTPS)。</li>
<li>解决了 FTP 的安全性问题，但相比 SFTP，在防火墙和 NAT 后可能仍然有些复杂。</li>
</ul>
</li>
<li><p><strong>HTTPS (HTTP Secure)</strong> 文件传输：</p>
<ul>
<li>通过 HTTP 协议和 SSL&#x2F;TLS 加密层进行文件传输。</li>
<li>常见的 Web 浏览器都支持 HTTPS 下载，许多云存储服务和文件共享系统也都基于 HTTPS。</li>
<li>适用于简单的文件下载和上传，但对于批量或专业的管理功能不如 SFTP 和 FTPS 方便。</li>
</ul>
</li>
</ol>
<p><strong>Python 代码示例：使用 <code>ftplib</code> 进行基本 FTP 操作</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ftplib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ftp_operations</span>(<span class="params">host, username, password, remote_dir, local_file_to_upload, remote_file_to_download</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行基本的FTP操作：连接、上传文件、列目录、下载文件、断开连接。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        host (str): FTP服务器地址。</span></span><br><span class="line"><span class="string">        username (str): 登录用户名。</span></span><br><span class="line"><span class="string">        password (str): 登录密码。</span></span><br><span class="line"><span class="string">        remote_dir (str): 服务器上的目标目录。</span></span><br><span class="line"><span class="string">        local_file_to_upload (str): 本地待上传文件路径。</span></span><br><span class="line"><span class="string">        remote_file_to_download (str): 服务器上待下载文件路径。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ftp = ftplib.FTP()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connecting to <span class="subst">&#123;host&#125;</span>...&quot;</span>)</span><br><span class="line">        <span class="comment"># 连接FTP服务器，默认端口21</span></span><br><span class="line">        ftp.connect(host)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connected.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 登录FTP服务器 (明文传输用户名和密码)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Logging in as <span class="subst">&#123;username&#125;</span>...&quot;</span>)</span><br><span class="line">        ftp.login(username, password)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Logged in successfully.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切换到指定目录</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Changing directory to <span class="subst">&#123;remote_dir&#125;</span>...&quot;</span>)</span><br><span class="line">        ftp.cwd(remote_dir)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Current remote directory: <span class="subst">&#123;ftp.pwd()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># === 上传文件 ===</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(local_file_to_upload):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(local_file_to_upload, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Uploading <span class="subst">&#123;local_file_to_upload&#125;</span> to server...&quot;</span>)</span><br><span class="line">                <span class="comment"># &#x27;STOR&#x27; 命令用于上传文件</span></span><br><span class="line">                ftp.storbinary(<span class="string">f&#x27;STOR <span class="subst">&#123;os.path.basename(local_file_to_upload)&#125;</span>&#x27;</span>, f)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;File <span class="subst">&#123;local_file_to_upload&#125;</span> uploaded.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Local file <span class="subst">&#123;local_file_to_upload&#125;</span> not found for upload.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># === 列出远程目录内容 ===</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nListing remote directory contents:&quot;</span>)</span><br><span class="line">        files = ftp.nlst() <span class="comment"># nlst() 获取文件和目录名列表</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  - <span class="subst">&#123;f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># === 下载文件 ===</span></span><br><span class="line">        download_target_path = <span class="string">f&quot;downloaded_<span class="subst">&#123;os.path.basename(remote_file_to_download)&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(download_target_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;\nDownloading <span class="subst">&#123;remote_file_to_download&#125;</span> from server...&quot;</span>)</span><br><span class="line">            <span class="comment"># &#x27;RETR&#x27; 命令用于下载文件</span></span><br><span class="line">            ftp.retrbinary(<span class="string">f&#x27;RETR <span class="subst">&#123;remote_file_to_download&#125;</span>&#x27;</span>, f.write)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;File downloaded to <span class="subst">&#123;download_target_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> ftplib.all_errors <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;FTP Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An unexpected error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> ftp:</span><br><span class="line">            ftp.quit() <span class="comment"># 关闭FTP连接</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;FTP connection closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># ⚠️ 注意: 请不要在生产环境中使用明文密码！FTP 极不安全！</span></span><br><span class="line">    FTP_HOST = <span class="string">&quot;ftp.example.com&quot;</span>  <span class="comment"># 替换为你的FTP服务器地址</span></span><br><span class="line">    FTP_USER = <span class="string">&quot;your_username&quot;</span>    <span class="comment"># 替换为你的FTP用户名</span></span><br><span class="line">    FTP_PASS = <span class="string">&quot;your_password&quot;</span>    <span class="comment"># 替换为你的FTP密码</span></span><br><span class="line"></span><br><span class="line">    REMOTE_DIRECTORY = <span class="string">&quot;/&quot;</span>        <span class="comment"># 服务器上的目标目录</span></span><br><span class="line">    LOCAL_FILE = <span class="string">&quot;test_upload.txt&quot;</span></span><br><span class="line">    REMOTE_FILE = <span class="string">&quot;remote_test_file.txt&quot;</span> <span class="comment"># 假设服务器上存在此文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个用于上传的测试文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(LOCAL_FILE, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;This is a test file for FTP upload.\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;It contains multiple lines of text.\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Created local test file: <span class="subst">&#123;LOCAL_FILE&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行FTP操作</span></span><br><span class="line">    ftp_operations(FTP_HOST, FTP_USER, FTP_PASS, REMOTE_DIRECTORY, LOCAL_FILE, REMOTE_FILE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理本地创建的测试文件</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(LOCAL_FILE):</span><br><span class="line">        os.remove(LOCAL_FILE)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Removed local test file: <span class="subst">&#123;LOCAL_FILE&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">f&quot;downloaded_<span class="subst">&#123;os.path.basename(REMOTE_FILE)&#125;</span>&quot;</span>):</span><br><span class="line">        os.remove(<span class="string">f&quot;downloaded_<span class="subst">&#123;os.path.basename(REMOTE_FILE)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Removed downloaded test file: downloaded_<span class="subst">&#123;os.path.basename(REMOTE_FILE)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>FTP 协议作为文件传输的先驱，在互联网早期发挥了巨大的作用。它通过分离控制连接和数据连接的设计，实现了灵活的文件传输。然而，其最严重的缺陷是<strong>缺乏安全性</strong>，所有敏感信息（包括认证凭证）都以明文形式传输，极易被攻击者窃取和篡改。在当今对网络安全要求极高的环境中，已经不推荐在公共网络上使用纯 FTP 进行文件传输。相反，<strong>SFTP 或 FTPS</strong> 提供了更安全的替代方案，它们在保留 FTP 功能的同时，利用加密技术保护了数据的机密性和完整性。在选择文件传输协议时，安全性应始终是首要考虑的因素。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/82faa099bd25/">https://blog.tbf1211.xx.kg/82faa099bd25/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/18f2ce1e9660/" title="DNS (Domain Name System) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DNS (Domain Name System) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS (Domain Name System) 是互联网的一项核心服务，它将人类可读的域名（如 www.example.com）转换为机器可读的 IP 地址（如 192.168.1.1 或 2001:0db8::1）。这种翻译功能使得用户可以方便地通过记忆友好的域名来访问网站和其他网络资源，而无需记住复杂的数字 IP 地址。DNS 本质上是一个分布式数据库系统，运行在应用层，通常使用 UDP 的 53 端口进行查询，TCP 53 端口用于区域传输 (zone transfer)。  核心思想：将域名映射到 IP 地址，提供一套全球性的、分层的、分布式数据库系统，从而实现互联网资源的定位和访问。   一、为什么需要 DNS？在互联网的早期，少量的计算机通过一个名为 HOSTS.TXT 的静态文件来完成主机名到 IP 地址的映射。然而，随着计算机数量的爆发式增长，这种中心化的、静态的管理方式变得不可行，主要原因如下：  人类记忆限制：用户难以记住大量复杂且不断变化的 IP 地址。 管理困难：集中式文件更新和同步的效率低下，无法适应全球范围内的网络变化。 扩展性差：集中式系统无法承...</div></div></div></a><a class="pagination-related" href="/23aa2938b836/" title="跨域问题详解及解决方案"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">跨域问题详解及解决方案</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，“跨域” (Cross-Origin) 是一个非常常见且令人困扰的问题。它源于浏览器的一项重要安全策略：同源策略 (Same-Origin Policy)。理解同源策略以及如何安全有效地解决跨域问题，是每个 Web 开发者必备的知识。  核心思想：同源策略是浏览器的一项安全机制，它限制了来自一个源的文档或脚本与来自另一个源的资源进行交互。当请求的目标源与当前页面的源不一致时，就发生了跨域。解决跨域问题的关键是让服务器端或中间代理明确允许跨域请求。    一、什么是同源策略 (Same-Origin Policy)？同源策略 是浏览器为了保护用户隐私和数据安全而制定的一项基本安全功能。它限制了一个 HMTL 文档中加载的脚本如何与来自不同源的资源进行交互。 1.1 “源”的定义如果两个 URL 的协议 (Protocol)、域名 (Domain) 和端口 (Port) 都相同，则称它们是“同源”的。只要其中任何一个不同，就被认为是“跨源”或“不同源”。    URL A URL B 结果 原因    http://example.com/a.html http...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/a148e5499a60/" title="IPSec (Internet Protocol Security) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-13</div><div class="info-item-2">IPSec (Internet Protocol Security) 详解</div></div><div class="info-2"><div class="info-item-1"> IPSec (Internet Protocol Security) 是一套在 IP 层 (网络层) 提供安全服务的协议族。它不依赖于任何特定的应用程序，而是通过加密和认证 IP 数据包在网络中安全传输。IPSec 广泛应用于构建 VPN (Virtual Private Network - 虚拟专用网络)，为远程用户、分支机构和云资源提供安全的、端到端的通信。它提供了数据完整性、数据源认证、防重放保护以及数据机密性等关键安全服务。  核心思想：IPSec 通过在网络层透明地加密和认证 IP 数据包，为 IP 通信提供端到端的安全保障，是构建安全 VPN 和保护 IP 流量的核心技术。   一、IPSec 概述1.1 什么是 IPSec？IPSec 是由 IETF (Internet Engineering Task Force) 定义的一整套开放标准的协议族，它工作在 OSI 模型的网络层 (Layer 3)。其核心目标是为 IP 通信提供高级安全功能，而无需修改应用程序。 1.2 为什么需要 IPSec？传统的 IP 协议本身无法提供数据的机密性、完整性或认证。数据在公共网...</div></div></div></a><a class="pagination-related" href="/55a0c7732ea3/" title="QUIC (Quick UDP Internet Connections) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="info-item-2">QUIC (Quick UDP Internet Connections) 详解</div></div><div class="info-2"><div class="info-item-1"> QUIC (Quick UDP Internet Connections) 是由 Google 最早开发的一种通用的传输层网络协议，它旨在通过在 UDP 协议之上实现可靠性和安全性来加速 HTTP 流量。QUIC 合并了 TCP、TLS 和 HTTP&#x2F;2 的最佳特性，并针对现代互联网环境进行了优化，解决了 TCP 的一些固有局限性。目前，QUIC 已经由 IETF (Internet Engineering Task Force) 标准化为 RFC 9000 系列，并作为 HTTP&#x2F;3 的底层传输协议。  核心思想：QUIC 将 TCP 连接管理、TLS 加密和 HTTP&#x2F;2 多路复用等功能集成到 UDP 上，通过 0-RTT 连接、独立流、更快的连接迁移和可插拔拥塞控制，实现了低延迟、高吞吐量和强大的安全性。   一、为什么需要 QUIC？尽管 TCP&#x2F;IP 协议栈在过去几十年中支撑了整个互联网，但随着网络应用的发展和移动设备的普及，TCP 的一些固有缺陷逐渐显现出来：  TCP 三次握手延迟 (3-RTT)：每次建立新的 TCP 连接...</div></div></div></a><a class="pagination-related" href="/f3c9e80cbf78/" title="ICMP 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="info-item-2">ICMP 协议详解</div></div><div class="info-2"><div class="info-item-1"> ICMP (Internet Control Message Protocol)，互联网控制消息协议，是 TCP&#x2F;IP 协议族中的一个核心协议。它主要用于在 IP 主机和路由器之间传递控制消息，这些控制消息可以报告数据报的处理错误，或者提供诊断信息。与 IP 协议的“尽力而为”特性不同，ICMP 为网络层提供了基本的错误报告和查询功能，但它本身并不能修复错误，只是提供一个通知机制。ICMP 消息被封装在 IP 数据报中传输，不提供可靠性保证。  核心思想：作为 IP 协议的“辅助”协议，ICMP 在网络层提供错误报告和诊断功能，帮助网络设备了解网络状态。    一、为什么需要 ICMP？IP 协议是一个无连接、不可靠的“尽力而为”的网络层协议。这意味着 IP 数据报在传输过程中可能丢失、重复、乱序，并且没有任何机制通知发送方这些问题。如果仅仅依赖 IP 协议，当数据报遇到各种网络问题（如目标不可达、路由循环、TTL 超时等）时，发送方将无从得知其数据报的命运。 ICMP 协议的引入正是为了弥补 IP 协议的这一不足：  错误报告 (Error Reporting)：当...</div></div></div></a><a class="pagination-related" href="/33c4660f6509/" title="SSH (Secure Shell) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-07</div><div class="info-item-2">SSH (Secure Shell) 协议详解</div></div><div class="info-2"><div class="info-item-1"> SSH (Secure Shell) 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。  核心思想：通过在不可信网络上建立加密通道，保障客户端与服务器之间通信的机密性、完整性和认证性。   一、为什么需要 SSH？在 SSH 出现之前，远程管理和文件传输主要依赖 Telnet、RSH (Remote Shell)、FTP (File Transfer Protocol) 等协议。这些协议存在严重的安全缺陷：  明文传输：用户名、密码和所有数据在网络中以明文形式传输，极易被窃听。 缺乏认证：无法有效验证远程主机的身份，容易遭受中间人攻击 (Man-in-the-Middle, MITM)。  SSH 的设计目标就是解决这些问题，提供一个安全的替代方案：  数据加密：所有传输数据（包括登录凭证和操作命令）都经过加密，防止窃听。 强大的...</div></div></div></a><a class="pagination-related" href="/bfc3178a0093/" title="FRP (Fast Reverse Proxy) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="info-item-2">FRP (Fast Reverse Proxy) 详解</div></div><div class="info-2"><div class="info-item-1"> FRP (Fast Reverse Proxy) 是一个高性能的内网穿透和反向代理工具，它允许您将位于内网（局域网）中的服务（如 Web 服务器、SSH、数据库等）通过一台具有公网 IP 的服务器暴露给公网用户访问。在当前 IPv4 地址资源日益紧张，许多家庭和小型办公室难以获取公网 IP 的背景下，FRP 提供了便捷、高效的解决方案。  核心思想：FRP 通过在公网服务器上运行一个 frps (服务端) 和在内网机器上运行一个 frpc (客户端) 来建立连接。内网流量经由 frpc 转发到 frps，再由 frps 转发到公网用户，实现内网服务的公网访问。   一、为什么需要 FRP？在许多场景下，我们需要从外部网络访问位于内网的服务，但常常面临以下问题：  没有公网 IP：大多数家庭宽带用户和一些小型企业用户不再拥有独立的公网 IPv4 地址。他们处于运营商的 NAT (Network Address Translation) 之后，无法直接从外部访问内网设备。 端口转发困难：即使有公网 IP，也可能需要手动在路由器上配置端口转发规则，这对于不熟悉网络配置的用户来说可能比...</div></div></div></a><a class="pagination-related" href="/378a51590e55/" title="HTTP&#x2F;1.1 协议深度详解：Web 通信的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="info-item-2">HTTP&#x2F;1.1 协议深度详解：Web 通信的基石</div></div><div class="info-2"><div class="info-item-1"> HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。  核心思想：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于请求-响应模型，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。   一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：  短连接 (Short Connection)：HTTP&#x2F;1.0 默认每个请求&#x2F;响应...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">551</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-FTP%EF%BC%9F"><span class="toc-text">一、为什么需要 FTP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81FTP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、FTP 的基本工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5-Control-Connection"><span class="toc-text">2.1 控制连接 (Control Connection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5-Data-Connection"><span class="toc-text">2.2 数据连接 (Data Connection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">2.3 工作流程概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81FTP-%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F-%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">三、FTP 传输模式 (数据连接的建立)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F-Active-Mode"><span class="toc-text">3.1 主动模式 (Active Mode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F-Passive-Mode"><span class="toc-text">3.2 被动模式 (Passive Mode)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81FTP-%E8%AE%A4%E8%AF%81%E4%B8%8E%E7%94%A8%E6%88%B7%E7%B1%BB%E5%9E%8B"><span class="toc-text">四、FTP 认证与用户类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81FTP-%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">五、FTP 传输模式 (文件内容)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81FTP-%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-text">六、FTP 命令示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81FTP-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">七、FTP 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">7.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">7.2 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AE%89%E5%85%A8%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-text">八、安全的替代方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">九、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-18.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>