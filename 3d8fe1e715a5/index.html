<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python lxml详解：高效XML/HTML解析与处理 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="lxml 是 Python 的一个强大且功能丰富的库，用于解析和处理 XML 和 HTML 文档。它结合了 C 语言库 libxml2 和 libxslt 的速度和功能，以及 Python 的简洁和灵活性。lxml 提供了多种解析方式（如 ElementTree API 和 SAX），并支持强大的 XPath 和 CSS 选择器进行数据提取。在高性能要求的场景下，lxml 往往是处理大型 XML">
<meta property="og:type" content="article">
<meta property="og:title" content="Python lxml详解：高效XML&#x2F;HTML解析与处理">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/3d8fe1e715a5/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="lxml 是 Python 的一个强大且功能丰富的库，用于解析和处理 XML 和 HTML 文档。它结合了 C 语言库 libxml2 和 libxslt 的速度和功能，以及 Python 的简洁和灵活性。lxml 提供了多种解析方式（如 ElementTree API 和 SAX），并支持强大的 XPath 和 CSS 选择器进行数据提取。在高性能要求的场景下，lxml 往往是处理大型 XML">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg">
<meta property="article:published_time" content="2023-06-04T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-28T09:11:10.445Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="lxml">
<meta property="article:tag" content="网络爬虫">
<meta property="article:tag" content="XML">
<meta property="article:tag" content="XPath">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python lxml详解：高效XML/HTML解析与处理",
  "url": "https://blog.tbf1211.xx.kg/3d8fe1e715a5/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg",
  "datePublished": "2023-06-04T22:24:00.000Z",
  "dateModified": "2026-01-28T09:11:10.445Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/3d8fe1e715a5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python lxml详解：高效XML/HTML解析与处理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">527</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-31.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python lxml详解：高效XML/HTML解析与处理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python lxml详解：高效XML/HTML解析与处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-06-04T22:24:00.000Z" title="发表于 2023-06-05 06:24:00">2023-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E5%BA%93/">库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>lxml</strong> 是 Python 的一个强大且功能丰富的库，用于解析和处理 XML 和 HTML 文档。它结合了 C 语言库 <code>libxml2</code> 和 <code>libxslt</code> 的速度和功能，以及 Python 的简洁和灵活性。lxml 提供了多种解析方式（如 ElementTree API 和 SAX），并支持强大的 XPath 和 CSS 选择器进行数据提取。在高性能要求的场景下，lxml 往往是处理大型 XML&#x2F;HTML 文档的首选。</p>
</blockquote>
<div class="note info flat"><p>核心思想：lxml 利用底层的 C 库，提供了比纯 Python 解析器快得多的性能，同时通过 Pythonic 的接口，使得 XML&#x2F;HTML 的解析、导航和数据提取变得高效而直观。</p>
</div>
<hr>
<h2 id="一、为什么选择-lxml？"><a href="#一、为什么选择-lxml？" class="headerlink" title="一、为什么选择 lxml？"></a>一、为什么选择 lxml？</h2><p>在 Python 处理 XML&#x2F;HTML 文档时，我们有多种选择，例如 Python 标准库中的 <code>xml.etree.ElementTree</code>、<code>minidom</code>，以及 <code>Beautiful Soup</code>。然而，lxml 在性能和功能上提供了独特的优势：</p>
<ol>
<li><strong>极高的性能</strong>：由于其核心解析引擎是用 C 语言实现的 <code>libxml2</code> 和 <code>libxslt</code>，lxml 在处理大型文档时比纯 Python 解析器（如 <code>html.parser</code> 或 <code>ElementTree</code>）快得多，尤其是在内存使用方面也更高效。</li>
<li><strong>功能全面</strong>：<ul>
<li><strong>支持 XPath</strong>：提供强大而灵活的 XPath 表达式，用于在文档中精确查找元素。</li>
<li><strong>支持 CSS Selector</strong>：通过 <code>lxml.cssselect</code> 模块提供熟悉的 CSS 选择器语法。</li>
<li><strong>XML Schema&#x2F;DTD 验证</strong>：支持对 XML 文档进行结构验证。</li>
<li><strong>XSLT 转换</strong>：实现 XML 文档的转换。</li>
<li><strong>XML 片段解析</strong>：能解析不完整的 XML&#x2F;HTML 片段。</li>
</ul>
</li>
<li><strong>容错性好</strong>：在解析 HTML 文档时，lxml 表现出与浏览器类似的容错性，能够处理不规范的 HTML 标签结构。</li>
<li><strong>Pythonic API</strong>：虽然底层是 C 库，但 lxml 提供了非常 Pythonic 和直观的 API，易于学习和使用。</li>
<li><strong>与 Beautiful Soup 结合</strong>：Beautiful Soup 可以使用 lxml 作为其底层解析器 (<code>BeautifulSoup(html_content, &#39;lxml&#39;)</code>)，以兼顾 Beautiful Soup 的易用性和 lxml 的解析速度。</li>
</ol>
<h2 id="二、安装-lxml"><a href="#二、安装-lxml" class="headerlink" title="二、安装 lxml"></a>二、安装 lxml</h2><p>lxml 可以通过 <code>pip</code> 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br></pre></td></tr></table></figure>

<h2 id="三、基本使用：解析-XML-HTML-文档"><a href="#三、基本使用：解析-XML-HTML-文档" class="headerlink" title="三、基本使用：解析 XML&#x2F;HTML 文档"></a>三、基本使用：解析 XML&#x2F;HTML 文档</h2><p>lxml 提供了 <strong><code>etree</code></strong> 模块，它是其核心，用于 Tree API 相关操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree, html</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 解析 XML 字符串</span></span><br><span class="line">xml_string = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;root&gt;</span></span><br><span class="line"><span class="string">    &lt;country name=&quot;Liechtenstein&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;rank&gt;1&lt;/rank&gt;</span></span><br><span class="line"><span class="string">        &lt;year&gt;2008&lt;/year&gt;</span></span><br><span class="line"><span class="string">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span></span><br><span class="line"><span class="string">        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/country&gt;</span></span><br><span class="line"><span class="string">    &lt;country name=&quot;Singapore&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;rank&gt;4&lt;/rank&gt;</span></span><br><span class="line"><span class="string">        &lt;year&gt;2011&lt;/year&gt;</span></span><br><span class="line"><span class="string">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span></span><br><span class="line"><span class="string">        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/country&gt;</span></span><br><span class="line"><span class="string">&lt;/root&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 fromstring 解析 XML 字符串</span></span><br><span class="line">xml_root = etree.fromstring(xml_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 解析 XML 字符串 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;根元素标签: <span class="subst">&#123;xml_root.tag&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个国家名称: <span class="subst">&#123;xml_root.find(<span class="string">&#x27;country&#x27;</span>).get(<span class="string">&#x27;name&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析 HTML 字符串</span></span><br><span class="line">html_string = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;title&gt;My Awesome Page&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Welcome&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;ul id=&quot;menu&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/products&quot;&gt;Products&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About Us&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;This is a paragraph with some &lt;b class=&quot;highlight&quot;&gt;bold text&lt;/b&gt;.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;Another paragraph.&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- This is a comment --&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 html.fromstring 解析 HTML 字符串</span></span><br><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 解析 HTML 字符串 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;HTML 根元素标签: <span class="subst">&#123;html_root.tag&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;页面标题: <span class="subst">&#123;html_root.xpath(<span class="string">&#x27;//title/text()&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>) <span class="comment"># 使用 XPath 提取标题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 从文件或 URL 加载 (推荐使用 requests 获取内容再解析)</span></span><br><span class="line"><span class="comment"># 以加载 example.com 为例</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&quot;http://www.example.com&quot;</span>)</span><br><span class="line">    response.raise_for_status() <span class="comment"># 检查请求是否成功</span></span><br><span class="line">    remote_html_root = html.fromstring(response.text)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 解析 www.example.com ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;远程页面标题: <span class="subst">&#123;remote_html_root.xpath(<span class="string">&#x27;//title/text()&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n无法访问 www.example.com: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># etree.parse() 可以直接从文件路径或文件对象加载</span></span><br><span class="line"><span class="comment"># tree = etree.parse(&#x27;my_document.xml&#x27;)</span></span><br><span class="line"><span class="comment"># root = tree.getroot()</span></span><br></pre></td></tr></table></figure>

<h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li><strong><code>etree.fromstring()</code></strong>: 用于从<strong>字符串</strong>解析 XML。</li>
<li><strong><code>html.fromstring()</code></strong>: 用于从<strong>字符串</strong>解析 HTML。它会自动处理 HTML 的容错性。</li>
<li><strong><code>etree.parse()</code></strong>: 用于从<strong>文件路径或文件对象</strong>解析 XML&#x2F;HTML 文件。</li>
</ul>
<p>一旦文档被解析，它就变成了一个 <code>Element</code> 对象（通常是根元素），你可以像操作树一样遍历和查询它。</p>
<h2 id="四、导航文档树"><a href="#四、导航文档树" class="headerlink" title="四、导航文档树"></a>四、导航文档树</h2><p>lxml 的元素对象提供了多种属性和方法来导航文档树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新解析 HTML 文档</span></span><br><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 子元素 (children)</span></span><br><span class="line"><span class="comment"># 获取 body 标签</span></span><br><span class="line">body = html_root.find(<span class="string">&#x27;body&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 导航子元素 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;body 的子元素标签:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> body:</span><br><span class="line">    <span class="comment"># 过滤掉非 Element 类型的子节点（如 NavigableString 或 Comment），这些默认会被忽略</span></span><br><span class="line">    <span class="comment"># 如果要包含文本节点，需要特定处理，后面会提到</span></span><br><span class="line">    <span class="built_in">print</span>(child.tag)</span><br><span class="line"><span class="comment"># h1</span></span><br><span class="line"><span class="comment"># ul</span></span><br><span class="line"><span class="comment"># p</span></span><br><span class="line"><span class="comment"># div</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 父元素 (parent)</span></span><br><span class="line">first_li = html_root.find(<span class="string">&#x27;.//li&#x27;</span>) <span class="comment"># 找到第一个 li</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n--- 导航父元素 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个 li 的父级是: <span class="subst">&#123;first_li.getparent().tag&#125;</span>&quot;</span>) <span class="comment"># ul</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 兄弟元素 (siblings)</span></span><br><span class="line">first_li = html_root.xpath(<span class="string">&quot;//li&quot;</span>)[<span class="number">0</span>] <span class="comment"># 获取第一个 li 标签</span></span><br><span class="line">next_li = first_li.getnext()</span><br><span class="line">prev_li = next_li.getprevious()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 导航兄弟元素 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个 li: <span class="subst">&#123;first_li.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个 li 的下一个兄弟: <span class="subst">&#123;next_li.text&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第二个 li 的上一个兄弟: <span class="subst">&#123;prev_li.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：lxml 的 .text 属性只会获取当前标签的直接文本内容，不包括子标签的文本。</span></span><br><span class="line"><span class="comment"># 如果标签内部有文本和子标签，.text 只获取标签开头到第一个子标签之间的文本。</span></span><br><span class="line"><span class="comment"># 例如 &lt;p&gt;Hello &lt;b&gt;World&lt;/b&gt;!&lt;/p&gt;，p.text 得到 &#x27;Hello &#x27;</span></span><br><span class="line">p_tag = html_root.xpath(<span class="string">&quot;//p&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nP 标签的文本内容: <span class="subst">&#123;p_tag.text&#125;</span>&quot;</span>) <span class="comment"># &#x27;This is a paragraph with some &#x27;</span></span><br><span class="line"></span><br><span class="line">bold_tag = p_tag.find(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Bold 标签的文本内容: <span class="subst">&#123;bold_tag.text&#125;</span>&quot;</span>) <span class="comment"># &#x27;bold text&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有文本内容（包括子标签的）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;P 标签及其子标签的完整文本内容: <span class="subst">&#123;<span class="string">&#x27;&#x27;</span>.join(p_tag.xpath(<span class="string">&#x27;.//text()&#x27;</span>))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="五、搜索文档树：XPath-和-CSS-Selector"><a href="#五、搜索文档树：XPath-和-CSS-Selector" class="headerlink" title="五、搜索文档树：XPath 和 CSS Selector"></a>五、搜索文档树：XPath 和 CSS Selector</h2><p>lxml 最强大的功能之一是使用 XPath 和 CSS 选择器进行数据提取。</p>
<h3 id="5-1-XPath-XML-Path-Language"><a href="#5-1-XPath-XML-Path-Language" class="headerlink" title="5.1 XPath (XML Path Language)"></a>5.1 XPath (XML Path Language)</h3><p>XPath 是一种在 XML 文档中查找信息的语言。lxml 完全支持 XPath 1.0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- XPath 搜索 ---&quot;</span>)</span><br><span class="line"><span class="comment"># 1. 查找所有 &lt;a&gt; 标签</span></span><br><span class="line">all_a = html_root.xpath(<span class="string">&#x27;//a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;所有 &lt;a&gt; 标签数量: <span class="subst">&#123;<span class="built_in">len</span>(all_a)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> all_a:</span><br><span class="line">    <span class="built_in">print</span>(a.get(<span class="string">&#x27;href&#x27;</span>), a.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查找 id=&quot;menu&quot; 的 ul 标签下的所有 li 标签</span></span><br><span class="line">menu_items = html_root.xpath(<span class="string">&#x27;//ul[@id=&quot;menu&quot;]/li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n菜单项数量: <span class="subst">&#123;<span class="built_in">len</span>(menu_items)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> menu_items:</span><br><span class="line">    <span class="built_in">print</span>(li.text.strip(), li.find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>)) <span class="comment"># li.text 可能会包含换行符和空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查找 class=&quot;active&quot; 的 li 标签</span></span><br><span class="line">active_item = html_root.xpath(<span class="string">&#x27;//li[@class=&quot;active&quot;]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n活跃菜单项: <span class="subst">&#123;active_item[<span class="number">0</span>].find(<span class="string">&#x27;a&#x27;</span>).text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 获取所有文本内容</span></span><br><span class="line">all_text = html_root.xpath(<span class="string">&#x27;//body//text()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nBody 内所有文本内容:&quot;</span>)</span><br><span class="line"><span class="comment"># print(&#x27;&#x27;.join(all_text)) # 可能会包含多余的换行和空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 带相对路径的 XPath</span></span><br><span class="line">some_p = html_root.xpath(<span class="string">&quot;//p&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">bold_in_p = some_p.xpath(<span class="string">&#x27;.//b&#x27;</span>)[<span class="number">0</span>] <span class="comment"># 在 p 标签的子节点中查找 b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nP 标签内的粗体文本: <span class="subst">&#123;bold_in_p.text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>常用 XPath 表达式：</strong></p>
<ul>
<li><code>//tagname</code>: 查找文档中所有指定标签名的元素。</li>
<li><code>/root/child</code>: 查找根元素下的直接子元素。</li>
<li><code>//tagname[@attribute=&quot;value&quot;]</code>: 查找具有特定属性值的标签。</li>
<li><code>//tagname[condition]</code>: 查找满足条件的标签。</li>
<li><code>//tagname[position()]</code>: 根据位置查找（如 <code>[1]</code> 第一个，<code>[last()]</code> 最后一个）。</li>
<li><code>//tagname/text()</code>: 提取标签内的直接文本内容。</li>
<li><code>//tagname/@attribute</code>: 提取标签的属性值。</li>
<li><code>.</code>: 当前节点。</li>
<li><code>..</code>: 父节点。</li>
</ul>
<h3 id="5-2-CSS-Selector"><a href="#5-2-CSS-Selector" class="headerlink" title="5.2 CSS Selector"></a>5.2 CSS Selector</h3><p>lxml 通过 <code>lxml.cssselect</code> 模块支持 CSS 选择器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.cssselect <span class="keyword">import</span> CSSSelector</span><br><span class="line"></span><br><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- CSS Selector 搜索 ---&quot;</span>)</span><br><span class="line"><span class="comment"># 1. 查找所有 li 标签</span></span><br><span class="line">sel_li = CSSSelector(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">all_li = sel_li(html_root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;所有 li 标签数量 (CSS): <span class="subst">&#123;<span class="built_in">len</span>(all_li)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查找 id 为 menu 的 ul 标签下的直接子 li 标签</span></span><br><span class="line">sel_menu_li = CSSSelector(<span class="string">&#x27;ul#menu &gt; li&#x27;</span>)</span><br><span class="line">menu_items_css = sel_menu_li(html_root)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n菜单项数量 (CSS): <span class="subst">&#123;<span class="built_in">len</span>(menu_items_css)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> menu_items_css:</span><br><span class="line">    <span class="built_in">print</span>(li.find(<span class="string">&#x27;a&#x27;</span>).text, li.find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查找 class 为 highlight 的 b 标签</span></span><br><span class="line">sel_bold = CSSSelector(<span class="string">&#x27;b.highlight&#x27;</span>)</span><br><span class="line">bold_text = sel_bold(html_root)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n高亮粗体文本 (CSS): <span class="subst">&#123;bold_text.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接在 Element 对象上使用 .cssselect()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n使用 Element.cssselect() 查找 P 标签下的 b 标签: <span class="subst">&#123;html_root.cssselect(<span class="string">&#x27;p b&#x27;</span>)[<span class="number">0</span>].text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>常用 CSS Selector 表达式：</strong></p>
<ul>
<li><code>tagname</code>: 匹配所有指定标签名的元素。</li>
<li><code>.classname</code>: 匹配所有具有指定 class 的元素。</li>
<li><code>#id</code>: 匹配指定 id 的元素。</li>
<li><code>tagname.classname</code>: 匹配同时具有标签名和 class 的元素。</li>
<li><code>tagname#id</code>: 匹配同时具有标签名和 id 的元素。</li>
<li><code>element[attribute=&quot;value&quot;]</code>: 匹配具有特定属性值的元素。</li>
<li><code>parent &gt; child</code>: 匹配作为 <code>parent</code> 直接子元素的 <code>child</code>。</li>
<li><code>ancestor descendant</code>: 匹配作为 <code>ancestor</code> 子孙元素的 <code>descendant</code>。</li>
<li><code>element:nth-child(n)</code>: 匹配第 n 个子元素。</li>
</ul>
<h2 id="六、修改文档树"><a href="#六、修改文档树" class="headerlink" title="六、修改文档树"></a>六、修改文档树</h2><p>lxml 也允许修改文档树，例如添加、删除或修改元素和属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">html_root = html.fromstring(html_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 添加属性</span></span><br><span class="line">h1_tag = html_root.find(<span class="string">&#x27;body/h1&#x27;</span>)</span><br><span class="line">h1_tag.<span class="built_in">set</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;main-title&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n添加 ID 属性后的 h1 标签: <span class="subst">&#123;h1_tag.xpath(<span class="string">&#x27;@id&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>) <span class="comment"># main-title</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 修改文本</span></span><br><span class="line">first_a = html_root.xpath(<span class="string">&#x27;//ul//a&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">first_a.text = <span class="string">&quot;Homepage&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n修改文本后的第一个链接: <span class="subst">&#123;first_a.text&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加子元素</span></span><br><span class="line">new_li = etree.Element(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">new_a = etree.SubElement(new_li, <span class="string">&#x27;a&#x27;</span>, href=<span class="string">&quot;/contact&quot;</span>)</span><br><span class="line">new_a.text = <span class="string">&quot;Contact&quot;</span></span><br><span class="line">menu_ul = html_root.find(<span class="string">&#x27;.//ul&#x27;</span>)</span><br><span class="line">menu_ul.append(new_li)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n添加新菜单项后的 UL 标签 (部分):&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> menu_ul:</span><br><span class="line">    <span class="built_in">print</span>(item.text.strip(), item.find(<span class="string">&#x27;a&#x27;</span>).text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除元素</span></span><br><span class="line">p_to_remove = html_root.xpath(<span class="string">&quot;//p&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">p_to_remove.getparent().remove(p_to_remove) <span class="comment"># 从父节点移除</span></span><br><span class="line"><span class="comment"># 此时文档中的第一个 &lt;p&gt; 标签已被删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 序列化回字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 修改后的 HTML (prettify) ---&quot;</span>)</span><br><span class="line"><span class="comment"># etree.tostring 可以将 Element 对象序列化为字节串</span></span><br><span class="line"><span class="comment"># etree.tostring(html_root, pretty_print=True).decode()</span></span><br><span class="line"><span class="comment"># html.tostring 更适用于 HTML 文档的序列化</span></span><br><span class="line"><span class="built_in">print</span>(html.tostring(html_root, pretty_print=<span class="literal">True</span>, encoding=<span class="string">&#x27;unicode&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="七、性能与内存考虑"><a href="#七、性能与内存考虑" class="headerlink" title="七、性能与内存考虑"></a>七、性能与内存考虑</h2><p>lxml 的核心优势在于性能，尤其是在处理大型文件时。</p>
<ul>
<li><strong>高效解析</strong>：由于 C 语言底层实现，解析速度快，内存占用低。</li>
<li><strong>SAX 解析</strong>：对于超大型 XML 文件（GB 级别），如果无法一次性加载到内存中，可以使用 lxml 提供的 SAX（Simple API for XML）解析器进行事件驱动解析，逐块处理数据而无需构建整个 DOM 树。</li>
<li><strong>增量解析</strong>：lxml 还支持增量解析，在接收到部分数据时即可开始解析。</li>
</ul>
<h2 id="八、lxml-vs-Beautiful-Soup"><a href="#八、lxml-vs-Beautiful-Soup" class="headerlink" title="八、lxml vs Beautiful Soup"></a>八、lxml vs Beautiful Soup</h2><p>Lxml 和 Beautiful Soup 各有优势，通常在项目选择时需要权衡：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">lxml</th>
<th align="left">Beautiful Soup</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>极佳</strong> (C 语言底层)</td>
<td align="left">相对较慢 (纯 Python)</td>
</tr>
<tr>
<td align="left"><strong>容错性</strong></td>
<td align="left">很好 (对于 HTML 解析)</td>
<td align="left"><strong>极佳</strong> (专为不规范 HTML 设计)</td>
</tr>
<tr>
<td align="left"><strong>API</strong></td>
<td align="left">更偏向标准 XML&#x2F;HTML API (<mark>XPath, CSS选择器</mark>)</td>
<td align="left">更 Pythonic，易用性强 (<code>.</code>, <code>.find_all()</code>)</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">需要 C 库 <code>libxml2</code>, <code>libxslt</code></td>
<td align="left">纯 Python 实现，无需外部依赖</td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left"><strong>全面</strong> (XPath, XSLT, Schema 验证)</td>
<td align="left">侧重数据提取</td>
</tr>
<tr>
<td align="left"><strong>上手难度</strong></td>
<td align="left">XPath&#x2F;CSS 选择器语法有一定学习成本</td>
<td align="left">API 直观，快速上手</td>
</tr>
<tr>
<td align="left"><strong>典型使用</strong></td>
<td align="left">高性能爬虫、XML 处理、Web API 响应解析</td>
<td align="left">数据清洗、原型开发、非结构化网页解析</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>：<br>很多情况下，可以<strong>结合使用</strong>两者。Beautiful Soup 可以将 lxml 作为其后端解析器，既享受到 lxml 的高性能，又利用 Beautiful Soup 更友好的 API。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree <span class="comment"># 只需要 lxml 安装，BeautifulSoup 自动使用</span></span><br><span class="line"></span><br><span class="line">html_doc = <span class="string">&quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;</span></span><br><span class="line">soup = BeautifulSoup(html_doc, <span class="string">&#x27;lxml&#x27;</span>) <span class="comment"># 指定使用 lxml 解析器</span></span><br><span class="line"><span class="built_in">print</span>(soup.title.string) <span class="comment"># 使用 Beautiful Soup 的 API</span></span><br></pre></td></tr></table></figure>

<h2 id="九、总结与进阶"><a href="#九、总结与进阶" class="headerlink" title="九、总结与进阶"></a>九、总结与进阶</h2><p>lxml 是 Python 数据抓取和 XML&#x2F;HTML 处理领域不可小觑的利器。它的卓越性能和强大的 XPath&#x2F;CSS 选择器支持，使其成为处理大型复杂文档的高效解决方案。</p>
<p><strong>进阶方向：</strong></p>
<ul>
<li><strong>XSLT 转换</strong>：学习如何使用 <code>lxml.etree.XSLT</code> 进行 XML 文档转换。</li>
<li><strong>XML Schema&#x2F;DTD 验证</strong>：利用 lxml 进行 XML 文档的结构验证。</li>
<li><strong>命名空间处理</strong>：在处理包含 XML 命名空间的文档时，正确使用 XPath 表达式。</li>
<li><strong>错误处理</strong>：学习如何处理解析过程中可能出现的各种错误。</li>
<li><strong>与 Web 框架集成</strong>：在 Flask、Django 等 Web 框架中处理 XML&#x2F;HTML 输入输出。</li>
<li><strong>异步抓取与 lxml</strong>：结合 <code>httpx</code> 或 <code>aiohttp</code> 进行异步网页抓取和解析。</li>
</ul>
<p>掌握 lxml，你将能够更高效、更精准地从各种结构化和半结构化文档中提取所需信息，为复杂的数据处理任务奠定坚实基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/3d8fe1e715a5/">https://blog.tbf1211.xx.kg/3d8fe1e715a5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/lxml/">lxml</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/">网络爬虫</a><a class="post-meta__tags" href="/tags/XML/">XML</a><a class="post-meta__tags" href="/tags/XPath/">XPath</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/5febe994b52e/" title="Java 构建工具 Maven 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java 构建工具 Maven 详解</div></div><div class="info-2"><div class="info-item-1"> Apache Maven (Maven) 是一个强大的项目管理和构建自动化工具，主要服务于基于 Java 的项目。它遵循约定优于配置 (Convention over Configuration) 的原则，提供了一个标准化的项目结构和生命周期，用于编译、测试、打包、部署等任务。Maven 的核心目标是让项目构建过程标准化、可预测且易于维护，同时提供强大的依赖管理功能。  核心思想：Maven 将项目视为一系列相互依赖的模块，通过一个声明式的 XML 文件 (pom.xml) 来管理项目的构建、报告和文档。它推崇一套标准的项目布局和生命周期，从而减少开发者在配置上的工作量。   一、为什么需要 Maven？在 Maven 出现之前，Java 项目的构建和管理通常面临诸多挑战：  依赖管理混乱： 项目所需的所有第三方 JAR 包都需要手动下载并添加到项目的 classpath 中。 如果多个项目使用相同库的不同版本，容易引发冲突 (JAR Hell)。 依赖的依赖（传递性依赖）管理起来更加复杂。   构建过程非标准化： 不同的项目可能有不同的构建脚本 (如 Ant)，导致构建步骤不...</div></div></div></a><a class="pagination-related" href="/0549b932640e/" title="DeFi (去中心化金融) 深度解读"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DeFi (去中心化金融) 深度解读</div></div><div class="info-2"><div class="info-item-1"> DeFi (Decentralized Finance)，即去中心化金融，是一个建立在区块链技术之上的开放、透明、无需许可 (Permissionless) 且无需信任 (Trustless) 的金融生态系统。它旨在通过智能合约 (Smart Contracts) 自动化执行金融协议，从而消除传统金融体系中对银行、券商、交易所等中心化中介机构的需求，将金融服务的控制权归还给用户。  核心思想：DeFi 通过区块链和智能合约，将传统金融产品（如借贷、交易、保险）去中心化、自动化和透明化，使得任何拥有互联网连接的人都可以平等地访问和参与，打破了传统金融的壁垒。   一、传统金融 (TradFi) 的痛点与 DeFi 的起源传统金融体系（TradFi）虽然成熟，但也存在诸多局限性：  中心化中介：银行、券商、交易所等扮演关键中介角色，带来高昂费用、效率低下、单点故障风险。 效率低下与高成本：交易结算时间长（如银行转账需要数天），跨境支付费用高昂，运营成本高。 金融排斥：全球仍有大量人口无法获得基础银行服务，被排除在主流金融体系之外。 不透明与审查：金融机构的运作往往不透明，用户数据可...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/06bc4d655ced/" title="Python Beautiful Soup详解：高效网页数据抓取与解析利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-09</div><div class="info-item-2">Python Beautiful Soup详解：高效网页数据抓取与解析利器</div></div><div class="info-2"><div class="info-item-1"> Beautiful Soup 是一个 Python 库，用于从 HTML 或 XML 文件中提取数据。它通过解析文档并提供用于导航、搜索和修改解析树的 Pythonic 接口，将复杂的 HTML&#x2F;XML 文档转化为易于处理的数据结构。Beautiful Soup 与 requests 等 HTTP 库结合使用，是构建网络爬虫进行数据抓取的强大工具。  核心思想：Beautiful Soup 将杂乱的 HTML&#x2F;XML 文档“煲成一锅美味的汤”，让你能够轻松地在其中挑选出你需要的数据元素，如同在厨房里筛选食材一样简单。   一、为什么需要 Beautiful Soup？在网络上，大量有价值的信息以 HTML 页面的形式存在。如果我们需要从这些页面中获取结构化数据（例如，产品信息、新闻标题、评论内容），直接操作原始的 HTML 字符串是非常困难和脆弱的。传统的字符串查找和正则表达式虽然可行，但存在以下问题：  HTML 结构复杂：HTML 标签嵌套层级深，结构不规则，使用正则表达式难以精确匹配。 HTML 容错性：浏览器会自动纠正不规范的 HTML 结构，但正则...</div></div></div></a><a class="pagination-related" href="/1b5035114ad1/" title="Python Requests库详解：HTTP请求的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="info-item-2">Python Requests库详解：HTTP请求的艺术</div></div><div class="info-2"><div class="info-item-1"> requests 库 是 Python 生态系统中最流行、最强大、也是最优雅的 HTTP 客户端库之一。它简化了复杂的 HTTP 请求操作，让开发者能够以极少量的代码发送各种类型的 HTTP 请求，并轻松处理响应。与 Python 内置的 urllib 模块相比，requests 提供了更友好、更直观的 API，被誉为“面向人类的 HTTP 服务”。  核心思想：requests 封装了底层 HTTP 协议的复杂性，提供简洁的 API，让开发者专注于业务逻辑而非网络通信的细节。   一、为什么选择 Requests？在 Python 中进行 HTTP 请求有多种方式，例如内置的 urllib 模块。但 requests 库之所以广受欢迎，主要得益于以下优势：  友好的 API：设计直观，易学易用，代码可读性高。 功能强大：支持几乎所有 HTTP 功能，包括 GET, POST, PUT, DELETE 等方法，以及请求头、数据、文件上传、Cookie、身份认证、代理、SSL 验证等。 自动处理：自动处理 URL 编码、重定向、会话管理等常见任务。 JSON 支持：内置 JSON...</div></div></div></a><a class="pagination-related" href="/40c57ff5cb61/" title="Pug(前Jade)模板引擎详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="info-item-2">Pug(前Jade)模板引擎详解</div></div><div class="info-2"><div class="info-item-1"> Pug（发音 &#x2F;pʌɡ&#x2F;），前身为 Jade，是一个高性能的 Node.js 模板引擎。它以其简洁、富有表现力的语法而闻名，旨在让 HTML 编写变得更加高效和愉快。Pug 摒弃了传统 HTML 的尖括号和闭合标签，转而使用缩进和基于文本的语法，这使得模板文件更小、更易读、也更不易出错。  核心思想：Pug 通过简洁的缩进语法替代冗长的 HTML 标签，提供强大的动态数据渲染、代码重用和条件逻辑功能。   一、Pug 简介1.1 什么是模板引擎？模板引擎是一种将数据填充到预定义模板中以生成最终输出（通常是 HTML 字符串）的工具。它将页面的结构（模板）与数据分离，使得前端开发更加模块化和可维护。 1.2 Pug 的特点 独特语法：使用缩进表示嵌套关系，无需关闭标签。 简洁明了：代码量显著少于对应的 HTML。 强大功能：支持变量、循环、条件判断、Mixin（类似于函数或组件）、包含（文件复用）、布局继承等高级特性。 编译到 HTML：Pug 模板最终会被编译成标准的 HTML。 Node.js 支持：作为 Node.js 的模板引擎，Pug 完美集成于 E...</div></div></div></a><a class="pagination-related" href="/0c202b3d53be/" title="前端文件下载的各种方式的详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-19</div><div class="info-item-2">前端文件下载的各种方式的详解</div></div><div class="info-2"><div class="info-item-1"> 在 Web 开发中，文件下载是一个常见且重要的功能。无论是下载用户生成的数据、报告、图片，还是静态资源，前端开发者都需要掌握多种实现文件下载的方法。本文将详细探讨前端实现文件下载的各种技术，包括 HTML 原生方式、JavaScript 编程方式以及涉及服务器端配合的场景。  核心思想：前端文件下载的核心在于如何将文件数据（无论是服务器传输的还是客户端生成的）转化为可供浏览器识别并触发下载操作的格式（如 Blob 对象或直接的 URL），并通过特定的机制（如 &lt;a&gt; 标签的 download 属性或服务器响应头）来提示浏览器进行下载而非直接显示。   一、文件下载的基础概念在深入具体方法之前，我们先理解文件下载的一些基本概念：  下载 vs. 显示：浏览器在处理文件时，会根据 Content-Type 和 Content-Disposition 等 HTTP 响应头来决定是下载文件（保存到本地）还是在浏览器中直接显示（如图片、PDF）。 文件来源： 服务器端文件：文件存储在服务器上，前端通过 URL 请求获取。 客户端生成文件：文件内容由前端 JavaScript ...</div></div></div></a><a class="pagination-related" href="/c0ed8953ea7d/" title="Python 编码规范详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="info-item-2">Python 编码规范详解</div></div><div class="info-2"><div class="info-item-1"> Python 编码规范 旨在提供一套指导原则和最佳实践，以确保 Python 代码的一致性、可读性、可维护性、可协作性和**“Pythonic”**（符合 Python 语言哲学）风格。Python 社区的核心编码规范是 PEP 8 (Python Enhancement Proposal 8)，它定义了 Python 代码的风格指南。遵循 PEP 8 不仅能让你的代码更容易被其他 Python 开发者理解，也能提高代码本身的质量和减少潜在错误。  核心思想：一致性至关重要。代码是写给人看的，不是机器。清晰、简洁、可读的代码能够极大地提高开发效率和项目成功率。   一、Python 编码哲学与 PEP 8Python 语言的设计哲学（可在 import this 中查看“The Zen of Python”）强调简洁、明确和可读性。PEP 8 是将这些哲学转化为具体编码实践的基石。 PEP 8 是什么？PEP 8 是 Python 官方的风格指南，由 Guido van Rossum (Python 创始人)、Barry Warsaw 和 Nick Coghlan 共同撰写。它...</div></div></div></a><a class="pagination-related" href="/234c44d5851b/" title="HTML5 单页面应用 (SPA) 路由实现详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="info-item-2">HTML5 单页面应用 (SPA) 路由实现详解</div></div><div class="info-2"><div class="info-item-1"> 单页面应用 (Single Page Application, SPA) 是一种 Web 应用程序模型，它通过动态重写当前页面而非从服务器加载整个新页面来实现与用户的交互。这种模式极大地提升了用户体验，使其更接近桌面应用。SPA 的核心技术之一是客户端路由 (Client-Side Routing)，它允许应用程序在不进行整页刷新的情况下，根据 URL 路径的变化渲染不同的视图。  核心思想：HTML5 History API 允许 Web 应用程序在客户端直接操纵浏览器会话历史记录，从而实现 URL 的无刷新更新和状态管理，这是现代 SPA 路由的基础。   一、传统页面跳转与 SPA 路由的区别在深入探讨 SPA 路由之前，我们首先理解传统多页面应用 (Multi-Page Application, MPA) 的页面跳转机制及其与 SPA 的根本不同：  传统 MPA 页面跳转：  用户点击链接或提交表单。 浏览器向服务器发送 HTTP 请求，请求新的 HTML 页面。 服务器响应并发送完整的 HTML 文档。 浏览器销毁当前页面，加载并渲染新的 HTML 文档。   特点...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">527</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-lxml%EF%BC%9F"><span class="toc-text">一、为什么选择 lxml？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85-lxml"><span class="toc-text">二、安装 lxml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A%E8%A7%A3%E6%9E%90-XML-HTML-%E6%96%87%E6%A1%A3"><span class="toc-text">三、基本使用：解析 XML&#x2F;HTML 文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-text">关键点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AF%BC%E8%88%AA%E6%96%87%E6%A1%A3%E6%A0%91"><span class="toc-text">四、导航文档树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%90%9C%E7%B4%A2%E6%96%87%E6%A1%A3%E6%A0%91%EF%BC%9AXPath-%E5%92%8C-CSS-Selector"><span class="toc-text">五、搜索文档树：XPath 和 CSS Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-XPath-XML-Path-Language"><span class="toc-text">5.1 XPath (XML Path Language)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-CSS-Selector"><span class="toc-text">5.2 CSS Selector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BF%AE%E6%94%B9%E6%96%87%E6%A1%A3%E6%A0%91"><span class="toc-text">六、修改文档树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E5%86%85%E5%AD%98%E8%80%83%E8%99%91"><span class="toc-text">七、性能与内存考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81lxml-vs-Beautiful-Soup"><span class="toc-text">八、lxml vs Beautiful Soup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E8%BF%9B%E9%98%B6"><span class="toc-text">九、总结与进阶</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-31.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>