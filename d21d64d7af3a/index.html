<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RDMA (Remote Direct Memory Access) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RDMA (Remote Direct Memory Access) 是一种高性能网络通信技术，允许一台计算机（源端）的网卡（Network Interface Card, NIC）直接访问另一台远程计算机（目的端）的内存，而无需目的端操作系统的 CPU 介入。这种“零拷贝” (Zero-copy) 和“内核旁路” (Kernel-bypass) 的特性极大地减少了数据传输的延迟、提高了吞吐量，">
<meta property="og:type" content="article">
<meta property="og:title" content="RDMA (Remote Direct Memory Access) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/d21d64d7af3a/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="RDMA (Remote Direct Memory Access) 是一种高性能网络通信技术，允许一台计算机（源端）的网卡（Network Interface Card, NIC）直接访问另一台远程计算机（目的端）的内存，而无需目的端操作系统的 CPU 介入。这种“零拷贝” (Zero-copy) 和“内核旁路” (Kernel-bypass) 的特性极大地减少了数据传输的延迟、提高了吞吐量，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg">
<meta property="article:published_time" content="2023-12-24T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-03T10:13:29.691Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RDMA (Remote Direct Memory Access) 详解",
  "url": "https://blog.tbf1211.xx.kg/d21d64d7af3a/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg",
  "datePublished": "2023-12-24T22:24:00.000Z",
  "dateModified": "2026-02-03T10:13:29.691Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/d21d64d7af3a/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RDMA (Remote Direct Memory Access) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">539</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">RDMA (Remote Direct Memory Access) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RDMA (Remote Direct Memory Access) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-12-24T22:24:00.000Z" title="发表于 2023-12-25 06:24:00">2023-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>RDMA (Remote Direct Memory Access)</strong> 是一种高性能网络通信技术，允许一台计算机（源端）的网卡（Network Interface Card, NIC）直接访问另一台远程计算机（目的端）的内存，而无需目的端操作系统的 CPU 介入。这种“零拷贝” (Zero-copy) 和“内核旁路” (Kernel-bypass) 的特性极大地减少了数据传输的延迟、提高了吞吐量，并显著降低了 CPU 占用率，是现代高性能计算 (HPC)、人工智能&#x2F;机器学习 (AI&#x2F;ML)、分布式存储和金融交易等领域中不可或缺的技术。</p>
</blockquote>
<div class="note info flat"><p>核心思想：RDMA 的核心是<strong>绕过操作系统内核的网络协议栈，实现远程内存的直接读写</strong>。它将数据在源端和目的端之间传输的任务从 CPU 卸载到专用的网络硬件（RDMA 网卡，如 HCA），从而实现了<strong>超低延迟、极高吞吐量和极低的 CPU 占用率</strong>。</p>
</div>
<hr>
<h2 id="一、传统网络通信的痛点"><a href="#一、传统网络通信的痛点" class="headerlink" title="一、传统网络通信的痛点"></a>一、传统网络通信的痛点</h2><p>在理解 RDMA 的优势之前，我们先回顾一下传统 TCP&#x2F;IP 网络通信的数据路径，以及它所面临的挑战：</p>
<ol>
<li><p><strong>数据拷贝开销 (Data Copy Overheads)</strong>：</p>
<ul>
<li>当应用程序发送数据时，数据通常从用户态内存拷贝到内核态的 socket 缓冲区。</li>
<li>网卡再从内核态缓冲区拷贝数据到其内部 DMA (Direct Memory Access) 缓冲区，然后发送到网络。</li>
<li>接收数据时，过程反向，数据从网卡 DMA 缓冲区拷贝到内核态 socket 缓冲区，再拷贝到用户态应用缓冲区。</li>
<li>这些内存拷贝操作会消耗大量的 CPU 资源和内存带宽。</li>
</ul>
</li>
<li><p><strong>上下文切换开销 (Context Switching Overheads)</strong>：</p>
<ul>
<li>数据传输涉及到多次用户态和内核态之间的上下文切换（例如，<code>send()</code> &#x2F; <code>recv()</code> 系统调用），这会引入额外的 CPU 周期和延迟。</li>
</ul>
</li>
<li><p><strong>操作系统协议栈开销 (OS Protocol Stack Overheads)</strong>：</p>
<ul>
<li>TCP&#x2F;IP 协议栈作为一个复杂的软件模块运行在操作系统内核中，包括流量控制、拥塞控制、错误重传、分段&#x2F;重组等功能。</li>
<li>这些复杂的逻辑处理需要大量的 CPU 运算，限制了数据传输的性能。</li>
</ul>
</li>
</ol>
<p><strong>传统 TCP&#x2F;IP 数据传输路径示意图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;应用 (用户空间)&quot;] --&gt; B{&quot;系统调用 (e.g., send())&quot;};
    B --&gt; C[&quot;操作系统内核空间 (TCP&#x2F;IP 协议栈)&quot;];
    C --&gt; D[&quot;TCP 缓冲区 (内核空间)&quot;];
    D --&gt; E[&quot;内存拷贝 (Kernel to NIC)&quot;];
    E --&gt; F[&quot;网卡 (NIC)&quot;];
    F --&gt; G[网络];

    G --&gt; F1[&quot;网卡 (NIC)&quot;];
    F1 --&gt; E1[&quot;内存拷贝 (NIC to Kernel)&quot;];
    E1 --&gt; D1[&quot;TCP 缓冲区 (内核空间)&quot;];
    D1 --&gt; C1[&quot;操作系统内核空间 (TCP&#x2F;IP 协议栈)&quot;];
    C1 --&gt; B1{&quot;系统调用 (e.g., recv())&quot;};
    B1 --&gt; A1[&quot;应用 (用户空间)&quot;];
  </pre></div>

<p>这些开销在数据量小、延迟要求不高的场景可能微不足道，但在需要极低延迟和极高吞吐率的场景（如 HPC 或大规模分布式系统）中，将成为严重的性能瓶颈。</p>
<h2 id="二、RDMA-的核心原理"><a href="#二、RDMA-的核心原理" class="headerlink" title="二、RDMA 的核心原理"></a>二、RDMA 的核心原理</h2><p>RDMA 的设计目标是解决传统网络通信中的上述痛点，其核心理念是实现“内核旁路”和“零拷贝”。</p>
<ol>
<li><p><strong>内核旁路 (Kernel Bypass)</strong>：</p>
<ul>
<li>RDMA 允许应用程序直接与网卡通信，绕过操作系统的 TCP&#x2F;IP 协议栈。一旦连接建立，数据传输不再需要 CPU 参与协议处理，所有的数据包处理、确认、重传等都由专用的 RDMA 网卡 (称为 Host Channel Adapter, HCA) 在硬件层面完成。</li>
</ul>
</li>
<li><p><strong>零拷贝 (Zero-Copy)</strong>：</p>
<ul>
<li>应用程序的数据可以直接从其用户态内存缓冲区发送到远程机器的用户态内存缓冲区，而无需经过任何中间的内核态内存拷贝。</li>
<li>这通过<strong>内存注册 (Memory Registration &#x2F; Pinning)</strong> 实现。应用程序需要“注册”其希望用于 RDMA 操作的内存区域。一旦内存被注册，它就会被“锁定”在物理内存中，不会被操作系统交换到磁盘，并且网卡可以直接对其进行 DMA 操作。</li>
</ul>
</li>
</ol>
<p><strong>RDMA 数据传输路径示意图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;应用 (用户空间)&quot;] &lt;--&gt; B{&quot;RDMA API (Verbs)&quot;};
    B &lt;--&gt; C[RDma 网卡 &#x2F; HCA];
    C &lt;--&gt; D[网络];

    D &lt;--&gt; C1[RDMA 网卡 &#x2F; HCA];
    C1 &lt;--&gt; B1{&quot;RDMA API (Verbs)&quot;};
    B1 &lt;--&gt; A1[&quot;应用 (用户空间)&quot;];
  </pre></div>

<p>通过这种机制，RDMA 极大地减少了数据传输的路径和 CPU 的参与，从而实现了相比传统网络数量级降低的延迟和更高的吞吐量。</p>
<h2 id="三、RDMA-的主要优势"><a href="#三、RDMA-的主要优势" class="headerlink" title="三、RDMA 的主要优势"></a>三、RDMA 的主要优势</h2><p>RDMA 的核心原理带来了显著的性能提升：</p>
<ol>
<li><p><strong>极低延迟 (Ultra-Low Latency)</strong>：</p>
<ul>
<li>由于内核旁路和零拷贝，数据传输路径最短，协议处理硬件化。典型延迟可以达到微秒 (μs) 甚至亚微秒级别，远低于传统 TCP&#x2F;IP 的数十到数百微秒。</li>
<li>例如，InfiniBand 通常可以实现 1-2 μs 的延迟。</li>
</ul>
</li>
<li><p><strong>极高吞吐量 (High Throughput)</strong>：</p>
<ul>
<li>RDMA 网卡能够以接近或达到理论线速的速度传输数据。通过卸载 CPU 的任务，它能够充分利用网络带宽，实现每秒数TB的数据传输能力。</li>
</ul>
</li>
<li><p><strong>极低 CPU 占用率 (Low CPU Utilization)</strong>：</p>
<ul>
<li>大部分数据传输和协议处理工作由 HCA 硬件完成，CPU 几乎不需要介入。这使得 CPU 可以将更多计算资源用于执行应用程序逻辑，而不是网络 I&#x2F;O。</li>
</ul>
</li>
<li><p><strong>提高应用效率</strong>：</p>
<ul>
<li>通过减少等待时间、提高数据传输速度和释放 CPU 资源，整体应用性能和可扩展性得到显著提升。</li>
</ul>
</li>
</ol>
<h2 id="四、RDMA-网络技术与协议"><a href="#四、RDMA-网络技术与协议" class="headerlink" title="四、RDMA 网络技术与协议"></a>四、RDMA 网络技术与协议</h2><p>RDMA 并非一种独立的网络协议，而是一种通过特定硬件和软件实现数据传输机制的总称。目前主要有以下几种实现 RDMA 的网络技术：</p>
<ol>
<li><p><strong>InfiniBand (IB)</strong>：</p>
<ul>
<li><strong>历史最悠久，性能最高</strong>的原生 RDMA 技术。</li>
<li>设计之初就是为了高性能计算而生，拥有自己的网络协议栈和专用硬件（HCA 和交换机）。</li>
<li>提供原子操作、拥塞控制等高级功能。</li>
<li><strong>特点</strong>：极低延迟、极高吞吐量、专用硬件、非以太网协议。</li>
</ul>
</li>
<li><p><strong>RDMA over Converged Ethernet (RoCE)</strong>：</p>
<ul>
<li><strong>基于以太网实现 RDMA</strong>。允许在标准以太网基础设施上运行 RDMA，无需 InfiniBand 专用硬件。</li>
<li><strong>RoCEv1</strong>：基于以太网链路层 (Layer 2)，不可路由。</li>
<li><strong>RoCEv2</strong>：基于 IP 和 UDP 协议 (Layer 3)，可路由。这是目前应用最广泛的 RDMA over Ethernet 技术。</li>
<li><strong>特点</strong>：利用现有以太网基础设施、较高性能（略低于原生 IB 但显著优于 TCP）、需要支持 PFC (Priority Flow Control) 的无损以太网。</li>
</ul>
</li>
<li><p><strong>iWARP (Internet Wide Area RDMA Protocol)</strong>：</p>
<ul>
<li><strong>基于 TCP 协议实现 RDMA</strong>。</li>
<li>iWARP 的 HCA 在硬件层面实现了 TCP&#x2F;IP 协议栈，使得 RDMA 操作在 TCP 连接上进行。</li>
<li><strong>特点</strong>：可以在标准 TCP&#x2F;IP 以太网基础设施上工作，无需无损网络。但由于底层依然是 TCP，其延迟和吞吐量通常略高于 RoCE，且对 CPU 占用率的降低不如 RoCE 和 InfiniBand 彻底。</li>
</ul>
</li>
</ol>
<p><strong>常见 RDMA 技术对比：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">InfiniBand (IB)</th>
<th align="left">RoCEv2 (RDMA over Converged Ethernet)</th>
<th align="left">iWARP (Internet Wide Area RDMA Protocol)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层协议</strong></td>
<td align="left">InfiniBand (专用)</td>
<td align="left">UDP&#x2F;IP (以太网)</td>
<td align="left">TCP&#x2F;IP (以太网)</td>
</tr>
<tr>
<td align="left"><strong>网络类型</strong></td>
<td align="left">专用网络</td>
<td align="left">以太网 (通常需无损以太网)</td>
<td align="left">以太网 (标准有损以太网)</td>
</tr>
<tr>
<td align="left"><strong>延迟</strong></td>
<td align="left">极低 (1-2 µs)</td>
<td align="left">低 (几 µs，略高于 IB)</td>
<td align="left">较低 (约 10 µs，高于 RoCE)</td>
</tr>
<tr>
<td align="left"><strong>吞吐量</strong></td>
<td align="left">极高 (原生线速)</td>
<td align="left">高 (接近线速)</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left"><strong>路由性</strong></td>
<td align="left">可路由 (通过 IB 路由器)</td>
<td align="left">可路由 (Layer 3)</td>
<td align="left">可路由</td>
</tr>
<tr>
<td align="left"><strong>硬件需求</strong></td>
<td align="left">专用 HCA 和交换机</td>
<td align="left">具备 RoCEv2 功能的 NIC (HCA) 和支持 PFC 的交换机</td>
<td align="left">具备 iWARP 功能的 NIC (HCA)</td>
</tr>
<tr>
<td align="left"><strong>CPU 卸载</strong></td>
<td align="left">高度卸载 (协议、流控、拥塞控制)</td>
<td align="left">高度卸载 (协议、流控、拥塞控制)</td>
<td align="left">较低的 CPU 卸载 (TCP&#x2F;IP 栈在 NIC)</td>
</tr>
</tbody></table>
<h2 id="五、RDMA-核心组件与概念"><a href="#五、RDMA-核心组件与概念" class="headerlink" title="五、RDMA 核心组件与概念"></a>五、RDMA 核心组件与概念</h2><p>理解 RDMA 需要掌握一些核心的硬件和软件概念：</p>
<ol>
<li><p><strong>主机通道适配器 (Host Channel Adapter, HCA)</strong>：</p>
<ul>
<li>RDMA 的专用网卡。它是实现 RDMA 机制的核心硬件，负责处理 RDMA 消息、进行 DMA 操作、管理连接、执行协议任务，从而将 CPU 从这些工作中解放出来。</li>
</ul>
</li>
<li><p><strong>Verbs API</strong>：</p>
<ul>
<li>RDMA 的标准编程接口。它是一组低层次的函数库，允许应用程序直接管理 HCA 的资源。</li>
<li><code>ibv_*</code> 系列库是 InfiniBand 和 RoCE 的标准 API。</li>
</ul>
</li>
<li><p><strong>保护域 (Protection Domain, PD)</strong>：</p>
<ul>
<li>PD 是 RDMA 资源的容器和管理单元，用于隔离和保护不同的应用程序。所有与特定 RDMA 上下文（例如一个应用程序）相关的 HCA 资源（QP, MR, CQ）都必须绑定到一个 PD。</li>
</ul>
</li>
<li><p><strong>队列对 (Queue Pair, QP)</strong>：</p>
<ul>
<li>QP 是 RDMA 连接的端点，由一个发送队列 (Send Queue, SQ) 和一个接收队列 (Receive Queue, RQ) 组成。</li>
<li>每个 QP 代表一个逻辑连接，应用程序通过向 SQ 提交工作请求 (Work Request, WR) 来发送数据，并从 RQ 接收数据（在双边操作中）。QP 必须连接到远程的 QP 才能进行 RDMA 通信。</li>
</ul>
</li>
<li><p><strong>内存区域 (Memory Region, MR) 与内存键 (Memory Key, MK)</strong>：</p>
<ul>
<li>MR 是应用程序注册给 HCA 的一段内存区域，用于 RDMA 操作。当内存被注册后，HCA 可以直接对其进行 DMA 访问。</li>
<li>注册过程会返回一个<strong>内存键 (Memory Key, MK)</strong>，包括 L_Key (Local Key) 和 R_Key (Remote Key)。<ul>
<li><strong>L_Key</strong>：用于本地 HCA 访问该 MR。</li>
<li><strong>R_Key</strong>：用于远程 HCA 访问该 MR。远程 HCA 需要有效 R_Key 才能对目标 MR 执行 RDMA 操作，这提供了内存访问的权限控制。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>工作请求 (Work Request, WR)</strong>：</p>
<ul>
<li>应用程序向 QP 提交的 RDMA 操作请求，例如发送数据、接收数据、远程写入、远程读取等。</li>
<li>一个 WR 包含了操作类型、本地数据缓冲区信息 (MR、偏移量、长度)、远程目标信息 (远程 QP、R_Key、远程地址) 等。</li>
</ul>
</li>
<li><p><strong>完成队列 (Completion Queue, CQ)</strong>：</p>
<ul>
<li>HCA 用来通知应用程序 RDMA 操作完成的队列。当一个 WR 被 HCA 执行完成时，HCA 会在 CQ 中放入一个<strong>工作完成 (Work Completion, WC)</strong> 事件。应用程序通过轮询或中断的方式从 CQ 获取 WC。</li>
</ul>
</li>
</ol>
<h2 id="六、RDMA-操作类型"><a href="#六、RDMA-操作类型" class="headerlink" title="六、RDMA 操作类型"></a>六、RDMA 操作类型</h2><p>RDMA 操作可以分为两大类：</p>
<ol>
<li><p><strong>单边操作 (One-sided Operations&#x2F;RDMA Read &amp; Write)</strong>：</p>
<ul>
<li>这是 RDMA 最独特的特性，也是其实现“内核旁路”和“零拷贝”的关键。</li>
<li><strong>远程写入 (RDMA Write &#x2F; Put)</strong>：源端应用程序向一个远程内存区域写入数据。远程端不需要执行任何操作（如 <code>recv()</code>），其 CPU 也无需介入。源端 HCA 直接将数据写入目的端 HCA 注册的内存区域。</li>
<li><strong>远程读取 (RDMA Read &#x2F; Get)</strong>：源端应用程序从一个远程内存区域读取数据到本地内存区域。远程端不需要执行任何操作（如 <code>send()</code>），其 CPU 也无需介入。目的端 HCA 直接将数据传输给源端 HCA。</li>
<li><strong>特点</strong>：无需目的端 CPU 参与，仅由源端的应用程序发起，对性能提升最明显。</li>
</ul>
</li>
<li><p><strong>双边操作 (Two-sided Operations &#x2F; Send &amp; Receive)</strong>：</p>
<ul>
<li>类似于传统的 message passing (消息传递)，但依然是内核旁路的。</li>
<li>源端应用程序发起一个 <code>Send</code> 操作，目的端应用程序必须提前发起一个 <code>Receive</code> 操作来接收数据。</li>
<li><strong>特点</strong>：虽然仍需要两边应用程序的协调，但在 HCA 硬件层面处理，避免了 OS 协议栈的开销和内存拷贝，因此比传统 TCP 仍然高效得多。</li>
</ul>
</li>
</ol>
<h2 id="七、RDMA-编程模型-概念性"><a href="#七、RDMA-编程模型-概念性" class="headerlink" title="七、RDMA 编程模型 (概念性)"></a>七、RDMA 编程模型 (概念性)</h2><p>RDMA 编程通常涉及以下步骤（使用 Verbs API）：</p>
<ol>
<li><p><strong>资源初始化</strong>：</p>
<ul>
<li>打开 HCA 设备。</li>
<li>分配保护域 (PD)。</li>
<li>创建并初始化两端的队列对 (QP)。</li>
<li>创建完成队列 (CQ)。</li>
</ul>
</li>
<li><p><strong>内存注册 (Memory Registration)</strong>：</p>
<ul>
<li>应用程序分配用于数据传输的缓冲区。</li>
<li>将这些缓冲区注册到 HCA，获取内存键 (R_Key, L_Key)。注册的目的是将虚拟地址转换为物理地址，并锁定内存，防止操作系统将其交换出物理内存。</li>
</ul>
</li>
<li><p><strong>QP 状态转换与连接建立</strong>：</p>
<ul>
<li>QP 经历一系列状态转换 (如 RESET -&gt; INIT -&gt; RTR (Ready To Receive) -&gt; RTS (Ready To Send))。</li>
<li>在 RTR&#x2F;RTS 阶段，两端的 QP 会交换必要的信息进行连接建立（例如，目的地的 QP 号、L_Key、连接 ID 等）。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li><strong>提交工作请求 (Work Request, WR)</strong>：应用程序创建 WR (例如，RDMA_WRITE, RDMA_READ, SEND)，指定本地缓冲区、远程缓冲区（对于单边操作）、R_Key 等信息，并将其提交到 QP 的发送队列 (SQ)。</li>
<li>HCA 从 SQ 中取出 WR 并执行对应的 RDMA 操作。</li>
</ul>
</li>
<li><p><strong>完成事件处理</strong>：</p>
<ul>
<li>HCA 完成 WR 后，会将一个工作完成 (Work Completion, WC) 放入 CQ。</li>
<li>应用程序通过轮询 CQ 或等待中断的方式，来检查操作是否完成，并获取 WC 的结果。</li>
</ul>
</li>
<li><p><strong>资源清理</strong>：</p>
<ul>
<li>关闭设备，释放所有分配的 PD, QP, MR, CQ 等资源。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 概念性的 Python (pyverbs 库) 编程流程示例</span></span><br><span class="line"><span class="comment"># 实际代码会复杂得多，涉及错误处理、内存管理等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyverbs.providers.mlx5 <span class="keyword">as</span> mlx5_prov</span><br><span class="line"><span class="keyword">import</span> pyverbs.device <span class="keyword">as</span> pv_dev</span><br><span class="line"><span class="keyword">import</span> pyverbs.pd <span class="keyword">as</span> pv_pd</span><br><span class="line"><span class="keyword">import</span> pyverbs.qp <span class="keyword">as</span> pv_qp</span><br><span class="line"><span class="keyword">import</span> pyverbs.mr <span class="keyword">as</span> pv_mr</span><br><span class="line"><span class="keyword">import</span> pyverbs.cq <span class="keyword">as</span> pv_cq</span><br><span class="line"><span class="keyword">import</span> pyverbs.wr <span class="keyword">as</span> pv_wr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设已经初始化好网络设备和远程QP信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rdma_client_example</span>(<span class="params">server_ip_addr, port, rkey, remote_vaddr</span>):</span><br><span class="line">    <span class="comment"># 1. 打开 RDMA 设备</span></span><br><span class="line">    dev = mlx5_prov.get_devices()[<span class="number">0</span>] <span class="comment"># 获取第一个RDMA设备</span></span><br><span class="line">    context = pv_dev.Context(dev)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 分配保护域 (PD)</span></span><br><span class="line">    pd = pv_pd.PD(context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建完成队列 (CQ)</span></span><br><span class="line">    cq = pv_cq.CQ(context, <span class="number">100</span>) <span class="comment"># 100个完成事件的CQ</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 创建队列对 (QP)</span></span><br><span class="line">    <span class="comment"># 假设QP类型为RC (Reliable Connected)</span></span><br><span class="line">    qp = pv_qp.QP(pd, cq, cq, pv_qp.IBV_QPT_RC, <span class="number">16</span>, <span class="number">16</span>) <span class="comment"># SQ/RQ深度为16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 内存注册 (MR)</span></span><br><span class="line">    <span class="comment"># 申请一块本地内存，并注册</span></span><br><span class="line">    local_buffer = <span class="built_in">bytearray</span>(<span class="string">b&#x27;Hello from RDMA Client&#x27;</span>)</span><br><span class="line">    mr = pv_mr.MR(pd, <span class="built_in">len</span>(local_buffer), pv_mr.IBV_ACCESS_LOCAL_WRITE | pv_mr.IBV_ACCESS_REMOTE_WRITE)</span><br><span class="line">    mr.write(local_buffer, <span class="number">0</span>) <span class="comment"># 将数据写入注册的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. QP 状态转换 (INIT -&gt; RTR -&gt; RTS) 和连接</span></span><br><span class="line">    <span class="comment"># 这部分涉及复杂的连接管理和参数交换，通常需要自定义协议或使用librdmacm</span></span><br><span class="line">    <span class="comment"># 简化为直接设置连接参数</span></span><br><span class="line">    qp.to_init()</span><br><span class="line">    qp_init_attr = pv_qp.QPInitAttr()... <span class="comment"># 设置QP初始属性</span></span><br><span class="line">    qp.to_rtr(server_ip_addr, port, remote_qp_num) <span class="comment"># 假设已知远程QP号</span></span><br><span class="line">    qp.to_rts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;QP connected. Ready for RDMA WRITE.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7. 提交 RDMA WRITE 工作请求 (WR)</span></span><br><span class="line">    sge = pv_wr.SGE(mr.lkey, mr.addr, mr.length)</span><br><span class="line">    wr = pv_wr.RDMAWrite(qp, sge, rkey, remote_vaddr) <span class="comment"># rkey, remote_vaddr 来自server</span></span><br><span class="line"></span><br><span class="line">    qp.post_send(wr) <span class="comment"># 提交发送请求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 8. 轮询完成队列 (CQ)</span></span><br><span class="line">    ret_wc = cq.poll_cq_blocking(<span class="number">1</span>) <span class="comment"># 阻塞等待1个完成事件</span></span><br><span class="line">    <span class="keyword">if</span> ret_wc:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;RDMA WRITE completed. Status: <span class="subst">&#123;ret_wc[<span class="number">0</span>].status&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;RDMA WRITE failed or timed out.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 9. 清理资源</span></span><br><span class="line">    qp.destroy()</span><br><span class="line">    mr.dereg()</span><br><span class="line">    cq.destroy()</span><br><span class="line">    pd.destroy()</span><br><span class="line">    context.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程服务器端会进行类似的初始化，注册自己的内存区域并分享 R_Key 和虚拟地址</span></span><br></pre></td></tr></table></figure>

<h2 id="八、典型应用场景"><a href="#八、典型应用场景" class="headerlink" title="八、典型应用场景"></a>八、典型应用场景</h2><p>RDMA 技术因其卓越的性能，已成为多个关键领域的核心：</p>
<ol>
<li><p><strong>高性能计算 (HPC)</strong>：</p>
<ul>
<li>在超级计算机集群中，作为节点间互联的主要技术，加速 MPI (Message Passing Interface) 消息传递，实现大规模并行计算的高效数据交换。</li>
</ul>
</li>
<li><p><strong>人工智能与机器学习 (AI&#x2F;ML)</strong>：</p>
<ul>
<li>分布式深度学习训练中，大量模型参数和梯度需要在 GPU 之间高效同步。RDMA 结合 <strong>NVIDIA GPUDirect RDMA</strong> 允许 GPU 直接读写远程 GPU 内存，极大地加速了训练过程。</li>
</ul>
</li>
<li><p><strong>分布式存储 (Distributed Storage)</strong>：</p>
<ul>
<li><strong>NVMe over Fabrics (NVMe-oF)</strong>：允许应用程序通过 RDMA 直接访问远程的 NVMe 固态硬盘，而无需经过远程服务器的 CPU，将存储延迟和带宽利用率推向极致。</li>
<li>Ceph、GlusterFS 等分布式存储系统也在积极采纳 RDMA 以提高性能。</li>
</ul>
</li>
<li><p><strong>内存数据库和数据分析 (In-Memory Databases &#x2F; Data Analytics)</strong>：</p>
<ul>
<li>如 Apache Spark、SAP HANA 等分布式内存数据库和分析引擎，利用 RDMA 快速传输内存中的数据，加速查询和数据处理。</li>
</ul>
</li>
<li><p><strong>金融交易 (Financial Trading)</strong>：</p>
<ul>
<li>股票交易系统、高频交易 (HFT) 对延迟有极致要求，RDMA 被用于实现毫秒级的市场数据分发和交易指令执行。</li>
</ul>
</li>
</ol>
<h2 id="九、挑战与考量"><a href="#九、挑战与考量" class="headerlink" title="九、挑战与考量"></a>九、挑战与考量</h2><p>尽管 RDMA 优势显著，但在部署和使用时也面临一些挑战：</p>
<ol>
<li><p><strong>编程复杂度</strong>：</p>
<ul>
<li>RDMA Verbs API 是低层次的，编程复杂，容易出错。通常需要使用更高层次的库或框架（如 MPI、gRPC with RDMA Transport）来简化开发。</li>
</ul>
</li>
<li><p><strong>硬件成本与兼容性</strong>：</p>
<ul>
<li>需要专用的 RDMA 网卡 (HCA) 和可能需要支持无损以太网的交换机（对于 RoCE）。这增加了硬件成本和网络基础设施的复杂性。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>直接内存访问意味着更高的权限和风险。如果 R_Key 管理不当，可能导致未经授权的远程内存访问。</li>
</ul>
</li>
<li><p><strong>部署与运维</strong>：</p>
<ul>
<li>RDMA 网络的部署、配置和故障排除比传统以太网更复杂，需要专用的知识和工具。</li>
</ul>
</li>
</ol>
<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>RDMA (Remote Direct Memory Access) 是一种革命性的网络通信技术，通过其“内核旁路”和“零拷贝”的核心机制，极大地变革了数据中心和高性能计算的通信范式。它带来的超低延迟、极高吞吐量和极低 CPU 占用率，使其成为 HPC、AI&#x2F;ML、分布式存储和金融交易等对性能有极致要求的应用领域的基石。尽管面临编程复杂度、硬件成本和安全性等挑战，但随着软件抽象层的发展和硬件成本的下降，RDMA 有望在更广泛的范围内得到应用，并持续推动分布式系统和数据处理技术的进步。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/d21d64d7af3a/">https://blog.tbf1211.xx.kg/d21d64d7af3a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ba096d7d0780/" title="虚拟局域网 (VLAN) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">虚拟局域网 (VLAN) 详解</div></div><div class="info-2"><div class="info-item-1"> 虚拟局域网 (VLAN - Virtual Local Area Network) 是一种在物理上共享同一网络基础设施（如交换机、网线）的局域网中，通过逻辑划分而不是物理划分来创建多个独立广播域的技术。它允许网络管理员将一个物理局域网划分成多个逻辑上独立的网络，每个 VLAN 都是一个独立的广播域。VLAN 技术是现代企业网络设计中不可或缺的组成部分，它极大地增强了网络的安全性、性能、灵活性和可管理性。  核心思想：在不改变物理连接的情况下，将一个物理交换机划分出多个逻辑隔离的广播域，实现设备间的逻辑分段通信。   一、什么是 VLAN？在传统的以太网中，所有连接到同一个交换机或集线器的设备都属于同一个广播域 (Broadcast Domain)。这意味着当任何一台设备发送一个广播帧（例如 ARP 请求），这个广播帧会到达该域内的所有其他设备。随着网络规模的扩大，广播流量会显著增加，导致网络性能下降并带来安全隐患。 VLAN 技术应运而生，它通过在数据链路层（OSI 模型第二层）对以太网帧进行标识和处理，从而实现：  逻辑隔离：即使设备物理上连接在同一台交换机上，如果它们属于不...</div></div></div></a><a class="pagination-related" href="/d883c2e5bd14/" title="端到端测试 (E2E Testing) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">端到端测试 (E2E Testing) 深度解析</div></div><div class="info-2"><div class="info-item-1"> 端到端测试 (End-to-End Testing, E2E Testing) 是一种软件测试方法，旨在模拟真实用户在应用程序中的完整交互路径。它涵盖了从用户界面 (UI) 到后端服务、数据库乃至任何外部依赖的整个应用堆栈。E2E 测试的目标是验证应用程序的所有组件和子系统作为一个整体是否协同工作，并满足业务需求，确保关键的用户流程能够顺畅地完成。  核心思想：从用户的视角出发，检验应用程序的每一个环节，确保整个系统在真实使用场景下能够稳定、正确地运行。   一、为什么需要端到端测试？在现代复杂的分布式系统中，一个应用程序通常包含前端界面、多个后端服务、数据库、缓存、消息队列以及第三方集成等众多组件。尽管单元测试和集成测试能够有效验证单个模块和它们之间的局部交互，但它们无法全面覆盖以下场景：  完整用户流程验证：用户从登录、操作数据到登出的整个业务流程是否顺畅。 系统集成问题：不同服务、数据库、缓存和外部API之间的实际交互是否正确。 UI 与后端的一致性：前端页面渲染的数据是否与后端返回的数据一致，以及前端操作能否正确触发后端逻辑。 环境配置问题：部署到准生产或生产环境后，各...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/abf64f03363d/" title="HTTP Upgrade 请求详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="info-item-2">HTTP Upgrade 请求详解</div></div><div class="info-2"><div class="info-item-1"> HTTP Upgrade 请求 是一种特殊的 HTTP&#x2F;1.1 机制，允许客户端和服务器在已经建立的 TCP 连接上，将当前协议从 HTTP&#x2F;1.1 切换到另一个不同的、更高级别的协议。最常见的应用场景是将 HTTP 连接升级到 WebSocket 协议，从而实现全双工、低延迟的持久连接。  核心思想：Upgrade 请求是 HTTP&#x2F;1.1 中用于协议协商的机制，允许在一个已有的 TCP 连接上，在客户端和服务器都同意的情况下，从 HTTP 切换到其他协议，避免了重新建立连接的开销，并开启更强大的通信模式。   一、为什么需要 HTTP Upgrade？HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 都是无状态的请求-响应协议。对于每个请求，客户端发送请求，服务器发送响应，然后连接可以关闭（非持久连接）或保持一段时间用于后续的 HTTP 请求（持久连接，Keep-Alive）。 这种请求-响应模式对于传统的 Web 页面浏览非常高效。然而，随着 Web 应用复杂度的增加，许多场景需要更高级的通信模式：  实时通信：聊天应用、在线游戏、...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/2dc209b3606e/" title="OSI 七层模型详解 (The OSI 7-Layer Model Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-12</div><div class="info-item-2">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</div></div><div class="info-2"><div class="info-item-1"> OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。  核心思想：将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。   一、为什么需要 OSI 模型？在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个统一的标准来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：  标准化：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。 模块化：将复杂的网络通...</div></div></div></a><a class="pagination-related" href="/a148e5499a60/" title="IPSec (Internet Protocol Security) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-13</div><div class="info-item-2">IPSec (Internet Protocol Security) 详解</div></div><div class="info-2"><div class="info-item-1"> IPSec (Internet Protocol Security) 是一套在 IP 层 (网络层) 提供安全服务的协议族。它不依赖于任何特定的应用程序，而是通过加密和认证 IP 数据包在网络中安全传输。IPSec 广泛应用于构建 VPN (Virtual Private Network - 虚拟专用网络)，为远程用户、分支机构和云资源提供安全的、端到端的通信。它提供了数据完整性、数据源认证、防重放保护以及数据机密性等关键安全服务。  核心思想：IPSec 通过在网络层透明地加密和认证 IP 数据包，为 IP 通信提供端到端的安全保障，是构建安全 VPN 和保护 IP 流量的核心技术。   一、IPSec 概述1.1 什么是 IPSec？IPSec 是由 IETF (Internet Engineering Task Force) 定义的一整套开放标准的协议族，它工作在 OSI 模型的网络层 (Layer 3)。其核心目标是为 IP 通信提供高级安全功能，而无需修改应用程序。 1.2 为什么需要 IPSec？传统的 IP 协议本身无法提供数据的机密性、完整性或认证。数据在公共网...</div></div></div></a><a class="pagination-related" href="/59d0e10ae2fa/" title="HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-05</div><div class="info-item-2">HTTPS (HTTP Secure) 深度详解：确保Web通信的安全与隐私</div></div><div class="info-2"><div class="info-item-1"> HTTPS (Hypertext Transfer Protocol Secure)，即超文本传输安全协议，是在 HTTP 协议的基础上，通过添加 SSL&#x2F;TLS (Secure Sockets Layer&#x2F;Transport Layer Security) 协议层来提供安全性的网络协议。它确保了客户端（通常是浏览器）和服务器之间的数据传输加密、完整且经过认证，从而保护用户的隐私和数据的安全。  核心思想：在不安全的互联网上，为 HTTP 通信提供加密、身份认证和数据完整性保护，使得网站能够安全可靠地传输信息。   一、为什么需要 HTTPS？传统的 HTTP 协议是一种明文传输协议，其数据的传输是透明的，没有任何加密。这导致了多重重要的安全隐患：  数据窃听 (Eavesdropping &#x2F; Sniffing)：  任何网络中间节点（如 Wi-Fi 热点、路由器、ISP）都可以截获并读取用户与网站之间传输的所有数据，包括敏感信息如用户名、密码、银行卡号、邮件内容等。 例如，您在一个非 HTTPS 网站登录，您的用户名和密码在网络中就是明文传输，攻...</div></div></div></a><a class="pagination-related" href="/425bf08190fa/" title="TLS Encrypted Client Hello (ECH) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="info-item-2">TLS Encrypted Client Hello (ECH) 详解</div></div><div class="info-2"><div class="info-item-1"> TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。  核心思想：在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。   一、为什么需要 ECH？SNI 的隐私痛点在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：明文 SNI (Server Name Indication)。 1.1 SNI 的作用SNI 是 TLS 协议的一个扩展，用于解决虚拟主机 (Virtual Hosting) 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 example.com 和 another.c...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">539</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E7%97%9B%E7%82%B9"><span class="toc-text">一、传统网络通信的痛点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81RDMA-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">二、RDMA 的核心原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81RDMA-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF"><span class="toc-text">三、RDMA 的主要优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81RDMA-%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="toc-text">四、RDMA 网络技术与协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81RDMA-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text">五、RDMA 核心组件与概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81RDMA-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-text">六、RDMA 操作类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81RDMA-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E6%A6%82%E5%BF%B5%E6%80%A7"><span class="toc-text">七、RDMA 编程模型 (概念性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">八、典型应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%8C%91%E6%88%98%E4%B8%8E%E8%80%83%E9%87%8F"><span class="toc-text">九、挑战与考量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">十、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-21.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>