<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git命令详解与实践 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Git 作为一个分布式版本控制系统，是现代软件开发中不可或缺的工具。它允许开发者追踪代码变更、协调团队协作，并管理项目版本。本文旨在对 Git 的核心命令进行详尽解析，涵盖从初始化仓库到高级操作的各个方面，帮助开发者更深入地理解和高效地利用 Git。  核心思想：理解 Git 的工作区、暂存区和仓库之间的关系，以及每个命令如何操作这些区域，是掌握 Git 的关键。   一、Git 核心概念回顾在">
<meta property="og:type" content="article">
<meta property="og:title" content="Git命令详解与实践">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/be852baa9322/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Git 作为一个分布式版本控制系统，是现代软件开发中不可或缺的工具。它允许开发者追踪代码变更、协调团队协作，并管理项目版本。本文旨在对 Git 的核心命令进行详尽解析，涵盖从初始化仓库到高级操作的各个方面，帮助开发者更深入地理解和高效地利用 Git。  核心思想：理解 Git 的工作区、暂存区和仓库之间的关系，以及每个命令如何操作这些区域，是掌握 Git 的关键。   一、Git 核心概念回顾在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg">
<meta property="article:published_time" content="2023-11-01T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-29T10:03:28.087Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git命令详解与实践",
  "url": "https://blog.tbf1211.xx.kg/be852baa9322/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg",
  "datePublished": "2023-11-01T22:24:00.000Z",
  "dateModified": "2026-01-29T10:03:28.087Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/be852baa9322/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git命令详解与实践',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">533</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Git命令详解与实践</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git命令详解与实践</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-01T22:24:00.000Z" title="发表于 2023-11-02 06:24:00">2023-11-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>Git 作为一个分布式版本控制系统，是现代软件开发中不可或缺的工具。它允许开发者追踪代码变更、协调团队协作，并管理项目版本。本文旨在对 Git 的核心命令进行详尽解析，涵盖从初始化仓库到高级操作的各个方面，帮助开发者更深入地理解和高效地利用 Git。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>理解 Git 的工作区、暂存区和仓库之间的关系，以及每个命令如何操作这些区域，是掌握 Git 的关键。</strong></p>
</div>
<hr>
<h2 id="一、Git-核心概念回顾"><a href="#一、Git-核心概念回顾" class="headerlink" title="一、Git 核心概念回顾"></a>一、Git 核心概念回顾</h2><p>在深入 Git 命令之前，理解几个核心概念对于后续的学习至关重要。</p>
<h3 id="1-1-工作区-Working-Directory"><a href="#1-1-工作区-Working-Directory" class="headerlink" title="1.1 工作区 (Working Directory)"></a>1.1 工作区 (Working Directory)</h3><p>你正在编辑和修改的文件所在的目录，也是你肉眼可见的目录。</p>
<h3 id="1-2-暂存区-Staging-Area-Index"><a href="#1-2-暂存区-Staging-Area-Index" class="headerlink" title="1.2 暂存区 (Staging Area &#x2F; Index)"></a>1.2 暂存区 (Staging Area &#x2F; Index)</h3><p>一个轻量级的中间区域，用于存放你准备提交的文件快照。当执行 <code>git add</code> 命令时，文件就从工作区被添加到暂存区。</p>
<h3 id="1-3-本地仓库-Local-Repository"><a href="#1-3-本地仓库-Local-Repository" class="headerlink" title="1.3 本地仓库 (Local Repository)"></a>1.3 本地仓库 (Local Repository)</h3><p>存放项目的所有版本历史记录（即一系列提交）。当你执行 <code>git commit</code> 命令时，暂存区的文件快照就会被永久保存到本地仓库。</p>
<h3 id="1-4-远程仓库-Remote-Repository"><a href="#1-4-远程仓库-Remote-Repository" class="headerlink" title="1.4 远程仓库 (Remote Repository)"></a>1.4 远程仓库 (Remote Repository)</h3><p>通常位于网络上的另一个服务器，用于团队协作和备份。本地仓库可以与远程仓库进行同步（<code>git push</code>, <code>git pull</code>, <code>git fetch</code>）。</p>
<h3 id="1-5-HEAD"><a href="#1-5-HEAD" class="headerlink" title="1.5 HEAD"></a>1.5 HEAD</h3><p>一个特殊的指针，总是指向你当前所在分支的最新提交。当你切换分支或提交新代码时，<code>HEAD</code> 会随之移动。</p>
<h3 id="1-6-Commit-提交"><a href="#1-6-Commit-提交" class="headerlink" title="1.6 Commit (提交)"></a>1.6 Commit (提交)</h3><p>Git 中最基本的单位，代表了项目历史中的一个快照。每次提交都包含作者信息、提交时间、提交信息以及指向父提交的指针（除了第一个提交）。</p>
<h3 id="1-7-Branch-分支"><a href="#1-7-Branch-分支" class="headerlink" title="1.7 Branch (分支)"></a>1.7 Branch (分支)</h3><p>一个指向提交的指针。分支允许开发者在不影响主线开发的情况下，独立进行新功能开发或 Bug 修复。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    A[工作区] -- git add --&gt; B[&quot;暂存区 (Index)&quot;]
    B -- git commit --&gt; C[本地仓库]
    C -- git push --&gt; D[远程仓库]
    D -- git pull&#x2F;fetch --&gt; C
  </pre></div>

<h2 id="二、Git-命令详解"><a href="#二、Git-命令详解" class="headerlink" title="二、Git 命令详解"></a>二、Git 命令详解</h2><p>本节将分类详细介绍 Git 的常用命令。</p>
<h3 id="2-1-配置类命令"><a href="#2-1-配置类命令" class="headerlink" title="2.1 配置类命令"></a>2.1 配置类命令</h3><p>首次使用 Git 或更换开发环境时，需要配置用户信息。</p>
<h4 id="2-1-1-git-config"><a href="#2-1-1-git-config" class="headerlink" title="2.1.1 git config"></a>2.1.1 <code>git config</code></h4><p><strong>作用</strong>：设置 Git 的配置变量，例如用户身份、编辑器、别名等。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git config --global user.name &quot;Your Name&quot;</code>：设置全局用户名。</li>
<li><code>git config --global user.email &quot;your_email@example.com&quot;</code>：设置全局用户邮箱。</li>
<li><code>git config --list</code>：查看所有配置信息。</li>
<li><code>git config user.name</code>：查看当前仓库的用户名。</li>
<li><code>git config --global -e</code>：使用编辑器打开全局配置文件进行编辑。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;张三&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;zhangsan@example.com&quot;</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># user.name=张三</span></span><br><span class="line"><span class="comment"># user.email=zhangsan@example.com</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>--global</code> 选项表示配置对当前用户的所有 Git 仓库生效。如果没有 <code>--global</code>，则配置仅对当前仓库生效。</p>
<h3 id="2-2-仓库初始化与克隆"><a href="#2-2-仓库初始化与克隆" class="headerlink" title="2.2 仓库初始化与克隆"></a>2.2 仓库初始化与克隆</h3><h4 id="2-2-1-git-init"><a href="#2-2-1-git-init" class="headerlink" title="2.2.1 git init"></a>2.2.1 <code>git init</code></h4><p><strong>作用</strong>：在当前目录初始化一个新的 Git 仓库。这会在当前目录创建一个 <code>.git</code> 隐藏文件夹，包含了所有 Git 仓库的元数据。</p>
<p><strong>语法</strong>：<code>git init</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my_project</span><br><span class="line"><span class="built_in">cd</span> my_project</span><br><span class="line">git init</span><br><span class="line"><span class="comment"># output: Initialized empty Git repository in /path/to/my_project/.git/</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：通常用于将一个现有项目转换为 Git 仓库。</p>
<h4 id="2-2-2-git-clone"><a href="#2-2-2-git-clone" class="headerlink" title="2.2.2 git clone"></a>2.2.2 <code>git clone</code></h4><p><strong>作用</strong>：克隆一个远程 Git 仓库到本地。它会下载远程仓库的所有版本历史，并自动设置好远程仓库的跟踪关系。</p>
<p><strong>语法</strong>：<code>git clone &lt;repository_url&gt; [directory_name]</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/octocat/Spoon-Knife.git</span><br><span class="line"><span class="comment"># output: Cloning into &#x27;Spoon-Knife&#x27;... (下载过程)</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>[directory_name]</code> 是可选的，如果省略，则会在当前目录创建一个与仓库同名的文件夹。</p>
<h3 id="2-3-基本操作"><a href="#2-3-基本操作" class="headerlink" title="2.3 基本操作"></a>2.3 基本操作</h3><h4 id="2-3-1-git-status"><a href="#2-3-1-git-status" class="headerlink" title="2.3.1 git status"></a>2.3.1 <code>git status</code></h4><p><strong>作用</strong>：显示工作区和暂存区的当前状态，包括哪些文件被修改、哪些被暂存、哪些是未跟踪文件等。</p>
<p><strong>语法</strong>：<code>git status</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改了文件 index.html，新增了文件 new.txt</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># On branch main</span></span><br><span class="line"><span class="comment"># Your branch is up to date with &#x27;origin/main&#x27;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#         modified:   index.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span></span><br><span class="line"><span class="comment">#         new.txt</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：这是一个非常常用的命令，帮助你了解当前代码库的状况。</p>
<h4 id="2-3-2-git-add"><a href="#2-3-2-git-add" class="headerlink" title="2.3.2 git add"></a>2.3.2 <code>git add</code></h4><p><strong>作用</strong>：将工作区的修改或新增文件添加到暂存区，准备进行提交。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git add &lt;file1&gt; &lt;file2&gt; ...</code>：添加指定文件。</li>
<li><code>git add .</code>：添加当前目录及子目录下所有新建、修改的文件（不包括删除的文件）。</li>
<li><code>git add -u</code>：添加所有已跟踪的修改和删除的文件（不包括新增文件）。</li>
<li><code>git add -A</code>：添加所有更改（包括新增、修改、删除）。等同于 <code>git add .</code> 或 <code>git add --all</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改了 index.html</span></span><br><span class="line">git add index.html <span class="comment"># 将 index.html 的修改添加到暂存区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增了 style.css</span></span><br><span class="line">git add . <span class="comment"># 将所有修改和新增文件添加到暂存区</span></span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># On branch main</span></span><br><span class="line"><span class="comment"># Your branch is up to date with &#x27;origin/main&#x27;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span></span><br><span class="line"><span class="comment">#         modified:   index.html</span></span><br><span class="line"><span class="comment">#         new file:   style.css</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git add</code> 是一个增量操作，每次添加都会将文件的当前状态存入暂存区。</p>
<h4 id="2-3-3-git-commit"><a href="#2-3-3-git-commit" class="headerlink" title="2.3.3 git commit"></a>2.3.3 <code>git commit</code></h4><p><strong>作用</strong>：将暂存区中的所有更改作为一个新的提交保存到本地仓库。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git commit -m &quot;Commit message&quot;</code>：使用 <code>-m</code> 选项直接提供提交信息。</li>
<li><code>git commit</code>：打开默认编辑器（如 Vim）编写提交信息。</li>
<li><code>git commit -am &quot;Commit message&quot;</code>：跳过暂存区，直接将所有已跟踪的修改（不包括新增文件）提交。相当于 <code>git add -u</code> 后再 <code>git commit -m</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;feat: Add user login feature&quot;</span></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># [main b2f1c8a] feat: Add user login feature</span></span><br><span class="line"><span class="comment">#  2 files changed, 25 insertions(+), 3 deletions(-)</span></span><br><span class="line"><span class="comment">#  create mode 100644 src/login.py</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：一个好的提交信息对于项目历史的可读性和维护性至关重要。建议遵循 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a> 规范。</p>
<h4 id="2-3-4-git-log"><a href="#2-3-4-git-log" class="headerlink" title="2.3.4 git log"></a>2.3.4 <code>git log</code></h4><p><strong>作用</strong>：显示提交历史记录。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git log</code>：显示所有提交，按时间倒序排列。</li>
<li><code>git log --oneline</code>：以简洁的单行格式显示提交。</li>
<li><code>git log --graph --oneline --all</code>：以图形方式显示所有分支的提交历史。</li>
<li><code>git log -p</code>：显示每个提交的具体更改内容 (diff)。</li>
<li><code>git log --author=&quot;Your Name&quot;</code>：按作者过滤提交。</li>
<li><code>git log --since=&quot;2 weeks ago&quot;</code>：过滤最近两周的提交。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --graph --all</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># * 8e2a3c1 (HEAD -&gt; main, origin/main) feat: add contact form</span></span><br><span class="line"><span class="comment"># * 6b7c8d9 fix: correct typo in homepage</span></span><br><span class="line"><span class="comment"># * 1a2b3c4 Initial commit</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git log</code> 是理解项目演变和追溯问题的重要工具。</p>
<h4 id="2-3-5-git-diff"><a href="#2-3-5-git-diff" class="headerlink" title="2.3.5 git diff"></a>2.3.5 <code>git diff</code></h4><p><strong>作用</strong>：比较文件之间的差异。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git diff</code>：比较工作区和暂存区之间的差异。</li>
<li><code>git diff --staged</code> 或 <code>git diff --cached</code>：比较暂存区和上次提交之间的差异。</li>
<li><code>git diff HEAD</code>：比较工作区和上次提交之间的差异。</li>
<li><code>git diff &lt;commit1&gt; &lt;commit2&gt;</code>：比较两个提交之间的差异。</li>
<li><code>git diff &lt;branch1&gt; &lt;branch2&gt;</code>：比较两个分支的最新提交之间的差异。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 working_file.txt 中做了修改，但未 git add</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment"># output: (显示 working_file.txt 的修改内容)</span></span><br><span class="line"></span><br><span class="line">git add working_file.txt</span><br><span class="line">git diff --staged</span><br><span class="line"><span class="comment"># output: (显示 working_file.txt 在暂存区和上次提交的差异)</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git diff</code> 可以帮助你在提交前审查自己的更改，或在审查他人代码时理解改动。</p>
<h3 id="2-4-分支管理"><a href="#2-4-分支管理" class="headerlink" title="2.4 分支管理"></a>2.4 分支管理</h3><h4 id="2-4-1-git-branch"><a href="#2-4-1-git-branch" class="headerlink" title="2.4.1 git branch"></a>2.4.1 <code>git branch</code></h4><p><strong>作用</strong>：列出、创建、删除分支。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git branch</code>：列出所有本地分支。</li>
<li><code>git branch -a</code>：列出所有本地和远程分支。</li>
<li><code>git branch &lt;branch_name&gt;</code>：创建新分支，但不切换过去。</li>
<li><code>git branch -d &lt;branch_name&gt;</code>：删除本地分支。</li>
<li><code>git branch -D &lt;branch_name&gt;</code>：强制删除本地分支（即使有未合并的提交）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="comment"># 列出本地分支</span></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># * main</span></span><br><span class="line"><span class="comment">#   feature/login</span></span><br><span class="line"></span><br><span class="line">git branch new-feature <span class="comment"># 创建新分支 new-feature</span></span><br><span class="line">git branch -d feature/login <span class="comment"># 删除 feature/login 分支</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-git-checkout-旧版"><a href="#2-4-2-git-checkout-旧版" class="headerlink" title="2.4.2 git checkout (旧版)"></a>2.4.2 <code>git checkout</code> (旧版)</h4><p><strong>作用</strong>：切换分支或恢复文件。在 Git 2.23 之后，其文件恢复和分支切换功能被 <code>git restore</code> 和 <code>git switch</code> 分离。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git checkout &lt;branch_name&gt;</code>：切换到指定分支。</li>
<li><code>git checkout -b &lt;new_branch_name&gt;</code>：创建并切换到新分支。</li>
<li><code>git checkout &lt;file_path&gt;</code>：丢弃工作区中文件的所有修改，恢复到最近一次提交的状态。</li>
<li><code>git checkout &lt;commit_hash&gt; &lt;file_path&gt;</code>：将文件恢复到指定提交时的状态。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature/dashboard <span class="comment"># 切换到 dashboard 分支</span></span><br><span class="line">git checkout -b feature/analytics <span class="comment"># 创建并切换到 analytics 分支</span></span><br><span class="line">git checkout index.html <span class="comment"># 丢弃 index.html 的所有本地修改</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-git-switch-新版，Git-2-23"><a href="#2-4-3-git-switch-新版，Git-2-23" class="headerlink" title="2.4.3 git switch (新版，Git 2.23+)"></a>2.4.3 <code>git switch</code> (新版，Git 2.23+)</h4><p><strong>作用</strong>：专门用于切换分支。旨在替代 <code>git checkout</code> 的分支切换功能。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git switch &lt;branch_name&gt;</code>：切换到指定分支。</li>
<li><code>git switch -c &lt;new_branch_name&gt;</code>：创建并切换到新分支。</li>
<li><code>git switch -C &lt;new_branch_name&gt;</code>：强制创建并切换到新分支（会覆盖同名分支）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch develop <span class="comment"># 切换到 develop 分支</span></span><br><span class="line">git switch -c feature/new-design <span class="comment"># 创建并切换到新分支</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：推荐使用 <code>git switch</code> 进行分支切换，因为它更清晰地表达了意图。</p>
<h4 id="2-4-4-git-restore-新版，Git-2-23"><a href="#2-4-4-git-restore-新版，Git-2-23" class="headerlink" title="2.4.4 git restore (新版，Git 2.23+)"></a>2.4.4 <code>git restore</code> (新版，Git 2.23+)</h4><p><strong>作用</strong>：专门用于恢复文件。旨在替代 <code>git checkout</code> 的文件恢复功能。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git restore &lt;file_path&gt;</code>：丢弃工作区中文件的所有修改，恢复到暂存区或上次提交的状态。</li>
<li><code>git restore --staged &lt;file_path&gt;</code>：将文件从暂存区撤回到工作区（但不会丢弃工作区中的修改）。</li>
<li><code>git restore --source=&lt;commit_hash&gt; &lt;file_path&gt;</code>：将文件恢复到指定提交时的状态。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改了 main.py，已 git add</span></span><br><span class="line">git restore --staged main.py <span class="comment"># 将 main.py 从暂存区撤回</span></span><br><span class="line">git restore main.py <span class="comment"># 丢弃 main.py 在工作区的修改</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：推荐使用 <code>git restore</code> 进行文件恢复，因为它更清晰地表达了意图。</p>
<h4 id="2-4-5-git-merge"><a href="#2-4-5-git-merge" class="headerlink" title="2.4.5 git merge"></a>2.4.5 <code>git merge</code></h4><p><strong>作用</strong>：将一个分支的更改合并到当前分支。</p>
<p><strong>语法</strong>：<code>git merge &lt;source_branch&gt;</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge feature/new-feature <span class="comment"># 将 feature/new-feature 分支合并到 develop</span></span><br><span class="line"><span class="comment"># output: (合并信息，可能需要解决冲突)</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git merge</code> 会创建一个新的合并提交（三方合并），保留了完整的历史记录。如果不需要新的合并提交（例如目标分支是源分支的直接祖先），Git 会执行快进合并 (fast-forward merge)。<br><strong>详细对比请参阅 <code>Git Merge vs. Rebase 对比详解</code> 文档。</strong></p>
<h4 id="2-4-6-git-rebase"><a href="#2-4-6-git-rebase" class="headerlink" title="2.4.6 git rebase"></a>2.4.6 <code>git rebase</code></h4><p><strong>作用</strong>：将一系列提交从一个分支移动或复制到另一个分支的顶部，从而创建线性的历史记录。它会改写提交历史。</p>
<p><strong>语法</strong>：<code>git rebase &lt;base_branch&gt;</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature/new-feature</span><br><span class="line">git rebase develop <span class="comment"># 将 feature/new-feature 分支的提交应用到 develop 分支的最新提交之上</span></span><br><span class="line"><span class="comment"># output: (变基过程，可能需要解决冲突)</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git rebase</code> 可以使提交历史更整洁，但会改写历史，<strong>切勿在已推送到公共仓库的分支上使用</strong>。<br><strong>详细对比请参阅 <code>Git Merge vs. Rebase 对比详解</code> 文档。</strong></p>
<h3 id="2-5-远程仓库操作"><a href="#2-5-远程仓库操作" class="headerlink" title="2.5 远程仓库操作"></a>2.5 远程仓库操作</h3><h4 id="2-5-1-git-remote"><a href="#2-5-1-git-remote" class="headerlink" title="2.5.1 git remote"></a>2.5.1 <code>git remote</code></h4><p><strong>作用</strong>：管理远程仓库。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git remote -v</code>：列出所有远程仓库及其 URL。</li>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code>：添加一个新的远程仓库。</li>
<li><code>git remote remove &lt;name&gt;</code>：移除指定远程仓库。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/another/repo.git</span><br><span class="line">git remote -v</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># origin  https://github.com/my/repo.git (fetch)</span></span><br><span class="line"><span class="comment"># origin  https://github.com/my/repo.git (push)</span></span><br><span class="line"><span class="comment"># upstream    https://github.com/another/repo.git (fetch)</span></span><br><span class="line"><span class="comment"># upstream    https://github.com/another/repo.git (push)</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>origin</code> 是克隆仓库时默认创建的远程仓库别名。</p>
<h4 id="2-5-2-git-fetch"><a href="#2-5-2-git-fetch" class="headerlink" title="2.5.2 git fetch"></a>2.5.2 <code>git fetch</code></h4><p><strong>作用</strong>：从远程仓库下载最新的提交和分支信息，但<strong>不合并</strong>到当前本地分支。它只会更新本地的远程分支引用（例如 <code>origin/main</code>）。</p>
<p><strong>语法</strong>：<code>git fetch [remote_name]</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line"><span class="comment"># output: (下载远程仓库的最新内容)</span></span><br><span class="line">git <span class="built_in">log</span> HEAD..origin/main <span class="comment"># 查看本地和远程/main的差异</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git fetch</code> 是一个安全的操作，因为它不会改变你的工作区或本地分支。</p>
<h4 id="2-5-3-git-pull"><a href="#2-5-3-git-pull" class="headerlink" title="2.5.3 git pull"></a>2.5.3 <code>git pull</code></h4><p><strong>作用</strong>：从远程仓库下载最新的提交，并自动合并到当前本地分支。等同于 <code>git fetch</code> 后再 <code>git merge</code>。</p>
<p><strong>语法</strong>：<code>git pull [remote_name] [branch_name]</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main <span class="comment"># 从 origin 远程仓库的 main 分支拉取并合并到当前分支</span></span><br><span class="line"><span class="comment"># output: (拉取并合并信息，可能需要解决冲突)</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git pull</code> 可能会导致合并冲突。可以使用 <code>git pull --rebase</code> 来替代 <code>git pull</code>，将本地提交变基到远程最新提交之上，避免合并提交。</p>
<h4 id="2-5-4-git-push"><a href="#2-5-4-git-push" class="headerlink" title="2.5.4 git push"></a>2.5.4 <code>git push</code></h4><p><strong>作用</strong>：将本地仓库的提交推送到远程仓库。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git push [remote_name] [branch_name]</code>：将本地分支推送到远程仓库的同名分支。</li>
<li><code>git push -u origin main</code>：设置本地 <code>main</code> 分支与远程 <code>origin/main</code> 分支的跟踪关系，并首次推送。后续只需 <code>git push</code>。</li>
<li><code>git push --force</code> 或 <code>git push --force-with-lease</code>：强制推送。<strong>慎用！</strong> 这会覆盖远程仓库的历史记录。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main <span class="comment"># 将本地 main 分支推送到 origin 远程仓库的 main 分支</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：当远程仓库有你本地没有的提交时，<code>git push</code> 会被拒绝。你需要先 <code>git pull</code> 同步远程更改并解决冲突后才能推送。<code>--force-with-lease</code> 比 <code>--force</code> 更安全，因为它会在强制推送前检查远程分支是否与本地分支的旧版本匹配，避免覆盖他人新的工作。</p>
<h3 id="2-6-撤销与修改"><a href="#2-6-撤销与修改" class="headerlink" title="2.6 撤销与修改"></a>2.6 撤销与修改</h3><h4 id="2-6-1-git-reset"><a href="#2-6-1-git-reset" class="headerlink" title="2.6.1 git reset"></a>2.6.1 <code>git reset</code></h4><p><strong>作用</strong>：重置 <code>HEAD</code> 指针和（可选）暂存区、工作区。这是一个<strong>破坏性</strong>命令，尤其是 <code>--hard</code> 选项。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git reset &lt;file_path&gt;</code>：将暂存区中指定文件撤回到工作区（即取消 <code>git add</code>）。</li>
<li><code>git reset --soft &lt;commit_hash&gt;</code>：移动 <code>HEAD</code> 到指定提交，但<strong>保留</strong>工作区和暂存区的更改。</li>
<li><code>git reset --mixed &lt;commit_hash&gt;</code> (默认)：移动 <code>HEAD</code> 到指定提交，<strong>清空</strong>暂存区，但<strong>保留</strong>工作区的更改。</li>
<li><code>git reset --hard &lt;commit_hash&gt;</code>：移动 <code>HEAD</code> 到指定提交，<strong>清空</strong>暂存区和工作区。<strong>最危险！会丢失未提交的更改。</strong></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销对 file.txt 的暂存</span></span><br><span class="line">git reset file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销最近两次提交，但保留所有修改在工作区和暂存区</span></span><br><span class="line">git reset --soft HEAD~2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销最近一次提交，清空暂存区，但保留工作区修改</span></span><br><span class="line">git reset HEAD~1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销最近一次提交，并丢弃所有修改，回到上一个提交的干净状态</span></span><br><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git reset</code> 应该小心使用，尤其是在已共享的分支上。</p>
<h4 id="2-6-2-git-revert"><a href="#2-6-2-git-revert" class="headerlink" title="2.6.2 git revert"></a>2.6.2 <code>git revert</code></h4><p><strong>作用</strong>：创建一个新的提交来撤销指定提交所引入的更改。这是一个<strong>安全</strong>的撤销操作，因为它不改写历史。</p>
<p><strong>语法</strong>：<code>git revert &lt;commit_hash&gt;</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert 2c3f4e5 <span class="comment"># 撤销哈希为 2c3f4e5 的提交，并创建一个新的提交</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git revert</code> 是在公共分支上撤销更改的首选方式，因为它保留了完整的历史记录。</p>
<h4 id="2-6-3-git-commit-amend"><a href="#2-6-3-git-commit-amend" class="headerlink" title="2.6.3 git commit --amend"></a>2.6.3 <code>git commit --amend</code></h4><p><strong>作用</strong>：修改最近一次提交。可以修改提交信息，或添加、移除文件到最近一次提交。</p>
<p><strong>语法</strong>：<code>git commit --amend -m &quot;New commit message&quot;</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交后发现信息写错了</span></span><br><span class="line">git commit --amend -m <span class="string">&quot;fix: Corrected typo in previous commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交后发现漏掉了 file.txt</span></span><br><span class="line">git add file.txt</span><br><span class="line">git commit --amend --no-edit <span class="comment"># 添加 file.txt 到上一次提交，不修改提交信息</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：此命令会替换掉最近的提交，生成一个新的提交哈希。因此，<strong>不要修改已推送到公共仓库的提交</strong>。</p>
<h4 id="2-6-4-git-clean"><a href="#2-6-4-git-clean" class="headerlink" title="2.6.4 git clean"></a>2.6.4 <code>git clean</code></h4><p><strong>作用</strong>：移除工作区中未跟踪的文件和目录。这是一个<strong>危险</strong>的命令，因为它会永久删除文件。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git clean -n</code> (dry run)：模拟执行，显示会删除哪些文件，但实际不删除。</li>
<li><code>git clean -f</code>：强制删除未跟踪的文件。</li>
<li><code>git clean -fd</code>：强制删除未跟踪的文件和目录。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clean -n <span class="comment"># 查看将要删除的文件</span></span><br><span class="line">git clean -fd <span class="comment"># 确认后执行删除</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：在执行 <code>git clean</code> 之前，务必先使用 <code>-n</code> 选项进行预览。</p>
<h3 id="2-7-标签与工具"><a href="#2-7-标签与工具" class="headerlink" title="2.7 标签与工具"></a>2.7 标签与工具</h3><h4 id="2-7-1-git-tag"><a href="#2-7-1-git-tag" class="headerlink" title="2.7.1 git tag"></a>2.7.1 <code>git tag</code></h4><p><strong>作用</strong>：创建、列出、删除标签。标签通常用于标记项目的重要里程碑，如发布版本。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git tag</code>：列出所有标签。</li>
<li><code>git tag -l &quot;v1.*&quot;</code>：列出符合模式的标签。</li>
<li><code>git tag &lt;tag_name&gt;</code>：创建轻量级标签（指向某个提交的指针）。</li>
<li><code>git tag -a &lt;tag_name&gt; -m &quot;Tag message&quot;</code>：创建附注标签（推荐，包含作者、日期和信息）。</li>
<li><code>git tag -d &lt;tag_name&gt;</code>：删除本地标签。</li>
<li><code>git push origin &lt;tag_name&gt;</code>：将指定标签推送到远程仓库。</li>
<li><code>git push origin --tags</code>：将所有本地标签推送到远程仓库。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 <span class="comment"># 创建轻量级标签</span></span><br><span class="line">git tag -a v1.0.1 -m <span class="string">&quot;Release version 1.0.1&quot;</span> <span class="comment"># 创建附注标签</span></span><br><span class="line">git push origin --tags <span class="comment"># 推送所有标签</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-git-stash"><a href="#2-7-2-git-stash" class="headerlink" title="2.7.2 git stash"></a>2.7.2 <code>git stash</code></h4><p><strong>作用</strong>：临时保存当前工作区和暂存区的修改，以便切换到其他任务，而无需提交这些不完整的更改。</p>
<p><strong>语法</strong>：</p>
<ul>
<li><code>git stash push -m &quot;Stash message&quot;</code>：保存当前修改并附带消息。</li>
<li><code>git stash list</code>：列出所有 stash。</li>
<li><code>git stash pop</code>：应用最近的一个 stash 并从列表中删除。</li>
<li><code>git stash apply &lt;stash@&#123;n&#125;&gt;</code>：应用指定的 stash，但不从列表中删除。</li>
<li><code>git stash drop &lt;stash@&#123;n&#125;&gt;</code>：删除指定的 stash。</li>
<li><code>git stash clear</code>：删除所有 stash。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正在开发新功能，但来了个紧急 Bug 需要修复</span></span><br><span class="line">git stash push -m <span class="string">&quot;WIP: login feature&quot;</span> <span class="comment"># 保存当前工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 main 分支修复 Bug...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bug 修复完成后，回到 feature 分支恢复工作</span></span><br><span class="line">git checkout feature/login</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-git-cherry-pick"><a href="#2-7-3-git-cherry-pick" class="headerlink" title="2.7.3 git cherry-pick"></a>2.7.3 <code>git cherry-pick</code></h4><p><strong>作用</strong>：选择一个或多个已存在的提交，并将其应用到当前分支上。这对于将一个分支上的特定 Bug 修复或小功能应用到另一个分支非常有用。</p>
<p><strong>语法</strong>：<code>git cherry-pick &lt;commit_hash&gt;</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有一个 Bug 修复提交在 hotfix 分支上，现在要应用到 develop</span></span><br><span class="line">git checkout develop</span><br><span class="line">git cherry-pick a1b2c3d <span class="comment"># a1b2c3d 是 hotfix 分支上的 Bug 修复提交</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：<code>git cherry-pick</code> 会创建一个新的提交，其内容与原提交相同，但哈希不同。</p>
<h4 id="2-7-4-git-reflog"><a href="#2-7-4-git-reflog" class="headerlink" title="2.7.4 git reflog"></a>2.7.4 <code>git reflog</code></h4><p><strong>作用</strong>：记录 <code>HEAD</code> 每次移动的日志。这是一个非常强大的“后悔药”，即使 <code>git log</code> 无法显示的历史，<code>reflog</code> 也能找回。</p>
<p><strong>语法</strong>：<code>git reflog</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># d1e2f3g (HEAD -&gt; main) HEAD@&#123;0&#125;: commit: Add new feature</span></span><br><span class="line"><span class="comment"># a0b1c2d HEAD@&#123;1&#125;: commit: Fix bug</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># d3e4f5g HEAD@&#123;10&#125;: reset --hard: moving to HEAD~2</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：如果你不小心执行了 <code>git reset --hard</code> 并丢失了提交，<code>git reflog</code> 可以帮你找到丢失提交的哈希，然后通过 <code>git reset --hard &lt;commit_hash&gt;</code> 恢复。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>Git 强大的版本控制能力来源于其丰富且灵活的命令集。从基础的 <code>init</code>、<code>add</code>、<code>commit</code> 到高级的 <code>rebase</code>、<code>stash</code>、<code>cherry-pick</code>，每个命令都有其特定的用途和对仓库历史的影响。掌握这些命令及其背后的原理，理解工作区、暂存区和仓库之间的交互，是成为高效 Git 用户的关键。在实际工作中，建议遵循团队协作规范，并谨慎使用会改写历史的破坏性命令，以确保项目历史的清晰和团队协作的顺畅。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/be852baa9322/">https://blog.tbf1211.xx.kg/be852baa9322/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/Git/">Git</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/b6adb43b8a7d/" title="GitHub Raw Content (raw.githubusercontent.com) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">GitHub Raw Content (raw.githubusercontent.com) 详解</div></div><div class="info-2"><div class="info-item-1"> raw.githubusercontent.com 是 GitHub 提供的一项服务，用于直接访问存储在 GitHub 仓库中的原始文件内容。当你在 GitHub 网站上查看一个文件时，你看到的是经过渲染的页面（例如，Markdown 文件会被渲染成 HTML），但 raw.githubusercontent.com 提供了该文件的原始、未经处理的版本，如同文件在本地文件系统中的字节流。它充当了一个简单的内容分发网络 (CDN)，使得开发者可以方便地将 GitHub 仓库中的文件作为静态资源直接引用到其他应用或网页中。  核心思想：提供对 GitHub 仓库中文件的原始、未经渲染内容的直接 HTTP 访问，将其作为静态资源或简单的数据源使用。   一、工作原理与 URL 结构raw.githubusercontent.com 的 URL 结构是高度规范化的，通常遵循以下格式： 1https://raw.githubusercontent.com/&#123;username&#125;/&#123;repository&#125;/&#123;branch&#125;/&#12...</div></div></div></a><a class="pagination-related" href="/85efaf3bfadb/" title="Hysteria2 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hysteria2 详解</div></div><div class="info-2"><div class="info-item-1"> Hysteria2 是 Hysteria 协议的下一代版本，它是一种高性能、抗审查的代理协议，专注于在高丢包、高延迟、带宽受限的网络环境下提供稳定快速的连接。Hysteria2 在其前身的基础上进行了多项重大改进，将底层传输协议从 QUIC 升级为基于自定义 UDP 的协议栈，并引入了更灵活的流量控制和更强大的抗审查特性。其核心理念是通过高效的 UDP 传输、TCP BBR 拥塞控制算法和 TLS 加密，在恶劣网络条件下最大化可用带宽，同时保持高度的隐蔽性。  核心思想：在不可靠的 UDP 传输之上构建一个可靠的、高性能的、基于 TCP BBR 算法的传输层，并结合 TLS 加密和流量伪装，以应对高丢包、高延迟和严格审查的网络环境。   一、为什么需要 Hysteria2？传统的代理协议，无论是基于 TCP (如 Shadowsocks TCP, VLESS&#x2F;Trojan over TCP+TLS) 还是基于 QUIC (如 Hysteria1)，在高丢包率、高延迟的网络环境中（例如跨国长距离传输、卫星网络、受到干扰的网络）都可能表现不佳：  TCP 协议的固有局限性...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/25324aef0ab0/" title="Git Merge vs. Rebase 对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-15</div><div class="info-item-2">Git Merge vs. Rebase 对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Git 版本控制系统中，git merge 和 git rebase 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。  核心思想：git merge 通过创建新的合并提交来集成更改，保留了所有分支的历史；git rebase 通过重写提交历史将一个分支的提交应用到另一个分支的顶部，从而创建线性的历史记录。   一、Git Merge (合并)1.1 定义git merge 命令用于将来自一个或多个分支的独立开发历史合并到当前分支。它通过创建一个新的合并提交 (merge commit) 来实现这一点，这个合并提交的父提交指向两个被合并分支的最新提交。这意味着 git merge 会保留所有分支的原始提交历史，并显式地记录合并发生的时间和地点。 1.2 工作原理当执行 git merge &lt;branch_name&gt; 时：  Git 找到当前分支 (HEAD) ...</div></div></div></a><a class="pagination-related" href="/876a758cde0d/" title=".gitignore 与 .gitattributes 文件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="info-item-2">.gitignore 与 .gitattributes 文件详解</div></div><div class="info-2"><div class="info-item-1"> .gitignore 和 .gitattributes 是 Git 版本控制系统中两个重要的配置文件，它们帮助开发者精细地控制 Git 如何处理工作目录中的文件。gitignore 主要用于忽略不应该被版本控制的文件，而 gitattributes 则用于定义不同文件的属性，影响 Git 存储和比较文件的方式。理解和正确使用这两个文件对于维护干净、高效且一致的 Git 仓库至关重要。  核心思想：  .gitignore 告诉 Git 哪些文件或目录应该被忽略，不纳入版本控制。 .gitattributes 告诉 Git 如何对待特定类型的文件，例如行尾符、合并策略、文本转换等。    一、.gitignore 文件详解.gitignore 文件用于指定 Git 应该忽略哪些文件或目录。 这些被忽略的文件不会被 Git 跟踪，也不会被添加到仓库中。这对于排除构建产物、日志文件、敏感配置、IDE 特定文件等内容非常有用，可以保持仓库的整洁，避免提交不必要的文件，并减少仓库大小。 1.1 工作原理Git 在执行 git add 或 git commit 等命令时，会检查工作目录中是...</div></div></div></a><a class="pagination-related" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-22</div><div class="info-item-2">Git 核心对象：Commit, Tree, Blob 详解</div></div><div class="info-2"><div class="info-item-1"> Git 作为一个分布式版本控制系统，其强大的能力和高效的存储机制离不开其底层对象模型。理解 Git 的核心对象——Commit (提交)、Tree (树) 和 Blob (二进制大对象)，是深入理解 Git 工作原理的关键。这些对象共同构成了 Git 存储库的骨架，以内容寻址 (Content-Addressable) 的方式，确保了版本历史的完整性和数据的不可篡改性。  Git 的宗旨是：一次只存储数据，而不是差异。 每个版本都是一个完整的快照，而非基于前一个版本的增量。这通过其核心对象模型高效实现。   一、Git 对象模型概述Git 存储库的核心是一个键值对数据库，其中“键”是内容的 SHA-1 校验和，而“值”则是 Git 对象。这些对象存储在 .git/objects 目录下。当 Git 添加或修改文件时，它不会直接存储文件的差异，而是将文件的完整内容作为对象存储起来，并根据其内容计算出一个唯一的 SHA-1 值作为标识符。 Git 对象主要分为四种类型，其中最核心的是 Blob、Tree 和 Commit：  Blob (Binary Large Object)：存...</div></div></div></a><a class="pagination-related" href="/a8310012f32b/" title="Git 从开发测试到上线的流程详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">Git 从开发测试到上线的流程详解</div></div><div class="info-2"><div class="info-item-1"> Git 作为一个分布式版本控制系统，在现代软件开发中扮演着核心角色。它不仅能追踪代码变更、协调团队协作，还能支撑复杂的开发、测试到上线的全流程管理。本文将详细阐述基于 Git 的标准开发、测试到上线流程，旨在提供一个清晰、可操作的实践指南。  核心思想：利用 Git 的分支管理能力，清晰地划分开发阶段，确保代码质量，并实现高效、可追溯的部署。   一、Git 分支模型选择在开始流程之前，选择一个合适的分支模型至关重要。常见的分支模型包括 Git Flow 和 GitHub Flow (或 GitLab Flow)。 1.1 Git FlowGit Flow 是一种较为复杂的、结构化的分支模型，适用于发布周期较长、版本发布严格的项目。它定义了五种主要分支：  main (或 master) 分支：用于存放生产环境稳定代码。只有当代码准备好发布时，才合并到此分支。每次合并到 main 都应该打上版本标签。 develop 分支：用于存放最新开发完成的代码，是所有功能开发分支的集成点。 feature 分支：用于开发新功能。通常从 develop 分支创建，完成功能开发后合并回 de...</div></div></div></a><a class="pagination-related" href="/793b1126e524/" title="Tomcat、Jetty 和 Undertow 对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-28</div><div class="info-item-2">Tomcat、Jetty 和 Undertow 对比详解</div></div><div class="info-2"><div class="info-item-1"> Tomcat、Jetty 和 Undertow 都是流行的 Java Web 服务器和 Servlet 容器，它们实现了 Java Servlet 规范、JavaServer Pages (JSP) 规范、Java Expression Language (EL) 规范以及 WebSocket 规范。在 Java 企业级应用开发中，特别是在 Spring Boot 等框架盛行的微服务时代，选择一个合适的内嵌或独立 Web 服务器变得尤为重要。虽然它们功能相似，但在架构设计、性能特点、内存占用、灵活性和社区支持等方面各有侧重。  核心思想：理解这些 Web 服务器的内部机制和特点，有助于在不同场景下做出最优选择。Tomcat 以稳定和功能全面闻名，Jetty 以轻量和可嵌入性见长，而 Undertow 则以高性能和低资源消耗脱颖而出。   一、基本概念和共通性在深入对比之前，我们先明确一些基本概念：  Web 服务器：能够响应 HTTP 请求，提供静态内容（如 HTML, CSS, JavaScript, 图片）。 Servlet 容器：实现了 Java Servlet 规范，能...</div></div></div></a><a class="pagination-related" href="/fa69350b38ad/" title="Git Submodules 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-16</div><div class="info-item-2">Git Submodules 详解</div></div><div class="info-2"><div class="info-item-1"> Git Submodule (子模块) 是 Git 版本控制系统提供的一种机制，允许一个 Git 仓库 (称为主仓库或 superproject) 将另一个完整的 Git 仓库 (称为子模块) 作为其子目录嵌入。主仓库会记录子模块的特定提交 (specific commit)，而不是其最新的 HEAD 状态。这意味着，当你克隆主仓库时，你并不会自动获得子模块的所有历史，而是获得其在主仓库中被记录的那个确切版本。  核心思想：将一个独立的 Git 仓库作为另一个 Git 仓库的子目录进行管理，并追踪子模块的特定提交，以实现外部依赖管理、模块化或代码复用，同时保持各仓库的独立性。   一、为什么需要 Git Submodules？在软件开发中，经常会遇到以下场景：  管理外部依赖：你的项目依赖于一个由第三方维护的库或框架，你希望将其代码包含在自己的仓库中，但又不想复制粘贴或手动更新。 模块化大型项目：一个大型项目由多个相对独立的组件构成，这些组件各自有独立的开发生命周期和版本控制，但需要在一个主项目中统一协调。 代码复用：多个项目共享同一段代码或一个公共库，你希望这段共享代码能够独...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">533</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Git-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE"><span class="toc-text">一、Git 核心概念回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B7%A5%E4%BD%9C%E5%8C%BA-Working-Directory"><span class="toc-text">1.1 工作区 (Working Directory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%9A%82%E5%AD%98%E5%8C%BA-Staging-Area-Index"><span class="toc-text">1.2 暂存区 (Staging Area &#x2F; Index)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93-Local-Repository"><span class="toc-text">1.3 本地仓库 (Local Repository)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-Remote-Repository"><span class="toc-text">1.4 远程仓库 (Remote Repository)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-HEAD"><span class="toc-text">1.5 HEAD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-Commit-%E6%8F%90%E4%BA%A4"><span class="toc-text">1.6 Commit (提交)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-Branch-%E5%88%86%E6%94%AF"><span class="toc-text">1.7 Branch (分支)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Git-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-text">二、Git 命令详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%91%BD%E4%BB%A4"><span class="toc-text">2.1 配置类命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-git-config"><span class="toc-text">2.1.1 git config</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%85%8B%E9%9A%86"><span class="toc-text">2.2 仓库初始化与克隆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-git-init"><span class="toc-text">2.2.1 git init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-git-clone"><span class="toc-text">2.2.2 git clone</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">2.3 基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-git-status"><span class="toc-text">2.3.1 git status</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-git-add"><span class="toc-text">2.3.2 git add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-git-commit"><span class="toc-text">2.3.3 git commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-git-log"><span class="toc-text">2.3.4 git log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-git-diff"><span class="toc-text">2.3.5 git diff</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="toc-text">2.4 分支管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-git-branch"><span class="toc-text">2.4.1 git branch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-git-checkout-%E6%97%A7%E7%89%88"><span class="toc-text">2.4.2 git checkout (旧版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-git-switch-%E6%96%B0%E7%89%88%EF%BC%8CGit-2-23"><span class="toc-text">2.4.3 git switch (新版，Git 2.23+)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-git-restore-%E6%96%B0%E7%89%88%EF%BC%8CGit-2-23"><span class="toc-text">2.4.4 git restore (新版，Git 2.23+)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-git-merge"><span class="toc-text">2.4.5 git merge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6-git-rebase"><span class="toc-text">2.4.6 git rebase</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-text">2.5 远程仓库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-git-remote"><span class="toc-text">2.5.1 git remote</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-git-fetch"><span class="toc-text">2.5.2 git fetch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-git-pull"><span class="toc-text">2.5.3 git pull</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-git-push"><span class="toc-text">2.5.4 git push</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%92%A4%E9%94%80%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="toc-text">2.6 撤销与修改</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-git-reset"><span class="toc-text">2.6.1 git reset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-git-revert"><span class="toc-text">2.6.2 git revert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-git-commit-amend"><span class="toc-text">2.6.3 git commit --amend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-git-clean"><span class="toc-text">2.6.4 git clean</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%B7%A5%E5%85%B7"><span class="toc-text">2.7 标签与工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-git-tag"><span class="toc-text">2.7.1 git tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-git-stash"><span class="toc-text">2.7.2 git stash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-git-cherry-pick"><span class="toc-text">2.7.3 git cherry-pick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-4-git-reflog"><span class="toc-text">2.7.4 git reflog</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">三、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-17.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>