<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>冲突域 (Collision Domain) 与广播域 (Broadcast Domain) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机网络中，理解冲突域 (Collision Domain) 和 广播域 (Broadcast Domain) 是理解局域网 (LAN) 工作原理和优化网络性能的基础。这两个概念描述了网络中数据帧或数据包传输的范围，以及网络设备如何影响这些范围。它们是评估网络设计、故障排除和选择合适网络设备的关键指标。  核心概念：冲突域影响数据传输的效率和碰撞的概率；广播域影响广播流量的范围和网络整体的性">
<meta property="og:type" content="article">
<meta property="og:title" content="冲突域 (Collision Domain) 与广播域 (Broadcast Domain) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/be99476e89e7/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在计算机网络中，理解冲突域 (Collision Domain) 和 广播域 (Broadcast Domain) 是理解局域网 (LAN) 工作原理和优化网络性能的基础。这两个概念描述了网络中数据帧或数据包传输的范围，以及网络设备如何影响这些范围。它们是评估网络设计、故障排除和选择合适网络设备的关键指标。  核心概念：冲突域影响数据传输的效率和碰撞的概率；广播域影响广播流量的范围和网络整体的性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-05.jpg">
<meta property="article:published_time" content="2024-07-31T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-24T14:25:00.969Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-05.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "冲突域 (Collision Domain) 与广播域 (Broadcast Domain) 详解",
  "url": "https://blog.tbf1211.xx.kg/be99476e89e7/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-05.jpg",
  "datePublished": "2024-07-31T22:24:00.000Z",
  "dateModified": "2026-01-24T14:25:00.969Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/be99476e89e7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '冲突域 (Collision Domain) 与广播域 (Broadcast Domain) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">518</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-05.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">冲突域 (Collision Domain) 与广播域 (Broadcast Domain) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">冲突域 (Collision Domain) 与广播域 (Broadcast Domain) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-07-31T22:24:00.000Z" title="发表于 2024-08-01 06:24:00">2024-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在计算机网络中，理解<strong>冲突域 (Collision Domain)</strong> 和 <strong>广播域 (Broadcast Domain)</strong> 是理解局域网 (LAN) 工作原理和优化网络性能的基础。这两个概念描述了网络中数据帧或数据包传输的范围，以及网络设备如何影响这些范围。它们是评估网络设计、故障排除和选择合适网络设备的关键指标。</p>
</blockquote>
<div class="note info flat"><p>核心概念：冲突域影响数据传输的效率和碰撞的概率；广播域影响广播流量的范围和网络整体的性能。</p>
</div>
<hr>
<h2 id="一、冲突域-Collision-Domain"><a href="#一、冲突域-Collision-Domain" class="headerlink" title="一、冲突域 (Collision Domain)"></a>一、冲突域 (Collision Domain)</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>冲突域</strong>是网络中所有能够因同时发送数据而发生<strong>数据碰撞 (Data Collision)</strong> 的设备的集合。在同一个冲突域内，任意时刻只能有一个设备发送数据，否则就会发生冲突。</p>
<h3 id="1-2-工作原理与影响"><a href="#1-2-工作原理与影响" class="headerlink" title="1.2 工作原理与影响"></a>1.2 工作原理与影响</h3><ul>
<li><strong>半双工模式</strong>：冲突域的概念主要与<strong>半双工 (Half-Duplex)</strong> 模式下的共享介质网络（如早期的同轴电缆以太网或使用集线器 Hub 的网络）相关。在这种模式下，设备要么发送数据，要么接收数据，不能同时进行。</li>
<li><strong>介质访问控制 (MAC)</strong>：为了管理共享介质，以太网使用 <strong>CSMA&#x2F;CD (Carrier Sense Multiple Access with Collision Detection)</strong> 机制。设备在发送前会监听介质是否空闲 (Carrier Sense)。如果空闲，就发送数据。在发送过程中，如果检测到其他设备同时发送，就会发生冲突 (Collision Detection)。</li>
<li><strong>性能影响</strong>：冲突会损坏数据，需要发送方重新发送，从而降低网络的有效带宽和吞吐量，增加延迟。冲突越频繁，网络效率越低。</li>
</ul>
<h3 id="1-3-常见的冲突域边界设备"><a href="#1-3-常见的冲突域边界设备" class="headerlink" title="1.3 常见的冲突域边界设备"></a>1.3 常见的冲突域边界设备</h3><p>理解哪些设备会隔离或扩大冲突域，是理解其核心的关键。</p>
<ul>
<li><strong>集线器 (Hub)</strong>：<ul>
<li><strong>边界</strong>：<strong>不隔离冲突域</strong>。所有连接到同一个集线器上的设备都属于同一个巨大的冲突域。集线器只是简单地放大电信号并泛洪到所有端口。</li>
<li><strong>导致</strong>：如果集线器上连接了 N 个设备，则这 N 个设备共享一个冲突域。</li>
</ul>
</li>
<li><strong>交换机 (Switch)</strong>：<ul>
<li><strong>边界</strong>：<strong>隔离冲突域</strong>。交换机的每个端口都是一个独立的冲突域。</li>
<li><strong>实现</strong>：当设备连接到交换机的端口时，它们通常以<strong>全双工 (Full-Duplex)</strong> 模式工作，这意味着它们可以同时发送和接收数据，从而彻底消除了该端口上的冲突。即使在半双工模式下，交换机也能通过存储转发机制隔离端口间的冲突。</li>
<li><strong>结果</strong>：一个 24 端口的交换机可以创建 24 个独立的冲突域，大大提升了网络性能。</li>
</ul>
</li>
<li><strong>路由器 (Router)</strong>：<ul>
<li><strong>边界</strong>：<strong>隔离冲突域</strong>。路由器的每个接口都连接一个独立的网络段，因此每个接口也都隔离了一个冲突域。</li>
<li><strong>结果</strong>：与交换机类似，路由器接口所连接的网段也是一个独立的冲突域。</li>
</ul>
</li>
</ul>
<h3 id="1-4-冲突域的演变与当前意义"><a href="#1-4-冲突域的演变与当前意义" class="headerlink" title="1.4 冲突域的演变与当前意义"></a>1.4 冲突域的演变与当前意义</h3><p>在早期共享式以太网和集线器时代，冲突域是网络性能的主要瓶颈。然而，随着<strong>交换机</strong>的普及和<strong>全双工通信</strong>的广泛应用，大部分现代局域网中，冲突域的影响已经大大减小，甚至近乎消失。现代网络中，每个连接到交换机端口的设备通常都工作在全双工模式下，每个端口都成为一个独立的微型冲突域，互不干扰。</p>
<p>尽管如此，理解冲突域的概念对于排查少数遗留的半双工设备带来的问题，以及理解网络基础原理仍然非常重要。</p>
<h2 id="二、广播域-Broadcast-Domain"><a href="#二、广播域-Broadcast-Domain" class="headerlink" title="二、广播域 (Broadcast Domain)"></a>二、广播域 (Broadcast Domain)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>广播域</strong>是网络中所有能够接收到同一个<strong>广播数据帧 (Broadcast Frame)</strong> 的设备的集合。当一个设备发送一个广播帧时（目的 MAC 地址是 <code>FF:FF:FF:FF:FF:FF</code>），该广播帧会扩散到其所在广播域内的所有设备。</p>
<h3 id="2-2-工作原理与影响"><a href="#2-2-工作原理与影响" class="headerlink" title="2.2 工作原理与影响"></a>2.2 工作原理与影响</h3><ul>
<li><strong>广播帧</strong>：广播帧用于在网络中查找未知设备的 MAC 地址（如 ARP 请求）、获取 IP 地址（如 DHCP 请求）以及其他一些特定协议的需求。</li>
<li><strong>泛洪 (Flooding)</strong>：当交换机或集线器接收到广播帧时，它会将其泛洪到除接收端口之外的所有其他端口，直至遇到隔离广播域的设备。</li>
<li><strong>性能影响</strong>：广播帧会占用网络带宽，并要求域内所有设备接收并处理这些帧，即使它们不是目标。在一个大型广播域中，过多的广播流量（即<strong>广播风暴 Broadcast Storm</strong>）会显著降低网络性能，增加设备的 CPU 负担，甚至导致网络瘫痪。</li>
</ul>
<h3 id="2-3-常见的广播域边界设备"><a href="#2-3-常见的广播域边界设备" class="headerlink" title="2.3 常见的广播域边界设备"></a>2.3 常见的广播域边界设备</h3><ul>
<li><strong>集线器 (Hub)</strong>：<ul>
<li><strong>边界</strong>：<strong>不隔离广播域</strong>。所有连接到同一个集线器上的设备都属于同一个广播域。</li>
</ul>
</li>
<li><strong>交换机 (Switch)</strong>：<ul>
<li><strong>边界</strong>：<strong>默认不隔离广播域</strong>。所有连接到同一个物理交换机（或多个未划分 VLAN 的交换机连接在一起）的设备都属于同一个广播域。广播帧会泛洪到所有端口。</li>
<li><strong>例外&#x2F;增强</strong>：通过配置 <strong>VLAN (Virtual Local Area Network)</strong>，可以在一个物理交换机上逻辑地创建多个独立的广播域。不同 VLAN 之间的广播帧互不影响。</li>
</ul>
</li>
<li><strong>路由器 (Router)</strong>：<ul>
<li><strong>边界</strong>：<strong>隔离广播域</strong>。路由器的每个接口都连接一个独立的网络段，Duff每个接口都创建了一个新的广播域。路由器<strong>不会转发广播帧</strong>到其他接口。</li>
<li><strong>结果</strong>：这是路由器能够连接不同 IP 子网的根本原因之一，它有效控制了广播流量的范围。</li>
</ul>
</li>
</ul>
<h3 id="2-4-广播域的重要性"><a href="#2-4-广播域的重要性" class="headerlink" title="2.4 广播域的重要性"></a>2.4 广播域的重要性</h3><p>广播域的规模直接影响网络的性能和安全性。</p>
<ul>
<li><strong>网络性能</strong>：广播域越大，广播流量越多，网络效率越低。</li>
<li><strong>网络安全</strong>：广播域内的设备可以互相监听广播报文，不恰当的配置可能导致信息泄露。</li>
<li><strong>网络设计</strong>：合理划分广播域是网络分层设计（如三层网络架构）的核心思想，通过路由器和 VLAN 来控制广播范围。</li>
</ul>
<h2 id="三、冲突域与广播域的对比总结"><a href="#三、冲突域与广播域的对比总结" class="headerlink" title="三、冲突域与广播域的对比总结"></a>三、冲突域与广播域的对比总结</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">冲突域 (Collision Domain)</th>
<th align="left">广播域 (Broadcast Domain)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>OSI 层级</strong></td>
<td align="left">物理层 (Layer 1) &amp; 数据链路层 (Layer 2)</td>
<td align="left">数据链路层 (Layer 2)</td>
</tr>
<tr>
<td align="left"><strong>关注问题</strong></td>
<td align="left">数据碰撞、介质访问、传输效率</td>
<td align="left">广播流量、网络性能、广播风暴、IP寻址效率</td>
</tr>
<tr>
<td align="left"><strong>影响范围</strong></td>
<td align="left">受限于半双工通信的共享介质</td>
<td align="left">所有能接收到广播帧的设备</td>
</tr>
<tr>
<td align="left"><strong>边界设备</strong></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>集线器 (Hub)</strong></td>
<td align="left"><strong>不隔离</strong>（所有端口是同一个冲突域）</td>
<td align="left"><strong>不隔离</strong>（所有端口是同一个广播域）</td>
</tr>
<tr>
<td align="left"><strong>交换机 (Switch)</strong></td>
<td align="left"><strong>隔离</strong>（每个端口是一个独立冲突域）</td>
<td align="left"><strong>默认不隔离</strong>（可使用 VLAN 隔离）</td>
</tr>
<tr>
<td align="left"><strong>路由器 (Router)</strong></td>
<td align="left"><strong>隔离</strong>（每个接口是一个独立冲突域）</td>
<td align="left"><strong>隔离</strong>（每个接口是一个独立广播域，不转发广播）</td>
</tr>
<tr>
<td align="left"><strong>现代网络</strong></td>
<td align="left">影响已大大减小（因全双工和交换机普及）</td>
<td align="left">仍是重要考虑因素（影响网络性能和管理）</td>
</tr>
</tbody></table>
<h2 id="四、理解冲突域和广播域的实践意义"><a href="#四、理解冲突域和广播域的实践意义" class="headerlink" title="四、理解冲突域和广播域的实践意义"></a>四、理解冲突域和广播域的实践意义</h2><h3 id="1-优化网络性能"><a href="#1-优化网络性能" class="headerlink" title="1. 优化网络性能"></a>1. 优化网络性能</h3><ul>
<li><strong>减少冲突域</strong>：通过部署交换机替换集线器，将大的冲突域分解为小的冲突域，甚至将每个端口变成独立的冲突域，从而彻底消除冲突，提升吞吐量。</li>
<li><strong>划分广播域</strong>：通过部署路由器和配置 VLAN，将大型广播域划分为更小、更易于管理的广播域。这可以限制广播流量在局部范围内，减少不必要的网络流量和设备负担，提高网络整体性能。</li>
</ul>
<h3 id="2-增强网络安全"><a href="#2-增强网络安全" class="headerlink" title="2. 增强网络安全"></a>2. 增强网络安全</h3><ul>
<li><strong>广播域隔离</strong>：不同广播域之间的设备默认无法直接通信，增强了网络隔离性。例如，将财务部门和研发部门通过 VLAN 划分为不同的广播域，可以防止未经授权的跨部门访问和信息泄露。</li>
<li><strong>ACL</strong>：在路由器上配置 ACL 可以进一步在广播域之间过滤 IP 流量，提供更细粒度的安全控制。</li>
</ul>
<h3 id="3-简化网络管理"><a href="#3-简化网络管理" class="headerlink" title="3. 简化网络管理"></a>3. 简化网络管理</h3><ul>
<li><strong>模块化设计</strong>：通过合理划分广播域，网络可以构建成模块化的结构，便于管理和故障排除。当一个广播域出现问题时，通常不会影响到其他广播域。</li>
<li><strong>IP 地址规划</strong>：广播域的划分与 IP 地址子网的划分紧密相关，有助于进行清晰的 IP 地址规划。</li>
</ul>
<h3 id="4-故障排除"><a href="#4-故障排除" class="headerlink" title="4. 故障排除"></a>4. 故障排除</h3><ul>
<li>当网络性能低下时，首先考虑是否是由于过大的冲突域（在旧有网络中）或广播域（广播风暴）造成的。</li>
<li>当一个特定网段的设备无法通信时，检查其是否在预期的广播域内，以及路由器或交换机配置是否正确。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>冲突域和广播域是网络专业人员必备的基础知识。冲突域关注的是物理层和数据链路层在共享介质访问时的效率问题，通过交换机和全双工技术已被有效解决。广播域则关注数据链路层广播流量的扩散范围，它对网络性能、安全性和可管理性有着持续且深远的影响，需要通过路由器和 VLAN 等技术进行精细规划和控制。深入理解并有效管理这两个概念，是构建高性能、高安全性和易于管理网络的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/be99476e89e7/">https://blog.tbf1211.xx.kg/be99476e89e7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7642665c9bbb/" title="Golang context 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang context 详解</div></div><div class="info-2"><div class="info-item-1"> context 包 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递请求范围的数据 (request-scoped data)、取消信号 (cancellation signals) 和截止时间 (deadlines) 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，context 包是管理 Goroutine 生命周期和避免资源泄露的基石。  核心思想：context.Context 接口允许在 Goroutine 树中安全地传递控制流信息。其核心价值在于实现对计算任务的统一取消、超时控制和值传递，从而提升程序的健壮性和资源利用效率。   一、context 包的必要性在 Go 语言中，Goroutine 是轻量级并发的基础。然而，当应用程序的并发逻辑变得复杂时，以下问题会变得突出：  并发操作的取消：当一个上游操作（如用户取消请求）不再需要其下游的所有并发子任务时，如何有效地通知并停止这些子任务，避免不必要的计算和资源消耗？ 操作超时控制：如何在复杂的请求链中，为整个链条或其中某个环节设置统一的...</div></div></div></a><a class="pagination-related" href="/460c8465e54b/" title="路由器 (Router) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">路由器 (Router) 详解</div></div><div class="info-2"><div class="info-item-1"> 路由器 (Router) 是一种工作在 OSI 模型网络层（第三层）的网络设备。它的核心功能是连接多个异构网络（如局域网 LANs 和广域网 WANs），并根据 IP 地址执行路由选择 (Routing) 和数据包转发 (Packet Forwarding)。路由器通过维护一张路由表 (Routing Table) 来决定数据包的最佳路径，从而跨越不同的网络段，实现设备间的通信。  核心功能：基于 IP 地址选择最佳路径并转发数据包，连接不同网络，隔离广播域。   一、什么是路由器？路由器是连接两个或多个离散网络（通常是不同 IP 子网）的互联设备。它负责接收来自一个网络的数据包，解析其目的 IP 地址，然后根据其内部的路由表，将数据包转发到前往目的网络的下一个路由器或最终目的主机。路由器是互联网的基础，没有路由器，数据包就无法跨越不同的网络到达目的地。 路由器在网络中的作用：  互联网络：连接不同的局域网、广域网，甚至是互联网。 路由选择：通过复杂的算法（路由协议）或静态配置，确定数据包从源到目的地的最佳路径。 数据包转发：将数据包从一个网络接口接收，再从另一个网络接口发送出...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/56d360e5bda1/" title="SNAT 与 DNAT 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">SNAT 与 DNAT 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：源网络地址转换 (SNAT - Source Network Address Translation) 和 目的网络地址转换 (DNAT - Destination Network Address Translation)。理解这两种机制对于网络设计、故障排查和安全性至关重要。  核心思想：  SNAT：解决“内部网络中主机如何安全地、共享地访问外部网络资源”的问题，修改出站数据包的源地址。 DNAT：解决“外部网络中主机如何安全地访问内部提供的服务”的问题，修改入站数据包的目的地址。     一、网络地址转换 (NAT) 概述NAT 技术最初是为了缓解 IPv4 地址枯竭问题而设计，它允许一个内部私有 IP 网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信。除了地址共享，NAT 也为内部网络提供了一层基本的安全隔...</div></div></div></a><a class="pagination-related" href="/b8edc2276249/" title="雪花算法 (Snowflake Algorithm) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-19</div><div class="info-item-2">雪花算法 (Snowflake Algorithm) 详解</div></div><div class="info-2"><div class="info-item-1"> 雪花算法 (Snowflake Algorithm) 是 Twitter 公司开源的一种分布式唯一 ID 生成算法。它旨在解决在分布式系统中生成全局唯一、递增（但非严格递增）且高性能 ID 的需求。其生成的 ID 是一个 64 位的整数，具有时间有序性，并且不依赖于数据库，易于扩展。  核心思想：将 64 位的 Long 型 ID 拆分为多个字段，分别存储时间戳、数据中心 ID、机器 ID 和序列号，通过位运算拼接以保证全局唯一性和大致的时间有序性。   一、为什么需要雪花算法？在分布式系统中，传统的单点自增 ID 方案面临巨大挑战：  唯一性问题：不同的数据库实例或服务节点可能生成相同的 ID。 性能瓶颈：为了保证唯一性，可能需要引入中心化的 ID 生成服务或数据库锁，成为系统瓶颈。 可用性问题：中心化服务一旦宕机，整个系统的 ID 生成将受影响。  虽然 UUID 能够保证全局唯一性，但它存在一些缺点：  存储和传输效率低：128 位，比 64 位 ID 更占用空间，索引性能较差。 无序性：UUID 是无序的，插入数据库时会导致 B+ 树索引频繁分裂和重建，影响数据库性能。...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a><a class="pagination-related" href="/f7642a181610/" title="CDN (内容分发网络) 服务详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">CDN (内容分发网络) 服务详解</div></div><div class="info-2"><div class="info-item-1"> CDN (Content Delivery Network)，即内容分发网络，是一种构建在现有网络基础之上的智能虚拟网络。它通过将站点内容发布到离用户最近的全球边缘节点，使用户在请求内容时，能够从距离自己最近的服务器获取数据，从而显著加速内容传输、减轻源站负载、提高用户体验和保障服务可用性。  核心思想：将内容缓存到离用户近的地方，让用户就近获取，缩短物理距离，从而缩短加载时间。   一、为什么需要 CDN？在没有 CDN 的情况下，用户访问网站的所有请求都会直接发送到源服务器。这存在几个问题：  访问速度慢：当用户与源服务器之间地理距离较远时，数据传输路径长，网络延迟高，导致页面加载缓慢，尤其是对于图片、视频等大文件。 网络拥堵：跨国或跨洲际网络传输容易受到骨干网带宽限制和拥堵的影响。 源站负载高：所有用户的请求都直接冲击源服务器，在高并发场景下可能导致源服务器过载、响应变慢甚至崩溃。 单点故障风险：源服务器一旦出现故障或遭受攻击，整个网站将无法访问。 安全性弱：源站直接暴露在公网，容易成为 DDoS 攻击的目标。  CDN 旨在解决上述问题，提供以下核心价值：  加速访问：...</div></div></div></a><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">518</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%B2%E7%AA%81%E5%9F%9F-Collision-Domain"><span class="toc-text">一、冲突域 (Collision Domain)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%B1%E5%93%8D"><span class="toc-text">1.2 工作原理与影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%B2%E7%AA%81%E5%9F%9F%E8%BE%B9%E7%95%8C%E8%AE%BE%E5%A4%87"><span class="toc-text">1.3 常见的冲突域边界设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%86%B2%E7%AA%81%E5%9F%9F%E7%9A%84%E6%BC%94%E5%8F%98%E4%B8%8E%E5%BD%93%E5%89%8D%E6%84%8F%E4%B9%89"><span class="toc-text">1.4 冲突域的演变与当前意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%BF%E6%92%AD%E5%9F%9F-Broadcast-Domain"><span class="toc-text">二、广播域 (Broadcast Domain)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BD%B1%E5%93%8D"><span class="toc-text">2.2 工作原理与影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%BF%E6%92%AD%E5%9F%9F%E8%BE%B9%E7%95%8C%E8%AE%BE%E5%A4%87"><span class="toc-text">2.3 常见的广播域边界设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%B9%BF%E6%92%AD%E5%9F%9F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text">2.4 广播域的重要性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%B2%E7%AA%81%E5%9F%9F%E4%B8%8E%E5%B9%BF%E6%92%AD%E5%9F%9F%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">三、冲突域与广播域的对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%90%86%E8%A7%A3%E5%86%B2%E7%AA%81%E5%9F%9F%E5%92%8C%E5%B9%BF%E6%92%AD%E5%9F%9F%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%84%8F%E4%B9%89"><span class="toc-text">四、理解冲突域和广播域的实践意义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%98%E5%8C%96%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD"><span class="toc-text">1. 优化网络性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-text">2. 增强网络安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%80%E5%8C%96%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="toc-text">3. 简化网络管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-text">4. 故障排除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-05.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>