<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>iptables 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="iptables 是 Linux 系统中一个强大的防火墙工具，它基于 Netfilter 框架。Netfilter 是 Linux 内核中的一个数据包过滤和修改框架，而 iptables 是用于在用户空间配置 Netfilter 规则的命令行工具。通过 iptables，系统管理员可以定义各种规则来过滤、修改、转发或拦截网络数据包，从而实现网络流量控制、端口转发、地址伪装等功能。可以说，ipta">
<meta property="og:type" content="article">
<meta property="og:title" content="iptables 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/c5054902e8b1/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="iptables 是 Linux 系统中一个强大的防火墙工具，它基于 Netfilter 框架。Netfilter 是 Linux 内核中的一个数据包过滤和修改框架，而 iptables 是用于在用户空间配置 Netfilter 规则的命令行工具。通过 iptables，系统管理员可以定义各种规则来过滤、修改、转发或拦截网络数据包，从而实现网络流量控制、端口转发、地址伪装等功能。可以说，ipta">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg">
<meta property="article:published_time" content="2025-10-24T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-31T06:41:34.991Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="防火墙">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "iptables 详解",
  "url": "https://blog.tbf1211.xx.kg/c5054902e8b1/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg",
  "datePublished": "2025-10-24T22:24:00.000Z",
  "dateModified": "2025-12-31T06:41:34.991Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/c5054902e8b1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'iptables 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">448</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-12.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">iptables 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">iptables 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>iptables</strong> 是 Linux 系统中一个强大的防火墙工具，它基于 Netfilter 框架。Netfilter 是 Linux 内核中的一个数据包过滤和修改框架，而 iptables 是用于在用户空间配置 Netfilter 规则的命令行工具。通过 iptables，系统管理员可以定义各种规则来过滤、修改、转发或拦截网络数据包，从而实现网络流量控制、端口转发、地址伪装等功能。可以说，iptables 是 Linux 系统网络安全和流量管理的基石。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>基于规则链对数据包进行匹配和处理。</strong> 数据包在网络协议栈中穿行时，会根据定义好的规则链进行检查，并按照链中的规则顺序执行相应的动作。</p>
</div>
<hr>
<h2 id="一、Netfilter-框架与-iptables-关系"><a href="#一、Netfilter-框架与-iptables-关系" class="headerlink" title="一、Netfilter 框架与 iptables 关系"></a>一、Netfilter 框架与 iptables 关系</h2><p>理解 iptables，首先要了解它与 Netfilter 的关系：</p>
<ul>
<li><strong>Netfilter</strong>：位于 Linux 内核中，是一个用于网络数据包过滤、修改、转发和跟踪的框架。它定义了几个”钩子” (Hooks) 点，当数据包经过这些钩子点时，Netfilter 会检查是否有注册的规则需要处理该数据包。</li>
<li><strong>iptables</strong>：是用户空间的命令行工具，用于向 Netfilter 框架添加、删除、修改和查询规则。它提供了简洁的接口来管理内核中的数据包处理逻辑。</li>
</ul>
<p>一个数据包在 Linux 系统内的穿越路径图 (简化版) 及其经过的 Netfilter 钩子点：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    subgraph Data Packet Flow
        Client[Client] -- 数据包发送 --&gt; NetworkIn[网络接口接收]
        NetworkIn -- PREROUTING --&gt; Decision1{是否本地进程？}
        Decision1 -- 是 --&gt; INPUT --&gt; LocalProcess[本地进程]
        Decision1 -- 否 --&gt; FORWARD --&gt; Decision2{是否转发？}
        Decision2 -- 是 --&gt; PostRouting[POSTROUTING] --&gt; NetworkOut[网络接口发送] --&gt; Server[Server]
        LocalProcess -- OUTPUT --&gt; PostRouting
    end
  </pre></div>

<p><em>图：数据包在 Linux 系统中的流向以及 Netfilter 钩子点的大致位置</em></p>
<h2 id="二、iptables-的三个基本概念：表-Tables-、链-Chains-、规则-Rules"><a href="#二、iptables-的三个基本概念：表-Tables-、链-Chains-、规则-Rules" class="headerlink" title="二、iptables 的三个基本概念：表 (Tables)、链 (Chains)、规则 (Rules)"></a>二、iptables 的三个基本概念：表 (Tables)、链 (Chains)、规则 (Rules)</h2><p>iptables 的核心由三个层次构成：<strong>表 -&gt; 链 -&gt; 规则</strong>。</p>
<h3 id="2-1-表-Tables"><a href="#2-1-表-Tables" class="headerlink" title="2.1 表 (Tables)"></a>2.1 表 (Tables)</h3><p>表是 iptables 中规则的集合，用于处理特定类型的网络任务。每个表都包含一些预定义的链。iptables 共有 5 个表：</p>
<ol>
<li><p><strong><code>filter</code> 表 (默认表)</strong>：</p>
<ul>
<li><strong>用途</strong>：实现数据包过滤，针对数据包是否被允许通过防火墙进行判断。包含允许&#x2F;拒绝数据包进入或离开某个接口的规则。</li>
<li><strong>包含链</strong>：<code>INPUT</code>, <code>FORWARD</code>, <code>OUTPUT</code>。</li>
<li><strong>优先级</strong>：中等。</li>
<li><strong>常见应用</strong>：阻止恶意IP访问、限制端口访问、建立白名单&#x2F;黑名单。</li>
</ul>
</li>
<li><p><strong><code>nat</code> 表 (Network Address Translation)</strong>：</p>
<ul>
<li><strong>用途</strong>：实现网络地址转换，修改数据包的源地址（SNAT）或目的地址（DNAT）。</li>
<li><strong>包含链</strong>：<code>PREROUTING</code>, <code>INPUT</code> (在旧版本中可能用于NAT，很少用), <code>OUTPUT</code>, <code>POSTROUTING</code>。</li>
<li><strong>优先级</strong>：高。</li>
<li><strong>常见应用</strong>：端口转发 (DNAT)、地址伪装&#x2F;共享上网 (SNAT&#x2F;MASQUERADE)。</li>
</ul>
</li>
<li><p><strong><code>mangle</code> 表</strong>：</p>
<ul>
<li><strong>用途</strong>：修改数据包的 IP 头信息，例如 TTL（Time To Live）、TOS（Type of Service）等，但不涉及 IP 地址或端口的更改。</li>
<li><strong>包含链</strong>：<code>PREROUTING</code>, <code>INPUT</code>, <code>FORWARD</code>, <code>OUTPUT</code>, <code>POSTROUTING</code>。</li>
<li><strong>优先级</strong>：最高。</li>
<li><strong>常见应用</strong>：QoS (Quality of Service)、标记数据包以便后续处理。</li>
</ul>
</li>
<li><p><strong><code>raw</code> 表</strong>：</p>
<ul>
<li><strong>用途</strong>：主要用于关闭 Netfilter 的连接跟踪 (Connection Tracking) 机制。</li>
<li><strong>包含链</strong>：<code>PREROUTING</code>, <code>OUTPUT</code>。</li>
<li><strong>优先级</strong>：最高 (比 mangle 更早)。</li>
<li><strong>常见应用</strong>：对某些高流量的、不需要连接跟踪的数据包进行优化（如简单的 UDP 服务）。</li>
</ul>
</li>
<li><p><strong><code>security</code> 表 (较新)</strong>：</p>
<ul>
<li><strong>用途</strong>：在 SELinux 环境下强制实施 MAC (Mandatory Access Control) 策略。</li>
<li><strong>包含链</strong>：<code>INPUT</code>, <code>OUTPUT</code>, <code>FORWARD</code>。</li>
<li><strong>优先级</strong>：在 <code>filter</code> 表之后。</li>
</ul>
</li>
</ol>
<h3 id="2-2-链-Chains"><a href="#2-2-链-Chains" class="headerlink" title="2.2 链 (Chains)"></a>2.2 链 (Chains)</h3><p>链是规则的有序列表。当数据包到达 Netfilter 框架的某个钩子点时，它会按照顺序遍历该钩子点所对应的链中的所有规则。iptables 主要有 5 条预定义链 (通常存在于 filter 表和 mangle 表中，nat 和 raw 表有自己特定的链)：</p>
<ol>
<li><p><strong><code>PREROUTING</code> 链</strong>：</p>
<ul>
<li><strong>触发时机</strong>：数据包刚进入防火墙时，在路由判断之前。</li>
<li><strong>表</strong>：<code>raw</code>, <code>mangle</code>, <code>nat</code>。</li>
<li><strong>用途</strong>：用于在数据包路由到本地进程或转发到其他接口之前，对其进行修改（如 DNAT）或标记。</li>
</ul>
</li>
<li><p><strong><code>INPUT</code> 链</strong>：</p>
<ul>
<li><strong>触发时机</strong>：数据包将要被本地进程接收时。</li>
<li><strong>表</strong>：<code>mangle</code>, <code>filter</code>, <code>security</code>。</li>
<li><strong>用途</strong>：控制进入本机的所有数据包（目的地是本机 IP 的数据包），例如允许&#x2F;拒绝 SSH 访问本机端口。</li>
</ul>
</li>
<li><p><strong><code>FORWARD</code> 链</strong>：</p>
<ul>
<li><strong>触发时机</strong>：数据包要被转发到另一个接口时（路由器功能）。</li>
<li><strong>表</strong>：<code>mangle</code>, <code>filter</code>, <code>security</code>。</li>
<li><strong>用途</strong>：控制穿越防火墙的数据包，例如在路由器上，控制内部网络与外部网络的通信。</li>
</ul>
</li>
<li><p><strong><code>OUTPUT</code> 链</strong>：</p>
<ul>
<li><strong>触发时机</strong>：本地进程产生的数据包即将离开本机时。</li>
<li><strong>表</strong>：<code>raw</code>, <code>mangle</code>, <code>nat</code>, <code>filter</code>, <code>security</code>。</li>
<li><strong>用途</strong>：控制本机发出的所有数据包。</li>
</ul>
</li>
<li><p><strong><code>POSTROUTING</code> 链</strong>：</p>
<ul>
<li><strong>触发时机</strong>：数据包即将离开防火墙时，在所有路由判断之后。</li>
<li><strong>表</strong>：<code>mangle</code>, <code>nat</code>。</li>
<li><strong>用途</strong>：用于在数据包离开之前，对其进行最终修改（如 SNAT&#x2F;MASQUERADE）。</li>
</ul>
</li>
</ol>
<p><strong>数据包流向与链的关系图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A(数据包进入网卡) --&gt; B{&quot;PREROUTING Chain &lt;br&gt;(Mangle, Raw, Nat)&quot;}
    B --&gt; C{路由判断: 目标是本机&lt;br&gt;还是转发?}
    C -- 目标是本机 --&gt; D{&quot;INPUT Chain (Mangle, &lt;br&gt;Filter, Security)&quot;}
    D --&gt; E(本地进程接收)
    C -- 目标是转发 --&gt; F{&quot;FORWARD Chain (Mangle, &lt;br&gt;Filter, Security)&quot;}
    F --&gt; G{&quot;POSTROUTING Chain &lt;br&gt;(Mangle, Nat)&quot;}
    G --&gt; H(数据包离开网卡)
    I(本地进程发送数据包) --&gt; J{&quot;OUTPUT Chain (Mangle, &lt;br&gt;Raw, Nat, Filter, Security)&quot;}
    J --&gt; G
  </pre></div>

<h3 id="2-3-规则-Rules"><a href="#2-3-规则-Rules" class="headerlink" title="2.3 规则 (Rules)"></a>2.3 规则 (Rules)</h3><p>规则是 iptables 的最小逻辑单元，由<strong>匹配条件 (Matches)</strong> 和<strong>动作 (Targets)</strong> 组成。</p>
<ul>
<li><p><strong>匹配条件</strong>：指定触发规则的数据包特征，例如：</p>
<ul>
<li><code>-p &lt;protocol&gt;</code>：协议类型 (tcp, udp, icmp, all)。</li>
<li><code>-s &lt;source_ip&gt;</code>：源 IP 地址或网络。</li>
<li><code>-d &lt;destination_ip&gt;</code>：目的 IP 地址或网络。</li>
<li><code>--sport &lt;source_port&gt;</code>：源端口号。</li>
<li><code>--dport &lt;destination_port&gt;</code>：目的端口号。</li>
<li><code>-i &lt;input_interface&gt;</code>：入站接口。</li>
<li><code>-o &lt;output_interface&gt;</code>：出站接口。</li>
<li><code>-m &lt;module&gt;</code>：通过模块扩展匹配功能，如 <code>-m state</code> (连接跟踪状态), <code>-m mac</code> (MAC 地址), <code>-m limit</code> (速率限制) 等。</li>
</ul>
</li>
<li><p><strong>动作 (Target)</strong>：指定当数据包匹配规则后执行的操作。</p>
<ul>
<li><strong><code>ACCEPT</code></strong>：允许数据包通过。</li>
<li><strong><code>DROP</code></strong>：默默丢弃数据包，不返回任何信息给发送方。</li>
<li><strong><code>REJECT</code></strong>：丢弃数据包，并向发送方返回一个错误信息（例如 ICMP host unreachable）。</li>
<li><strong><code>SNAT</code></strong>：源网络地址转换（详见 DNAT&#x2F;SNAT 详解）。</li>
<li><strong><code>DNAT</code></strong>：目的网络地址转换（详见 DNAT&#x2F;SNAT 详解）。</li>
<li><strong><code>MASQUERADE</code></strong>：源地址伪装，一种特殊的 SNAT，用于动态 IP 地址。</li>
<li><strong><code>LOG</code></strong>：记录数据包信息到系统日志，然后继续匹配下一条规则。</li>
<li><strong><code>RETURN</code></strong>：停止在当前链中匹配，返回到调用链。</li>
<li><strong><code>JUMP &lt;user-defined-chain&gt;</code></strong>：跳转到用户自定义链，进行更复杂的处理。</li>
</ul>
</li>
</ul>
<h2 id="三、iptables-常用命令"><a href="#三、iptables-常用命令" class="headerlink" title="三、iptables 常用命令"></a>三、iptables 常用命令</h2><p><code>iptables</code> 命令的基本格式： <code>iptables -t &lt;table_name&gt; &lt;command&gt; &lt;chain_name&gt; &lt;match&gt; -j &lt;target&gt;</code></p>
<h3 id="3-1-链管理"><a href="#3-1-链管理" class="headerlink" title="3.1 链管理"></a>3.1 链管理</h3><ul>
<li><strong><code>iptables -L</code></strong>：列出所有规则（默认是 <code>filter</code> 表）。<ul>
<li><code>-t &lt;table_name&gt;</code>：指定表，如 <code>iptables -t nat -L</code>。</li>
<li><code>-n</code>：不进行 IP&#x2F;端口到名称的解析，显示数字形式。</li>
<li><code>-v</code>：显示详细信息，包括数据包和字节计数。</li>
<li><code>--line-numbers</code>：显示规则的行号，方便删除&#x2F;插入。</li>
</ul>
</li>
<li><strong><code>iptables -F</code></strong>：清空所有规则（默认是 <code>filter</code> 表的所有链）。<ul>
<li><code>-t &lt;table_name&gt;</code>：清空指定表的所有规则。</li>
<li><code>&lt;chain_name&gt;</code>：清空指定链的规则，如 <code>iptables -F INPUT</code>。</li>
</ul>
</li>
<li><strong><code>iptables -X</code></strong>：删除用户自定义链。</li>
<li><strong><code>iptables -Z</code></strong>：将所有链的包计数器和字节计数器归零。</li>
<li><strong><code>iptables -P &lt;chain_name&gt; &lt;target&gt;</code></strong>：设置链的默认策略。<ul>
<li>例如：<code>iptables -P INPUT DROP</code> (将 INPUT 链的默认策略设置为 DROP)。</li>
<li><strong>警告</strong>：设置默认策略为 <code>DROP</code> 前请三思，确保你不会把自己锁在系统之外。</li>
</ul>
</li>
</ul>
<h3 id="3-2-规则管理"><a href="#3-2-规则管理" class="headerlink" title="3.2 规则管理"></a>3.2 规则管理</h3><ul>
<li><strong><code>iptables -A &lt;chain_name&gt; &lt;match&gt; -j &lt;target&gt;</code></strong>：添加规则到链的末尾。<ul>
<li>例如：<code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code></li>
</ul>
</li>
<li><strong><code>iptables -D &lt;chain_name&gt; &lt;rule_number|match&gt;</code></strong>：删除规则。<ul>
<li>按行号删除：<code>iptables -D INPUT 5</code> (删除 INPUT 链的第 5 条规则)。</li>
<li>按规则内容删除：<code>iptables -D INPUT -p tcp --dport 22 -j ACCEPT</code>。</li>
</ul>
</li>
<li><strong><code>iptables -I &lt;chain_name&gt; [rule_number] &lt;match&gt; -j &lt;target&gt;</code></strong>：插入规则。<ul>
<li>默认插入到链的开头（第 1 条），也可指定行号。<code>iptables -I INPUT 1 -p tcp --dport 80 -j ACCEPT</code>。</li>
</ul>
</li>
<li><strong><code>iptables -R &lt;chain_name&gt; &lt;rule_number&gt; &lt;match&gt; -j &lt;target&gt;</code></strong>：替换规则。<ul>
<li><code>iptables -R INPUT 5 -p tcp --dport 8080 -j ACCEPT</code> (替换 INPUT 链的第 5 条规则)。</li>
</ul>
</li>
</ul>
<h2 id="四、iptables-进阶应用示例"><a href="#四、iptables-进阶应用示例" class="headerlink" title="四、iptables 进阶应用示例"></a>四、iptables 进阶应用示例</h2><h3 id="4-1-允许-SSH-访问"><a href="#4-1-允许-SSH-访问" class="headerlink" title="4.1 允许 SSH 访问"></a>4.1 允许 SSH 访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许 TCP 协议， 목적端口 22 的流量进入 INPUT 链</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许已建立和相关联的连接通过 (连接跟踪机制，非常重要)</span></span><br><span class="line"><span class="comment"># 这样 SSH 响应流量可以正常返回</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h3 id="4-2-拒绝某个-IP-地址的访问"><a href="#4-2-拒绝某个-IP-地址的访问" class="headerlink" title="4.2 拒绝某个 IP 地址的访问"></a>4.2 拒绝某个 IP 地址的访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拒绝源 IP 为 192.168.1.100 的所有流量进入</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -s 192.168.1.100 -j DROP</span><br><span class="line"><span class="comment"># 或者拒绝到某个特定端口</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -s 192.168.1.100 -p tcp --dport 80 -j REJECT</span><br></pre></td></tr></table></figure>

<h3 id="4-3-端口转发-DNAT"><a href="#4-3-端口转发-DNAT" class="headerlink" title="4.3 端口转发 (DNAT)"></a>4.3 端口转发 (DNAT)</h3><p>将外部访问公网 IP 的 80 端口转发到内部服务器 <code>192.168.1.100</code> 的 80 端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启 IP 转发</span></span><br><span class="line"><span class="built_in">sudo</span> sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"><span class="comment"># DNAT 规则：将发往本路由器公网 IP (假设为 203.0.113.1) 的 80 端口 TCP 流量重定向到内部服务器</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -A PREROUTING -d 203.0.113.1 -p tcp --dport 80 -j DNAT --to-destination 192.168.1.100:80</span><br><span class="line"><span class="comment"># SNAT 规则：确保内部服务器的响应能正确返回到外部客户端</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -A POSTROUTING -s 192.168.1.100 -o eth0 -j MASQUERADE</span><br><span class="line"><span class="comment"># 允许转发（如果 filter 表的 FORWARD 链默认策略是 DROP）</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -i eth0 -o eth1 -p tcp --dport 80 -d 192.168.1.100 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许转发的响应流量</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A FORWARD -i eth1 -o eth0 -p tcp --sport 80 -s 192.168.1.100 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p><em>注：<code>eth0</code> 假设为公网接口，<code>eth1</code> 为内网接口。</em></p>
<h3 id="4-4-限制连接速率"><a href="#4-4-限制连接速率" class="headerlink" title="4.4 限制连接速率"></a>4.4 限制连接速率</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制对 22 端口的 SSH 连接，每分钟最多 5 次新连接</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 5/minute --limit-burst 10 -j ACCEPT</span><br><span class="line"><span class="comment"># 对于超出限制的连接，则拒绝</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -A INPUT -p tcp --dport 22 -j REJECT</span><br></pre></td></tr></table></figure>

<h2 id="五、保存和恢复-iptables-规则"><a href="#五、保存和恢复-iptables-规则" class="headerlink" title="五、保存和恢复 iptables 规则"></a>五、保存和恢复 iptables 规则</h2><p>iptables 规则默认只存在于内存中，系统重启后会丢失。需要保存规则才能持久化。</p>
<ul>
<li><strong>保存规则</strong>：<ul>
<li>Debian&#x2F;Ubuntu: <code>sudo iptables-save &gt; /etc/iptables/rules.v4</code></li>
<li>CentOS&#x2F;RHEL (旧版本): <code>sudo service iptables save</code> 或 <code>sudo /sbin/service iptables save</code> (会保存到 <code>/etc/sysconfig/iptables</code>)</li>
<li>CentOS&#x2F;RHEL (新版本，使用 firewalld 或 nftables): 可能需要禁用 firewalld (不推荐)，或直接使用 <code>iptables-save</code>。</li>
</ul>
</li>
<li><strong>恢复规则</strong>：<ul>
<li><code>sudo iptables-restore &lt; /etc/iptables/rules.v4</code></li>
<li>为了在重启时自动恢复，通常需要配置系统服务或在启动脚本中加入 <code>iptables-restore</code> 命令。</li>
</ul>
</li>
</ul>
<h2 id="六、iptables-的局限性与替代方案"><a href="#六、iptables-的局限性与替代方案" class="headerlink" title="六、iptables 的局限性与替代方案"></a>六、iptables 的局限性与替代方案</h2><p><strong>局限性：</strong></p>
<ul>
<li><strong>语法复杂</strong>：对于新手来说，iptables 的命令行语法可能比较晦涩难懂，容易出错。</li>
<li><strong>状态管理</strong>：所有规则都是线性检查，管理大量复杂规则时效率可能下降。</li>
</ul>
<p><strong>替代方案：</strong></p>
<p>随着 Linux 系统和网络技术的发展，出现了更高级的防火墙管理工具：</p>
<ol>
<li><p><strong><code>firewalld</code></strong>：</p>
<ul>
<li><strong>特点</strong>：动态防火墙管理工具，基于区域 (zones) 的概念。用户只需将接口或源 IP 归属到特定区域，然后为区域配置服务，无需直接操作 iptables 链和规则。支持运行时修改，无需重启服务。</li>
<li><strong>底层</strong>：<code>firewalld</code> 可以使用 <code>iptables</code> 也能够使用 <code>nftables</code> 作为后端。</li>
<li><strong>优势</strong>：更易用，更适合服务管理，避免了直接操作 iptables 的复杂性。</li>
</ul>
</li>
<li><p><strong><code>nftables</code></strong>：</p>
<ul>
<li><strong>特点</strong>：Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在取代 <code>iptables</code>、<code>ip6tables</code>、<code>arptables</code> 和 <code>ebtables</code> 等工具，提供统一的语法和更强大的功能。</li>
<li><strong>优势</strong>：语法更简洁，效率更高，支持原子操作（一次性应用所有规则），并能更好地处理复杂规则集。</li>
<li><strong>趋势</strong>：是未来的发展方向，现代 Linux 发行版逐渐转向 <code>nftables</code>。</li>
</ul>
</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>iptables 是 Linux 系统中一个强大而灵活的防火墙工具，它通过 Netfilter 框架在内核层面实现对网络数据包的精细控制。理解表、链和规则这三个核心概念是掌握 iptables 的关键。通过配置规则，可以实现数据过滤、地址转换、流量控制等多种功能，从而保障系统网络安全和优化网络性能。虽然其命令行语法相对复杂，但在许多 Linux 环境中仍是常用的防火墙解决方案。对于新系统，建议关注 <code>firewalld</code> 或直接学习 <code>nftables</code>，它们提供了更现代、更简洁的管理方式。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/c5054902e8b1/">https://blog.tbf1211.xx.kg/c5054902e8b1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/">防火墙</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/9b793354c088/" title="nftables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">nftables 详解</div></div><div class="info-2"><div class="info-item-1"> nftables 是 Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在逐步取代传统的 iptables (以及 ip6tables, arptables, ebtables) 工具集，提供一个统一的、高效的、更易于管理和扩展的防火墙解决方案。nftables 引入了一套全新的语法和设计理念，旨在解决 iptables 长期存在的一些问题，例如命令复杂性、重复代码以及 IPv4 和 IPv6 规则管理的独立性等。  核心思想：基于表达式的统一规则集，支持原子性更新，并针对 IPv4&#x2F;IPv6&#x2F;桥接等协议提供统一管理。 它的设计哲学是从指令式规则集转向声明式通用虚拟机指令，使得规则处理更高效、更灵活。   一、为什么需要 nftables？iptables 的局限性虽然 iptables 强大且稳定，但它在设计和使用上存在一些固有的局限性，促使 Netfilter 社区开发 nftables：  语法复杂且碎片化：  iptables (用于 IPv4)、ip6tables (用于 IPv6)、arptables (用于 ARP)、ebtab...</div></div></div></a><a class="pagination-related" href="/7601ab41dda6/" title="Go语言并发与并行详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go语言并发与并行详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言（Golang） 被设计为一门天然支持并发的语言，其并发模型是基于 CSP (Communicating Sequential Processes) 理论的实现。Go 语言通过轻量级的 Goroutine (协程) 和原生的 Channel (管道) 机制，极大地简化了并发编程的复杂性，使得开发者能够更容易地编写出高并发、高性能的应用程序。  核心思想：不要通过共享内存来通信；相反，通过通信来共享内存。 这是 Go 并发哲学中的核心原则。   一、并发 (Concurrency) 与并行 (Parallelism)在深入 Go 语言的并发机制之前，理解并发与并行的区别至关重要。 1.1 并发 (Concurrency) 定义：并发是指系统能够同时处理多个任务的能力。这些任务不一定在同一时刻运行，它们可能在单个 CPU 核心上通过时间片轮转的方式快速切换执行，给人一种“同时进行”的错觉。 特性： 处理多个任务：关注如何设计程序来处理事件流，即使只有一个处理器。 任务切换：通过快速切换执行上下文来模拟同时执行。 目的：提高程序的吞吐量和响应速度。   类比：一个厨师可以在...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/9b793354c088/" title="nftables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-28</div><div class="info-item-2">nftables 详解</div></div><div class="info-2"><div class="info-item-1"> nftables 是 Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在逐步取代传统的 iptables (以及 ip6tables, arptables, ebtables) 工具集，提供一个统一的、高效的、更易于管理和扩展的防火墙解决方案。nftables 引入了一套全新的语法和设计理念，旨在解决 iptables 长期存在的一些问题，例如命令复杂性、重复代码以及 IPv4 和 IPv6 规则管理的独立性等。  核心思想：基于表达式的统一规则集，支持原子性更新，并针对 IPv4&#x2F;IPv6&#x2F;桥接等协议提供统一管理。 它的设计哲学是从指令式规则集转向声明式通用虚拟机指令，使得规则处理更高效、更灵活。   一、为什么需要 nftables？iptables 的局限性虽然 iptables 强大且稳定，但它在设计和使用上存在一些固有的局限性，促使 Netfilter 社区开发 nftables：  语法复杂且碎片化：  iptables (用于 IPv4)、ip6tables (用于 IPv6)、arptables (用于 ARP)、ebtab...</div></div></div></a><a class="pagination-related" href="/a92b9122509b/" title="Ubuntu UFW (Uncomplicated Firewall) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-01</div><div class="info-item-2">Ubuntu UFW (Uncomplicated Firewall) 详解</div></div><div class="info-2"><div class="info-item-1"> UFW (Uncomplicated Firewall) 是 Ubuntu Linux 及其衍生发行版中一个简化且易于使用的防火墙配置工具。它作为 iptables 的前端，提供了一个用户友好的命令行界面，让普通用户和系统管理员能够更轻松地管理 Linux 内核的 Netfilter 防火墙规则。UFW 的目标是“不复杂”，即简化防火墙的管理，使其不再令人生畏。  核心思想： UFW 提供了一种高级抽象，将复杂的 iptables 命令封装成少数直观的指令，使得用户无需深入理解 iptables 规则链即可实现基本的防火墙配置。   一、为什么选择 UFW？Linux 系统内置了强大的 Netfilter 框架和 iptables 工具，但 iptables 的语法复杂，规则众多，对于初学者来说学习曲线陡峭。UFW 旨在解决以下问题：  简化防火墙管理：  易于上手：通过简单的命令即可配置常见的防火墙规则，无需掌握复杂的 iptables 语法。 减少错误：简化后的命令减少了因语法错误导致配置失误的风险。   增强系统安全性：  默认拒绝策略：UFW 默认采用“默认拒绝所有传入...</div></div></div></a><a class="pagination-related" href="/296c75615ac4/" title="L4 负载均衡详解 (Layer 4 Load Balancing Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-13</div><div class="info-item-2">L4 负载均衡详解 (Layer 4 Load Balancing Explained)</div></div><div class="info-2"><div class="info-item-1"> L4 负载均衡 (Layer 4 Load Balancing)，也称为传输层负载均衡，是一种在 OSI 模型第四层（传输层）上进行流量分发的负载均衡技术。它主要根据网络数据包的 IP 地址和端口号信息来决定将请求转发到哪个后端服务器，而不解析应用层数据（如 HTTP 头、URL 或 Cookie）。L4 负载均衡器在建立 TCP 连接之初或接收 UDP 数据包时就做出转发决策。  核心思想：基于连接或数据包的源&#x2F;目的 IP 和端口进行快速、高效的流量转发，实现后端服务器的水平扩展和高可用性。   一、为什么需要 L4 负载均衡？在许多高性能和高并发的应用场景中，L4 负载均衡是实现可扩展性和可靠性的基础组件：  高吞吐量和低延迟：由于 L4 负载均衡器不需要解析应用层协议内容，其处理速度非常快，能够处理极高的并发连接和请求，并保持较低的延迟。这对于对性能要求极高的应用至关重要。 协议无关性：L4 负载均衡不限于 HTTP&#x2F;HTTPS 协议，它可以对任何基于 TCP 或 UDP 的协议（如 SSH、FTP、SMTP、DNS、RTP 以及各种私有协议）进行负载...</div></div></div></a><a class="pagination-related" href="/a97c16bf3fd0/" title="奇偶检验详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-14</div><div class="info-item-2">奇偶检验详解</div></div><div class="info-2"><div class="info-item-1"> 奇偶检验 (Parity Check) 是一种最简单、最古老的错误检测方法，用于验证数据在传输或存储过程中是否发生了一位或奇数位的错误。它通过在原始数据的基础上添加一个额外的比特位（称为奇偶校验位）来实现。  核心思想： 通过统计数据位中 ‘1’ 的数量是奇数还是偶数，并添加一个校验位来使其总数符合预设的奇偶性，从而在接收端检测数据是否被意外翻转。   一、奇偶检验的基本原理奇偶检验的基本思想是确保一组二进制位中 ‘1’ 的总数（包括校验位）始终是奇数或偶数。 1.1 两种类型根据要求的奇偶性，奇偶检验分为两种：  奇校验 (Odd Parity Check)：  发送方统计数据位中 ‘1’ 的个数。 如果 ‘1’ 的个数为偶数，则奇偶校验位设置为 ‘1’，使包括校验位在内的所有位中 ‘1’ 的总数为奇数。 如果 ‘1’ 的个数为奇数，则奇偶校验位设置为 ‘0’，使包括校验位在内的所有位中 ‘1’ 的总数仍为奇数。 目标：传输的整个数据串（数据位 + 校验位）中 ‘1’ 的个数为奇数。   偶校验 (Even Parity Check)：  发送方统计数据位中 ‘1’ 的个数。...</div></div></div></a><a class="pagination-related" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-15</div><div class="info-item-2">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</div></div><div class="info-2"><div class="info-item-1"> L7 负载均衡 (Layer 7 Load Balancing)，也被称为应用层负载均衡，是基于 OSI 模型第七层（应用层）信息（如 HTTP&#x2F;HTTPS 请求的 URL、URI、Header、Cookie 或请求方法）来智能分发客户端请求的一种负载均衡技术。与仅基于 IP 地址和端口进行分发的 L4 负载均衡不同，L7 负载均衡能够对应用层数据包的内容进行深度检查和解析，从而实现更精细、更智能的流量分发策略。  核心思想：理解应用层请求的“意图”，并根据这些意图将请求路由到最合适的后端服务器或服务。 它能够对流量进行更深入的控制和优化。   一、为什么需要 L7 负载均衡？随着现代应用程序架构（如微服务、API 网关、无服务器）的日益复杂，以及对性能、安全性和可伸缩性需求的提升，L4 负载均衡的局限性逐渐显现。L7 负载均衡应运而生，主要解决了以下问题：  更细粒度的路由 (Fine-grained Routing)：L4 负载均衡只能基于 IP 和端口分发，无法区分同一端口上的不同应用或 API。L7 能够根据 URL 路径 (/api/users 到用户服务，...</div></div></div></a><a class="pagination-related" href="/84980af09d70/" title="HTTP URL 与 IP:端口 的区别详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-25</div><div class="info-item-2">HTTP URL 与 IP:端口 的区别详解</div></div><div class="info-2"><div class="info-item-1"> 虽然 http://127.0.0.1:1080 和 127.0.0.1:1080 都指向本地机器上的 1080 端口，但它们在含义、使用上下文和系统处理方式上存在根本区别。前者是一个完整的 URL (Uniform Resource Locator)，明确指定了协议 (Protocol)；而后者仅仅是一个 地址:端口 组合，通常用于网络服务的监听或内部配置，本身不包含协议信息。  核心思想：协议 (http://) 定义了客户端与服务端通信的方式和规则，而 IP:端口 仅仅标识了一个网络端点。在不同上下文中，对 IP:端口 的处理方式会有所不同，例如浏览器会自动补全协议，而网络编程接口通常只接收 IP:端口 来监听。   一、核心概念定义在深入探讨两者区别之前，我们先定义几个关键概念： 1.1 IP 地址 (Internet Protocol Address)定义：一个分配给网络上设备的数字标签，用于在计算机网络中标识和定位设备。127.0.0.1 是一个特殊的 IP 地址，称为回环地址 (Loopback Address) 或 本地主机 (localhost)，它总是指向当...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">448</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Netfilter-%E6%A1%86%E6%9E%B6%E4%B8%8E-iptables-%E5%85%B3%E7%B3%BB"><span class="toc-text">一、Netfilter 框架与 iptables 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81iptables-%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E8%A1%A8-Tables-%E3%80%81%E9%93%BE-Chains-%E3%80%81%E8%A7%84%E5%88%99-Rules"><span class="toc-text">二、iptables 的三个基本概念：表 (Tables)、链 (Chains)、规则 (Rules)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A1%A8-Tables"><span class="toc-text">2.1 表 (Tables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%93%BE-Chains"><span class="toc-text">2.2 链 (Chains)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%A7%84%E5%88%99-Rules"><span class="toc-text">2.3 规则 (Rules)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81iptables-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">三、iptables 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%93%BE%E7%AE%A1%E7%90%86"><span class="toc-text">3.1 链管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86"><span class="toc-text">3.2 规则管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81iptables-%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">四、iptables 进阶应用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%85%81%E8%AE%B8-SSH-%E8%AE%BF%E9%97%AE"><span class="toc-text">4.1 允许 SSH 访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%8B%92%E7%BB%9D%E6%9F%90%E4%B8%AA-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">4.2 拒绝某个 IP 地址的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91-DNAT"><span class="toc-text">4.3 端口转发 (DNAT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%99%90%E5%88%B6%E8%BF%9E%E6%8E%A5%E9%80%9F%E7%8E%87"><span class="toc-text">4.4 限制连接速率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D-iptables-%E8%A7%84%E5%88%99"><span class="toc-text">五、保存和恢复 iptables 规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81iptables-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-text">六、iptables 的局限性与替代方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-12.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>