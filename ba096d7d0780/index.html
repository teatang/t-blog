<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>虚拟局域网 (VLAN) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虚拟局域网 (VLAN - Virtual Local Area Network) 是一种在物理上共享同一网络基础设施（如交换机、网线）的局域网中，通过逻辑划分而不是物理划分来创建多个独立广播域的技术。它允许网络管理员将一个物理局域网划分成多个逻辑上独立的网络，每个 VLAN 都是一个独立的广播域。VLAN 技术是现代企业网络设计中不可或缺的组成部分，它极大地增强了网络的安全性、性能、灵活性和可">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟局域网 (VLAN) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/ba096d7d0780/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="虚拟局域网 (VLAN - Virtual Local Area Network) 是一种在物理上共享同一网络基础设施（如交换机、网线）的局域网中，通过逻辑划分而不是物理划分来创建多个独立广播域的技术。它允许网络管理员将一个物理局域网划分成多个逻辑上独立的网络，每个 VLAN 都是一个独立的广播域。VLAN 技术是现代企业网络设计中不可或缺的组成部分，它极大地增强了网络的安全性、性能、灵活性和可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg">
<meta property="article:published_time" content="2024-01-05T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-26T03:25:52.144Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "虚拟局域网 (VLAN) 详解",
  "url": "https://blog.tbf1211.xx.kg/ba096d7d0780/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg",
  "datePublished": "2024-01-05T22:24:00.000Z",
  "dateModified": "2026-02-26T03:25:52.144Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/ba096d7d0780/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '虚拟局域网 (VLAN) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">557</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">虚拟局域网 (VLAN) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">虚拟局域网 (VLAN) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-01-05T22:24:00.000Z" title="发表于 2024-01-06 06:24:00">2024-01-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>虚拟局域网 (VLAN - Virtual Local Area Network)</strong> 是一种在物理上共享同一网络基础设施（如交换机、网线）的局域网中，通过<strong>逻辑划分</strong>而不是物理划分来创建多个独立广播域的技术。它允许网络管理员将一个物理局域网划分成多个逻辑上独立的网络，每个 VLAN 都是一个独立的广播域。VLAN 技术是现代企业网络设计中不可或缺的组成部分，它极大地增强了网络的<strong>安全性、性能、灵活性和可管理性</strong>。</p>
</blockquote>
<div class="note info flat"><p>核心思想：在不改变物理连接的情况下，将一个物理交换机划分出多个逻辑隔离的广播域，实现设备间的逻辑分段通信。</p>
</div>
<hr>
<h2 id="一、什么是-VLAN？"><a href="#一、什么是-VLAN？" class="headerlink" title="一、什么是 VLAN？"></a>一、什么是 VLAN？</h2><p>在传统的以太网中，所有连接到同一个交换机或集线器的设备都属于同一个<strong>广播域 (Broadcast Domain)</strong>。这意味着当任何一台设备发送一个广播帧（例如 ARP 请求），这个广播帧会到达该域内的所有其他设备。随着网络规模的扩大，广播流量会显著增加，导致网络性能下降并带来安全隐患。</p>
<p>VLAN 技术应运而生，它通过在数据链路层（OSI 模型第二层）对以太网帧进行标识和处理，从而实现：</p>
<ol>
<li><strong>逻辑隔离</strong>：即使设备物理上连接在同一台交换机上，如果它们属于不同的 VLAN，它们也无法直接通过二层通信。</li>
<li><strong>创建多个广播域</strong>：每个 VLAN 都是一个独立的广播域。广播流量被限制在所属的 VLAN 内部，不会扩散到其他 VLAN。</li>
</ol>
<p>简单来说，VLAN 就像在一个大的开放办公室里，用虚拟的墙壁隔出了多个独立的部门。虽然大家在同一个屋檐下，但不同部门的人员不能直接交流（除非通过外部的路由）。</p>
<h2 id="二、为什么需要-VLAN？"><a href="#二、为什么需要-VLAN？" class="headerlink" title="二、为什么需要 VLAN？"></a>二、为什么需要 VLAN？</h2><p>在现代网络环境中，VLAN 带来了多方面的重要优势：</p>
<ol>
<li><strong>提高网络安全性 (Security)</strong>：<ul>
<li>将敏感数据或服务器隔离到独立的 VLAN 中，即使网络中的其他部分受到攻击，这些敏感资源也能得到保护。</li>
<li>防止未经授权的用户访问特定网络资源。</li>
<li>将不同部门（例如财务部、研发部、访客网络）的用户物理隔离，即使他们连接在同一台交换机上。</li>
</ul>
</li>
<li><strong>优化网络性能 (Performance)</strong>：<ul>
<li>缩小广播域，减少广播流量（如 ARP 请求、DHCP 发现），从而降低 CPU 负载和网络拥堵。</li>
<li>提高网络设备的 VLAN 间转发效率。</li>
</ul>
</li>
<li><strong>增强网络管理和灵活性 (Management &amp; Flexibility)</strong>：<ul>
<li>便于移动、添加和更改网络设备。用户可以物理上连接在网络的任何端口，只要其端口被配置为正确的 VLAN，就能访问所需资源，而无需重新布线。</li>
<li>逻辑地组织网络资源，例如将所有服务器放入一个 VLAN，所有工作站放入另一个 VLAN。</li>
<li>简化网络故障排除。</li>
</ul>
</li>
<li><strong>节约成本 (Cost-Effectiveness)</strong>：<ul>
<li>通过逻辑划分，减少了购买额外物理交换机的需求，充分利用现有网络硬件。</li>
<li>简化布线。</li>
</ul>
</li>
</ol>
<h2 id="三、VLAN-的工作原理"><a href="#三、VLAN-的工作原理" class="headerlink" title="三、VLAN 的工作原理"></a>三、VLAN 的工作原理</h2><p>VLAN 的核心工作机制是基于 <strong>IEEE 802.1Q 标准</strong>的<strong>帧标记 (Frame Tagging)</strong>。</p>
<ol>
<li><strong>VLAN 标识 (VLAN ID)</strong>：每个 VLAN 都有一个唯一的标识符，称为 VLAN ID (VID)，取值范围通常为 1-4094。</li>
<li><strong>交换机识别</strong>：支持 VLAN 的交换机在收到以太网帧时，会根据帧的流向和端口的配置，判断帧所属的 VLAN。</li>
<li><strong>帧处理</strong>：<ul>
<li><strong>入站帧 (Ingress Frame)</strong>：当一个以太网帧进入交换机端口时，交换机会根据该端口所属的 VLAN ID，在帧头中插入一个 802.1Q 标签（如果该帧需要跨多个 VLAN 传输或前往其他 VLAN 感知设备）。</li>
<li><strong>出站帧 (Egress Frame)</strong>：当一个以太网帧从交换机端口发出时，交换机会检查端口类型。如果是连接到终端设备的接入端口，在发出前会移除 VLAN 标签，确保终端设备接收到标准的以太网帧；如果是连接到其他交换机或路由器的干道端口，帧会带着 VLAN 标签发出。</li>
</ul>
</li>
<li><strong>转发决策</strong>：交换机内部根据 VLAN ID 和 MAC 地址表来进行二层转发决策。来自 VLAN A 的帧只会被转发到 VLAN A 内部的端口，而不会转发到 VLAN B 的端口，除非通过三层路由设备。</li>
</ol>
<h2 id="四、VLAN-标记-VLAN-Tagging-IEEE-802-1Q"><a href="#四、VLAN-标记-VLAN-Tagging-IEEE-802-1Q" class="headerlink" title="四、VLAN 标记 (VLAN Tagging) - IEEE 802.1Q"></a>四、VLAN 标记 (VLAN Tagging) - IEEE 802.1Q</h2><p>IEEE 802.1Q 是目前最广泛采用的 VLAN 标记标准。它在标准的以太网帧头中插入了一个 4 字节的标签 (Tag)。</p>
<h3 id="802-1Q-标签结构"><a href="#802-1Q-标签结构" class="headerlink" title="802.1Q 标签结构"></a>802.1Q 标签结构</h3><p>原始以太网帧：<br><code>目的MAC | 源MAC | 类型/长度 | 数据 | FCS</code></p>
<p>带有 802.1Q 标签的以太网帧：<br><code>目的MAC | 源MAC | TPID | TCI | 类型/长度 | 数据 | FCS</code></p>
<p>其中：</p>
<ul>
<li><strong>TPID (Tag Protocol Identifier - 2 字节)</strong>：通常固定为 <code>0x8100</code>，表示这是一个 802.1Q 标记帧。</li>
<li><strong>TCI (Tag Control Information - 2 字节)</strong>：<ul>
<li><strong>Priority (3 bits)</strong>：也称作 PCP (Priority Code Point)，用于 QoS (服务质量) 优先级，0-7，最高优先权为 7。</li>
<li><strong>DEI (Drop Eligible Indicator - 1 bit)</strong>：当网络拥塞时，路由器可以选择性丢弃带有 DEI &#x3D; 1 的帧。</li>
<li><strong>VLAN ID (VID - 12 bits)</strong>：这是最重要的部分，表示帧所属的 VLAN 编号。可表示 2^12 &#x3D; 4096 个 VLAN (0 和 4095 通常保留，所以实际可用 1-4094)。</li>
</ul>
</li>
</ul>
<h2 id="五、VLAN-端口模式"><a href="#五、VLAN-端口模式" class="headerlink" title="五、VLAN 端口模式"></a>五、VLAN 端口模式</h2><p>交换机端口（接口）根据其在 VLAN 环境中的角色，可以配置为不同的模式。</p>
<h3 id="5-1-Access-Port-接入端口-Access-Mode"><a href="#5-1-Access-Port-接入端口-Access-Mode" class="headerlink" title="5.1 Access Port (接入端口 &#x2F; Access Mode)"></a>5.1 Access Port (接入端口 &#x2F; Access Mode)</h3><ul>
<li><strong>特点</strong>：<ul>
<li>属于且<strong>只能属于一个 VLAN</strong>。</li>
<li>连接<strong>终端设备</strong>，如 PC、服务器、打印机、IP 电话等。</li>
<li>不发送&#x2F;接收带 VLAN 标签的帧。当数据进入端口时，交换机为其添加所属 VLAN 的标签；当数据离开端口时，交换机去除标签。终端设备对此过程<strong>无感知</strong>。</li>
</ul>
</li>
<li><strong>用途</strong>：隔离终端用户流量。</li>
</ul>
<h3 id="5-2-Trunk-Port-干道端口-Trunk-Mode"><a href="#5-2-Trunk-Port-干道端口-Trunk-Mode" class="headerlink" title="5.2 Trunk Port (干道端口 &#x2F; Trunk Mode)"></a>5.2 Trunk Port (干道端口 &#x2F; Trunk Mode)</h3><ul>
<li><strong>特点</strong>：<ul>
<li>用于<strong>承载多个 VLAN 的流量</strong>。</li>
<li>连接<strong>交换机与交换机</strong>之间，或<strong>交换机与路由器&#x2F;防火墙</strong>之间。</li>
<li>发送和接收<strong>带 VLAN 标签的帧</strong>。</li>
<li><strong>Native VLAN (本征 VLAN)</strong>：干道端口可以配置一个“本征 VLAN”。属于本征 VLAN 的流量在干道上传输时<strong>不带标签</strong>。这意味着，如果干道端口接收到一个不带标签的帧，它会将其视为来自本征 VLAN 的流量。两端干道端口的本征 VLAN 必须匹配，否则可能导致通信问题或安全漏洞。</li>
</ul>
</li>
<li><strong>用途</strong>：实现 VLAN 流量在不同网络设备间的透明传输。</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph Network A
        A1(PC_VLAN10) --- Access_VLAN10[Access Port VLAN 10]
        A2(PC_VLAN20) --- Access_VLAN20[Access Port VLAN 20]
        Switch_A[Layer 2 Switch A]
        Access_VLAN10 --&gt; Switch_A
        Access_VLAN20 --&gt; Switch_A
    end

    subgraph Network B
        B1(PC_VLAN10) --- Access_VLAN10_B[Access Port VLAN 10]
        B2(PC_VLAN20) --- Access_VLAN20_B[Access Port VLAN 20]
        Switch_B[Layer 2 Switch B]
        Access_VLAN10_B --&gt; Switch_B
        Access_VLAN20_B --&gt; Switch_B
    end

    Switch_A --- Trunk_Port_A[&quot;Trunk Port (VLAN 10,20 tagged)&quot;]
    Switch_B --- Trunk_Port_B[&quot;Trunk Port (VLAN 10,20 tagged)&quot;]

    Trunk_Port_A -- 802.1Q Tagged Frames --&gt; Trunk_Port_B

    style A1 fill:#D4EDDA,stroke-width:2px,stroke:#28A745;
    style A2 fill:#F8D7DA,stroke-width:2px,stroke:#DC3545;
    style B1 fill:#D4EDDA,stroke-width:2px,stroke:#28A745;
    style B2 fill:#F8D7DA,stroke-width:2px,stroke:#DC3545;
    style Access_VLAN10 stroke-dasharray: 5 5;
    style Access_VLAN20 stroke-dasharray: 5 5;
    style Access_VLAN10_B stroke-dasharray: 5 5;
    style Access_VLAN20_B stroke-dasharray: 5 5;
    style Trunk_Port_A stroke-dasharray: 5 5;
    style Trunk_Port_B stroke-dasharray: 5 5;
    style Switch_A fill:#F9E79F,stroke:#F1C40F,stroke-width:2px;
    style Switch_B fill:#F9E79F,stroke:#F1C40F,stroke-width:2px;
  </pre></div>

<h2 id="六、VLAN-间路由-Inter-VLAN-Routing"><a href="#六、VLAN-间路由-Inter-VLAN-Routing" class="headerlink" title="六、VLAN 间路由 (Inter-VLAN Routing)"></a>六、VLAN 间路由 (Inter-VLAN Routing)</h2><p>由于每个 VLAN 都是一个独立的广播域，不同 VLAN 之间的设备不能直接进行二层通信。如果需要实现不同 VLAN 之间的通信，就必须通过**三层设备（路由器或三层交换机）**进行路由。这个过程称为 <strong>VLAN 间路由</strong>。</p>
<h3 id="6-1-Router-on-a-Stick-ROAS"><a href="#6-1-Router-on-a-Stick-ROAS" class="headerlink" title="6.1 Router-on-a-Stick (ROAS)"></a>6.1 Router-on-a-Stick (ROAS)</h3><ul>
<li><strong>原理</strong>：利用路由器的<strong>一个物理接口</strong>，通过配置<strong>多个逻辑子接口</strong> (Sub-interfaces)，每个子接口配置不同的 IP 地址和 VLAN 封装信息 (802.1Q dot1Q)。</li>
<li><strong>工作机制</strong>：交换机的干道端口连接到路由器的物理接口。当一个 VLAN 的流量需要到达另一个 VLAN 时，流量会通过干道发送到路由器。路由器解封装帧，进行路由查找，然后重新封装到目标 VLAN 的帧中（添加对应 VLAN ID 的标签），再通过同一个物理接口发送回交换机。</li>
<li><strong>优点</strong>：成本低，只需要一个路由器接口。</li>
<li><strong>缺点</strong>：单个物理接口可能成为<strong>性能瓶颈 (单臂路由)</strong>。</li>
</ul>
<h3 id="6-2-Layer-3-Switch-三层交换机"><a href="#6-2-Layer-3-Switch-三层交换机" class="headerlink" title="6.2 Layer 3 Switch (三层交换机)"></a>6.2 Layer 3 Switch (三层交换机)</h3><ul>
<li><strong>原理</strong>：三层交换机集成了二层交换和三层路由功能。它可以在内部直接进行 VLAN 间路由，而无需将流量发送到外部路由器。</li>
<li><strong>工作机制</strong>：为每个 VLAN 创建一个 <strong>SVI (Switch Virtual Interface - 虚拟交换接口)</strong>，并为其分配 IP 地址。三层交换机可以直接根据目的 IP 地址在内部进行路由查找和数据包转发。</li>
<li><strong>优点</strong>：路由速度快，大容量，低延迟，因为路由是在硬件中完成的。</li>
<li><strong>缺点</strong>：成本相对较高。</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    User_VLAN10(PC VLAN 10) --- Access10[Access Port VLAN 10]
    User_VLAN20(PC VLAN 20) --- Access20[Access Port VLAN 20]
    User_VLAN30(PC VLAN 30) --- Access30[Access Port VLAN 30]

    Access10 --&gt; L2Switch[Layer 2 交换机]
    Access20 --&gt; L2Switch
    Access30 --&gt; L2Switch

    L2Switch --- Trunk[&quot;Trunk Port (连接路由器)&quot;]
    Trunk --- RouterPhysical[路由器物理接口]

    subgraph Router
        RouterPhysical --&gt; RouterSub10[子接口 GigabitEthernet0&#x2F;0.10, VLAN 10 SVI]
        RouterPhysical --&gt; RouterSub20[子接口 GigabitEthernet0&#x2F;0.20, VLAN 20 SVI]
        RouterPhysical --&gt; RouterSub30[子接口 GigabitEthernet0&#x2F;0.30, VLAN 30 SVI]
        RouterSub10 --- RouterL3[路由器处理路由]
        RouterSub20 --- RouterL3
        RouterSub30 --- RouterL3
    end

    RouterPhysical -- 802.1Q Tagged Frames --&gt; Trunk
  </pre></div>

<h2 id="七、配置示例-Cisco-IOS-CLI"><a href="#七、配置示例-Cisco-IOS-CLI" class="headerlink" title="七、配置示例 (Cisco IOS CLI)"></a>七、配置示例 (Cisco IOS CLI)</h2><p>以下是一些基于 Cisco IOS 命令行的典型 VLAN 配置示例。</p>
<h3 id="7-1-交换机-VLAN-配置"><a href="#7-1-交换机-VLAN-配置" class="headerlink" title="7.1 交换机 VLAN 配置"></a>7.1 交换机 VLAN 配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 创建 VLAN 并命名</span><br><span class="line">Switch&gt;enable</span><br><span class="line">Switch#configure terminal</span><br><span class="line">Switch(config)#vlan 10</span><br><span class="line">Switch(config-vlan)#name Sales_Dept</span><br><span class="line">Switch(config-vlan)#exit</span><br><span class="line">Switch(config)#vlan 20</span><br><span class="line">Switch(config-vlan)#name IT_Dept</span><br><span class="line">Switch(config-vlan)#exit</span><br><span class="line"></span><br><span class="line">// 配置 Access 端口</span><br><span class="line">Switch(config)#interface FastEthernet0/1 // 或 GigabitEthernet0/1</span><br><span class="line">Switch(config-if)#switchport mode access</span><br><span class="line">Switch(config-if)#switchport access vlan 10 // 将此端口分配给 VLAN 10</span><br><span class="line">Switch(config-if)#exit</span><br><span class="line"></span><br><span class="line">Switch(config)#interface FastEthernet0/2</span><br><span class="line">Switch(config-if)#switchport mode access</span><br><span class="line">Switch(config-if)#switchport access vlan 20 // 将此端口分配给 VLAN 20</span><br><span class="line">Switch(config-if)#exit</span><br><span class="line"></span><br><span class="line">// 配置 Trunk 端口</span><br><span class="line">// Trunke 端口通常用于连接另一个交换机或路由器</span><br><span class="line">Switch(config)#interface GigabitEthernet0/1 // 连接路由器的端口</span><br><span class="line">Switch(config-if)#switchport mode trunk</span><br><span class="line">Switch(config-if)#switchport trunk encapsulation dot1q // 多数现代交换机默认此封装，但明确指定更好</span><br><span class="line">Switch(config-if)#switchport trunk allowed vlan 10,20 // 允许 VLAN 10 和 20 的流量通过此干道</span><br><span class="line">Switch(config-if)#switchport trunk native vlan 99 // (可选) 配置本征 VLAN，不带标签的流量属于 VLAN 99</span><br><span class="line">Switch(config-if)#exit</span><br><span class="line"></span><br><span class="line">// 查看 VLAN 配置</span><br><span class="line">Switch#show vlan brief</span><br><span class="line">Switch#show interfaces trunk</span><br><span class="line">Switch#show running-config interface FastEthernet0/1</span><br></pre></td></tr></table></figure>

<h3 id="7-2-路由器间-VLAN-路由-Router-on-a-Stick"><a href="#7-2-路由器间-VLAN-路由-Router-on-a-Stick" class="headerlink" title="7.2 路由器间 VLAN 路由 (Router-on-a-Stick)"></a>7.2 路由器间 VLAN 路由 (Router-on-a-Stick)</h3><p>假设路由器接口是 <code>GigabitEthernet0/0</code>，连接到交换机的 Trunk 端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 路由器配置</span><br><span class="line">Router&gt;enable</span><br><span class="line">Router#configure terminal</span><br><span class="line"></span><br><span class="line">// 配置物理接口为 no shutdown，不分配 IP 地址</span><br><span class="line">Router(config)#interface GigabitEthernet0/0</span><br><span class="line">Router(config-if)#no ip address</span><br><span class="line">Router(config-if)#no shutdown</span><br><span class="line">Router(config-if)#exit</span><br><span class="line"></span><br><span class="line">// 配置 VLAN 10 的子接口</span><br><span class="line">Router(config)#interface GigabitEthernet0/0.10</span><br><span class="line">Router(config-subif)#encapsulation dot1Q 10 // 指定此子接口处理 VLAN ID 为 10 的流量</span><br><span class="line">Router(config-subif)#ip address 192.168.10.1 255.255.255.0 // 为 VLAN 10 设置网关 IP</span><br><span class="line">Router(config-subif)#exit</span><br><span class="line"></span><br><span class="line">// 配置 VLAN 20 的子接口</span><br><span class="line">Router(config)#interface GigabitEthernet0/0.20</span><br><span class="line">Router(config-subif)#encapsulation dot1Q 20 // 指定此子接口处理 VLAN ID 为 20 的流量</span><br><span class="line">Router(config-subif)#ip address 192.168.20.1 255.255.255.0 // 为 VLAN 20 设置网关 IP</span><br><span class="line">Router(config-subif)#exit</span><br><span class="line"></span><br><span class="line">// 查看路由器接口状态</span><br><span class="line">Router#show ip interface brief</span><br><span class="line">Router#show running-config interface GigabitEthernet0/0</span><br></pre></td></tr></table></figure>

<h2 id="八、VLAN-的优缺点"><a href="#八、VLAN-的优缺点" class="headerlink" title="八、VLAN 的优缺点"></a>八、VLAN 的优缺点</h2><h3 id="8-1-优点："><a href="#8-1-优点：" class="headerlink" title="8.1 优点："></a>8.1 优点：</h3><ol>
<li><strong>增强了网络安全性</strong>：通过逻辑隔离，限制了攻击范围。</li>
<li><strong>提高了网络性能</strong>：缩小广播域，减少广播风暴。</li>
<li><strong>简化了网络管理</strong>：逻辑分区使得网络重构和故障排除更容易。</li>
<li><strong>节约了网络硬件成本</strong>：提高了物理交换机端口的利用率。</li>
<li><strong>增强了灵活性</strong>：用户和设备可以独立于物理位置进行组织。</li>
</ol>
<h3 id="8-2-缺点与挑战："><a href="#8-2-缺点与挑战：" class="headerlink" title="8.2 缺点与挑战："></a>8.2 缺点与挑战：</h3><ol>
<li><strong>增加了配置复杂性</strong>：需要正确配置交换机端口和 VLAN 路由，任何错误都可能导致通信故障。</li>
<li><strong>“VLAN Hopping”等安全风险</strong>：如果配置不当（例如不安全的本征 VLAN 默认设置），攻击者可能利用 VLAN 跳跃技术从一个 VLAN 渗透到另一个 VLAN。</li>
<li><strong>单点故障</strong>：Router-on-a-Stick 模式下，物理接口或路由器是瓶颈，一旦故障，多个 VLAN 间的通信会中断。</li>
<li><strong>广播域仍有</strong>：虽然缩小了广播域，但 VLAN 内部仍然存在广播，广播仍需控制。</li>
<li><strong>设计挑战</strong>：大型网络的 VLAN 规划需要深思熟虑，包括 VLAN ID 分配、IP 地址规划、端口分配等。</li>
</ol>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>VLAN 技术是现代企业网络设计中的基石，它通过逻辑划分实现网络的隔离和优化，有效解决了传统物理局域网在安全性、性能和管理上的固有挑战。通过理解 VLAN 的工作原理、802.1Q 标记标准以及访问端口和干道端口的区别，网络管理员可以有效地设计和实现一个高性能、高安全性和易于管理的网络环境。随着云计算和虚拟化技术的普及，VLAN 的概念和应用也在不断演进，成为实现更高级网络分段（如微服务网络、SDN）的基础。合理规划和部署 VLAN，是构建健壮和高效网络架构的关键一步。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/ba096d7d0780/">https://blog.tbf1211.xx.kg/ba096d7d0780/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f35a31a1b5c1/" title="PHP 各个版本新特性详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">PHP 各个版本新特性详解</div></div><div class="info-2"><div class="info-item-1"> PHP 作为最流行的后端脚本语言之一，自诞生以来便不断演进。从早期的松散特性到现代的强类型、高性能，每一次版本迭代都带来了显著的改进。本文将详细回顾 PHP 7.0 以后，各个主要版本（7.x 和 8.x 系列）引入的新特性、性能提升和废弃功能，帮助开发者理解 PHP 的发展轨迹并更好地进行技术选型和代码迁移。  核心思想：PHP 的演进主线是：提高性能、增强类型系统、简化语法、引入现代编程范式和清理历史遗留问题。   一、PHP 7.0 (2015年) - 性能飞跃的起点PHP 7.0 是一个里程碑式的版本，其最大的亮点是引入了全新的 Zend Engine (Zend Engine 3.0，代号 PHPNG)，带来了惊人的性能提升。 1.1 核心特性与性能提升 Zend Engine 3.0 (PHPNG)：这是 7.0 最大的亮点。与 PHP 5.6 相比，PHP 7.0 在实际应用中实现了 2 倍甚至更高的性能提升，大幅降低了内存消耗。这是通过重写 Zend Engine 的核心，优化了数据结构、Opcodes 处理和垃圾回收机制实现的。 抽象语法树 (Abstract...</div></div></div></a><a class="pagination-related" href="/d21d64d7af3a/" title="RDMA (Remote Direct Memory Access) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RDMA (Remote Direct Memory Access) 详解</div></div><div class="info-2"><div class="info-item-1"> RDMA (Remote Direct Memory Access) 是一种高性能网络通信技术，允许一台计算机（源端）的网卡（Network Interface Card, NIC）直接访问另一台远程计算机（目的端）的内存，而无需目的端操作系统的 CPU 介入。这种“零拷贝” (Zero-copy) 和“内核旁路” (Kernel-bypass) 的特性极大地减少了数据传输的延迟、提高了吞吐量，并显著降低了 CPU 占用率，是现代高性能计算 (HPC)、人工智能&#x2F;机器学习 (AI&#x2F;ML)、分布式存储和金融交易等领域中不可或缺的技术。  核心思想：RDMA 的核心是绕过操作系统内核的网络协议栈，实现远程内存的直接读写。它将数据在源端和目的端之间传输的任务从 CPU 卸载到专用的网络硬件（RDMA 网卡，如 HCA），从而实现了超低延迟、极高吞吐量和极低的 CPU 占用率。   一、传统网络通信的痛点在理解 RDMA 的优势之前，我们先回顾一下传统 TCP&#x2F;IP 网络通信的数据路径，以及它所面临的挑战：  数据拷贝开销 (Data Copy Overh...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/62ea6394243a/" title="RPC(Remote Procedure Call)远程过程调用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">RPC(Remote Procedure Call)远程过程调用详解</div></div><div class="info-2"><div class="info-item-1"> RPC (Remote Procedure Call)，即远程过程调用，是一种分布式计算技术，它允许程序调用位于不同地址空间（通常是不同计算机上）的子程序或函数，就像调用本地子程序一样。RPC 屏蔽了底层网络通信的复杂性，让开发者可以专注于业务逻辑，提高开发效率。  核心思想： RPC 的目标是透明化 (Transparency) 远程服务的调用过程，让客户端感觉就像在调用本地方法，而实际上调用的请求被序列化并通过网络传输到远程服务，远程服务执行后将结果序列化并返回给客户端。   一、为什么需要 RPC？在传统的单体应用中，所有功能都运行在同一个进程中，方法调用直接发生在内存中。然而，随着业务复杂性和系统规模的增长，单体应用面临诸多挑战：  扩展性差：难以针对不同模块的负载压力独立扩展。 开发效率低：团队协作困难，代码冲突多。 容错性差：单个模块故障可能导致整个系统崩溃。 技术栈限制：难以在不同模块中使用最佳技术栈。  为了解决这些问题，系统架构逐渐向分布式系统和微服务架构演进。在这种架构中，一个大型应用被拆分成多个独立的服务，每个服务运行在不同的进程中，甚至不同的物理机器上。...</div></div></div></a><a class="pagination-related" href="/56d360e5bda1/" title="SNAT 与 DNAT 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">SNAT 与 DNAT 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：源网络地址转换 (SNAT - Source Network Address Translation) 和 目的网络地址转换 (DNAT - Destination Network Address Translation)。理解这两种机制对于网络设计、故障排查和安全性至关重要。  核心思想：  SNAT：解决“内部网络中主机如何安全地、共享地访问外部网络资源”的问题，修改出站数据包的源地址。 DNAT：解决“外部网络中主机如何安全地访问内部提供的服务”的问题，修改入站数据包的目的地址。     一、网络地址转换 (NAT) 概述NAT 技术最初是为了缓解 IPv4 地址枯竭问题而设计，它允许一个内部私有 IP 网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信。除了地址共享，NAT 也为内部网络提供了一层基本的安全隔...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a><a class="pagination-related" href="/6b3b0892e720/" title="IPv4 (Internet Protocol version 4) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-16</div><div class="info-item-2">IPv4 (Internet Protocol version 4) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv4 (Internet Protocol version 4) 是互联网协议家族（TCP&#x2F;IP 协议族）中最核心的协议之一，也是当前互联网上使用最广泛的协议。它位于 OSI 模型的网络层（第三层），负责在复杂的互联网中数据包的寻址和路由。IPv4 定义了数据包的格式以及在网络中传输和转发的机制，使得不同网络中的设备能够相互通信。尽管其地址耗尽问题催生了 IPv6，但 IPv4 仍是支撑全球互联网运行的基石。  核心思想：在互联网这个异构网络中，为每个连接的设备提供一个唯一的逻辑地址，并设计一种数据包转发机制，确保数据能从源头准确无误地传输到目的地。   一、什么是 IPv4？IPv4 是互联网协议的第四个版本。它是一种无连接的协议，意味着每个数据包都独立发送，不保证顺序或可靠性（这些由上层协议如 TCP 负责）。IPv4 的主要职责包括：  寻址 (Addressing)：为网络上的每个设备分配一个唯一的 32 位数字地址（IP 地址），用于标识设备。 路由 (Routing)：根据数据包的目的 IP 地址，决定数据包在网络中传输的最佳路径，并将其转发到下一个路...</div></div></div></a><a class="pagination-related" href="/f7642a181610/" title="CDN (内容分发网络) 服务详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">CDN (内容分发网络) 服务详解</div></div><div class="info-2"><div class="info-item-1"> CDN (Content Delivery Network)，即内容分发网络，是一种构建在现有网络基础之上的智能虚拟网络。它通过将站点内容发布到离用户最近的全球边缘节点，使用户在请求内容时，能够从距离自己最近的服务器获取数据，从而显著加速内容传输、减轻源站负载、提高用户体验和保障服务可用性。  核心思想：将内容缓存到离用户近的地方，让用户就近获取，缩短物理距离，从而缩短加载时间。   一、为什么需要 CDN？在没有 CDN 的情况下，用户访问网站的所有请求都会直接发送到源服务器。这存在几个问题：  访问速度慢：当用户与源服务器之间地理距离较远时，数据传输路径长，网络延迟高，导致页面加载缓慢，尤其是对于图片、视频等大文件。 网络拥堵：跨国或跨洲际网络传输容易受到骨干网带宽限制和拥堵的影响。 源站负载高：所有用户的请求都直接冲击源服务器，在高并发场景下可能导致源服务器过载、响应变慢甚至崩溃。 单点故障风险：源服务器一旦出现故障或遭受攻击，整个网站将无法访问。 安全性弱：源站直接暴露在公网，容易成为 DDoS 攻击的目标。  CDN 旨在解决上述问题，提供以下核心价值：  加速访问：...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">557</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-VLAN%EF%BC%9F"><span class="toc-text">一、什么是 VLAN？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-VLAN%EF%BC%9F"><span class="toc-text">二、为什么需要 VLAN？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81VLAN-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">三、VLAN 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81VLAN-%E6%A0%87%E8%AE%B0-VLAN-Tagging-IEEE-802-1Q"><span class="toc-text">四、VLAN 标记 (VLAN Tagging) - IEEE 802.1Q</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#802-1Q-%E6%A0%87%E7%AD%BE%E7%BB%93%E6%9E%84"><span class="toc-text">802.1Q 标签结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81VLAN-%E7%AB%AF%E5%8F%A3%E6%A8%A1%E5%BC%8F"><span class="toc-text">五、VLAN 端口模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Access-Port-%E6%8E%A5%E5%85%A5%E7%AB%AF%E5%8F%A3-Access-Mode"><span class="toc-text">5.1 Access Port (接入端口 &#x2F; Access Mode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Trunk-Port-%E5%B9%B2%E9%81%93%E7%AB%AF%E5%8F%A3-Trunk-Mode"><span class="toc-text">5.2 Trunk Port (干道端口 &#x2F; Trunk Mode)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81VLAN-%E9%97%B4%E8%B7%AF%E7%94%B1-Inter-VLAN-Routing"><span class="toc-text">六、VLAN 间路由 (Inter-VLAN Routing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Router-on-a-Stick-ROAS"><span class="toc-text">6.1 Router-on-a-Stick (ROAS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Layer-3-Switch-%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-text">6.2 Layer 3 Switch (三层交换机)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B-Cisco-IOS-CLI"><span class="toc-text">七、配置示例 (Cisco IOS CLI)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA-VLAN-%E9%85%8D%E7%BD%AE"><span class="toc-text">7.1 交换机 VLAN 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E9%97%B4-VLAN-%E8%B7%AF%E7%94%B1-Router-on-a-Stick"><span class="toc-text">7.2 路由器间 VLAN 路由 (Router-on-a-Stick)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81VLAN-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">八、VLAN 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">8.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%BC%BA%E7%82%B9%E4%B8%8E%E6%8C%91%E6%88%98%EF%BC%9A"><span class="toc-text">8.2 缺点与挑战：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">九、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e3b0c5d197a/" title="Web Components 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Components 详解"/></a><div class="content"><a class="title" href="/4e3b0c5d197a/" title="Web Components 详解">Web Components 详解</a><time datetime="2026-02-07T22:24:00.000Z" title="发表于 2026-02-08 06:24:00">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>