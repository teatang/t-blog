<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Codex 详解与使用技巧：OpenAI 的代码智能模型 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Codex 是由 OpenAI 训练的一个大型语言模型，其核心能力在于理解自然语言并将其转换为代码，或者理解代码并解释其含义。它是 GPT 系列模型的一个特化版本，专门针对编程语言进行了大量训练。Codex 不仅能生成 Python 代码，还能处理多种其他编程语言，是 OpenAI 在人工智能编程领域迈出的重要一步，也是 GitHub Copilot 等工具的基石。  核心思想：将自然语言描述的">
<meta property="og:type" content="article">
<meta property="og:title" content="Codex 详解与使用技巧：OpenAI 的代码智能模型">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/b100840425a8/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Codex 是由 OpenAI 训练的一个大型语言模型，其核心能力在于理解自然语言并将其转换为代码，或者理解代码并解释其含义。它是 GPT 系列模型的一个特化版本，专门针对编程语言进行了大量训练。Codex 不仅能生成 Python 代码，还能处理多种其他编程语言，是 OpenAI 在人工智能编程领域迈出的重要一步，也是 GitHub Copilot 等工具的基石。  核心思想：将自然语言描述的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg">
<meta property="article:published_time" content="2025-11-06T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-05T10:07:09.952Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="代码生成">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="AI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Codex 详解与使用技巧：OpenAI 的代码智能模型",
  "url": "https://blog.tbf1211.xx.kg/b100840425a8/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg",
  "datePublished": "2025-11-06T22:24:00.000Z",
  "dateModified": "2026-01-05T10:07:09.952Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/b100840425a8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Codex 详解与使用技巧：OpenAI 的代码智能模型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">466</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Codex 详解与使用技巧：OpenAI 的代码智能模型</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Codex 详解与使用技巧：OpenAI 的代码智能模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-11-06T22:24:00.000Z" title="发表于 2025-11-07 06:24:00">2025-11-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Codex</strong> 是由 OpenAI 训练的一个大型语言模型，其核心能力在于<strong>理解自然语言并将其转换为代码</strong>，或者<strong>理解代码并解释其含义</strong>。它是 GPT 系列模型的一个特化版本，专门针对编程语言进行了大量训练。Codex 不仅能生成 Python 代码，还能处理多种其他编程语言，是 OpenAI 在人工智能编程领域迈出的重要一步，也是 GitHub Copilot 等工具的基石。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将自然语言描述的问题转化为可执行的代码，实现人机协作编程，降低编程门槛，提升开发效率。</strong> 掌握有效的指令（Prompt）是充分发挥 Codex 能力的关键。</p>
</div>
<hr>
<h2 id="一、Codex-的起源与核心能力"><a href="#一、Codex-的起源与核心能力" class="headerlink" title="一、Codex 的起源与核心能力"></a>一、Codex 的起源与核心能力</h2><p>Codex 的开发是基于 OpenAI 的 GPT-3 模型。GPT-3 以其强大的文本生成能力震惊业界，但其在代码生成方面虽然有一定表现，但仍缺乏专业性和精准度。为了弥补这一差距，OpenAI 进一步对 GPT-3 进行了微调，使用了海量的代码数据，最终诞生了 Codex。</p>
<h3 id="1-1-背景：GPT-3-的局限性与代码生成的需求"><a href="#1-1-背景：GPT-3-的局限性与代码生成的需求" class="headerlink" title="1.1 背景：GPT-3 的局限性与代码生成的需求"></a>1.1 背景：GPT-3 的局限性与代码生成的需求</h3><p>GPT-3 在零样本（zero-shot）和少样本（few-shot）学习方面表现出色，能够完成多种自然语言任务。然而，当涉及到编程任务时，即使是 GPT-3 也面临挑战：编程语言的严谨性、上下文的复杂性以及缺乏专业领域知识。正是这些需求促使 OpenAI 开发了一个专门用于代码的 AI 模型。</p>
<h3 id="1-2-Codex-的诞生与-GitHub-Copilot"><a href="#1-2-Codex-的诞生与-GitHub-Copilot" class="headerlink" title="1.2 Codex 的诞生与 GitHub Copilot"></a>1.2 Codex 的诞生与 GitHub Copilot</h3><p>2021 年，OpenAI 推出了 Codex，并宣布其成为了 <strong>GitHub Copilot</strong> 的核心引擎。GitHub Copilot 是一个“AI结对程序员”，能够根据开发者的注释或部分代码，实时建议完整的代码行、函数甚至整个文件。这标志着 AI 辅助编程进入了一个新的时代。</p>
<h3 id="1-3-核心能力"><a href="#1-3-核心能力" class="headerlink" title="1.3 核心能力"></a>1.3 核心能力</h3><p>Codex 能够执行多种代码相关的任务：</p>
<ol>
<li><strong>自然语言到代码的转换 (Natural Language to Code)</strong>：这是其最主要的能力。开发者可以用自然语言描述他们想要实现的功能，Codex 就能生成相应的代码。</li>
<li><strong>代码到自然语言的解释 (Code to Natural Language)</strong>：反向操作，解释一段代码的用途和逻辑。</li>
<li><strong>代码补全和建议 (Code Completion &amp; Suggestion)</strong>：在编写代码时，根据上下文提供智能的代码补全建议。</li>
<li><strong>代码重构 (Code Refactoring)</strong>：建议改进现有代码的结构或效率。</li>
<li><strong>单元测试生成 (Unit Test Generation)</strong>：为给定代码片段生成单元测试。</li>
<li><strong>错误检测和调试辅助 (Error Detection &amp; Debugging Assistance)</strong>：通过解释代码或生成替代方案来帮助识别问题。</li>
<li><strong>多种编程语言支持</strong>：Python 是其表现最好的语言，但它也支持 JavaScript, Go, Ruby, Java, C++, Shell 等多种语言。</li>
</ol>
<h3 id="1-4-技术原理-基于-GPT-架构"><a href="#1-4-技术原理-基于-GPT-架构" class="headerlink" title="1.4 技术原理 (基于 GPT 架构)"></a>1.4 技术原理 (基于 GPT 架构)</h3><p>Codex 继承了 GPT 系列模型的核心架构——<strong>Transformer</strong>。它在海量的自然语言和编程代码数据集上进行了大规模预训练，使其能够理解并生成高质量的文本和代码。作为自回归模型，它通过预测下一个 token 来生成内容，并利用注意力机制捕捉复杂的上下文依赖。</p>
<h2 id="二、Codex-指令-Prompt-的使用技巧"><a href="#二、Codex-指令-Prompt-的使用技巧" class="headerlink" title="二、Codex 指令 (Prompt) 的使用技巧"></a>二、Codex 指令 (Prompt) 的使用技巧</h2><p>Codex 的性能与您提供的指令（Prompt）质量直接相关。一个清晰、具体且包含足够上下文的 Prompt 能显著提高生成代码的准确性和相关性。</p>
<h3 id="2-1-提供清晰且具体的任务描述"><a href="#2-1-提供清晰且具体的任务描述" class="headerlink" title="2.1 提供清晰且具体的任务描述"></a>2.1 提供清晰且具体的任务描述</h3><p>模糊的指令会导致模糊的结果。明确告诉 Codex 你想做什么。</p>
<ul>
<li><strong>差的指令</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 写一个函数</span><br></pre></td></tr></table></figure></li>
<li><strong>好的指令</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 函数: 接收一个整数列表，返回它们的平均值。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_average</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-指明编程语言和版本-框架-如果需要"><a href="#2-2-指明编程语言和版本-框架-如果需要" class="headerlink" title="2.2 指明编程语言和版本&#x2F;框架 (如果需要)"></a>2.2 指明编程语言和版本&#x2F;框架 (如果需要)</h3><p>Codex 支持多种语言。明确指定语言可以避免混淆。如果任务与特定框架相关，也应提及。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript (React): 创建一个功能组件，显示一个计数器，并带有一个增加按钮。</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python (Pandas): 读取 &#x27;data.csv&#x27; 文件，筛选出 &#x27;age&#x27; 列大于 30 的行。</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-提供输入和输出示例-Few-shot-Learning"><a href="#2-3-提供输入和输出示例-Few-shot-Learning" class="headerlink" title="2.3 提供输入和输出示例 (Few-shot Learning)"></a>2.3 提供输入和输出示例 (Few-shot Learning)</h3><p>这是提高生成质量最有效的方法之一。通过提供几个输入和预期输出的例子，Codex 能更好地理解你的意图。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 函数: 将字符串转换为驼峰命名法。</span></span><br><span class="line"><span class="comment"># to_camel_case(&quot;hello world&quot;) -&gt; &quot;helloWorld&quot;</span></span><br><span class="line"><span class="comment"># to_camel_case(&quot;foo_bar_baz&quot;) -&gt; &quot;fooBarBaz&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_camel_case</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
Codex 会根据这些示例推断出正确的转换逻辑。</li>
</ul>
<h3 id="2-4-拆解复杂任务"><a href="#2-4-拆解复杂任务" class="headerlink" title="2.4 拆解复杂任务"></a>2.4 拆解复杂任务</h3><p>如果任务过于复杂，尝试将其拆分为几个更小的、可管理的子任务。先让 Codex 完成一个部分，再继续下一个。</p>
<ul>
<li><strong>复杂任务</strong>：创建一个完整的 Web 应用，包含用户认证、数据库交互和 API 接口。</li>
<li><strong>拆解任务</strong>：<ol>
<li>生成用户注册的 API 接口 (输入：用户名、密码，输出：成功&#x2F;失败)。</li>
<li>生成用户登录的 API 接口。</li>
<li>生成数据库模型 (用户表)。</li>
<li>生成一个简单的前端注册表单。</li>
</ol>
</li>
</ul>
<h3 id="2-5-利用上下文和注释"><a href="#2-5-利用上下文和注释" class="headerlink" title="2.5 利用上下文和注释"></a>2.5 利用上下文和注释</h3><p>Codex 在 IDE 中通常能访问到你当前文件的全部内容。善用注释来指导它。</p>
<ul>
<li><strong>文件开头</strong>：可以写上文件用途，使用的技术栈等。</li>
<li><strong>函数前</strong>：写上函数的目的、参数、返回值。</li>
<li><strong>行内</strong>：注释你希望下一步实现什么。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件: data_processing.py</span></span><br><span class="line"><span class="comment"># 这个脚本用于处理客户数据，包括加载、清洗和分析。</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">filepath: <span class="built_in">str</span></span>) -&gt; pd.DataFrame:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载指定路径的 CSV 文件到 DataFrame。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        filepath: CSV 文件的路径。</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        pd.DataFrame: 加载的数据。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Load the CSV file</span></span><br><span class="line">    df = pd.read_csv(filepath)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, add a function to clean the data: remove duplicate rows</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-明确约束和要求"><a href="#2-6-明确约束和要求" class="headerlink" title="2.6 明确约束和要求"></a>2.6 明确约束和要求</h3><p>如果代码需要满足特定的性能、风格或库要求，请在 Prompt 中说明。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript: 编写一个递归函数计算斐波那契数列的第 n 项，要求使用尾递归优化。</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python: 使用列表推导式 (list comprehension) 创建一个包含 1 到 100 之间所有偶数的列表。</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-迭代与修正"><a href="#2-7-迭代与修正" class="headerlink" title="2.7 迭代与修正"></a>2.7 迭代与修正</h3><p>很少有第一次尝试就能生成完美的代码。将 Codex 视为一个可以迭代和修正的工具。</p>
<ul>
<li><strong>步骤</strong>：<ol>
<li>输入 Prompt。</li>
<li>查看生成结果。</li>
<li>如果结果不满意，修改 Prompt (更具体、添加示例、调整措辞)，或者手动修改生成的代码，让 Codex 在修改后的上下文上继续生成。</li>
<li>重复直到满意。</li>
</ol>
</li>
</ul>
<h3 id="2-8-错误修复与优化指令"><a href="#2-8-错误修复与优化指令" class="headerlink" title="2.8 错误修复与优化指令"></a>2.8 错误修复与优化指令</h3><p>Codex 也能帮助修复和优化代码。</p>
<ul>
<li><strong>错误修复</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修复以下 Python 代码中的 bug。它应该返回列表中所有元素的乘积，但当前实现是错误的。</span></span><br><span class="line"><span class="comment"># def product(numbers):</span></span><br><span class="line"><span class="comment">#     res = 0</span></span><br><span class="line"><span class="comment">#     for n in numbers:</span></span><br><span class="line"><span class="comment">#         res *= n</span></span><br><span class="line"><span class="comment">#     return res</span></span><br></pre></td></tr></table></figure></li>
<li><strong>优化</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化以下 Python 代码，使其运行更高效。</span></span><br><span class="line"><span class="comment"># def expensive_calculation(n):</span></span><br><span class="line"><span class="comment">#     result = 0</span></span><br><span class="line"><span class="comment">#     for i in range(n):</span></span><br><span class="line"><span class="comment">#         for j in range(n):</span></span><br><span class="line"><span class="comment">#             result += i * j</span></span><br><span class="line"><span class="comment">#     return result</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三、Codex-的工作流程"><a href="#三、Codex-的工作流程" class="headerlink" title="三、Codex 的工作流程"></a>三、Codex 的工作流程</h2><p>Codex 的典型工作流程可以用以下序列图表示：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant User as 用户 (开发者)
    participant IDE as 集成开发环境 (如 VS Code with Copilot)
    participant CopilotPlugin as GitHub Copilot 插件
    participant OpenAI_API as OpenAI Codex API

    User-&gt;&gt;IDE: 1. 在代码编辑器中输入自然语言注释或部分代码
    IDE-&gt;&gt;CopilotPlugin: 2. 插件检测到用户输入或上下文变化
    CopilotPlugin-&gt;&gt;OpenAI_API: 3. 将当前代码上下文 (文件内容, 光标位置, 注释, 用户输入的Prompt等) 发送给 Codex API
    OpenAI_API--&gt;&gt;Codex_Model: 4. Codex 模型根据输入生成代码建议
    Codex_Model--&gt;&gt;OpenAI_API: 5. 返回生成的代码建议
    OpenAI_API--&gt;&gt;CopilotPlugin: 6. 返回代码建议
    CopilotPlugin-&gt;&gt;IDE: 7. 在编辑器中显示代码建议 (通常是灰色文本)
    User-&gt;&gt;IDE: 8. 用户接受、修改或忽略建议
    IDE-&gt;&gt;User: 9. 代码继续编写 (返回步骤 1)
  </pre></div>

<p><strong>关键点</strong>：</p>
<ul>
<li><strong>上下文感知</strong>：Codex 接收的不仅仅是用户输入的指令，还包括整个代码文件的上下文信息（已导入的库、已定义的函数、变量名等），这使得它能够生成与现有代码风格和逻辑一致的代码。</li>
<li><strong>迭代性</strong>：通常情况下，Codex 并不是一次性生成整个复杂程序，而是逐步辅助开发者，通过多次交互，从函数签名到具体实现，再到测试用例。</li>
</ul>
<h2 id="四、Codex-的应用场景"><a href="#四、Codex-的应用场景" class="headerlink" title="四、Codex 的应用场景"></a>四、Codex 的应用场景</h2><p>Codex 的能力使其在多个方面具有巨大的应用潜力：</p>
<ol>
<li><strong>提高开发效率</strong>：快速原型开发、减少重复劳动、降低学习曲线。</li>
<li><strong>教育和学习</strong>：辅助编程新手、代码解释器。</li>
<li><strong>多语言开发</strong>：跨语言辅助。</li>
<li><strong>自动化脚本</strong>：快速生成用于数据处理、文件操作、系统管理等任务的自动化脚本。</li>
<li><strong>无代码&#x2F;低代码平台</strong>：作为后端引擎，将用户的自然语言需求转换为平台可识别的代码或配置。</li>
</ol>
<h2 id="五、Codex-的局限性与挑战"><a href="#五、Codex-的局限性与挑战" class="headerlink" title="五、Codex 的局限性与挑战"></a>五、Codex 的局限性与挑战</h2><p>尽管 Codex 强大，但它并非完美无缺，存在一些重要的局限性和挑战：</p>
<ol>
<li><strong>代码正确性与安全性</strong>：不保证完全正确，可能包含逻辑错误、效率低下或安全漏洞。开发者必须仔细审查和测试。</li>
<li><strong>版权和开源协议问题</strong>：训练数据包含了大量的开源代码，可能引发版权争议。</li>
<li><strong>“黑盒”问题</strong>：决策过程不透明，难以理解错误原因。</li>
<li><strong>创造力有限</strong>：主要基于模式组合，在解决全新或高度抽象的问题时能力有限。</li>
<li><strong>环境依赖性</strong>：生成的代码可能依赖于特定的库版本、环境配置等。</li>
<li><strong>对现有代码的理解深度</strong>：对于大型、复杂且具有特定业务逻辑的代码库，理解深度仍有待提高。</li>
<li><strong>“幻觉”现象 (Hallucination)</strong>：有时会生成看起来合理但实际上并不存在或不起作用的 API 调用。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Codex 是 OpenAI 在代码智能领域的一个里程碑，它通过将自然语言转化为可执行代码，极大地提高了开发效率和可访问性。它已经成为 GitHub Copilot 等工具的核心，改变了许多开发者的日常工作方式。然而，要充分发挥其潜力，开发者需要掌握有效的指令工程（Prompt Engineering）技巧，并将其视为一个强大的“结对程序员”，而非独立完成所有工作的“全能机器”。在人机协作的编程未来中，人类程序员的专业判断、创造力和批判性思维依然是不可或缺的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/b100840425a8/">https://blog.tbf1211.xx.kg/b100840425a8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/">代码生成</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/AI/">AI</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/fdb8a5195f3e/" title="知识图谱 (Knowledge Graph) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">知识图谱 (Knowledge Graph) 详解</div></div><div class="info-2"><div class="info-item-1"> 知识图谱 (Knowledge Graph, KG) 是一种结构化的知识表示形式，它以图 (Graph) 的形式来描述客观世界中存在的各种实体 (Entities)、概念 (Concepts) 及其之间的关系 (Relations)。通过将离散、异构的信息链接起来，知识图谱构建了一个庞大且相互关联的“知识网络”，使得机器能够像人类一样理解、组织和利用知识，从而支持复杂的推理和智能应用。  核心思想：将现实世界的知识抽象为“实体-关系-实体”或“实体-属性-属性值”的三元组结构，并通过图的形式直观地表示和存储这些知识，从而实现知识的机器可读、可理解和可推理。 它旨在解决传统关系型数据库在表示复杂、动态、多源异构数据时存在的语义鸿沟问题。   一、知识图谱的基本构成知识图谱的核心是其图结构中的基本元素：  实体 (Entities)  定义：指现实世界中具有明确指代和区分度的“事物”或“概念”，可以是具象的（如“苹果公司”、“埃菲尔铁塔”、“约翰·F·肯尼迪”）或抽象的（如“人工智能”、“经济学”、“创新”）。 表示：在知识图谱中，每个实体通常有一个唯一的标识符 (URI&#x2F...</div></div></div></a><a class="pagination-related" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Claude Code 详解：Anthropic 的代码智能模型</div></div><div class="info-2"><div class="info-item-1"> Claude Code 是 Anthropic 公司开发的 Claude 系列大型语言模型在代码理解、生成和辅助方面的一个特定能力集合或优化方向。Anthropic 以其在 AI 安全和可控性方面的研究而闻名，Claude 模型旨在成为一个有益、无害且诚实的 AI 助手。因此，Claude Code 不仅关注代码的正确性，也强调生成代码的安全性、可读性和遵循最佳实践。  核心思想：结合 Anthropic 的安全和伦理原则，提供安全、有益、高质量的代码生成与辅助能力，旨在成为开发者的“无害”智能编程伙伴。   一、Claude Code 的背景与 Anthropic 理念Anthropic 由前 OpenAI 员工创立，致力于开发安全、可控且有益的人工智能系统。其核心产品 Claude 语言模型系列被设计为更易于对齐人类价值观，并通过“宪法 AI (Constitutional AI)”等方法进行训练，减少有害、偏见或不真实内容的生成。 在代码领域，这种理念意味着 Claude Code 不仅仅是生成能运行的代码，更关注：  安全性：避免生成包含已知漏洞或不良安全实践的代码。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">Claude Code 详解：Anthropic 的代码智能模型</div></div><div class="info-2"><div class="info-item-1"> Claude Code 是 Anthropic 公司开发的 Claude 系列大型语言模型在代码理解、生成和辅助方面的一个特定能力集合或优化方向。Anthropic 以其在 AI 安全和可控性方面的研究而闻名，Claude 模型旨在成为一个有益、无害且诚实的 AI 助手。因此，Claude Code 不仅关注代码的正确性，也强调生成代码的安全性、可读性和遵循最佳实践。  核心思想：结合 Anthropic 的安全和伦理原则，提供安全、有益、高质量的代码生成与辅助能力，旨在成为开发者的“无害”智能编程伙伴。   一、Claude Code 的背景与 Anthropic 理念Anthropic 由前 OpenAI 员工创立，致力于开发安全、可控且有益的人工智能系统。其核心产品 Claude 语言模型系列被设计为更易于对齐人类价值观，并通过“宪法 AI (Constitutional AI)”等方法进行训练，减少有害、偏见或不真实内容的生成。 在代码领域，这种理念意味着 Claude Code 不仅仅是生成能运行的代码，更关注：  安全性：避免生成包含已知漏洞或不良安全实践的代码。 ...</div></div></div></a><a class="pagination-related" href="/e520aa0d37e4/" title="Ollama 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-03</div><div class="info-item-2">Ollama 深度解析</div></div><div class="info-2"><div class="info-item-1"> Ollama 是一个开源项目，旨在简化在本地机器上运行大型语言模型 (LLM) 的过程。它提供了一个易于使用的命令行界面和 API，让用户能够快速下载、运行、创建和管理各种预训练的开源 LLM，如 Llama 2, Mistral, Gemma 等。Ollama 专注于提供流畅的用户体验，使个人开发者、研究人员和企业能够在自己的硬件上，以隐私保护和成本效益的方式探索和利用 LLM 的强大功能。  核心思想：将复杂的大语言模型本地化运行过程封装成简单命令，让用户能轻松部署、交互和定制开源 LLM，实现AI的民主化和去中心化。   一、Ollama 简介随着大语言模型技术的飞速发展，越来越多的开发者和企业希望在本地环境中运行这些模型，以实现数据隐私、降低成本、离线可用以及更灵活的定制化。然而，直接在本地部署和管理 LLM 往往涉及复杂的依赖安装、模型格式转换、GPU 配置等挑战。 Ollama 应运而生，它旨在解决这些痛点，提供一个“一站式”解决方案：  极简的用户体验：通过单个可执行文件和直观的命令行指令，即可完成模型的下载、运行和管理。 广泛的模型支持：支持多种流行的开源 LL...</div></div></div></a><a class="pagination-related" href="/7c1d07475a60/" title="图生图 (Image-to-Image) 原理详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-13</div><div class="info-item-2">图生图 (Image-to-Image) 原理详解</div></div><div class="info-2"><div class="info-item-1"> 图生图 (Image-to-Image Generation) 是一种先进的人工智能技术，其核心是将一张输入图像作为条件，生成另一张与之相关的输出图像。这种技术能够实现图像风格转换、超分辨率、图像修复、语义分割图到真实图像转换等多种复杂的视觉任务。现代图生图模型通常建立在强大的生成模型之上，尤其是扩散模型 (Diffusion Models)，并通过精密的条件控制机制来引导图像的转换过程。  核心思想：图生图模型通过学习输入图像与目标输出图像之间的映射关系，将输入的视觉信息作为生成过程的条件。与文生图从随机噪声开始不同，图生图往往以输入图像的某种噪声化版本作为起点，然后通过迭代去噪过程，逐步生成符合条件的新图像。   一、为什么需要图生图？在计算机视觉领域，许多任务都可以被重新定义为图像到图像的转换问题。传统方法往往需要针对每个任务设计专门的算法，费时费力。图生图技术提供了一种统一且灵活的解决方案：  自动化复杂编辑：将耗时且专业的图像编辑工作（如图像修复、前景替换、风格化）自动化。 内容创作辅助：辅助艺术家和设计师快速生成不同风格的草图、渲染图或变体。 数据增强：为训练其他模...</div></div></div></a><a class="pagination-related" href="/e65255eb560f/" title="潜空间 (Latent Space) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-26</div><div class="info-item-2">潜空间 (Latent Space) 详解</div></div><div class="info-2"><div class="info-item-1"> 潜空间 (Latent Space)，又称隐空间或潜在空间，是深度学习，尤其是生成模型中的一个核心概念。它是一个经过模型学习和压缩的、低维度的、连续的数学空间，用于表示原始高维数据（如图像、文本、音频）的内在结构和语义特征。数据点在潜空间中的位置编码了其核心属性，使得模型能够在此空间中进行高效的生成、插值和操控，而无需直接处理复杂的高维数据。  核心思想：潜空间是数据的一种“抽象语言”或“概念地图”。它将高维、复杂的原始数据（如一张照片的几百万像素）压缩成一个低维的向量表示。在这个低维空间中，语义相似的数据点彼此靠近，且空间是连续的，微小的移动对应着数据在现实世界中语义上的平滑变化。   一、为什么需要潜空间？处理现实世界中的数据（如图像、文本）面临以下挑战：  高维度性 (High Dimensionality)：一张 512x512 像素的 RGB 图像包含 $512 \times 512 \times 3 \approx 78$ 万个像素值。直接在如此高维的空间中进行操作、生成或搜索是计算密集且效率低下的。 数据稀疏性 (Data Sparsity)：在高维空间中，真实数...</div></div></div></a><a class="pagination-related" href="/289566312b0f/" title="Vision Transformer (ViT) 与 Residual Network (ResNet) 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-16</div><div class="info-item-2">Vision Transformer (ViT) 与 Residual Network (ResNet) 深度详解</div></div><div class="info-2"><div class="info-item-1"> 在深度学习的计算机视觉领域，卷积神经网络 (CNN) 曾长期占据主导地位，而 Residual Network (ResNet) 则是其中一个里程碑式的创新，通过引入残差连接解决了深层网络训练中的梯度消失问题。近年来，随着 Transformer 模型在自然语言处理 (NLP) 领域取得巨大成功，研究人员尝试将其引入视觉领域，催生了 Vision Transformer (ViT)。ViT 颠覆了传统 CNN 的范式，直接将图像视为一系列序列化的图像块 (patches)，并用 Transformer 编码器进行处理。本文将对这两大具有代表性的模型进行深入剖析和比较。  ResNet 的核心思想： 通过残差连接 (Residual Connection) 允许网络学习残差函数，使得训练极深的网络变得可能，从而有效缓解了深度神经网络中的梯度消失和梯度爆炸问题，提高了模型性能。 ViT 的核心思想： 放弃了 CNN 的归纳偏置 (inductive bias)，直接将图像分割成固定大小的图像块 (patches)，并将其视为序列化的词向量 (tokens)，然后输入标准的 Tran...</div></div></div></a><a class="pagination-related" href="/8e2a5540853c/" title="LoRA (Low-Rank Adaptation) 模型详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-24</div><div class="info-item-2">LoRA (Low-Rank Adaptation) 模型详解</div></div><div class="info-2"><div class="info-item-1"> LoRA (Low-Rank Adaptation of Large Language Models) 是一种参数高效微调 (Parameter-Efficient Fine-Tuning, PEFT) 技术，旨在大幅减少大型预训练模型（如大型语言模型 LLMs 和扩散模型 Diffusion Models）在下游任务上进行微调时所需的可训练参数数量和计算资源。它通过在模型原有权重矩阵旁边引入两个低秩矩阵进行增量更新，从而实现高效且高性能的微调，避免了对整个模型进行全量微调的巨大开销。  核心思想：冻结预训练模型的原始权重，并向其注入少量可训练的低秩分解矩阵。在微调过程中，只训练这些新注入的低秩矩阵，而预训练模型的绝大部分参数保持不变。在推理时，这些低秩矩阵可以与原始权重合并，几乎不增加推理延迟。   一、为什么需要 LoRA？随着深度学习模型规模的爆炸式增长，特别是大型语言模型 (LLMs) 和扩散模型 (Diffusion Models) 的参数量达到数十亿甚至数万亿，对其进行全量微调（即训练所有模型参数）带来了严峻的挑战：  巨大的计算成本：全量微调一个数十亿参数的模型需...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">466</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">227</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">81</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Codex-%E7%9A%84%E8%B5%B7%E6%BA%90%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B"><span class="toc-text">一、Codex 的起源与核心能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%83%8C%E6%99%AF%EF%BC%9AGPT-3-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-text">1.1 背景：GPT-3 的局限性与代码生成的需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Codex-%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E-GitHub-Copilot"><span class="toc-text">1.2 Codex 的诞生与 GitHub Copilot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B"><span class="toc-text">1.3 核心能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-%E5%9F%BA%E4%BA%8E-GPT-%E6%9E%B6%E6%9E%84"><span class="toc-text">1.4 技术原理 (基于 GPT 架构)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Codex-%E6%8C%87%E4%BB%A4-Prompt-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">二、Codex 指令 (Prompt) 的使用技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8F%90%E4%BE%9B%E6%B8%85%E6%99%B0%E4%B8%94%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="toc-text">2.1 提供清晰且具体的任务描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8C%87%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%89%88%E6%9C%AC-%E6%A1%86%E6%9E%B6-%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81"><span class="toc-text">2.2 指明编程语言和版本&#x2F;框架 (如果需要)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8F%90%E4%BE%9B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B-Few-shot-Learning"><span class="toc-text">2.3 提供输入和输出示例 (Few-shot Learning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8B%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E4%BB%BB%E5%8A%A1"><span class="toc-text">2.4 拆解复杂任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%A9%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">2.5 利用上下文和注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%98%8E%E7%A1%AE%E7%BA%A6%E6%9D%9F%E5%92%8C%E8%A6%81%E6%B1%82"><span class="toc-text">2.6 明确约束和要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E8%BF%AD%E4%BB%A3%E4%B8%8E%E4%BF%AE%E6%AD%A3"><span class="toc-text">2.7 迭代与修正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E9%94%99%E8%AF%AF%E4%BF%AE%E5%A4%8D%E4%B8%8E%E4%BC%98%E5%8C%96%E6%8C%87%E4%BB%A4"><span class="toc-text">2.8 错误修复与优化指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Codex-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">三、Codex 的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Codex-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、Codex 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Codex-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E6%8C%91%E6%88%98"><span class="toc-text">五、Codex 的局限性与挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-18.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>