<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Codex 详解与使用技巧：OpenAI 的代码智能模型 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Codex 是由 OpenAI 训练的一个大型语言模型，其核心能力在于理解自然语言并将其转换为代码，或者理解代码并解释其含义。它是 GPT 系列模型的一个特化版本，专门针对编程语言进行了大量训练。Codex 不仅能生成 Python 代码，还能处理多种其他编程语言，是 OpenAI 在人工智能编程领域迈出的重要一步，也是 GitHub Copilot 等工具的基石。  核心思想：将自然语言描述的">
<meta property="og:type" content="article">
<meta property="og:title" content="Codex 详解与使用技巧：OpenAI 的代码智能模型">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/b100840425a8/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Codex 是由 OpenAI 训练的一个大型语言模型，其核心能力在于理解自然语言并将其转换为代码，或者理解代码并解释其含义。它是 GPT 系列模型的一个特化版本，专门针对编程语言进行了大量训练。Codex 不仅能生成 Python 代码，还能处理多种其他编程语言，是 OpenAI 在人工智能编程领域迈出的重要一步，也是 GitHub Copilot 等工具的基石。  核心思想：将自然语言描述的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg">
<meta property="article:published_time" content="2025-11-06T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:34:25.640Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="代码生成">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="AI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Codex 详解与使用技巧：OpenAI 的代码智能模型",
  "url": "https://blog.tbf1211.xx.kg/b100840425a8/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg",
  "datePublished": "2025-11-06T22:24:00.000Z",
  "dateModified": "2026-02-01T09:34:25.640Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/b100840425a8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Codex 详解与使用技巧：OpenAI 的代码智能模型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-19.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Codex 详解与使用技巧：OpenAI 的代码智能模型</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Codex 详解与使用技巧：OpenAI 的代码智能模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-11-06T22:24:00.000Z" title="发表于 2025-11-07 06:24:00">2025-11-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Codex</strong> 是由 OpenAI 训练的一个大型语言模型，其核心能力在于<strong>理解自然语言并将其转换为代码</strong>，或者<strong>理解代码并解释其含义</strong>。它是 GPT 系列模型的一个特化版本，专门针对编程语言进行了大量训练。Codex 不仅能生成 Python 代码，还能处理多种其他编程语言，是 OpenAI 在人工智能编程领域迈出的重要一步，也是 GitHub Copilot 等工具的基石。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将自然语言描述的问题转化为可执行的代码，实现人机协作编程，降低编程门槛，提升开发效率。</strong> 掌握有效的指令（Prompt）是充分发挥 Codex 能力的关键。</p>
</div>
<hr>
<h2 id="一、Codex-的起源与核心能力"><a href="#一、Codex-的起源与核心能力" class="headerlink" title="一、Codex 的起源与核心能力"></a>一、Codex 的起源与核心能力</h2><p>Codex 的开发是基于 OpenAI 的 GPT-3 模型。GPT-3 以其强大的文本生成能力震惊业界，但其在代码生成方面虽然有一定表现，但仍缺乏专业性和精准度。为了弥补这一差距，OpenAI 进一步对 GPT-3 进行了微调，使用了海量的代码数据，最终诞生了 Codex。</p>
<h3 id="1-1-背景：GPT-3-的局限性与代码生成的需求"><a href="#1-1-背景：GPT-3-的局限性与代码生成的需求" class="headerlink" title="1.1 背景：GPT-3 的局限性与代码生成的需求"></a>1.1 背景：GPT-3 的局限性与代码生成的需求</h3><p>GPT-3 在零样本（zero-shot）和少样本（few-shot）学习方面表现出色，能够完成多种自然语言任务。然而，当涉及到编程任务时，即使是 GPT-3 也面临挑战：编程语言的严谨性、上下文的复杂性以及缺乏专业领域知识。正是这些需求促使 OpenAI 开发了一个专门用于代码的 AI 模型。</p>
<h3 id="1-2-Codex-的诞生与-GitHub-Copilot"><a href="#1-2-Codex-的诞生与-GitHub-Copilot" class="headerlink" title="1.2 Codex 的诞生与 GitHub Copilot"></a>1.2 Codex 的诞生与 GitHub Copilot</h3><p>2021 年，OpenAI 推出了 Codex，并宣布其成为了 <strong>GitHub Copilot</strong> 的核心引擎。GitHub Copilot 是一个“AI结对程序员”，能够根据开发者的注释或部分代码，实时建议完整的代码行、函数甚至整个文件。这标志着 AI 辅助编程进入了一个新的时代。</p>
<h3 id="1-3-核心能力"><a href="#1-3-核心能力" class="headerlink" title="1.3 核心能力"></a>1.3 核心能力</h3><p>Codex 能够执行多种代码相关的任务：</p>
<ol>
<li><strong>自然语言到代码的转换 (Natural Language to Code)</strong>：这是其最主要的能力。开发者可以用自然语言描述他们想要实现的功能，Codex 就能生成相应的代码。</li>
<li><strong>代码到自然语言的解释 (Code to Natural Language)</strong>：反向操作，解释一段代码的用途和逻辑。</li>
<li><strong>代码补全和建议 (Code Completion &amp; Suggestion)</strong>：在编写代码时，根据上下文提供智能的代码补全建议。</li>
<li><strong>代码重构 (Code Refactoring)</strong>：建议改进现有代码的结构或效率。</li>
<li><strong>单元测试生成 (Unit Test Generation)</strong>：为给定代码片段生成单元测试。</li>
<li><strong>错误检测和调试辅助 (Error Detection &amp; Debugging Assistance)</strong>：通过解释代码或生成替代方案来帮助识别问题。</li>
<li><strong>多种编程语言支持</strong>：Python 是其表现最好的语言，但它也支持 JavaScript, Go, Ruby, Java, C++, Shell 等多种语言。</li>
</ol>
<h3 id="1-4-技术原理-基于-GPT-架构"><a href="#1-4-技术原理-基于-GPT-架构" class="headerlink" title="1.4 技术原理 (基于 GPT 架构)"></a>1.4 技术原理 (基于 GPT 架构)</h3><p>Codex 继承了 GPT 系列模型的核心架构——<strong>Transformer</strong>。它在海量的自然语言和编程代码数据集上进行了大规模预训练，使其能够理解并生成高质量的文本和代码。作为自回归模型，它通过预测下一个 token 来生成内容，并利用注意力机制捕捉复杂的上下文依赖。</p>
<h2 id="二、Codex-指令-Prompt-的使用技巧"><a href="#二、Codex-指令-Prompt-的使用技巧" class="headerlink" title="二、Codex 指令 (Prompt) 的使用技巧"></a>二、Codex 指令 (Prompt) 的使用技巧</h2><p>Codex 的性能与您提供的指令（Prompt）质量直接相关。一个清晰、具体且包含足够上下文的 Prompt 能显著提高生成代码的准确性和相关性。</p>
<h3 id="2-1-提供清晰且具体的任务描述"><a href="#2-1-提供清晰且具体的任务描述" class="headerlink" title="2.1 提供清晰且具体的任务描述"></a>2.1 提供清晰且具体的任务描述</h3><p>模糊的指令会导致模糊的结果。明确告诉 Codex 你想做什么。</p>
<ul>
<li><strong>差的指令</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 写一个函数</span><br></pre></td></tr></table></figure></li>
<li><strong>好的指令</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 函数: 接收一个整数列表，返回它们的平均值。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_average</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-指明编程语言和版本-框架-如果需要"><a href="#2-2-指明编程语言和版本-框架-如果需要" class="headerlink" title="2.2 指明编程语言和版本&#x2F;框架 (如果需要)"></a>2.2 指明编程语言和版本&#x2F;框架 (如果需要)</h3><p>Codex 支持多种语言。明确指定语言可以避免混淆。如果任务与特定框架相关，也应提及。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript (React): 创建一个功能组件，显示一个计数器，并带有一个增加按钮。</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python (Pandas): 读取 &#x27;data.csv&#x27; 文件，筛选出 &#x27;age&#x27; 列大于 30 的行。</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-提供输入和输出示例-Few-shot-Learning"><a href="#2-3-提供输入和输出示例-Few-shot-Learning" class="headerlink" title="2.3 提供输入和输出示例 (Few-shot Learning)"></a>2.3 提供输入和输出示例 (Few-shot Learning)</h3><p>这是提高生成质量最有效的方法之一。通过提供几个输入和预期输出的例子，Codex 能更好地理解你的意图。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 函数: 将字符串转换为驼峰命名法。</span></span><br><span class="line"><span class="comment"># to_camel_case(&quot;hello world&quot;) -&gt; &quot;helloWorld&quot;</span></span><br><span class="line"><span class="comment"># to_camel_case(&quot;foo_bar_baz&quot;) -&gt; &quot;fooBarBaz&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_camel_case</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
Codex 会根据这些示例推断出正确的转换逻辑。</li>
</ul>
<h3 id="2-4-拆解复杂任务"><a href="#2-4-拆解复杂任务" class="headerlink" title="2.4 拆解复杂任务"></a>2.4 拆解复杂任务</h3><p>如果任务过于复杂，尝试将其拆分为几个更小的、可管理的子任务。先让 Codex 完成一个部分，再继续下一个。</p>
<ul>
<li><strong>复杂任务</strong>：创建一个完整的 Web 应用，包含用户认证、数据库交互和 API 接口。</li>
<li><strong>拆解任务</strong>：<ol>
<li>生成用户注册的 API 接口 (输入：用户名、密码，输出：成功&#x2F;失败)。</li>
<li>生成用户登录的 API 接口。</li>
<li>生成数据库模型 (用户表)。</li>
<li>生成一个简单的前端注册表单。</li>
</ol>
</li>
</ul>
<h3 id="2-5-利用上下文和注释"><a href="#2-5-利用上下文和注释" class="headerlink" title="2.5 利用上下文和注释"></a>2.5 利用上下文和注释</h3><p>Codex 在 IDE 中通常能访问到你当前文件的全部内容。善用注释来指导它。</p>
<ul>
<li><strong>文件开头</strong>：可以写上文件用途，使用的技术栈等。</li>
<li><strong>函数前</strong>：写上函数的目的、参数、返回值。</li>
<li><strong>行内</strong>：注释你希望下一步实现什么。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件: data_processing.py</span></span><br><span class="line"><span class="comment"># 这个脚本用于处理客户数据，包括加载、清洗和分析。</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">filepath: <span class="built_in">str</span></span>) -&gt; pd.DataFrame:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载指定路径的 CSV 文件到 DataFrame。</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        filepath: CSV 文件的路径。</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        pd.DataFrame: 加载的数据。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Load the CSV file</span></span><br><span class="line">    df = pd.read_csv(filepath)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, add a function to clean the data: remove duplicate rows</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-明确约束和要求"><a href="#2-6-明确约束和要求" class="headerlink" title="2.6 明确约束和要求"></a>2.6 明确约束和要求</h3><p>如果代码需要满足特定的性能、风格或库要求，请在 Prompt 中说明。</p>
<ul>
<li><strong>示例</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript: 编写一个递归函数计算斐波那契数列的第 n 项，要求使用尾递归优化。</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python: 使用列表推导式 (list comprehension) 创建一个包含 1 到 100 之间所有偶数的列表。</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-7-迭代与修正"><a href="#2-7-迭代与修正" class="headerlink" title="2.7 迭代与修正"></a>2.7 迭代与修正</h3><p>很少有第一次尝试就能生成完美的代码。将 Codex 视为一个可以迭代和修正的工具。</p>
<ul>
<li><strong>步骤</strong>：<ol>
<li>输入 Prompt。</li>
<li>查看生成结果。</li>
<li>如果结果不满意，修改 Prompt (更具体、添加示例、调整措辞)，或者手动修改生成的代码，让 Codex 在修改后的上下文上继续生成。</li>
<li>重复直到满意。</li>
</ol>
</li>
</ul>
<h3 id="2-8-错误修复与优化指令"><a href="#2-8-错误修复与优化指令" class="headerlink" title="2.8 错误修复与优化指令"></a>2.8 错误修复与优化指令</h3><p>Codex 也能帮助修复和优化代码。</p>
<ul>
<li><strong>错误修复</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修复以下 Python 代码中的 bug。它应该返回列表中所有元素的乘积，但当前实现是错误的。</span></span><br><span class="line"><span class="comment"># def product(numbers):</span></span><br><span class="line"><span class="comment">#     res = 0</span></span><br><span class="line"><span class="comment">#     for n in numbers:</span></span><br><span class="line"><span class="comment">#         res *= n</span></span><br><span class="line"><span class="comment">#     return res</span></span><br></pre></td></tr></table></figure></li>
<li><strong>优化</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化以下 Python 代码，使其运行更高效。</span></span><br><span class="line"><span class="comment"># def expensive_calculation(n):</span></span><br><span class="line"><span class="comment">#     result = 0</span></span><br><span class="line"><span class="comment">#     for i in range(n):</span></span><br><span class="line"><span class="comment">#         for j in range(n):</span></span><br><span class="line"><span class="comment">#             result += i * j</span></span><br><span class="line"><span class="comment">#     return result</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="三、Codex-的工作流程"><a href="#三、Codex-的工作流程" class="headerlink" title="三、Codex 的工作流程"></a>三、Codex 的工作流程</h2><p>Codex 的典型工作流程可以用以下序列图表示：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant User as 用户 (开发者)
    participant IDE as 集成开发环境 (如 VS Code with Copilot)
    participant CopilotPlugin as GitHub Copilot 插件
    participant OpenAI_API as OpenAI Codex API

    User-&gt;&gt;IDE: 1. 在代码编辑器中输入自然语言注释或部分代码
    IDE-&gt;&gt;CopilotPlugin: 2. 插件检测到用户输入或上下文变化
    CopilotPlugin-&gt;&gt;OpenAI_API: 3. 将当前代码上下文 (文件内容, 光标位置, 注释, 用户输入的Prompt等) 发送给 Codex API
    OpenAI_API--&gt;&gt;Codex_Model: 4. Codex 模型根据输入生成代码建议
    Codex_Model--&gt;&gt;OpenAI_API: 5. 返回生成的代码建议
    OpenAI_API--&gt;&gt;CopilotPlugin: 6. 返回代码建议
    CopilotPlugin-&gt;&gt;IDE: 7. 在编辑器中显示代码建议 (通常是灰色文本)
    User-&gt;&gt;IDE: 8. 用户接受、修改或忽略建议
    IDE-&gt;&gt;User: 9. 代码继续编写 (返回步骤 1)
  </pre></div>

<p><strong>关键点</strong>：</p>
<ul>
<li><strong>上下文感知</strong>：Codex 接收的不仅仅是用户输入的指令，还包括整个代码文件的上下文信息（已导入的库、已定义的函数、变量名等），这使得它能够生成与现有代码风格和逻辑一致的代码。</li>
<li><strong>迭代性</strong>：通常情况下，Codex 并不是一次性生成整个复杂程序，而是逐步辅助开发者，通过多次交互，从函数签名到具体实现，再到测试用例。</li>
</ul>
<h2 id="四、Codex-的应用场景"><a href="#四、Codex-的应用场景" class="headerlink" title="四、Codex 的应用场景"></a>四、Codex 的应用场景</h2><p>Codex 的能力使其在多个方面具有巨大的应用潜力：</p>
<ol>
<li><strong>提高开发效率</strong>：快速原型开发、减少重复劳动、降低学习曲线。</li>
<li><strong>教育和学习</strong>：辅助编程新手、代码解释器。</li>
<li><strong>多语言开发</strong>：跨语言辅助。</li>
<li><strong>自动化脚本</strong>：快速生成用于数据处理、文件操作、系统管理等任务的自动化脚本。</li>
<li><strong>无代码&#x2F;低代码平台</strong>：作为后端引擎，将用户的自然语言需求转换为平台可识别的代码或配置。</li>
</ol>
<h2 id="五、Codex-的局限性与挑战"><a href="#五、Codex-的局限性与挑战" class="headerlink" title="五、Codex 的局限性与挑战"></a>五、Codex 的局限性与挑战</h2><p>尽管 Codex 强大，但它并非完美无缺，存在一些重要的局限性和挑战：</p>
<ol>
<li><strong>代码正确性与安全性</strong>：不保证完全正确，可能包含逻辑错误、效率低下或安全漏洞。开发者必须仔细审查和测试。</li>
<li><strong>版权和开源协议问题</strong>：训练数据包含了大量的开源代码，可能引发版权争议。</li>
<li><strong>“黑盒”问题</strong>：决策过程不透明，难以理解错误原因。</li>
<li><strong>创造力有限</strong>：主要基于模式组合，在解决全新或高度抽象的问题时能力有限。</li>
<li><strong>环境依赖性</strong>：生成的代码可能依赖于特定的库版本、环境配置等。</li>
<li><strong>对现有代码的理解深度</strong>：对于大型、复杂且具有特定业务逻辑的代码库，理解深度仍有待提高。</li>
<li><strong>“幻觉”现象 (Hallucination)</strong>：有时会生成看起来合理但实际上并不存在或不起作用的 API 调用。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Codex 是 OpenAI 在代码智能领域的一个里程碑，它通过将自然语言转化为可执行代码，极大地提高了开发效率和可访问性。它已经成为 GitHub Copilot 等工具的核心，改变了许多开发者的日常工作方式。然而，要充分发挥其潜力，开发者需要掌握有效的指令工程（Prompt Engineering）技巧，并将其视为一个强大的“结对程序员”，而非独立完成所有工作的“全能机器”。在人机协作的编程未来中，人类程序员的专业判断、创造力和批判性思维依然是不可或缺的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/b100840425a8/">https://blog.tbf1211.xx.kg/b100840425a8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/">代码生成</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/AI/">AI</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-19.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/fdb8a5195f3e/" title="知识图谱 (Knowledge Graph) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">知识图谱 (Knowledge Graph) 详解</div></div><div class="info-2"><div class="info-item-1"> 知识图谱 (Knowledge Graph, KG) 是一种结构化的知识表示形式，它以图 (Graph) 的形式来描述客观世界中存在的各种实体 (Entities)、概念 (Concepts) 及其之间的关系 (Relations)。通过将离散、异构的信息链接起来，知识图谱构建了一个庞大且相互关联的“知识网络”，使得机器能够像人类一样理解、组织和利用知识，从而支持复杂的推理和智能应用。  核心思想：将现实世界的知识抽象为“实体-关系-实体”或“实体-属性-属性值”的三元组结构，并通过图的形式直观地表示和存储这些知识，从而实现知识的机器可读、可理解和可推理。 它旨在解决传统关系型数据库在表示复杂、动态、多源异构数据时存在的语义鸿沟问题。   一、知识图谱的基本构成知识图谱的核心是其图结构中的基本元素：  实体 (Entities)  定义：指现实世界中具有明确指代和区分度的“事物”或“概念”，可以是具象的（如“苹果公司”、“埃菲尔铁塔”、“约翰·F·肯尼迪”）或抽象的（如“人工智能”、“经济学”、“创新”）。 表示：在知识图谱中，每个实体通常有一个唯一的标识符 (URI&#x2F...</div></div></div></a><a class="pagination-related" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Claude Code 详解：Anthropic 的代码智能模型</div></div><div class="info-2"><div class="info-item-1"> Claude Code 是 Anthropic 公司推出的官方 CLI 工具，专为软件工程设计。它将 Claude 的强大 AI 能力带入终端，帮助开发者完成代码编写、调试、重构、测试等各类编程任务。作为一款专业的 AI 编程助手，Claude Code 特别强调安全性，仅协助处理授权的安全测试、CTF 挑战等合法场景。  核心特性：Claude Code 通过自然语言对话完成复杂编程任务，支持多文件编辑、智能体任务、代码库探索等功能，是提升开发效率的利器。    一、Claude Code 概述1.1 什么是 Claude Code？Claude Code 是 Anthropic 推出的官方命令行界面 (CLI) 工具，它将 Claude AI 模型的能力带入开发者的终端环境。与传统的代码补全工具不同，Claude Code 是一个完整的 AI 编程助手，能够理解项目上下文、执行复杂任务、与文件系统交互，并生成高质量的代码。 作为 Claude Agent SDK 的官方实现，Claude Code 采用了专业的软件工程方法论，强调：  安全性优先：仅协助授权的安全测试和防御...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-16</div><div class="info-item-2">AI 辅助编程的关键要点与代码幻觉防范</div></div><div class="info-2"><div class="info-item-1"> AI 辅助编程，通常指利用大型语言模型 (LLM) 如 GPT、Claude、Copilot 等来帮助开发者完成代码生成、代码补全、错误检查、文档编写等任务。它极大地提高了开发效率，但同时也引入了新的挑战，其中最突出的就是 “代码幻觉 (Code Hallucinations)”。代码幻觉是指 AI 生成了看似合理但实际上错误、不存在、或与需求不符的代码、API 调用或概念。  核心思想：AI 是强大的工具而非万能的替代品。在使用 AI 辅助编程时，开发者必须保持批判性思维，通过有效的“提示工程”和严谨的“人工验证”来驾驭 AI，防止其产生误导性的“代码幻觉”。   一、AI 辅助编程的核心优势与风险1.1 核心优势 提高效率：快速生成样板代码、函数骨架、测试用例等，减少重复劳动。 知识获取：作为“超级Stack Overflow”，快速查询 API 用法、框架最佳实践、算法实现等。 学习辅助：解释复杂代码、概念，帮助新手快速理解。 跨语言&#x2F;框架能力：在不熟悉的语言或框架中提供初步帮助。 重构与优化建议：提出改进代码结构、性能或可读性的建议。  1.2 主要风险 代码...</div></div></div></a><a class="pagination-related" href="/e520aa0d37e4/" title="Ollama 深度解析"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-03</div><div class="info-item-2">Ollama 深度解析</div></div><div class="info-2"><div class="info-item-1"> Ollama 是一个开源项目，旨在简化在本地机器上运行大型语言模型 (LLM) 的过程。它提供了一个易于使用的命令行界面和 API，让用户能够快速下载、运行、创建和管理各种预训练的开源 LLM，如 Llama 2, Mistral, Gemma 等。Ollama 专注于提供流畅的用户体验，使个人开发者、研究人员和企业能够在自己的硬件上，以隐私保护和成本效益的方式探索和利用 LLM 的强大功能。  核心思想：将复杂的大语言模型本地化运行过程封装成简单命令，让用户能轻松部署、交互和定制开源 LLM，实现AI的民主化和去中心化。   一、Ollama 简介随着大语言模型技术的飞速发展，越来越多的开发者和企业希望在本地环境中运行这些模型，以实现数据隐私、降低成本、离线可用以及更灵活的定制化。然而，直接在本地部署和管理 LLM 往往涉及复杂的依赖安装、模型格式转换、GPU 配置等挑战。 Ollama 应运而生，它旨在解决这些痛点，提供一个“一站式”解决方案：  极简的用户体验：通过单个可执行文件和直观的命令行指令，即可完成模型的下载、运行和管理。 广泛的模型支持：支持多种流行的开源 LL...</div></div></div></a><a class="pagination-related" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-05</div><div class="info-item-2">Claude Code 详解：Anthropic 的代码智能模型</div></div><div class="info-2"><div class="info-item-1"> Claude Code 是 Anthropic 公司推出的官方 CLI 工具，专为软件工程设计。它将 Claude 的强大 AI 能力带入终端，帮助开发者完成代码编写、调试、重构、测试等各类编程任务。作为一款专业的 AI 编程助手，Claude Code 特别强调安全性，仅协助处理授权的安全测试、CTF 挑战等合法场景。  核心特性：Claude Code 通过自然语言对话完成复杂编程任务，支持多文件编辑、智能体任务、代码库探索等功能，是提升开发效率的利器。    一、Claude Code 概述1.1 什么是 Claude Code？Claude Code 是 Anthropic 推出的官方命令行界面 (CLI) 工具，它将 Claude AI 模型的能力带入开发者的终端环境。与传统的代码补全工具不同，Claude Code 是一个完整的 AI 编程助手，能够理解项目上下文、执行复杂任务、与文件系统交互，并生成高质量的代码。 作为 Claude Agent SDK 的官方实现，Claude Code 采用了专业的软件工程方法论，强调：  安全性优先：仅协助授权的安全测试和防御...</div></div></div></a><a class="pagination-related" href="/21e140c78f80/" title="大型语言模型如何理解人类文字：从Token到语义表征"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-16</div><div class="info-item-2">大型语言模型如何理解人类文字：从Token到语义表征</div></div><div class="info-2"><div class="info-item-1"> 大型语言模型 (Large Language Models, LLMs) 在处理和生成人类语言方面展现出了前所未有的能力，这引发了一个核心问题：它们是如何“理解”人类文字的？这种理解并非传统意义上的认知或意识，而是通过对海量文本数据中统计模式和语义关联的深度学习，构建出高度复杂的语言表征。  核心思想：LLMs 将人类语言转化为高维数学向量，并通过 Transformer 架构中的注意力机制，捕捉词语、句子乃至篇章间的复杂关联，从而在统计层面模拟人类对语言的理解和生成。   一、基础构建模块：从文本到向量LLMs 的“理解”始于将人类可读的文字转化为机器可处理的数值形式。这一过程主要依赖于分词 (Tokenization) 和词嵌入 (Word Embeddings)。 1.1 分词 (Tokenization)分词是将连续的文本序列切分成有意义的最小单位——Token 的过程。Token 可以是一个词、一个子词 (subword) 甚至一个字符。  词级别分词 (Word-level Tokenization)：以空格或标点符号为界，将文本切分为词。简单直观，但词汇量庞大，且...</div></div></div></a><a class="pagination-related" href="/1bd89b02cd88/" title="大型语言模型中的Token详解：数据、处理与意义"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-20</div><div class="info-item-2">大型语言模型中的Token详解：数据、处理与意义</div></div><div class="info-2"><div class="info-item-1"> Token 是大型语言模型 (Large Language Models, LLMs) 处理文本的基本单位。它不是传统意义上的“词”，而是模型将人类可读的文字序列（如句子、段落）切分、编码并最终用于学习和生成文本的离散符号表示。理解 Token 的概念对于深入了解 LLMs 的工作原理、能力边界以及成本核算至关重要。  核心思想：LLMs 不直接处理原始文本，而是将其分解为一系列经过特殊编码的 Token。这些 Token 构成了模型输入和输出的最小单元，并直接影响模型的性能、效率和成本。   一、什么是 Token？在自然语言处理 (NLP) 领域，尤其是在 LLMs 中，Token 是指模型进行训练和推理时所使用的文本片段。它可能是：  一个完整的词 (Word)：例如 “cat”, “run”。 一个词的一部分 (Subword)：例如 “un”, “believe”, “able” 组合成 “unbelievable”。 一个标点符号 (Punctuation)：例如 “.”, “,”, “!”。 一个特殊符号或控制字符 (Special Token)：例如 [CLS]...</div></div></div></a><a class="pagination-related" href="/33aeea5bfccf/" title="大语言模型参数详解：规模、类型与意义"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-22</div><div class="info-item-2">大语言模型参数详解：规模、类型与意义</div></div><div class="info-2"><div class="info-item-1"> 参数 (Parameters) 是大型语言模型 (Large Language Models, LLMs) 的核心组成部分，它们是模型在训练过程中从海量数据中学习到的数值权重和偏置。这些参数共同构成了模型的“知识”和“理解”能力。参数的规模，尤其是数量，是衡量一个 LLM 大小的关键指标，并直接影响其性能、能力边界以及所需的计算资源。  核心思想：LLMs 的“智能”并非来自于明确的编程规则，而是通过在海量数据上优化数亿甚至数万亿个可学习参数而涌现。这些参数以分布式形式存储了语言的语法、语义、事实知识和世界常识。   一、什么是大语言模型参数？在神经网络的上下文中，参数是指模型在训练过程中需要学习和调整的所有权重 (weights) 和偏置 (biases)。它们是连接神经元之间强度的数值表示，决定了模型的输入如何被转换、处理并最终生成输出。  权重 (Weights)：定义了输入特征（或前一层神经元的输出）对当前神经元输出的贡献程度。一个较大的权重意味着该输入特征对结果有更强的影响。 偏置 (Biases)：是一种加性项，允许激活函数在不依赖任何输入的情况下被激活。它相当于调...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Codex-%E7%9A%84%E8%B5%B7%E6%BA%90%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B"><span class="toc-text">一、Codex 的起源与核心能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%83%8C%E6%99%AF%EF%BC%9AGPT-3-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-text">1.1 背景：GPT-3 的局限性与代码生成的需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Codex-%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E-GitHub-Copilot"><span class="toc-text">1.2 Codex 的诞生与 GitHub Copilot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B"><span class="toc-text">1.3 核心能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86-%E5%9F%BA%E4%BA%8E-GPT-%E6%9E%B6%E6%9E%84"><span class="toc-text">1.4 技术原理 (基于 GPT 架构)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Codex-%E6%8C%87%E4%BB%A4-Prompt-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-text">二、Codex 指令 (Prompt) 的使用技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8F%90%E4%BE%9B%E6%B8%85%E6%99%B0%E4%B8%94%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="toc-text">2.1 提供清晰且具体的任务描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8C%87%E6%98%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%89%88%E6%9C%AC-%E6%A1%86%E6%9E%B6-%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81"><span class="toc-text">2.2 指明编程语言和版本&#x2F;框架 (如果需要)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8F%90%E4%BE%9B%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E7%A4%BA%E4%BE%8B-Few-shot-Learning"><span class="toc-text">2.3 提供输入和输出示例 (Few-shot Learning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%8B%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E4%BB%BB%E5%8A%A1"><span class="toc-text">2.4 拆解复杂任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%A9%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%B3%A8%E9%87%8A"><span class="toc-text">2.5 利用上下文和注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%98%8E%E7%A1%AE%E7%BA%A6%E6%9D%9F%E5%92%8C%E8%A6%81%E6%B1%82"><span class="toc-text">2.6 明确约束和要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E8%BF%AD%E4%BB%A3%E4%B8%8E%E4%BF%AE%E6%AD%A3"><span class="toc-text">2.7 迭代与修正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E9%94%99%E8%AF%AF%E4%BF%AE%E5%A4%8D%E4%B8%8E%E4%BC%98%E5%8C%96%E6%8C%87%E4%BB%A4"><span class="toc-text">2.8 错误修复与优化指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Codex-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">三、Codex 的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Codex-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、Codex 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Codex-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E6%8C%91%E6%88%98"><span class="toc-text">五、Codex 的局限性与挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-19.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>