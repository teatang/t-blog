<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ICMP 协议详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ICMP (Internet Control Message Protocol)，互联网控制消息协议，是 TCP&#x2F;IP 协议族中的一个核心协议。它主要用于在 IP 主机和路由器之间传递控制消息，这些控制消息可以报告数据报的处理错误，或者提供诊断信息。与 IP 协议的“尽力而为”特性不同，ICMP 为网络层提供了基本的错误报告和查询功能，但它本身并不能修复错误，只是提供一个通知机制。IC">
<meta property="og:type" content="article">
<meta property="og:title" content="ICMP 协议详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/f3c9e80cbf78/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="ICMP (Internet Control Message Protocol)，互联网控制消息协议，是 TCP&#x2F;IP 协议族中的一个核心协议。它主要用于在 IP 主机和路由器之间传递控制消息，这些控制消息可以报告数据报的处理错误，或者提供诊断信息。与 IP 协议的“尽力而为”特性不同，ICMP 为网络层提供了基本的错误报告和查询功能，但它本身并不能修复错误，只是提供一个通知机制。IC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-11.jpg">
<meta property="article:published_time" content="2023-07-31T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-25T10:07:56.041Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="UDP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-11.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ICMP 协议详解",
  "url": "https://blog.tbf1211.xx.kg/f3c9e80cbf78/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-11.jpg",
  "datePublished": "2023-07-31T22:24:00.000Z",
  "dateModified": "2026-02-25T10:07:56.041Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/f3c9e80cbf78/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ICMP 协议详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">555</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-11.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">ICMP 协议详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ICMP 协议详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-07-31T22:24:00.000Z" title="发表于 2023-08-01 06:24:00">2023-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>ICMP (Internet Control Message Protocol)</strong>，互联网控制消息协议，是 TCP&#x2F;IP 协议族中的一个核心协议。它主要用于在 IP 主机和路由器之间传递控制消息，这些控制消息可以报告数据报的处理错误，或者提供诊断信息。与 IP 协议的“尽力而为”特性不同，ICMP 为网络层提供了基本的错误报告和查询功能，但它本身并不能修复错误，只是提供一个通知机制。ICMP 消息被封装在 IP 数据报中传输，不提供可靠性保证。</p>
</blockquote>
<div class="note info flat"><p>核心思想：作为 IP 协议的“辅助”协议，ICMP 在网络层提供错误报告和诊断功能，帮助网络设备了解网络状态。</p>
</div>

<hr>
<h2 id="一、为什么需要-ICMP？"><a href="#一、为什么需要-ICMP？" class="headerlink" title="一、为什么需要 ICMP？"></a>一、为什么需要 ICMP？</h2><p>IP 协议是一个无连接、不可靠的“尽力而为”的网络层协议。这意味着 IP 数据报在传输过程中可能丢失、重复、乱序，并且没有任何机制通知发送方这些问题。如果仅仅依赖 IP 协议，当数据报遇到各种网络问题（如目标不可达、路由循环、TTL 超时等）时，发送方将无从得知其数据报的命运。</p>
<p>ICMP 协议的引入正是为了弥补 IP 协议的这一不足：</p>
<ol>
<li><strong>错误报告 (Error Reporting)</strong>：当路由器或目标主机无法处理某个 IP 数据报时（例如目的地不可达、端口不可达、TTL 超时等），ICMP 协议会生成一个错误报告消息发送给原始发送方。</li>
<li><strong>诊断功能 (Diagnostic Function)</strong>：主要用于网络管理员诊断网络问题，例如 <code>ping</code> 命令利用 ICMP Echo Request&#x2F;Reply 消息来测试主机的可达性和测量往返时间 (RTT)。</li>
<li><strong>查询功能 (Query Function)</strong>：允许主机或路由器查询其他主机的网络信息（如时间戳、地址掩码等，不过部分查询功能已被弃用或有更好的替代）。</li>
</ol>
<p>ICMP 消息被封装在 IP 数据报的数据部分中，其 IP 报头中的 Protocol 字段值为 1 (<code>0x01</code>) 表示内容是 ICMP 消息。</p>
<h2 id="二、ICMP-报文格式"><a href="#二、ICMP-报文格式" class="headerlink" title="二、ICMP 报文格式"></a>二、ICMP 报文格式</h2><p>ICMP 报文的基本格式相对简单，但在其通用报头之后，会根据不同的消息类型 (Type) 和代码 (Code) 包含不同的数据字段。</p>
<p><strong>ICMP 报文通用报头结构</strong>:</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">长度（字节）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Type</strong></td>
<td align="left">1</td>
<td align="left">ICMP 消息的类型。例如，<code>0</code> 表示 Echo Reply，<code>8</code> 表示 Echo Request，<code>3</code> 表示 Destination Unreachable。</td>
</tr>
<tr>
<td align="left"><strong>Code</strong></td>
<td align="left">1</td>
<td align="left">ICMP 消息类型的子类型，提供更具体的错误或查询信息。例如，对于 Type 3 (Destination Unreachable)，Code 为 <code>0</code> 表示 Network Unreachable，<code>1</code> 表示 Host Unreachable，<code>4</code> 表示 Fragmentation Needed (DF set)。</td>
</tr>
<tr>
<td align="left"><strong>Checksum</strong></td>
<td align="left">2</td>
<td align="left">整个 ICMP 报文（包括报头和数据）的 16 位校验和。计算方法与 IP 头部校验和类似：所有 16 位字的和的补码。</td>
</tr>
<tr>
<td align="left"><strong>Rest of Header</strong></td>
<td align="left">4 或更多</td>
<td align="left">这个字段的含义取决于 Type 和 Code 字段的值。对于某些消息类型，它可能包含 Identifier (标识符) 和 Sequence Number (序列号)；对于错误报告消息，它可能包含 unused 字段。</td>
</tr>
<tr>
<td align="left"><strong>Data</strong></td>
<td align="left">可变</td>
<td align="left">实际的 ICMP 数据。对于错误报告消息，它通常包含导致错误的原 IP 报头和原 IP 报文数据的前 8 个字节。</td>
</tr>
</tbody></table>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    A[IP 报文] --&gt; B[IP 头部]
    A --&gt; C[IP 数据部分]

    C --&gt; D[ICMP 报文]
    D --&gt; E[&quot;Type (1 Byte)&quot;]
    D --&gt; F[&quot;Code (1 Byte)&quot;]
    D --&gt; G[&quot;Checksum (2 Bytes)&quot;]
    D --&gt; H[&quot;Rest of Header (4+ Bytes)&quot;]
    D --&gt; I[&quot;Data (Variable Bytes)&quot;]

    subgraph &quot;Rest of Header&quot;
        H1{&quot;Identifier (2 Bytes)&quot;} --&gt; H
        H2{&quot;Sequence Number (2 Bytes)&quot;} --&gt; H
        H3{&quot;Unused (4 Bytes)&quot;} --&gt; H
        H4{Other Type-Specific Fields} --&gt; H
    end

    subgraph &quot;Data (for Error Messages)&quot;
        I1{Original IP Header} --&gt; I
        I2{First 8 Bytes of Original IP Data} --&gt; I
    end
  </pre></div>

<h2 id="三、ICMP-消息类型和代码"><a href="#三、ICMP-消息类型和代码" class="headerlink" title="三、ICMP 消息类型和代码"></a>三、ICMP 消息类型和代码</h2><p>ICMP 消息大致可以分为两类：<strong>错误报告消息 (Error Reporting Messages)</strong> 和 <strong>查询消息 (Query Messages)</strong>。</p>
<h3 id="3-1-错误报告消息"><a href="#3-1-错误报告消息" class="headerlink" title="3.1 错误报告消息"></a>3.1 错误报告消息</h3><p>这类消息用于通知发送方在数据报处理过程中遇到的问题。通常，ICMP 错误消息中会包含<strong>导致错误的原 IP 报头</strong>以及<strong>原 IP 报文数据的前 8 个字节</strong>，以便发送方能够识别是哪个数据报出了问题。</p>
<ol>
<li><p><strong>目标不可达 (Destination Unreachable - Type 3)</strong>：<br>当路由器或主机无法将数据包交付给目标时发送。</p>
<ul>
<li><code>Code 0</code>: 网络不可达 (Network Unreachable)</li>
<li><code>Code 1</code>: 主机不可达 (Host Unreachable)</li>
<li><code>Code 2</code>: 协议不可达 (Protocol Unreachable)</li>
<li><code>Code 3</code>: 端口不可达 (Port Unreachable)</li>
<li><code>Code 4</code>: 需要分片但设置了 Dont Fragment (DF) 位 (Fragmentation Needed and DF Set) - 常用于 Path MTU Discovery。</li>
<li><code>Code 5</code>: 源路由失败 (Source Route Failed)</li>
<li>… (及其他更少见的 Code)</li>
</ul>
</li>
<li><p><strong>源站抑制 (Source Quench - Type 4)</strong>：<br>（RFC 792 规定，RFC 6633 弃用）当路由器或主机缓存区溢出，无法处理更多数据时，发送此消息通知源主机放慢发送速度。在现代网络中，通常通过更上层的流量控制机制（如 TCP 拥塞控制）来管理，ICMP Source Quench 几乎不再使用，甚至被许多设备禁用，以避免其自身成为攻击工具。</p>
</li>
<li><p><strong>重定向 (Redirect - Type 5)</strong>：<br>当路由器发现有一个更好的路径（同一子网内的另一台路由器）可以到达目标主机或网络时，会向原始发送方发送此消息。</p>
<ul>
<li><code>Code 0</code>: 为网络重定向 (Redirect Datagram for the Network)</li>
<li><code>Code 1</code>: 为主机重定向 (Redirect Datagram for the Host)</li>
<li><code>Code 2</code>: 为服务类型和网络重定向 (Redirect Datagram for the Type of Service and Network)</li>
<li><code>Code 3</code>: 为服务类型和主机重定向 (Redirect Datagram for the Type of Service and Host)</li>
</ul>
</li>
<li><p><strong>超时 (Time Exceeded - Type 11)</strong>：</p>
<ul>
<li><code>Code 0</code>: 传输中 TTL 超时 (TTL Expired in Transit) - 主要用于 <code>traceroute</code> 工具。当数据包的 IP 头部的 TTL (Time To Live) 字段减为 0 时，路由器会丢弃该数据包并发送此消息。</li>
<li><code>Code 1</code>: 片段重组超时 (Fragment Reassembly Time Exceeded) - 当分片的 IP 包无法在规定时间内被目标主机重组成完整数据包时发送。</li>
</ul>
</li>
<li><p><strong>参数问题 (Parameter Problem - Type 12)</strong>：<br>当路由器或主机在处理 IP 头部或数据部分时发现了一个无效的参数。</p>
<ul>
<li><code>Code 0</code>: 指示错误报头中的哪个字段有问题。</li>
</ul>
</li>
</ol>
<h3 id="3-2-查询消息"><a href="#3-2-查询消息" class="headerlink" title="3.2 查询消息"></a>3.2 查询消息</h3><p>这类消息主要用于主机或路由器之间进行信息查询和诊断。</p>
<ol>
<li><p><strong>回显请求&#x2F;应答 (Echo Request&#x2F;Reply - Type 8&#x2F;0)</strong>：<br>最著名的 ICMP 消息，由 <code>ping</code> 工具使用。</p>
<ul>
<li><code>Type 8, Code 0</code>: Echo Request (请求)</li>
<li><code>Type 0, Code 0</code>: Echo Reply (应答)</li>
<li>包含 Identifier (进程 ID 或其他唯一标识) 和 Sequence Number (顺序号)，用于匹配请求和应答。数据部分通常填充任意字节，用于测量往返时间。</li>
</ul>
</li>
<li><p><strong>时间戳请求&#x2F;应答 (Timestamp Request&#x2F;Reply - Type 13&#x2F;14)</strong>：<br>用于测量往返时间以及同步时钟（不常用，有 NTP 等更专业的协议）。</p>
<ul>
<li><code>Type 13, Code 0</code>: Timestamp Request</li>
<li><code>Type 14, Code 0</code>: Timestamp Reply</li>
<li>包含 Originate Timestamp (请求发送时间), Receive Timestamp (到达应答方时间), Transmit Timestamp (应答方发送时间)。</li>
</ul>
</li>
<li><p><strong>地址掩码请求&#x2F;应答 (Address Mask Request&#x2F;Reply - Type 17&#x2F;18)</strong>：<br>（已被弃用）主机使用此消息来发现其所在网络的子网掩码。在 ARP、DHCP 和 IP 配置静态化后，此功能不再需要。</p>
</li>
<li><p><strong>信息请求&#x2F;应答 (Information Request&#x2F;Reply - Type 15&#x2F;16)</strong>：<br>（已被弃用）用于获取网络号信息。</p>
</li>
</ol>
<h2 id="四、常见应用和工具"><a href="#四、常见应用和工具" class="headerlink" title="四、常见应用和工具"></a>四、常见应用和工具</h2><p>ICMP 在网络诊断和管理中扮演着不可或缺的角色。</p>
<h3 id="4-1-Ping-Packet-Internet-Groper"><a href="#4-1-Ping-Packet-Internet-Groper" class="headerlink" title="4.1 Ping (Packet Internet Groper)"></a>4.1 Ping (Packet Internet Groper)</h3><p><code>ping</code> 命令是网络管理员日常使用的最基本工具之一，它利用 ICMP Echo Request 和 Echo Reply 消息来：</p>
<ul>
<li><strong>测试主机可达性</strong>：判断目标主机是否在线且响应。</li>
<li><strong>测量往返时间 (RTT)</strong>：评估网络延迟。</li>
<li><strong>检查丢包率</strong>：评估网络连接质量。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PING www.google.com (142.250.76.100): 56 data bytes</span><br><span class="line">64 bytes from 142.250.76.100: icmp_seq=0 ttl=118 time=19.183 ms</span><br><span class="line">64 bytes from 142.250.76.100: icmp_seq=1 ttl=118 time=19.167 ms</span><br><span class="line">64 bytes from 142.250.76.100: icmp_seq=2 ttl=118 time=19.171 ms</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 19.167/19.174/19.183/0.007 ms</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Traceroute-或-Tracert"><a href="#4-2-Traceroute-或-Tracert" class="headerlink" title="4.2 Traceroute (或 Tracert)"></a>4.2 Traceroute (或 Tracert)</h3><p><code>traceroute</code> （在 Windows 上是 <code>tracert</code>）命令用于显示 IP 数据包从源主机到目的主机所经过的路由路径。它利用了 ICMP 的 <code>Time Exceeded</code> 消息。</p>
<p><strong>工作原理:</strong></p>
<ol>
<li>发送一个目的地址为目标主机、TTL 设置为 1 的数据包（通常是 UDP 数据报或 ICMP Echo Request）。</li>
<li>路径上的第一个路由器收到数据包后，将 TTL 减 1（变为 0），然后丢弃数据包，并向源主机发送一个 ICMP <code>Time Exceeded (Type 11, Code 0)</code> 消息。</li>
<li>源主机收到此消息后，记录下第一个路由器的 IP 地址。</li>
<li>接着，源主机发送一个 TTL 设置为 2 的数据包，路径上的第二个路由器会发送 <code>Time Exceeded</code> 消息。</li>
<li>这个过程一直重复，直到数据包到达目标主机。目标主机收到数据包后，如果使用的是 UDP 探测（通常探测一个不可能的端口），会返回一个 ICMP <code>Destination Unreachable (Type 3, Code 3 - Port Unreachable)</code> 消息；如果使用的是 ICMP Echo Request 探测，则返回 ICMP <code>Echo Reply (Type 0, Code 0)</code>。</li>
<li>源主机根据收到的这些 ICMP 消息，构建出完整的路由路径。</li>
</ol>
<p><strong>示例:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.google.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">traceroute to www.google.com (142.250.76.100), 64 hops max, 52 byte packets</span><br><span class="line"> 1  router.example.com (192.168.1.1)  1.234 ms  1.107 ms  1.171 ms</span><br><span class="line"> 2  isp-gw-1.example.com (X.X.X.X)  5.678 ms  5.801 ms  5.723 ms</span><br><span class="line"> 3  isp-router-2.example.com (Y.Y.Y.Y)  12.345 ms  12.500 ms  12.400 ms</span><br><span class="line"> ...</span><br><span class="line"> 8  sfo03s17-in-f4.1e100.net (142.250.76.100)  18.900 ms  18.912 ms  19.001 ms</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Path-MTU-Discovery-PMTUD"><a href="#4-3-Path-MTU-Discovery-PMTUD" class="headerlink" title="4.3 Path MTU Discovery (PMTUD)"></a>4.3 Path MTU Discovery (PMTUD)</h3><p>PMTUD 是一种确定在源和目的之间 IP 路径上可以传输的最大传输单元 (MTU) 的技术。它利用了 ICMP <code>Destination Unreachable (Type 3, Code 4)</code> 消息。</p>
<p><strong>工作原理:</strong></p>
<ol>
<li>源主机发送 IP 数据包时，将 IP 头部中的 <code>Don&#39;t Fragment (DF)</code> 位设置为 1。</li>
<li>如果在路径中的某个路由器需要对该数据包进行分片，但由于 <code>DF</code> 位设置为 1 而无法分片，则该路由器会丢弃数据包，并向源主机发送一个 ICMP <code>Destination Unreachable (Type 3, Code 4)</code> 消息。</li>
<li>这个 ICMP 消息中会包含该路由器接口的 MTU 大小。</li>
<li>源主机收到这个消息后，会减小其发送数据包的 MTU 大小，然后重新发送。</li>
<li>这个过程重复，直到找到路径上最小的 MTU（即路径 MTU）。</li>
</ol>
<h2 id="五、ICMPv4-的安全考量"><a href="#五、ICMPv4-的安全考量" class="headerlink" title="五、ICMPv4 的安全考量"></a>五、ICMPv4 的安全考量</h2><p>由于 ICMP 消息的性质，它也常常被恶意利用：</p>
<ol>
<li><strong>拒绝服务 (DoS) 攻击</strong>：<ul>
<li><strong>Ping Flood (ICMP Flood)</strong>：攻击者向目标主机发送大量的 ICMP Echo Request 消息，以耗尽目标带宽或 CPU 资源。</li>
<li><strong>Smurf Attack</strong>：利用 ICMP Echo Request 向一个网络的广播地址发送数据包，并伪造源 IP 地址为受害者。网络中的所有主机都会响应并向受害者发送 Echo Reply，从而放大攻击流量。</li>
</ul>
</li>
<li><strong>网络侦察 (Network Reconnaissance)</strong>：攻击者可以利用 ICMP 消息来探测网络拓扑、发现活动主机、甚至通过分析 ICMP 错误消息来推断目标操作系统类型。</li>
<li><strong>路由操控 (Routing Manipulation)</strong>：伪造 ICMP Redirect 消息可能诱使主机向错误的路由器发送数据包，从而进行中间人攻击或流量劫持。</li>
<li><strong>死机 ping (Ping of Death)</strong>：发送一个超大尺寸的 Ping 包，超过 IP 数据报的最大长度限制 (65535 字节)。虽然现代操作系统已经能够处理，但在过去曾导致系统崩溃。</li>
</ol>
<p><strong>缓解措施</strong>：</p>
<ul>
<li><strong>防火墙规则</strong>：配置防火墙以限制不同类型 ICMP 消息的通过。例如，可以阻断进来的 ICMP Echo Request 以隐藏主机，但通常允许 Echo Reply 以进行出站连接的诊断。</li>
<li><strong>速率限制 (Rate Limiting)</strong>：限制 ICMP 消息的发送和接收速率，防止洪水攻击。</li>
<li><strong>禁用不必要的 ICMP 消息</strong>：如 Source Quench 和 Address Mask Request&#x2F;Reply。</li>
</ul>
<h2 id="六、ICMPv6-IPv6-的-ICMP"><a href="#六、ICMPv6-IPv6-的-ICMP" class="headerlink" title="六、ICMPv6 (IPv6 的 ICMP)"></a>六、ICMPv6 (IPv6 的 ICMP)</h2><p>随着 IPv6 的部署，ICMP 也发展到了 <strong>ICMPv6</strong> (Internet Control Message Protocol for IPv6)。ICMPv6 不仅仅是 IPv4 ICMP 的简单升级，它在 IPv6 协议族中扮演着更为核心的角色：</p>
<ul>
<li><strong>错误报告和诊断</strong>：与 ICMPv4 类似，报告错误和进行诊断。</li>
<li><strong>邻居发现 (Neighbor Discovery Protocol, NDP)</strong>：ICMPv6 承担了 IPv4 中 ARP 的功能，用于确定邻居的链路层地址。</li>
<li><strong>路由器发现 (Router Discovery)</strong>：代替了 IPv4 中一些路由协议的功能，允许主机发现链路上存在的路由器。</li>
<li><strong>前缀发现 (Prefix Discovery)</strong>：允许主机发现本地链路上的网络前缀。</li>
<li><strong>自动配置 (Stateless Address Autoconfiguration, SLAAC)</strong>：路由器通过 ICMPv6 消息向主机发布网络配置信息。</li>
</ul>
<p>ICMPv6 是 IPv6 协议栈不可或缺的一部分，其功能比 ICMPv4 更为丰富和重要。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>ICMP 协议是 TCP&#x2F;IP 协议族中一个看似辅助但实际至关重要的组成部分。它通过提供错误报告和诊断功能，有效地弥补了 IP 协议无连接、不可靠的特性，使得网络管理者能够及时发现和解决网络问题。从简单的 <code>ping</code> 到复杂的 <code>traceroute</code> 和 <code>PMTUD</code>，ICMP 的消息类型和代码是理解网络行为和诊断故障的关键。同时，由于其在网络层的直接作用，对 ICMP 消息的正确管理和过滤，也是网络安全策略中不可忽视的一环。在 IPv6 中，ICMPv6 的作用更是被提升到了核心地位，成为实现 IPv6 许多基本功能的基石。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/f3c9e80cbf78/">https://blog.tbf1211.xx.kg/f3c9e80cbf78/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/UDP/">UDP</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/892037383fe2/" title="MathJax 详解：在 Web 上优雅地渲染数学公式"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MathJax 详解：在 Web 上优雅地渲染数学公式</div></div><div class="info-2"><div class="info-item-1"> MathJax 是一个开源的 JavaScript 显示引擎，用于在所有现代浏览器中显示数学公式。它以高性能渲染高质量的排版，支持广泛使用的数学标记语言，如 LaTeX、MathML 和 AsciiMath。MathJax 的目标是让网页上的数学内容能够像桌面排版软件那样清晰、美观、易读，同时保持可访问性和可搜索性。  核心思想： MathJax 使得在浏览器中显示复杂的数学公式变得简单、美观且无需安装任何插件或字体。它将数学标记语言转换为网页上可渲染的图形元素（通常是 HTML + CSS 或 SVG），确保跨平台和设备的显示一致性。   一、为什么选择 MathJax？在 Web 上显示数学公式一直是一个挑战。传统的解决方案包括：  图片 (Images)：将公式渲染成图片。 缺点：不清晰（特别是缩放时）、不易编辑、不可搜索、不能复制文本、可访问性差（屏幕阅读器无法识别）。   纯文本 (Plain Text)：使用 ASCII 字符近似表示公式（如 x^2 + y^2 = r^2）。 缺点：可读性极差，无法表达复杂结构。   MathML (Mathematical Ma...</div></div></div></a><a class="pagination-related" href="/0fe4ebbe0d37/" title="Fish Shell 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Fish Shell 详解</div></div><div class="info-2"><div class="info-item-1"> Fish Shell (Friendly Interactive Shell) 是一个专为交互式使用而设计的类 Unix Shell。与 Bash 或 Zsh 等传统 Shell 不同，Fish 的核心设计哲学是提供开箱即用 (out-of-the-box) 的用户友好体验，它默认集成了许多现代化功能，如语法高亮、自动建议和 Web 配置界面，致力于让命令行工作更加便捷和高效，而无需复杂的配置。  核心思想：“Friendly” 是 Fish Shell 的核心，它预装了许多提升用户体验的功能，减少了用户手动配置的负担，让命令行操作更加智能、直观。   一、为什么选择 Fish Shell？传统的 Shell (如 Bash, Zsh) 功能强大且高度可定制，但它们的许多高级特性需要用户投入大量时间进行配置，例如：  语法高亮：需要额外安装插件。 自动建议：需要额外安装插件，如 Zsh 的 zsh-autosuggestions。 灵活的Tab补全：需要复杂的配置。 更友好的错误提示：通常需要手动配置。  对于许多用户而言，尤其是那些刚接触命令行或希望减少配置时间的开发者，这些...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a><a class="pagination-related" href="/9be87a9e79b5/" title="KCP协议详解：一个快速可靠的UDP上层协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-13</div><div class="info-item-2">KCP协议详解：一个快速可靠的UDP上层协议</div></div><div class="info-2"><div class="info-item-1"> KCP (Fast and Reliable UDP protocol) 是一个由 skywind3000 (吴云) 在 2014 年开源的快速可靠的 UDP 上层协议。它的设计目标是在网络状况不佳（高延迟、高丢包率）的环境下，提供比 TCP 更快的传输速度和更低的延迟，同时保持数据的可靠性。KCP 并不是一个完整的网络协议栈，而是一个可嵌入式的库，它运行在 UDP 协议之上，提供了 TCP 所具备的可靠性、流量控制和拥塞控制等机制，但针对延迟和重传进行了优化。  核心思想：在保障数据可靠性的前提下，通过优化重传机制、激进发送和控制重传间隔等方法，尽可能地减少传输延迟，以适应游戏、实时音视频等对延迟高度敏感的应用。   一、为什么需要 KCP？TCP 协议是互联网上最常用的可靠传输协议，但它在一些场景下存在明显的局限性：  慢启动 (Slow Start)：TCP 为了避免网络拥塞，在连接建立初期会限制发送速率，逐渐增加。这对于短连接或突发数据传输会增加初始延迟。 队头阻塞 (Head-of-Line Blocking, HOLB)：TCP 的报文是严格按序到达的。如果某个数据...</div></div></div></a><a class="pagination-related" href="/c5be75f3ed25/" title="WebSocket 详解：实现全双工实时通信"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="info-item-2">WebSocket 详解：实现全双工实时通信</div></div><div class="info-2"><div class="info-item-1"> WebSocket 是一种在单个 TCP 连接上进行全双工（Full-Duplex）通信的网络协议。它在 Web 浏览器和服务器之间提供了一个持久化的连接，允许双方在任何时候发送消息，而无需像传统的 HTTP 请求那样需要先发送请求再接收响应。WebSocket 解决了传统 Web 应用中实现实时通信的诸多难题，是构建实时 Web 应用的关键技术之一。  核心思想：从 HTTP 协议“握手”后，将底层 TCP 连接“升级”为 WebSocket 连接，实现客户端与服务器之间长时间、双向、无阻塞的消息传输，从而大幅降低通信开销，提升实时应用的性能。   一、为什么需要 WebSocket？传统 HTTP 的局限性在 WebSocket 出现之前，Web 应用程序要实现实时通信，如聊天室、股票行情、在线游戏、推送通知等，面临着传统 HTTP 协议的固有局限性：  半双工 (Half-Duplex) 通信：HTTP 协议是单向请求-响应模型。客户端发送请求，服务器返回响应。服务器无法主动向客户端发送消息，除非客户端先发起请求。 效率低下： 频繁连接建立与断开：每个 HTTP 请求都需...</div></div></div></a><a class="pagination-related" href="/058452c6e7a6/" title="TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="info-item-2">TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石</div></div><div class="info-2"><div class="info-item-1"> TCP (Transmission Control Protocol)，即传输控制协议，是 Internet 协议套件 (Internet Protocol Suite) 中的核心协议之一，位于传输层。它提供可靠的、面向连接的、基于字节流的全双工通信服务。TCP 协议确保了数据能够按序、无差错地从一个应用进程传输到另一个应用进程。  核心思想：在不可靠的 IP 层之上，通过一系列机制（如序号、确认、重传、流量控制、拥塞控制）构建一个高度可靠、有序的数据传输通道。   一、为什么需要 TCP？在网络模型中，IP 协议（网络层）提供了尽力而为 (best-effort) 的数据报服务，它不保证数据包的到达、顺序或不重复。然而，大多数应用（如网页浏览、文件传输、电子邮件）都需要一个可靠的数据传输服务。TCP 正是为了弥补 IP 协议的这些不足而设计的，它在应用层和网络层之间提供了一个可靠的、虚拟的通信管道。 TCP 的主要职责包括：  可靠性：确保数据无损、无错地到达目的地。 有序性：确保数据包以正确的顺序交付给接收方。 流量控制：防止发送方发送数据过快，导致接收方缓冲区溢出。 拥塞...</div></div></div></a><a class="pagination-related" href="/425bf08190fa/" title="TLS Encrypted Client Hello (ECH) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="info-item-2">TLS Encrypted Client Hello (ECH) 详解</div></div><div class="info-2"><div class="info-item-1"> TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。  核心思想：在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。   一、为什么需要 ECH？SNI 的隐私痛点在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：明文 SNI (Server Name Indication)。 1.1 SNI 的作用SNI 是 TLS 协议的一个扩展，用于解决虚拟主机 (Virtual Hosting) 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 example.com 和 another.c...</div></div></div></a><a class="pagination-related" href="/7bd4a820ad36/" title="TCP&#x2F;IP协议栈深度详解：因特网的核心基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-11</div><div class="info-item-2">TCP&#x2F;IP协议栈深度详解：因特网的核心基石</div></div><div class="info-2"><div class="info-item-1"> TCP&#x2F;IP 协议 (Transmission Control Protocol&#x2F;Internet Protocol) 是一组用于互联网通信的协议集合，通常被称为 TCP&#x2F;IP 协议族 (TCP&#x2F;IP Protocol Suite) 或 TCP&#x2F;IP 协议栈 (TCP&#x2F;IP Protocol Stack)。它是现代互联网和局域网 (LAN) 的基石，定义了数据如何在网络中传输、路由和接收。TCP&#x2F;IP 协议族以其分层结构而闻名，将复杂的网络通信任务分解为更小、更易于管理的子任务。  核心思想：将复杂的网络通信过程划分为独立的层次，每层负责特定的功能，并通过协议进行协作，从而实现高效、可靠且可扩展的全球通信。   一、为什么需要 TCP&#x2F;IP 协议？在计算机网络发展的早期，各种网络设备和操作系统拥有各自不兼容的通信协议，导致不同厂商的设备之间难以互联互通。为了解决这一问题，美国国防部高级研究计划局 (ARPA) 资助开发了 ARPANET 项目，并在此基础上逐步发展出了 TCP&#x2F;IP 协议。...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">555</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">232</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ICMP%EF%BC%9F"><span class="toc-text">一、为什么需要 ICMP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ICMP-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">二、ICMP 报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ICMP-%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BB%A3%E7%A0%81"><span class="toc-text">三、ICMP 消息类型和代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E6%B6%88%E6%81%AF"><span class="toc-text">3.1 错误报告消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%9F%A5%E8%AF%A2%E6%B6%88%E6%81%AF"><span class="toc-text">3.2 查询消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">四、常见应用和工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Ping-Packet-Internet-Groper"><span class="toc-text">4.1 Ping (Packet Internet Groper)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Traceroute-%E6%88%96-Tracert"><span class="toc-text">4.2 Traceroute (或 Tracert)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Path-MTU-Discovery-PMTUD"><span class="toc-text">4.3 Path MTU Discovery (PMTUD)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ICMPv4-%E7%9A%84%E5%AE%89%E5%85%A8%E8%80%83%E9%87%8F"><span class="toc-text">五、ICMPv4 的安全考量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ICMPv6-IPv6-%E7%9A%84-ICMP"><span class="toc-text">六、ICMPv6 (IPv6 的 ICMP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e3b0c5d197a/" title="Web Components 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Components 详解"/></a><div class="content"><a class="title" href="/4e3b0c5d197a/" title="Web Components 详解">Web Components 详解</a><time datetime="2026-02-07T22:24:00.000Z" title="发表于 2026-02-08 06:24:00">2026-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="婴儿早期语音发展中的“Mama”与“Baba”现象探究"/></a><div class="content"><a class="title" href="/ecb44ccf1b04/" title="婴儿早期语音发展中的“Mama”与“Baba”现象探究">婴儿早期语音发展中的“Mama”与“Baba”现象探究</a><time datetime="2026-02-05T22:24:00.000Z" title="发表于 2026-02-06 06:24:00">2026-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-11.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>