<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker Swarm 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker Swarm 是 Docker 官方提供的原生容器编排工具。它将一组 Docker 主机（宿主机）聚合成一个集群，并将这些主机视为单个虚拟的 Docker 主机。通过 Docker Swarm，用户可以轻松地部署、管理和扩展在多个节点上运行的容器化应用程序。它简化了容器集群的搭建和管理，特别适合那些希望在不引入过多复杂性的情况下，实现容器高可用和负载均衡的用户。  核心思想：将多台物">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker Swarm 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/56481bc27387/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Docker Swarm 是 Docker 官方提供的原生容器编排工具。它将一组 Docker 主机（宿主机）聚合成一个集群，并将这些主机视为单个虚拟的 Docker 主机。通过 Docker Swarm，用户可以轻松地部署、管理和扩展在多个节点上运行的容器化应用程序。它简化了容器集群的搭建和管理，特别适合那些希望在不引入过多复杂性的情况下，实现容器高可用和负载均衡的用户。  核心思想：将多台物">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg">
<meta property="article:published_time" content="2023-11-18T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-29T03:51:22.321Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="容器技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker Swarm 详解",
  "url": "https://blog.tbf1211.xx.kg/56481bc27387/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg",
  "datePublished": "2023-11-18T22:24:00.000Z",
  "dateModified": "2025-12-29T03:51:22.321Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/56481bc27387/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker Swarm 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">441</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-22.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker Swarm 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Docker Swarm 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-18T22:24:00.000Z" title="发表于 2023-11-19 06:24:00">2023-11-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Docker Swarm</strong> 是 Docker 官方提供的原生容器编排工具。它将一组 Docker 主机（宿主机）聚合成一个集群，并将这些主机视为单个虚拟的 Docker 主机。通过 Docker Swarm，用户可以轻松地部署、管理和扩展在多个节点上运行的容器化应用程序。它简化了容器集群的搭建和管理，特别适合那些希望在不引入过多复杂性的情况下，实现容器高可用和负载均衡的用户。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<br><strong>将多台物理机&#x2F;虚拟机抽象成一个统一的资源池，并提供原生 Docker API 接口，从而实现容器的集群化部署、服务发现、负载均衡和故障恢复。</strong></p>
</div>

<hr>
<h2 id="一、为什么需要-Docker-Swarm？"><a href="#一、为什么需要-Docker-Swarm？" class="headerlink" title="一、为什么需要 Docker Swarm？"></a>一、为什么需要 Docker Swarm？</h2><p>Docker Compose 解决了单机多容器应用的编排问题，但现代分布式应用程序通常需要运行在多台服务器（节点）上，以实现：</p>
<ol>
<li><strong>高可用性 (High Availability)</strong>：单个节点故障不影响整个应用程序的运行。</li>
<li><strong>负载均衡 (Load Balancing)</strong>：将流量均匀分配到多个容器实例，提高应用程序的响应速度和吞吐量。</li>
<li><strong>伸缩性 (Scalability)</strong>：根据需求动态增加或减少应用程序的容器实例数量。</li>
<li><strong>滚动更新 (Rolling Updates)</strong>：在不停机的情况下，逐步更新应用程序版本。</li>
<li><strong>服务发现 (Service Discovery)</strong>：集群中的服务能够自动发现并相互通信。</li>
</ol>
<p>传统手动在多台服务器上管理容器、端口映射、网络配置非常复杂且容易出错。Docker Swarm 的出现就是为了解决这些问题，提供一个简单易用的容器集群管理方案。</p>
<h2 id="二、Docker-Swarm-核心概念"><a href="#二、Docker-Swarm-核心概念" class="headerlink" title="二、Docker Swarm 核心概念"></a>二、Docker Swarm 核心概念</h2><ol>
<li><strong>Swarm (集群)</strong>：<ul>
<li>由多个 Docker 主机组成的集群，共同运行容器化应用程序。</li>
<li>集群中的每个 Docker 主机都被称为一个<strong>节点 (Node)</strong>。</li>
</ul>
</li>
<li><strong>Node (节点)</strong>：<ul>
<li>参与 Swarm 集群的 Docker 主机。节点分为两种角色：<ul>
<li><strong>Manager Node (管理节点)</strong>：负责 Swarm 集群的健康状态维护、工作节点的管理、调度服务任务以及处理 Swarm API 请求。管理节点之间可以有多个来提供高可用性 (RAFT 协议)。</li>
<li><strong>Worker Node (工作节点)</strong>：负责接收并执行管理节点分配的容器任务。它们是实际运行应用程序容器的节点。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Service (服务)</strong>：<ul>
<li>在 Swarm 中运行的应用程序的定义。一个服务定义了要使用的 Docker 镜像、开放的端口、运行的副本数量、网络配置、存储卷等。</li>
<li>服务可以是<strong>全局服务 (Global Service)</strong>，即在每个可用的工作节点上运行一个任务实例；也可以是<strong>副本服务 (Replicated Service)</strong>，即指定在集群中运行固定数量的任务实例。</li>
</ul>
</li>
<li><strong>Task (任务)</strong>：<ul>
<li>服务的一个运行实例，是 Swarm 中调度的原子单位。</li>
<li>在工作节点上运行一个容器以及其相关的命令。</li>
<li>管理节点接收服务定义，将其分解为一系列任务，并分发给工作节点执行。</li>
</ul>
</li>
<li><strong>Desired State (期望状态)</strong>：<ul>
<li>你通过服务定义向 Swarm 声明的应用程序的理想状态（例如，某服务应运行 3 个副本）。</li>
<li>Swarm 会持续监控集群状态，并自动采取行动以使其达到期望状态，这实现了自愈和弹性。</li>
</ul>
</li>
<li><strong>Load Balancing (负载均衡)</strong>：<ul>
<li>Docker Swarm 拥有内置的 DNS 服务发现和路由网格 (Routing Mesh)。</li>
<li>当外部请求访问 Swarm 暴露的任意节点上的服务端口时，路由网格会将请求转发到集群中任意一个正在运行该服务任务的容器实例上。</li>
</ul>
</li>
<li><strong>Ingress Network (入口网络)</strong>：<ul>
<li>Docker Swarm 的路由网格基于 Ingress 网络实现。这是一个特殊的层 7 负载均衡器，使得你可以通过集群中的任何节点 IP 访问任何服务，即使该服务容器不在该节点上运行。</li>
</ul>
</li>
</ol>
<h2 id="三、Docker-Swarm-架构"><a href="#三、Docker-Swarm-架构" class="headerlink" title="三、Docker Swarm 架构"></a>三、Docker Swarm 架构</h2><p>Docker Swarm 集群由一个或多个管理节点和零个或多个工作节点组成。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph Swarm Cluster
        Manager1[Manager Node 1] &lt;--&gt;|RAFT| Manager2[Manager Node 2]
        Manager1 --- Worker1[Worker Node 1]
        Manager1 --- Worker2[Worker Node 2]
        Manager2 --- Worker3[Worker Node 3]
      
        linkStyle 0 stroke:red,stroke-width:2px;
        linkStyle 1 stroke:blue,stroke-width:1px;
        linkStyle 2 stroke:blue,stroke-width:1px;
        linkStyle 3 stroke:blue,stroke-width:1px;

        Worker1 -- Task --&gt; ServiceA_Container1
        Worker2 -- Task --&gt; ServiceA_Container2
        Worker2 -- Task --&gt; ServiceB_Container1
        Worker3 -- Task --&gt; ServiceB_Container2
        Worker3 -- Task --&gt; ServiceC_Container1

        ExternalClient[(External Client)] -- Traffic --&gt; Manager1
        ExternalClient -- Traffic --&gt; Worker1
        ExternalClient -- Traffic --&gt; Worker2

        Manager1 -- Orchestrates &amp; Schedules --&gt; WorkerNodes[Worker Nodes]
        WorkerNodes -- Runs Tasks (Containers) --&gt; ServicePods[Service Containers]
        Manager1 -- Maintains Desired State --&gt; ClusterState[Cluster State]
        Manager1 &lt;--&gt;|API| WorkerNodes

        subgraph &quot;Routing Mesh (Ingress Network)&quot;
            direction LR
            R1[Manager Node 1 IP:Port] --&gt; LB[Load Balancer]
            R2[Worker Node 1 IP:Port] --&gt; LB
            R3[Worker Node 2 IP:Port] --&gt; LB
            LB --&gt; ServiceA_Container1
            LB --&gt; ServiceA_Container2
            LB --&gt; ServiceB_Container1
            LB --&gt; ServiceB_Container2
        end
    end
  </pre></div>

<ul>
<li><strong>管理节点 (Manager Node)</strong>：<ul>
<li>作为 Swarm 的大脑，决策容器的调度和编排。</li>
<li>维护集群的所有状态（使用 Raft 一致性协议），保证高可用性和数据一致性。</li>
<li>向客户端暴露 Docker API 接口。</li>
</ul>
</li>
<li><strong>工作节点 (Worker Node)</strong>：<ul>
<li>执行管理节点分配的任务，实际运行容器。</li>
</ul>
</li>
</ul>
<h2 id="四、Docker-Swarm-主要特性"><a href="#四、Docker-Swarm-主要特性" class="headerlink" title="四、Docker Swarm 主要特性"></a>四、Docker Swarm 主要特性</h2><ol>
<li><strong>去中心化设计 (Decentralized Design)</strong>：<ul>
<li>Swarm 将管理节点和工作节点的管理能力分配到所有节点上，使得整个集群在架构上更加扁平化。</li>
<li>管理节点使用 Raft 协议保证集群状态的一致性，允许少量管理节点失效而不影响集群。</li>
</ul>
</li>
<li><strong>服务发现与负载均衡 (Service Discovery &amp; Load Balancing)</strong>：<ul>
<li>内置 DNS 服务器，可以通过服务名称进行容器间通信。</li>
<li>内置的路由网格 (Ingress Routing Mesh) 允许你通过集群中任何节点的 IP 地址和暴露的端口来访问任何服务，无论该服务的容器实例是否在该节点上运行，流量都会被路由到可用的容器实例。</li>
</ul>
</li>
<li><strong>容错与自愈 (Fault Tolerance &amp; Self-healing)</strong>：<ul>
<li>当一个工作节点故障或一个容器实例崩溃时，Swarm 管理器会自动在健康节点上重新调度并启动该容器，以维持服务的期望状态。</li>
</ul>
</li>
<li><strong>滚动更新与回滚 (Rolling Updates &amp; Rollbacks)</strong>：<ul>
<li>支持零停机滚动更新服务。你可以逐步更新服务的镜像版本，而不会造成服务中断。</li>
<li>如果更新后出现问题，可以快速回滚到上一个稳定版本。</li>
</ul>
</li>
<li><strong>声明式服务模型 (Declarative Service Model)</strong>：<ul>
<li>通过定义服务（如 Docker Compose 文件），声明应用程序的期望状态。Swarm 会努力维持这个状态。</li>
</ul>
</li>
<li><strong>安全性 (Security)</strong>：<ul>
<li>所有节点之间的通信都通过 TLS (Transport Layer Security) 进行加密和认证，确保集群内部通信的安全。</li>
</ul>
</li>
<li><strong>与 Docker Compose 集成</strong>：<ul>
<li>可以直接使用标准的 <code>docker-compose.yml</code> 文件来定义多容器应用，并使用 <code>docker stack deploy</code> 命令将其部署到 Swarm 集群中。这使得从单机开发到集群部署的迁移非常平滑。</li>
</ul>
</li>
</ol>
<h2 id="五、Docker-Swarm-常用命令"><a href="#五、Docker-Swarm-常用命令" class="headerlink" title="五、Docker Swarm 常用命令"></a>五、Docker Swarm 常用命令</h2><h3 id="5-1-初始化-Swarm-集群"><a href="#5-1-初始化-Swarm-集群" class="headerlink" title="5.1 初始化 Swarm 集群"></a>5.1 初始化 Swarm 集群</h3><p>在第一台想要作为管理节点的机器上执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr &lt;MANAGER_IP&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;MANAGER_IP&gt;</code> 应该是该管理节点对其他节点可访问的 IP 地址。</li>
<li>执行成功后，会输出一个 <code>docker swarm join</code> 命令，用于将其他节点加入集群。</li>
</ul>
<h3 id="5-2-将节点加入-Swarm-集群"><a href="#5-2-将节点加入-Swarm-集群" class="headerlink" title="5.2 将节点加入 Swarm 集群"></a>5.2 将节点加入 Swarm 集群</h3><p><strong>加入工作节点：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm <span class="built_in">join</span> --token &lt;TOKEN&gt; &lt;MANAGER_IP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;TOKEN&gt;</code> 是 <code>docker swarm init</code> 命令输出的工作节点加入令牌。</li>
<li><code>&lt;MANAGER_IP&gt;:&lt;PORT&gt;</code> 是管理节点的 IP 地址和 Swarm 默认通信端口 (2377)。</li>
</ul>
<p><strong>加入管理节点 (作为高可用管理节点)：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm <span class="built_in">join</span> --token &lt;TOKEN&gt; --manager &lt;MANAGER_IP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;TOKEN&gt;</code> 是 <code>docker swarm init</code> 命令输出的管理节点加入令牌。</li>
</ul>
<h3 id="5-3-退出-移除-Swarm-节点"><a href="#5-3-退出-移除-Swarm-节点" class="headerlink" title="5.3 退出&#x2F;移除 Swarm 节点"></a>5.3 退出&#x2F;移除 Swarm 节点</h3><p><strong>节点退出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave <span class="comment"># 在要退出的节点上执行</span></span><br></pre></td></tr></table></figure>

<p><strong>管理节点移除故障节点：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有节点</span></span><br><span class="line">docker node <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 从 Swarm 中移除节点</span></span><br><span class="line">docker node <span class="built_in">rm</span> &lt;NODE_ID/NODE_NAME&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-服务管理"><a href="#5-4-服务管理" class="headerlink" title="5.4 服务管理"></a>5.4 服务管理</h3><p><strong>创建服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name my-web-app \</span><br><span class="line">  --publish 80:80 \</span><br><span class="line">  --replicas 3 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--name</code>：服务名称。</li>
<li><code>--publish</code>：端口映射（宿主机端口:容器端口）。</li>
<li><code>--replicas</code>：期望的容器副本数量。</li>
<li><code>nginx:latest</code>：使用的 Docker 镜像。</li>
</ul>
<p><strong>查看服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">ls</span>                <span class="comment"># 列出所有服务</span></span><br><span class="line">docker service ps my-web-app     <span class="comment"># 查看服务的任务（容器）状态</span></span><br></pre></td></tr></table></figure>

<p><strong>伸缩服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service scale my-web-app=5 <span class="comment"># 将 my-web-app 服务扩展到 5 个副本</span></span><br></pre></td></tr></table></figure>

<p><strong>更新服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service update \</span><br><span class="line">  --image myregistry/my-web-app:v2.0 \</span><br><span class="line">  --update-delay 10s \</span><br><span class="line">  --update-parallelism 1 \</span><br><span class="line">  my-web-app</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--image</code>：更新服务使用的镜像版本。</li>
<li><code>--update-delay</code>：每个容器更新之间的延迟。</li>
<li><code>--update-parallelism</code>：每次更新的容器数量。</li>
</ul>
<p><strong>删除服务：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service <span class="built_in">rm</span> my-web-app</span><br></pre></td></tr></table></figure>

<h3 id="5-5-栈-Stack-管理-使用-Docker-Compose-文件"><a href="#5-5-栈-Stack-管理-使用-Docker-Compose-文件" class="headerlink" title="5.5 栈 (Stack) 管理 (使用 Docker Compose 文件)"></a>5.5 栈 (Stack) 管理 (使用 Docker Compose 文件)</h3><p><strong>部署栈：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml my-app-stack</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-c</code>：指定 Compose 文件。</li>
<li><code>my-app-stack</code>：栈的名称。</li>
</ul>
<p><strong>查看栈：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">ls</span>                     <span class="comment"># 列出所有栈</span></span><br><span class="line">docker stack services my-app-stack  <span class="comment"># 查看栈中所有服务的状态</span></span><br><span class="line">docker stack ps my-app-stack        <span class="comment"># 查看栈中所有任务的状态</span></span><br></pre></td></tr></table></figure>

<p><strong>移除栈：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack <span class="built_in">rm</span> my-app-stack</span><br></pre></td></tr></table></figure>

<h2 id="六、Docker-Swarm-的优缺点与适用场景"><a href="#六、Docker-Swarm-的优缺点与适用场景" class="headerlink" title="六、Docker Swarm 的优缺点与适用场景"></a>六、Docker Swarm 的优缺点与适用场景</h2><h3 id="6-1-优点："><a href="#6-1-优点：" class="headerlink" title="6.1 优点："></a>6.1 优点：</h3><ol>
<li><strong>开箱即用，易学易用</strong>：Docker Swarm 是 Docker Engine 的一部分，安装 Docker 即可使用。命令与 Docker CLI 命令高度兼容，学习曲线平缓。</li>
<li><strong>原生集成</strong>：与 Docker 生态系统（如 Dockerfile, Docker Compose）无缝集成，可以直接部署已有的 <code>docker-compose.yml</code> 文件。</li>
<li><strong>轻量级，低开销</strong>：相比 Kubernetes，Docker Swarm 自身资源消耗更少，启动速度更快。</li>
<li><strong>路由网格 (Routing Mesh)</strong>：内置的负载均衡和 Ingress 网络简化了服务的暴露和访问。</li>
<li><strong>适合小型至中型集群</strong>：对于不需要极致复杂功能、更注重部署便捷性的场景非常适用。</li>
</ol>
<h3 id="6-2-缺点："><a href="#6-2-缺点：" class="headerlink" title="6.2 缺点："></a>6.2 缺点：</h3><ol>
<li><strong>功能相对简单</strong>：相比 Kubernetes，Swarm 在服务发现、存储管理、网络策略、身份认证和授权 (RBAC) 等方面功能较为基础。</li>
<li><strong>生态系统较小</strong>：社区活跃度和第三方工具集成度不如 Kubernetes。</li>
<li><strong>高级调度能力不足</strong>：不支持基于自定义资源（CRD）的复杂调度策略。</li>
<li><strong>可扩展性限制</strong>：在大规模集群或超高复杂度的应用场景下，其扩展性和稳定性可能不如 Kubernetes。</li>
</ol>
<h3 id="6-3-适用场景："><a href="#6-3-适用场景：" class="headerlink" title="6.3 适用场景："></a>6.3 适用场景：</h3><ul>
<li><strong>刚开始接触容器编排，追求简单快速上手</strong>：对于新手来说，Swarm 的概念和操作更加直观。</li>
<li><strong>开发和测试环境</strong>：快速搭建高可用的多容器应用环境。</li>
<li><strong>小型或中型生产环境</strong>：对资源要求不高、规模可预测的应用程序，部署在一组机器上。</li>
<li><strong>基于 Docker Compose 文件的现有应用</strong>：可以几乎不做修改地迁移到 Swarm 集群。</li>
<li><strong>Proof of Concept (POC) 或演示</strong>：快速证明容器集群化部署的价值。</li>
</ul>
<h2 id="七、与-Kubernetes-的关系"><a href="#七、与-Kubernetes-的关系" class="headerlink" title="七、与 Kubernetes 的关系"></a>七、与 Kubernetes 的关系</h2><p>Docker Swarm 和 Kubernetes 都是容器编排工具，但它们在设计哲学、复杂性、功能集和生态系统方面存在显著差异：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Docker Swarm</th>
<th align="left">Kubernetes</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left"><strong>低，易上手</strong>，使用原生 Docker CLI 命令和概念。</td>
<td align="left"><strong>高，学习曲线陡峭</strong>，引入大量新概念（Pod, Deployment, Service, Ingress 等）。</td>
</tr>
<tr>
<td align="left"><strong>安装部署</strong></td>
<td align="left"><strong>简单</strong>，<code>docker swarm init</code> 即可建立集群。</td>
<td align="left"><strong>复杂</strong>，通常需要工具 (kubeadm, kops, Rancher) 来部署。</td>
</tr>
<tr>
<td align="left"><strong>原生集成</strong></td>
<td align="left">与 Dockerfile, Docker Compose 无缝集成。</td>
<td align="left">需要将 Docker Compose 转换为 K8s 配置 (如 <code>kompose</code>)。</td>
</tr>
<tr>
<td align="left"><strong>负载均衡</strong></td>
<td align="left">内置路由网格 (Routing Mesh)。</td>
<td align="left">使用 Service (通过 kube-proxy IPVS&#x2F;iptables) 和 Ingress Controller。</td>
</tr>
<tr>
<td align="left"><strong>服务发现</strong></td>
<td align="left">内置 DNS。</td>
<td align="left">内置 DNS。</td>
</tr>
<tr>
<td align="left"><strong>高可用</strong></td>
<td align="left">Manager 节点通过 Raft 协议实现高可用。</td>
<td align="left">Control Plane 组件高可用，etcd 集群高可用。</td>
</tr>
<tr>
<td align="left"><strong>可扩展性</strong></td>
<td align="left">适用于小型到中型规模。</td>
<td align="left">适用于大规模、超大规模集群。</td>
</tr>
<tr>
<td align="left"><strong>功能集</strong></td>
<td align="left"><strong>核心编排功能</strong>，较精简。</td>
<td align="left"><strong>功能丰富</strong>：CRD, RBAC, 高级网络策略, 存储插件, 自动伸缩, Helm 等。</td>
</tr>
<tr>
<td align="left"><strong>社区生态</strong></td>
<td align="left">较小，发展速度较慢。</td>
<td align="left"><strong>庞大且活跃</strong>，拥有丰富的工具、插件和解决方案。</td>
</tr>
<tr>
<td align="left"><strong>供应商支持</strong></td>
<td align="left">Docker 公司原生支持。</td>
<td align="left">得到了几乎所有主流云厂商和企业的大力支持。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">小型项目、本地开发、快速原型、对运维要求不高的场景。</td>
<td align="left">生产环境、微服务架构、大规模分布式系统、对灵活性和扩展性有高要求的场景。</td>
</tr>
</tbody></table>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>Docker Swarm 作为 Docker 官方提供的轻量级容器编排工具，为用户提供了一种简单、高效的方式来管理和部署多容器应用程序。它以其易用性、与 Docker 生态的无缝集成以及低开销等特点，成为中小规模容器集群的理想选择。虽然功能不如 Kubernetes 强大和灵活，但在许多场景下，Docker Swarm 能够满足需求，并提供了一个更平滑的容器化之旅。对于那些已经熟悉 Docker 并希望快速进入集群管理领域的用户来说，Docker Swarm 是一个极佳的起点。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/56481bc27387/">https://blog.tbf1211.xx.kg/56481bc27387/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/">容器技术</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-22.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/a98d6341806e/" title="Unicode 与 UTF-8 编码深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unicode 与 UTF-8 编码深度解析</div></div><div class="info-2"><div class="info-item-1"> 在现代计算机系统中，处理和显示全球范围内的各种文字和符号是至关重要的。Unicode (统一码) 和 UTF-8 是实现这一目标的两个核心标准。它们通常被提及，但其确切含义和关系有时会混淆。简而言之，Unicode 定义了字符的唯一标识，而 UTF-8 则是 Unicode 字符的一种高效、可变长度的编码方式，尤其适用于互联网传输。  核心思想：Unicode 是一个巨大的“字符字典”，为每个字符分配一个唯一的数字（码点）；UTF-8 是一种聪明的“翻译规则”，将这些码点以字节序列的形式存储或传输，且具有向 ASCII 兼容的优势。   一、字符编码的演进：从 ASCII 到 Unicode在 Unicode 出现之前，计算机世界充满了各种相互冲突的字符编码标准，这导致了“乱码”问题的普遍存在。  ASCII (American Standard Code for Information Interchange)：最早且最广泛使用的字符编码标准。它使用 7 位表示 128 个字符，主要包括英文字母、数字和一些标点符号。 局限性：无法表示非英文字符。   扩展 ASCII (Ex...</div></div></div></a><a class="pagination-related" href="/8ba79d4c7826/" title="Python SQLAlchemy 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python SQLAlchemy 详解</div></div><div class="info-2"><div class="info-item-1"> SQLAlchemy 是一个强大的 Python SQL 工具包和 ORM (Object Relational Mapper)，它为应用程序和数据库之间提供了完整的抽象层。SQLAlchemy 旨在提供高效且灵活的数据库访问，支持多种数据库后端，并允许开发者在对象操作和原生 SQL 语句之间进行灵活切换。  核心思想：将数据库操作封装为 Python 对象，既提供高层次的 ORM 抽象，简化数据模型管理；又保留低层次的 SQL 表达式语言，允许执行复杂的 SQL 查询，兼顾开发效率与性能优化。   一、为什么需要 SQLAlchemy？在 Python 应用中与数据库交互时，通常会遇到以下挑战：  数据库类型差异：不同的数据库（MySQL, PostgreSQL, SQLite, Oracle 等）有不同的 SQL 语法和连接 API。直接使用原生驱动代码会导致代码难以跨数据库移植。 SQL 语句管理：手动编写和维护 SQL 字符串容易出错，尤其是在处理复杂查询、表连接和条件过滤时，且存在 SQL 注入风险。 数据与对象映射：将数据库行数据手动转换为 Python 对象，以及...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/54746cccf92e/" title="Docker 核心技术深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-21</div><div class="info-item-2">Docker 核心技术深度解析</div></div><div class="info-2"><div class="info-item-1"> Docker 是一个开源的容器化平台，它允许开发者将应用程序及其所有依赖项打包到一个标准化的、可移植的、自包含的单元——容器 (Container) 中。与传统的虚拟机 (VM) 技术不同，Docker 容器不包含独立的操作系统内核，而是共享宿主机的 Linux 内核，这使得容器更加轻量、启动更快。Docker 的强大之处在于它巧妙地利用了 Linux 操作系统底层的一系列核心技术来实现这种轻量级隔离和资源管理。  核心思想：Docker 并非一个虚拟化产品，而是利用 Linux 内核提供的 Namespaces（命名空间）实现隔离，Cgroups（控制组）实现资源限制，以及 Union File Systems（联合文件系统）实现高效的镜像管理，最终通过容器运行时（如 containerd 和 runc）来编排和执行这些操作。   一、Linux 容器技术概述Docker 的核心是 Linux 容器 (LXC) 技术，它并非一项单一技术，而是 Linux 内核中多项特性的结合。这些特性使得一个进程或一组进程可以在一个相对隔离的环境中运行，拥有自己独立的资源视图，并且其资源使用...</div></div></div></a><a class="pagination-related" href="/5dea4260c32f/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像构建 (Image Building) 是 Docker 容器化技术的核心环节，它指的是根据 Dockerfile 中定义的一系列指令，逐步创建一个 Docker 镜像的过程。这个过程最终会生成一个轻量级、独立、可执行的软件包，其中包含运行应用程序所需的一切：代码、运行时环境、系统工具、库和配置。  核心思想：Docker 镜像构建是一个分层 (Layered) 且基于指令 (Instruction-based) 的过程。每条 Dockerfile 指令都会在现有镜像层之上创建一个新的只读层，这些层的集合构成了最终的 Docker 镜像。    一、Docker 镜像与分层存储在深入构建过程之前，理解 Docker 镜像的核心概念——分层存储 (Layered Storage) 至关重要。  只读层 (Read-Only Layers)： Docker 镜像由一系列只读的文件系统层组成，这些层叠加在一起。 Dockerfile 中的每条指令（例如 FROM, RUN, COPY 等）都会在现有镜像层之上创建一个新的只读层。 这些层是可重用的。如果多个镜像共享相...</div></div></div></a><a class="pagination-related" href="/828da7ae380f/" title="Docker Compose 详解：定义和运行多容器 Docker 应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-27</div><div class="info-item-2">Docker Compose 详解：定义和运行多容器 Docker 应用</div></div><div class="info-2"><div class="info-item-1"> Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。通过一个 YAML 文件 (docker-compose.yml)，你可以配置应用程序的服务（即容器）、网络和卷等所有方面，然后使用一个命令（docker compose 或 docker-compose）启动、停止和管理整个应用程序栈。它极大地简化了复杂应用程序的部署和管理，特别适用于开发、测试和小型生产环境。  核心思想：将多容器应用程序的配置进行抽象和定义，实现一次定义，随处运行的容器化应用部署。    一、为什么需要 Docker Compose？当我们开发和部署一个应用程序时，通常不仅仅涉及一个容器。一个典型的现代应用程序可能包含：  一个 Web 服务器（如 Nginx, Apache） 一个应用服务器（如 Node.js, Python Flask, Java Spring Boot） 一个数据库（如 PostgreSQL, MySQL, MongoDB） 一个缓存服务（如 Redis） 消息队列、定时任务等其他辅助服务  如果手动管理这些容器：  复杂性高：你需要分别使用 d...</div></div></div></a><a class="pagination-related" href="/ec0c74ef7e6c/" title="Dockerfile 常用指令详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-23</div><div class="info-item-2">Dockerfile 常用指令详解</div></div><div class="info-2"><div class="info-item-1"> Dockerfile 是一个文本文件，其中包含了用户可以在命令行上调用以组装映像的所有命令。Docker 读取 Dockerfile 中的指令并自动构建镜像。通过 Dockerfile，你可以构建可移植、可复用、可共享的 Docker 镜像，这对于实现应用程序的容器化、简化部署流程和CI&#x2F;CD（持续集成&#x2F;持续部署）至关重要。  核心思想：Dockerfile 提供了一种声明式的方式来定义 Docker 镜像的构建过程。通过一系列指令，它描述了如何从一个基础镜像开始，逐步添加文件、安装软件、配置环境、暴露端口，最终形成一个可运行的、自包含的应用程序镜像。    一、Dockerfile 基础概念 镜像 (Image)：是 Docker 容器的只读模板，包含了运行某个软件所需的一切，包括代码、运行时、库、环境变量和配置文件。镜像通过 Dockerfile 构建。 容器 (Container)：是镜像的运行实例。容器是轻量级、独立的、可执行的软件包，包含应用程序及其所有依赖。 层 (Layer)：Docker 镜像由一系列只读层（Layer）组成。Dockerfi...</div></div></div></a><a class="pagination-related" href="/977c8a1633a2/" title="区块链原理详解：技术基石与运作机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="info-item-2">区块链原理详解：技术基石与运作机制</div></div><div class="info-2"><div class="info-item-1"> 区块链（Blockchain） 是一种分布式账本技术（Distributed Ledger Technology, DLT），它以块（Block）的形式存储数据，并通过密码学方式将这些块连接成一个链（Chain）。其核心思想是去中心化、不可篡改、公开透明，允许多个参与方在没有中央机构的情况下，共同维护一个安全、可靠、同步的数据记录系统。区块链最初作为比特币的底层技术而闻名，但其应用已远超数字货币范畴，正在变革金融、供应链、物联网等多个领域。  核心思想：区块链通过将交易数据打包成块，使用加密哈希环环相扣，并在分布式网络中通过共识机制维护这一链式结构，从而确保了数据的不可篡改性、可追溯性和去中心化特性。   一、区块链的起源与核心问题在区块链出现之前，所有数字交易系统都依赖于中心化的机构（如银行、支付平台）来验证和记录交易。这种中心化模式存在固有问题：  单点故障：中心服务器一旦出现故障或被攻击，整个系统可能瘫痪或数据丢失。 信任成本：参与方必须信任中心机构，中心机构可能存在信息不对称、权力滥用、数据篡改等风险。 效率瓶颈：中心化系统的处理能力有限，且跨机构操作可能面临协调困难。...</div></div></div></a><a class="pagination-related" href="/be930ce35928/" title="Java 常用设计模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-30</div><div class="info-item-2">Java 常用设计模式详解</div></div><div class="info-2"><div class="info-item-1"> 设计模式 (Design Patterns) 是在软件工程中，针对特定问题场景提出的一套经过验证的、可复用的解决方案。它们是从实践中总结出来的，是软件开发过程中的最佳实践。学习和应用设计模式，可以帮助开发者构建出结构清晰、可维护、可扩展、复用性强的软件系统，同时也能促进团队成员之间的沟通。  核心思想：设计模式的目标是提升软件的灵活性 (Flexibility)、可重用性 (Reusability) 和可扩展性 (Extensibility)，同时降低维护成本 (Maintainability)。它们不是代码，而是解决特定问题的思想和方法。   一、设计模式的分类根据 GoF (Gang of Four，《设计模式：可复用面向对象软件的基础》的四位作者) 的经典分类，设计模式主要分为三类：  创建型模式 (Creational Patterns)： 关注对象的创建机制，目标是解耦对象的创建与使用，从而提供更大的灵活性。 包括：单例 (Singleton)、工厂方法 (Factory Method)、抽象工厂 (Abstract Factory)、建造者 (Builder)、原型...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">441</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Docker-Swarm%EF%BC%9F"><span class="toc-text">一、为什么需要 Docker Swarm？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Docker-Swarm-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Docker Swarm 核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Docker-Swarm-%E6%9E%B6%E6%9E%84"><span class="toc-text">三、Docker Swarm 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Docker-Swarm-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-text">四、Docker Swarm 主要特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Docker-Swarm-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">五、Docker Swarm 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%88%9D%E5%A7%8B%E5%8C%96-Swarm-%E9%9B%86%E7%BE%A4"><span class="toc-text">5.1 初始化 Swarm 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%B0%86%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5-Swarm-%E9%9B%86%E7%BE%A4"><span class="toc-text">5.2 将节点加入 Swarm 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%80%E5%87%BA-%E7%A7%BB%E9%99%A4-Swarm-%E8%8A%82%E7%82%B9"><span class="toc-text">5.3 退出&#x2F;移除 Swarm 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">5.4 服务管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%A0%88-Stack-%E7%AE%A1%E7%90%86-%E4%BD%BF%E7%94%A8-Docker-Compose-%E6%96%87%E4%BB%B6"><span class="toc-text">5.5 栈 (Stack) 管理 (使用 Docker Compose 文件)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Docker-Swarm-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">六、Docker Swarm 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">6.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">6.2 缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">6.3 适用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%B8%8E-Kubernetes-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">七、与 Kubernetes 的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-22.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>