<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>提示词模板详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="提示词模板 (Prompt Template) 是一种精心设计的结构化文本框架，旨在将人类意图转化为大型语言模型 (LLM) 最能理解和高效执行的指令集。它通过明确角色、设定目标、注入约束、提供上下文和示例，系统性地优化 AI 交互，确保输出的一致性、准确性和高质量。  核心思想：将编程思维应用于提示工程，用模板封装智慧，让 AI 成为可预测、高效率的智能伙伴。 优秀的提示词模板是 AI 时代“">
<meta property="og:type" content="article">
<meta property="og:title" content="提示词模板详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/66853900b34d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="提示词模板 (Prompt Template) 是一种精心设计的结构化文本框架，旨在将人类意图转化为大型语言模型 (LLM) 最能理解和高效执行的指令集。它通过明确角色、设定目标、注入约束、提供上下文和示例，系统性地优化 AI 交互，确保输出的一致性、准确性和高质量。  核心思想：将编程思维应用于提示工程，用模板封装智慧，让 AI 成为可预测、高效率的智能伙伴。 优秀的提示词模板是 AI 时代“">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg">
<meta property="article:published_time" content="2025-04-29T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-12T09:40:22.785Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="LLM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "提示词模板详解",
  "url": "https://blog.tbf1211.xx.kg/66853900b34d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-07.jpg",
  "datePublished": "2025-04-29T22:24:00.000Z",
  "dateModified": "2026-01-12T09:40:22.785Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/66853900b34d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '提示词模板详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">486</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-07.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">提示词模板详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">提示词模板详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-04-29T22:24:00.000Z" title="发表于 2025-04-30 06:24:00">2025-04-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/LLM/">LLM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>提示词模板 (Prompt Template)</strong> 是一种精心设计的结构化文本框架，旨在将人类意图转化为大型语言模型 (LLM) 最能理解和高效执行的指令集。它通过明确角色、设定目标、注入约束、提供上下文和示例，系统性地优化 AI 交互，确保输出的一致性、准确性和高质量。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将编程思维应用于提示工程，用模板封装智慧，让 AI 成为可预测、高效率的智能伙伴。</strong> 优秀的提示词模板是 AI 时代“代码即文档，文档即代码”理念在人机协作层面的体现。</p>
</div>

<hr>
<h2 id="一、优秀提示词模板的核心特征"><a href="#一、优秀提示词模板的核心特征" class="headerlink" title="一、优秀提示词模板的核心特征"></a>一、优秀提示词模板的核心特征</h2><p>一个卓越的提示词模板，如同高质量的软件架构，具备以下关键特征：</p>
<ol>
<li><strong>明确的角色与目标 (Clear Role &amp; Objective)</strong>：AI 被赋予清晰的身份（如“首席软件架构师”、“精英提示工程师”）和单义的任务目标。</li>
<li><strong>严谨的硬约束 (Rigorous Hard Constraints)</strong>：使用强制性语言（“必须”、“不得”、“禁止”）定义输出格式、内容、行为边界，确保可判定性。</li>
<li><strong>结构化输出规范 (Structured Output Specification)</strong>：通过 Markdown、JSON、YAML 等明确的格式，确保 AI 输出稳定、易于解析和后续处理。</li>
<li><strong>丰富的上下文与知识注入 (Rich Context &amp; Knowledge Injection)</strong>：提供背景信息、领域知识、心智模型、哲学原则，引导 AI 深入理解和高质量推理。</li>
<li><strong>清晰的流程与工作流 (Clear Process &amp; Workflow)</strong>：将复杂任务分解为可执行的阶段和步骤，指导 AI 逐步完成。</li>
<li><strong>可追溯的记忆与自动化 (Traceable Memory &amp; Automation)</strong>：定义 AI 如何与外部系统交互（如文件读写、Git 操作），以及如何管理错误和上下文记忆。</li>
<li><strong>高质量的示例 (High-Quality Examples)</strong>：通过 Few-Shot Learning 机制，提供输入-输出对，直观示范期望的行为和结果。</li>
</ol>
<h2 id="二、各类提示词模板详解与范例"><a href="#二、各类提示词模板详解与范例" class="headerlink" title="二、各类提示词模板详解与范例"></a>二、各类提示词模板详解与范例</h2><p>提示词模板可以根据其主要功能和设计侧重点进行分类。以下将详细介绍不同类型的模板，并提供基于用户输入的优秀范例。</p>
<h3 id="2-1-角色扮演模板-Role-Playing-Template"><a href="#2-1-角色扮演模板-Role-Playing-Template" class="headerlink" title="2.1 角色扮演模板 (Role-Playing Template)"></a>2.1 角色扮演模板 (Role-Playing Template)</h3><p><strong>定义</strong>：通过为 AI 分配一个明确的专家角色，使其以该角色的专业知识、思维模式、沟通风格和价值观进行响应，从而提升输出的专业性和针对性。</p>
<p><strong>范例</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 角色定义</span></span><br><span class="line"></span><br><span class="line">你是 Linus Torvalds，Linux 内核的创造者和首席架构师。你已经维护 Linux 内核超过30年，审核过数百万行代码，建立了世界上最成功的开源项目。现在我们正在开创一个新项目，你将以你独特的视角来分析代码质量的潜在风险，确保项目从一开始就建立在坚实的技术基础上。</span><br><span class="line"></span><br><span class="line"><span class="section">## 我的核心哲学</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>  &quot;&quot;好品味&quot;&quot;(Good Taste) - 我的第一准则</span><br><span class="line"><span class="code">    &quot;&quot;有时你可以从不同角度看问题，重写它让特殊情况消失，变成正常情况。&quot;&quot;</span></span><br><span class="line"><span class="code">    - 消除边界情况永远优于增加条件判断</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">2.</span>  &quot;&quot;Never break userspace&quot;&quot; - 我的铁律</span><br><span class="line"><span class="code">    &quot;&quot;我们不破坏用户空间！&quot;&quot;</span></span><br><span class="line"><span class="code">    - 任何导致现有程序崩溃的改动都是bug，无论多么&quot;&quot;理论正确&quot;&quot;</span></span><br><span class="line"><span class="code">    - 向后兼容性是神圣不可侵犯的</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">3.</span>  实用主义 - 我的信仰</span><br><span class="line"><span class="code">    &quot;&quot;我是个该死的实用主义者。&quot;&quot;</span></span><br><span class="line"><span class="code">    - 解决实际问题，而不是假想的威胁</span></span><br><span class="line"><span class="code">    - 代码要为现实服务，不是为论文服务</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">4.</span>  简洁执念 - 我的标准</span><br><span class="line"><span class="code">    &quot;&quot;如果你需要超过3层缩进，你就已经完蛋了，应该修复你的程序。&quot;&quot;</span></span><br><span class="line"><span class="code">    - 函数必须短小精悍，只做一件事并做好</span></span><br><span class="line"><span class="code">    - 复杂性是万恶之源</span></span><br></pre></td></tr></table></figure>

<p><strong>范例解析</strong>：</p>
<ul>
<li><strong>角色明确</strong>：直接指定为“Linus Torvalds”，这不仅仅是名称，更包含了他30年维护 Linux 内核的经验和权威性。</li>
<li><strong>哲学注入</strong>：详细阐述了 Linus 的“好品味”、“Never break userspace”、“实用主义”和“简洁执念”四大核心哲学，这些是 AI 做出技术判断的最高指导原则。</li>
<li><strong>行为预期</strong>：AI 会以 Linus 的口吻和思维方式（直接、犀利、技术优先）来分析代码质量，并拒绝过度设计。</li>
</ul>
<h3 id="2-2-硬约束与规则模板-Hard-Constraint-Rule-Based-Template"><a href="#2-2-硬约束与规则模板-Hard-Constraint-Rule-Based-Template" class="headerlink" title="2.2 硬约束与规则模板 (Hard Constraint &amp; Rule-Based Template)"></a>2.2 硬约束与规则模板 (Hard Constraint &amp; Rule-Based Template)</h3><p><strong>定义</strong>：专注于设定严格、明确、可判定的规则，强制 AI 在输出内容、格式或行为上遵守特定标准，确保任务的合规性和一致性。</p>
<p><strong>范例</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 处理规则（硬性约束）</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 所有输出必须为<span class="strong">**单行约束**</span>，每条仅表达一个明确、可判定的约束。</span><br><span class="line"><span class="bullet">2.</span> 所有约束必须使用<span class="strong">**禁止式或强制式**</span>表述（如“必须 / 不得 / 禁止”），禁止使用建议性、描述性或口号化语言。</span><br><span class="line"><span class="bullet">3.</span> 所有约束必须能够被明确判定为“符合 / 不符合”，不得包含模糊、主观或情境依赖表述。</span><br><span class="line"><span class="bullet">4.</span> 输出中<span class="strong">**不得包含**</span>解释、示例、背景说明、段落标题或任何非约束性文本。</span><br><span class="line"><span class="bullet">5.</span> 所有约束必须使用<span class="strong">**连续的阿拉伯数字编号**</span>，从 1 开始递增，不得跳号或重复。</span><br><span class="line"><span class="bullet">6.</span> 对语义重复、等价或从属的内容必须进行合并，禁止产生冗余约束。</span><br><span class="line"><span class="bullet">7.</span> 对隐含但必要的前置条件必须显式化，并转化为可执行的硬约束。</span><br><span class="line"><span class="bullet">8.</span> 约束输出顺序必须按<span class="strong">**工程优先级**</span>排列：先合法性与成立条件，再结构与行为约束，最后风格与质量约束。</span><br><span class="line"><span class="bullet">9.</span> 所有约束默认视为【前置条件式硬约束】，任一违反即视为任务不成立。</span><br><span class="line"><span class="bullet">10.</span> 输入中的建议、原则或描述性文本必须被转换为<span class="strong">**等价的禁止式或强制式约束**</span>，否则不得保留。</span><br><span class="line"><span class="bullet">11.</span> 不得引入输入中不存在的新领域知识、新规则或扩展解释，仅允许形式化、结构化与等价转换。</span><br><span class="line"><span class="bullet">12.</span> 任何无法被转换为<span class="strong">**可判定硬约束**</span>的内容必须被直接丢弃，不得以弱约束形式保留。</span><br></pre></td></tr></table></figure>

<p><strong>范例解析</strong>：</p>
<ul>
<li><strong>强制性表述</strong>：大量使用“必须”、“不得”、“禁止”，不留任何回旋余地。</li>
<li><strong>可判定性</strong>：每条规则都强调“明确、可判定的约束”，避免模糊和主观判断。</li>
<li><strong>聚焦单一职责</strong>：每条规则只表达一个明确的约束，便于 AI 理解和执行，也便于验证。</li>
<li><strong>结果导向</strong>：明确了输出内容、格式、结构的具体要求，甚至包括编号和排序规则。</li>
</ul>
<h3 id="2-3-结构化输出模板-Structured-Output-Template"><a href="#2-3-结构化输出模板-Structured-Output-Template" class="headerlink" title="2.3 结构化输出模板 (Structured Output Template)"></a>2.3 结构化输出模板 (Structured Output Template)</h3><p><strong>定义</strong>：严格规定 AI 输出的格式和结构（如 Markdown、JSON、XML），确保输出内容的一致性、可解析性和便于自动化处理。</p>
<p><strong>范例</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 二、执行流程（Execution Workflow）</span></span><br><span class="line"></span><br><span class="line"><span class="section">### Step 1：初始化文档容器</span></span><br><span class="line"></span><br><span class="line">创建一个空的结构化文档对象，作为最终输出模板。</span><br><span class="line"></span><br><span class="line">文档 = 初始化空上下文文档()</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">### Step 2：生成核心上下文模块</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 2.1 项目概要（Project Overview）</span></span><br><span class="line"></span><br><span class="line">文档.项目概要 = &#123;</span><br><span class="line">  项目名称: &quot;&quot;暂无信息&quot;&quot;,</span><br><span class="line">  项目背景: &quot;&quot;暂无信息&quot;&quot;,</span><br><span class="line">  目标与目的: &quot;&quot;暂无信息&quot;&quot;,</span><br><span class="line">  要解决的问题: &quot;&quot;暂无信息&quot;&quot;,</span><br><span class="line">  整体愿景: &quot;&quot;暂无信息&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">#### 2.2 范围定义（Scope Definition）</span></span><br><span class="line"></span><br><span class="line">文档.范围定义 = &#123;</span><br><span class="line">  当前范围: &quot;&quot;暂无信息&quot;&quot;,</span><br><span class="line">  非本次范围: &quot;&quot;暂无信息&quot;&quot;,</span><br><span class="line">  约束条件: &quot;&quot;暂无信息&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... (此处省略其他模块定义，如 实体信息、功能模块、技术方向等)</span><br><span class="line"></span><br><span class="line"><span class="section">#### 2.8 后续计划与风险（Next Steps &amp; Risks）</span></span><br><span class="line"></span><br><span class="line">文档.后续计划 = &#123;</span><br><span class="line">  待讨论主题: [],</span><br><span class="line">  潜在风险与不确定性: [],</span><br><span class="line">  推荐的后续初始化 Prompt: &quot;&quot;暂无信息&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">### Step 3：输出结果（Final Output）</span></span><br><span class="line"></span><br><span class="line">以完整、结构化、Markdown 形式输出 文档</span><br></pre></td></tr></table></figure>

<p><strong>范例解析</strong>：</p>
<ul>
<li><strong>明确的结构层次</strong>：通过 JSON 伪代码定义了文档的深层嵌套结构 (<code>文档.项目概要</code>, <code>文档.范围定义</code> 等)。</li>
<li><strong>字段定义与默认值</strong>：每个字段都有明确的名称，并指定了当信息缺失时的默认填充内容（<code>&quot;暂无信息&quot;</code>），避免了空值或结构不完整。</li>
<li><strong>可编程性</strong>：这种结构类似于编程中的数据结构定义，使得 AI 可以像填充对象一样填充文档内容，确保了输出的稳定性。</li>
<li><strong>最终输出格式</strong>：明确要求以“完整、结构化、Markdown 形式输出”，结合了结构化定义和人类可读性。</li>
</ul>
<h3 id="2-4-流程与工作流模板-Process-Workflow-Template"><a href="#2-4-流程与工作流模板-Process-Workflow-Template" class="headerlink" title="2.4 流程与工作流模板 (Process &amp; Workflow Template)"></a>2.4 流程与工作流模板 (Process &amp; Workflow Template)</h3><p><strong>定义</strong>：将一个复杂的任务分解为一系列有序的阶段和步骤，引导 AI 按照预设的逻辑路径进行思考和执行，适用于需要多阶段处理或多代理协作的场景。</p>
<p><strong>范例</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 工作流程</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1. 需求分析阶段</span></span><br><span class="line"><span class="bullet">-</span> 仔细分析用户的功能需求和技术要求</span><br><span class="line"><span class="bullet">-</span> 识别潜在的技术挑战和风险点</span><br><span class="line"><span class="bullet">-</span> 确定适合的技术栈和架构方案</span><br><span class="line"><span class="bullet">-</span> 评估项目的复杂度和规模</span><br><span class="line"></span><br><span class="line"><span class="section">### 2. 架构设计阶段</span></span><br><span class="line"><span class="bullet">-</span> 设计清晰的分层架构结构</span><br><span class="line"><span class="bullet">-</span> 定义模块间的接口和依赖关系</span><br><span class="line"><span class="bullet">-</span> 选择合适的设计模式和算法</span><br><span class="line"><span class="bullet">-</span> 考虑性能、安全性和可扩展性</span><br><span class="line"></span><br><span class="line"><span class="section">### 3. 代码实现阶段</span></span><br><span class="line">必须遵循以下代码质量标准：</span><br><span class="line"></span><br><span class="line"><span class="section">#### 代码结构要求</span></span><br><span class="line"><span class="bullet">-</span> 使用清晰的命名规范（变量、函数、类名语义化）</span><br><span class="line"><span class="bullet">-</span> 保持函数单一职责，每个函数不超过50行</span><br><span class="line"><span class="bullet">-</span> 类的设计遵循SOLID原则</span><br><span class="line"><span class="bullet">-</span> 目录结构清晰，文件组织合理</span><br><span class="line"></span><br><span class="line">... (此处省略其他阶段，如 测试保障阶段、文档编写阶段)</span><br></pre></td></tr></table></figure>

<p><strong>范例解析</strong>：</p>
<ul>
<li><strong>阶段划分清晰</strong>：将软件开发生命周期拆解为“需求分析”、“架构设计”、“代码实现”、“测试保障”、“文档编写”等清晰的阶段。</li>
<li><strong>步骤具体化</strong>：每个阶段都包含了一系列具体的、可执行的任务描述。</li>
<li><strong>质量标准嵌入</strong>：在“代码实现阶段”中，直接嵌入了代码质量（结构、风格、错误处理、性能、安全）的具体要求，确保 AI 在执行过程中遵循。</li>
<li><strong>层层递进</strong>：逻辑上从宏观的需求分析，逐步深入到微观的代码实现和质量保障，符合实际的开发流程。</li>
</ul>
<h3 id="2-5-知识与心智模型注入模板-Knowledge-Mental-Model-Injection-Template"><a href="#2-5-知识与心智模型注入模板-Knowledge-Mental-Model-Injection-Template" class="headerlink" title="2.5 知识与心智模型注入模板 (Knowledge &amp; Mental Model Injection Template)"></a>2.5 知识与心智模型注入模板 (Knowledge &amp; Mental Model Injection Template)</h3><p><strong>定义</strong>：向 AI 注入特定的知识体系、思维模式、认知框架或哲学理念，使其在处理问题时能够运用这些“内在智慧”，进行更深层次的推理和洞察。</p>
<p><strong>范例</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心认知框架</span></span><br><span class="line"><span class="attr">cognitive_framework:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;&quot;</span><span class="string">认知与工作的三层架构&quot;&quot;</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">&quot;&quot;</span><span class="string">一个三层双向交互的认知模型。&quot;&quot;</span></span><br><span class="line">  <span class="attr">layers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;&quot;</span><span class="string">Bug现象层&quot;&quot;</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">&quot;&quot;</span><span class="string">接收问题和最终修复的层&quot;&quot;</span></span><br><span class="line">      <span class="attr">activities:</span> [<span class="string">&quot;&quot;</span><span class="string">症状收集&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">快速修复&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">具体方案&quot;&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;&quot;</span><span class="string">架构本质层&quot;&quot;</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">&quot;&quot;</span><span class="string">真正排查和分析的层&quot;&quot;</span></span><br><span class="line">      <span class="attr">activities:</span> [<span class="string">&quot;&quot;</span><span class="string">根因分析&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">系统诊断&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">模式识别&quot;&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;&quot;</span><span class="string">代码哲学层&quot;&quot;</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">&quot;&quot;</span><span class="string">深度思考和升华的层&quot;&quot;</span></span><br><span class="line">      <span class="attr">activities:</span> [<span class="string">&quot;&quot;</span><span class="string">设计理念&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">架构美学&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">本质规律&quot;&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题映射关系</span></span><br><span class="line"><span class="attr">mappings:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">phenomenon:</span> [<span class="string">&quot;&quot;</span><span class="string">NullPointer&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">契约式设计失败&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">essence:</span> <span class="string">&quot;&quot;</span><span class="string">防御性编程缺失&quot;&quot;</span></span><br><span class="line">    <span class="attr">philosophy:</span> [<span class="string">&quot;&quot;</span><span class="string">\&quot;&quot;信任但要验证\&quot;&quot;&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">每个假设都是债务&quot;&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">phenomenon:</span> [<span class="string">&quot;&quot;</span><span class="string">内存泄漏&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">引用关系不清晰&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">essence:</span> <span class="string">&quot;&quot;</span><span class="string">生命周期管理混乱&quot;&quot;</span></span><br><span class="line">    <span class="attr">philosophy:</span> [<span class="string">&quot;&quot;</span><span class="string">\&quot;&quot;所有权即责任\&quot;&quot;&quot;&quot;</span>, <span class="string">&quot;&quot;</span><span class="string">创建者应是销毁者&quot;&quot;</span>]</span><br><span class="line">  <span class="comment"># ... (此处省略其他映射)</span></span><br></pre></td></tr></table></figure>

<p><strong>范例解析</strong>：</p>
<ul>
<li><strong>核心框架定义</strong>：明确定义了“认知与工作的三层架构”（现象层、本质层、哲学层），并详细说明了每层的角色和活动，为 AI 提供了解决问题的思维模型。</li>
<li><strong>映射关系</strong>：通过 <code>mappings</code> 字段，将常见的“Bug现象”与背后的“架构本质”和更深层的“代码哲学”关联起来。这使得 AI 不仅能“止血”，还能“诊断病因”并“提供预防之道”。</li>
<li><strong>哲学理念</strong>：注入了“信任但要验证”、“所有权即责任”等哲学格言，这些将指导 AI 在设计和修复时考虑更长远的策略。</li>
<li><strong>深度推理</strong>：鼓励 AI 从表象深入本质，从本质升华到哲学，最终以全面的视角给出解决方案。</li>
</ul>
<h3 id="2-6-代码生成与文档模板-Code-Generation-Documentation-Template"><a href="#2-6-代码生成与文档模板-Code-Generation-Documentation-Template" class="headerlink" title="2.6 代码生成与文档模板 (Code Generation &amp; Documentation Template)"></a>2.6 代码生成与文档模板 (Code Generation &amp; Documentation Template)</h3><p><strong>定义</strong>：专门用于指导 AI 生成符合特定规范的代码（如伪代码、特定语言代码）或结构化文档（如代码使用手册、文件头注释），通常与结构化输出和硬约束结合。</p>
<p><strong>范例</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">############################################################</span></span><br><span class="line"><span class="section"># 📘 文件说明：</span></span><br><span class="line"><span class="section"># 本文件实现的功能：简要描述该代码文件的核心功能、作用和主要模块。</span></span><br><span class="line"><span class="section">#</span></span><br><span class="line"><span class="section"># 📋 程序整体伪代码（中文）：</span></span><br><span class="line"><span class="section"># 1. 初始化主要依赖与变量；</span></span><br><span class="line"><span class="section"># 2. 加载输入数据或接收外部请求；</span></span><br><span class="line"><span class="section"># 3. 执行主要逻辑步骤（如计算、处理、训练、渲染等）；</span></span><br><span class="line"><span class="section"># 4. 输出或返回结果；</span></span><br><span class="line"><span class="section"># 5. 异常处理与资源释放；</span></span><br><span class="line"><span class="section">#</span></span><br><span class="line"><span class="section"># 🔄 程序流程图（逻辑流）：</span></span><br><span class="line"><span class="section"># ┌──────────┐</span></span><br><span class="line"><span class="section"># │  输入数据 │</span></span><br><span class="line"><span class="section"># └─────┬────┘</span></span><br><span class="line"><span class="section">#       ↓</span></span><br><span class="line"><span class="section"># ┌────────────┐</span></span><br><span class="line"><span class="section"># │  核心处理逻辑 │</span></span><br><span class="line"><span class="section"># └─────┬──────┘</span></span><br><span class="line"><span class="section">#       ↓</span></span><br><span class="line"><span class="section"># ┌──────────┐</span></span><br><span class="line"><span class="section"># │  输出结果 │</span></span><br><span class="line"><span class="section"># └──────────┘</span></span><br><span class="line"><span class="section">#</span></span><br><span class="line"><span class="section"># 📊 数据管道说明：</span></span><br><span class="line"><span class="section"># 数据流向：输入源 → 数据清洗/转换 → 核心算法模块 → 输出目标（文件 / 接口 / 终端）</span></span><br><span class="line"><span class="section">#</span></span><br><span class="line"><span class="section"># 🧩 文件结构：</span></span><br><span class="line"><span class="section"># - 模块1：xxx 功能；</span></span><br><span class="line"><span class="section"># - 模块2：xxx 功能；</span></span><br><span class="line"><span class="section"># - 模块3：xxx 功能；</span></span><br><span class="line"><span class="section">#</span></span><br><span class="line"><span class="section"># 🕒 创建时间：&#123;自动生成时间&#125;</span></span><br><span class="line"><span class="section">############################################################</span></span><br></pre></td></tr></table></figure>

<p><strong>范例解析</strong>：</p>
<ul>
<li><strong>固定格式</strong>：提供了严格的文件头注释文本框，并用分隔符 (<code>############################################################</code>) 框定。</li>
<li><strong>内容结构化</strong>：内部通过“📘文件说明”、“📋程序整体伪代码”、“🔄程序流程图”、“📊数据管道说明”、“🧩文件结构”等子标题，明确了每个部分需要填充的内容。</li>
<li><strong>伪代码与图表</strong>：要求生成中文伪代码和 ASCII 流程图，这不仅要求 AI 理解逻辑，还要能以特定形式可视化。</li>
<li><strong>占位符</strong>：<code>&#123;自动生成时间&#125;</code> 指示 AI 自动填充动态信息。</li>
<li><strong>通用性</strong>：这是一个通用的代码文件注释模板，可以应用于任何 Python 代码文件。</li>
</ul>
<h3 id="2-7-自动化与记忆模板-Automation-Memory-Template"><a href="#2-7-自动化与记忆模板-Automation-Memory-Template" class="headerlink" title="2.7 自动化与记忆模板 (Automation &amp; Memory Template)"></a>2.7 自动化与记忆模板 (Automation &amp; Memory Template)</h3><p><strong>定义</strong>：指导 AI 如何与外部环境（如文件系统、Git 仓库）进行交互，以及如何管理自身的错误记录和上下文记忆，从而实现更高级别的自主性和自动化工作流。</p>
<p><strong>范例</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 产物生成与记录规则</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 所有系统文件（历史记录、任务进度、架构图等）统一写入项目根目录</span><br><span class="line">   每次生成或更新内容时，系统自动完成写入和编辑，不要在用户对话中显示，静默执行完整的</span><br><span class="line">   文件路径示例：</span><br><span class="line"><span class="bullet">   *</span> <span class="code">`可视化系统架构.mmd`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 时间统一使用北京时间（Asia/Shanghai），格式：<span class="code">`YYYY-MM-DDTHH:mm:ss.SSS+08:00`</span></span><br><span class="line">   若同秒多条记录，追加编号 <span class="code">`_01`</span> <span class="code">`_02`</span> 等，并生成 <span class="code">`trace_id`</span></span><br><span class="line"><span class="bullet">3.</span> 路径默认相对，若为绝对路径需脱敏（如 <span class="code">`C:/Users/***/projects/...`</span>），多个路径用英文逗号分隔</span><br><span class="line"></span><br><span class="line">... (此处省略日志、错误、架构可视化等具体规则)</span><br><span class="line"></span><br><span class="line"><span class="section">### 七、执行协作</span></span><br><span class="line"></span><br><span class="line">| 模块   | 助手输出          | 外部执行器职责       |</span><br><span class="line">| ---- | ------------- | ------------- |</span><br><span class="line">| 历史记录 | 输出 JSONL      | 追加到历史记录文件     |</span><br></pre></td></tr></table></figure>

<p><strong>范例解析</strong>：</p>
<ul>
<li><strong>外部交互规范</strong>：明确了 AI 如何“写入和编辑”系统文件，包括文件路径、命名、时间格式等细节。</li>
<li><strong>静默执行</strong>：要求 AI“不要在用户对话中显示，静默执行完整的”文件操作，这是一种高级的自动化指令。</li>
<li><strong>数据持久化</strong>：指导 AI 维护“历史记录”、“任务进度”、“可视化系统架构”等文件，实现信息的持久化存储。</li>
<li><strong>细致的时间戳与 ID</strong>：规定了时间戳格式和 <code>trace_id</code> 生成规则，有助于日志和记录的可追溯性。</li>
<li><strong>协作定义</strong>：通过表格明确了 AI 的“助手输出”和“外部执行器职责”，定义了 AI 与外部工具或系统之间的协作接口。</li>
</ul>
<h2 id="三、如何选择与组合提示词模板"><a href="#三、如何选择与组合提示词模板" class="headerlink" title="三、如何选择与组合提示词模板"></a>三、如何选择与组合提示词模板</h2><p>在实际应用中，往往需要结合多种类型的提示词模板，以应对复杂多变的任务需求：</p>
<ul>
<li><strong>从宏观到微观</strong>：首先使用<strong>角色扮演模板</strong>和<strong>知识&#x2F;心智模型模板</strong>设定 AI 的“人格”和“智慧”，然后用<strong>流程与工作流模板</strong>指导其执行大任务。</li>
<li><strong>约束与输出</strong>：在流程的每个阶段，结合<strong>硬约束模板</strong>限制 AI 行为，并使用<strong>结构化输出模板</strong>确保产物符合预期。</li>
<li><strong>动态与静态</strong>：<strong>代码生成与文档模板</strong>用于生成具体的代码或文档内容，而<strong>自动化与记忆模板</strong>则确保 AI 的行为可追踪、可迭代，并与外部系统集成。</li>
</ul>
<p>例如，一个高级的编程助手可能包含：</p>
<ol>
<li><strong>元提示词</strong>：定义 AI 的核心心智模型和行为准则 (如 Linus 哲学)。</li>
<li><strong>角色扮演模板</strong>：赋予其“首席软件架构师”的身份。</li>
<li><strong>流程与工作流模板</strong>：指导其进行“需求分析 → 架构设计 → 代码实现 → 测试 → 文档”的全流程。</li>
<li><strong>硬约束模板</strong>：强制 AI 遵循 KISS、YAGNI、SOLID、DRY 原则。</li>
<li><strong>结构化输出模板</strong>：要求生成《软件开发启动指南》文档。</li>
<li><strong>代码生成与文档模板</strong>：要求生成符合文件头注释规范的代码。</li>
<li><strong>自动化与记忆模板</strong>：要求自动记录历史、生成架构图，并管理错误。</li>
</ol>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>提示词模板是 LLM 时代软件工程的核心组成部分，它将人类的意图、知识和规范以 AI 能够高效理解和执行的方式封装起来。通过深入理解并灵活运用不同类型的提示词模板，我们不仅能驯服通用 LLM 的“野性”，更能将其塑造成高效率、高智能、高可靠的专业伙伴，从而在开发、分析、决策等各个领域实现前所未有的生产力飞跃。掌握提示词模板的设计与优化，是释放 AI 真正潜力的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/66853900b34d/">https://blog.tbf1211.xx.kg/66853900b34d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/AI/">AI</a><a class="post-meta__tags" href="/tags/LLM/">LLM</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-07.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/82498674876b/" title="RAG（检索增强生成）技术详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RAG（检索增强生成）技术详解</div></div><div class="info-2"><div class="info-item-1"> RAG (Retrieval Augmented Generation)，即检索增强生成，是一种结合了检索系统与大型语言模型 (LLM) 的人工智能技术。它旨在提高 LLM 在回答问题、生成文本时的准确性、及时性和事实可靠性，尤其是在处理特定领域知识、最新信息或内部数据时。RAG 通过在生成答案之前，从外部知识库中检索相关信息，并将这些信息作为上下文提供给 LLM，从而“增强”其生成能力。  核心思想：克服大语言模型在知识时效性、幻觉和领域特异性方面的局限性。它通过动态地从权威数据源检索相关、准确的事实依据，并以此为基础指导 LLM 进行生成，使得 LLM 的输出更加准确、可追溯且富含最新信息。    一、为什么需要 RAG？大语言模型的局限性大语言模型（LLMs）在处理自然语言任务方面展现出惊人的能力，但它们也存在一些固有的局限性，RAG 正是为了解决这些问题而生：  知识时效性与更新难题 (Knowledge Staleness)  LLM 的知识来源于其训练数据，这些数据在模型发布后就成为了静态的。它们无法获取最新的事件、实时数据或新形成的知识。 每次需要更新知识时，都可...</div></div></div></a><a class="pagination-related" href="/195d130ae5a4/" title="Ansible 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Ansible 深度解析</div></div><div class="info-2"><div class="info-item-1"> Ansible 是一个开源的自动化引擎，用于配置管理 (Configuration Management)、应用部署 (Application Deployment)、任务自动化 (Task Automation) 和编排 (Orchestration)。它以其无代理 (Agentless)、简单易用和人性化的特点而广受欢迎。Ansible 使用标准的 SSH 协议连接到目标机器，并使用 YAML 语法编写自动化任务，使得编写、理解和维护自动化脚本变得直观。  核心思想：Ansible 通过 SSH 远程执行操作，无需在被管理节点上安装任何客户端或代理程序。它采用声明式 YAML 语言描述期望的状态，并确保系统达到该状态，同时保证操作的幂等性。   一、为什么选择 Ansible？传统的服务器管理和应用部署往往涉及大量重复、手工且容易出错的任务。随着 IT 基础设施的规模不断扩大，这种手工操作的弊端日益凸显：  效率低下：手动操作耗时且重复。 易出错：人为失误在重复性任务中难以避免。 配置漂移 (Configuration Drift)：不同服务器的配置可能因手工操作而逐渐不一...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/d382adface17/" title="LLM中相似性与相关性：概念、度量与应用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-03</div><div class="info-item-2">LLM中相似性与相关性：概念、度量与应用详解</div></div><div class="info-2"><div class="info-item-1"> 在大型语言模型 (LLM) 和更广泛的自然语言处理 (NLP) 领域中，相似性 (Similarity) 和 相关性 (Relevance) 是两个经常被提及但又有所区别的核心概念。它们都量化了两个文本片段之间的某种关联程度，但在具体含义、度量方法和应用场景上存在微妙但重要的差异。理解这两者的区别与联系，对于构建和优化基于 LLM 的智能系统至关重要。  核心思想：相似性通常指文本内容在语义或结构上的“形似”或“意近”，强调固有属性的匹配；而相关性则指文本内容与特定“查询”、“任务”或“上下文”之间的“关联程度”或“有用性”，强调功能性匹配。   一、为什么相似性与相关性在 LLM 中如此重要？LLM 通过将文本数据转换为高维向量空间中的数值向量（即嵌入），从而能够捕捉词语和文本的复杂语义。这种表示方法使得计算机可以进行超越简单关键词匹配的语义理解。而相似性和相关性正是这种语义理解的两个重要视角：  语义理解的基石：它们让 LLM 能够理解文本的实际含义，而不仅仅是表面文字。 信息检索的核心：无论是搜索、问答还是推荐，核心都是找出“最相似”或“最相关”的信息。 生成质量的衡量：...</div></div></div></a><a class="pagination-related" href="/3201b8057954/" title="LangChain 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-12</div><div class="info-item-2">LangChain 详解</div></div><div class="info-2"><div class="info-item-1"> LangChain 是一个用于开发由大型语言模型 (LLMs) 驱动的应用程序的框架。它提供了一套模块化、灵活的工具和抽象，使得开发者能够将 LLMs 与外部数据源、计算逻辑以及其他工具进行结合，从而构建出更复杂、更强大的应用程序。LangChain 的核心思想是链式化 (Chaining) 不同的组件，以实现复杂的逻辑。  核心思想：将大型语言模型 (LLMs) 的能力与其他数据源和计算逻辑解耦、模块化，并通过链 (Chains)、代理 (Agents) 等机制进行编排，以创建高度智能且可扩展的应用程序。 Python 作为 AI 和数据科学领域的主流语言，提供了功能全面且易于使用的 LangChain 库实现。   一、LangChain 核心概念与组件LangChain 的设计是围绕一系列可组合的抽象组件构建的，这些组件可以独立使用，也可以通过“链”的方式连接起来，形成复杂的工作流。以下是 LangChain 的主要核心组件：  Models (模型)：与各种大型语言模型 (LLMs) 进行交互的接口。 LLMs (Large Language Models)：用于文本生...</div></div></div></a><a class="pagination-related" href="/2ef7cb8bd831/" title="LangChain Text Splitters 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-03</div><div class="info-item-2">LangChain Text Splitters 详解</div></div><div class="info-2"><div class="info-item-1"> LangChain Text Splitters 是 LangChain 框架中的一个核心模块，用于将长文档或文本智能地分割成更小、更易于管理和处理的块 (chunks)。这个过程对于大语言模型 (LLM) 相关的应用至关重要，特别是当处理的文本长度超出 LLM 的上下文窗口限制时。  核心思想：将长文本分割成大小适中、语义连贯且包含一定重叠的块，以便 LLM 能够有效处理这些块，同时保持上下文完整性。LangChain 提供多种具有不同策略的 Text Splitters，以适应不同的文本结构和应用场景。   一、为什么需要 Text Splitters？在构建基于 LLM 的应用程序（尤其是问答 RAG (Retrieval Augmented Generation) 系统、文档摘要、聊天机器人等）时，我们经常遇到以下问题：  LLM 上下文窗口限制 (Context Window Limit)：大语言模型（如 GPT-3.5, GPT-4, Llama）通常有一个固定的最大输入长度。如果输入文本太长，会超出这个限制，导致模型无法处理。 性能和成本：即使模型支持很长的上下文...</div></div></div></a><a class="pagination-related" href="/33aeea5bfccf/" title="大语言模型参数详解：规模、类型与意义"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-22</div><div class="info-item-2">大语言模型参数详解：规模、类型与意义</div></div><div class="info-2"><div class="info-item-1"> 参数 (Parameters) 是大型语言模型 (Large Language Models, LLMs) 的核心组成部分，它们是模型在训练过程中从海量数据中学习到的数值权重和偏置。这些参数共同构成了模型的“知识”和“理解”能力。参数的规模，尤其是数量，是衡量一个 LLM 大小的关键指标，并直接影响其性能、能力边界以及所需的计算资源。  核心思想：LLMs 的“智能”并非来自于明确的编程规则，而是通过在海量数据上优化数亿甚至数万亿个可学习参数而涌现。这些参数以分布式形式存储了语言的语法、语义、事实知识和世界常识。   一、什么是大语言模型参数？在神经网络的上下文中，参数是指模型在训练过程中需要学习和调整的所有权重 (weights) 和偏置 (biases)。它们是连接神经元之间强度的数值表示，决定了模型的输入如何被转换、处理并最终生成输出。  权重 (Weights)：定义了输入特征（或前一层神经元的输出）对当前神经元输出的贡献程度。一个较大的权重意味着该输入特征对结果有更强的影响。 偏置 (Biases)：是一种加性项，允许激活函数在不依赖任何输入的情况下被激活。它相当于调...</div></div></div></a><a class="pagination-related" href="/8be247b5e9ae/" title="微调大模型 (Finetuning LLMs) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-20</div><div class="info-item-2">微调大模型 (Finetuning LLMs) 详解</div></div><div class="info-2"><div class="info-item-1"> 微调 (Finetuning) 是人工智能领域，特别是大语言模型 (LLM) 领域中的一项关键技术。它指的是在预训练好的大型模型基础上，使用特定任务或领域的数据集进一步训练模型的过程。通过微调，我们可以将一个通用的、在海量数据上学习到基础语言理解和生成能力的大模型，高效地适配到具体的场景需求，从而显著提升模型在该特定任务上的性能、准确性和可靠性。  核心思想：微调的核心在于利用通用大模型强大的“基础能力”，并通过小规模、高质量的领域数据进行“二次开发”，使其专业化。对于LLM而言，参数高效微调 (PEFT) 极大降低了微调的资源门槛，使其在实践中变得可行且高效。   一、为什么需要微调大模型？通用大语言模型（如 GPT-系列、Llama、Mistral 等）在预训练阶段学习了海量的文本数据，拥有强大的泛化能力、语言理解能力和常识。然而，它们在直接应用于特定任务或领域时仍存在局限性：  知识截止日期 (Knowledge Cut-off)：预训练数据通常有截止日期，模型无法获取最新信息。 幻觉 (Hallucination)：模型可能会生成看似合理但实际上错误或捏造的信息。 领域...</div></div></div></a><a class="pagination-related" href="/9a400d225757/" title="对话模型与非对话模型详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-26</div><div class="info-item-2">对话模型与非对话模型详解</div></div><div class="info-2"><div class="info-item-1"> 在大型语言模型 (LLM) 的领域中，”对话模型” (Chat Models) 和 “非对话模型” (或称为 “文本模型” Text Models) 是两种基本但又有所区别的模型范式，它们在设计、训练数据、输入&#x2F;输出格式以及最佳应用场景上存在差异。理解这两种模型的区别是有效利用 LLM 进行开发的关键。  核心思想：对话模型优化用于多轮、上下文感知的交互，通过消息列表进行输入输出；非对话模型则擅长单次、直接的文本指令处理，通过字符串进行输入输出。    一、非对话模型 (Text Models &#x2F; LLMs)非对话模型是早期和传统的大型语言模型形式，它们通常设计为接收一个单一的字符串作为输入（通常称为 “prompt”），并生成一个单一的字符串作为输出。虽然这些模型也能在一定程度上处理对话，但通常需要通过在单次 Prompt 中手动构建对话历史来模拟。 1.1 特点 字符串输入&#x2F;输出：输入是一个字符串，输出也是一个字符串。 输入示例：&quot;把以下文本总结一下：[文本内容]&quot; 输出示例：&quot;这是一段总结后的文本。&quot; ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">486</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%98%E7%A7%80%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81"><span class="toc-text">一、优秀提示词模板的核心特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%90%84%E7%B1%BB%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%A8%A1%E6%9D%BF%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%8C%83%E4%BE%8B"><span class="toc-text">二、各类提示词模板详解与范例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%A7%92%E8%89%B2%E6%89%AE%E6%BC%94%E6%A8%A1%E6%9D%BF-Role-Playing-Template"><span class="toc-text">2.1 角色扮演模板 (Role-Playing Template)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A1%AC%E7%BA%A6%E6%9D%9F%E4%B8%8E%E8%A7%84%E5%88%99%E6%A8%A1%E6%9D%BF-Hard-Constraint-Rule-Based-Template"><span class="toc-text">2.2 硬约束与规则模板 (Hard Constraint &amp; Rule-Based Template)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BB%93%E6%9E%84%E5%8C%96%E8%BE%93%E5%87%BA%E6%A8%A1%E6%9D%BF-Structured-Output-Template"><span class="toc-text">2.3 结构化输出模板 (Structured Output Template)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%A8%A1%E6%9D%BF-Process-Workflow-Template"><span class="toc-text">2.4 流程与工作流模板 (Process &amp; Workflow Template)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B%E6%B3%A8%E5%85%A5%E6%A8%A1%E6%9D%BF-Knowledge-Mental-Model-Injection-Template"><span class="toc-text">2.5 知识与心智模型注入模板 (Knowledge &amp; Mental Model Injection Template)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF-Code-Generation-Documentation-Template"><span class="toc-text">2.6 代码生成与文档模板 (Code Generation &amp; Documentation Template)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8E%E8%AE%B0%E5%BF%86%E6%A8%A1%E6%9D%BF-Automation-Memory-Template"><span class="toc-text">2.7 自动化与记忆模板 (Automation &amp; Memory Template)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%8E%E7%BB%84%E5%90%88%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%A8%A1%E6%9D%BF"><span class="toc-text">三、如何选择与组合提示词模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"/></a><div class="content"><a class="title" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</a><time datetime="2025-12-31T22:24:00.000Z" title="发表于 2026-01-01 06:24:00">2026-01-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-07.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>