<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>KCP协议详解：一个快速可靠的UDP上层协议 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="KCP (Fast and Reliable UDP protocol) 是一个由 skywind3000 (吴云) 在 2014 年开源的快速可靠的 UDP 上层协议。它的设计目标是在网络状况不佳（高延迟、高丢包率）的环境下，提供比 TCP 更快的传输速度和更低的延迟，同时保持数据的可靠性。KCP 并不是一个完整的网络协议栈，而是一个可嵌入式的库，它运行在 UDP 协议之上，提供了 TCP 所">
<meta property="og:type" content="article">
<meta property="og:title" content="KCP协议详解：一个快速可靠的UDP上层协议">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/9be87a9e79b5/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="KCP (Fast and Reliable UDP protocol) 是一个由 skywind3000 (吴云) 在 2014 年开源的快速可靠的 UDP 上层协议。它的设计目标是在网络状况不佳（高延迟、高丢包率）的环境下，提供比 TCP 更快的传输速度和更低的延迟，同时保持数据的可靠性。KCP 并不是一个完整的网络协议栈，而是一个可嵌入式的库，它运行在 UDP 协议之上，提供了 TCP 所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg">
<meta property="article:published_time" content="2023-03-12T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-24T14:25:00.946Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="UDP">
<meta property="article:tag" content="KCP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "KCP协议详解：一个快速可靠的UDP上层协议",
  "url": "https://blog.tbf1211.xx.kg/9be87a9e79b5/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg",
  "datePublished": "2023-03-12T22:24:00.000Z",
  "dateModified": "2026-01-24T14:25:00.946Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/9be87a9e79b5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KCP协议详解：一个快速可靠的UDP上层协议',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">518</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">KCP协议详解：一个快速可靠的UDP上层协议</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">KCP协议详解：一个快速可靠的UDP上层协议</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-12T22:24:00.000Z" title="发表于 2023-03-13 06:24:00">2023-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>KCP (Fast and Reliable UDP protocol)</strong> 是一个由 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/skywind3000">skywind3000</a> (吴云) 在 2014 年开源的<strong>快速可靠的 UDP 上层协议</strong>。它的设计目标是在网络状况不佳（高延迟、高丢包率）的环境下，提供比 TCP 更快的传输速度和更低的延迟，同时保持数据的可靠性。KCP 并不是一个完整的网络协议栈，而是一个可嵌入式的库，它运行在 UDP 协议之上，提供了 TCP 所具备的可靠性、流量控制和拥塞控制等机制，但针对延迟和重传进行了优化。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：在保障数据可靠性的前提下，通过<strong>优化重传机制、激进发送和控制重传间隔</strong>等方法，尽可能地减少传输延迟，以适应游戏、实时音视频等对延迟高度敏感的应用。</p>
</div>
<hr>
<h2 id="一、为什么需要-KCP？"><a href="#一、为什么需要-KCP？" class="headerlink" title="一、为什么需要 KCP？"></a>一、为什么需要 KCP？</h2><p>TCP 协议是互联网上最常用的可靠传输协议，但它在一些场景下存在明显的局限性：</p>
<ol>
<li><strong>慢启动 (Slow Start)</strong>：TCP 为了避免网络拥塞，在连接建立初期会限制发送速率，逐渐增加。这对于短连接或突发数据传输会增加初始延迟。</li>
<li><strong>队头阻塞 (Head-of-Line Blocking, HOLB)</strong>：TCP 的报文是严格按序到达的。如果某个数据包丢失，后续所有已到达但序号更大的数据包必须在缓冲区中等待该丢失包重传成功并按序递交，从而造成延迟。</li>
<li><strong>重传策略</strong>：TCP 的重传通常是基于定时器或三次重复 ACK。当数据包丢失时，需要等待较长时间才能触发重传，这在延迟敏感的应用中是不可接受的。</li>
<li><strong>固定拥塞控制</strong>：TCP 的拥塞控制算法（如 Reno、Cubic）是为了普适场景设计的，对于某些特定应用（如游戏）可能过于保守，或者响应不够迅速。</li>
</ol>
<p>UDP 虽然提供了极低的延迟和高度的灵活性，但它是<strong>不可靠</strong>的，不保证数据传输的顺序、完整性和不重复。</p>
<p>KCP 的出现就是为了<strong>结合 UDP 的低延迟优势，并克服 TCP 在特定场景下的不足</strong>，在一个可靠数据传输的基础上，提供：</p>
<ul>
<li><strong>更低的首次发送延迟</strong>：通过不依赖队列长度、直接发送等手段减少延迟。</li>
<li><strong>更快的重传响应</strong>：通过更激进的 ACK 机制和更短的重传间隔实现。</li>
<li><strong>在丢包率高的情况下性能更好</strong>：通过选择性重传等方式，减少队头阻塞。</li>
</ul>
<p>因此，KCP 主要应用于：</p>
<ul>
<li><strong>实时在线游戏</strong>：对延迟要求极高，偶发丢包总比卡顿或长时间延迟好。</li>
<li><strong>实时音视频通话</strong>：需要稳定的低延迟传输。</li>
<li><strong>边缘计算、物联网数据传输</strong>：在网络质量不稳定的环境下需要可靠高效传输。</li>
</ul>
<h2 id="二、KCP-与-TCP-的关键差异与优化"><a href="#二、KCP-与-TCP-的关键差异与优化" class="headerlink" title="二、KCP 与 TCP 的关键差异与优化"></a>二、KCP 与 TCP 的关键差异与优化</h2><p>KCP 借鉴了 TCP 的一些机制，但对其进行了激进的优化，以达到低延迟的目标：</p>
<h3 id="2-1-队头阻塞优化"><a href="#2-1-队头阻塞优化" class="headerlink" title="2.1 队头阻塞优化"></a>2.1 队头阻塞优化</h3><ul>
<li><strong>TCP</strong>：严格的<strong>字节流</strong>模型，所有数据必须完全按序到达才能递交上层应用。一个丢包会导致所有后续包的阻塞。</li>
<li><strong>KCP</strong>：基于<strong>报文</strong>模型，每个报文都有自己的序号。KCP 仍然保证数据按序递交上层应用，但其重传机制允许接收方缓存乱序到达的报文，并在丢失报文到达后快速递交。</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph TCP Head-of-Line Blocking
        C1(Packet 1) -- OK --&gt; S1(Buffer)
        C2(Packet 2) -- OK --&gt; S2(Buffer)
        C3(Packet 3) -- Lost --&gt;
        C4(Packet 4) -- OK --&gt; S4(Buffer - Waiting)
        C5(Packet 5) -- OK --&gt; S5(Buffer - Waiting)
        S1 --&gt; App(递交 App)
        S2 --&gt; App
        S4 -.-&gt; App(阻塞)
        S5 -.-&gt; App(阻塞)
        subgraph Retransmission
            R3(Packet 3 Resend) --&gt; S3(Buffer)
        end
        S3 --&gt; App(解除阻塞)
        S4 --&gt; App
        S5 --&gt; App
    end

    subgraph KCP Optimized for HOLB
        K_C1(Packet 1) -- OK --&gt; K_S1(Buffer)
        K_C2(Packet 2) -- OK --&gt; K_S2(Buffer)
        K_C3(Packet 3) -- Lost --&gt;
        K_C4(Packet 4) -- OK --&gt; K_S4(Buffer - Cached)
        K_C5(Packet 5) -- OK --&gt; K_S5(Buffer - Cached)
        K_S1 --&gt; K_App(递交 App)
        K_S2 --&gt; K_App
        subgraph Retransmission
            K_R3(Packet 3 Resend) --&gt; K_S3(Buffer)
        end
        K_S3 --&gt; K_App(递交 App)
        K_S4 --&gt; K_App(递交 App)
        K_S5 --&gt; K_App(递交 App)
    end
  </pre></div>

<h3 id="2-2-ACK-与重传机制"><a href="#2-2-ACK-与重传机制" class="headerlink" title="2.2 ACK 与重传机制"></a>2.2 ACK 与重传机制</h3><ul>
<li><strong>TCP</strong>：<ul>
<li><strong>累积 ACK</strong>：一个 ACK 确认它之前的所有数据包。</li>
<li><strong>重传定时器</strong>：基于 RTT (Round Trip Time) 动态调整重传间隔。通常较长，避免不必要的重传。</li>
<li><strong>三次重复 ACK</strong>：快速重传机制，避免等待定时器超时。</li>
</ul>
</li>
<li><strong>KCP</strong>：<ul>
<li><strong>可选 ACK</strong>：除了累积 ACK 之外，KCP 还有一个叫 <code>UNA</code> (Unacked Number) 的机制，类似于选择性 ACK (SACK)。ACK 包中会带上当前已收到的报文序号，即使中间有丢包。</li>
<li><strong>激进重传 (Turbo retransmission)</strong>：<ul>
<li>不仅使用超时重传，还使用<strong>快速重传</strong>。当发送方收到重复的 ACK (<code>ack_nodata</code>) 且达到一定阈值（可通过参数配置，默认为 2 次）时，会立即重传对应的丢失报文。</li>
<li>KCP 的重传定时器远小于 TCP，可以通过参数 <code>ikcp_nodelay(1, 10, 2, 1)</code>（nodelay&#x3D;1, interval&#x3D;10ms, resend&#x3D;2, nc&#x3D;1）开启激进模式。interval 是内部循环的刷新间隔，resend 是快速重传阈值，nc&#x3D;1 代表关闭拥塞控制。</li>
</ul>
</li>
<li><strong>小延迟 ACK</strong>：KCP 收到报文后不会立即发送 ACK，而是延迟一小段时间（默认 30ms），尝试将多个 ACK 打包到一个 UDP 包中发送，以节省带宽。但在 <code>ikcp_nodelay(1, x, x, 1)</code> 模式下，这个延迟会减少或取消。</li>
</ul>
</li>
</ul>
<h3 id="2-3-拥塞控制与流量控制"><a href="#2-3-拥塞控制与流量控制" class="headerlink" title="2.3 拥塞控制与流量控制"></a>2.3 拥塞控制与流量控制</h3><ul>
<li><strong>TCP</strong>：严格的慢启动、拥塞避免、快速重传、快速恢复机制。旨在公平地占用带宽，保护网络。</li>
<li><strong>KCP</strong>：<ul>
<li><strong>可选拥塞控制</strong>：KCP 提供了多种拥塞控制模式，可以通过参数配置。在游戏等场景中，有时会选择关闭或弱化拥塞控制 (<code>ikcp_nodelay</code> 的 <code>nc</code> 参数)。</li>
<li><strong>发送窗口 (Send Window)</strong>：与 TCP 类似，限制飞行中（已发送未确认）的数据量，防止发送方过载接收方。</li>
<li><strong>接收窗口 (Receive Window)</strong>：限制接收方可接收的数据量，防止接收缓冲区溢出。</li>
</ul>
</li>
</ul>
<h3 id="2-4-其他优化"><a href="#2-4-其他优化" class="headerlink" title="2.4 其他优化"></a>2.4 其他优化</h3><ul>
<li><strong>非延迟 ACK (NoDelay ACK)</strong>：TCP 的 ACK 通常有一个延时（用于合并 ACK）。KCP 允许立即发送 ACK，降低延迟。</li>
<li><strong>流量整形 (Flow Shaping)</strong>：KCP 的内部缓冲区管理允许更细粒度的流量控制。</li>
<li><strong>可调参数</strong>：KCP 提供了大量的参数供开发者根据应用场景和网络环境进行调优，例如窗口大小、重传间隔、重传阈值、是否开启拥塞控制等。</li>
</ul>
<h2 id="三、KCP-的核心数据结构与-API"><a href="#三、KCP-的核心数据结构与-API" class="headerlink" title="三、KCP 的核心数据结构与 API"></a>三、KCP 的核心数据结构与 API</h2><p>KCP 作为一个库，对外提供了一组 C 语言风格的 API，其核心是 <code>ikcp_send</code>, <code>ikcp_recv</code>, <code>ikcp_update</code>, <code>ikcp_input</code>, <code>ikcp_flush</code> 等函数。</p>
<h3 id="3-1-核心数据结构：ikcpcb"><a href="#3-1-核心数据结构：ikcpcb" class="headerlink" title="3.1 核心数据结构：ikcpcb"></a>3.1 核心数据结构：<code>ikcpcb</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IKCPCB</span> &#123;</span></span><br><span class="line">    IUINT32 conv; <span class="comment">// 会话ID，与对端匹配</span></span><br><span class="line">    IUINT32 mtu;  <span class="comment">// 最大传输单元，默认 1400</span></span><br><span class="line"></span><br><span class="line">    IUINT32 state; <span class="comment">// 连接状态</span></span><br><span class="line">    IUINT32 snd_una; <span class="comment">// 发送数据中，最小还未确认的序号</span></span><br><span class="line">    IUINT32 snd_nxt; <span class="comment">// 下一个发送数据序号</span></span><br><span class="line">    IUINT32 rcv_nxt; <span class="comment">// 下一个接收数据序号 (期望接收的序号)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送窗口与接收窗口</span></span><br><span class="line">    IUINT32 snd_wnd; <span class="comment">// 发送窗口大小</span></span><br><span class="line">    IUINT32 rcv_wnd; <span class="comment">// 接收窗口大小</span></span><br><span class="line">    IUINT32 rmt_wnd; <span class="comment">// 远程接收窗口大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重传相关</span></span><br><span class="line">    IUINT32 acklist[<span class="number">256</span>]; <span class="comment">// 待发送的 ACK 列表</span></span><br><span class="line">    IUINT32 ackcount; <span class="comment">// acklist 中的数量</span></span><br><span class="line">    IUINT32 interval; <span class="comment">// 内部时钟更新间隔</span></span><br><span class="line">    IUINT32 rx_srtt; <span class="comment">// smoothed RTT</span></span><br><span class="line">    IUINT32 rx_rttval; <span class="comment">// RTT variance</span></span><br><span class="line">    IUINT32 rx_rto; <span class="comment">// retransmit timeout (重传超时)</span></span><br><span class="line">    IUINT32 fastresend; <span class="comment">// 快速重传阈值</span></span><br><span class="line">    IUINT32 nodelay; <span class="comment">// 0/1/2 模式控制延迟 (默认0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部数据队列</span></span><br><span class="line">    IKCPSEG *snd_queue; <span class="comment">// 待发送队列</span></span><br><span class="line">    IKCPSEG *rcv_queue; <span class="comment">// 待确认接收队列 (已收到但未递交到应用层)</span></span><br><span class="line">    IKCPSEG *snd_buf;   <span class="comment">// 已发送但未确认队列</span></span><br><span class="line">    IKCPSEG *rcv_buf;   <span class="comment">// 接收缓冲区 (乱序到达的包)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出函数指针</span></span><br><span class="line">    <span class="type">int</span> (*output)(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, <span class="keyword">struct</span> IKCPCB *kcp, <span class="type">void</span> *user);</span><br><span class="line">    <span class="type">void</span> *user; <span class="comment">// 用户自定义数据指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各种状态计数器、拥塞控制相关变量等</span></span><br><span class="line">    IUINT32 cwnd; <span class="comment">// 拥塞窗口</span></span><br><span class="line">    IUINT32 probe; <span class="comment">// 探测类型</span></span><br><span class="line">    IUINT32 current; <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="comment">// ... 更多字段 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-核心-API-Go-语言示例，其他语言类似"><a href="#3-2-核心-API-Go-语言示例，其他语言类似" class="headerlink" title="3.2 核心 API (Go 语言示例，其他语言类似)"></a>3.2 核心 API (Go 语言示例，其他语言类似)</h3><p>KCP 库本身是 C 语言实现，但有多种语言绑定，例如 Go 语言的 <code>github.com/xtaci/kcp</code>。</p>
<ul>
<li><strong><code>Dial()</code> &#x2F; <code>Listen()</code></strong>：建立 KCP 连接。</li>
<li><strong><code>Send(data []byte)</code></strong>：发送数据。将数据添加到 KCP 内部的发送队列。</li>
<li><strong><code>Recv() ([]byte, error)</code></strong>：接收数据。从 KCP 内部的接收队列中获取数据，如果队列为空则阻塞。</li>
<li><strong><code>Update(currentMs uint32)</code></strong>：<strong>KCP 的核心驱动函数</strong>。需要外部定时调用 (通常每隔 10ms - 100ms)，执行 KCP 内部协议逻辑，如超时检测、重传、ACK 处理、窗口更新、发送数据包等。这是一个非阻塞函数。</li>
<li><strong><code>Input(data []byte)</code></strong>：将底层 UDP 接收到的数据包输入到 KCP 实例中。KCP 会解析包头，根据序号和类型进行处理。</li>
<li><strong><code>SetMtu(mtu int)</code></strong>：设置最大传输单元。</li>
<li><strong><code>SetWindow(sndwnd, rcvwnd int)</code></strong>：设置发送窗口和接收窗口大小。</li>
<li><strong><code>SetNoDelay(nodelay, interval, resend, nc int)</code></strong>：设置延迟模式、更新间隔、快速重传阈值和是否禁用拥塞控制。</li>
</ul>
<p><strong>基本使用流程：</strong></p>
<ol>
<li><strong>初始化</strong>：创建 KCP 实例 (<code>ikcp_create</code>)，设置会话 ID (<code>conv</code>)，并设置一个回调 <code>output</code> 函数，该函数负责将 KCP 封装好的 UDP 数据包真正发送出去。</li>
<li><strong>发送</strong>：调用 <code>ikcp_send</code> 发送数据。</li>
<li><strong>接收</strong>：底层 UDP 收到数据后，调用 <code>ikcp_input</code> 将数据注入 KCP 实例。随后，上层应用通过 <code>ikcp_recv</code> 从 KCP 实例中读取数据。</li>
<li><strong>驱动</strong>：在应用层启动一个定时器，每隔一定时间调用 <code>ikcp_update</code> 来驱动 KCP 内部状态机，确保 ACK、重传、窗口更新等机制正常工作。</li>
</ol>
<h2 id="四、配置调优与模式选择"><a href="#四、配置调优与模式选择" class="headerlink" title="四、配置调优与模式选择"></a>四、配置调优与模式选择</h2><p>KCP 的一大特点就是其高度可配置性，允许开发者根据具体应用场景进行调优。</p>
<h3 id="4-1-nodelay-mode"><a href="#4-1-nodelay-mode" class="headerlink" title="4.1 nodelay mode"></a>4.1 nodelay mode</h3><p><code>ikcp_nodelay(1, 10, 2, 1)</code> 是 KCP 最常用的性能模式，参数含义如下：</p>
<ul>
<li><code>nodelay = 1</code>：启用 <code>NoDelay</code> 模式。<ul>
<li><code>0</code>：普通模式，<code>ikcp_update</code> 的调用间隔会随着 RTT 变化，ACK 会延迟发送，更平稳但延迟高。</li>
<li><code>1</code>：启用非延迟模式，ACK 不延迟发送，<code>ikcp_update</code> 的调用间隔固定为 <code>interval</code> 参数。</li>
<li><code>2</code>：极速模式，比 1 更激进，ACK 优先级更高。</li>
</ul>
</li>
<li><code>interval = 10</code>：内部时钟刷新间隔，单位毫秒。<strong>建议 10-100ms</strong>，过小会消耗 CPU 资源，过大会增加延迟。</li>
<li><code>resend = 2</code>：快速重传阈值。在接收方收到 2 个重复 ACK 后，发送方会立即重传该丢包。<strong>建议 2-5</strong>。</li>
<li><code>nc = 1</code>：是否禁用拥塞控制。<ul>
<li><code>0</code>：启用拥塞控制。</li>
<li><code>1</code>：禁用拥塞控制。在游戏等场景，宁可多占带宽也要保证延迟时，可以禁用。但在公网环境下禁用拥塞控制可能导致网络拥塞加剧，应谨慎使用。</li>
</ul>
</li>
</ul>
<h3 id="4-2-窗口大小"><a href="#4-2-窗口大小" class="headerlink" title="4.2 窗口大小"></a>4.2 窗口大小</h3><p><code>ikcp_wndsize(sndwnd, rcvwnd)</code>：</p>
<ul>
<li><code>sndwnd</code>：发送窗口大小。决定了最大允许在途的未确认数据包数量。越大吞吐量越高，但可能浪费带宽或需要更多内存。</li>
<li><code>rcvwnd</code>：接收窗口大小。决定了接收方能缓存的最大乱序数据包数量。越大能容忍的乱序程度越高，但同样需要更多内存。</li>
</ul>
<h3 id="4-3-MTU-Maximum-Transmission-Unit"><a href="#4-3-MTU-Maximum-Transmission-Unit" class="headerlink" title="4.3 MTU (Maximum Transmission Unit)"></a>4.3 MTU (Maximum Transmission Unit)</h3><p><code>ikcp_setmtu(mtu)</code>：</p>
<ul>
<li>通常 UDP MTU 是 1400 字节，如果 KCP 封装的包超过这个值，底层 UDP 层会进行分片，这会增加丢包率。</li>
<li>根据实际网络环境调整 MTU，避免 IP 层分片，例如设置为 1300-1400 字节。</li>
</ul>
<h2 id="五、KCP-的优缺点"><a href="#五、KCP-的优缺点" class="headerlink" title="五、KCP 的优缺点"></a>五、KCP 的优缺点</h2><h3 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h3><ul>
<li><strong>低延迟</strong>：通过激进重传、快速 ACK、可调参数等特性，在网络不佳时比 TCP 具有更低的平均延迟。</li>
<li><strong>高吞吐量</strong>：在丢包率较高时，由于其优化的重传机制和队头阻塞处理，可以保持更好的吞吐量。</li>
<li><strong>高度可配置</strong>：允许开发者根据特定应用场景（如游戏）进行深度调优。</li>
<li><strong>轻量级、嵌入式</strong>：作为一个库，可以方便地嵌入到各种应用中，且资源开销相对较小。</li>
<li><strong>消除队头阻塞</strong>：相比 TCP，乱序数据包的处理更有效，减少了等待重传包的时间。</li>
<li><strong>无专利</strong>：完全开源，无任何专利限制。</li>
</ul>
<h3 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点**"></a>5.2 缺点**</h3><ul>
<li><strong>消耗带宽</strong>：激进重传和更频繁的 ACK 可能会在网络状况良好时导致带宽的额外消耗。</li>
<li><strong>可能会加剧网络拥塞 (如果禁用拥塞控制)</strong>：如果 <code>nc=1</code>，KCP 会不顾网络拥塞地发送数据，这在公网环境下可能对其他流量不公平，甚至加剧拥塞。</li>
<li><strong>不保证公平性</strong>：与 TCP 相比，KCP 不是为了实现网络上的流量公平性而设计的，可能导致“抢占”带宽。</li>
<li><strong>额外开发成本</strong>：KCP 只是一个库，开发者需要自行实现 UDP 绑定、并发处理、底层 socket 操作、多路复用等功能。</li>
<li><strong>需要调优经验</strong>：KCP 的性能很大程度上依赖于合理的参数配置，这需要一定的专业知识和测试。</li>
</ul>
<h2 id="六、KCP-的使用和项目"><a href="#六、KCP-的使用和项目" class="headerlink" title="六、KCP 的使用和项目"></a>六、KCP 的使用和项目</h2><p>KCP 已经被广泛应用于各种场景，特别是在游戏领域：</p>
<ul>
<li><strong>游戏服务器框架</strong>：如 <code>unity-kcp</code> (Unity 游戏引擎)、<code>skynet</code> (Lua 语言游戏服务器)。</li>
<li><strong>VPN&#x2F;隧道代理</strong>：如 <code>kcptun</code>，利用 KCP 优化代理传输速度。</li>
<li><strong>Go 语言库</strong>：<code>github.com/xtaci/kcp</code> 是一个广受欢迎的 Go 语言 KCP 实现，与 Go 的协程机制结合紧密，提供了高性能的网络编程能力。</li>
<li><strong>多种语言绑定</strong>：C++, Java, Python, C#, Rust 等都有 KCP 的实现或绑定。</li>
</ul>
<p><strong>示例 (Go 语言 <code>xtaci/kcp</code> 库)</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/xtaci/kcp-go/v5&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	PORT    = <span class="string">&quot;:8888&quot;</span> <span class="comment">// 服务端端口</span></span><br><span class="line">	CONV_ID = <span class="number">123</span>     <span class="comment">// KCP 会话ID</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleClient</span><span class="params">(conn *kcp.UDPSession)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;客户端 %s 连接成功\n&quot;</span>, conn.RemoteAddr())</span><br><span class="line"></span><br><span class="line">	conn.SetWindowSize(<span class="number">1024</span>, <span class="number">1024</span>) <span class="comment">// 设置KCP发送和接收窗口大小</span></span><br><span class="line">	<span class="comment">// fastresend: 快速重传阈值, noDelay: 开启无延迟模式, interval: KCP刷新间隔, nc: 是否关闭拥塞控制</span></span><br><span class="line">	conn.SetNoDelay(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment">// 设置为激进模式: 无延迟，10ms刷新，2次ACK重传，关闭拥塞控制</span></span><br><span class="line">	conn.SetMtu(<span class="number">1350</span>)            <span class="comment">// 设置MTU以避免IP层分片</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 接收数据</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4096</span>)</span><br><span class="line">		n, err := conn.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;客户端 %s 断开连接\n&quot;</span>, conn.RemoteAddr())</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;读取客户端 %s 数据失败: %v\n&quot;</span>, conn.RemoteAddr(), err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		receivedMsg := <span class="type">string</span>(buf[:n])</span><br><span class="line">		fmt.Printf(<span class="string">&quot;收到来自 %s 的消息: %s\n&quot;</span>, conn.RemoteAddr(), receivedMsg)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 回复客户端</span></span><br><span class="line">		response := fmt.Sprintf(<span class="string">&quot;服务器收到: %s (收到于 %s)&quot;</span>, receivedMsg, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(response))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;回复客户端 %s 失败: %v\n&quot;</span>, conn.RemoteAddr(), err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;KCP 服务器启动，监听端口 %s\n&quot;</span>, PORT)</span><br><span class="line">	<span class="comment">// 使用 kcp.ListenWithOptions 监听 KCP 连接</span></span><br><span class="line">	<span class="comment">// conv: KCP会话ID，用于识别不同的KCP连接</span></span><br><span class="line">	<span class="comment">// dataShards, parityShards: 用于FEC (Forward Error Correction) 前向纠错，这里设为0表示不使用</span></span><br><span class="line">	lis, err := kcp.ListenWithOptions(PORT, <span class="literal">nil</span>, CONV_ID, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> lis.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		s, err := lis.AcceptKCP()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;接受 KCP 连接失败: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleClient(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second) <span class="comment">// 等待服务器启动</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;KCP 客户端启动，连接服务器 %s\n&quot;</span>, PORT)</span><br><span class="line">	<span class="comment">// 使用 kcp.DialWithOptions 连接 KCP 服务器</span></span><br><span class="line">	s, err := kcp.DialWithOptions(PORT, <span class="literal">nil</span>, CONV_ID, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> s.Close()</span><br><span class="line"></span><br><span class="line">	s.SetWindowSize(<span class="number">1024</span>, <span class="number">1024</span>)</span><br><span class="line">	s.SetNoDelay(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">	s.SetMtu(<span class="number">1350</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		msg := fmt.Sprintf(<span class="string">&quot;Hello KCP from client %d! (发送于 %s)&quot;</span>, i+<span class="number">1</span>, time.Now().Format(<span class="string">&quot;15:04:05.000&quot;</span>))</span><br><span class="line">		_, err := s.Write([]<span class="type">byte</span>(msg))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;发送消息失败: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;客户端发送: %s\n&quot;</span>, msg)</span><br><span class="line"></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">4096</span>)</span><br><span class="line">		n, err := s.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;读取服务器回复失败: %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;客户端收到回复: %s\n&quot;</span>, <span class="type">string</span>(buf[:n]))</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> server()</span><br><span class="line">	client()</span><br><span class="line">	time.Sleep(time.Hour) <span class="comment">// 让程序运行足够长时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此 Go 语言示例展示了如何使用 <code>xtaci/kcp-go</code> 库创建一个简单的 KCP 服务器和客户端。服务器监听 KCP 连接，接受客户端消息并回复；客户端连接服务器，发送消息并接收回复。其中包含了 <code>SetWindowSize</code>、<code>SetNoDelay</code>、<code>SetMtu</code> 等关键 KCP 参数的配置，演示了如何开启激进模式。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>KCP 协议通过在 UDP 基础上实现一套激进的可靠传输机制，成功在一个可靠数据传输的前提下，达到了比 TCP 更低的延迟和在网络条件不佳时更好的性能表现。它并非 TCP 的替代品，而是针对<strong>特定应用场景</strong>（如游戏、实时音视频）的<strong>高性能补充</strong>。对于延迟敏感型应用，KCP 提供了一个强大的工具，但它的使用需要开发者对网络环境和 KCP 参数有深刻理解，并进行细致的调优。在选择网络传输协议时，应根据实际业务需求权衡 KCP 的优缺点。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/9be87a9e79b5/">https://blog.tbf1211.xx.kg/9be87a9e79b5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/UDP/">UDP</a><a class="post-meta__tags" href="/tags/KCP/">KCP</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/a1d408b2ddbe/" title="Python多进程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python多进程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式概述模式构成：  生产者 (Producer)：负责生成数据，并将其放入共享的缓冲区（队列）中。 消费者 (Consumer)：负责从共享的缓冲区（队列）中取出数据进行处理。 缓冲区 (Buffer &#x2F; Queue)：一个共享的数据结构，通常是一个队列，用于存储生产者生产的数据和消费者消费的数据。它充当了生产者和消费者之间的桥梁。  解决的问题：  解耦：生产者和消费者可以独立运行，互不干扰，提高系统的灵活性。 并发：允许多个生产者和多个消费者同时存在，提高处理效率。 削峰填谷：当生产速度快于消费速度时，缓冲区可以存储多余的数据，防止数...</div></div></div></a><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a><a class="pagination-related" href="/65edca489ee4/" title="DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="info-item-2">DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS over TLS (DoT) 和 DNS over HTTPS (DoH) 是旨在增强 DNS (Domain Name System) 查询和响应隐私性 (Privacy) 与安全性 (Security) 的两种协议。它们通过对 DNS 流量进行加密，防止网络中间方（如 ISP、政府机构或恶意攻击者）窥探用户的域名解析请求或篡改 DNS 响应，从而解决了传统 DNS 协议固有的安全和隐私缺陷。  核心思想：将明文传输的 DNS 查询封装到加密的传输层安全 (TLS) 或超文本传输安全 (HTTPS) 连接中，以保护用户隐私、防止 DNS 劫持和对抗网络审查。   一、传统 DNS 的隐私与安全痛点传统的 DNS 协议通常通过 UDP (User Datagram Protocol) 或 TCP (Transmission Control Protocol) 的 53 号端口进行通信。这种通信方式存在以下固有的安全和隐私缺陷：  明文传输 (Plaintext Transmission)：DNS 查询和响应在网络上以明文形式传输。  隐私泄露：任何能够嗅探网络流量的中间...</div></div></div></a><a class="pagination-related" href="/a8d205bac226/" title="HTTP&#x2F;2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="info-item-2">HTTP&#x2F;2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a><a class="pagination-related" href="/abf64f03363d/" title="HTTP Upgrade 请求详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="info-item-2">HTTP Upgrade 请求详解</div></div><div class="info-2"><div class="info-item-1"> HTTP Upgrade 请求 是一种特殊的 HTTP&#x2F;1.1 机制，允许客户端和服务器在已经建立的 TCP 连接上，将当前协议从 HTTP&#x2F;1.1 切换到另一个不同的、更高级别的协议。最常见的应用场景是将 HTTP 连接升级到 WebSocket 协议，从而实现全双工、低延迟的持久连接。  核心思想：Upgrade 请求是 HTTP&#x2F;1.1 中用于协议协商的机制，允许在一个已有的 TCP 连接上，在客户端和服务器都同意的情况下，从 HTTP 切换到其他协议，避免了重新建立连接的开销，并开启更强大的通信模式。   一、为什么需要 HTTP Upgrade？HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 都是无状态的请求-响应协议。对于每个请求，客户端发送请求，服务器发送响应，然后连接可以关闭（非持久连接）或保持一段时间用于后续的 HTTP 请求（持久连接，Keep-Alive）。 这种请求-响应模式对于传统的 Web 页面浏览非常高效。然而，随着 Web 应用复杂度的增加，许多场景需要更高级的通信模式：  实时通信：聊天应用、在线游戏、...</div></div></div></a><a class="pagination-related" href="/378a51590e55/" title="HTTP&#x2F;1.1 协议深度详解：Web 通信的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="info-item-2">HTTP&#x2F;1.1 协议深度详解：Web 通信的基石</div></div><div class="info-2"><div class="info-item-1"> HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。  核心思想：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于请求-响应模型，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。   一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：  短连接 (Short Connection)：HTTP&#x2F;1.0 默认每个请求&#x2F;响应...</div></div></div></a><a class="pagination-related" href="/425bf08190fa/" title="TLS Encrypted Client Hello (ECH) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="info-item-2">TLS Encrypted Client Hello (ECH) 详解</div></div><div class="info-2"><div class="info-item-1"> TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。  核心思想：在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。   一、为什么需要 ECH？SNI 的隐私痛点在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：明文 SNI (Server Name Indication)。 1.1 SNI 的作用SNI 是 TLS 协议的一个扩展，用于解决虚拟主机 (Virtual Hosting) 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 example.com 和 another.c...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">518</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-KCP%EF%BC%9F"><span class="toc-text">一、为什么需要 KCP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81KCP-%E4%B8%8E-TCP-%E7%9A%84%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">二、KCP 与 TCP 的关键差异与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E4%BC%98%E5%8C%96"><span class="toc-text">2.1 队头阻塞优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-ACK-%E4%B8%8E%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-text">2.2 ACK 与重传机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">2.3 拥塞控制与流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96"><span class="toc-text">2.4 其他优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81KCP-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E-API"><span class="toc-text">三、KCP 的核心数据结构与 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aikcpcb"><span class="toc-text">3.1 核心数据结构：ikcpcb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A0%B8%E5%BF%83-API-Go-%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B%EF%BC%8C%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%B1%BB%E4%BC%BC"><span class="toc-text">3.2 核心 API (Go 语言示例，其他语言类似)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%85%8D%E7%BD%AE%E8%B0%83%E4%BC%98%E4%B8%8E%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9"><span class="toc-text">四、配置调优与模式选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-nodelay-mode"><span class="toc-text">4.1 nodelay mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="toc-text">4.2 窗口大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-MTU-Maximum-Transmission-Unit"><span class="toc-text">4.3 MTU (Maximum Transmission Unit)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81KCP-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">五、KCP 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BC%98%E7%82%B9"><span class="toc-text">5.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">5.2 缺点**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81KCP-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%A1%B9%E7%9B%AE"><span class="toc-text">六、KCP 的使用和项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-02.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>