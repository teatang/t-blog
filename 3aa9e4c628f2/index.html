<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>在 Vercel 开发 Next.js 应用详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vercel 是 Next.js 的创建者，也是一个领先的云平台，专为部署和扩展 Web 应用程序而设计，特别是针对 Next.js 应用。它提供了一站式的开发、预览和部署工作流，集成了 Git 仓库，并支持无服务器功能、全球 CDN、自动 SSL 等，极大地简化了 Next.js 应用的部署和管理。  核心思想：在 Vercel 上开发 Next.js 应用，核心在于利用 Vercel 与 N">
<meta property="og:type" content="article">
<meta property="og:title" content="在 Vercel 开发 Next.js 应用详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/3aa9e4c628f2/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Vercel 是 Next.js 的创建者，也是一个领先的云平台，专为部署和扩展 Web 应用程序而设计，特别是针对 Next.js 应用。它提供了一站式的开发、预览和部署工作流，集成了 Git 仓库，并支持无服务器功能、全球 CDN、自动 SSL 等，极大地简化了 Next.js 应用的部署和管理。  核心思想：在 Vercel 上开发 Next.js 应用，核心在于利用 Vercel 与 N">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg">
<meta property="article:published_time" content="2024-03-11T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-22T08:07:54.388Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="Serverless">
<meta property="article:tag" content="云服务">
<meta property="article:tag" content="Vercel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "在 Vercel 开发 Next.js 应用详解",
  "url": "https://blog.tbf1211.xx.kg/3aa9e4c628f2/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg",
  "datePublished": "2024-03-11T22:24:00.000Z",
  "dateModified": "2025-12-22T08:07:54.388Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/3aa9e4c628f2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '在 Vercel 开发 Next.js 应用详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">424</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">219</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">在 Vercel 开发 Next.js 应用详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">在 Vercel 开发 Next.js 应用详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-03-11T22:24:00.000Z" title="发表于 2024-03-12 06:24:00">2024-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/3aa9e4c628f2/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Vercel</strong> 是 Next.js 的创建者，也是一个领先的云平台，专为部署和扩展 Web 应用程序而设计，特别是针对 Next.js 应用。它提供了一站式的开发、预览和部署工作流，集成了 Git 仓库，并支持无服务器功能、全球 CDN、自动 SSL 等，极大地简化了 Next.js 应用的部署和管理。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>在 Vercel 上开发 Next.js 应用，核心在于利用 Vercel 与 Next.js 的深度集成，实现从代码提交到全球部署的自动化工作流。这包括使用 Next.js 的特性（如数据获取、API 路由），配置 Vercel 项目，利用其预览部署、环境变量、无服务器函数等功能，实现高效且可扩展的开发和部署。</strong></p>
</div>
<hr>
<h2 id="一、Next-js-基础"><a href="#一、Next-js-基础" class="headerlink" title="一、Next.js 基础"></a>一、Next.js 基础</h2><p>在深入 Vercel 之前，确保你对 Next.js 的核心概念有所了解：</p>
<ul>
<li><strong>文件系统路由 (File-system Routing)</strong>：根据 <code>pages</code> (或 <code>app</code> 目录) 目录结构自动生成路由。</li>
<li><strong>数据获取 (Data Fetching)</strong>：<ul>
<li><code>getServerSideProps</code> (SSR): 服务端渲染，每次请求生成页面。</li>
<li><code>getStaticProps</code> (SSG): 静态站点生成，构建时生成页面，支持 <code>revalidate</code> 增量静态再生 (ISR)。</li>
<li><code>getStaticPaths</code> (SSG): 配合 <code>getStaticProps</code> 生成动态路由的静态路径。</li>
<li><strong>App Router</strong>: <code>async/await</code> 组件，<code>fetch</code> 请求默认为 SSR 或 SSG。</li>
</ul>
</li>
<li><strong>API 路由 (API Routes)</strong>：在 <code>pages/api</code> (或 <code>app/api</code>) 中创建后端无服务器函数。</li>
<li><strong>CSS Modules &#x2F; Styled-JSX &#x2F; Tailwind CSS</strong>：内置的样式支持。</li>
<li><strong>图片优化 (Image Optimization)</strong>：<code>next/image</code> 组件。</li>
</ul>
<h2 id="二、Vercel-项目设置"><a href="#二、Vercel-项目设置" class="headerlink" title="二、Vercel 项目设置"></a>二、Vercel 项目设置</h2><h3 id="2-1-创建-Next-js-应用"><a href="#2-1-创建-Next-js-应用" class="headerlink" title="2.1 创建 Next.js 应用"></a>2.1 创建 Next.js 应用</h3><p>首先，使用 Create Next App 创建一个新的 Next.js 项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest my-next-app --typescript --eslint --app <span class="comment"># 或者 --pages</span></span><br><span class="line"><span class="built_in">cd</span> my-next-app</span><br><span class="line">npm run dev <span class="comment"># 运行开发服务器</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-连接-Git-仓库"><a href="#2-2-连接-Git-仓库" class="headerlink" title="2.2 连接 Git 仓库"></a>2.2 连接 Git 仓库</h3><p>将你的 Next.js 项目推送到一个 Git 仓库（GitHub, GitLab, Bitbucket）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/your-username/my-next-app.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h3 id="2-3-在-Vercel-上创建项目"><a href="#2-3-在-Vercel-上创建项目" class="headerlink" title="2.3 在 Vercel 上创建项目"></a>2.3 在 Vercel 上创建项目</h3><ol>
<li>访问 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://vercel.com/">Vercel.com</a> 并注册&#x2F;登录。</li>
<li>点击 “Add New…” -&gt; “Project”。</li>
<li>选择你刚才推送的 Git 仓库，点击 “Import”。</li>
<li>Vercel 会自动检测这是一个 Next.js 项目，并预设构建和输出配置。<ul>
<li><strong>Root Directory (根目录)</strong>：如果你的 Next.js 应用不在仓库根目录，这里需要指定。</li>
<li><strong>Framework Preset (框架预设)</strong>：Vercel 会自动选择 <code>Next.js</code>。</li>
<li><strong>Build Command (构建命令)</strong>：<code>next build</code> (默认)。</li>
<li><strong>Output Directory (输出目录)</strong>：<code>public</code> (默认)。</li>
</ul>
</li>
<li>点击 “Deploy”。Vercel 会自动拉取代码，执行构建，并部署你的应用。</li>
</ol>
<h3 id="2-4-自动部署与预览分支"><a href="#2-4-自动部署与预览分支" class="headerlink" title="2.4 自动部署与预览分支"></a>2.4 自动部署与预览分支</h3><p>一旦项目设置完成，Vercel 会自动：</p>
<ul>
<li><strong>生产部署 (Production Deployment)</strong>：当你向主分支 (通常是 <code>main</code> 或 <code>master</code>) 提交代码时，Vercel 会自动构建并部署到生产环境。</li>
<li><strong>预览部署 (Preview Deployment)</strong>：当你创建新的分支并推送代码，或者创建 Pull Request (PR) 时，Vercel 会为每个分支或 PR 自动创建一个独立的预览部署。这允许你在合并到主分支之前测试新功能。</li>
</ul>
<h2 id="三、Vercel-特性在-Next-js-中的应用"><a href="#三、Vercel-特性在-Next-js-中的应用" class="headerlink" title="三、Vercel 特性在 Next.js 中的应用"></a>三、Vercel 特性在 Next.js 中的应用</h2><p>Vercel 与 Next.js 的深度集成，意味着 Next.js 的许多特性在 Vercel 上都能得到最佳实践。</p>
<h3 id="3-1-无服务器函数-Serverless-Functions"><a href="#3-1-无服务器函数-Serverless-Functions" class="headerlink" title="3.1 无服务器函数 (Serverless Functions)"></a>3.1 无服务器函数 (Serverless Functions)</h3><p>Next.js 的 <strong>API 路由</strong> 在 Vercel 上自动部署为 <strong>无服务器函数 (Serverless Functions)</strong>。</p>
<ul>
<li><strong>工作方式</strong>：每个 <code>pages/api/*.ts</code> (或 <code>app/api/*.ts</code>) 文件都会被编译成一个独立的 Serverless 函数。</li>
<li><strong>优势</strong>：按需付费、自动扩缩容、无需管理服务器。</li>
<li><strong>最佳实践</strong>：<ul>
<li>保持函数轻量：每个函数只处理一个或少数相关任务。</li>
<li>无状态：确保函数是无状态的，方便扩缩容。</li>
<li>使用环境变量：敏感信息通过 Vercel 的环境变量管理。</li>
</ul>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/api/hello.ts (Pages Router)</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">NextApiRequest</span>, <span class="title class_">NextApiResponse</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;next&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"><span class="attr">req</span>: <span class="title class_">NextApiRequest</span>, <span class="attr">res</span>: <span class="title class_">NextApiResponse</span></span>) &#123;</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/api/hello/route.ts (App Router)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">GET</span>(<span class="params"><span class="attr">request</span>: <span class="title class_">Request</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&#x27;Hello, Next.js!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-环境变量-Environment-Variables"><a href="#3-2-环境变量-Environment-Variables" class="headerlink" title="3.2 环境变量 (Environment Variables)"></a>3.2 环境变量 (Environment Variables)</h3><p>Vercel 提供了一个安全的 UI 界面来管理环境变量，这些变量可以在构建时或运行时注入到你的 Next.js 应用中。</p>
<ol>
<li><strong>在 Vercel 后台设置</strong>：进入你的项目设置 -&gt; “Environment Variables”。</li>
<li><strong>类型</strong>：<ul>
<li><strong>Build Time</strong>：在构建应用时可用的变量（例如 <code>NEXT_PUBLIC_ANALYTICS_ID</code>）。</li>
<li><strong>Runtime</strong>：在 Serverless 函数运行时可用的变量（例如数据库连接字符串）。</li>
</ul>
</li>
<li><strong>Scoped (作用域)</strong>：可以为不同的环境（生产、预览、开发）设置不同的变量值。</li>
</ol>
<p><strong>在 Next.js 代码中使用：</strong></p>
<ul>
<li><strong>客户端&#x2F;公共环境变量</strong>：必须以 <code>NEXT_PUBLIC_</code> 开头。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在客户端和服务器端都可用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">NEXT_PUBLIC_ANALYTICS_ID</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>服务器端环境变量</strong>：不以 <code>NEXT_PUBLIC_</code> 开头，只在服务器端代码（<code>getServerSideProps</code>, API 路由等）中可用。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只在服务器端可用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">DATABASE_URL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-数据获取与渲染策略"><a href="#3-3-数据获取与渲染策略" class="headerlink" title="3.3 数据获取与渲染策略"></a>3.3 数据获取与渲染策略</h3><p>Vercel 对 Next.js 的各种数据获取方法提供了原生支持：</p>
<ul>
<li><strong>SSG (<code>getStaticProps</code>, <code>getStaticPaths</code>)</strong>：<ul>
<li>在构建时生成 HTML，文件存储在 Vercel 的全球 CDN 上，访问速度极快。</li>
<li>支持 <strong>Incremental Static Regeneration (ISR)</strong>：通过 <code>revalidate</code> 选项，可以在部署后定期重新生成页面，实现静态页面的动态更新，而无需重新部署整个应用。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ... 获取数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123; data &#125;,</span><br><span class="line">    <span class="attr">revalidate</span>: <span class="number">60</span>, <span class="comment">// 每 60 秒重新验证一次数据</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>SSR (<code>getServerSideProps</code>)</strong>：<ul>
<li>每次请求都在 Vercel 的 Serverless Functions 上执行，生成 HTML。</li>
<li>适用于需要实时数据的页面。</li>
</ul>
</li>
<li><strong>App Router (<code>fetch</code> 缓存机制)</strong>：<ul>
<li>App Router 引入了新的数据获取和缓存机制。</li>
<li><code>fetch</code> 请求默认可缓存，Vercel 会智能地处理这些缓存。</li>
<li>默认情况下，<code>fetch</code> 是 SSR 行为，但也可以通过 <code>revalidate</code> 选项实现类似 ISR 的行为。</li>
</ul>
</li>
</ul>
<h3 id="3-4-域名与-SSL"><a href="#3-4-域名与-SSL" class="headerlink" title="3.4 域名与 SSL"></a>3.4 域名与 SSL</h3><p>Vercel 自动化了域名配置和 SSL 证书管理：</p>
<ol>
<li><strong>Custom Domains (自定义域名)</strong>：在 Vercel 项目设置中，可以轻松添加自定义域名。</li>
<li><strong>Automatic SSL</strong>：Vercel 自动为所有域名（包括预览域名）颁发和续订 Let’s Encrypt SSL 证书，无需手动操作。</li>
<li><strong>Global CDN</strong>：你的 Next.js 应用（尤其是静态资产和 SSG 页面）会自动部署到 Vercel 的全球 CDN 上，提供极低的延迟。</li>
</ol>
<h3 id="3-5-边缘缓存-Edge-Caching"><a href="#3-5-边缘缓存-Edge-Caching" class="headerlink" title="3.5 边缘缓存 (Edge Caching)"></a>3.5 边缘缓存 (Edge Caching)</h3><p>Vercel 自动缓存 Next.js 应用程序的静态内容和 SSG 页面，并将其分发到全球边缘网络。</p>
<ul>
<li>对于 <code>getStaticProps</code> 生成的页面，Vercel 会在构建后直接缓存。</li>
<li>对于带有 <code>revalidate</code> 的 ISR 页面，Vercel 也会进行边缘缓存，并在过期后触发重新生成。</li>
<li>对于 API 路由或 <code>getServerSideProps</code>，你可以通过设置响应头（如 <code>Cache-Control</code>）来控制 CDN 缓存行为。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/api/cached-data.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"><span class="attr">req</span>: <span class="title class_">NextApiRequest</span>, <span class="attr">res</span>: <span class="title class_">NextApiResponse</span></span>) &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;s-maxage=60, stale-while-revalidate&#x27;</span>); <span class="comment">// 缓存 60 秒，并在后台重新验证</span></span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123; <span class="attr">timestamp</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>() &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-Monorepo-支持"><a href="#3-6-Monorepo-支持" class="headerlink" title="3.6 Monorepo 支持"></a>3.6 Monorepo 支持</h3><p>如果你的 Next.js 应用是 Monorepo 中的一部分（例如使用 Nx 或 Turborepo），Vercel 也能很好地支持：</p>
<ul>
<li>在 Vercel 项目设置中，指定你的 Next.js 应用的 <code>Root Directory</code>。</li>
<li>Vercel 会自动检测 Monorepo，并只构建相关的项目。</li>
</ul>
<h2 id="四、开发工作流与调试"><a href="#四、开发工作流与调试" class="headerlink" title="四、开发工作流与调试"></a>四、开发工作流与调试</h2><h3 id="4-1-本地开发"><a href="#4-1-本地开发" class="headerlink" title="4.1 本地开发"></a>4.1 本地开发</h3><ul>
<li>使用 <code>npm run dev</code> 在本地运行 Next.js 应用。</li>
<li>使用 <code>wrangler login</code> 和 <code>wrangler dev</code> (针对 Workers) 等 CLI 工具辅助开发。</li>
</ul>
<h3 id="4-2-预览部署-Preview-Deployments"><a href="#4-2-预览部署-Preview-Deployments" class="headerlink" title="4.2 预览部署 (Preview Deployments)"></a>4.2 预览部署 (Preview Deployments)</h3><ul>
<li><strong>快速反馈</strong>：每个 Git 分支和 PR 都有独立的预览 URL，团队成员和客户可以即时查看和测试新功能。</li>
<li><strong>环境隔离</strong>：预览部署有独立的 URL 和可能不同的环境变量（如果你配置了的话），确保与生产环境隔离。</li>
<li><strong>Git 集成</strong>：Vercel 会在 PR 中自动添加部署状态和链接。</li>
</ul>
<h3 id="4-3-生产部署-Production-Deployments"><a href="#4-3-生产部署-Production-Deployments" class="headerlink" title="4.3 生产部署 (Production Deployments)"></a>4.3 生产部署 (Production Deployments)</h3><ul>
<li>一旦 PR 合并到主分支，Vercel 会自动触发生产部署。</li>
<li>Vercel 提供原子部署，确保网站始终在线，没有停机时间。</li>
<li>支持部署回滚：如果生产部署出现问题，可以一键回滚到之前的版本。</li>
</ul>
<h3 id="4-4-调试与监控"><a href="#4-4-调试与监控" class="headerlink" title="4.4 调试与监控"></a>4.4 调试与监控</h3><ul>
<li><strong>Vercel Dashboard</strong>：提供部署日志、函数执行日志 (Serverless Functions Logs)、带宽使用情况等。</li>
<li><strong>Build Logs</strong>：在每次构建失败时，可以查看详细的构建日志来诊断问题。</li>
<li><strong>Function Logs</strong>：Serverless 函数的 <code>console.log</code> 输出会出现在这里。</li>
<li><strong>Vercel Analytics</strong>：提供开箱即用的 Web 性能指标和访客分析。</li>
</ul>
<h2 id="五、总结与最佳实践"><a href="#五、总结与最佳实践" class="headerlink" title="五、总结与最佳实践"></a>五、总结与最佳实践</h2><p>在 Vercel 上开发 Next.js 应用是一个高效且现代的工作流程。利用 Vercel 与 Next.js 的深度集成，你可以：</p>
<ol>
<li><strong>自动化部署</strong>：通过 Git 提交实现自动化的 CI&#x2F;CD。</li>
<li><strong>极速性能</strong>：利用全球 CDN、边缘缓存和 Serverless Functions 带来低延迟和高响应速度。</li>
<li><strong>简化运维</strong>：无需管理服务器、SSL 证书或 CDN 配置。</li>
<li><strong>提升协作</strong>：通过预览部署，团队可以更快地迭代和审查新功能。</li>
</ol>
<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>充分利用 Next.js 特性</strong>：根据数据更新频率和用户体验需求，合理选择 SSG、SSR 或 ISR。</li>
<li><strong>环境变量隔离</strong>：为不同的环境（生产、预览、开发）配置不同的环境变量，确保安全和灵活性。</li>
<li><strong>优化 Serverless Functions</strong>：保持 API 路由函数精简，避免长时间运行的任务。</li>
<li><strong>监控与日志</strong>：定期检查 Vercel Dashboard 上的日志和性能指标，及时发现并解决问题。</li>
<li><strong>代码审查</strong>：结合 Vercel 的预览部署流程，在合并到主分支前，充分进行代码审查和测试。</li>
</ul>
<p>通过这些实践，你可以充分发挥 Vercel 和 Next.js 的强大能力，构建和部署高性能、可扩展的 Web 应用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/3aa9e4c628f2/">https://blog.tbf1211.xx.kg/3aa9e4c628f2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/Serverless/">Serverless</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a><a class="post-meta__tags" href="/tags/Vercel/">Vercel</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/487df70cf615/" title="Vercel Serverless Functions 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Vercel Serverless Functions 深度详解</div></div><div class="info-2"><div class="info-item-1"> Vercel Serverless Functions 是 Vercel 平台的核心服务之一，它允许开发者部署并运行后端代码，而无需管理任何服务器基础设施。这些函数是轻量级的、按需执行的计算单元，能够根据流量自动扩缩容，并天然集成到 Vercel 的全球 CDN 和部署工作流中。Vercel Functions 不仅为 Next.js 提供了强大的 API 路由支持，还允许开发者使用多种编程语言（如 Node.js, Python, Go, Ruby 等）构建独立的后端服务。  核心思想：Vercel Serverless Functions 提供了一种高效、自动扩缩容的无状态计算环境，使开发者能够将后端逻辑作为独立的函数部署到 Vercel 的全球边缘网络。其核心优势在于与前端框架的无缝集成、多语言支持、自动管理基础设施，并通过 Git 驱动的部署流程，极大地简化了全栈应用的开发和运维。   一、Vercel Serverless Functions 概览1.1 核心概念 无服务器 (Serverless)：你无需预置或管理任何服务器。Vercel 负责所有基础设施的配置、维...</div></div></div></a><a class="pagination-related" href="/c645d233e96b/" title="Vercel.json详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Vercel.json详解</div></div><div class="info-2"><div class="info-item-1"> vercel.json 是 Vercel 平台的核心配置文件，它允许开发者对项目的部署行为、路由规则、Serverless Functions 配置、环境变量、构建过程等进行细粒度的控制。通过 vercel.json，你可以超越 Vercel 的默认零配置行为，根据项目的特定需求定制化部署策略。  核心思想：vercel.json 是一个 JSON 文件，用于声明 Vercel 项目的各种配置，包括路由重写、重定向、HTTP Headers、Serverless Functions 设置、构建步骤和环境变量等，从而实现高级部署功能和优化。   一、vercel.json 的基本结构与作用vercel.json 文件通常位于项目的根目录下。Vercel 在每次部署时会读取这个文件，并根据其中的配置来处理构建、路由和请求。 一个典型的 vercel.json 结构如下： 123456789101112131415&#123;  &quot;version&quot;: 2,  &quot;name&quot;: &quot;my-vercel-project&quot;,  &qu...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cc0334bd16dd/" title="Vercel介绍"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">Vercel介绍</div></div><div class="info-2"><div class="info-item-1"> Vercel 是一家领先的前端云 (Frontend Cloud) 平台，专注于为前端开发者提供极速的部署、自动化的CI&#x2F;CD、全球化的内容分发 (CDN) 和 Serverless 功能。它以其与 Next.js 框架的深度集成而闻名，旨在帮助开发者以最快速度将 Web 项目从构思变为全球可用的产品，同时提供卓越的性能和开发者体验。  核心思想：Vercel 是一个将前端部署、构建、Hosting 和 Serverless 后端能力融为一体的平台，特别优化了 Next.js 等现代化框架的开发和部署流程，让开发者能够专注于代码，无需管理基础设施。   一、为什么选择 Vercel？在现代 Web 开发中，前端项目的部署和运维变得越来越复杂：  构建优化：代码打包、压缩、Tree Shaking。 性能优化：CDN 分发、图片优化、SEO 优化。 开发体验：持续集成&#x2F;持续部署 (CI&#x2F;CD)、预览部署、分支管理。 后端需求：API 路由、Server-Side Rendering (SSR)、数据获取等，需要 Serverless 或 Node.j...</div></div></div></a><a class="pagination-related" href="/487df70cf615/" title="Vercel Serverless Functions 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="info-item-2">Vercel Serverless Functions 深度详解</div></div><div class="info-2"><div class="info-item-1"> Vercel Serverless Functions 是 Vercel 平台的核心服务之一，它允许开发者部署并运行后端代码，而无需管理任何服务器基础设施。这些函数是轻量级的、按需执行的计算单元，能够根据流量自动扩缩容，并天然集成到 Vercel 的全球 CDN 和部署工作流中。Vercel Functions 不仅为 Next.js 提供了强大的 API 路由支持，还允许开发者使用多种编程语言（如 Node.js, Python, Go, Ruby 等）构建独立的后端服务。  核心思想：Vercel Serverless Functions 提供了一种高效、自动扩缩容的无状态计算环境，使开发者能够将后端逻辑作为独立的函数部署到 Vercel 的全球边缘网络。其核心优势在于与前端框架的无缝集成、多语言支持、自动管理基础设施，并通过 Git 驱动的部署流程，极大地简化了全栈应用的开发和运维。   一、Vercel Serverless Functions 概览1.1 核心概念 无服务器 (Serverless)：你无需预置或管理任何服务器。Vercel 负责所有基础设施的配置、维...</div></div></div></a><a class="pagination-related" href="/c645d233e96b/" title="Vercel.json详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-11</div><div class="info-item-2">Vercel.json详解</div></div><div class="info-2"><div class="info-item-1"> vercel.json 是 Vercel 平台的核心配置文件，它允许开发者对项目的部署行为、路由规则、Serverless Functions 配置、环境变量、构建过程等进行细粒度的控制。通过 vercel.json，你可以超越 Vercel 的默认零配置行为，根据项目的特定需求定制化部署策略。  核心思想：vercel.json 是一个 JSON 文件，用于声明 Vercel 项目的各种配置，包括路由重写、重定向、HTTP Headers、Serverless Functions 设置、构建步骤和环境变量等，从而实现高级部署功能和优化。   一、vercel.json 的基本结构与作用vercel.json 文件通常位于项目的根目录下。Vercel 在每次部署时会读取这个文件，并根据其中的配置来处理构建、路由和请求。 一个典型的 vercel.json 结构如下： 123456789101112131415&#123;  &quot;version&quot;: 2,  &quot;name&quot;: &quot;my-vercel-project&quot;,  &qu...</div></div></div></a><a class="pagination-related" href="/1165e3e15519/" title="边缘计算 (Edge Computing) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-05</div><div class="info-item-2">边缘计算 (Edge Computing) 详解</div></div><div class="info-2"><div class="info-item-1"> 边缘计算 (Edge Computing) 是一种分布式计算范式，它将计算和数据存储能力从集中式的云数据中心下沉到网络的边缘，即数据源或数据源附近。其核心思想是在数据产生的地方进行数据处理、分析和存储，而不是将所有数据都传输到远程的云端进行处理。这种模式旨在解决云计算在延迟、带宽、隐私和可靠性方面面临的挑战，特别是在物联网 (IoT)、5G 和人工智能 (AI) 等新兴技术驱动下，变得越来越重要。  核心思想：将计算能力推向数据源头，在网络边缘就近处理数据，以降低延迟、节省带宽、增强隐私和提高可靠性。   一、为什么需要边缘计算？传统的云计算模型将数据发送到远程数据中心进行处理。随着物联网设备的爆炸式增长、5G 网络的高速发展以及AI应用对实时性的高要求，这种中心化的模式暴露出以下问题：  高延迟 (High Latency)：数据从边缘设备传输到云端，再从云端返回，需要较长时间。对于自动驾驶、工业自动化、远程医疗等实时性要求极高的应用，几毫秒的延迟都可能造成严重后果。 带宽限制与成本 (Bandwidth Constraints &amp; Cost)：物联网设备产生海量数据...</div></div></div></a><a class="pagination-related" href="/6842deb76626/" title="AWS Lambda与Serverless详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="info-item-2">AWS Lambda与Serverless详解</div></div><div class="info-2"><div class="info-item-1"> AWS Lambda 是亚马逊网络服务 (Amazon Web Services, AWS) 提供的核心 Serverless 计算服务，也是函数即服务 (Function-as-a-Service, FaaS) 的开创者和领导者。它允许开发者运行代码，而无需配置或管理服务器。开发者只需上传代码，Lambda 会自动处理运行代码所需的一切，包括容量预置、扩展、打补丁和维护。  核心思想：AWS Lambda 是 AWS Serverless 生态的核心，它将代码作为“函数”运行在无服务器环境中，由各种 AWS 事件触发，按需执行，自动伸缩，并按实际使用量计费。   一、AWS Lambda 概览AWS Lambda 于 2014 年推出，彻底改变了云计算的开发和部署模式。它让开发者能够将后端逻辑解耦为一系列独立、短生命周期的函数，从而极大地简化了运维。 1.1 Lambda 的核心概念 函数 (Function)：这是 Lambda 中的基本部署单元，包含你的代码和相关配置（如运行时、内存、超时时间、环境变量）。 事件 (Event)：触发 Lambda 函数执行的任何操作。事...</div></div></div></a><a class="pagination-related" href="/f5c29582f368/" title="Serverless 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="info-item-2">Serverless 详解</div></div><div class="info-2"><div class="info-item-1"> Serverless (无服务器) 是一种云计算的执行模型，它允许开发者构建和运行应用程序而无需管理服务器。在这种模型下，云服务提供商负责服务器的调配、维护和扩展，开发者只需关注自己的代码逻辑。Serverless 并不是指“没有服务器”，而是指“开发者不需要关心服务器”。它通常包含两种核心服务模式：函数即服务 (Function-as-a-Service, FaaS) 和 后端即服务 (Backend-as-a-Service, BaaS)。  核心思想：将基础设施管理完全交给云服务商，开发者只需编写代码并部署，按实际使用量付费，实现极致的弹性伸缩和降低运维成本。   一、为什么需要 Serverless？传统的应用部署模型（物理机、虚拟机、容器）都需要开发者或运维团队投入大量精力进行服务器管理：  资源调配：预估并配置合适的 CPU、内存、存储。 操作系统管理：安装、打补丁、更新。 运行时环境：安装语言运行时、库、依赖。 扩展性：根据流量变化手动或自动伸缩服务器集群。 高可用性：设置负载均衡、故障转移机制。 监控与日志：部署监控 agent，收集日志。  这些“非功能性需求...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">424</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">219</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Next-js-%E5%9F%BA%E7%A1%80"><span class="toc-text">一、Next.js 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Vercel-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">二、Vercel 项目设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA-Next-js-%E5%BA%94%E7%94%A8"><span class="toc-text">2.1 创建 Next.js 应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%9E%E6%8E%A5-Git-%E4%BB%93%E5%BA%93"><span class="toc-text">2.2 连接 Git 仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%9C%A8-Vercel-%E4%B8%8A%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">2.3 在 Vercel 上创建项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%A2%84%E8%A7%88%E5%88%86%E6%94%AF"><span class="toc-text">2.4 自动部署与预览分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Vercel-%E7%89%B9%E6%80%A7%E5%9C%A8-Next-js-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">三、Vercel 特性在 Next.js 中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BD%E6%95%B0-Serverless-Functions"><span class="toc-text">3.1 无服务器函数 (Serverless Functions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-Environment-Variables"><span class="toc-text">3.2 环境变量 (Environment Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E4%B8%8E%E6%B8%B2%E6%9F%93%E7%AD%96%E7%95%A5"><span class="toc-text">3.3 数据获取与渲染策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%9F%9F%E5%90%8D%E4%B8%8E-SSL"><span class="toc-text">3.4 域名与 SSL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%BE%B9%E7%BC%98%E7%BC%93%E5%AD%98-Edge-Caching"><span class="toc-text">3.5 边缘缓存 (Edge Caching)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Monorepo-%E6%94%AF%E6%8C%81"><span class="toc-text">3.6 Monorepo 支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-text">四、开发工作流与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91"><span class="toc-text">4.1 本地开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%A2%84%E8%A7%88%E9%83%A8%E7%BD%B2-Preview-Deployments"><span class="toc-text">4.2 预览部署 (Preview Deployments)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2-Production-Deployments"><span class="toc-text">4.3 生产部署 (Production Deployments)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%B0%83%E8%AF%95%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-text">4.4 调试与监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">五、总结与最佳实践</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能体 (Agent) 详解：深入 LangChain 开发实践"/></a><div class="content"><a class="title" href="/bfcc84247c6a/" title="智能体 (Agent) 详解：深入 LangChain 开发实践">智能体 (Agent) 详解：深入 LangChain 开发实践</a><time datetime="2025-12-10T22:24:00.000Z" title="发表于 2025-12-11 06:24:00">2025-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-18.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}&path=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews) {
            pagePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors) {
            siteUV.textContent = typeof data.visitors.value !== 'undefined' ? data.visitors.value : data.visitors
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews) {
            sitePV.textContent = typeof data.pageviews.value !== 'undefined' ? data.pageviews.value : data.pageviews
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>