<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 各类数据结构指令详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis 是一个开源（BSD 许可）的内存数据结构存储，可用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。理解并熟练使用这些数据结构及其相关指令，是高效利用 Redis 的关键。  Redis 的强大之处在于其在内存中操作这些丰富的数据结构，使得读写速度极快。掌握">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 各类数据结构指令详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2dc66126bcaa/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Redis 是一个开源（BSD 许可）的内存数据结构存储，可用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。理解并熟练使用这些数据结构及其相关指令，是高效利用 Redis 的关键。  Redis 的强大之处在于其在内存中操作这些丰富的数据结构，使得读写速度极快。掌握">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg">
<meta property="article:published_time" content="2023-05-07T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-22T03:39:24.796Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 各类数据结构指令详解",
  "url": "https://blog.tbf1211.xx.kg/2dc66126bcaa/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg",
  "datePublished": "2023-05-07T22:24:00.000Z",
  "dateModified": "2025-11-22T03:39:24.796Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2dc66126bcaa/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 各类数据结构指令详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">306</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-28.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis 各类数据结构指令详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis 各类数据结构指令详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-05-07T22:24:00.000Z" title="发表于 2023-05-08 06:24:00">2023-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2dc66126bcaa/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>Redis 是一个开源（BSD 许可）的内存数据结构存储，可用作数据库、缓存和消息代理。它支持多种类型的数据结构，如字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。理解并熟练使用这些数据结构及其相关指令，是高效利用 Redis 的关键。</p>
</blockquote>
<div class="note info flat"><p>Redis 的强大之处在于其在内存中操作这些丰富的数据结构，使得读写速度极快。掌握每个数据结构的使用场景和对应指令，是进行高性能应用开发的基础。</p>
</div>
<hr>
<h2 id="一、通用键指令-Generic-Commands"><a href="#一、通用键指令-Generic-Commands" class="headerlink" title="一、通用键指令 (Generic Commands)"></a>一、通用键指令 (Generic Commands)</h2><p>这些指令适用于所有数据类型的键。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>DEL key [key ...]</code></td>
<td align="left">删除一个或多个键。</td>
<td align="left"><code>DEL mykey mylist</code></td>
</tr>
<tr>
<td align="left"><code>EXISTS key [key ...]</code></td>
<td align="left">检查给定键是否存在。返回存在的键的数量。</td>
<td align="left"><code>EXISTS mykey</code></td>
</tr>
<tr>
<td align="left"><code>EXPIRE key seconds</code></td>
<td align="left">设置键的过期时间（秒）。</td>
<td align="left"><code>EXPIRE mykey 60</code> (60秒后过期)</td>
</tr>
<tr>
<td align="left"><code>TTL key</code></td>
<td align="left">获取键的剩余过期时间（秒）。<code>-1</code> 表示永久，<code>-2</code> 表示键不存在或已过期。</td>
<td align="left"><code>TTL mykey</code></td>
</tr>
<tr>
<td align="left"><code>PERSIST key</code></td>
<td align="left">移除键的过期时间，使其变为永久。</td>
<td align="left"><code>PERSIST mykey</code></td>
</tr>
<tr>
<td align="left"><code>TYPE key</code></td>
<td align="left">返回键存储值的类型。</td>
<td align="left"><code>TYPE mykey</code> (可能返回 <code>string</code>, <code>list</code> 等)</td>
</tr>
<tr>
<td align="left"><code>KEYS pattern</code></td>
<td align="left">查找所有符合给定模式的键。<strong>应避免在生产环境中使用，会阻塞 Redis。</strong></td>
<td align="left"><code>KEYS user:*</code></td>
</tr>
<tr>
<td align="left"><code>RENAME key newkey</code></td>
<td align="left">重命名键。</td>
<td align="left"><code>RENAME oldkey newkey</code></td>
</tr>
<tr>
<td align="left"><code>SCAN cursor [MATCH pattern] [COUNT count]</code></td>
<td align="left">用于迭代数据库中的键，避免 <code>KEYS</code> 的问题。</td>
<td align="left"><code>SCAN 0 MATCH user:* COUNT 100</code></td>
</tr>
</tbody></table>
<h2 id="二、字符串-Strings"><a href="#二、字符串-Strings" class="headerlink" title="二、字符串 (Strings)"></a>二、字符串 (Strings)</h2><p>Redis 最基本的数据类型，可以存储文本、整数、浮点数，甚至是二进制数据。最大能存储 512MB。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code></td>
<td align="left">设置键值对。<code>EX</code>:过期秒数, <code>PX</code>:过期毫秒数, <code>NX</code>:键不存在才设置, <code>XX</code>:键存在才设置。</td>
<td align="left"><code>SET mykey &quot;hello&quot;</code><br><code>SET mykey &quot;world&quot; EX 10</code><br><code>SET mykey &quot;new&quot; NX</code></td>
</tr>
<tr>
<td align="left"><code>GET key</code></td>
<td align="left">获取键的值。</td>
<td align="left"><code>GET mykey</code></td>
</tr>
<tr>
<td align="left"><code>MSET key value [key value ...]</code></td>
<td align="left">同时设置多个键值对。</td>
<td align="left"><code>MSET key1 v1 key2 v2</code></td>
</tr>
<tr>
<td align="left"><code>MGET key [key ...]</code></td>
<td align="left">同时获取多个键的值。</td>
<td align="left"><code>MGET key1 key2</code></td>
</tr>
<tr>
<td align="left"><code>INCR key</code></td>
<td align="left">将键存储的整数值加 1。如果键不存在，则初始化为 0 后再加 1。</td>
<td align="left"><code>INCR counter</code></td>
</tr>
<tr>
<td align="left"><code>DECR key</code></td>
<td align="left">将键存储的整数值减 1。</td>
<td align="left"><code>DECR counter</code></td>
</tr>
<tr>
<td align="left"><code>INCRBY key increment</code></td>
<td align="left">将键存储的整数值增加指定量。</td>
<td align="left"><code>INCRBY counter 10</code></td>
</tr>
<tr>
<td align="left"><code>DECRBY key decrement</code></td>
<td align="left">将键存储的整数值减少指定量。</td>
<td align="left"><code>DECRBY counter 5</code></td>
</tr>
<tr>
<td align="left"><code>GETSET key value</code></td>
<td align="left">设置键的新值并返回旧值。</td>
<td align="left"><code>GETSET mykey &quot;new_value&quot;</code></td>
</tr>
<tr>
<td align="left"><code>APPEND key value</code></td>
<td align="left">将值追加到键的末尾。如果键不存在，则创建键并设置值。</td>
<td align="left"><code>APPEND mykey &quot; world&quot;</code> (<code>mykey</code> 的值变为 <code>hello world</code>)</td>
</tr>
<tr>
<td align="left"><code>GETRANGE key start end</code></td>
<td align="left">获取字符串的子字符串。</td>
<td align="left"><code>GETRANGE mykey 0 4</code> (返回 <code>hello</code>)</td>
</tr>
<tr>
<td align="left"><code>SETEX key seconds value</code></td>
<td align="left">设置键值对并指定过期时间（秒）。</td>
<td align="left"><code>SETEX mykey 60 &quot;value&quot;</code></td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 用户会话存储、计数器、短 URL 映射。</p>
<h2 id="三、哈希-Hashes"><a href="#三、哈希-Hashes" class="headerlink" title="三、哈希 (Hashes)"></a>三、哈希 (Hashes)</h2><p>哈希是字段（field）和值（value）的映射表，非常适合存储对象。一个哈希可以存储多个字段-值对。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>HSET key field value [field value ...]</code></td>
<td align="left">设置哈希中一个或多个字段的值。</td>
<td align="left"><code>HSET user:1 name &quot;Alice&quot; age 30 city &quot;New York&quot;</code></td>
</tr>
<tr>
<td align="left"><code>HGET key field</code></td>
<td align="left">获取哈希中指定字段的值。</td>
<td align="left"><code>HGET user:1 name</code></td>
</tr>
<tr>
<td align="left"><code>HMSET key field value [field value ...]</code></td>
<td align="left">同时设置多个字段的值。（已被 <code>HSET</code> 替代，但仍兼容）</td>
<td align="left"><code>HMSET user:2 name &quot;Bob&quot; age 25</code></td>
</tr>
<tr>
<td align="left"><code>HMGET key field [field ...]</code></td>
<td align="left">同时获取多个字段的值。</td>
<td align="left"><code>HMGET user:1 name city</code></td>
</tr>
<tr>
<td align="left"><code>HGETALL key</code></td>
<td align="left">获取哈希中所有字段和值。</td>
<td align="left"><code>HGETALL user:1</code></td>
</tr>
<tr>
<td align="left"><code>HDEL key field [field ...]</code></td>
<td align="left">删除哈希中一个或多个字段。</td>
<td align="left"><code>HDEL user:1 age</code></td>
</tr>
<tr>
<td align="left"><code>HLEN key</code></td>
<td align="left">获取哈希中字段的数量。</td>
<td align="left"><code>HLEN user:1</code></td>
</tr>
<tr>
<td align="left"><code>HEXISTS key field</code></td>
<td align="left">检查哈希中是否存在指定字段。</td>
<td align="left"><code>HEXISTS user:1 name</code></td>
</tr>
<tr>
<td align="left"><code>HKEYS key</code></td>
<td align="left">获取哈希中所有字段名。</td>
<td align="left"><code>HKEYS user:1</code></td>
</tr>
<tr>
<td align="left"><code>HVALS key</code></td>
<td align="left">获取哈希中所有字段值。</td>
<td align="left"><code>HVALS user:1</code></td>
</tr>
<tr>
<td align="left"><code>HINCRBY key field increment</code></td>
<td align="left">将哈希中指定字段的值增加指定量。字段值必须是整数。</td>
<td align="left"><code>HINCRBY user:1 visits 1</code></td>
</tr>
<tr>
<td align="left"><code>HINCRBYFLOAT key field increment</code></td>
<td align="left">将哈希中指定字段的浮点数值增加指定量。</td>
<td align="left"><code>HINCRBYFLOAT product:1 price 1.5</code></td>
</tr>
<tr>
<td align="left"><code>HSETNX key field value</code></td>
<td align="left">只有当字段不存在时，才设置哈希中字段的值。</td>
<td align="left"><code>HSETNX user:1 email &quot;alice@example.com&quot;</code> (如果 <code>email</code> 字段已存在，则不会更新)</td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 存储用户对象信息、商品详情、配置设置。</p>
<h2 id="四、列表-Lists"><a href="#四、列表-Lists" class="headerlink" title="四、列表 (Lists)"></a>四、列表 (Lists)</h2><p>列表是值的有序集合。你可以向列表的两端（左侧或右侧）添加元素。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>LPUSH key value [value ...]</code></td>
<td align="left">将一个或多个值插入到列表的头部（左侧）。</td>
<td align="left"><code>LPUSH mylist &quot;apple&quot; &quot;banana&quot;</code> (列表: <code>banana, apple</code>)</td>
</tr>
<tr>
<td align="left"><code>RPUSH key value [value ...]</code></td>
<td align="left">将一个或多个值插入到列表的尾部（右侧）。</td>
<td align="left"><code>RPUSH mylist &quot;cherry&quot;</code> (列表: <code>banana, apple, cherry</code>)</td>
</tr>
<tr>
<td align="left"><code>LPOP key</code></td>
<td align="left">移除并返回列表的头部元素。</td>
<td align="left"><code>LPOP mylist</code> (返回 <code>banana</code>, 列表: <code>apple, cherry</code>)</td>
</tr>
<tr>
<td align="left"><code>RPOP key</code></td>
<td align="left">移除并返回列表的尾部元素。</td>
<td align="left"><code>RPOP mylist</code> (返回 <code>cherry</code>, 列表: <code>apple</code>)</td>
</tr>
<tr>
<td align="left"><code>LRANGE key start stop</code></td>
<td align="left">返回列表中指定范围内的元素。<code>0</code> 表示第一个元素，<code>-1</code> 表示最后一个元素。</td>
<td align="left"><code>LRANGE mylist 0 -1</code> (返回所有)<br><code>LRANGE mylist 0 0</code> (返回第一个)</td>
</tr>
<tr>
<td align="left"><code>LLEN key</code></td>
<td align="left">获取列表的长度。</td>
<td align="left"><code>LLEN mylist</code></td>
</tr>
<tr>
<td align="left"><code>LINDEX key index</code></td>
<td align="left">通过索引获取列表中的元素。</td>
<td align="left"><code>LINDEX mylist 0</code></td>
</tr>
<tr>
<td align="left"><code>LREM key count value</code></td>
<td align="left">从列表中移除与指定值相等的元素。<code>count &gt; 0</code>: 从头开始移除 <code>count</code> 个。<br><code>count &lt; 0</code>: 从尾开始移除 &#96;</td>
<td align="left">count</td>
</tr>
<tr>
<td align="left"><code>LINSERT key BEFORE|AFTER pivot value</code></td>
<td align="left">在 <code>pivot</code> 元素之前或之后插入值。</td>
<td align="left"><code>LINSERT mylist BEFORE &quot;apple&quot; &quot;pear&quot;</code> (列表: <code>banana, pear, apple, cherry</code>)</td>
</tr>
<tr>
<td align="left"><code>TRIM key start stop</code></td>
<td align="left">将列表修剪到指定范围，保留范围内的元素，移除范围外的元素。通常用于实现固定长度列表。</td>
<td align="left"><code>LTRIM mylist 0 99</code> (只保留最新的100个元素)</td>
</tr>
<tr>
<td align="left"><code>BLPOP key [key ...] timeout</code></td>
<td align="left">阻塞式左弹出。如果列表为空，则阻塞直到有元素可弹出或超时。 timeout 为 0 表示永远阻塞。</td>
<td align="left"><code>BLPOP queue1 queue2 0</code></td>
</tr>
<tr>
<td align="left"><code>BRPOP key [key ...] timeout</code></td>
<td align="left">阻塞式右弹出。</td>
<td align="left"><code>BRPOP queue1 5</code> (阻塞最多 5 秒)</td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 消息队列、最新文章列表、关注者时间线、任务队列。</p>
<h2 id="五、集合-Sets"><a href="#五、集合-Sets" class="headerlink" title="五、集合 (Sets)"></a>五、集合 (Sets)</h2><p>集合是无序的、不重复的字符串元素集合。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SADD key member [member ...]</code></td>
<td align="left">将一个或多个成员添加到集合。如果成员已存在，则忽略。</td>
<td align="left"><code>SADD myset &quot;apple&quot; &quot;banana&quot;</code></td>
</tr>
<tr>
<td align="left"><code>SMEMBERS key</code></td>
<td align="left">返回集合中的所有成员。</td>
<td align="left"><code>SMEMBERS myset</code> (返回 <code>apple</code>, <code>banana</code>，顺序不确定)</td>
</tr>
<tr>
<td align="left"><code>SISMEMBER key member</code></td>
<td align="left">判断成员是否是集合的成员。</td>
<td align="left"><code>SISMEMBER myset &quot;apple&quot;</code> (返回 1)</td>
</tr>
<tr>
<td align="left"><code>SCARD key</code></td>
<td align="left">获取集合的成员数量。</td>
<td align="left"><code>SCARD myset</code></td>
</tr>
<tr>
<td align="left"><code>SREM key member [member ...]</code></td>
<td align="left">从集合中移除一个或多个成员。</td>
<td align="left"><code>SREM myset &quot;banana&quot;</code></td>
</tr>
<tr>
<td align="left"><code>SPOP key [count]</code></td>
<td align="left">随机移除并返回集合中的一个或多个成员。</td>
<td align="left"><code>SPOP myset</code></td>
</tr>
<tr>
<td align="left"><code>SRANDMEMBER key [count]</code></td>
<td align="left">随机返回集合中的一个或多个成员，但不移除。</td>
<td align="left"><code>SRANDMEMBER myset 2</code> (随机返回两个成员)</td>
</tr>
<tr>
<td align="left"><code>SINTER key [key ...]</code></td>
<td align="left">返回所有给定集合的交集。</td>
<td align="left"><code>SADD set1 a b c</code><br><code>SADD set2 b c d</code><br><code>SINTER set1 set2</code> (返回 <code>b</code>, <code>c</code>)</td>
</tr>
<tr>
<td align="left"><code>SUNION key [key ...]</code></td>
<td align="left">返回所有给定集合的并集。</td>
<td align="left"><code>SUNION set1 set2</code> (返回 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>)</td>
</tr>
<tr>
<td align="left"><code>SDIFF key [key ...]</code></td>
<td align="left">返回第一个集合与所有其他集合的差集。</td>
<td align="left"><code>SDIFF set1 set2</code> (返回 <code>a</code>)</td>
</tr>
<tr>
<td align="left"><code>SINTERSTORE destination key [key ...]</code></td>
<td align="left">将交集结果存储到目标集合。</td>
<td align="left"><code>SINTERSTORE common_elements set1 set2</code></td>
</tr>
<tr>
<td align="left"><code>SUNIONSTORE destination key [key ...]</code></td>
<td align="left">将并集结果存储到目标集合。</td>
<td align="left"><code>SUNIONSTORE all_elements set1 set2</code></td>
</tr>
<tr>
<td align="left"><code>SDIFFSTORE destination key [key ...]</code></td>
<td align="left">将差集结果存储到目标集合。</td>
<td align="left"><code>SDIFFSTORE unique_to_set1 set1 set2</code></td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 标签系统、共同关注、抽奖程序、用户权限管理（例如，一个用户属于哪些角色）。</p>
<h2 id="六、有序集合-Sorted-Sets-ZSETS"><a href="#六、有序集合-Sorted-Sets-ZSETS" class="headerlink" title="六、有序集合 (Sorted Sets &#x2F; ZSETS)"></a>六、有序集合 (Sorted Sets &#x2F; ZSETS)</h2><p>有序集合是集合的变种，每个成员都关联一个分数（score），集合中的成员是唯一的，但分数可以重复。元素<strong>按照分数从小到大排序</strong>。分数相同的元素，再根据成员的字典序排序。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ZADD key [NX|XX] [GT|LT] [CH] [INCR] score member [score member ...]</code></td>
<td align="left">将分数和成员添加到有序集合。<code>NX</code>: 成员不存在才添加, <code>XX</code>: 成员存在才更新, <code>CH</code>: 改变计数, <code>INCR</code>: 分数递增。</td>
<td align="left"><code>ZADD myzset 1 &quot;one&quot;</code><br><code>ZADD myzset 2 &quot;two&quot; 3 &quot;three&quot;</code><br><code>ZADD myzset INCR 1 &quot;one&quot;</code> (将 “one” 的分数加 1)</td>
</tr>
<tr>
<td align="left"><code>ZRANGE key start stop [WITHSCORES]</code></td>
<td align="left">返回有序集合中指定排名范围内的成员。<code>0</code> 是第一个元素，<code>-1</code> 是最后一个元素。<code>WITHSCORES</code> 返回分数。</td>
<td align="left"><code>ZRANGE myzset 0 -1 WITHSCORES</code></td>
</tr>
<tr>
<td align="left"><code>ZREM key member [member ...]</code></td>
<td align="left">从有序集合中移除一个或多个成员。</td>
<td align="left"><code>ZREM myzset &quot;one&quot;</code></td>
</tr>
<tr>
<td align="left"><code>ZCARD key</code></td>
<td align="left">获取有序集合的成员数量。</td>
<td align="left"><code>ZCARD myzset</code></td>
</tr>
<tr>
<td align="left"><code>ZSCORE key member</code></td>
<td align="left">获取有序集合中指定成员的分数。</td>
<td align="left"><code>ZSCORE myzset &quot;two&quot;</code></td>
</tr>
<tr>
<td align="left"><code>ZRANK key member</code></td>
<td align="left">返回有序集合中指定成员的排名（分数从小到大排，排名从 0 开始）。</td>
<td align="left"><code>ZRANK myzset &quot;two&quot;</code></td>
</tr>
<tr>
<td align="left"><code>ZREVRANK key member</code></td>
<td align="left">返回有序集合中指定成员的逆序排名（分数从大到小排，排名从 0 开始）。</td>
<td align="left"><code>ZREVRANK myzset &quot;two&quot;</code></td>
</tr>
<tr>
<td align="left"><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code></td>
<td align="left">返回有序集合中指定分数范围内的成员。<code>min</code> 和 <code>max</code> 可以是 <code>-inf</code> (负无穷大) 或 <code>+inf</code> (正无穷大)。</td>
<td align="left"><code>ZRANGEBYSCORE myzset -inf 2 WITHSCORES</code><br><code>ZRANGEBYSCORE myzset (1 3</code> (排除分数 1 和 3)<br><code>ZRANGEBYSCORE myzset 1 3 LIMIT 0 1</code></td>
</tr>
<tr>
<td align="left"><code>ZCOUNT key min max</code></td>
<td align="left">返回有序集合中指定分数范围内的成员数量。</td>
<td align="left"><code>ZCOUNT myzset 1 3</code></td>
</tr>
<tr>
<td align="left"><code>ZINCRBY key increment member</code></td>
<td align="left">对有序集合中指定成员的分数进行增量操作。</td>
<td align="left"><code>ZINCRBY myzset 1 &quot;one&quot;</code></td>
</tr>
<tr>
<td align="left"><code>ZREMRANGEBYRANK key start stop</code></td>
<td align="left">移除有序集合中指定排名范围内的所有成员。</td>
<td align="left"><code>ZREMRANGEBYRANK myzset 0 99</code> (移除排名前 100 的成员)</td>
</tr>
<tr>
<td align="left"><code>ZREMRANGEBYSCORE key min max</code></td>
<td align="left">移除有序集合中指定分数范围内的所有成员。</td>
<td align="left"><code>ZREMRANGEBYSCORE myzset baits 100 200</code></td>
</tr>
<tr>
<td align="left"><code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></td>
<td align="left">计算给定多个有序集合的并集，并将结果存储到目标有序集合中。可指定权重和聚合方式。</td>
<td align="left"><code>ZADD zset1 1 &quot;a&quot; 2 &quot;b&quot;</code> <code>ZADD zset2 3 &quot;a&quot; 4 &quot;c&quot;</code><br><code>ZUNIONSTORE zunion 2 zset1 zset2 AGGREGATE MAX</code> (a:3, b:2, c:4)</td>
</tr>
<tr>
<td align="left"><code>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></td>
<td align="left">计算给定多个有序集合的交集，并将结果存储到目标有序集合中。</td>
<td align="left"><code>ZINTERSTORE zinter 2 zset1 zset2 AGGREGATE SUM</code> (a:4)</td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 排行榜（游戏积分榜、最热文章榜）、带有优先级的任务队列、根据分数范围筛选数据。</p>
<h2 id="七、Stream-流"><a href="#七、Stream-流" class="headerlink" title="七、Stream (流)"></a>七、Stream (流)</h2><p>Redis 5.0 引入了 Stream 数据结构，它是一个只追加的数据结构，用于处理日志流、事件流等时间序列数据。它支持多消费者组。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>XADD key ID field value [field value ...]</code></td>
<td align="left">添加新的条目到 Stream。ID 可以是 <code>*</code> (自动生成)，或手动指定。</td>
<td align="left"><code>XADD mystream * sensor_id 123 temperature 25.5</code><br><code>XADD mystream 1-0 event_type &quot;login&quot; user_id 456</code></td>
</tr>
<tr>
<td align="left"><code>XRANGE key start end [COUNT count]</code></td>
<td align="left">获取 Stream 中指定 ID 范围内的条目。<code>min</code> 和 <code>max</code> 可以是 <code>&quot;-&quot;</code> (最小ID) 或 <code>&quot;+&quot;</code> (最大ID)。</td>
<td align="left"><code>XRANGE mystream - +</code><br><code>XRANGE mystream 1678881330000-0 1678881330999-999 COUNT 10</code></td>
</tr>
<tr>
<td align="left"><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></td>
<td align="left">从一个或多个 Stream 中读取条目。<code>BLOCK</code> 实现阻塞读取。</td>
<td align="left"><code>XREAD COUNT 2 STREAMS mystream 0-0</code><br><code>XREAD BLOCK 0 STREAMS mystream $</code> (阻塞读取最新条目)</td>
</tr>
<tr>
<td align="left"><code>XGROUP CREATE key groupname ID [MKSTREAM]</code></td>
<td align="left">创建消费者组。<code>ID</code> 指定消费者组的起始 ID（例如 <code>$</code> 表示从最新开始，<code>0</code> 表示从头开始）。<code>MKSTREAM</code>：如果 Stream 不存在则自动创建。</td>
<td align="left"><code>XGROUP CREATE mystream mygroup $ MKSTREAM</code></td>
</tr>
<tr>
<td align="left"><code>XREADGROUP GROUP groupname consumername COUNT count [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</code></td>
<td align="left">从消费者组中读取条目。<code>ID</code> 为 <code>&gt;</code> 表示从未发送给当前消费者的条目开始。</td>
<td align="left"><code>XREADGROUP GROUP mygroup myconsumer COUNT 1 STREAMS mystream &gt;</code></td>
</tr>
<tr>
<td align="left"><code>XACK key groupname ID [ID ...]</code></td>
<td align="left">确认消费者已处理完某个条目。</td>
<td align="left"><code>XACK mystream mygroup 1678881330000-0</code></td>
</tr>
<tr>
<td align="left"><code>XPENDING key groupname [IDLE min-idle-time] [start end count] [consumer]</code></td>
<td align="left">获取消费者组中待处理消息列表。</td>
<td align="left"><code>XPENDING mystream mygroup</code></td>
</tr>
<tr>
<td align="left"><code>XCLAIM key groupname consumername min-idle-time ID [ID ...]</code></td>
<td align="left">夺回（claim）其他消费者已读取但长时间未确认的条目。</td>
<td align="left"><code>XCLAIM mystream mygroup newconsumer 3600000 1678881330000-0</code></td>
</tr>
<tr>
<td align="left"><code>XTRIM key MAXLEN [~] count</code></td>
<td align="left">裁剪 Stream，保留指定数量的最新条目。<code>~</code> 大约保留。</td>
<td align="left"><code>XTRIM mystream MAXLEN 1000</code></td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 实时消息系统、事件溯源、微服务间通信、物联网数据采集。</p>
<h2 id="八、HyperLogLog-HLL"><a href="#八、HyperLogLog-HLL" class="headerlink" title="八、HyperLogLog (HLL)"></a>八、HyperLogLog (HLL)</h2><p>HyperLogLog 是一种概率性数据结构，用于估算集合中元素的唯一数量（即基数）。它使用的内存非常少（固定 12KB），但会存在小部分误差。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>PFADD key element [element ...]</code></td>
<td align="left">添加一个或多个元素到 HyperLogLog。</td>
<td align="left"><code>PFADD users:20231010 &quot;user1&quot; &quot;user2&quot; &quot;user3&quot;</code></td>
</tr>
<tr>
<td align="left"><code>PFCOUNT key [key ...]</code></td>
<td align="left">返回 HyperLogLog 的近似基数。</td>
<td align="left"><code>PFCOUNT users:20231010</code></td>
</tr>
<tr>
<td align="left"><code>PFMERGE destkey sourcekey [sourcekey ...]</code></td>
<td align="left">将多个 HyperLogLog 合并到一个新的 HyperLogLog 中。</td>
<td align="left"><code>PFMERGE users:total users:20231010 users:20231011</code></td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 网站独立访客数统计、用户日活&#x2F;月活统计、热门商品访问量统计。</p>
<h2>九、Geospatial (地理空间)</h2>

<p>Redis 3.2 引入了地理空间索引，允许存储和查询地理空间坐标，通常用于基于位置的服务 (LBS)。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></td>
<td align="left">添加一个或多个地理空间成员（经度、纬度和名称）。</td>
<td align="left"><code>GEOADD city_locations 13.361 38.084 &quot;Palermo&quot; 15.087 37.502 &quot;Catania&quot;</code></td>
</tr>
<tr>
<td align="left"><code>GEOPOS key member [member ...]</code></td>
<td align="left">获取指定成员的经度和纬度。</td>
<td align="left"><code>GEOPOS city_locations &quot;Palermo&quot;</code></td>
</tr>
<tr>
<td align="left"><code>GEODIST key member1 member2 [UNIT]</code></td>
<td align="left">计算两个成员之间的距离。<code>UNIT</code> 可以是 <code>m</code> (米), <code>km</code> (千米), <code>mi</code> (英里), <code>ft</code> (英尺)。</td>
<td align="left"><code>GEODIST city_locations &quot;Palermo&quot; &quot;Catania&quot; km</code></td>
</tr>
<tr>
<td align="left"><code>GEORADIUS key longitude latitude radius IN|OUT [UNIT] [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></td>
<td align="left">根据中心点和半径查询附近的成员。<code>WITHCOORD</code> 返回坐标，<code>WITHDIST</code> 返回距离。</td>
<td align="left"><code>GEORADIUS city_locations 15 37 100 km WITHCOORD WITHDIST COUNT 5 ASC</code></td>
</tr>
<tr>
<td align="left"><code>GEOSEARCH key [FROMMEMBER member|FROMLONLAT longitude latitude] [BYRADIUS radius unit|BYBOX width height unit] [ASC|DESC] [COUNT count [ANY]] [WITHCOORD] [WITHDIST] [WITHHASH]</code></td>
<td align="left">更灵活的地理空间查询指令 (Redis 6.2+)。</td>
<td align="left"><code>GEOSEARCH city_locations FROMLONLAT 15 37 BYRADIUS 100 km</code></td>
</tr>
</tbody></table>
<p><strong>场景示例</strong>: 查找附近的人&#x2F;店铺、地理围栏、LBS 游戏。</p>
<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>Redis 凭借其丰富的数据结构和闪电般的读写速度，使其成为现代应用开发中不可或缺的工具。</p>
<ul>
<li><strong>字符串</strong>：最简单，用于缓存、计数器、KV 存储。</li>
<li><strong>哈希</strong>：适合存储对象，如用户会话、商品信息。</li>
<li><strong>列表</strong>：实现消息队列、时间线、LIFO&#x2F;FIFO 队列。</li>
<li><strong>集合</strong>：去重、集合运算，如标签、共同兴趣、权限管理。</li>
<li><strong>有序集合</strong>：排行榜、带优先级队列、范围查询。</li>
<li><strong>Stream</strong>：处理时间序列数据、消息队列、事件日志。</li>
<li><strong>HyperLogLog</strong>：大数据集的基数估算，节省内存。</li>
<li><strong>Geospatial</strong>：地理位置信息存储与查询，LBS 应用。</li>
</ul>
<p>通过理解每种数据结构的特性和适用场景，并熟练运用其相关指令，你将能够更好地设计和优化你的应用程序，充分发挥 Redis 的强大潜力。开始使用这些指令，构建你的高性能、高并发应用吧！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2dc66126bcaa/">https://blog.tbf1211.xx.kg/2dc66126bcaa/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/e82a5ce0823e/" title="Web3.0解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Web3.0解析</div></div><div class="info-2"><div class="info-item-1"> Web 3.0 并非一个单一的技术或产品，而是一个正在演进中的互联网愿景，旨在构建一个更加去中心化、开放、可信和用户拥有数据的未来网络。它被认为是继 Web 1.0 (只读网络) 和 Web 2.0 (读写网络) 之后的“价值互联网”或“所有权互联网”。  “Web3 is the internet owned by the builders and users, orchestrated with tokens.” —— Chris Dixon, Andreessen Horowitz   一、互联网的演进：从 Web 1.0 到 Web 3.0为了更好地理解 Web 3.0，我们首先回顾一下互联网的两个重要阶段。 1. Web 1.0：只读网络 (Tim Berners-Lee 的愿景) 时间: 约 1990 年代初至 2000 年代初。 特点: 静态网页: 主要由静态 HTML 页面组成。 信息发布: 用户主要是信息的消费者，从网站获取信息。 门户网站: AOL、Yahoo! 等门户网站是主要的流量入口。 “信息高速公路”: 旨在连接人与信息。   核心痛点: 用户参与度...</div></div></div></a><a class="pagination-related" href="/b519dd676c66/" title="PWA (Progressive Web Apps) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">PWA (Progressive Web Apps) 深度解析</div></div><div class="info-2"><div class="info-item-1"> PWA (Progressive Web Apps - 渐进式 Web 应用) 是一种利用现代 Web 技术，将 Web 应用提升至接近原生应用体验的新方法。它旨在结合 Web 的广阔可达性与原生应用的丰富功能，为用户提供可靠 (Reliable)、快速 (Fast)、沉浸式 (Engaging) 的体验。PWA 不仅仅是一种技术，更是一套开发理念和最佳实践。  核心思想：PWA 的目标是让 Web 应用具备类似原生应用的体验和功能，同时保留 Web 的优点（无需安装、易于发现、跨平台）。这主要通过 Service Worker 实现离线能力和性能优化，通过 Web App Manifest 实现安装和应用体验，以及通过 HTTPS 确保安全性来达成。   一、为什么需要 PWA？(Web 与原生应用的融合)传统 Web 应用和原生移动应用各有优缺点：  传统 Web 应用 (网站)： 优点：无需安装、易于发现、跨平台、更新灵活、共享方便。 缺点：依赖网络、加载慢、无离线功能、无法添加到主屏幕、无法发送推送通知、用户体验与原生应用有差距。   原生移动应用： 优点：性能好、可离...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/abb68b6fbe95/" title="从单机到哨兵，一张图理清redis架构演进！"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-26</div><div class="info-item-2">从单机到哨兵，一张图理清redis架构演进！</div></div><div class="info-2"><div class="info-item-1">Redis 的架构是逐步演进而来的，正所谓“罗马不是一天建成的”。    2010 年：单机版 Redis  当 Redis1.0在 2010 年首次发布时，整体架构非常简单，通常作为业务系统的缓存使用。不过，Redis 的数据是存储在内存中的，一旦重启，数据就会全部丢失，导致请求会直接打到数据库上，带来较大的压力。  2013 年：持久化机制上线  2013 年，Redis2.8版本发布，解决了之前“重启就丢数据”的问题。Redis 引入了 RDB（内存快照）机制，用于定时将内存中的数据持久化到磁盘。同时还支持 AOF（只追加文件）方式，将每一次写操作都记录到日志文件中，实现更高级别的持久化保障。  2013 年：主从复制机制  同样在 Redis2.8中，官方引入了主从复制功能，提升了系统的高可用性。主节点负责处理实时的读写请求，从节点则负责同步主节点的数据，起到备份和读扩展的作用。  2013 年：Sentinel 哨兵机制上线  在 Redis2.8版本中，引入了 Sentinel（哨兵）机制，用于实时监控 Redis 实例的运行状态。它主要负责以下几个方面的工作：   ...</div></div></div></a><a class="pagination-related" href="/895bad372d95/" title="MySQL 索引详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="info-item-2">MySQL 索引详解</div></div><div class="info-2"><div class="info-item-1"> 索引是数据库中用于提高查询速度的一种数据结构。在 MySQL 中，合理有效地使用索引能够显著提升数据库的查询性能，减少 I&#x2F;O 操作。然而，不恰当的索引也可能带来额外的开销。理解 MySQL 索引的原理和优化策略，是数据库性能调优的关键。  “好的索引，事半功倍；坏的索引，越帮越忙。” - 数据库优化格言   一、什么是索引？索引（Index）是一种特殊的查找表，数据库搜索引擎可以利用它来快速定位数据。可以将其类比为一本书的目录，通过目录我们可以快速找到感兴趣的章节，而不需要通读整本书。 在数据库中，没有索引的查询需要全表扫描，即逐行检查每条记录，直到找到符合条件的记录。当数据量非常大时，这种操作的效率会非常低下。索引通过创建指向数据物理位置的指针，使得数据库在查询时能够直接跳转到相关记录，从而大大加快查询速度。 二、索引的优缺点优点 显著提高数据检索速度：这是索引最核心、最主要的优点。 加快表与表之间的连接速度：对于 JOIN 操作，索引可以加速连接条件的匹配。 加快分组和排序操作：GROUP BY 和 ORDER BY 操作通常通过消除临时表和对文件进行排序来提高...</div></div></div></a><a class="pagination-related" href="/138d9ed60364/" title="MySQL EXPLAIN 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="info-item-2">MySQL EXPLAIN 详解</div></div><div class="info-2"><div class="info-item-1"> EXPLAIN 是 MySQL 提供的一个非常强大的工具，用于分析 SELECT 语句的执行计划。通过 EXPLAIN 的输出结果，我们可以了解查询是如何执行的，包括使用了哪些索引、扫描了多少行、是否进行了文件排序等信息。这是数据库性能调优不可或缺的一环，能够帮助我们发现 SQL 语句中的性能瓶颈并进行优化。  “优化前，先 EXPLAIN。没有 EXPLAIN 的优化都是盲人摸象。” - 数据库优化格言   一、什么是 EXPLAIN？EXPLAIN 命令实际上是用来获取 MySQL 执行查询语句的执行计划的。执行计划描述了 MySQL 如何处理 SQL 语句，包括：  表的连接顺序 每个表使用的索引 是否使用了临时表 是否进行了文件排序 扫描的行数预估  通过分析这些信息，我们可以判断查询是否高效，是否可以进一步优化。 二、如何使用 EXPLAIN？使用 EXPLAIN 非常简单，只需将 EXPLAIN 关键字放在任何 SELECT 语句的前面。 1234EXPLAIN SELECT * FROM users WHERE username = &#x27;Alice&#x2...</div></div></div></a><a class="pagination-related" href="/f1bab0cad58f/" title="MySQL B+树索引原理详解与对比"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-11</div><div class="info-item-2">MySQL B+树索引原理详解与对比</div></div><div class="info-2"><div class="info-item-1"> 数据库索引是提升查询性能的关键，而 MySQL 中最常见的索引结构就是 B+树。理解 B+树的原理对于优化数据库性能至关重要。本文将详细解析 B+树索引的内部工作机制，并将其与二叉查找树、平衡二二叉查找树、红黑树和 B 树进行对比，阐明 B+树在磁盘存储和数据库查询场景下的优势。  “索引的本质是空间换时间，而 B+树是这种理念在磁盘存储场景下的极致优化。”   一、为什么需要索引？想象一下，你有一本几百页的字典，如果要查找一个词，没有目录（索引）的话，你可能需要从头到尾翻阅。而有了目录（索引），你可以快速定位到词语的大致位置，大大提高查找效率。 在数据库中，表是按照某种顺序（不一定是逻辑顺序）存储在磁盘上的。当数据量巨大时，如果没有索引，每次查询都需要进行全表扫描（Full Table Scan），这意味着数据库需要读取磁盘上的每一行数据并进行比较，效率极低。 索引通过创建一种特殊的数据结构，可以快速定位到数据记录的位置，从而显著减少磁盘 I&#x2F;O 次数，提高查询速度。 二、各种树结构简述与对比在深入 B+树之前，我们先回顾一下几种常见的树形数据结构，了解它们的优缺点...</div></div></div></a><a class="pagination-related" href="/c67852654c03/" title="Docker镜像构建与管理：打造标准化、可复用的容器镜像"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">Docker镜像构建与管理：打造标准化、可复用的容器镜像</div></div><div class="info-2"><div class="info-item-1"> 原文地址 mp.weixin.qq.com  Docker 镜像构建与管理：打造标准化、可复用的容器镜像开篇：你是否也在镜像管理上栽过跟头？凌晨 2 点，生产环境突然告警，新部署的容器启动失败。排查后发现：开发环境用的镜像 800MB，生产环境的却有 3.2GB，里面塞满了编译工具、测试数据，甚至还有开发同学的 SSH 私钥… 这种 “镜像肥胖症” 你遇到过吗？或者更糟糕的：  同一个服务，测试环境能跑，生产环境启动就报错 镜像仓库里堆满了 latest、v1、v1-final、v1-final-final 这种让人崩溃的标签 构建一次镜像要等 20 分钟，因为每次都要重新下载依赖包  今天这篇文章，我会基于 5 年运维实战经验，教你构建一套标准化的镜像管理体系：从多阶段构建优化到镜像安全扫描，从版本管理策略到自动化构建流程，让你的镜像体积缩小 70%、构建速度提升 5 倍，并且永远不会再出现 “这个镜像到底能不能用” 的灵魂拷问。 一、镜像构建的三大核心原则（90% 的人都忽略了）1. 最小化原则：镜像里只放 “必需品”很多人写 Dockerfile 就像搬家，什么都往里塞。...</div></div></div></a><a class="pagination-related" href="/5dea4260c32f/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">306</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%9A%E7%94%A8%E9%94%AE%E6%8C%87%E4%BB%A4-Generic-Commands"><span class="toc-text">一、通用键指令 (Generic Commands)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-Strings"><span class="toc-text">二、字符串 (Strings)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%93%88%E5%B8%8C-Hashes"><span class="toc-text">三、哈希 (Hashes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%88%97%E8%A1%A8-Lists"><span class="toc-text">四、列表 (Lists)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%9B%86%E5%90%88-Sets"><span class="toc-text">五、集合 (Sets)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-Sorted-Sets-ZSETS"><span class="toc-text">六、有序集合 (Sorted Sets &#x2F; ZSETS)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Stream-%E6%B5%81"><span class="toc-text">七、Stream (流)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81HyperLogLog-HLL"><span class="toc-text">八、HyperLogLog (HLL)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">九、Geospatial (地理空间)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">十、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"/></a><div class="content"><a class="title" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析">压缩字典树 (Radix Trie/Patricia Trie) 深度解析</a><time datetime="2025-11-17T22:24:00.000Z" title="发表于 2025-11-18 06:24:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c28be5a597e1/" title="Golang 内存对齐详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 内存对齐详解"/></a><div class="content"><a class="title" href="/c28be5a597e1/" title="Golang 内存对齐详解">Golang 内存对齐详解</a><time datetime="2025-11-12T22:24:00.000Z" title="发表于 2025-11-13 06:24:00">2025-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 空结构体 (struct{}) 详解"/></a><div class="content"><a class="title" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解">Golang 空结构体 (struct{}) 详解</a><time datetime="2025-11-10T22:24:00.000Z" title="发表于 2025-11-11 06:24:00">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b100840425a8/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codex 详解与使用技巧：OpenAI 的代码智能模型"/></a><div class="content"><a class="title" href="/b100840425a8/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型">Codex 详解与使用技巧：OpenAI 的代码智能模型</a><time datetime="2025-11-06T22:24:00.000Z" title="发表于 2025-11-07 06:24:00">2025-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Claude Code 详解：Anthropic 的代码智能模型"/></a><div class="content"><a class="title" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型">Claude Code 详解：Anthropic 的代码智能模型</a><time datetime="2025-11-04T22:24:00.000Z" title="发表于 2025-11-05 06:24:00">2025-11-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-28.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>