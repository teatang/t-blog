<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Protocol Buffers 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Protocol Buffers (Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的序列化数据结构的方法。它旨在替代 XML 等数据交换格式，以实现更小、更快、更简单的数据传输。Protobuf 允许开发者定义数据结构（称为 message），并通过生成的代码，以高效的二进制格式序列化这些数据，或从二进制格式反序列化回原始数据结构。它广泛应用于微服务间的通信、数据存储">
<meta property="og:type" content="article">
<meta property="og:title" content="Protocol Buffers 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/a90dd53e3ba4/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Protocol Buffers (Protobuf) 是 Google 开发的一种语言无关、平台无关、可扩展的序列化数据结构的方法。它旨在替代 XML 等数据交换格式，以实现更小、更快、更简单的数据传输。Protobuf 允许开发者定义数据结构（称为 message），并通过生成的代码，以高效的二进制格式序列化这些数据，或从二进制格式反序列化回原始数据结构。它广泛应用于微服务间的通信、数据存储">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg">
<meta property="article:published_time" content="2026-02-11T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-26T10:04:41.134Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Protocol Buffers 详解",
  "url": "https://blog.tbf1211.xx.kg/a90dd53e3ba4/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg",
  "datePublished": "2026-02-11T22:24:00.000Z",
  "dateModified": "2026-02-26T10:04:41.134Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/a90dd53e3ba4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Protocol Buffers 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">562</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Protocol Buffers 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Protocol Buffers 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2026-02-11T22:24:00.000Z" title="发表于 2026-02-12 06:24:00">2026-02-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Protocol Buffers (Protobuf)</strong> 是 Google 开发的一种<strong>语言无关、平台无关、可扩展的序列化数据结构</strong>的方法。它旨在替代 XML 等数据交换格式，以实现更小、更快、更简单的数据传输。Protobuf 允许开发者定义数据结构（称为 <code>message</code>），并通过生成的代码，以高效的二进制格式序列化这些数据，或从二进制格式反序列化回原始数据结构。它广泛应用于微服务间的通信、数据存储以及网络协议定义等场景，尤其是 Google 自家的 gRPC 框架更是以 Protobuf 作为其默认的接口定义语言和数据交换格式。</p>
</blockquote>
<div class="note info flat"><p>核心思想：通过简洁的 <code>.proto</code> 文件定义数据结构，然后通过代码生成工具将其转换为特定语言的高效代码，实现紧凑、快速的二进制数据序列化和反序列化，支持强大的 Schema 演进和跨语言互操作性。</p>
</div>

<hr>
<h2 id="一、为什么需要-Protocol-Buffers？"><a href="#一、为什么需要-Protocol-Buffers？" class="headerlink" title="一、为什么需要 Protocol Buffers？"></a>一、为什么需要 Protocol Buffers？</h2><p>在分布式系统和微服务架构中，不同服务之间的数据交换是核心环节。传统的数据交换格式，如 JSON 或 XML，存在以下一些问题：</p>
<ol>
<li><strong>性能瓶颈</strong>：文本格式解析速度相对较慢，对于大量数据或高并发场景，CPU 消耗较大。</li>
<li><strong>数据体积大</strong>：文本格式通常包含大量的冗余字符（如标签、空格、换行），导致数据包体积较大，增加了网络带宽和存储成本。</li>
<li><strong>缺乏强类型检查</strong>：JSON&#x2F;XML 本身是弱类型的，虽然可以通过 Schema 定义进行约束，但运行时仍然容易出现类型不匹配或字段缺失的问题，需要额外的验证逻辑。</li>
<li><strong>跨语言互操作性复杂</strong>：虽然 JSON&#x2F;XML 是跨语言的，但要在不同语言中实现对复杂数据结构的序列化和反序列化，并保持严格的类型和结构一致性，需要各语言端手动实现或使用第三方库，容易出错。</li>
</ol>
<p>Protocol Buffers 旨在解决这些问题，提供一个：</p>
<ul>
<li><strong>高效和紧凑</strong>：使用二进制格式存储数据，大幅减少存储空间和网络传输带宽，解析速度更快。</li>
<li><strong>强类型</strong>：通过严格的 <code>*.proto</code> 文件定义，确保数据结构的一致性，减少运行时错误。</li>
<li><strong>出色的 Schema 演进能力</strong>：允许在数据结构发生变化时，保持新旧数据之间的兼容性，使得系统组件可以独立升级。</li>
<li><strong>语言无关性</strong>：支持大多数主流编程语言（Java, Python, C++, Go, C#, Ruby, JavaScript 等）。</li>
</ul>
<h2 id="二、Protocol-Buffers-的核心概念"><a href="#二、Protocol-Buffers-的核心概念" class="headerlink" title="二、Protocol Buffers 的核心概念"></a>二、Protocol Buffers 的核心概念</h2><h3 id="2-1-Interface-Definition-Language-IDL-proto-文件"><a href="#2-1-Interface-Definition-Language-IDL-proto-文件" class="headerlink" title="2.1 Interface Definition Language (IDL) - .proto 文件"></a>2.1 Interface Definition Language (IDL) - <code>.proto</code> 文件</h3><p>Protobuf 的核心是 <code>.proto</code> 文件，它使用一种简洁的<strong>接口定义语言 (IDL)</strong> 来描述数据结构。开发者在 <code>.proto</code> 文件中定义 <code>message</code> 类型，类似于编程语言中的类或结构体。</p>
<p><strong>示例：</strong></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 指定 Protobuf 版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial; <span class="comment">// 定义包名，避免命名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">bool</span> has_email = <span class="number">3</span>; <span class="comment">// 字段定义：类型 字段名 = 字段编号;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123; <span class="comment">// 定义枚举类型</span></span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123; <span class="comment">// 可以定义嵌套消息</span></span><br><span class="line">    <span class="type">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>; <span class="comment">// repeated 表示可以有零个或多个该类型的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Message-Types-消息类型"><a href="#2-2-Message-Types-消息类型" class="headerlink" title="2.2 Message Types (消息类型)"></a>2.2 Message Types (消息类型)</h3><p><code>message</code> 是 Protobuf 中最基本的数据结构单元。它由一系列命名字段组成，每个字段都有一个类型和一个唯一的字段编号。</p>
<h3 id="2-3-字段规则与数据类型"><a href="#2-3-字段规则与数据类型" class="headerlink" title="2.3 字段规则与数据类型"></a>2.3 字段规则与数据类型</h3><h4 id="2-3-1-字段规则-Field-Rules"><a href="#2-3-1-字段规则-Field-Rules" class="headerlink" title="2.3.1 字段规则 (Field Rules)"></a>2.3.1 字段规则 (Field Rules)</h4><p>在 <code>proto2</code> 中，字段规则有 <code>required</code>, <code>optional</code>, <code>repeated</code>。</p>
<ul>
<li><code>required</code>：字段必须被设置。如果未设置，序列化时会出错。</li>
<li><code>optional</code>：字段可有可无。如果未设置，则使用默认值。</li>
<li><code>repeated</code>：字段可以重复任意次数（包括零次），相当于数组或列表。</li>
</ul>
<p>在 <code>proto3</code> 中，简化了字段规则：</p>
<ul>
<li><strong>默认隐式可选</strong>：所有非 <code>repeated</code> 的字段都是 <code>optional</code> 的，且没有 <code>required</code> 关键字。如果赋值为字段类型的默认值（例如 <code>int32</code> 为 0，<code>string</code> 为空字符串，<code>bool</code> 为 <code>false</code>），它在序列化时不会被编码，从而节省空间。</li>
<li><code>repeated</code>：与 <code>proto2</code> 相同，表示列表或数组。</li>
</ul>
<h4 id="2-3-2-数据类型-Scalar-Types"><a href="#2-3-2-数据类型-Scalar-Types" class="headerlink" title="2.3.2 数据类型 (Scalar Types)"></a>2.3.2 数据类型 (Scalar Types)</h4><p>Protobuf 提供了丰富的标量数据类型，对应到不同编程语言会有相应的映射：</p>
<table>
<thead>
<tr>
<th align="left">Protobuf 类型</th>
<th align="left">备注</th>
<th align="left">对应 Python 类型</th>
<th align="left">对应 Java 类型</th>
<th align="left">对应 Go 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>double</code></td>
<td align="left">双精度浮点数</td>
<td align="left"><code>float</code></td>
<td align="left"><code>double</code></td>
<td align="left"><code>float64</code></td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left">单精度浮点数</td>
<td align="left"><code>float</code></td>
<td align="left"><code>float</code></td>
<td align="left"><code>float32</code></td>
</tr>
<tr>
<td align="left"><code>int32</code></td>
<td align="left">32 位整数 (使用变长编码，负数效率低)</td>
<td align="left"><code>int</code></td>
<td align="left"><code>int</code></td>
<td align="left"><code>int32</code></td>
</tr>
<tr>
<td align="left"><code>int64</code></td>
<td align="left">64 位整数 (使用变长编码，负数效率低)</td>
<td align="left"><code>int</code></td>
<td align="left"><code>long</code></td>
<td align="left"><code>int64</code></td>
</tr>
<tr>
<td align="left"><code>uint32</code></td>
<td align="left">32 位无符号整数 (使用变长编码)</td>
<td align="left"><code>int</code></td>
<td align="left"><code>int</code></td>
<td align="left"><code>uint32</code></td>
</tr>
<tr>
<td align="left"><code>uint64</code></td>
<td align="left">64 位无符号整数 (使用变长编码)</td>
<td align="left"><code>int</code></td>
<td align="left"><code>long</code></td>
<td align="left"><code>uint64</code></td>
</tr>
<tr>
<td align="left"><code>sint32</code></td>
<td align="left">32 位有符号整数 (使用 ZigZag 编码，负数效率高)</td>
<td align="left"><code>int</code></td>
<td align="left"><code>int</code></td>
<td align="left"><code>int32</code></td>
</tr>
<tr>
<td align="left"><code>sint64</code></td>
<td align="left">64 位有符号整数 (使用 ZigZag 编码，负数效率高)</td>
<td align="left"><code>int</code></td>
<td align="left"><code>long</code></td>
<td align="left"><code>int64</code></td>
</tr>
<tr>
<td align="left"><code>fixed32</code></td>
<td align="left">32 位固定长度整数</td>
<td align="left"><code>int</code></td>
<td align="left"><code>int</code></td>
<td align="left"><code>uint32</code></td>
</tr>
<tr>
<td align="left"><code>fixed64</code></td>
<td align="left">64 位固定长度整数</td>
<td align="left"><code>int</code></td>
<td align="left"><code>long</code></td>
<td align="left"><code>uint64</code></td>
</tr>
<tr>
<td align="left"><code>sfixed32</code></td>
<td align="left">32 位有符号固定长度整数</td>
<td align="left"><code>int</code></td>
<td align="left"><code>int</code></td>
<td align="left"><code>int32</code></td>
</tr>
<tr>
<td align="left"><code>sfixed64</code></td>
<td align="left">64 位有符号固定长度整数</td>
<td align="left"><code>int</code></td>
<td align="left"><code>long</code></td>
<td align="left"><code>int64</code></td>
</tr>
<tr>
<td align="left"><code>bool</code></td>
<td align="left">布尔值</td>
<td align="left"><code>bool</code></td>
<td align="left"><code>boolean</code></td>
<td align="left"><code>bool</code></td>
</tr>
<tr>
<td align="left"><code>string</code></td>
<td align="left">UTF-8 编码的文本字符串</td>
<td align="left"><code>str</code></td>
<td align="left"><code>String</code></td>
<td align="left"><code>string</code></td>
</tr>
<tr>
<td align="left"><code>bytes</code></td>
<td align="left">任意字节序列</td>
<td align="left"><code>bytes</code></td>
<td align="left"><code>ByteString</code></td>
<td align="left"><code>[]byte</code></td>
</tr>
</tbody></table>
<p><strong>注意</strong>：<code>int32</code>, <code>int64</code>, <code>uint32</code>, <code>uint64</code> 使用 <code>varint</code> 变长编码，对于小数值非常高效，但对于负数，<code>int32</code> 和 <code>int64</code> 会占用 10 个字节。因此，如果字段值可能为负且数值范围较大，建议使用 <code>sint32</code> 或 <code>sint64</code>，它们使用 ZigZag 编码，对负数同样高效。</p>
<h3 id="2-4-字段编号-Field-Numbers"><a href="#2-4-字段编号-Field-Numbers" class="headerlink" title="2.4 字段编号 (Field Numbers)"></a>2.4 字段编号 (Field Numbers)</h3><p>每个字段声明时都会有一个<strong>唯一的字段编号</strong>（例如 <code>name = 1;</code> 中的 <code>1</code>）。这个编号在序列化时用于标识字段，而不是字段名。这是 Protobuf 实现<strong>Schema 演进</strong>的关键。</p>
<ul>
<li><strong>规则</strong>：字段编号必须在 1 到 536,870,911 之间。1 到 15 的编号需要一个字节编码，16 到 2047 需要两个字节。因此，对于频繁出现或数量较大的字段，应使用 1 到 15 的编号以优化性能。不应使用 19000 到 19999 的编号，这是 Protobuf 内部保留的。</li>
<li><strong>重要性</strong>：一旦定义，<strong>字段编号绝不能更改</strong>。删除某个字段后，在将来也不应重新使用该字段编号，以避免与旧数据发生冲突。</li>
</ul>
<h3 id="2-5-序列化和反序列化"><a href="#2-5-序列化和反序列化" class="headerlink" title="2.5 序列化和反序列化"></a>2.5 序列化和反序列化</h3><p>当数据从应用程序写入时，Protobuf 会根据 Schema 定义和字段类型，将其编码为紧凑的<strong>二进制格式</strong>。反之，当读取数据时，Protobuf 会将二进制数据解码回应用程序中的数据对象。</p>
<h3 id="2-6-代码生成-Code-Generation"><a href="#2-6-代码生成-Code-Generation" class="headerlink" title="2.6 代码生成 (Code Generation)"></a>2.6 代码生成 (Code Generation)</h3><p>Protobuf 最大的特点是其<strong>代码生成</strong>机制。开发者使用 <code>protoc</code> (Protobuf 编译器) 对 <code>.proto</code> 文件进行编译，生成目标语言（如 Python, Java, Go）的源代码文件。这些生成的代码包含了与 message 类型对应的类或结构体，以及方便的 getter&#x2F;setter 方法和序列化&#x2F;反序列化方法。</p>
<h3 id="2-7-Schema-演进-Schema-Evolution"><a href="#2-7-Schema-演进-Schema-Evolution" class="headerlink" title="2.7 Schema 演进 (Schema Evolution)"></a>2.7 Schema 演进 (Schema Evolution)</h3><p>Protobuf 的 Schema 演进能力非常强大，允许你在不破坏现有数据兼容性的前提下修改数据结构：</p>
<ul>
<li><strong>新增字段</strong>：可以添加新的字段，只要分配一个新的、未使用的字段编号。旧的程序读取新数据时会忽略这些新字段；新的程序读取旧数据时，新字段将使用其默认值。</li>
<li><strong>删除字段</strong>：可以删除字段，但其字段编号不能再被使用。新程序读取旧数据时会忽略该字段；旧程序读取新数据时会忽略已删除的字段。</li>
<li><strong>修改字段类型</strong>：某些类型兼容性修改是允许的（例如 <code>int32</code> 改为 <code>int64</code>），但通常不推荐，因为它可能会导致数据丢失或解析错误。多数类型之间的更改是不兼容的。</li>
<li><strong>重命名字段</strong>：允许重命名字段，只要字段编号保持不变即可，因为序列化时只依赖字段编号。</li>
<li><strong>添加 <code>oneof</code> 字段</strong>：允许在 <code>oneof</code> 中添加新成员。</li>
<li><strong>添加 <code>enum</code> 值</strong>：可以添加新的枚举值。</li>
</ul>
<h2 id="三、Protobuf-的优势与劣势"><a href="#三、Protobuf-的优势与劣势" class="headerlink" title="三、Protobuf 的优势与劣势"></a>三、Protobuf 的优势与劣势</h2><h3 id="3-1-优势"><a href="#3-1-优势" class="headerlink" title="3.1 优势"></a>3.1 优势</h3><ul>
<li><strong>高效紧凑</strong>：二进制格式相比 XML&#x2F;JSON 大幅减少数据体积，节省带宽和存储。</li>
<li><strong>序列化速度快</strong>：二进制编码和解码速度远超文本格式。</li>
<li><strong>强类型</strong>：<code>.proto</code> 文件定义了严格的类型和结构，减少了运行时错误。</li>
<li><strong>Schema 演进</strong>：通过字段编号实现向前和向后兼容性，方便系统升级和协调。</li>
<li><strong>跨语言支持</strong>：生成的代码可以在多种编程语言中使用，实现无缝的跨语言数据交换。</li>
<li><strong>自动代码生成</strong>： <code>protoc</code> 简化了开发，减少了手动编写序列化代码的工作量和出错率。</li>
<li><strong>广泛应用于 RPC</strong>：是 gRPC 的基础，是构建高性能分布式系统的理想选择。</li>
</ul>
<h3 id="3-2-劣势"><a href="#3-2-劣势" class="headerlink" title="3.2 劣势"></a>3.2 劣势</h3><ul>
<li><strong>非人类可读</strong>：二进制格式不方便直接查看和调试，需要专门的工具或反序列化才能理解。</li>
<li><strong>需要代码生成</strong>：每次修改 <code>.proto</code> 文件后都需要重新编译并生成代码，这对于脚本语言或需要高度动态 Schema 的场景可能不够灵活。</li>
<li><strong>缺乏自描述性</strong>：Protobuf 编码的数据本身不包含 Schema 信息（不像 Avro Data File），读取方必须拥有相同的 <code>.proto</code> 定义才能正确解析数据。</li>
<li><strong>学习曲线</strong>：对于不熟悉 IDL 和代码生成流程的开发者来说，可能需要一定的学习时间。</li>
<li><strong>无内置联合类型&#x2F;Any 值</strong>：虽然 <code>oneof</code> 可以模拟联合类型，但没有 Avro 那样灵活的 <code>union</code> 类型或 <code>Any</code> 类型（尽管 Protobuf 提供了 <code>google.protobuf.Any</code> 类型的特殊消息来解决这个问题，但使用起来比原生 <code>union</code> 更复杂）。</li>
</ul>
<h2 id="四、Protobuf-与其他数据格式的比较"><a href="#四、Protobuf-与其他数据格式的比较" class="headerlink" title="四、Protobuf 与其他数据格式的比较"></a>四、Protobuf 与其他数据格式的比较</h2><table>
<thead>
<tr>
<th align="left">特性 &#x2F; 格式</th>
<th align="left">Protocol Buffers</th>
<th align="left">Apache Avro</th>
<th align="left">JSON</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Schema</strong></td>
<td align="left"><strong>强制要求</strong>，自定义 IDL (<code>.proto</code>) 定义，需代码生成。</td>
<td align="left"><strong>强制要求</strong>，JSON 定义，可嵌入数据或注册表管理。</td>
<td align="left"><strong>可选&#x2F;无</strong>，通常依靠约定。</td>
</tr>
<tr>
<td align="left"><strong>数据格式</strong></td>
<td align="left"><strong>紧凑二进制</strong>。</td>
<td align="left"><strong>紧凑二进制</strong>，行式存储。</td>
<td align="left"><strong>文本 (UTF-8)</strong>，人类可读。</td>
</tr>
<tr>
<td align="left"><strong>Schema 演进</strong></td>
<td align="left"><strong>良好</strong> (基于字段 ID，兼容性强)。</td>
<td align="left"><strong>强大</strong> (读写 Schema 兼容性处理，支持 Union)。</td>
<td align="left"><strong>灵活但无内置支持</strong>，需手动处理兼容性。</td>
</tr>
<tr>
<td align="left"><strong>代码生成</strong></td>
<td align="left"><strong>强制</strong>。</td>
<td align="left"><strong>可选</strong> (动态解析，脚本语言无需)。</td>
<td align="left"><strong>无</strong>。</td>
</tr>
<tr>
<td align="left"><strong>RPC 支持</strong></td>
<td align="left"><strong>内置 (gRPC)</strong>。</td>
<td align="left"><strong>内置</strong>。</td>
<td align="left"><strong>无</strong> (通常与 HTTP&#x2F;REST 结合)。</td>
</tr>
<tr>
<td align="left"><strong>易读性</strong></td>
<td align="left">差 (二进制)。</td>
<td align="left">差 (二进制)。</td>
<td align="left"><strong>高</strong> (文本)。</td>
</tr>
<tr>
<td align="left"><strong>大小&#x2F;性能</strong></td>
<td align="left"><strong>优异</strong>。</td>
<td align="left"><strong>优异</strong>，可能略小于 Protobuf。</td>
<td align="left">差。</td>
</tr>
<tr>
<td align="left"><strong>自描述性</strong></td>
<td align="left">差 (数据不包含 Schema)。</td>
<td align="left"><strong>高</strong> (Avro Data File 包含 Schema)。</td>
<td align="left">差 (文本不包含 Schema 结构)。</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">微服务间通信 (gRPC)、数据存储、网络协议。</td>
<td align="left">大数据存储、流处理、Kafka 消息、数据湖。</td>
<td align="left">Web API、配置文件、浏览器与服务器数据交换。</td>
</tr>
</tbody></table>
<h2 id="五、Protobuf-工作原理-Workflow"><a href="#五、Protobuf-工作原理-Workflow" class="headerlink" title="五、Protobuf 工作原理 (Workflow)"></a>五、Protobuf 工作原理 (Workflow)</h2><p>Protobuf 的工作流程通常包含以下几个步骤：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    %% --- 开发阶段 ---
    subgraph DevTime [&quot;1. Development Time&quot;]
        direction TB
        ProtoFile[&quot;📄 &lt;b&gt;Definition&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;Write .proto file&quot;] 
        Protoc[[&quot;⚙️ &lt;b&gt;Protoc Compiler&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;Generate Code&quot;]]
        GenCode[&quot;📦 &lt;b&gt;Generated Classes&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(Java, Go, Python, etc.)&quot;]

        ProtoFile --&gt; Protoc
        Protoc --&gt; GenCode
    end

    %% --- 运行阶段：发送方 ---
    subgraph Sender [&quot;2. Runtime: Sender&quot;]
        direction TB
        AppA[&quot;💻 Application A&quot;]
        ObjA[&quot;Object (Data)&quot;]
        Serialize[&quot;&lt;b&gt;Serialize&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(toBinary)&quot;]

        AppA --&gt; ObjA
        ObjA --&gt; Serialize
    end

    %% --- 传输媒介 ---
    subgraph Transport [&quot;Binary Stream (传输层)&quot;]
        direction LR
        Wire{&quot;01010110... &lt;br&#x2F;&gt; (Protobuf Binary Payload)&quot;}
    end

    %% --- 运行阶段：接收方 ---
    subgraph Receiver [&quot;3. Runtime: Receiver&quot;]
        direction TB
        Deserialize[&quot;&lt;b&gt;Deserialize&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(parseFrom)&quot;]
        ObjB[&quot;Reconstructed Object&quot;]
        AppB[&quot;💻 Application B&quot;]

        Deserialize --&gt; ObjB
        ObjB --&gt; AppB
    end

    %% --- 逻辑连接 ---
    GenCode -.-&gt;|Import| AppA
    GenCode -.-&gt;|Import| AppB
    
    Serialize &#x3D;&#x3D;&gt; Wire
    Wire &#x3D;&#x3D;&gt; Deserialize

  </pre></div>

<ol>
<li><strong>定义 <code>.proto</code> 文件</strong>：首先，开发者编写 <code>.proto</code> 文件，使用 Protobuf 的 IDL 来定义消息 (<code>message</code>) 的结构、字段和类型。</li>
<li><strong>编译 <code>.proto</code> 文件</strong>：使用 <code>protoc</code> 编译器将 <code>.proto</code> 文件编译成目标编程语言（如 Python, Java, Go）的源代码。这些生成的代码包含了对应消息类型的类或结构体，以及用于设置字段、序列化和反序列化数据的方法。</li>
<li><strong>应用程序中使用生成的代码</strong>：在应用程序中，开发者可以使用生成的代码来创建消息实例，设置其字段值。</li>
<li><strong>序列化数据</strong>：调用消息实例的序列化方法，将其转换为紧凑的二进制字节流。</li>
<li><strong>传输或存储</strong>：将序列化后的二进制数据通过网络传输给其他服务，或存储到文件&#x2F;数据库中。</li>
<li><strong>反序列化数据</strong>：接收方应用程序获取到二进制数据后，使用其对应语言中生成的代码来调用反序列化方法，将二进制数据解码并重建为消息实例（数据对象）。</li>
<li><strong>处理数据</strong>：应用程序可以像处理普通对象一样访问消息实例的字段，进行业务逻辑处理。</li>
</ol>
<h2 id="六、代码示例-Python"><a href="#六、代码示例-Python" class="headerlink" title="六、代码示例 (Python)"></a>六、代码示例 (Python)</h2><p>这里我们以 Python 为例，演示如何使用 Protobuf。</p>
<h3 id="6-1-定义-Protobuf-Schema-person-proto"><a href="#6-1-定义-Protobuf-Schema-person-proto" class="headerlink" title="6.1 定义 Protobuf Schema (person.proto)"></a>6.1 定义 Protobuf Schema (<code>person.proto</code>)</h3><p>创建一个名为 <code>person.proto</code> 的文件：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>; <span class="comment">// Unique ID for the person</span></span><br><span class="line">  <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="type">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">AddressBook</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-编译-proto-文件"><a href="#6-2-编译-proto-文件" class="headerlink" title="6.2 编译 .proto 文件"></a>6.2 编译 <code>.proto</code> 文件</h3><p>首先，确保你已经安装了 Protobuf 编译器 <code>protoc</code>。安装方法可以参考 Protobuf 官方文档 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://grpc.io/docs/protoc-installation/"><sup>1</sup></a>。</p>
<p>然后，在 <code>person.proto</code> 文件所在的目录执行以下命令，为 Python 生成代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. person.proto</span><br></pre></td></tr></table></figure>

<p>这会生成一个名为 <code>person_pb2.py</code> 的文件。这个文件中包含了 Python 版本的 <code>Person</code> 和 <code>AddressBook</code> 消息类。</p>
<h3 id="6-3-Python-示例代码-main-py"><a href="#6-3-Python-示例代码-main-py" class="headerlink" title="6.3 Python 示例代码 (main.py)"></a>6.3 Python 示例代码 (<code>main.py</code>)</h3><p>现在，我们可以使用生成的 <code>person_pb2.py</code> 文件来序列化和反序列化数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> person_pb2 <span class="comment"># 导入生成的 Protocol Buffers 模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建并填充 Person 消息</span></span><br><span class="line">person = person_pb2.Person()</span><br><span class="line">person.name = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">person.<span class="built_in">id</span> = <span class="number">1234</span></span><br><span class="line">person.email = <span class="string">&quot;john.doe@example.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加电话号码</span></span><br><span class="line">phone1 = person.phones.add()</span><br><span class="line">phone1.number = <span class="string">&quot;555-1234&quot;</span></span><br><span class="line">phone1.<span class="built_in">type</span> = person_pb2.Person.PhoneType.MOBILE</span><br><span class="line"></span><br><span class="line">phone2 = person.phones.add()</span><br><span class="line">phone2.number = <span class="string">&quot;555-5678&quot;</span></span><br><span class="line">phone2.<span class="built_in">type</span> = person_pb2.Person.PhoneType.HOME</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 原始 Person 消息 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Name: <span class="subst">&#123;person.name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ID: <span class="subst">&#123;person.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Email: <span class="subst">&#123;person.email&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> phone <span class="keyword">in</span> person.phones:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Phone: <span class="subst">&#123;phone.number&#125;</span> (<span class="subst">&#123;person_pb2.Person.PhoneType.Name(phone.<span class="built_in">type</span>)&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 序列化消息到字节串</span></span><br><span class="line"><span class="comment"># 将消息序列化为二进制格式</span></span><br><span class="line">serialized_data = person.SerializeToString()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n--- 序列化后的二进制数据 (<span class="subst">&#123;<span class="built_in">len</span>(serialized_data)&#125;</span> bytes) ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(serialized_data) <span class="comment"># 输出的是字节串，非人类可读</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 反序列化字节串到新的 Person 消息对象</span></span><br><span class="line">new_person = person_pb2.Person()</span><br><span class="line">new_person.ParseFromString(serialized_data) <span class="comment"># 从二进制数据解析</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- 反序列化后的 New Person 消息 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Name: <span class="subst">&#123;new_person.name&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;ID: <span class="subst">&#123;new_person.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Email: <span class="subst">&#123;new_person.email&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> phone <span class="keyword">in</span> new_person.phones:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Phone: <span class="subst">&#123;phone.number&#125;</span> (<span class="subst">&#123;person_pb2.Person.PhoneType.Name(phone.<span class="built_in">type</span>)&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 演示 AddressBook 消息以及文件存取</span></span><br><span class="line">address_book = person_pb2.AddressBook()</span><br><span class="line">address_book.people.append(person) <span class="comment"># 将之前创建的 person 添加到 AddressBook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个 Person</span></span><br><span class="line">person2 = person_pb2.Person()</span><br><span class="line">person2.name = <span class="string">&quot;Jane Smith&quot;</span></span><br><span class="line">person2.<span class="built_in">id</span> = <span class="number">5678</span></span><br><span class="line">person2.email = <span class="string">&quot;jane.smith@example.com&quot;</span></span><br><span class="line">phone3 = person2.phones.add()</span><br><span class="line">phone3.number = <span class="string">&quot;555-4321&quot;</span></span><br><span class="line">phone3.<span class="built_in">type</span> = person_pb2.Person.PhoneType.WORK</span><br><span class="line">address_book.people.append(person2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化 AddressBook 并保存到文件</span></span><br><span class="line">file_name = <span class="string">&quot;addressbook.dat&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(address_book.SerializeToString())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nAddressBook 已序列化并保存到 <span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件反序列化 AddressBook</span></span><br><span class="line">new_address_book = person_pb2.AddressBook()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    new_address_book.ParseFromString(f.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n--- 从文件反序列化后的 AddressBook ---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> new_address_book.people:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Name: <span class="subst">&#123;p.name&#125;</span>, ID: <span class="subst">&#123;p.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> phone <span class="keyword">in</span> p.phones:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;    Phone: <span class="subst">&#123;phone.number&#125;</span> (<span class="subst">&#123;person_pb2.Person.PhoneType.Name(phone.<span class="built_in">type</span>)&#125;</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>运行步骤：</strong></p>
<ol>
<li>保存 <code>person.proto</code> 文件。</li>
<li>执行 <code>protoc --python_out=. person.proto</code> 生成 <code>person_pb2.py</code>。</li>
<li>保存 <code>main.py</code> 文件。</li>
<li>执行 <code>python main.py</code>。</li>
</ol>
<p>你将看到 Protobuf 消息的创建、序列化、反序列化以及文件存取的详细输出。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Protocol Buffers 提供了一种高效、可靠且维护性强的数据序列化解决方案。其强类型定义、紧凑的二进制格式和强大的 Schema 演进能力，使其成为构建高性能、分布式系统和跨语言通信的理想选择。尽管它牺牲了部分人类可读性和动态性，但通过代码生成带来的开发效率和运行时性能的提升，以及与 gRPC 的深度集成，使其在当今的软件开发领域，尤其是在微服务和大数据后端系统中占据着举足轻重的地位。 理解并掌握 Protobuf 是现代软件工程师必备的技能之一。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/a90dd53e3ba4/">https://blog.tbf1211.xx.kg/a90dd53e3ba4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/0d177e0002e6/" title="程序错误处理详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">程序错误处理详解</div></div><div class="info-2"><div class="info-item-1"> 在软件开发中，程序错误是不可避免的。无论是用户输入错误、系统资源耗尽、网络连接中断，还是代码本身的逻辑缺陷，都可能导致程序无法按预期运行。错误处理 (Error Handling) 是构建健壮、可靠和高质量软件的关键环节，它定义了程序在遇到问题时如何响应、如何从错误中恢复，或如何优雅地终止。一个设计良好的错误处理机制不仅能提高程序的稳定性，还能改善用户体验，并有助于故障诊断。  核心思想：预见并管理程序执行过程中可能出现的异常情况，以确保系统在面对挑战时能够保持稳定性、可靠性，并提供清晰的反馈。    一、为什么需要错误处理？软件系统在运行过程中会遇到各种不可预测的情况，这些情况可能导致程序偏离其预期行为。例如：  外部因素：文件读写失败（文件不存在、权限不足）、网络连接中断、数据库服务不可用、第三方API返回错误。 用户输入：输入格式不正确、值超出合法范围。 资源限制：内存不足、磁盘空间不足。 程序逻辑错误：空指针引用、数组越界、除以零等。  如果不进行适当的错误处理，这些问题可能导致程序崩溃、数据损坏、安全漏洞，甚至影响整个系统的稳定性。因此，错误处理是构建可靠、可维护和用...</div></div></div></a><a class="pagination-related" href="/28d59ad3e642/" title="Apache Avro 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Apache Avro 详解</div></div><div class="info-2"><div class="info-item-1"> Apache Avro 是一个数据序列化系统和远程过程调用 (RPC) 框架，起源于 Apache Hadoop 项目。它的核心目标是提供一个高效、紧凑、跨语言的数据交换和持久化存储解决方案，尤其适用于大数据环境和需要强大Schema 演进 (Schema Evolution) 支持的场景。Avro 通过 JSON 定义数据结构（Schema），但实际数据以紧凑的二进制格式存储，兼顾了可读性与传输效率。  核心思想：以 JSON 定义 Schema (模式) 实现跨语言的数据结构描述，以紧凑二进制格式序列化数据，并通过读写 Schema 差异自动处理数据兼容性，实现高效灵活的数据交换。    一、为什么需要 Avro？在分布式系统和大数据领域，数据交换和存储是核心挑战。传统的数据格式如 JSON 或 XML 虽然具有良好的可读性，但在数据量巨大时，它们的文件体积和解析效率往往成为瓶颈。而其他二进制格式如 Protocol Buffers 或 Thrift 虽然效率高，但通常需要代码生成，且在 Schema 演进和动态语言支持方面存在一些局限性。 Avro 的出现旨在解决这些问题...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/28d59ad3e642/" title="Apache Avro 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-10</div><div class="info-item-2">Apache Avro 详解</div></div><div class="info-2"><div class="info-item-1"> Apache Avro 是一个数据序列化系统和远程过程调用 (RPC) 框架，起源于 Apache Hadoop 项目。它的核心目标是提供一个高效、紧凑、跨语言的数据交换和持久化存储解决方案，尤其适用于大数据环境和需要强大Schema 演进 (Schema Evolution) 支持的场景。Avro 通过 JSON 定义数据结构（Schema），但实际数据以紧凑的二进制格式存储，兼顾了可读性与传输效率。  核心思想：以 JSON 定义 Schema (模式) 实现跨语言的数据结构描述，以紧凑二进制格式序列化数据，并通过读写 Schema 差异自动处理数据兼容性，实现高效灵活的数据交换。    一、为什么需要 Avro？在分布式系统和大数据领域，数据交换和存储是核心挑战。传统的数据格式如 JSON 或 XML 虽然具有良好的可读性，但在数据量巨大时，它们的文件体积和解析效率往往成为瓶颈。而其他二进制格式如 Protocol Buffers 或 Thrift 虽然效率高，但通常需要代码生成，且在 Schema 演进和动态语言支持方面存在一些局限性。 Avro 的出现旨在解决这些问题...</div></div></div></a><a class="pagination-related" href="/fa3d796f3333/" title="MessagePack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-09</div><div class="info-item-2">MessagePack 详解</div></div><div class="info-2"><div class="info-item-1"> MessagePack 是一个高效的二进制序列化格式，它允许你在多种语言之间交换数据，就像 JSON 一样。但与 JSON 不同的是，MessagePack 以更紧凑的二进制形式表示数据，这通常使其具有更小的消息大小和更快的编码&#x2F;解码速度。它被设计为一个“像 JSON 但更快更小”的替代品，特别适用于网络协议、数据存储以及低功耗设备等对性能和带宽敏感的场景。  核心思想：将结构化数据（如对象、数组、基本类型）编码成紧凑的二进制流，以实现高效的数据传输和存储。   一、什么是 MessagePack？MessagePack 是一种基于二进制的数据交换格式，其设计目标是高效、紧凑和跨语言兼容。它通过一种优化的二进制表示来序列化各种数据类型，包括整数、浮点数、字符串、二进制数据、数组和映射。其官方网站将其描述为“一个整洁、紧凑的二进制序列化格式”。 与文本格式（如 JSON）相比，MessagePack 的主要优势在于：  更小的消息尺寸：通过减少冗余信息并直接使用二进制表示数据类型，MessagePack 生成的数据通常比同等 JSON 数据小。 更快的处理速度：由于节省...</div></div></div></a><a class="pagination-related" href="/f7642a181610/" title="CDN (内容分发网络) 服务详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">CDN (内容分发网络) 服务详解</div></div><div class="info-2"><div class="info-item-1"> CDN (Content Delivery Network)，即内容分发网络，是一种构建在现有网络基础之上的智能虚拟网络。它通过将站点内容发布到离用户最近的全球边缘节点，使用户在请求内容时，能够从距离自己最近的服务器获取数据，从而显著加速内容传输、减轻源站负载、提高用户体验和保障服务可用性。  核心思想：将内容缓存到离用户近的地方，让用户就近获取，缩短物理距离，从而缩短加载时间。   一、为什么需要 CDN？在没有 CDN 的情况下，用户访问网站的所有请求都会直接发送到源服务器。这存在几个问题：  访问速度慢：当用户与源服务器之间地理距离较远时，数据传输路径长，网络延迟高，导致页面加载缓慢，尤其是对于图片、视频等大文件。 网络拥堵：跨国或跨洲际网络传输容易受到骨干网带宽限制和拥堵的影响。 源站负载高：所有用户的请求都直接冲击源服务器，在高并发场景下可能导致源服务器过载、响应变慢甚至崩溃。 单点故障风险：源服务器一旦出现故障或遭受攻击，整个网站将无法访问。 安全性弱：源站直接暴露在公网，容易成为 DDoS 攻击的目标。  CDN 旨在解决上述问题，提供以下核心价值：  加速访问：...</div></div></div></a><a class="pagination-related" href="/9b793354c088/" title="nftables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-28</div><div class="info-item-2">nftables 详解</div></div><div class="info-2"><div class="info-item-1"> nftables 是 Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在逐步取代传统的 iptables (以及 ip6tables, arptables, ebtables) 工具集，提供一个统一的、高效的、更易于管理和扩展的防火墙解决方案。nftables 引入了一套全新的语法和设计理念，旨在解决 iptables 长期存在的一些问题，例如命令复杂性、重复代码以及 IPv4 和 IPv6 规则管理的独立性等。  核心思想：基于表达式的统一规则集，支持原子性更新，并针对 IPv4&#x2F;IPv6&#x2F;桥接等协议提供统一管理。 它的设计哲学是从指令式规则集转向声明式通用虚拟机指令，使得规则处理更高效、更灵活。   一、为什么需要 nftables？iptables 的局限性虽然 iptables 强大且稳定，但它在设计和使用上存在一些固有的局限性，促使 Netfilter 社区开发 nftables：  语法复杂且碎片化：  iptables (用于 IPv4)、ip6tables (用于 IPv6)、arptables (用于 ARP)、ebtab...</div></div></div></a><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-03</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a><a class="pagination-related" href="/56d360e5bda1/" title="SNAT 与 DNAT 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">SNAT 与 DNAT 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：源网络地址转换 (SNAT - Source Network Address Translation) 和 目的网络地址转换 (DNAT - Destination Network Address Translation)。理解这两种机制对于网络设计、故障排查和安全性至关重要。  核心思想：  SNAT：解决“内部网络中主机如何安全地、共享地访问外部网络资源”的问题，修改出站数据包的源地址。 DNAT：解决“外部网络中主机如何安全地访问内部提供的服务”的问题，修改入站数据包的目的地址。     一、网络地址转换 (NAT) 概述NAT 技术最初是为了缓解 IPv4 地址枯竭问题而设计，它允许一个内部私有 IP 网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信。除了地址共享，NAT 也为内部网络提供了一层基本的安全隔...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">562</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">86</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Protocol-Buffers%EF%BC%9F"><span class="toc-text">一、为什么需要 Protocol Buffers？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Protocol-Buffers-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Protocol Buffers 的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Interface-Definition-Language-IDL-proto-%E6%96%87%E4%BB%B6"><span class="toc-text">2.1 Interface Definition Language (IDL) - .proto 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Message-Types-%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.2 Message Types (消息类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AD%97%E6%AE%B5%E8%A7%84%E5%88%99%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.3 字段规则与数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%AD%97%E6%AE%B5%E8%A7%84%E5%88%99-Field-Rules"><span class="toc-text">2.3.1 字段规则 (Field Rules)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Scalar-Types"><span class="toc-text">2.3.2 数据类型 (Scalar Types)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AD%97%E6%AE%B5%E7%BC%96%E5%8F%B7-Field-Numbers"><span class="toc-text">2.4 字段编号 (Field Numbers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">2.5 序列化和反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90-Code-Generation"><span class="toc-text">2.6 代码生成 (Code Generation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Schema-%E6%BC%94%E8%BF%9B-Schema-Evolution"><span class="toc-text">2.7 Schema 演进 (Schema Evolution)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Protobuf-%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-text">三、Protobuf 的优势与劣势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BC%98%E5%8A%BF"><span class="toc-text">3.1 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8A%A3%E5%8A%BF"><span class="toc-text">3.2 劣势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Protobuf-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">四、Protobuf 与其他数据格式的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Protobuf-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-Workflow"><span class="toc-text">五、Protobuf 工作原理 (Workflow)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Python"><span class="toc-text">六、代码示例 (Python)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%AE%9A%E4%B9%89-Protobuf-Schema-person-proto"><span class="toc-text">6.1 定义 Protobuf Schema (person.proto)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%96%E8%AF%91-proto-%E6%96%87%E4%BB%B6"><span class="toc-text">6.2 编译 .proto 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Python-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-main-py"><span class="toc-text">6.3 Python 示例代码 (main.py)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0d177e0002e6/" title="程序错误处理详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序错误处理详解"/></a><div class="content"><a class="title" href="/0d177e0002e6/" title="程序错误处理详解">程序错误处理详解</a><time datetime="2026-02-13T22:24:00.000Z" title="发表于 2026-02-14 06:24:00">2026-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/a90dd53e3ba4/" title="Protocol Buffers 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Protocol Buffers 详解"/></a><div class="content"><a class="title" href="/a90dd53e3ba4/" title="Protocol Buffers 详解">Protocol Buffers 详解</a><time datetime="2026-02-11T22:24:00.000Z" title="发表于 2026-02-12 06:24:00">2026-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/28d59ad3e642/" title="Apache Avro 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Apache Avro 详解"/></a><div class="content"><a class="title" href="/28d59ad3e642/" title="Apache Avro 详解">Apache Avro 详解</a><time datetime="2026-02-09T22:24:00.000Z" title="发表于 2026-02-10 06:24:00">2026-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e3b0c5d197a/" title="Web Components 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Components 详解"/></a><div class="content"><a class="title" href="/4e3b0c5d197a/" title="Web Components 详解">Web Components 详解</a><time datetime="2026-02-07T22:24:00.000Z" title="发表于 2026-02-08 06:24:00">2026-02-08</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-17.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>