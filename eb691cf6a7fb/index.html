<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PPPoE (Point-to-Point Protocol over Ethernet) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PPPoE (Point-to-Point Protocol over Ethernet)，中文常译为“以太网上的点对点协议”，是一种将传统的点对点协议 (PPP) 封装在以太网数据帧中的网络协议。它主要用于在以太网局域网中实现点对点连接，最常见的应用场景是通过 DSL (数字用户线路) 或光纤等宽带接入技术向最终用户提供上网服务。PPPoE 允许 ISP (互联网服务提供商) 对用户进行身份验">
<meta property="og:type" content="article">
<meta property="og:title" content="PPPoE (Point-to-Point Protocol over Ethernet) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/eb691cf6a7fb/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="PPPoE (Point-to-Point Protocol over Ethernet)，中文常译为“以太网上的点对点协议”，是一种将传统的点对点协议 (PPP) 封装在以太网数据帧中的网络协议。它主要用于在以太网局域网中实现点对点连接，最常见的应用场景是通过 DSL (数字用户线路) 或光纤等宽带接入技术向最终用户提供上网服务。PPPoE 允许 ISP (互联网服务提供商) 对用户进行身份验">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg">
<meta property="article:published_time" content="2024-02-06T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-30T03:20:58.341Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PPPoE (Point-to-Point Protocol over Ethernet) 详解",
  "url": "https://blog.tbf1211.xx.kg/eb691cf6a7fb/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg",
  "datePublished": "2024-02-06T22:24:00.000Z",
  "dateModified": "2026-01-30T03:20:58.341Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/eb691cf6a7fb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PPPoE (Point-to-Point Protocol over Ethernet) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-25.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">PPPoE (Point-to-Point Protocol over Ethernet) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PPPoE (Point-to-Point Protocol over Ethernet) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-02-06T22:24:00.000Z" title="发表于 2024-02-07 06:24:00">2024-02-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>PPPoE (Point-to-Point Protocol over Ethernet)</strong>，中文常译为“<strong>以太网上的点对点协议</strong>”，是一种将传统的点对点协议 (PPP) 封装在以太网数据帧中的网络协议。它主要用于在以太网局域网中实现点对点连接，最常见的应用场景是<strong>通过 DSL (数字用户线路) 或光纤等宽带接入技术向最终用户提供上网服务</strong>。PPPoE 允许 ISP (互联网服务提供商) 对用户进行身份验证 (Authentication)、会话管理以及基于会话的计费，同时为用户分配 IP 地址和其他网络参数。</p>
</blockquote>
<div class="note info flat"><p>核心思想：在以太网链路的基础上，模拟 PPP 连接的拨号体验，为每个用户提供独立的虚拟“隧道”，实现用户身份认证、IP地址分配和会话管理，以便进行计费和带宽控制。</p>
</div>
<hr>
<h2 id="一、什么是-PPPoE？"><a href="#一、什么是-PPPoE？" class="headerlink" title="一、什么是 PPPoE？"></a>一、什么是 PPPoE？</h2><p>在 ADSL (非对称数字用户线路) 和早期的光纤宽带时代，ISP 需要一种机制来管理大量拨号上网的用户。传统的拨号上网（通过电话线 Modem 连接）使用的是 PPP 协议，它能够提供用户认证、IP 地址分配和加密等功能。然而，随着局域网 (LAN) 和以太网的普及，人们希望在以太网环境下也能获得类似 PPP 的功能。</p>
<p>PPPoE 正是为解决这一问题而设计的。它将 PPP 帧封装在以太网帧中，使得在以太网上建立虚拟的点对点连接成为可能。通过 PPPoE，每个用户都可以像拨号上网一样，通过输入用户名和密码连接到 ISP 网络，获得独立的 IP 地址和互联网访问权限。</p>
<h2 id="二、为什么需要-PPPoE？"><a href="#二、为什么需要-PPPoE？" class="headerlink" title="二、为什么需要 PPPoE？"></a>二、为什么需要 PPPoE？</h2><p>PPPoE 协议主要解决了以下几个核心问题：</p>
<ol>
<li><strong>用户认证 (Authentication)</strong>：ISP 可以通过 PPPoE 要求用户提供有效的用户名和密码（通常使用 PAP 或 CHAP 协议），确保只有授权用户才能接入网络。这对于运营商提供服务、管理用户是基础。</li>
<li><strong>IP 地址分配 (IP Address Assignment)</strong>：ISP 不必为每个潜在用户预留固定 IP 地址。当用户拨号成功后，PPPoE 服务器会动态地为用户分配一个公共 IP 地址（或私有 IP 地址，配合 NAT）。用完即还，提高了 IP 地址的利用率。</li>
<li><strong>会话管理 (Session Management)</strong>：每个 PPPoE 连接都是一个独立的会话。ISP 可以根据单个会话来管理带宽、监控流量、设置QoS (服务质量) 和防火墙策略。</li>
<li><strong>计费 (Accounting)</strong>：由于每个用户都有独立的会话，ISP 可以精确地追踪每个用户的在线时长或流量消耗，从而实现按时间或按流量计费。</li>
<li><strong>安全性</strong>：虽然 PPPoE 本身不提供强大的加密，但其基于 PPP 的认证机制提供了基本的用户识别。</li>
<li><strong>易于部署</strong>：利用了现有以太网基础设施，用户只需一个支持 PPPoE 的客户端软件（操作系统内置或路由器内置）即可连接。</li>
</ol>
<h2 id="三、PPPoE-的工作原理"><a href="#三、PPPoE-的工作原理" class="headerlink" title="三、PPPoE 的工作原理"></a>三、PPPoE 的工作原理</h2><p>PPPoE 会话的建立通常分为两个主要阶段：<strong>发现阶段 (Discovery Stage)</strong> 和 <strong>会话阶段 (Session Stage)</strong>。</p>
<h3 id="3-1-发现阶段-Discovery-Stage"><a href="#3-1-发现阶段-Discovery-Stage" class="headerlink" title="3.1 发现阶段 (Discovery Stage)"></a>3.1 发现阶段 (Discovery Stage)</h3><p>在发现阶段，PPPoE 客户端（用户设备，如家庭路由器或 PC）和 PPPoE 服务器（ISP 端设备，如接入服务器 BNG&#x2F;BRAS）相互发现对方，并建立一个唯一的会话 ID。这个阶段使用标准的以太网广播帧进行通信。</p>
<ol>
<li><p><strong>PADI (PPPoE Active Discovery Initiation)</strong>：</p>
<ul>
<li>客户端向以太网广播一个 PADI 帧，寻找可用的 PPPoE 服务器。</li>
<li>PADI 帧包含客户端的 MAC 地址和它想要的服务名称（可选）。</li>
<li>目的 MAC 地址是广播地址 (<code>FF:FF:FF:FF:FF:FF</code>)。</li>
<li>目的 IP 地址未使用（因为客户端还没有 IP 地址）。</li>
</ul>
</li>
<li><p><strong>PADO (PPPoE Active Discovery Offer)</strong>：</p>
<ul>
<li>所有接收到 PADI 帧的 PPPoE 服务器（例如 BNG&#x2F;BRAS - Broadband Network Gateway&#x2F;Broadband Remote Access Server）都会响应一个 PADO 帧。</li>
<li>PADO 帧包含服务器的 MAC 地址、服务名称和唯一的名称标签（表示该服务器能够提供什么服务）。</li>
<li>目的 MAC 地址是客户端的 MAC 地址（单播响应）。</li>
</ul>
</li>
<li><p><strong>PADR (PPPoE Active Discovery Request)</strong>：</p>
<ul>
<li>客户端从多个 PADO 帧中选择一个服务器（通常是第一个响应或服务最优的），然后发送一个 PADR 帧给选择的服务器。</li>
<li>PADR 帧包含客户端的 MAC 地址、选择的服务名称和它要启动的会话 ID（通常为零）。</li>
<li>目的 MAC 地址是选择的服务器的 MAC 地址（单播）。</li>
</ul>
</li>
<li><p><strong>PADS (PPPoE Active Discovery Session-confirmation)</strong>：</p>
<ul>
<li>被选择的服务器收到 PADR 帧后，会生成一个唯一的会话 ID，并发送一个 PADS 帧响应给客户端。</li>
<li>PADS 帧包含服务器的 MAC 地址、客户端的 MAC 地址、选择的服务名称和分配给本次会话的唯一<strong>会话 ID (Session ID)</strong>。</li>
<li>至此，发现阶段结束，一个点对点的 PPPoE 会话连接正式建立（逻辑链路）。</li>
</ul>
</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as PPPoE 客户端
    participant Server as PPPoE 服务器 (ISP BRAS)

    Client-&gt;&gt;Server: 1. PADI (Discovery Initiation) - 广播帧
    Server-&gt;&gt;Client: 2. PADO (Discovery Offer) - 单播帧 (响应多个PADO，客户端选择一个)
    Client-&gt;&gt;Server: 3. PADR (Discovery Request) - 单播帧 (告知选择哪个服务器)
    Server-&gt;&gt;Client: 4. PADS (Discovery Session-confirmation) - 单播帧 (分配会话ID)
    Note over Client,Server: 发现阶段完成，会话ID建立
  </pre></div>

<h3 id="3-2-会话阶段-Session-Stage"><a href="#3-2-会话阶段-Session-Stage" class="headerlink" title="3.2 会话阶段 (Session Stage)"></a>3.2 会话阶段 (Session Stage)</h3><p>一旦会话 ID 建立，双方就可以开始使用标准的 PPP 协议进行通信。这个阶段所有的通信都是<strong>单播</strong>的。</p>
<ol>
<li><p><strong>LCP (Link Control Protocol - 链路控制协议)</strong>：</p>
<ul>
<li>客户端和服务器通过 LCP 协商链路参数，例如认证类型（PAP&#x2F;CHAP）、魔术数字、最大接收单元 (MRU) 等。</li>
<li>认证 (Authentication)：客户端提交用户名和密码给服务器。</li>
<li>服务器验证用户的凭据。</li>
</ul>
</li>
<li><p><strong>Authentication (认证)</strong>：</p>
<ul>
<li>客户端使用协商好的认证协议（如 PAP 或 CHAP）向服务器发送用户名和密码。</li>
<li><strong>PAP (Password Authentication Protocol)</strong>：明文传输密码，安全性低。</li>
<li><strong>CHAP (Challenge Handshake Authentication Protocol)</strong>：挑战-应答机制，不直接传输密码，安全性相对较高。</li>
</ul>
</li>
<li><p><strong>NCP (Network Control Protocol - 网络控制协议)</strong>：</p>
<ul>
<li>认证成功后，双方会进入 NCP 阶段，最常用的是 <strong>IPCP (IP Control Protocol)</strong>。</li>
<li>IPCP 协商和分配 IP 地址、DNS 服务器地址、默认网关和其他 IP 相关参数给客户端。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li>一旦 IP 地址等网络参数配置完毕，客户端就可以开始通过 PPPoE 会话发送和接收 IP 数据包，接入互联网。</li>
<li>每传输一个 IP 数据包，它都会被 PPP 封装，然后 PPP 帧再被 PPPoE 和以太网封装。</li>
</ul>
</li>
<li><p><strong>PADT (PPPoE Active Discovery Terminate)</strong>：</p>
<ul>
<li>当客户端或服务器希望终止会话时，会发送一个 PADT 帧。</li>
<li>PADT 帧会带上要终止的会话 ID，通知对方会话已结束。</li>
<li>会话结束后，分配给客户端的 IP 地址会被释放。</li>
</ul>
</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as PPPoE 客户端
    participant Server as PPPoE 服务器 (ISP BRAS)

    Client-&gt;&gt;Server: LCP (协商链路参数)
    Server-&gt;&gt;Client: LCP ACK (确认参数)
    Client-&gt;&gt;Server: PAP&#x2F;CHAP (发送认证凭据)
    Server-&gt;&gt;Client: PAP&#x2F;CHAP 认证结果 (成功&#x2F;失败)
    alt 认证成功
        Client-&gt;&gt;Server: IPCP (协商IP地址、DNS等)
        Server-&gt;&gt;Client: IPCP ACK (分配IP地址、DNS等)
        Note over Client,Server: 会话阶段开始，可以传输数据 (PPPoE 封装)
        Client--&gt;&gt;Server: 数据包 (封装在 PPPoE&#x2F;PPP&#x2F;Ethernet)
        Server--&gt;&gt;Client: 数据包 (封装在 PPPoE&#x2F;PPP&#x2F;Ethernet)
    else 认证失败
        Server-&gt;&gt;Client: LCP Terminate (终止链路)
        Note over Client,Server: 连接失败
    end
    Client-&gt;&gt;Server: PADT (Terminate) &#x2F; 服务器超时
    Server--&gt;&gt;Client: PADT (Terminate ACK)
    Note over Client,Server: PPPoE 会话终止
  </pre></div>

<h2 id="四、PPPoE-数据帧结构"><a href="#四、PPPoE-数据帧结构" class="headerlink" title="四、PPPoE 数据帧结构"></a>四、PPPoE 数据帧结构</h2><p>PPPoE 帧是 PPP 帧封装在以太网帧中的结果。</p>
<h3 id="4-1-以太网帧头"><a href="#4-1-以太网帧头" class="headerlink" title="4.1 以太网帧头"></a>4.1 以太网帧头</h3><ul>
<li><strong>目的 MAC 地址 (6 字节)</strong>：在发现阶段可以是广播地址 (<code>FF:FF:FF:FF:FF:FF</code>)，在会话阶段是 PPPoE 服务器的 MAC 地址（或客户端 MAC）。</li>
<li><strong>源 MAC 地址 (6 字节)</strong>：发送方的 MAC 地址。</li>
<li><strong>EtherType (2 字节)</strong>：<ul>
<li><code>0x8863</code>：表示 PPPoE 发现阶段的帧。</li>
<li><code>0x8864</code>：表示 PPPoE 会话阶段的帧。</li>
</ul>
</li>
</ul>
<h3 id="4-2-PPPoE-头部"><a href="#4-2-PPPoE-头部" class="headerlink" title="4.2 PPPoE 头部"></a>4.2 PPPoE 头部</h3><p>紧跟在以太网帧头之后是 PPPoE 专有的头部：</p>
<ul>
<li><strong>版本 (Version - 4 bits)</strong>：通常为 1。</li>
<li><strong>类型 (Type - 4 bits)</strong>：通常为 1。</li>
<li><strong>Code (8 bits)</strong>：<ul>
<li>发现阶段：PADI (<code>0x09</code>), PADO (<code>0x07</code>), PADR (<code>0x19</code>), PADS (<code>0x65</code>), PADT (<code>0xA7</code>)</li>
<li>会话阶段：总是 <code>0x00</code></li>
</ul>
</li>
<li><strong>会话 ID (Session ID - 16 bits)</strong>：由 PADS 帧分配的唯一会话标识符，在会话阶段中所有通信都携带此 ID。</li>
<li><strong>长度 (Length - 16 bits)</strong>：表示 PPP Payload 的长度。</li>
</ul>
<h3 id="4-3-PPP-头部和-Payload"><a href="#4-3-PPP-头部和-Payload" class="headerlink" title="4.3 PPP 头部和 Payload"></a>4.3 PPP 头部和 Payload</h3><ul>
<li><strong>PPP 头部（通常 2 字节）</strong>：在会话阶段，PPPoE 头部后面是标准的 PPP 帧。PPP 帧通常以协议字段（如 <code>0xC021</code> for LCP, <code>0xC023</code> for PAP, <code>0xC223</code> for CHAP, <code>0x8021</code> for IPCP, <code>0x0021</code> for IP）开始。</li>
<li><strong>PPP Payload</strong>：这部分是真正的用户数据（如 IP 包），或者更高层协议（如 LCP、IPCP、认证数据）的数据。</li>
</ul>
<p>最终的封装结构看起来是这样的：<br><code>Ethernet Header (MAC, EtherType) | PPPoE Header (Version, Type, Code, Session ID, Length) | PPP Header (Protocol) | PPP Payload (IP Packet/LCP/CHAP etc.) | FCS</code></p>
<h2 id="五、PPPoE-的部署与应用"><a href="#五、PPPoE-的部署与应用" class="headerlink" title="五、PPPoE 的部署与应用"></a>五、PPPoE 的部署与应用</h2><h3 id="5-1-家庭宽带接入"><a href="#5-1-家庭宽带接入" class="headerlink" title="5.1 家庭宽带接入"></a>5.1 家庭宽带接入</h3><p>这是 PPPoE 最主要的应用场景。</p>
<ul>
<li><strong>用户设备</strong>：通常是家庭路由器（内置 PPPoE 客户端）或直接在电脑上进行 PPPoE 拨号。</li>
<li><strong>连接方式</strong>：用户路由器通过网线连接到光猫 (ONT&#x2F;ONU) 或 ADSL Modem，光猫&#x2F;Modem 将以太网信号转换成光信号&#x2F;ADSL 信号传输到 ISP 的局端设备。</li>
<li><strong>ISP 端</strong>：BRAN (Broadband Remote Access Server) 设备作为 PPPoE 服务器接收用户请求，进行认证、IP 分配和会话管理。</li>
</ul>
<h3 id="5-2-企业虚拟专网-VPN"><a href="#5-2-企业虚拟专网-VPN" class="headerlink" title="5.2 企业虚拟专网 (VPN)"></a>5.2 企业虚拟专网 (VPN)</h3><p>在某些企业环境中，PPPoE 也可能被用于在现有以太网 LAN 上建立虚拟的专用连接，实现更精细的用户管理和隔离，尽管更多时候企业会选择 IPsec VPN 或 MPLS。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>PPPoE 是连接了传统 PPP 和现代以太网的桥梁，它成功地将 PPP 协议的认证、授权和计费 (Authentication, Authorization, Accounting - AAA) 功能扩展到了以太网环境中。尤其是在 ADSL 和光纤宽带接入中，PPPoE 扮演着至关重要的角色，使得运营商能够高效地管理海量宽带用户。理解 PPPoE 的发现和会话阶段的工作原理，以及其帧结构，对于网络工程师和故障排除人员来说，都是掌握现代宽带接入技术的关键。尽管在一些高级企业网络或数据中心场景下，PPPoE 可能不如其他技术普遍，但其在“最后一公里”的宽带接入中，依然是不可或缺的核心协议。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/eb691cf6a7fb/">https://blog.tbf1211.xx.kg/eb691cf6a7fb/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-25.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/322d9ce55371/" title="DHCP (动态主机配置协议) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DHCP (动态主机配置协议) 详解</div></div><div class="info-2"><div class="info-item-1"> DHCP (Dynamic Host Configuration Protocol)，即动态主机配置协议，是一个应用层协议，它允许服务器动态地为客户端（例如计算机、智能手机、物联网设备等）分配 IP 地址和其他网络配置参数。DHCP 是目前最常用的网络配置方式，极大地简化了网络管理，避免了手动配置 IP 地址可能出现的冲突和错误。  核心思想：自动化分配 IP 地址和其他网络参数，简化网络管理，提高效率。   一、为什么需要 DHCP？在没有 DHCP 的情况下，每台连接到 TCP&#x2F;IP 网络的设备都需要手动配置以下信息：  IP 地址：设备在网络上的唯一标识。 子网掩码：用于区分 IP 地址的网络部分和主机部分。 默认网关：设备访问外部网络的路由器的 IP 地址。 DNS 服务器地址：用于将域名解析为 IP 地址的服务器。  手动配置的弊端显而易见：  复杂且耗时：对于大型网络，手动配置数百甚至数千台设备的网络参数是一项繁琐且容易出错的工作。 易出错：人为输入错误可能导致网络连接问题或 IP 地址冲突。 IP 地址冲突：如果不小心将同一个 IP 地址分配给多台设备，...</div></div></div></a><a class="pagination-related" href="/1165e3e15519/" title="边缘计算 (Edge Computing) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">边缘计算 (Edge Computing) 详解</div></div><div class="info-2"><div class="info-item-1"> 边缘计算 (Edge Computing) 是一种分布式计算范式，它将计算和数据存储能力从集中式的云数据中心下沉到网络的边缘，即数据源或数据源附近。其核心思想是在数据产生的地方进行数据处理、分析和存储，而不是将所有数据都传输到远程的云端进行处理。这种模式旨在解决云计算在延迟、带宽、隐私和可靠性方面面临的挑战，特别是在物联网 (IoT)、5G 和人工智能 (AI) 等新兴技术驱动下，变得越来越重要。  核心思想：将计算能力推向数据源头，在网络边缘就近处理数据，以降低延迟、节省带宽、增强隐私和提高可靠性。   一、为什么需要边缘计算？传统的云计算模型将数据发送到远程数据中心进行处理。随着物联网设备的爆炸式增长、5G 网络的高速发展以及AI应用对实时性的高要求，这种中心化的模式暴露出以下问题：  高延迟 (High Latency)：数据从边缘设备传输到云端，再从云端返回，需要较长时间。对于自动驾驶、工业自动化、远程医疗等实时性要求极高的应用，几毫秒的延迟都可能造成严重后果。 带宽限制与成本 (Bandwidth Constraints &amp; Cost)：物联网设备产生海量数据...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/17bcd938fa86/" title="NDP (Neighbor Discovery Protocol) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-29</div><div class="info-item-2">NDP (Neighbor Discovery Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> NDP (Neighbor Discovery Protocol)，即邻居发现协议，是 IPv6 (Internet Protocol version 6) 中的一个关键协议。它属于 ICMPv6 (Internet Control Message Protocol for IPv6) 的一部分，旨在替代 IPv4 中的 ARP (Address Resolution Protocol)、ICMP Router Discovery (路由器发现) 和 ICMP Redirect (重定向) 等功能，为 IPv6 主机和路由器提供在同一链路 (link) 上发现彼此、确定链路层地址、发现路由器、处理地址自动配置以及检测重复地址等服务。  核心思想：为 IPv6 提供无状态、多功能、更安全且效率更高的本地链路通信机制。它通过一系列 ICMPv6 消息，实现了 IPv4 中分散的多个协议功能，支持 IPv6 的核心特性如无状态地址自动配置 (SLAAC) 和高效的邻居管理。   一、为什么需要 NDP？(与 IPv4 协议的对比)IPv4 网络中的一些协议在 IPv6 环境下存在局限...</div></div></div></a><a class="pagination-related" href="/06b4f10e9d05/" title="RTSP (Real-Time Streaming Protocol) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-16</div><div class="info-item-2">RTSP (Real-Time Streaming Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> RTSP (Real-Time Streaming Protocol) 是一种应用层协议，旨在为流媒体服务器提供对实时媒体流的控制功能。它允许客户端远程控制流媒体服务器，例如启动、暂停、快进、倒带或停止媒体流，而无需下载整个文件。RTSP 协议本身不负责传输实际的媒体数据，它主要负责媒体流的会话建立、控制和断开。实际的媒体数据通常由 RTP (Real-time Transport Protocol) 和 RTCP (RTP Control Protocol) 协议进行传输。  核心思想：RTSP 就像一个“远程遥控器”，用于指挥流媒体服务器发送或停止媒体数据，而具体的数据传输则交给其他协议（通常是 RTP&#x2F;RTCP）来完成。   一、为什么需要 RTSP？在流媒体领域，用户需要对媒体播放进行灵活的控制，类似于操作本地播放器。传统的 HTTP 协议虽然可以用于文件下载，但其“请求-响应”模式并不适合实时流媒体的互动控制：  缺乏实时控制能力：HTTP 主要用于文件传输，不支持播放、暂停、快进、倒带等实时媒体控制操作。 不适合长时间连接：HTTP 通常是短连接，每次操作...</div></div></div></a><a class="pagination-related" href="/322d9ce55371/" title="DHCP (动态主机配置协议) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-08</div><div class="info-item-2">DHCP (动态主机配置协议) 详解</div></div><div class="info-2"><div class="info-item-1"> DHCP (Dynamic Host Configuration Protocol)，即动态主机配置协议，是一个应用层协议，它允许服务器动态地为客户端（例如计算机、智能手机、物联网设备等）分配 IP 地址和其他网络配置参数。DHCP 是目前最常用的网络配置方式，极大地简化了网络管理，避免了手动配置 IP 地址可能出现的冲突和错误。  核心思想：自动化分配 IP 地址和其他网络参数，简化网络管理，提高效率。   一、为什么需要 DHCP？在没有 DHCP 的情况下，每台连接到 TCP&#x2F;IP 网络的设备都需要手动配置以下信息：  IP 地址：设备在网络上的唯一标识。 子网掩码：用于区分 IP 地址的网络部分和主机部分。 默认网关：设备访问外部网络的路由器的 IP 地址。 DNS 服务器地址：用于将域名解析为 IP 地址的服务器。  手动配置的弊端显而易见：  复杂且耗时：对于大型网络，手动配置数百甚至数千台设备的网络参数是一项繁琐且容易出错的工作。 易出错：人为输入错误可能导致网络连接问题或 IP 地址冲突。 IP 地址冲突：如果不小心将同一个 IP 地址分配给多台设备，...</div></div></div></a><a class="pagination-related" href="/aeeb1d5d94e7/" title="WebDAV详解：基于HTTP的分布式文件管理协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-02</div><div class="info-item-2">WebDAV详解：基于HTTP的分布式文件管理协议</div></div><div class="info-2"><div class="info-item-1"> WebDAV (Web Distributed Authoring and Versioning) 是一种基于 HTTP 协议的扩展协议，它允许客户端直接通过 Web 远程地执行文件和文件夹的操作，包括创建、移动、复制、删除、读取以及管理文件属性和锁机制。简而言之，WebDAV 将 Web 服务器从一个简单的内容消费者转变为一个可供用户直接进行创作和协同工作的平台，将 Web 页面视为可编辑的文档集合。  核心思想：WebDAV 在不改变 HTTP 核心语义的前提下，增加了 HTTP 缺乏的文件锁定、属性管理、命名空间管理等功能，使其能够支持分布式文件系统的基本操作。它将传统的“请求-响应”模式扩展为“文档创作-协作”模式。   一、为什么需要 WebDAV？HTTP 的局限性HTTP (Hypertext Transfer Protocol) 在设计之初，主要是为了实现信息的单向传输，即客户端请求资源，服务器提供资源。它的主要方法 (GET, POST, PUT, DELETE, HEAD, OPTIONS) 专注于获取、提交和替换&#x2F;删除单个资源。 然而，对于 We...</div></div></div></a><a class="pagination-related" href="/6014745b242a/" title="ARP (Address Resolution Protocol) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-31</div><div class="info-item-2">ARP (Address Resolution Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> ARP (Address Resolution Protocol)，即地址解析协议，是一个在局域网 (LAN) 内使用的网络层协议，主要用于将IP 地址 (网络层地址)解析为MAC 地址 (数据链路层地址)。在 TCP&#x2F;IP 协议栈中，当一台主机知道目标主机的 IP 地址，但需要知道其在同一物理网络上的 MAC 地址才能进行数据帧的发送时，就会使用 ARP 协议。  核心思想：将逻辑地址 (IP) 映射到物理地址 (MAC)，使得 IP 数据包能够在数据链路层封装成帧并通过物理网络介质传输到正确的目标设备。   一、为什么需要 ARP？在理解 ARP 之前，我们需要明确 IP 地址和 MAC 地址在网络通信中的角色：  IP 地址 (Internet Protocol Address)：工作在 OSI 模型的第三层 (网络层)。它是一个逻辑地址，用于在不同网络之间识别和路由数据包。IP 地址是分层的，包含网络部分和主机部分，使得路由器能够根据网络部分将数据包转发到正确的网络。 MAC 地址 (Media Access Control Address)：工作在 OSI ...</div></div></div></a><a class="pagination-related" href="/0f6de86a0220/" title="STUN (Session Traversal Utilities for NAT) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-12</div><div class="info-item-2">STUN (Session Traversal Utilities for NAT) 详解</div></div><div class="info-2"><div class="info-item-1"> STUN (Session Traversal Utilities for NAT)，即 NAT 会话穿越工具，是一种网络协议，它允许位于NAT (Network Address Translation，网络地址转换) 设备之后的客户端发现其外部（公共）IP 地址和端口号，以及 NAT 设备的类型。STUN 的主要目的是协助建立对等连接 (P2P)，尤其是在 VoIP、视频会议和 WebRTC 等实时通信应用中。  核心思想：帮助内网主机探测 NAT 类型和获取公网 IP:Port，为 P2P 连接做准备。   一、为什么需要 STUN？现代互联网中，IPv4 地址资源日益枯竭，导致大多数终端设备都部署在 NAT 设备（如路由器）之后。NAT 设备通过将内部私有 IP 地址映射到外部公共 IP 地址和端口，允许多个内部设备共享一个公共 IP 地址访问互联网。 然而，NAT 给直接的点对点 (P2P) 通信带来了巨大的挑战：  内网 IP 地址不可路由：内部私有 IP 地址在公共互联网上是不可见的，外部设备无法直接通过私有 IP 地址联系到内部设备。 端口映射不确定：NAT 设备...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-PPPoE%EF%BC%9F"><span class="toc-text">一、什么是 PPPoE？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-PPPoE%EF%BC%9F"><span class="toc-text">二、为什么需要 PPPoE？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81PPPoE-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">三、PPPoE 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8F%91%E7%8E%B0%E9%98%B6%E6%AE%B5-Discovery-Stage"><span class="toc-text">3.1 发现阶段 (Discovery Stage)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BC%9A%E8%AF%9D%E9%98%B6%E6%AE%B5-Session-Stage"><span class="toc-text">3.2 会话阶段 (Session Stage)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81PPPoE-%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">四、PPPoE 数据帧结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%A4%B4"><span class="toc-text">4.1 以太网帧头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-PPPoE-%E5%A4%B4%E9%83%A8"><span class="toc-text">4.2 PPPoE 头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-PPP-%E5%A4%B4%E9%83%A8%E5%92%8C-Payload"><span class="toc-text">4.3 PPP 头部和 Payload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81PPPoE-%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-text">五、PPPoE 的部署与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%B6%E5%BA%AD%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5"><span class="toc-text">5.1 家庭宽带接入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BC%81%E4%B8%9A%E8%99%9A%E6%8B%9F%E4%B8%93%E7%BD%91-VPN"><span class="toc-text">5.2 企业虚拟专网 (VPN)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-25.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>