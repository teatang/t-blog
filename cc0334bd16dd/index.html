<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Vercel介绍 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vercel 是一家领先的前端云 (Frontend Cloud) 平台，专注于为前端开发者提供极速的部署、自动化的CI&#x2F;CD、全球化的内容分发 (CDN) 和 Serverless 功能。它以其与 Next.js 框架的深度集成而闻名，旨在帮助开发者以最快速度将 Web 项目从构思变为全球可用的产品，同时提供卓越的性能和开发者体验。  核心思想：Vercel 是一个将前端部署、构建、">
<meta property="og:type" content="article">
<meta property="og:title" content="Vercel介绍">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/cc0334bd16dd/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Vercel 是一家领先的前端云 (Frontend Cloud) 平台，专注于为前端开发者提供极速的部署、自动化的CI&#x2F;CD、全球化的内容分发 (CDN) 和 Serverless 功能。它以其与 Next.js 框架的深度集成而闻名，旨在帮助开发者以最快速度将 Web 项目从构思变为全球可用的产品，同时提供卓越的性能和开发者体验。  核心思想：Vercel 是一个将前端部署、构建、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg">
<meta property="article:published_time" content="2024-03-02T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-31T14:22:27.340Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="CI&#x2F;CD">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="Serverless">
<meta property="article:tag" content="云服务">
<meta property="article:tag" content="Vercel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vercel介绍",
  "url": "https://blog.tbf1211.xx.kg/cc0334bd16dd/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg",
  "datePublished": "2024-03-02T22:24:00.000Z",
  "dateModified": "2025-12-31T14:22:27.340Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/cc0334bd16dd/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vercel介绍',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">450</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Vercel介绍</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Vercel介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-03-02T22:24:00.000Z" title="发表于 2024-03-03 06:24:00">2024-03-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>7分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Vercel</strong> 是一家领先的<strong>前端云 (Frontend Cloud)</strong> 平台，专注于为前端开发者提供<strong>极速的部署、自动化的CI&#x2F;CD、全球化的内容分发 (CDN) 和 Serverless 功能</strong>。它以其与 <strong>Next.js</strong> 框架的深度集成而闻名，旨在帮助开发者以最快速度将 Web 项目从构思变为全球可用的产品，同时提供卓越的性能和开发者体验。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>Vercel 是一个将前端部署、构建、Hosting 和 Serverless 后端能力融为一体的平台，特别优化了 Next.js 等现代化框架的开发和部署流程，让开发者能够专注于代码，无需管理基础设施。</strong></p>
</div>
<hr>
<h2 id="一、为什么选择-Vercel？"><a href="#一、为什么选择-Vercel？" class="headerlink" title="一、为什么选择 Vercel？"></a>一、为什么选择 Vercel？</h2><p>在现代 Web 开发中，前端项目的部署和运维变得越来越复杂：</p>
<ul>
<li><strong>构建优化</strong>：代码打包、压缩、Tree Shaking。</li>
<li><strong>性能优化</strong>：CDN 分发、图片优化、SEO 优化。</li>
<li><strong>开发体验</strong>：持续集成&#x2F;持续部署 (CI&#x2F;CD)、预览部署、分支管理。</li>
<li><strong>后端需求</strong>：API 路由、Server-Side Rendering (SSR)、数据获取等，需要 Serverless 或 Node.js 服务。</li>
</ul>
<p>Vercel 旨在解决这些痛点，提供一个<strong>一体化、高性能、开发者友好</strong>的解决方案：</p>
<ol>
<li><strong>极简的部署流程</strong>：只需连接 Git 仓库，每次代码提交都会自动构建和部署。</li>
<li><strong>全球 CDN 分发</strong>：所有部署都默认在全球 CDN 上分发，确保内容快速送达用户。</li>
<li><strong>深度集成 Next.js</strong>：对 Next.js 项目有最佳支持，包括 SSR、ISR、API Routes、Edge Functions 等功能。</li>
<li><strong>Serverless Functions</strong>：内置 Serverless Functions (AWS Lambda 或 Edge Functions)，方便地为前端项目添加后端逻辑。</li>
<li><strong>预览部署与评论</strong>：为每次 Git 提交生成独立的预览部署，方便团队协作和代码评审。</li>
<li><strong>零配置 (Zero-Config)</strong>：对于 Next.js、React、Vue 等常见框架，无需额外配置即可部署。</li>
</ol>
<h2 id="二、Vercel-的核心功能与组件"><a href="#二、Vercel-的核心功能与组件" class="headerlink" title="二、Vercel 的核心功能与组件"></a>二、Vercel 的核心功能与组件</h2><p>Vercel 的平台由多个关键组件构成，共同提供完整的开发和部署体验：</p>
<h3 id="2-1-部署与-CI-CD"><a href="#2-1-部署与-CI-CD" class="headerlink" title="2.1 部署与 CI&#x2F;CD"></a>2.1 部署与 CI&#x2F;CD</h3><ul>
<li><strong>Git 集成</strong>：与 GitHub、GitLab、Bitbucket 等主流 Git 服务无缝集成。每次 <code>git push</code> 都会自动触发构建和部署。</li>
<li><strong>生产部署 (Production Deployments)</strong>：合并到主分支（如 <code>main</code> 或 <code>master</code>）的代码会被部署到生产环境。</li>
<li><strong>预览部署 (Preview Deployments)</strong>：每次非主分支的提交、Pull Request&#x2F;Merge Request 都会生成一个唯一的预览 URL，方便团队成员和利益相关者审查。</li>
<li><strong>即时部署 (Instant Deployments)</strong>：Vercel 的构建系统和全球 CDN 优化，使得部署速度非常快。</li>
<li><strong>回滚 (Rollbacks)</strong>：可以轻松回滚到之前的任意一个部署版本。</li>
</ul>
<h3 id="2-2-全球内容分发网络-CDN"><a href="#2-2-全球内容分发网络-CDN" class="headerlink" title="2.2 全球内容分发网络 (CDN)"></a>2.2 全球内容分发网络 (CDN)</h3><ul>
<li><strong>全球边缘网络</strong>：Vercel 的所有部署都默认通过其全球边缘网络进行分发。这确保了静态资源、Server-Side Rendered (SSR) 内容和 Serverless Functions 都能在离用户最近的位置响应，提供极低的延迟。</li>
<li><strong>图片优化</strong>：内置的图像优化服务 (Next.js Image Optimization) 可以在边缘按需优化、调整大小和格式化图像，进一步提升性能。</li>
<li><strong>智能缓存</strong>：自动优化缓存策略，提高资源命中率。</li>
</ul>
<h3 id="2-3-Serverless-Functions-无服务器函数"><a href="#2-3-Serverless-Functions-无服务器函数" class="headerlink" title="2.3 Serverless Functions (无服务器函数)"></a>2.3 Serverless Functions (无服务器函数)</h3><p>Vercel 支持将后端逻辑作为 Serverless Functions 部署，这些函数运行在离用户最近的区域。</p>
<ul>
<li><strong>API Routes (Next.js)</strong>：在 Next.js 项目中，<code>pages/api</code> 或 <code>app/api</code> 目录下的文件会自动转换为 Serverless Functions。</li>
<li><strong>通用 Serverless Functions</strong>：也可以部署独立的 Node.js, Go, Python, Ruby 等语言的 Serverless Functions。</li>
<li><strong>Edge Functions</strong>：<ul>
<li><strong>基于 V8 引擎</strong>：运行在 Cloudflare Workers (V8) 相同的技术栈上，提供<strong>极速的冷启动和超低延迟</strong>。</li>
<li><strong>全球分布式</strong>：部署在全球 Vercel 边缘节点上。</li>
<li><strong>用例</strong>：非常适合 A&#x2F;B 测试、个性化、URL 重写、认证鉴权、实时数据处理、地理位置路由等需要在请求到达源服务器之前执行的逻辑。</li>
</ul>
</li>
</ul>
<h3 id="2-4-Next-js-深度集成"><a href="#2-4-Next-js-深度集成" class="headerlink" title="2.4 Next.js 深度集成"></a>2.4 Next.js 深度集成</h3><p>Vercel 是 Next.js 的创建者，因此对 Next.js 有着无与伦比的优化和支持：</p>
<ul>
<li><strong>SSR&#x2F;ISR 自动优化</strong>：Next.js 的 Server-Side Rendering (SSR) 和 Incremental Static Regeneration (ISR) 功能在 Vercel 上运行效率最高。Vercel 会智能地将 SSR 和 API Routes 部署为 Serverless Functions，并将 ISR 生成的静态页面缓存在 CDN 上。</li>
<li><strong>Middleware</strong>：Next.js Middleware 可以作为 Edge Function 运行，在请求到达页面之前进行处理。</li>
<li><strong>Image Optimization</strong>：内置的 Next.js 图片优化服务。</li>
</ul>
<h3 id="2-5-开发者体验与协作"><a href="#2-5-开发者体验与协作" class="headerlink" title="2.5 开发者体验与协作"></a>2.5 开发者体验与协作</h3><ul>
<li><strong>Vercel CLI</strong>：强大的命令行工具，用于本地开发、部署和管理项目。</li>
<li><strong>环境变量管理</strong>：安全地管理不同环境下的环境变量。</li>
<li><strong>域名管理</strong>：可以轻松连接自定义域名，并自动配置 SSL 证书。</li>
<li><strong>团队协作</strong>：提供团队功能，方便多个开发者共同管理项目。</li>
<li><strong>Git 评论</strong>：预览部署会自动在 Git 提供商（如 GitHub）上留下评论，方便代码审查。</li>
</ul>
<h2 id="三、Vercel-的架构优势"><a href="#三、Vercel-的架构优势" class="headerlink" title="三、Vercel 的架构优势"></a>三、Vercel 的架构优势</h2><p>Vercel 的核心架构理念是“<strong>Frontend Cloud</strong>”，它将前端部署、CDN 和 Serverless 后端紧密结合，构建了一个统一的平台。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[用户] --&gt; B{&quot;Vercel 全球边缘网络 (CDN)&quot;}
    B -- 请求 --&gt; C{Vercel 路由与处理层}

    C -- 静态资源 --&gt; D[&quot;Vercel CDN (缓存)&quot;]
    C -- Server-Side Rendered (SSR) &#x2F; API Routes --&gt; E[&quot;Vercel Serverless Functions (AWS Lambda)&quot;]
    C -- Edge Functions &#x2F; Middleware --&gt; F[&quot;Vercel Edge Runtime (V8)&quot;]

    D --&gt; G[返回静态内容]
    E --&gt; H[返回动态内容]
    F --&gt; I[在边缘处理请求并返回 &#x2F; 修改请求继续处理]

    G -- 优化响应 --&gt; B
    H -- 优化响应 --&gt; B
    I -- 优化响应 --&gt; B
    B --&gt; A

    subgraph 开发者
        J[Next.js App &#x2F; 其他前端框架]
        K[Git 仓库]
        J -- Git Push --&gt; K
        K -- Webhook --&gt; L[Vercel CI&#x2F;CD]
        L -- 构建 &amp; 部署 --&gt; B
    end
  </pre></div>

<p><strong>关键点：</strong></p>
<ul>
<li><strong>请求在边缘处理</strong>：用户请求首先到达离他们最近的 Vercel 边缘节点。</li>
<li><strong>智能路由</strong>：Vercel 会智能地判断是返回 CDN 缓存的静态资源，还是需要调用 Serverless Function (SSR 或 API) 或 Edge Function。</li>
<li><strong>Serverless 和 Edge Functions</strong>：动态内容和后端逻辑运行在 Serverless 环境中，按需启动和扩展，无需开发者管理服务器。Edge Functions 提供更极致的低延迟。</li>
<li><strong>优化的 CDN</strong>：所有内容都通过全球 CDN 分发，包括静态资源和 SSR 缓存内容。</li>
</ul>
<h2 id="四、Vercel-的优缺点与适用场景"><a href="#四、Vercel-的优缺点与适用场景" class="headerlink" title="四、Vercel 的优缺点与适用场景"></a>四、Vercel 的优缺点与适用场景</h2><h3 id="4-1-优点："><a href="#4-1-优点：" class="headerlink" title="4.1 优点："></a>4.1 优点：</h3><ol>
<li><strong>极佳的开发者体验</strong>：Git 集成、零配置、预览部署，大大简化了部署流程。</li>
<li><strong>高性能</strong>：全球 CDN、Edge Functions、图片优化，确保网站速度快、响应低延迟。</li>
<li><strong>与 Next.js 深度集成</strong>：对 Next.js 项目的支持是业界最佳，充分发挥框架特性。</li>
<li><strong>自动伸缩与免运维</strong>：Serverless 架构，无需管理服务器，自动扩展以应对流量高峰。</li>
<li><strong>成本效益</strong>：对于中小型项目，免费层功能强大，按需付费模式。</li>
<li><strong>团队协作功能</strong>：评论、环境变量管理、团队成员管理等。</li>
</ol>
<h3 id="4-2-缺点："><a href="#4-2-缺点：" class="headerlink" title="4.2 缺点："></a>4.2 缺点：</h3><ol>
<li><strong>供应商锁定</strong>：深度集成其生态，迁移到其他平台可能需要一些工作。</li>
<li><strong>某些高级功能限制</strong>：对于非常复杂的、需要长时间运行的后端服务或自定义的数据库管理，Vercel 的 Serverless Functions 可能不是最佳选择。</li>
<li><strong>定价模式</strong>：虽然免费层强大，但对于大型团队或高流量项目，某些高级功能（如更高并发的 Serverless Functions）可能需要升级付费计划。</li>
<li><strong>地域限制</strong>：虽然是全球 CDN，但 Serverless Functions 的执行区域受限于 Vercel 的部署位置。</li>
</ol>
<h3 id="4-3-适用场景："><a href="#4-3-适用场景：" class="headerlink" title="4.3 适用场景："></a>4.3 适用场景：</h3><ul>
<li><strong>Next.js 项目</strong>：这是 Vercel 最推荐和最擅长的场景。</li>
<li><strong>Jamstack 网站</strong>：静态网站、博客、文档站等。</li>
<li><strong>营销落地页与企业官网</strong>：需要快速迭代、高性能展示的网站。</li>
<li><strong>Web 应用的 Frontend</strong>：单页应用 (SPA) 的前端部署，结合 Serverless API。</li>
<li><strong>电子商务网站</strong>：利用 Next.js 的 SSR&#x2F;ISR 和 Vercel 的全球 CDN，提供快速的购物体验。</li>
<li><strong>个人项目与原型开发</strong>：免费层提供强大功能，非常适合快速启动项目。</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Vercel 作为前端云的领导者，通过其简洁的部署流程、强大的全球 CDN、内置的 Serverless 能力以及对 Next.js 的深度优化，极大地提升了现代 Web 应用的开发效率和运行性能。它使得前端开发者能够更专注于构建卓越的用户体验，而无需为复杂的部署和基础设施管理分心。对于任何希望快速迭代、部署高性能 Web 应用的团队或个人来说，Vercel 都是一个值得深入探索和利用的强大平台。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/cc0334bd16dd/">https://blog.tbf1211.xx.kg/cc0334bd16dd/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CI-CD/">CI/CD</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/Serverless/">Serverless</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a><a class="post-meta__tags" href="/tags/Vercel/">Vercel</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/c645d233e96b/" title="Vercel.json详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Vercel.json详解</div></div><div class="info-2"><div class="info-item-1"> vercel.json 是 Vercel 平台的核心配置文件，它允许开发者对项目的部署行为、路由规则、Serverless Functions 配置、环境变量、构建过程等进行细粒度的控制。通过 vercel.json，你可以超越 Vercel 的默认零配置行为，根据项目的特定需求定制化部署策略。  核心思想：vercel.json 是一个 JSON 文件，用于声明 Vercel 项目的各种配置，包括路由重写、重定向、HTTP Headers、Serverless Functions 设置、构建步骤和环境变量等，从而实现高级部署功能和优化。   一、vercel.json 的基本结构与作用vercel.json 文件通常位于项目的根目录下。Vercel 在每次部署时会读取这个文件，并根据其中的配置来处理构建、路由和请求。 一个典型的 vercel.json 结构如下： 123456789101112131415&#123;  &quot;version&quot;: 2,  &quot;name&quot;: &quot;my-vercel-project&quot;,  &qu...</div></div></div></a><a class="pagination-related" href="/10254658f0df/" title="MathJax 详解：在 Web 上优雅地渲染数学公式"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MathJax 详解：在 Web 上优雅地渲染数学公式</div></div><div class="info-2"><div class="info-item-1"> MathJax 是一个开源的 JavaScript 显示引擎，用于在所有现代浏览器中显示数学公式。它以高性能渲染高质量的排版，支持广泛使用的数学标记语言，如 LaTeX、MathML 和 AsciiMath。MathJax 的目标是让网页上的数学内容能够像桌面排版软件那样清晰、美观、易读，同时保持可访问性和可搜索性。  核心思想： MathJax 使得在浏览器中显示复杂的数学公式变得简单、美观且无需安装任何插件或字体。它将数学标记语言转换为网页上可渲染的图形元素（通常是 HTML + CSS 或 SVG），确保跨平台和设备的显示一致性。   一、为什么选择 MathJax？在 Web 上显示数学公式一直是一个挑战。传统的解决方案包括：  图片 (Images)：将公式渲染成图片。 缺点：不清晰（特别是缩放时）、不易编辑、不可搜索、不能复制文本、可访问性差（屏幕阅读器无法识别）。   纯文本 (Plain Text)：使用 ASCII 字符近似表示公式（如 x^2 + y^2 = r^2）。 缺点：可读性极差，无法表达复杂结构。   MathML (Mathematical Ma...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/487df70cf615/" title="Vercel Serverless Functions 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="info-item-2">Vercel Serverless Functions 深度详解</div></div><div class="info-2"><div class="info-item-1"> Vercel Serverless Functions 是 Vercel 平台的核心服务之一，它允许开发者部署并运行后端代码，而无需管理任何服务器基础设施。这些函数是轻量级的、按需执行的计算单元，能够根据流量自动扩缩容，并天然集成到 Vercel 的全球 CDN 和部署工作流中。Vercel Functions 不仅为 Next.js 提供了强大的 API 路由支持，还允许开发者使用多种编程语言（如 Node.js, Python, Go, Ruby 等）构建独立的后端服务。  核心思想：Vercel Serverless Functions 提供了一种高效、自动扩缩容的无状态计算环境，使开发者能够将后端逻辑作为独立的函数部署到 Vercel 的全球边缘网络。其核心优势在于与前端框架的无缝集成、多语言支持、自动管理基础设施，并通过 Git 驱动的部署流程，极大地简化了全栈应用的开发和运维。   一、Vercel Serverless Functions 概览1.1 核心概念 无服务器 (Serverless)：你无需预置或管理任何服务器。Vercel 负责所有基础设施的配置、维...</div></div></div></a><a class="pagination-related" href="/3aa9e4c628f2/" title="在 Vercel 开发 Next.js 应用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-12</div><div class="info-item-2">在 Vercel 开发 Next.js 应用详解</div></div><div class="info-2"><div class="info-item-1"> Vercel 是 Next.js 的创建者，也是一个领先的云平台，专为部署和扩展 Web 应用程序而设计，特别是针对 Next.js 应用。它提供了一站式的开发、预览和部署工作流，集成了 Git 仓库，并支持无服务器功能、全球 CDN、自动 SSL 等，极大地简化了 Next.js 应用的部署和管理。  核心思想：在 Vercel 上开发 Next.js 应用，核心在于利用 Vercel 与 Next.js 的深度集成，实现从代码提交到全球部署的自动化工作流。这包括使用 Next.js 的特性（如数据获取、API 路由），配置 Vercel 项目，利用其预览部署、环境变量、无服务器函数等功能，实现高效且可扩展的开发和部署。   一、Next.js 基础在深入 Vercel 之前，确保你对 Next.js 的核心概念有所了解：  文件系统路由 (File-system Routing)：根据 pages (或 app 目录) 目录结构自动生成路由。 数据获取 (Data Fetching)： getServerSideProps (SSR): 服务端渲染，每次请求生成页面。 ge...</div></div></div></a><a class="pagination-related" href="/c645d233e96b/" title="Vercel.json详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-11</div><div class="info-item-2">Vercel.json详解</div></div><div class="info-2"><div class="info-item-1"> vercel.json 是 Vercel 平台的核心配置文件，它允许开发者对项目的部署行为、路由规则、Serverless Functions 配置、环境变量、构建过程等进行细粒度的控制。通过 vercel.json，你可以超越 Vercel 的默认零配置行为，根据项目的特定需求定制化部署策略。  核心思想：vercel.json 是一个 JSON 文件，用于声明 Vercel 项目的各种配置，包括路由重写、重定向、HTTP Headers、Serverless Functions 设置、构建步骤和环境变量等，从而实现高级部署功能和优化。   一、vercel.json 的基本结构与作用vercel.json 文件通常位于项目的根目录下。Vercel 在每次部署时会读取这个文件，并根据其中的配置来处理构建、路由和请求。 一个典型的 vercel.json 结构如下： 123456789101112131415&#123;  &quot;version&quot;: 2,  &quot;name&quot;: &quot;my-vercel-project&quot;,  &qu...</div></div></div></a><a class="pagination-related" href="/6842deb76626/" title="AWS Lambda与Serverless详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="info-item-2">AWS Lambda与Serverless详解</div></div><div class="info-2"><div class="info-item-1"> AWS Lambda 是亚马逊网络服务 (Amazon Web Services, AWS) 提供的核心 Serverless 计算服务，也是函数即服务 (Function-as-a-Service, FaaS) 的开创者和领导者。它允许开发者运行代码，而无需配置或管理服务器。开发者只需上传代码，Lambda 会自动处理运行代码所需的一切，包括容量预置、扩展、打补丁和维护。  核心思想：AWS Lambda 是 AWS Serverless 生态的核心，它将代码作为“函数”运行在无服务器环境中，由各种 AWS 事件触发，按需执行，自动伸缩，并按实际使用量计费。   一、AWS Lambda 概览AWS Lambda 于 2014 年推出，彻底改变了云计算的开发和部署模式。它让开发者能够将后端逻辑解耦为一系列独立、短生命周期的函数，从而极大地简化了运维。 1.1 Lambda 的核心概念 函数 (Function)：这是 Lambda 中的基本部署单元，包含你的代码和相关配置（如运行时、内存、超时时间、环境变量）。 事件 (Event)：触发 Lambda 函数执行的任何操作。事...</div></div></div></a><a class="pagination-related" href="/1165e3e15519/" title="边缘计算 (Edge Computing) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-05</div><div class="info-item-2">边缘计算 (Edge Computing) 详解</div></div><div class="info-2"><div class="info-item-1"> 边缘计算 (Edge Computing) 是一种分布式计算范式，它将计算和数据存储能力从集中式的云数据中心下沉到网络的边缘，即数据源或数据源附近。其核心思想是在数据产生的地方进行数据处理、分析和存储，而不是将所有数据都传输到远程的云端进行处理。这种模式旨在解决云计算在延迟、带宽、隐私和可靠性方面面临的挑战，特别是在物联网 (IoT)、5G 和人工智能 (AI) 等新兴技术驱动下，变得越来越重要。  核心思想：将计算能力推向数据源头，在网络边缘就近处理数据，以降低延迟、节省带宽、增强隐私和提高可靠性。   一、为什么需要边缘计算？传统的云计算模型将数据发送到远程数据中心进行处理。随着物联网设备的爆炸式增长、5G 网络的高速发展以及AI应用对实时性的高要求，这种中心化的模式暴露出以下问题：  高延迟 (High Latency)：数据从边缘设备传输到云端，再从云端返回，需要较长时间。对于自动驾驶、工业自动化、远程医疗等实时性要求极高的应用，几毫秒的延迟都可能造成严重后果。 带宽限制与成本 (Bandwidth Constraints &amp; Cost)：物联网设备产生海量数据...</div></div></div></a><a class="pagination-related" href="/f5c29582f368/" title="Serverless 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="info-item-2">Serverless 详解</div></div><div class="info-2"><div class="info-item-1"> Serverless (无服务器) 是一种云计算的执行模型，它允许开发者构建和运行应用程序而无需管理服务器。在这种模型下，云服务提供商负责服务器的调配、维护和扩展，开发者只需关注自己的代码逻辑。Serverless 并不是指“没有服务器”，而是指“开发者不需要关心服务器”。它通常包含两种核心服务模式：函数即服务 (Function-as-a-Service, FaaS) 和 后端即服务 (Backend-as-a-Service, BaaS)。  核心思想：将基础设施管理完全交给云服务商，开发者只需编写代码并部署，按实际使用量付费，实现极致的弹性伸缩和降低运维成本。   一、为什么需要 Serverless？传统的应用部署模型（物理机、虚拟机、容器）都需要开发者或运维团队投入大量精力进行服务器管理：  资源调配：预估并配置合适的 CPU、内存、存储。 操作系统管理：安装、打补丁、更新。 运行时环境：安装语言运行时、库、依赖。 扩展性：根据流量变化手动或自动伸缩服务器集群。 高可用性：设置负载均衡、故障转移机制。 监控与日志：部署监控 agent，收集日志。  这些“非功能性需求...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">450</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-Vercel%EF%BC%9F"><span class="toc-text">一、为什么选择 Vercel？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Vercel-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BB%84%E4%BB%B6"><span class="toc-text">二、Vercel 的核心功能与组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%83%A8%E7%BD%B2%E4%B8%8E-CI-CD"><span class="toc-text">2.1 部署与 CI&#x2F;CD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%85%A8%E7%90%83%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C-CDN"><span class="toc-text">2.2 全球内容分发网络 (CDN)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Serverless-Functions-%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-text">2.3 Serverless Functions (无服务器函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Next-js-%E6%B7%B1%E5%BA%A6%E9%9B%86%E6%88%90"><span class="toc-text">2.4 Next.js 深度集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%BC%80%E5%8F%91%E8%80%85%E4%BD%93%E9%AA%8C%E4%B8%8E%E5%8D%8F%E4%BD%9C"><span class="toc-text">2.5 开发者体验与协作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Vercel-%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF"><span class="toc-text">三、Vercel 的架构优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Vercel-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、Vercel 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">4.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">4.2 缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">4.3 适用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-02.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>