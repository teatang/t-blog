<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golang context 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="context 包 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递请求范围的数据 (request-scoped data)、取消信号 (cancellation signals) 和截止时间 (deadlines) 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，context 包是管理 Goroutine 生命">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang context 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/7642665c9bbb/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="context 包 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递请求范围的数据 (request-scoped data)、取消信号 (cancellation signals) 和截止时间 (deadlines) 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，context 包是管理 Goroutine 生命">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2024-08-02T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-15T10:08:44.460Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="goroutine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang context 详解",
  "url": "https://blog.tbf1211.xx.kg/7642665c9bbb/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2024-08-02T22:24:00.000Z",
  "dateModified": "2026-01-15T10:08:44.460Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/7642665c9bbb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang context 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">495</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Golang context 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Golang context 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-02T22:24:00.000Z" title="发表于 2024-08-03 06:24:00">2024-08-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/goroutine/">goroutine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong><code>context</code> 包</strong> 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递<strong>请求范围的数据 (request-scoped data)</strong>、<strong>取消信号 (cancellation signals)</strong> 和<strong>截止时间 (deadlines)</strong> 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，<code>context</code> 包是管理 Goroutine 生命周期和避免资源泄露的基石。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong><code>context.Context</code> 接口允许在 Goroutine 树中安全地传递控制流信息。其核心价值在于实现对计算任务的统一取消、超时控制和值传递，从而提升程序的健壮性和资源利用效率。</strong></p>
</div>
<hr>
<h2 id="一、context-包的必要性"><a href="#一、context-包的必要性" class="headerlink" title="一、context 包的必要性"></a>一、<code>context</code> 包的必要性</h2><p>在 Go 语言中，Goroutine 是轻量级并发的基础。然而，当应用程序的并发逻辑变得复杂时，以下问题会变得突出：</p>
<ol>
<li><strong>并发操作的取消</strong>：当一个上游操作（如用户取消请求）不再需要其下游的所有并发子任务时，如何有效地通知并停止这些子任务，避免不必要的计算和资源消耗？</li>
<li><strong>操作超时控制</strong>：如何在复杂的请求链中，为整个链条或其中某个环节设置统一的超时时间，并确保超时后所有相关的 Goroutine 都能被及时终止？</li>
<li><strong>请求范围值的传递</strong>：在处理一个用户请求时，可能需要在不同的 Goroutine 之间传递一些与该请求相关但又不是核心业务逻辑的元数据（例如：认证令牌、追踪 ID、数据库事务）。传统方法可能导致函数签名臃肿或全局变量滥用。</li>
<li><strong>资源泄露风险</strong>：如果 Goroutine 在不需要继续执行时未能及时退出，可能会持续持有文件句柄、网络连接、内存等资源，导致系统性能下降甚至崩溃。</li>
</ol>
<p><code>context</code> 包正是为了解决这些问题而设计，它提供了一个统一、可组合的抽象层来管理并发操作的生命周期和数据流。</p>
<h2 id="二、context-Context-接口详解"><a href="#二、context-Context-接口详解" class="headerlink" title="二、context.Context 接口详解"></a>二、<code>context.Context</code> 接口详解</h2><p><code>context.Context</code> 是一个接口，定义了四个核心方法，这些方法提供了传递截止时间、取消信号和请求范围值的机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this Context is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err returns a non-nil error if Done is closed, indicating why the</span></span><br><span class="line">    <span class="comment">// context was canceled.</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    <span class="comment">// A Context that has no deadline will return ok==false.</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key, or nil if no value is</span></span><br><span class="line">    <span class="comment">// associated with key in this context.</span></span><br><span class="line">    Value(key any) any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>Done() &lt;-chan struct&#123;&#125;</code></strong>：</p>
<ul>
<li>返回一个只读的 <code>&lt;-chan struct&#123;&#125;</code> 类型 Channel。</li>
<li>当此 <code>Context</code> 被取消或超时时，该 Channel 会被关闭。</li>
<li>Goroutine 应该监听这个 <code>Done</code> Channel。一旦 Channel 被关闭，意味着父 <code>Context</code> 发出了停止信号，子 Goroutine 应立即停止其工作并返回，从而实现优雅退出。</li>
<li>关闭 Channel 是 Go 中发送广播信号的惯用模式。</li>
</ul>
</li>
<li><p><strong><code>Err() error</code></strong>：</p>
<ul>
<li>如果 <code>Done()</code> Channel 已经关闭，<code>Err()</code> 返回一个非 <code>nil</code> 的错误，指示 <code>Context</code> 被取消的原因。</li>
<li>常见的错误值包括：<ul>
<li><code>context.Canceled</code>：<code>Context</code> 被 <code>CancelFunc</code> 手动取消。</li>
<li><code>context.DeadlineExceeded</code>：<code>Context</code> 由于超时或到达截止时间而被取消。</li>
</ul>
</li>
<li>如果 <code>Done()</code> Channel 尚未关闭，<code>Err()</code> 返回 <code>nil</code>。</li>
</ul>
</li>
<li><p><strong><code>Deadline() (deadline time.Time, ok bool)</code></strong>：</p>
<ul>
<li>返回此 <code>Context</code> 的截止时间点。如果 <code>Context</code> 有截止时间，<code>ok</code> 为 <code>true</code>；否则 <code>ok</code> 为 <code>false</code>。</li>
<li>Goroutine 可以通过此方法提前判断是否还有足够的时间完成任务，从而决定是否启动新的耗时操作。</li>
</ul>
</li>
<li><p><strong><code>Value(key any) any</code></strong>：</p>
<ul>
<li>允许存储和检索与 <code>Context</code> 相关的请求范围值。</li>
<li><code>key</code> 必须是可比较的类型，通常建议使用自定义的、不导出 (unexported) 的结构体类型作为键，以避免键冲突。</li>
<li>此方法用于传递那些在整个请求生命周期中可能需要，但又不适合作为函数参数层层传递的元数据（如追踪 ID、认证信息等）。</li>
</ul>
</li>
</ol>
<h2 id="三、context-的创建与衍生"><a href="#三、context-的创建与衍生" class="headerlink" title="三、context 的创建与衍生"></a>三、<code>context</code> 的创建与衍生</h2><p><code>context</code> 包提供了四种主要函数来创建和衍生 <code>Context</code>。所有 <code>Context</code> 形成一个树状结构，子 <code>Context</code> 会继承父 <code>Context</code> 的属性，并且当父 <code>Context</code> 被取消时，其所有子 <code>Context</code> 也会被取消。</p>
<h3 id="3-1-根-Context：context-Background-和-context-TODO"><a href="#3-1-根-Context：context-Background-和-context-TODO" class="headerlink" title="3.1 根 Context：context.Background() 和 context.TODO()"></a>3.1 根 Context：<code>context.Background()</code> 和 <code>context.TODO()</code></h3><p>所有 <code>Context</code> 树的起点。它们本身不携带任何值，不会被取消，也没有截止时间。</p>
<ul>
<li><strong><code>context.Background()</code></strong>：<ul>
<li>通常作为<strong>主函数、初始化或顶级 Goroutine 的根 Context</strong>。</li>
<li>语义上表示“无限制的上下文”。</li>
</ul>
</li>
<li><strong><code>context.TODO()</code></strong>：<ul>
<li>语义上表示“待办 (To Do)”。</li>
<li>当不确定要使用哪个 <code>Context</code>，或者函数将来应该接受 <code>Context</code> 但目前尚未实现时使用。它是一个占位符，提示开发者将来需要替换为更具体的 <code>Context</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 作为根 Context</span></span><br><span class="line">	bgCtx := context.Background()</span><br><span class="line">	bgDeadline, _ := bgCtx.Deadline()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Background Context: Deadline=%v, Done=%v, Err=%v\n&quot;</span>, bgDeadline, bgCtx.Done(), bgCtx.Err())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 作为占位符</span></span><br><span class="line">	todoCtx := context.TODO()</span><br><span class="line">	todoDeadline, _ := todoCtx.Deadline()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;TODO Context: Deadline=%v, Done=%v, Err=%v\n&quot;</span>, todoDeadline, todoCtx.Done(), todoCtx.Err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-context-WithCancel-parent-Context-：取消型-Context"><a href="#3-2-context-WithCancel-parent-Context-：取消型-Context" class="headerlink" title="3.2 context.WithCancel(parent Context)：取消型 Context"></a>3.2 <code>context.WithCancel(parent Context)</code>：取消型 Context</h3><ul>
<li>基于一个父 <code>Context</code> 创建一个新的子 <code>Context</code>，并返回一个 <code>CancelFunc</code>。</li>
<li>调用返回的 <code>CancelFunc</code> 会立即取消此新 <code>Context</code> 及其所有子 <code>Context</code>。</li>
<li>当父 <code>Context</code> 被取消时，此子 <code>Context</code> 也会被取消。</li>
</ul>
<p><strong>示例：手动取消 Goroutine 链</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchUserData</span><span class="params">(ctx context.Context, userID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 监听父 Context 的取消信号</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Fetcher for User %d: 收到取消信号，优雅退出。原因: %v\n&quot;</span>, userID, ctx.Err())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond): <span class="comment">// 模拟耗时操作</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Fetcher for User %d: 正在获取用户数据...\n&quot;</span>, userID)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个可取消的根 Context</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel() <span class="comment">// 务必在不再需要 Context 时调用 cancel()，释放资源</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 启动数据获取 Goroutine...&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> fetchUserData(ctx, <span class="number">123</span>)</span><br><span class="line">	<span class="keyword">go</span> fetchUserData(ctx, <span class="number">456</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 主 Goroutine 运行一段时间</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\nMain: 发送取消信号，停止所有数据获取...&quot;</span>)</span><br><span class="line">	cancel() <span class="comment">// 调用 cancel 函数，取消所有子 Goroutine 的 Context</span></span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待 Goroutine 退出</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 程序结束。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><strong><code>defer cancel()</code></strong>：<strong>这是使用 <code>WithCancel</code>、<code>WithTimeout</code> 和 <code>WithDeadline</code> 模式的黄金法则。</strong> 即使子 Goroutine 提前退出，也必须调用 <code>CancelFunc</code> 来清理与 <code>Context</code> 关联的资源，避免内存泄露。</li>
</ul>
<h3 id="3-3-context-WithTimeout-parent-Context-timeout-time-Duration-：超时型-Context"><a href="#3-3-context-WithTimeout-parent-Context-timeout-time-Duration-：超时型-Context" class="headerlink" title="3.3 context.WithTimeout(parent Context, timeout time.Duration)：超时型 Context"></a>3.3 <code>context.WithTimeout(parent Context, timeout time.Duration)</code>：超时型 Context</h3><ul>
<li>基于父 <code>Context</code> 创建一个新的子 <code>Context</code>，并在指定的 <code>timeout</code> 持续时间后自动取消。</li>
<li>同样返回一个新 <code>Context</code> 和一个 <code>CancelFunc</code>。</li>
<li><code>timeout</code> 达到时，<code>Context</code> 会自动取消（<code>Err()</code> 返回 <code>context.DeadlineExceeded</code>）。</li>
<li>也可以手动调用 <code>CancelFunc</code> 提前取消。</li>
</ul>
<p><strong>示例：控制网络请求超时</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeHTTPRequest</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second): <span class="comment">// 模拟一个需要 3 秒才能完成的网络请求</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;HTTP Request: 请求成功完成。&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 监听 Context 的取消或超时信号</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;HTTP Request: 请求被取消或超时。原因: %v\n&quot;</span>, ctx.Err())</span><br><span class="line">		<span class="keyword">return</span> ctx.Err()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个带 2 秒超时的 Context</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel() <span class="comment">// 确保 Context 资源被释放</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 启动模拟 HTTP 请求...&quot;</span>)</span><br><span class="line">	err := makeHTTPRequest(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Main: 请求结束，遇到错误: %v\n&quot;</span>, err) <span class="comment">// 预期会是 context.DeadlineExceeded</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Main: 请求成功完成。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 确保 Goroutine 有时间打印消息</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 程序结束。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-context-WithDeadline-parent-Context-deadline-time-Time-：截止时间型-Context"><a href="#3-4-context-WithDeadline-parent-Context-deadline-time-Time-：截止时间型-Context" class="headerlink" title="3.4 context.WithDeadline(parent Context, deadline time.Time)：截止时间型 Context"></a>3.4 <code>context.WithDeadline(parent Context, deadline time.Time)</code>：截止时间型 Context</h3><ul>
<li>与 <code>WithTimeout</code> 类似，但不是指定一个持续时间，而是指定一个具体的截止时间点 <code>deadline</code>。</li>
<li>当当前时间到达或超过 <code>deadline</code> 时，<code>Context</code> 自动取消。</li>
<li>同样返回一个新 <code>Context</code> 和一个 <code>CancelFunc</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置一个在未来 2 秒的截止时间</span></span><br><span class="line">	deadline := time.Now().Add(<span class="number">2</span> * time.Second)</span><br><span class="line">	ctx, cancel := context.WithDeadline(context.Background(), deadline)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Main: 任务将在 %s 截止。\n&quot;</span>, deadline.Format(time.RFC3339))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second): <span class="comment">// 模拟等待 3 秒</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Main: 任务完成 (不应该发生，因为已过截止时间)。&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Main: Context 已超时或被取消，原因: %v\n&quot;</span>, ctx.Err()) <span class="comment">// 预期会是 context.DeadlineExceeded</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 程序结束。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-context-WithValue-parent-Context-key-val-any-：值型-Context"><a href="#3-5-context-WithValue-parent-Context-key-val-any-：值型-Context" class="headerlink" title="3.5 context.WithValue(parent Context, key, val any)：值型 Context"></a>3.5 <code>context.WithValue(parent Context, key, val any)</code>：值型 Context</h3><ul>
<li>基于父 <code>Context</code> 创建一个新 <code>Context</code>，并在其中存储一个键值对。</li>
<li>这个 <code>Context</code> 会成为一个不可变的链表节点，每个节点持有自己的键值对，并指向其父 <code>Context</code>。</li>
<li>主要用于在请求处理链中传递与请求相关的元数据。</li>
</ul>
<p><strong>示例：传递请求 ID 和认证信息</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义不导出的键类型，以避免与其他包中的键冲突</span></span><br><span class="line"><span class="keyword">type</span> contextKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	RequestIDKey   contextKey = <span class="string">&quot;requestID&quot;</span></span><br><span class="line">	AuthTokenKey   contextKey = <span class="string">&quot;authToken&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performDBQuery</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	requestID := ctx.Value(RequestIDKey)</span><br><span class="line">	authToken := ctx.Value(AuthTokenKey)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> requestID != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;[%v] &quot;</span>, requestID)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> authToken != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;[Auth: %v] &quot;</span>, authToken)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;正在执行数据库查询...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">		fmt.Printf(<span class="string">&quot;[%v] 数据库查询完成。\n&quot;</span>, requestID)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;[%v] 数据库查询被取消，原因: %v\n&quot;</span>, requestID, ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建根 Context</span></span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 传递请求 ID</span></span><br><span class="line">	requestCtx := context.WithValue(ctx, RequestIDKey, <span class="string">&quot;REQ-XYZ-789&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 传递认证令牌 (基于 requestCtx 衍生)</span></span><br><span class="line">	authCtx := context.WithValue(requestCtx, AuthTokenKey, <span class="string">&quot;Bearer ABCDEF12345&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 启动 Goroutine 进行数据库查询，并传递带值的 Context</span></span><br><span class="line">	<span class="keyword">go</span> performDBQuery(authCtx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 主 Goroutine 模拟其他操作</span></span><br><span class="line">	time.Sleep(<span class="number">1500</span> * time.Millisecond) </span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 程序结束。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li><strong>键的类型</strong>：强烈建议使用自定义的、不导出的结构体类型作为 <code>WithValue</code> 的键，而不是简单的字符串或基本类型（如 <code>int</code>）。这样可以有效避免不同包之间键名冲突导致的值覆盖或意外访问。例如：<code>type myKey int; const RequestIDKey myKey = 0</code>。</li>
<li><strong>不可变性</strong>：<code>Context</code> 是不可变的。<code>WithValue</code> 会创建一个新的 <code>Context</code> 实例，其中包含新的键值对，并链接到父 <code>Context</code>。</li>
<li><strong>谨慎使用</strong>：<code>WithValue</code> 提供了一种全局访问请求数据的便利，但也容易导致隐式依赖。对于重要的业务数据，仍然建议通过函数参数显式传递。仅将 <code>WithValue</code> 用于真正属于“请求上下文”的元数据。</li>
</ul>
<h2 id="四、Context-的传递规则与最佳实践"><a href="#四、Context-的传递规则与最佳实践" class="headerlink" title="四、Context 的传递规则与最佳实践"></a>四、Context 的传递规则与最佳实践</h2><p>正确的 <code>Context</code> 使用模式是 Go 语言编程中的一项重要技能。</p>
<ol>
<li><p><strong>作为函数的第一个参数</strong>：</p>
<ul>
<li>Go 语言社区约定，<code>context.Context</code> 应该作为函数的第一个参数传递，通常命名为 <code>ctx</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyFunc</span><span class="params">(ctx context.Context, arg1 <span class="type">string</span>, arg2 <span class="type">int</span>)</span></span> (result <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不要传递 <code>nil</code> Context</strong>：</p>
<ul>
<li>除非你有非常特殊的理由，否则不应该传递 <code>nil</code> 给 <code>Context</code> 参数。</li>
<li>当需要一个不进行任何操作的根 <code>Context</code> 时，使用 <code>context.Background()</code>。</li>
<li>当不确定使用哪个 <code>Context</code> 时，使用 <code>context.TODO()</code>。</li>
<li>传递 <code>nil</code> Context 调用其方法会导致 <code>panic</code>。</li>
</ul>
</li>
<li><p><strong>Context 链条式衍生</strong>：</p>
<ul>
<li>始终从一个已有的 <code>Context</code> 衍生出新的 <code>Context</code>。例如，从 <code>context.Background()</code> 衍生出 <code>WithCancel</code>，再从 <code>WithCancel</code> 衍生出 <code>WithTimeout</code>，等等。</li>
<li>这形成了 <code>Context</code> 树，保证了取消信号和截止时间能够正确地沿树向下传播。</li>
<li>不要在 Goroutine 内部创建新的根 <code>Context</code>，除非该 Goroutine 启动了一个完全独立的、与父级生命周期无关的新操作树。</li>
</ul>
</li>
<li><p><strong><code>defer cancel()</code> 的重要性</strong>：</p>
<ul>
<li><code>context.WithCancel</code>, <code>context.WithTimeout</code>, <code>context.WithDeadline</code> 函数会返回一个 <code>CancelFunc</code>。</li>
<li><strong>务必在不再需要该 <code>Context</code> 时（例如函数返回前）调用 <code>CancelFunc</code></strong>，即使 Goroutine 已经提前退出。这可以释放 <code>Context</code> 内部持有的资源，避免潜在的内存泄露。最常见且推荐的做法是使用 <code>defer cancel()</code>。</li>
</ul>
</li>
<li><p><strong>Goroutine 监听 <code>ctx.Done()</code></strong>：</p>
<ul>
<li>所有长时间运行的 Goroutine 都应该接收 <code>Context</code> 作为参数，并在其内部通过 <code>select &#123; case &lt;-ctx.Done(): return &#125;</code> 或类似机制来监听取消信号。一旦 <code>ctx.Done()</code> Channel 被关闭，Goroutine 应该立即停止工作并返回，实现优雅退出。</li>
<li>对于调用外部库或标准库函数的场景，许多现代 Go 库的函数都接受 <code>Context</code> 参数（如 <code>net/http</code>、<code>database/sql</code>），它们会自动处理 <code>Context</code> 的取消和超时。</li>
</ul>
</li>
<li><p><strong>避免在 <code>struct</code> 中存储 <code>Context</code></strong>：</p>
<ul>
<li><code>Context</code> 是一个请求范围 (request-scoped) 的值，其生命周期通常与一个请求或一个操作相关。</li>
<li>将 <code>Context</code> 存储在 <code>struct</code> 字段中会模糊其生命周期，可能导致 <code>Context</code> 被意外地重用或持有过长时间，从而引发并发问题或资源泄露。</li>
<li>正确的做法是将其作为函数的参数显式传递。</li>
</ul>
</li>
</ol>
<h2 id="五、Context-树的取消传播示意"><a href="#五、Context-树的取消传播示意" class="headerlink" title="五、Context 树的取消传播示意"></a>五、Context 树的取消传播示意</h2><p><code>Context</code> 的核心优势在于其层次化的取消传播机制。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;Root Context (e.g., Background)&quot;] --&gt; B{&quot;HTTP Request Handler (WithCancel)&quot;}
    B --&gt; C{&quot;Database Query (WithTimeout)&quot;}
    B --&gt; D{&quot;External Service Call (WithCancel)&quot;}
    C --&gt; E[DB Connection Goroutine]
    D --&gt; F[RPC Client Goroutine]
    D --&gt; G[Log Goroutine]

    subgraph &quot;Cancellation Scenarios&quot;
        B_Cancel[调用 B 的 CancelFunc] --&gt; B_Cancelled(B Cancelled)
        B_Cancelled --&gt; C_Cancelled(C Cancelled)
        B_Cancelled --&gt; D_Cancelled(D Cancelled)
        C_Timeout[C 超时] --&gt; C_Cancelled(C Cancelled)

        C_Cancelled --&gt; E_Stopped[E 收到取消信号并停止]
        D_Cancelled --&gt; F_Stopped[F 收到取消信号并停止]
        D_Cancelled --&gt; G_Stopped[G 收到取消信号并停止]
    end
  </pre></div>

<ul>
<li>如果 <code>HTTP Request Handler</code> (Context B) 的 <code>CancelFunc</code> 被调用，或者其父 <code>Context</code> 被取消，那么 <code>B</code> 及其所有子 <code>Context</code> (<code>C</code>, <code>D</code>) 都会被取消。</li>
<li>如果 <code>Database Query</code> (Context C) 的 <code>CancelFunc</code> 被调用或 <code>C</code> 超时，那么只有 <code>C</code> 及其后代 (<code>E</code>) 会被取消，<code>D</code> 和其后代 (<code>F</code>, <code>G</code>) 不受影响。</li>
<li>这种机制使得可以精确地控制并发操作的生命周期，实现细粒度的取消和超时管理。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><code>context</code> 包是 Go 语言并发编程中一个设计精巧且功能强大的工具。它通过一套统一的接口和创建函数，解决了 Goroutine 之间传递控制信号、管理超时和传递请求元数据等核心难题。正确且熟练地运用 <code>context.Context</code>，不仅能够显著提升 Go 程序的并发控制能力和资源管理效率，还能使代码结构更加清晰，易于理解和维护。在现代 Go 应用程序，尤其是微服务和高并发系统中，<code>context.Context</code> 的使用几乎无处不在，是构建健壮系统的必备技能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/7642665c9bbb/">https://blog.tbf1211.xx.kg/7642665c9bbb/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/goroutine/">goroutine</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/6a755772301d/" title="Golang errgroup.Group 并发模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang errgroup.Group 并发模式详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，sync/errgroup 包提供了一个 Group 类型，它是对 sync.WaitGroup 和 context 包的封装，旨在更优雅地处理并发 goroutine 组的错误和取消。它使得在多个 goroutine 中执行任务，并在任何一个 goroutine 返回错误时，能够及时通知并取消其他 goroutine，同时等待所有 goroutine 完成变得更简单。  核心思想：errgroup.Group 允许你并行执行一组任务。如果其中任何一个任务失败，它会自动取消所有正在运行的任务，并聚合它们的错误。它简化了并行任务的启动、context 信号传递、错误收集和等待所有任务完成的逻辑。   一、为什么需要 errgroup.Group？在 Go 语言中进行并发编程时，经常会遇到以下场景：  启动多个 goroutine 处理子任务：一个大任务可能需要分解成多个独立的子任务，并行的由不同的 goroutine 执行。 等待所有 goroutine 完成：主 goroutine 需要知道所有子任务都已完成才能继续或返回。 处理子任务的错误：任何一个子任务的...</div></div></div></a><a class="pagination-related" href="/544a32bf949e/" title="TypeScript泛型约束详解：精细化类型参数能力"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TypeScript泛型约束详解：精细化类型参数能力</div></div><div class="info-2"><div class="info-item-1"> TypeScript 泛型约束 (Generic Constraints) 是泛型机制中一个至关重要的概念。它允许我们限制泛型类型参数可以表示的类型范围。通过泛型约束，我们可以在泛型代码内部安全地访问泛型类型参数的特定属性或方法，从而编写出既通用又具备类型安全性的代码。  核心思想：泛型约束的本质是使用 extends 关键字来声明一个类型参数必须是某个特定类型或实现某个接口的子类型。这为编译器提供了足够的类型信息，使其能够在泛型函数、类或接口内部进行更精确的类型检查。   一、为什么需要泛型约束？在上一篇泛型详解中，我们了解到泛型允许我们编写处理任何类型的代码。但有时，我们希望泛型处理的类型具有某种共同的特性。 考虑一个场景：我们想编写一个函数，它接受一个列表，并返回列表中元素的长度之和。 问题示例： 12345678910111213function sumLengths&lt;T&gt;(items: T[]): number &#123;  let totalLength = 0;  for (let item of items) &#123;    // 报错: Pr...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6a755772301d/" title="Golang errgroup.Group 并发模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-04</div><div class="info-item-2">Golang errgroup.Group 并发模式详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，sync/errgroup 包提供了一个 Group 类型，它是对 sync.WaitGroup 和 context 包的封装，旨在更优雅地处理并发 goroutine 组的错误和取消。它使得在多个 goroutine 中执行任务，并在任何一个 goroutine 返回错误时，能够及时通知并取消其他 goroutine，同时等待所有 goroutine 完成变得更简单。  核心思想：errgroup.Group 允许你并行执行一组任务。如果其中任何一个任务失败，它会自动取消所有正在运行的任务，并聚合它们的错误。它简化了并行任务的启动、context 信号传递、错误收集和等待所有任务完成的逻辑。   一、为什么需要 errgroup.Group？在 Go 语言中进行并发编程时，经常会遇到以下场景：  启动多个 goroutine 处理子任务：一个大任务可能需要分解成多个独立的子任务，并行的由不同的 goroutine 执行。 等待所有 goroutine 完成：主 goroutine 需要知道所有子任务都已完成才能继续或返回。 处理子任务的错误：任何一个子任务的...</div></div></div></a><a class="pagination-related" href="/9f5a2c0e7ea7/" title="Goroutine 相比 OS 线程，为什么能规模化？"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">Goroutine 相比 OS 线程，为什么能规模化？</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是其并发模型的核心。与传统的操作系统 (OS) 线程相比，Goroutine 展现出了惊人的规模化能力，使得 Go 程序能够轻松地并发处理成千上万甚至数百万的任务。这种规模化的差异并非偶然，而是由 Goroutine 独特的设计哲学和 Go 运行时（runtime）的智能调度机制所决定的。  核心思想：Goroutine 之所以能规模化，是因为它是一种轻量级的用户态协程，由 Go 运行时在少数 OS 线程上进行多路复用和调度，从而避免了 OS 线程的高开销和上下文切换代价。   一、Goroutine 与 OS 线程的本质区别在深入探讨为什么 Goroutine 能够规模化之前，我们需要理解它与 OS 线程之间的根本不同。 1.1 OS 线程 (Operating System Thread) 内核态实体：OS 线程是由操作系统内核调度的执行单元。每次创建、销毁或切换线程都需要进行系统调用（进入内核态），这会带来较大的开销。 内存开销大：每个 OS 线程通常会分配一个固定大小的栈（例如，Linux 上默认 8MB），即使实际只使用了很小一部...</div></div></div></a><a class="pagination-related" href="/099de403ef3d/" title="Golang 缓冲Channel和无缓冲Channel的区别"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Golang 缓冲Channel和无缓冲Channel的区别</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言的并发编程模型中，Channel 是 Goroutine 之间通信和同步的核心机制。Channel 提供了一种安全、同步的方式来传递数据。根据其容量大小，Channel 可以分为两种类型：无缓冲 Channel (Unbuffered Channel) 和 缓冲 Channel (Buffered Channel)。理解这两种 Channel 的区别以及它们各自的适用场景，是编写高效、正确 Go 并发代码的关键。  核心思想：无缓冲 Channel 强调“同步”通信，发送方和接收方必须同时就绪。缓冲 Channel 则允许“异步”通信，发送方可以在接收方未就绪时发送数据，但容量有限。   一、Channel 简介在 Go 中，Channel 是类型化的管道，可以通过它们发送和接收特定类型的值。它遵循“通过通信共享内存，而不是通过共享内存来通信”的并发哲学。 声明 Channel 的基本语法： 12345// 声明一个传递 int 类型数据的无缓冲 Channelvar ch1 chan int// 声明一个传递 string 类型数据的缓冲 Channel，容量为...</div></div></div></a><a class="pagination-related" href="/98c39f8e2307/" title="Go 语言协程设计与调度原理"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-05</div><div class="info-item-2">Go 语言协程设计与调度原理</div></div><div class="info-2"><div class="info-item-1"> Go 语言以其强大的并发特性而闻名，其核心是轻量级协程 (Goroutine) 和高效的调度器。理解 Goroutine 的设计理念以及 Go 运行时如何调度这些协程，对于编写高性能、高并发的 Go 应用程序至关重要。本文将深入探讨 Go 语言协程的设计哲学，并详细解析其背后支撑的 GMP 调度模型。  核心概念：  Goroutine：Go 语言的轻量级并发单元，用户态线程。 GMP 模型：Go 语言运行时调度 Goroutine 的核心模型，由 G (Goroutine)、M (Machine&#x2F;Thread)、P (Processor) 三要素组成。     一、Go 语言协程 (Goroutine) 的设计哲学传统的并发编程通常基于操作系统线程。虽然线程提供了并发能力，但它们也带来了不小的开销：  创建&#x2F;销毁开销大：创建和销毁线程需要向操作系统内核申请资源，涉及系统调用，开销较大。 上下文切换开销大：线程的上下文切换由操作系统内核完成，需要保存和恢复大量的寄存器信息，开销较大。 内存消耗大：每个线程通常需要 MB 级别的栈空间，大量线程会导致内存消耗巨...</div></div></div></a><a class="pagination-related" href="/7601ab41dda6/" title="Go语言并发与并行详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">Go语言并发与并行详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言（Golang） 被设计为一门天然支持并发的语言，其并发模型是基于 CSP (Communicating Sequential Processes) 理论的实现。Go 语言通过轻量级的 Goroutine (协程) 和原生的 Channel (管道) 机制，极大地简化了并发编程的复杂性，使得开发者能够更容易地编写出高并发、高性能的应用程序。  核心思想：不要通过共享内存来通信；相反，通过通信来共享内存。 这是 Go 并发哲学中的核心原则。   一、并发 (Concurrency) 与并行 (Parallelism)在深入 Go 语言的并发机制之前，理解并发与并行的区别至关重要。 1.1 并发 (Concurrency) 定义：并发是指系统能够同时处理多个任务的能力。这些任务不一定在同一时刻运行，它们可能在单个 CPU 核心上通过时间片轮转的方式快速切换执行，给人一种“同时进行”的错觉。 特性： 处理多个任务：关注如何设计程序来处理事件流，即使只有一个处理器。 任务切换：通过快速切换执行上下文来模拟同时执行。 目的：提高程序的吞吐量和响应速度。   类比：一个厨师可以在...</div></div></div></a><a class="pagination-related" href="/49c9c17349e3/" title="Go语言常用设计模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">Go语言常用设计模式详解</div></div><div class="info-2"><div class="info-item-1"> 设计模式是对在特定情境下，反复出现的问题提供一套成熟的、可复用的解决方案。Go 语言以其简洁、并发优先的特性，在实现设计模式时通常会有其独特的“Go 惯例”，有时会与传统面向对象设计模式的实现有所不同。本篇将探讨 Go 语言中常用的设计模式，并结合 Go 的特性给出实现示例。  核心思想：Go 语言的设计模式实现通常倾向于简洁、组合而非继承、接口优先以及利用 Goroutine 和 Channel 进行并发处理。   一、Go 语言与设计模式的哲学Go 语言在设计模式的实践上，有一些与传统 OOP 语言不同的哲学：  组合优于继承：Go 没有类继承的概念，而是通过结构体嵌入（Composition）和接口（Interfaces）来实现代码复用和多态。 接口优先：Go 的接口是隐式实现的（implicit interface satisfaction），任何类型只要实现了接口定义的所有方法，就自然地实现了该接口。这使得接口更加灵活，鼓励“小接口，大组合”的原则。 并发原语：Goroutine 和 Channel 是 Go 语言的核心并发原语，许多设计模式在 Go 中会自然融入并发...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">495</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81context-%E5%8C%85%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">一、context 包的必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81context-Context-%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3"><span class="toc-text">二、context.Context 接口详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81context-%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%A1%8D%E7%94%9F"><span class="toc-text">三、context 的创建与衍生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%B9-Context%EF%BC%9Acontext-Background-%E5%92%8C-context-TODO"><span class="toc-text">3.1 根 Context：context.Background() 和 context.TODO()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-context-WithCancel-parent-Context-%EF%BC%9A%E5%8F%96%E6%B6%88%E5%9E%8B-Context"><span class="toc-text">3.2 context.WithCancel(parent Context)：取消型 Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-context-WithTimeout-parent-Context-timeout-time-Duration-%EF%BC%9A%E8%B6%85%E6%97%B6%E5%9E%8B-Context"><span class="toc-text">3.3 context.WithTimeout(parent Context, timeout time.Duration)：超时型 Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-context-WithDeadline-parent-Context-deadline-time-Time-%EF%BC%9A%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E5%9E%8B-Context"><span class="toc-text">3.4 context.WithDeadline(parent Context, deadline time.Time)：截止时间型 Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-context-WithValue-parent-Context-key-val-any-%EF%BC%9A%E5%80%BC%E5%9E%8B-Context"><span class="toc-text">3.5 context.WithValue(parent Context, key, val any)：值型 Context</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Context-%E7%9A%84%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">四、Context 的传递规则与最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Context-%E6%A0%91%E7%9A%84%E5%8F%96%E6%B6%88%E4%BC%A0%E6%92%AD%E7%A4%BA%E6%84%8F"><span class="toc-text">五、Context 树的取消传播示意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"/></a><div class="content"><a class="title" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</a><time datetime="2025-12-31T22:24:00.000Z" title="发表于 2026-01-01 06:24:00">2026-01-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>