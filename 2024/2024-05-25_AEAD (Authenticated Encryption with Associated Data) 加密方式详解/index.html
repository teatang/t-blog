<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AEAD (Authenticated Encryption with Associated Data) 加密方式详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AEAD (Authenticated Encryption with Associated Data)，即带关联数据的认证加密，是现代密码学中的一个重要概念和加密模式。它不仅仅提供传统加密算法的机密性 (Confidentiality)，还能同时保障数据的完整性 (Integrity) 和真实性 (Authenticity)。此外，AEAD 模式允许对“关联数据”进行认证，这些数据不需要加密，">
<meta property="og:type" content="article">
<meta property="og:title" content="AEAD (Authenticated Encryption with Associated Data) 加密方式详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-05-25_AEAD%20(Authenticated%20Encryption%20with%20Associated%20Data)%20%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="AEAD (Authenticated Encryption with Associated Data)，即带关联数据的认证加密，是现代密码学中的一个重要概念和加密模式。它不仅仅提供传统加密算法的机密性 (Confidentiality)，还能同时保障数据的完整性 (Integrity) 和真实性 (Authenticity)。此外，AEAD 模式允许对“关联数据”进行认证，这些数据不需要加密，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2024-05-24T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-23T08:30:48.741Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="AEAD">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AEAD (Authenticated Encryption with Associated Data) 加密方式详解",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-05-25_AEAD%20(Authenticated%20Encryption%20with%20Associated%20Data)%20%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2024-05-24T22:24:00.000Z",
  "dateModified": "2025-10-23T08:30:48.741Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-05-25_AEAD%20(Authenticated%20Encryption%20with%20Associated%20Data)%20%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AEAD (Authenticated Encryption with Associated Data) 加密方式详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">165</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">160</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">AEAD (Authenticated Encryption with Associated Data) 加密方式详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">AEAD (Authenticated Encryption with Associated Data) 加密方式详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-05-24T22:24:00.000Z" title="发表于 2024-05-25 06:24:00">2024-05-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-05-25_AEAD%20(Authenticated%20Encryption%20with%20Associated%20Data)%20%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>AEAD (Authenticated Encryption with Associated Data)</strong>，即<strong>带关联数据的认证加密</strong>，是现代密码学中的一个重要概念和加密模式。它不仅仅提供传统加密算法的<strong>机密性 (Confidentiality)</strong>，还能同时保障数据的<strong>完整性 (Integrity)</strong> 和<strong>真实性 (Authenticity)</strong>。此外，AEAD 模式允许对“关联数据”进行认证，这些数据不需要加密，但其完整性也需要被验证。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：将加密（提供机密性）和消息认证码 (MAC, 提供完整性和真实性) 组合到一个单一的密码操作中，同时允许对非加密数据进行认证。</p>
</div>

<h2 id="一、为什么需要-AEAD？"><a href="#一、为什么需要-AEAD？" class="headerlink" title="一、为什么需要 AEAD？"></a>一、为什么需要 AEAD？</h2><p>在 AEAD 出现之前，密码学中存在两种主要的安全目标：</p>
<ol>
<li><strong>机密性 (Confidentiality)</strong>：通过加密手段（如 AES、ChaCha20）使未经授权的方无法读取数据。</li>
<li><strong>完整性 (Integrity) 和真实性 (Authenticity)</strong>：通过消息认证码 (MAC) 或数字签名来确保数据在传输过程中未被篡改，并确认数据确实来自声称的发送方。</li>
</ol>
<p>传统的加密方式（如 ECB、CBC 模式的 AES）和消息认证码（如 HMAC）是单独的组件。开发者需要手动将它们组合起来，以实现所谓的<strong>认证加密 (Authenticated Encryption)</strong>。然而，不正确的组合方式可能会引入严重的安全漏洞。</p>
<h3 id="1-1-“组合”认证加密的陷阱"><a href="#1-1-“组合”认证加密的陷阱" class="headerlink" title="1.1 “组合”认证加密的陷阱"></a>1.1 “组合”认证加密的陷阱</h3><p>有三种常见的组合方式，但只有一种是安全的：</p>
<ul>
<li><strong>Encrypt-then-MAC (EthenM)</strong>：先加密明文得到密文，然后对密文计算 MAC 标签。这是<strong>唯一安全</strong>的组合方式。</li>
<li><strong>MAC-then-Encrypt (MthenE)</strong>：先对明文计算 MAC 标签，然后将明文和 MAC 标签一起加密。<ul>
<li><strong>问题</strong>：即使密文被篡改，攻击者也可能在不破坏 MAC 结构的情况下进行修改，从而导致解密会报错，但攻击者可能从错误信息中获取有用信息（Padding Oracle Attack）。此外，MAC 不保护明文的机密性。</li>
</ul>
</li>
<li><strong>Encrypt-and-MAC (EandM)</strong>：分别对明文进行加密和 MAC 计算。<ul>
<li><strong>问题</strong>：这可能会泄露明文的模式，因为 MAC 不涉及加密。攻击者可以独立篡改密文和 MAC，然后尝试匹配它们以通过验证。</li>
</ul>
</li>
</ul>
<p>由于开发者经常会错误地组合加密和 MAC 算法，导致各种安全漏洞，密码学界开始倡导使用<strong>认证加密</strong>原语，其中 AEAD 模式是其中非常成功且广泛采用的一种。</p>
<h2 id="二、AEAD-的核心概念"><a href="#二、AEAD-的核心概念" class="headerlink" title="二、AEAD 的核心概念"></a>二、AEAD 的核心概念</h2><p>AEAD 模式将机密性、完整性和真实性整合到一个单一的算法操作中。</p>
<h3 id="2-1-主要功能"><a href="#2-1-主要功能" class="headerlink" title="2.1 主要功能"></a>2.1 主要功能</h3><ol>
<li><strong>加密 (Encryption)</strong>：将明文转换为无法解读的密文，提供机密性。</li>
<li><strong>认证 (Authentication)</strong>：生成一个 MAC 标签，用于验证密文和关联数据的完整性及真实性。</li>
<li><strong>关联数据 (Associated Data, AD)</strong>：AEAD 模式的一个独特之处。它允许在加密和认证过程中包含一些<strong>不加密但需要认证</strong>的数据。这些数据在解密和验证时也必须提供，且不能被篡改。<ul>
<li><strong>应用场景</strong>：网络协议中的头部信息（如 IP 地址、端口号、协议版本），会话 ID，时间戳等。这些信息不需要保密，但其完整性对协议的正确运行至关重要。如果 AD 被篡改，解密和验证过程就会失败。</li>
</ul>
</li>
</ol>
<h3 id="2-2-AEAD-的输出"><a href="#2-2-AEAD-的输出" class="headerlink" title="2.2 AEAD 的输出"></a>2.2 AEAD 的输出</h3><p>AEAD 加密操作通常会产生两个输出：</p>
<ul>
<li><strong>密文 (Ciphertext)</strong>：加密后的明文。</li>
<li><strong>认证标签 (Authentication Tag &#x2F; MAC Tag)</strong>：用于验证密文和关联数据的完整性与真实性的密文。</li>
</ul>
<p>解密时，需要提供密文、Nonce、密钥和关联数据。如果 MAC 标签验证不通过，则解密失败，不会返回任何明文。这被称为 <strong>“Fail-fast”</strong> 特性，可以防止攻击者通过操控密文来尝试各种解密结果。</p>
<h3 id="2-3-Nonce-IV-Initialization-Vector"><a href="#2-3-Nonce-IV-Initialization-Vector" class="headerlink" title="2.3 Nonce &#x2F; IV (Initialization Vector)"></a>2.3 Nonce &#x2F; IV (Initialization Vector)</h3><p>与所有流密码或块密码的工作模式一样，AEAD 模式也需要一个<strong>随机数 (Nonce)</strong> 或<strong>初始化向量 (IV)</strong>。</p>
<ul>
<li><strong>Nonce 的要求</strong>：<ul>
<li><strong>唯一性</strong>：对于给定的密钥，每个加密操作使用的 Nonce 都必须是唯一的。重复使用 Nonce 是灾难性的安全漏洞，会导致密钥流的重复利用，从而泄露密钥并使得密文易被攻击。</li>
<li><strong>无序性</strong>：不需要是随机的，但必须是唯一的。通常使用递增计数器或随机数生成。</li>
<li><strong>不保密</strong>：Nonc 不需要保密，通常与密文和标签一起公开传输。</li>
</ul>
</li>
</ul>
<h2 id="三、常见的-AEAD-模式"><a href="#三、常见的-AEAD-模式" class="headerlink" title="三、常见的 AEAD 模式"></a>三、常见的 AEAD 模式</h2><h3 id="3-1-AES-GCM-Galois-Counter-Mode"><a href="#3-1-AES-GCM-Galois-Counter-Mode" class="headerlink" title="3.1 AES-GCM (Galois&#x2F;Counter Mode)"></a>3.1 AES-GCM (Galois&#x2F;Counter Mode)</h3><ul>
<li><strong>特点</strong>：<ul>
<li><strong>底层算法</strong>：基于 AES 块密码的计数器模式 (CTR) 进行加密，并使用 Galois 字段乘法来计算 MAC。</li>
<li><strong>性能</strong>：在支持 AES-NI 硬件指令的 CPU 上表现出色，加密和认证速度都非常快。</li>
<li><strong>广泛应用</strong>：广泛应用于 TLS&#x2F;SSL (HTTPS)、IPSec、SSH 等协议中。</li>
</ul>
</li>
<li><strong>Nonce 大小</strong>：通常为 96 位（12 字节）。</li>
</ul>
<h3 id="3-2-ChaCha20-Poly1305"><a href="#3-2-ChaCha20-Poly1305" class="headerlink" title="3.2 ChaCha20-Poly1305"></a>3.2 ChaCha20-Poly1305</h3><ul>
<li><strong>特点</strong>：<ul>
<li><strong>底层算法</strong>：基于 ChaCha20 流密码进行加密，并使用 Poly1305 消息认证码。</li>
<li><strong>性能</strong>：在没有 AES-NI 硬件支持的 CPU 上（如许多移动设备），ChaCha20-Poly1305 表现通常优于 AES-GCM，因为它完全可以通过软件高效实现。</li>
<li><strong>抗侧信道攻击</strong>：纯软件实现，且不涉及查找表，因此对某些侧信道攻击有更强的抵抗力。</li>
<li><strong>广泛应用</strong>：在 TLS 1.2&#x2F;1.3 中作为重要选项，特别是 Google Chrome 浏览器和许多移动应用的首选。WireGuard VPN 也将其作为核心加密套件。</li>
</ul>
</li>
<li><strong>Nonce 大小</strong>：通常为 96 位（12 字节）。</li>
</ul>
<h3 id="3-3-其他-AEAD-模式"><a href="#3-3-其他-AEAD-模式" class="headerlink" title="3.3 其他 AEAD 模式"></a>3.3 其他 AEAD 模式</h3><ul>
<li><strong>GCM-SIV</strong>：旨在解决 AES-GCM 非重复 Nonce 的问题，提供了 <strong>Nonce Reuse Resistance</strong>，即使 Nonce 重复也能保证数据安全（但依然不能保证机密性，只是 MAC 不会被伪造）。</li>
<li><strong>OCB (Offset Codebook Mode)</strong>：一个高效的 AEAD 模式，但由于专利问题，不像 GCM 那样普及。</li>
</ul>
<h2 id="四、AEAD-的优势"><a href="#四、AEAD-的优势" class="headerlink" title="四、AEAD 的优势"></a>四、AEAD 的优势</h2><ol>
<li><strong>安全性高</strong>：防止了不正确组合加密和 MAC 算法造成的潜在漏洞。</li>
<li><strong>简单易用</strong>：开发者只需选择一个 AEAD 算法，提供密钥、Nonce、明文和关联数据，算法内部会自动处理加密和认证的复杂逻辑。</li>
<li><strong>机密性、完整性、真实性保障</strong>：一次操作同时满足所有三个安全目标。</li>
<li><strong>防范篡改</strong>：即使攻击者只修改密文或关联数据的一个比特，MAC 验证也会失败，接收方能够立即发现篡改。</li>
<li><strong>Fail-fast 机制</strong>：如果认证失败，解密操作会中止并返回错误，避免泄露部分解密的数据，防止各种 Padding Oracle Attack。</li>
<li><strong>保护非加密数据</strong>：关联数据机制非常实用，避免了为保护少量非敏感数据也要对其进行加密的开销。</li>
</ol>
<h2 id="五、AEAD-的应用场景"><a href="#五、AEAD-的应用场景" class="headerlink" title="五、AEAD 的应用场景"></a>五、AEAD 的应用场景</h2><ul>
<li><strong>TLS&#x2F;SSL (HTTPS)</strong>：AEAD 模式是 TLS 1.2 及更高版本中的标准加密套件。</li>
<li><strong>VPN 协议</strong>：例如 WireGuard 使用 ChaCha20-Poly1305。</li>
<li><strong>数据存储</strong>：加密文件系统或数据库字段时，使用 AEAD 确保数据安全不被篡改。</li>
<li><strong>网络通信协议</strong>：任何需要可靠、安全通信的协议。</li>
<li><strong>密钥管理和分发</strong>：保护传输中的密钥。</li>
</ul>
<h2 id="六、Go-语言实现-AES-GCM-AEAD"><a href="#六、Go-语言实现-AES-GCM-AEAD" class="headerlink" title="六、Go 语言实现 AES-GCM AEAD"></a>六、Go 语言实现 AES-GCM AEAD</h2><p>Go 语言标准库通过 <code>crypto/cipher</code> 包提供了 AEAD 接口，并有 <code>crypto/aes</code> 和 <code>golang.org/x/crypto/chacha20poly1305</code> 等实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// generateRandomBytes 生成指定长度的随机字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateRandomBytes</span><span class="params">(n <span class="type">int</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	_, err := io.ReadFull(rand.Reader, b)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;生成随机字节失败: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 生成 256 位 (32 字节) 的 AES 密钥</span></span><br><span class="line">	key, err := generateRandomBytes(<span class="number">32</span>) <span class="comment">// AES-256 需要 32 字节的密钥</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;生成密钥失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;密钥 (Hex): %x\n&quot;</span>, key)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 创建 AES 块密码器</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;创建 AES 块密码器失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 创建 AES-GCM AEAD 密码器</span></span><br><span class="line">	æs GCM cipher.AEAD</span><br><span class="line">	gcm, err := cipher.NewGCM(block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;创建 GCM AEAD 密码器失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 生成 Nonce (必须是随机的，且每个加密操作必须不同，但不需要保密)</span></span><br><span class="line">	<span class="comment">// GCM 的 Nonce 大小通常是 12 字节</span></span><br><span class="line">	nonce, err := generateRandomBytes(gcm.NonceSize())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;生成 Nonce 失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Nonce (Hex): %x\n&quot;</span>, nonce)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 定义明文和附加认证数据 (Associated Data, AD)</span></span><br><span class="line">	plaintext := []<span class="type">byte</span>(<span class="string">&quot;这是需要加密和验证的绝密消息！Go语言 AES-GCM AEAD 示例。&quot;</span>)</span><br><span class="line">	associatedData := []<span class="type">byte</span>(<span class="string">&quot;这是附加认证数据，不加密但需要验证完整性。例如，协议版本号或会话ID。&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n原始明文: %s\n&quot;</span>, <span class="type">string</span>(plaintext))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;附加认证数据 (AD): %s\n&quot;</span>, <span class="type">string</span>(associatedData))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 加密并生成 MAC 标签</span></span><br><span class="line">	<span class="comment">// Seal 函数的 out 缓冲区会包含密文和 MAC 标签</span></span><br><span class="line">	<span class="comment">// 格式通常是 nonce + ciphertext + tag</span></span><br><span class="line">	ciphertextWithTag := gcm.Seal(<span class="literal">nil</span>, nonce, plaintext, associatedData)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;\n加密后的数据 (密文+标签, Hex): %x\n&quot;</span>, ciphertextWithTag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 7. 解密并验证 MAC 标签</span></span><br><span class="line">	<span class="comment">// Open 函数会在解密前验证 MAC 标签，如果验证失败会返回错误</span></span><br><span class="line">	decryptedPlaintext, err := gcm.Open(<span class="literal">nil</span>, nonce, ciphertextWithTag, associatedData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;解密或MAC验证失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;解密后的明文: %s\n&quot;</span>, <span class="type">string</span>(decryptedPlaintext))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">string</span>(plaintext) == <span class="type">string</span>(decryptedPlaintext) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;\n加密、解密和MAC验证成功！数据完整且真实。&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;\n解密后的数据与原始数据不匹配，加密或解密失败。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 8. 模拟数据篡改，验证 MAC 机制</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 模拟数据篡改 ---&quot;</span>)</span><br><span class="line">	tamperedCiphertextWithTag := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(ciphertextWithTag))</span><br><span class="line">	<span class="built_in">copy</span>(tamperedCiphertextWithTag, ciphertextWithTag)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(tamperedCiphertextWithTag) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tamperedCiphertextWithTag[<span class="number">0</span>] ^= <span class="number">0x01</span> <span class="comment">// 修改第一个字节</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = gcm.Open(<span class="literal">nil</span>, nonce, tamperedCiphertextWithTag, associatedData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;尝试解密篡改数据 (预期失败): %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解密篡改数据成功 (不应该发生)! MAC 验证失效。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 9. 模拟 AD 篡改</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 模拟 AD 篡改 ---&quot;</span>)</span><br><span class="line">	tamperedAssociatedData := []<span class="type">byte</span>(<span class="string">&quot;篡改过的附加认证数据&quot;</span>)</span><br><span class="line">	_, err = gcm.Open(<span class="literal">nil</span>, nonce, ciphertextWithTag, tamperedAssociatedData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;尝试解密原始密文但 AD 篡改 (预期失败): %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;解密成功但 AD 篡改 (不应该发生)! MAC 验证失效。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 10. 模拟 Nonce 重复使用，理论上 GCM 应该返回错误（但 Go 的实现可能不会立即报错），但这是严重的安全性问题</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 模拟 Nonce 重复使用 ---&quot;</span>)</span><br><span class="line">	<span class="comment">// 使用相同的 Key, Nonce, Plaintext 和 AD 再次加密</span></span><br><span class="line">	<span class="comment">// 这里的目的是为了演示潜在的安全风险，实际应用中绝不能这样做</span></span><br><span class="line">	anotherCiphertextWithTag := gcm.Seal(<span class="literal">nil</span>, nonce, plaintext, associatedData)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;重复 Nonce 加密 (仅为演示，实际应用禁止): %x\n&quot;</span>, anotherCiphertextWithTag)</span><br><span class="line">	<span class="comment">// 在 GCM 中，Nonce 重复使用会导致：</span></span><br><span class="line">	<span class="comment">// 1. 如果你改变了 Plaintext，可能会引发密钥泄露。</span></span><br><span class="line">	<span class="comment">// 2. 攻击者可以通过分析两个密文之间的关系，推断出 MAC 密钥和部分明文。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">密钥 (Hex): 91d36d...</span><br><span class="line">Nonce (Hex): f154e5...</span><br><span class="line"></span><br><span class="line">原始明文: 这是需要加密和验证的绝密消息！Go语言 AES-GCM AEAD 示例。</span><br><span class="line">附加认证数据 (AD): 这是附加认证数据，不加密但需要验证完整性。例如，协议版本号或会话ID。</span><br><span class="line"></span><br><span class="line">加密后的数据 (密文+标签, Hex): 040f7b....</span><br><span class="line">解密后的明文: 这是需要加密和验证的绝密消息！Go语言 AES-GCM AEAD 示例。</span><br><span class="line"></span><br><span class="line">加密、解密和MAC验证成功！数据完整且真实。</span><br><span class="line"></span><br><span class="line">--- 模拟数据篡改 ---</span><br><span class="line">尝试解密篡改数据 (预期失败): cipher: message authentication failed</span><br><span class="line"></span><br><span class="line">--- 模拟 AD 篡改 ---</span><br><span class="line">尝试解密原始密文但 AD 篡改 (预期失败): cipher: message authentication failed</span><br><span class="line"></span><br><span class="line">--- 模拟 Nonce 重复使用 ---</span><br><span class="line">重复 Nonce 加密 (仅为演示，实际应用禁止): 040f7b....</span><br></pre></td></tr></table></figure>
<p>此 Go 语言示例演示了如何使用 <code>crypto/aes</code> 和 <code>crypto/cipher</code> 包实现 AES-GCM AEAD。它展示了密钥和 Nonce 的生成、数据的加密与解密、以及 MAC 标签对密文和关联数据完整性的保护。通过模拟篡改密文和 AD，你可以看到 AEAD 如何有效地检测并拒绝非法数据。最后，也再次强调了 Nonce 唯一性的重要性。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>AEAD 模式是现代密码学中的基石，它通过将机密性、完整性和真实性整合到单一操作中，大大简化了安全协议的设计和实现，降低了开发者因不当组合加密原语而引入安全漏洞的风险。AES-GCM 和 ChaCha20-Poly1305 是目前最主流和被推荐的 AEAD 算法，它们各自在不同的硬件环境下展现出最佳性能，并已成为 TLS 等关键协议的强制性或推荐组件。在任何需要数据机密性、完整性与真实性的应用中，优先选择 AEAD 模式是最佳实践。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-05-25_AEAD%20(Authenticated%20Encryption%20with%20Associated%20Data)%20%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2024/2024-05-25_AEAD%20(Authenticated%20Encryption%20with%20Associated%20Data)%20%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/AEAD/">AEAD</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-06-04_Mermaid%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%E6%96%87%E6%9C%AC%E6%8F%8F%E8%BF%B0%E7%94%9F%E6%88%90%E5%90%84%E7%A7%8D%E6%BC%82%E4%BA%AE%E5%9B%BE%E8%A1%A8/" title="Mermaid详解：用文本描述生成各种漂亮图表"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Mermaid详解：用文本描述生成各种漂亮图表</div></div><div class="info-2"><div class="info-item-1"> 在软件开发、项目管理和技术文档编写中，图表是传达复杂信息、说明系统架构、业务流程或交互逻辑的强大工具。然而，传统上绘制图表往往需要专门的图形编辑软件，操作繁琐，不易版本控制，也难以在文本文件中直接嵌入。这时，Mermaid 应运而生。Mermaid 是一个基于 JavaScript 的库，它允许你使用简单的类 Markdown 文本语法来定义和渲染各种图表，并将其嵌入到 Markdown、HTML 或其他 Web 环境中。它极大地简化了图表的创建、维护和版本控制，是现代文档编写的利器。  “Mermaid 的核心思想是‘图表即代码’。这意味着你可以像编写代码一样编写图表的逻辑，从而实现图表的版本控制、自动化生成和轻松分享。它让复杂的可视化变得触手可及。”   一、Mermaid 简介 官方网站：mermaid.live (在线编辑器) GitHub 仓库：mermaid-js&#x2F;mermaid  Mermaid 是一款基于 JavaScript 的图表绘制工具，它采用文本描述语言来定义图表结构，然后将其渲染成 SVG 或 PNG 格式的图形。它的目标是：  简化图表创建...</div></div></div></a><a class="pagination-related" href="/2024/2024-05-21_%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%20(Replay%20Attack)%20%E8%AF%A6%E8%A7%A3/" title="重放攻击 (Replay Attack) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">重放攻击 (Replay Attack) 详解</div></div><div class="info-2"><div class="info-item-1"> 重放攻击 (Replay Attack)，又称回放攻击或重播攻击，是计算机网络安全领域中的一种常见攻击方式。其基本原理是攻击者通过窃听（截获）合法的网络通信数据包，然后将这些截获到的数据包原封不动地重新发送给一个或多个目标系统，以此来欺骗系统或获得未授权的效应。即使攻击者不知道数据包内容的具体含义，也可以通过重放这些合法的数据包来达到攻击目的。  核心思想：攻击者窃取一次成功的会话或请求，并在之后的时间里重复发送这段数据，以冒充合法用户获得同样的权限或发起相同的操作。   一、重放攻击的工作原理重放攻击的步骤通常如下：  窃听 (Eavesdropping)：攻击者使用网络嗅探工具（如 Wireshark）在网络上监听和截获合法用户与服务器之间的通信。这可能包括登录凭证（尽管通常是哈希或加密的）、交易请求、授权令牌等。 截获 (Interception)：攻击者捕获到完整的、有效的通信数据包或消息序列。 重放 (Replay)：在一段时间之后，攻击者将这些截获到的数据包原封不动地重新发送给目标服务器。 欺骗 (Deception)：如果目标服务器没有有效的机制来验证请求的新鲜性...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-03-16_%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/" title="渗透测试原理详解：深入了解网络安全攻防"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-16</div><div class="info-item-2">渗透测试原理详解：深入了解网络安全攻防</div></div><div class="info-2"><div class="info-item-1"> 渗透测试（Penetration Testing） 是一种有目的、有计划的模拟攻击行为，旨在评估信息系统、网络、应用程序或组织的安全防护能力。它模拟恶意攻击者可能使用的技术和方法，主动发现系统中的安全漏洞、弱点和配置错误，并评估这些漏洞可能造成的潜在影响。渗透测试的最终目标是帮助组织识别并修复安全缺陷，提高整体的安全韧性，而非破坏或窃取数据。  核心思想：渗透测试像一次“模拟实战演习”，由专业的“红队”（渗透测试人员）扮演“黑客”，通过合法授权的攻击手段，挑战组织的“蓝队”（安全防护系统），从而发现真实世界中可能存在的安全盲点和薄弱环节。   一、为什么需要渗透测试？在当今高度互联的世界中，网络攻击日益频繁且复杂。传统的安全审计、漏洞扫描、代码审查等方法虽然重要，但它们往往局限于静态分析或已知漏洞的检测。渗透测试的价值在于：  主动发现未知漏洞：通过模拟真实攻击者的思维和手法，发现仅靠工具扫描难以识别的逻辑漏洞、业务漏洞和组合漏洞。 验证安全控制的有效性：测试已部署的安全设备（如防火墙、IDS&#x2F;IPS）、安全策略和人员响应机制是否能有效抵御攻击。 评估业务影响：清晰地...</div></div></div></a><a class="pagination-related" href="/2024/2024-05-21_%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%20(Replay%20Attack)%20%E8%AF%A6%E8%A7%A3/" title="重放攻击 (Replay Attack) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="info-item-2">重放攻击 (Replay Attack) 详解</div></div><div class="info-2"><div class="info-item-1"> 重放攻击 (Replay Attack)，又称回放攻击或重播攻击，是计算机网络安全领域中的一种常见攻击方式。其基本原理是攻击者通过窃听（截获）合法的网络通信数据包，然后将这些截获到的数据包原封不动地重新发送给一个或多个目标系统，以此来欺骗系统或获得未授权的效应。即使攻击者不知道数据包内容的具体含义，也可以通过重放这些合法的数据包来达到攻击目的。  核心思想：攻击者窃取一次成功的会话或请求，并在之后的时间里重复发送这段数据，以冒充合法用户获得同样的权限或发起相同的操作。   一、重放攻击的工作原理重放攻击的步骤通常如下：  窃听 (Eavesdropping)：攻击者使用网络嗅探工具（如 Wireshark）在网络上监听和截获合法用户与服务器之间的通信。这可能包括登录凭证（尽管通常是哈希或加密的）、交易请求、授权令牌等。 截获 (Interception)：攻击者捕获到完整的、有效的通信数据包或消息序列。 重放 (Replay)：在一段时间之后，攻击者将这些截获到的数据包原封不动地重新发送给目标服务器。 欺骗 (Deception)：如果目标服务器没有有效的机制来验证请求的新鲜性...</div></div></div></a><a class="pagination-related" href="/2023/2023-10-12_%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%A2%84%E9%98%B2%EF%BC%9A%E6%9E%84%E5%BB%BA%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8%E9%98%B2%E7%BA%BF/" title="常见网络攻击详解与预防：构建数字安全防线"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">常见网络攻击详解与预防：构建数字安全防线</div></div><div class="info-2"><div class="info-item-1"> 在数字时代，网络攻击已成为无处不在的威胁。从个人数据泄露到企业系统瘫痪，网络攻击的危害日益增长，形式也越来越多样化。理解这些S攻击类型、攻击原理以及如何有效预防它们，是构建强大数字安全防线的基石。本文将详细介绍一些最常见的网络攻击及其相应的防范措施。  “网络安全不是一蹴而就的，而是一个持续不断的过程，需要技术、策略和人的共同努力。”   一、概述：网络攻击的种类与威胁网络攻击通常利用系统、应用或协议的漏洞，试图破坏数据的机密性（Confidentiality）、完整性（Integrity）和可用性（Availability），即所谓的 CIA 三要素。 根据攻击目标和手段，网络攻击可以分为多种类型：  拒绝服务攻击 (DoS&#x2F;DDoS)：破坏系统的可用性。 数据窃取&#x2F;泄露：破坏数据的机密性。 数据篡改：破坏数据的完整性。 恶意程序感染：破坏系统的可控性，窃取数据或进行其他恶意活动。 社会工程学攻击：利用人性的弱点进行欺骗。  接下来，我们将详细解析几种最常见的攻击类型。 二、常见网络攻击详解与预防2.1 拒绝服务攻击 (DoS &#x2F; DDoS)2....</div></div></div></a><a class="pagination-related" href="/2023/2023-12-21_JWT%20(JSON%20Web%20Tokens)%20%E8%AF%A6%E8%A7%A3/" title="JWT (JSON Web Tokens) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="info-item-2">JWT (JSON Web Tokens) 详解</div></div><div class="info-2"><div class="info-item-1"> JWT (JSON Web Token) 是一个开放标准 (RFC 7519)，它定义了一种简洁、自包含且安全的方式，用于在各方之间安全地传输信息。这些信息通过数字签名进行验证，可以被信任。JWT 通常用作无状态 (Stateless) 认证机制，替代传统的 Session-Cookie 模式。  核心思想：将用户认证信息和少量授权信息编码进 Token 本身，并通过签名确保其不可篡改。 服务端无需存储 Session 状态，只需验证 Token 即可。   一、为什么需要 JWT？传统的基于 Session-Cookie 的认证方式有其局限性：  有状态 (Stateful)：服务端需要存储每个用户的 Session 信息。随着用户量增加，存储和管理 Session 成为负担，特别是分布式部署和微服务架构下，Session 共享和同步变得复杂。 跨域问题：Cookie 默认是同源策略，跨域请求携带 Cookie 会比较复杂，需要复杂的 CORS (Cross-Origin Resource Sharing) 配置。 移动端不友好：移动应用通常不依赖 Cookie，需要更灵活的...</div></div></div></a><a class="pagination-related" href="/2024/2024-01-18_%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0Token%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%8F%90%E5%8D%87%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%9A%84%E8%AE%A4%E8%AF%81%E7%AD%96%E7%95%A5/" title="无感刷新Token详解：提升用户体验与系统安全的认证策略"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="info-item-2">无感刷新Token详解：提升用户体验与系统安全的认证策略</div></div><div class="info-2"><div class="info-item-1"> 在现代 Web 和移动应用中，基于 Token 的认证方式（如 JWT）已成为主流。它解决了传统 Session-Cookie 认证在分布式系统和跨域场景下的诸多痛点。然而，Token 的有效期问题又带来了新的挑战：如果 Access Token 长期有效，一旦泄露风险巨大；如果短期有效，用户又会频繁因 Token 过期而被迫重新登录，严重影响用户体验。无感刷新 Token (Silent Token Refresh) 正是为了解决这一矛盾而生，它旨在提升安全性、兼顾用户体验，让用户在不感知的情况下，始终保持登录状态。  “无感刷新 Token 的核心思想是：使用一个短期有效的 Access Token 负责日常业务访问，同时使用一个长期有效但受严密保护的 Refresh Token 来在 Access Token 过期时重新获取新的 Access Token，从而实现长期登录且不牺牲安全性的目标。”   一、为什么需要无感刷新 Token？在基于 Token 的认证系统中，通常会涉及到两种 Token：  Access Token (访问令牌)：  用途：用于访问受保护的资源...</div></div></div></a><a class="pagination-related" href="/2024/2024-02-08_DHCP%20(%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE)%20%E8%AF%A6%E8%A7%A3/" title="DHCP (动态主机配置协议) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-08</div><div class="info-item-2">DHCP (动态主机配置协议) 详解</div></div><div class="info-2"><div class="info-item-1"> DHCP (Dynamic Host Configuration Protocol)，即动态主机配置协议，是一个应用层协议，它允许服务器动态地为客户端（例如计算机、智能手机、物联网设备等）分配 IP 地址和其他网络配置参数。DHCP 是目前最常用的网络配置方式，极大地简化了网络管理，避免了手动配置 IP 地址可能出现的冲突和错误。  核心思想：自动化分配 IP 地址和其他网络参数，简化网络管理，提高效率。   一、为什么需要 DHCP？在没有 DHCP 的情况下，每台连接到 TCP&#x2F;IP 网络的设备都需要手动配置以下信息：  IP 地址：设备在网络上的唯一标识。 子网掩码：用于区分 IP 地址的网络部分和主机部分。 默认网关：设备访问外部网络的路由器的 IP 地址。 DNS 服务器地址：用于将域名解析为 IP 地址的服务器。  手动配置的弊端显而易见：  复杂且耗时：对于大型网络，手动配置数百甚至数千台设备的网络参数是一项繁琐且容易出错的工作。 易出错：人为输入错误可能导致网络连接问题或 IP 地址冲突。 IP 地址冲突：如果不小心将同一个 IP 地址分配给多台设备，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">165</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">160</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-AEAD%EF%BC%9F"><span class="toc-text">一、为什么需要 AEAD？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E2%80%9C%E7%BB%84%E5%90%88%E2%80%9D%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-text">1.1 “组合”认证加密的陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81AEAD-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、AEAD 的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-text">2.1 主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-AEAD-%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">2.2 AEAD 的输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Nonce-IV-Initialization-Vector"><span class="toc-text">2.3 Nonce &#x2F; IV (Initialization Vector)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84-AEAD-%E6%A8%A1%E5%BC%8F"><span class="toc-text">三、常见的 AEAD 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-AES-GCM-Galois-Counter-Mode"><span class="toc-text">3.1 AES-GCM (Galois&#x2F;Counter Mode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ChaCha20-Poly1305"><span class="toc-text">3.2 ChaCha20-Poly1305</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%85%B6%E4%BB%96-AEAD-%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.3 其他 AEAD 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81AEAD-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">四、AEAD 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81AEAD-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、AEAD 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-AES-GCM-AEAD"><span class="toc-text">六、Go 语言实现 AES-GCM AEAD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言指向指针的指针(Pointer to Pointer)详解"/></a><div class="content"><a class="title" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解">Go语言指向指针的指针(Pointer to Pointer)详解</a><time datetime="2025-09-30T22:24:00.000Z" title="发表于 2025-10-01 06:24:00">2025-10-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>