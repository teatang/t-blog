<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python yield 关键字深度详解：迭代器、生成器与协程 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python 的 yield 关键字 是构建生成器 (Generators) 和协程 (Coroutines) 的核心。它将一个普通的函数转化成一个可以在多次调用之间“暂停”和“恢复”执行的特殊函数，从而实现惰性计算和并发编程的强大能力。理解 yield 的工作原理对于编写高性能、内存高效和并发的 Python 代码至关重要。  核心思想：yield 使得函数不是一次性计算并返回所有结果，而是在">
<meta property="og:type" content="article">
<meta property="og:title" content="Python yield 关键字深度详解：迭代器、生成器与协程">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-08-26_Python%20yield%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Python 的 yield 关键字 是构建生成器 (Generators) 和协程 (Coroutines) 的核心。它将一个普通的函数转化成一个可以在多次调用之间“暂停”和“恢复”执行的特殊函数，从而实现惰性计算和并发编程的强大能力。理解 yield 的工作原理对于编写高性能、内存高效和并发的 Python 代码至关重要。  核心思想：yield 使得函数不是一次性计算并返回所有结果，而是在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg">
<meta property="article:published_time" content="2024-08-25T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-15T04:52:41.589Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="编程语法">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="程序设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python yield 关键字深度详解：迭代器、生成器与协程",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-08-26_Python%20yield%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg",
  "datePublished": "2024-08-25T22:24:00.000Z",
  "dateModified": "2025-10-15T04:52:41.589Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-08-26_Python%20yield%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python yield 关键字深度详解：迭代器、生成器与协程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">137</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">52</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python yield 关键字深度详解：迭代器、生成器与协程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python yield 关键字深度详解：迭代器、生成器与协程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-25T22:24:00.000Z" title="发表于 2024-08-26 06:24:00">2024-08-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-08-26_Python%20yield%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Python 的 <code>yield</code> 关键字</strong> 是构建<strong>生成器 (Generators)</strong> 和<strong>协程 (Coroutines)</strong> 的核心。它将一个普通的函数转化成一个可以在多次调用之间“暂停”和“恢复”执行的特殊函数，从而实现惰性计算和并发编程的强大能力。理解 <code>yield</code> 的工作原理对于编写高性能、内存高效和并发的 Python 代码至关重要。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：<code>yield</code> 使得函数不是一次性计算并返回所有结果，而是在每次被请求时（通过 <code>next()</code> 或 <code>for</code> 循环）“生产”一个结果并暂停，保存其状态，直到下一次被请求时从上次暂停的地方继续执行。这在处理大量数据流或需要非阻塞I&#x2F;O时非常有优势。</p>
</div>

<h2 id="一、为什么需要-yield？迭代器与内存效率的痛点"><a href="#一、为什么需要-yield？迭代器与内存效率的痛点" class="headerlink" title="一、为什么需要 yield？迭代器与内存效率的痛点"></a>一、为什么需要 <code>yield</code>？迭代器与内存效率的痛点</h2><p>在处理序列数据时，我们通常会使用列表 (List)。然而，当数据量变得非常庞大时，将所有数据一次性加载到内存中会带来严重的问题：</p>
<ul>
<li><strong>内存溢出 (Memory Exhaustion)</strong>：如果数据量超过可用内存，程序会崩溃。</li>
<li><strong>性能下降</strong>：即使内存足够，一次性处理大量数据也会导致程序启动缓慢，响应延迟。</li>
</ul>
<p>考虑一个场景：需要处理一个包含数十亿行数据的日志文件。如果尝试将所有行读入一个列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 large_log.txt 有数十亿行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_large_file_into_list</span>(<span class="params">filepath</span>):</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            lines.append(line)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这可能会导致内存崩溃</span></span><br><span class="line"><span class="comment"># all_lines = read_large_file_into_list(&quot;large_log.txt&quot;)</span></span><br></pre></td></tr></table></figure>

<p>理想情况下，我们只需要<strong>按需 (on-demand)</strong> 获取每一行数据，而不是一次性加载所有数据。这就是<strong>迭代器 (Iterator)</strong> 的用武之地。</p>
<h3 id="1-1-迭代器-Iterator-：按需获取，节约内存"><a href="#1-1-迭代器-Iterator-：按需获取，节约内存" class="headerlink" title="1.1 迭代器 (Iterator)：按需获取，节约内存"></a>1.1 迭代器 (<code>Iterator</code>)：按需获取，节约内存</h3><p>迭代器是一种对象，它实现了迭代器协议：</p>
<ul>
<li><code>__iter__(self)</code> 方法：返回迭代器对象本身。</li>
<li><code>__next__(self)</code> 方法：返回序列中的下一个元素。当没有更多元素时，抛出 <code>StopIteration</code> 异常。</li>
</ul>
<p><code>for</code> 循环内部，正是通过调用对象的 <code>__iter__</code> 和 <code>__next__</code> 方法来遍历可迭代对象的。</p>
<p>自定义一个迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRange</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, end</span>):</span><br><span class="line">        <span class="variable language_">self</span>.current = start</span><br><span class="line">        <span class="variable language_">self</span>.end = end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="variable language_">self</span>.end:</span><br><span class="line">            num = <span class="variable language_">self</span>.current</span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义迭代器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> MyRange(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>手动编写一个迭代器类虽然可行，但对于简单的逐个生产数据的需求来说，显得有些繁琐。<code>yield</code> 关键字正是为了更简洁地创建迭代器而出现的。</p>
<h2 id="二、yield-的基本用法：创建生成器函数"><a href="#二、yield-的基本用法：创建生成器函数" class="headerlink" title="二、yield 的基本用法：创建生成器函数"></a>二、<code>yield</code> 的基本用法：创建生成器函数</h2><p>当一个函数包含 <code>yield</code> 语句时，它将不再是普通函数，而是一个<strong>生成器函数 (Generator Function)</strong>。生成器函数被调用时，不会立即执行函数体内的代码，而是返回一个<strong>生成器对象 (Generator Object)</strong>。</p>
<p>生成器对象是<strong>迭代器</strong>的一种特殊形式，它实现了迭代器协议，你可以像使用其他迭代器一样对其进行迭代（例如，通过 <code>for</code> 循环或调用 <code>next()</code>）。</p>
<p><strong>示例：使用 <code>yield</code> 创建一个简单的生成器</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Start of generator&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After first yield&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After second yield&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End of generator&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用生成器函数，返回一个生成器对象</span></span><br><span class="line">gen = my_generator()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Generator object created, but not executed yet.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次调用 next()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Calling next() for the first time:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen)) <span class="comment"># 执行到第一个 yield 语句，返回 1，然后暂停</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次调用 next()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Calling next() for the second time:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen)) <span class="comment"># 从上次暂停的地方继续执行，到第二个 yield 语句，返回 2，然后暂停</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三次调用 next()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Calling next() for the third time:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen)) <span class="comment"># 从上次暂停的地方继续执行，到第三个 yield 语句，返回 3，然后暂停</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四次调用 next()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Calling next() for the fourth time:&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(gen)) <span class="comment"># 函数执行完毕，抛出 StopIteration</span></span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;StopIteration caught!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- Using the generator in a for loop ---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> my_generator(): <span class="comment"># for 循环会自动调用 next() 并处理 StopIteration</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Received: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>输出分析</strong>：</p>
<ul>
<li>当 <code>my_generator()</code> 被调用时，函数体内的代码并没有立即执行，而是返回了一个生成器对象 <code>gen</code>。</li>
<li>每次调用 <code>next(gen)</code> 时，函数会从上次暂停的地方继续执行，直到遇到下一个 <code>yield</code> 语句，返回一个值，然后<strong>再次暂停</strong>，同时<strong>保存其执行状态</strong>（包括局部变量和指令指针）。</li>
<li>当函数执行完毕，或者在 <code>yield</code> 之后没有新的 <code>yield</code> 语句时，再次调用 <code>next()</code> 会抛出 <code>StopIteration</code> 异常，<code>for</code> 循环会自动捕获并终止迭代。</li>
</ul>
<p>这种机制使得生成器非常适用于惰性计算和处理无限序列。</p>
<h2 id="三、yield-的进阶用法：与-send-和-throw-交互"><a href="#三、yield-的进阶用法：与-send-和-throw-交互" class="headerlink" title="三、yield 的进阶用法：与 send() 和 throw() 交互"></a>三、<code>yield</code> 的进阶用法：与 <code>send()</code> 和 <code>throw()</code> 交互</h2><p>除了作为迭代器按需“生产”数据外，<code>yield</code> 还可以实现双向通信，从而将生成器升级为<strong>协程 (Coroutines)</strong>。</p>
<h3 id="3-1-1-generator-send-value"><a href="#3-1-1-generator-send-value" class="headerlink" title="3.1 1. generator.send(value)"></a>3.1 1. <code>generator.send(value)</code></h3><p><code>send()</code> 方法允许你向暂停的生成器<strong>发送 (send)</strong> 一个值。这个值会成为上次 <code>yield</code> 表达式的返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeater_generator</span>():</span><br><span class="line">    received = <span class="keyword">yield</span> <span class="string">&quot;Ready to receive&quot;</span> <span class="comment"># 第一个 yield 语句，也接收 send 的值</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Generator received: <span class="subst">&#123;received&#125;</span>&quot;</span>)</span><br><span class="line">        received = <span class="keyword">yield</span> <span class="string">f&quot;Received &#x27;<span class="subst">&#123;received&#125;</span>&#x27;, waiting for next.&quot;</span></span><br><span class="line"></span><br><span class="line">gen = repeater_generator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次启动生成器，执行到第一个 yield</span></span><br><span class="line">initial_msg = <span class="built_in">next</span>(gen)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Initial Message: <span class="subst">&#123;initial_msg&#125;</span>&quot;</span>) <span class="comment"># Output: Initial Message: Ready to receive</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送第一个值</span></span><br><span class="line">response_1 = gen.send(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="comment"># Output: Generator received: Hello</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Generator Response 1: <span class="subst">&#123;response_1&#125;</span>&quot;</span>) <span class="comment"># Output: Generator Response 1: Received &#x27;Hello&#x27;, waiting for next.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送第二个值</span></span><br><span class="line">response_2 = gen.send(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="comment"># Output: Generator received: World</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Generator Response 2: <span class="subst">&#123;response_2&#125;</span>&quot;</span>) <span class="comment"># Output: Generator Response 2: Received &#x27;World&#x27;, waiting for next.</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：首次启动生成器必须使用 <code>next(gen)</code> 或 <code>gen.send(None)</code>。因为在生成器第一次 <code>yield</code> 之前，没有地方可以接收 <code>send()</code> 发送的值。</p>
<h3 id="3-2-2-generator-throw-type-value-traceback"><a href="#3-2-2-generator-throw-type-value-traceback" class="headerlink" title="3.2 2. generator.throw(type, value, traceback)"></a>3.2 2. <code>generator.throw(type, value, traceback)</code></h3><p><code>throw()</code> 方法用于向生成器内部注入一个异常。这个异常会在当前 <code>yield</code> 语句处抛出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">error_handling_generator</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Generator started.&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Generator received: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        value = <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Generator received: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Generator caught ValueError: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Generator caught TypeError: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Generator finished cleanup.&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Generator cleanup done.&quot;</span> <span class="comment"># 异常处理后也可以继续 yield</span></span><br><span class="line"></span><br><span class="line">gen = error_handling_generator()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen)) <span class="comment"># Output: Generator started. \n 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- Throwing ValueError ---&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gen.throw(ValueError, <span class="string">&quot;Simulated error!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> StopIteration: <span class="comment"># 如果生成器处理完异常并终止了，会捕获 StopIteration</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Generator naturally stopped after error.&quot;</span>)</span><br><span class="line"><span class="comment"># Output: Generator caught ValueError: Simulated error!</span></span><br><span class="line"><span class="comment"># Output: Generator finished cleanup.</span></span><br><span class="line"><span class="comment"># 如果 Generator cleanup done. 也被 yield 了，这里会有一个 next() 来接收</span></span><br><span class="line"><span class="comment"># 否则就 StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次尝试 next() 可能会引发 StopIteration (如果 generator 已经结束)</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Generator definitively stopped.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-generator-close"><a href="#3-3-3-generator-close" class="headerlink" title="3.3 3. generator.close()"></a>3.3 3. <code>generator.close()</code></h3><p><code>close()</code> 方法用于立即终止生成器，并在当前 <code>yield</code> 暂停处抛出 <code>GeneratorExit</code> 异常。如果生成器内部有 <code>finally</code> 块，它将执行清理代码，但不会产生任何新的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cleanup_generator</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Generator started. Waiting for close.&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Generator cleanup on close.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This line will not be printed if closed early.&quot;</span>)</span><br><span class="line"></span><br><span class="line">gen = cleanup_generator()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen)) <span class="comment"># Output: Generator started. Waiting for close. \n 1</span></span><br><span class="line"></span><br><span class="line">gen.close()</span><br><span class="line"><span class="comment"># Output: Generator cleanup on close.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Generator closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">next</span>(gen)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Generator is truly stopped.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="四、yield-from-语句：委托给子生成器"><a href="#四、yield-from-语句：委托给子生成器" class="headerlink" title="四、yield from 语句：委托给子生成器"></a>四、<code>yield from</code> 语句：委托给子生成器</h2><p><code>yield from</code> 语句 (Python 3.3 引入) 提供了一种将操作<strong>委托 (delegate)</strong> 给另一个生成器或可迭代对象的方式。它简化了生成器之间的链式调用，使得代码更简洁，并且能更好地处理异常和返回值。</p>
<p><strong>传统方式 (手动循环)：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub_generator</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_generator_old</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Starting main generator&quot;</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sub_generator(<span class="number">3</span>): <span class="comment"># 手动遍历子生成器</span></span><br><span class="line">        <span class="keyword">yield</span> item</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Main generator finished&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> main_generator_old():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>yield from</code>：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sub_generator</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sub-generator-<span class="subst">&#123;x&#125;</span> started.&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sub-generator-<span class="subst">&#123;x&#125;</span> ended.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Sub-gen finished value&quot;</span> <span class="comment"># 子生成器可以有返回值！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_generator_new</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Starting main generator&quot;</span></span><br><span class="line">    <span class="comment"># yield from 表达式会成为子生成器的返回值</span></span><br><span class="line">    returned_value = <span class="keyword">yield</span> <span class="keyword">from</span> sub_generator(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Main generator received from sub-gen: <span class="subst">&#123;returned_value&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Main generator finished&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> main_generator_new():</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><code>yield from</code> 的优势</strong>：</p>
<ul>
<li><strong>简化代码</strong>：替代了手动 <code>for ... yield ...</code> 循环。</li>
<li><strong>异常处理透明</strong>：子生成器中的异常会直接传递给委托生成器，就好像它们在委托生成器中发生一样。</li>
<li><strong>返回值传递</strong>：子生成器的 <code>return</code> 值 (通过 <code>StopIteration</code> 的 <code>value</code> 属性传递) 可以被委托生成器直接捕获，作为 <code>yield from</code> 表达式的值。这对于协程非常重要。</li>
<li><strong>协程链</strong>：使得协程的异步编程模型更加强大和易于管理，例如在 <code>async/await</code> 之前的 <code>asyncio</code> 中广泛使用。</li>
</ul>
<h2 id="五、生成器与协程的联系与区别"><a href="#五、生成器与协程的联系与区别" class="headerlink" title="五、生成器与协程的联系与区别"></a>五、生成器与协程的联系与区别</h2><ul>
<li><strong>生成器 (Generators)</strong>：主要用于按需生成数据序列，实现惰性计算，节约内存。它们是<strong>生产者</strong>。</li>
<li><strong>协程 (Coroutines)</strong>：是生成器的推广，它们不仅能生产数据 (通过 <code>yield</code> 值)，还能消费数据 (通过 <code>send()</code> 接收值)。它们可以用于实现更复杂的异步和并发任务调度。在 Python 3.5 引入 <code>async/await</code> 语法糖之后，协程得到了更明确的定义和更广泛的应用。<code>async def</code> 定义的函数就是协程，其核心也是基于 <code>yield from</code>（在底层实现上）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[函数] --&gt; B&#123;是否包含 yield?&#125;</span><br><span class="line">    B -- Yes --&gt; C[生成器 Generator]</span><br><span class="line">    B -- No --&gt; D[普通函数]</span><br><span class="line"></span><br><span class="line">    C --&gt; E&#123;是否仅用于迭代?&#125;</span><br><span class="line">    E -- Yes --&gt; F[简单的惰性序列生产者]</span><br><span class="line">    E -- No --&gt; G[协程 Coroutine]</span><br><span class="line"></span><br><span class="line">    G -- 使用 send(), throw() --&gt; H[实现双向通信和高级流控制]</span><br><span class="line">    G -- Python 3.5+ --&gt; I[async/await 语法糖]</span><br><span class="line">    I --&gt; J[异步编程框架 (如 asyncio)]</span><br></pre></td></tr></table></figure>

<h2 id="六、yield-的应用场景"><a href="#六、yield-的应用场景" class="headerlink" title="六、yield 的应用场景"></a>六、<code>yield</code> 的应用场景</h2><ol>
<li><strong>处理大型数据集</strong>：读取大文件、处理数据库查询结果集等，避免一次性加载所有数据到内存。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_lines_from_file</span>(<span class="params">filepath</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">yield</span> line.strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> read_lines_from_file(<span class="string">&quot;large_data.csv&quot;</span>):</span><br><span class="line">    <span class="comment"># 处理每一行数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;ERROR&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Found error: <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>无限序列</strong>：生成斐波那契数列、素数序列等理论上无限的序列。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_sequence</span>():</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">fib_gen = fibonacci_sequence()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(fib_gen))</span><br></pre></td></tr></table></figure></li>
<li><strong>管道 (Pipelines)</strong>：将多个生成器连接起来，形成数据处理管道。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doubler</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">yield</span> num * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter_even</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> num</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道：生成 -&gt; 翻倍 -&gt; 过滤偶数</span></span><br><span class="line">pipeline = filter_even(doubler(producer(<span class="number">10</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(pipeline)) <span class="comment"># Output: [0, 4, 8, 12, 16]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>协程与异步编程</strong>：在 <code>asyncio</code> 等异步框架中，<code>await</code> 关键字背后正是 <code>yield from</code> 的变体。它让协程可以暂停执行，等待一个 I&#x2F;O 操作完成，而不是阻塞整个程序。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是简化概念，async/await 是更高级的抽象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Start fetching <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 实际的 await 调用会暂停协程</span></span><br><span class="line">    <span class="comment"># result = await some_http_call(url)</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">f&quot;Partial data from <span class="subst">&#123;url&#125;</span>&quot;</span> <span class="comment"># 假装是等待期间的 yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Finished fetching <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Full data from <span class="subst">&#123;url&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在传统的 yield 结构中模拟，实际 async def 函数不会直接 yield 值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_simple_async_example</span>():</span><br><span class="line">    coro = fetch_data(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(coro)) <span class="comment"># 启动</span></span><br><span class="line">    <span class="comment"># 实际 await 发生后，会有事件循环调度</span></span><br><span class="line">    <span class="comment"># 这里为了演示，我们用 send 来模拟外部的完成通知</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        coro.send(<span class="string">&quot;HTTP Response&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Coro returned: <span class="subst">&#123;e.value&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># run_simple_async_example()</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>yield</code> 关键字是 Python 中一个多功能且强大的工具，它将普通函数转化为生成器和协程，能够彻底改变你处理数据流和并发的方式。</p>
<ul>
<li><strong>作为生成器</strong>，它使你能够实现<strong>惰性计算</strong>，按需生成数据，从而显著优化内存使用和程序性能，尤其是在处理大规模数据集或无限序列时。</li>
<li><strong>作为协程</strong>（结合 <code>send()</code>、<code>throw()</code> 和 <code>yield from</code>），它提供了<strong>双向通信</strong>的能力，是实现非阻塞 I&#x2F;O 和高级并发模式（如 <code>asyncio</code>）的基础。</li>
</ul>
<p>掌握 <code>yield</code> 不仅能够让你编写出更高效、更优雅的 Python 代码，也是理解现代 Python 异步编程范式的敲门砖。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-08-26_Python%20yield%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B/">https://blog.tbf1211.xx.kg/2024/2024-08-26_Python%20yield%20%E5%85%B3%E9%94%AE%E5%AD%97%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/">编程语法</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-09-02_GoLang%20gRPC%20%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="GoLang gRPC 详解：构建高性能、跨语言的微服务"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">GoLang gRPC 详解：构建高性能、跨语言的微服务</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是 Google 开发的一个高性能、开源的 RPC 框架，支持多种编程语言。它基于 HTTP&#x2F;2 协议传输，并使用 Protocol Buffers (Protobuf) 作为接口定义语言 (IDL) 和数据序列化机制。Go 语言作为云原生时代的明星语言，与 gRPC 的结合更是如虎添翼，是构建高性能、跨语言微服务系统的理想选择。  “gRPC aims to bring the benefits of modern RPC to everyone.”   一、gRPC 简介1. 什么是 gRPC？gRPC 是一种现代的 RPC (远程过程调用) 框架，它允许你在一个语言中定义服务（使用 Protobuf），然后在任何支持 gRPC 的语言中实现客户端和服务器。其核心特性包括：  高性能: 基于 HTTP&#x2F;2 和 Protobuf，提供更快的传输速度和更小的消息体。 多语言支持: 通过代码生成，支持 Go、Java、Python、C++、Node.js、C# 等多种语言。 强类型接口: ...</div></div></div></a><a class="pagination-related" href="/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Vue3响应式原理深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Vue3响应式原理深度解析</div></div><div class="info-2"><div class="info-item-1"> Vue 3 响应式系统是其 MVVM 框架的核心基石，它让前端开发者能够以声明式的方式构建用户界面，而无需手动操作 DOM。与 Vue 2 基于 Object.defineProperty 的实现不同，Vue 3 借助 ES6 的 Proxy 对象，彻底重构了响应式系统，带来了更高性能、更强大的功能和更灵活的 API。  “Vue 3 的响应式系统是一个优雅而强大的解决方案，它通过 Proxy 和一套高效的依赖追踪机制，实现了数据与视图的紧密双向绑定，极大地提升了开发体验。”   一、响应式系统的核心概念在深入 Vue 3 响应式原理之前，我们需要理解几个核心概念：  数据劫持 (Data Interception)：当访问或修改数据时，能够执行自定义逻辑。 依赖收集 (Dependency Collection)：追踪哪些组件或函数正在使用哪些响应式数据。 派发更新 (Trigger Update)：当响应式数据发生变化时，通知所有依赖于该数据的组件或函数进行更新。  二、Vue 2 与 Vue 3 响应式原理对比理解 Vue 3 的优势，最好从对比 Vue 2 开始。 2....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-04-14_Python%20with%20%E8%AF%AD%E5%8F%A5%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/" title="Python with 语句深度详解：资源管理与上下文管理器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-14</div><div class="info-item-2">Python with 语句深度详解：资源管理与上下文管理器</div></div><div class="info-2"><div class="info-item-1"> Python 的 with 语句 提供了一种更安全、简洁且可读性强的方式来管理资源，确保资源在使用完毕后能够正确地被清理或释放，即使在代码执行过程中发生异常。这个机制的核心是上下文管理器 (Context Manager) 协议，它定义了进入和退出某个代码块时需要执行的操作。  核心思想：with 语句允许你定义一个代码块，当这个代码块被进入时，一个资源会自动被准备好，并且无论代码块如何退出（正常结束或抛出异常），资源都会自动被清理。这大大简化了错误处理和资源管理的复杂性。   一、为什么需要 with 语句？传统资源管理的痛点在很多编程场景中，我们需要使用一些外部资源，例如：  文件操作：打开文件进行读写。 网络连接：建立 Socket 连接。 数据库连接：连接数据库，执行查询。 线程锁：获取和释放锁。 内存分配：比如一些临时的数据结构。  这些资源通常是有限的，并且在使用完毕后必须被正确地释放或清理，否则可能导致：  资源泄漏：文件句柄过多、数据库连接未关闭，最终耗尽系统资源。 数据损坏：文件未正确关闭可能导致数据丢失或不完整。 死锁：锁未正确释放可能导致程序挂起。  传统...</div></div></div></a><a class="pagination-related" href="/2024/2024-04-17_Python%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%20(Structural%20Pattern%20Matching)%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/" title="Python 结构化模式匹配 (Structural Pattern Matching) 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-17</div><div class="info-item-2">Python 结构化模式匹配 (Structural Pattern Matching) 深度详解</div></div><div class="info-2"><div class="info-item-1"> Python 的结构化模式匹配 (Structural Pattern Matching) 是在 Python 3.10 中引入的一项强大新特性，灵感来源于其他函数式编程语言。该特性通过 match 和 case 语句，提供了一种简洁、富有表现力的方式来根据数据结构和值进行分支逻辑处理。它不仅是对传统 if/elif/else 语句的补充，更是一种处理复杂数据结构（如列表、字典、对象）的新范式，能够显著提高代码的可读性、可维护性和健壮性。  核心思想：模式匹配允许你将一个主题 (subject) 值与一系列模式 (patterns) 进行比较。当一个模式成功匹配主题值时，相关的代码块将被执行。在此过程中，模式还可以解构 (destructure) 主题值，并将其中的部分绑定到新的变量上，从而直接获取所需的数据。   一、为什么需要结构化模式匹配？背景与痛点在 Python 3.10 之前，处理复杂的数据结构，特别是当需要根据其形状、类型或包含的值进行条件判断时，代码往往会变得冗长且难以阅读。例如，考虑处理来自不同来源的 JSON 数据，或者解析命令行参数，传统的方法通常涉及： ...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-09_Python%E5%85%83%E7%B1%BB(Metaclass)%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Python元类(Metaclass)深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="info-item-2">Python元类(Metaclass)深度解析</div></div><div class="info-2"><div class="info-item-1">Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，它允许我们在类被创建时对其行为进行定制，是 Python 中进行高级面向对象编程的强大工具。 1. 什么是元类？在 Python 中，当你定义一个类 class MyClass: pass 的时候，Python 解释器会自动执行以下步骤：  定义一个类对象：解释器读取 MyClass 的定义，并创建一个名为 MyClass 的类对象。 将类对象绑定到命名空间：这个 MyClass 类对象被绑定到当前的命名空间中。  然后，当你通过 my_instance = MyClass() 来创建实例时，MyClass 这个类对象就会被调用，从而创建并返回一个实例对象。 元类就是用来创建这些类对象的...</div></div></div></a><a class="pagination-related" href="/2023/2023-06-15_Python%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/" title="Python装饰器详解：从基础到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-15</div><div class="info-item-2">Python装饰器详解：从基础到高级应用</div></div><div class="info-2"><div class="info-item-1"> Python 装饰器 (Decorators) 是一种强大而优雅的语法糖，它允许你在不修改原函数代码的情况下，给函数添加额外的功能或修改其行为。装饰器本质上是一个接受函数作为参数并返回一个新函数的函数。它广泛应用于日志记录、性能测试、事务处理、权限验证等场景，是 Python 高级编程中不可或缺的工具。  “装饰器是 Python 的一项强大功能，它使得代码更加模块化、可读性更高，能够优雅地实现功能的扩展和复用，而无需侵入式地修改原有代码。”   一、理解装饰器前的预备知识要真正理解装饰器，我们需要先掌握几个 Python 核心概念： 1.1 函数是第一类对象 (First-Class Objects)在 Python 中，函数与其他数据类型（如整数、字符串）一样，是第一类对象。这意味着你可以：  将函数赋值给变量 将函数作为参数传递给其他函数 将函数作为另一个函数的返回值 在数据结构中存储函数  示例： 123456789101112131415161718192021def greet(name):    return f&quot;Hello, &#123;name&#1...</div></div></div></a><a class="pagination-related" href="/2024/2024-04-11_Python%20OpenCV%E8%AF%A6%E8%A7%A3%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9A%84%E5%BC%BA%E5%A4%A7%E5%B7%A5%E5%85%B7/" title="Python OpenCV详解：计算机视觉的强大工具"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-11</div><div class="info-item-2">Python OpenCV详解：计算机视觉的强大工具</div></div><div class="info-2"><div class="info-item-1"> OpenCV (Open Source Computer Vision Library) 是一个开源计算机视觉库，其 C++ 核心库被封装为多种语言接口，其中就包括 Python。它提供了丰富的功能，涵盖了从低级图像处理操作（如滤波、变形）到高级计算机视觉任务（如物体检测、人脸识别、姿态估计、机器学习算法）等各个方面。opencv-python 库使得 Python 开发者能够轻松利用这些强大的计算机视觉能力，广泛应用于科研、工业、人工智能等领域。  核心思想：OpenCV 提供了一套全面且高性能的工具集，以简化图像和视频的处理与分析，使计算机能够“看清”并理解世界。   一、为什么选择 OpenCV-Python？ 功能全面：涵盖了计算机视觉的几乎所有核心功能。 性能优异：底层由 C&#x2F;C++ 实现，性能接近原生应用，同时提供了 Python 简单易用的接口。 跨平台：支持 Windows、Linux、macOS 等多种操作系统。 活跃社区与丰富资源：庞大的用户群和详细的文档、教程，解决问题方便。 与 Python 生态集成好：可以方便地与 NumPy、Matplot...</div></div></div></a><a class="pagination-related" href="/2024/2024-03-27_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88Prototype%20Chain%EF%BC%89/" title="深入理解JavaScript原型链（Prototype Chain）"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-27</div><div class="info-item-2">深入理解JavaScript原型链（Prototype Chain）</div></div><div class="info-2"><div class="info-item-1"> JavaScript 是一门基于**原型（Prototype）**的语言，而非传统的基于类（Class）的语言（尽管 ES6 引入了 class 语法糖）。理解原型链是深入掌握 JavaScript 面向对象、继承以及对象属性查找机制的关键。它解释了为什么一个对象可以访问到它自身没有定义的方法和属性。  “JavaScript 的一切皆对象，而原型链是这些对象连接的纽带。”   一、什么是原型（Prototype）？在 JavaScript 中，每个对象都有一个内部属性，指向它的原型（Prototype）。这个原型又是一个对象，它也有自己的原型，这样一层一层向上，直到最后是 null。这个由一系列原型组成的链条就是原型链。 1. [[Prototype]] 和 __proto__ [[Prototype]]：这是对象内部隐藏的属性，它指向该对象的原型。在 ES5 之前，开发者无法直接访问这个内部属性。 __proto__：这是大多数现代 JavaScript 引擎提供的一个非标准的 getter&#x2F;setter，用于访问或设置对象的 [[Prototype]]。虽然它现...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">137</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">52</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-yield%EF%BC%9F%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%95%88%E7%8E%87%E7%9A%84%E7%97%9B%E7%82%B9"><span class="toc-text">一、为什么需要 yield？迭代器与内存效率的痛点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%EF%BC%9A%E6%8C%89%E9%9C%80%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98"><span class="toc-text">1.1 迭代器 (Iterator)：按需获取，节约内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81yield-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-text">二、yield 的基本用法：创建生成器函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81yield-%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95%EF%BC%9A%E4%B8%8E-send-%E5%92%8C-throw-%E4%BA%A4%E4%BA%92"><span class="toc-text">三、yield 的进阶用法：与 send() 和 throw() 交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-generator-send-value"><span class="toc-text">3.1 1. generator.send(value)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-generator-throw-type-value-traceback"><span class="toc-text">3.2 2. generator.throw(type, value, traceback)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-generator-close"><span class="toc-text">3.3 3. generator.close()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81yield-from-%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%A7%94%E6%89%98%E7%BB%99%E5%AD%90%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">四、yield from 语句：委托给子生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text">五、生成器与协程的联系与区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81yield-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">六、yield 的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言指向指针的指针(Pointer to Pointer)详解"/></a><div class="content"><a class="title" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解">Go语言指向指针的指针(Pointer to Pointer)详解</a><time datetime="2025-09-30T22:24:00.000Z" title="发表于 2025-10-01 06:24:00">2025-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-28_HTMX%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8HTML%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E9%A9%B1%E5%8A%A8AJAX%E3%80%81CSS%E8%BF%87%E6%B8%A1%E5%92%8CWebSocket/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"/></a><div class="content"><a class="title" href="/2025/2025-09-28_HTMX%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8HTML%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E9%A9%B1%E5%8A%A8AJAX%E3%80%81CSS%E8%BF%87%E6%B8%A1%E5%92%8CWebSocket/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</a><time datetime="2025-09-27T22:24:00.000Z" title="发表于 2025-09-28 06:24:00">2025-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2详解：在Windows运行Linux的新标准"/></a><div class="content"><a class="title" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准">WSL2详解：在Windows运行Linux的新标准</a><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-02.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><script src="/self/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>