<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UART (通用异步收发传输器) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UART (Universal Asynchronous Receiver&#x2F;Transmitter)，即通用异步收发传输器，是一种硬件设备，用于通过串行端口在计算机或微控制器与外设之间进行异步串行通信。它是最常见、最基本的串行通信方式之一，广泛应用于设备调试、传感器数据传输、模块间通信等场景。  核心思想：UART 通过两根线（发送线 TX 和接收线 RX）以位为单位，按照预设的波特率">
<meta property="og:type" content="article">
<meta property="og:title" content="UART (通用异步收发传输器) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-09-06_UART%20(%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E5%99%A8)%20%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="UART (Universal Asynchronous Receiver&#x2F;Transmitter)，即通用异步收发传输器，是一种硬件设备，用于通过串行端口在计算机或微控制器与外设之间进行异步串行通信。它是最常见、最基本的串行通信方式之一，广泛应用于设备调试、传感器数据传输、模块间通信等场景。  核心思想：UART 通过两根线（发送线 TX 和接收线 RX）以位为单位，按照预设的波特率">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg">
<meta property="article:published_time" content="2024-09-05T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-31T09:32:56.300Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="嵌入式系统">
<meta property="article:tag" content="硬件编程">
<meta property="article:tag" content="硬件协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UART (通用异步收发传输器) 详解",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-09-06_UART%20(%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E5%99%A8)%20%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg",
  "datePublished": "2024-09-05T22:24:00.000Z",
  "dateModified": "2025-10-31T09:32:56.300Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-09-06_UART%20(%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E5%99%A8)%20%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UART (通用异步收发传输器) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">170</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">UART (通用异步收发传输器) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">UART (通用异步收发传输器) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-09-05T22:24:00.000Z" title="发表于 2024-09-06 06:24:00">2024-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/">嵌入式系统</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E5%8D%8F%E8%AE%AE/">硬件协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-09-06_UART%20(%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E5%99%A8)%20%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>UART (Universal Asynchronous Receiver&#x2F;Transmitter)</strong>，即<strong>通用异步收发传输器</strong>，是一种硬件设备，用于通过串行端口在计算机或微控制器与外设之间进行<strong>异步串行通信</strong>。它是最常见、最基本的串行通信方式之一，广泛应用于设备调试、传感器数据传输、模块间通信等场景。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>UART 通过两根线（发送线 TX 和接收线 RX）以位为单位，按照预设的波特率、数据位、停止位和奇偶校验位，异步传输数据，无需时钟线。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-UART？"><a href="#一、为什么需要-UART？" class="headerlink" title="一、为什么需要 UART？"></a>一、为什么需要 UART？</h2><p>在微控制器和外部设备（如电脑、传感器、其他微控制器、蓝牙模块、GPS 模块等）之间进行数据交换是嵌入式系统的核心需求。</p>
<ul>
<li><strong>并行通信的局限性</strong>：并行通信（如 SPI 的某些模式）虽然速度快，但需要多根数据线（例如 8 位数据需要 8 根线），这会增加硬件成本、PCB 布线难度和功耗，尤其是在远距离传输时容易产生信号同步问题。</li>
<li><strong>串行通信的优势</strong>：串行通信每次只发送一个数据位，大大减少了所需的信号线数量（UART 只需要两根线），简化了硬件设计。</li>
<li><strong>异步通信的简便性</strong>：UART 是一种异步通信协议，这意味着发送方和接收方不需要共享一个时钟信号。它们各自独立地使用自己的内部时钟，但必须预先约定好通信参数（如波特率）。</li>
</ul>
<p>UART 的出现，使得在资源有限的嵌入式系统中，高效、可靠地进行设备间通信成为可能。</p>
<h2 id="二、UART-的核心概念与通信参数"><a href="#二、UART-的核心概念与通信参数" class="headerlink" title="二、UART 的核心概念与通信参数"></a>二、UART 的核心概念与通信参数</h2><p>UART 的通信是<strong>全双工 (Full-Duplex)</strong> 的，即可以同时发送和接收数据，分别通过两根独立的线实现：</p>
<ul>
<li><strong>TX (Transmit)</strong>：发送数据线，连接到接收方的 RX。</li>
<li><strong>RX (Receive)</strong>：接收数据线，连接到发送方的 TX。</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph LR
    A[发送方 UART] --&gt;|TX| B[接收方 UART];
    B --&gt;|RX| A;

    subgraph UART 数据帧结构
        Idle[&quot;空闲状态 (高电平)&quot;] -- 10ms --&gt; StartBit[&quot;起始位 (低电平, 1位)&quot;]
        StartBit --&gt; DataBits[&quot;数据位 (5-9位, 最常用 8位)&quot;]
        DataBits --&gt; ParityBit[&quot;奇偶校验位 (可选, 1位)&quot;]
        ParityBit --&gt; StopBits[&quot;停止位 (1, 1.5, 2位, 最常用 1位)&quot;]
        StopBits --&gt; Idle;
    end
  </pre></div>

<p>UART 通信的关键在于发送方和接收方必须就以下几个通信参数达成一致：</p>
<ol>
<li><strong>波特率 (Baud Rate)</strong>：<ul>
<li>表示每秒传输的<strong>位数 (bits per second, bps)</strong>。</li>
<li>发送方和接收方必须使用相同的波特率，否则接收方无法正确采样数据。</li>
<li>常见波特率：9600, 19200, 38400, 57600, 115200 bps 等。波特率越高，传输速度越快。</li>
<li>波特率选择的考量：数据传输量、传输距离、设备性能。</li>
</ul>
</li>
<li><strong>数据位 (Data Bits)</strong>：<ul>
<li>每个数据帧中实际数据位的数量。</li>
<li>通常为 5、6、7、8 或 9 位，最常用的是 <strong>8 位</strong>（传输一个字节）。</li>
</ul>
</li>
<li><strong>停止位 (Stop Bits)</strong>：<ul>
<li>用于标记一个数据帧的结束。</li>
<li>通常为 1、1.5 或 2 位，最常用的是 <strong>1 位</strong>。</li>
</ul>
</li>
<li><strong>奇偶校验位 (Parity Bit)</strong>：<ul>
<li>一个可选的位，用于检测数据传输过程中是否发生错误。</li>
<li><strong>无校验 (None)</strong>：最常用，不使用校验位。</li>
<li><strong>偶校验 (Even)</strong>：数据位和校验位中 1 的总数为偶数。</li>
<li><strong>奇校验 (Odd)</strong>：数据位和校验位中 1 的总数为奇数。</li>
<li><strong>原理</strong>：发送方计算数据位中 1 的数量，然后设置校验位使其符合奇偶规则。接收方收到数据后进行同样的计算，如果结果不符，则认为数据传输有误。</li>
<li><strong>局限性</strong>：奇偶校验只能检测出<strong>单个位错误</strong>，或奇数个位错误。如果发生偶数个位错误，校验可能仍然通过。因此，它是一种简单但有限的错误检测机制。</li>
</ul>
</li>
</ol>
<h3 id="2-1-UART-数据帧结构"><a href="#2-1-UART-数据帧结构" class="headerlink" title="2.1 UART 数据帧结构"></a>2.1 UART 数据帧结构</h3><p>一个完整的 UART 数据帧通常包括：</p>
<ol>
<li><strong>空闲状态 (Idle State)</strong>：当没有数据传输时，UART 数据线保持在高电平。</li>
<li><strong>起始位 (Start Bit)</strong>：当发送方准备发送数据时，首先会将数据线从高电平拉低（<strong>1 位低电平</strong>），通知接收方数据传输即将开始。接收方检测到这个下降沿后，会开始以波特率进行采样。</li>
<li><strong>数据位 (Data Bits)</strong>：紧随起始位之后是实际的数据位，通常是 <strong>低位在前，高位在后</strong> (Least Significant Bit first - LSB first)。</li>
<li><strong>奇偶校验位 (Parity Bit)</strong>：如果启用了奇偶校验，数据位之后会有一个奇偶校验位。</li>
<li><strong>停止位 (Stop Bit(s))</strong>：数据帧的结束标志，通常是 <strong>1 位高电平</strong>。它确保了在下一个起始位到来之前，接收方有足够的时间进行处理，并重新同步。</li>
</ol>
<p><strong>一个典型的数据帧 (8N1)：</strong><br>这是一种常见的配置，表示：</p>
<ul>
<li>8 个数据位</li>
<li>无奇偶校验 (None)</li>
<li>1 个停止位</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant IDLE as 空闲 (高电平)
    participant START as 起始位 (低电平)
    participant D0 as 数据位0 (LSB)
    participant D1 as 数据位1
    participant D2 as 数据位2
    participant D3 as 数据位3
    participant D4 as 数据位4
    participant D5 as 数据位5
    participant D6 as 数据位6
    participant D7 as 数据位7 (MSB)
    participant STOP as 停止位 (高电平)

    IDLE -&gt;&gt; START: 下降沿
    START -&gt;&gt; D0: 位传输
    D0 -&gt;&gt; D1: 位传输
    D1 -&gt;&gt; D2: 位传输
    D2 -&gt;&gt; D3: 位传输
    D3 -&gt;&gt; D4: 位传输
    D4 -&gt;&gt; D5: 位传输
    D5 -&gt;&gt; D6: 位传输
    D6 -&gt;&gt; D7: 位传输
    D7 -&gt;&gt; STOP: 位传输
    STOP -&gt;&gt; IDLE: 上升沿 (或继续保持高电平)
  </pre></div>

<h2 id="三、UART-的硬件实现-RS-232-TTL"><a href="#三、UART-的硬件实现-RS-232-TTL" class="headerlink" title="三、UART 的硬件实现 (RS-232, TTL)"></a>三、UART 的硬件实现 (RS-232, TTL)</h2><p>虽然 UART 描述的是数据传输的逻辑协议，但在物理层，它有不同的电压标准：</p>
<ol>
<li><strong>TTL (Transistor-Transistor Logic) UART</strong>：<ul>
<li><strong>电压电平</strong>：高电平通常为 3.3V 或 5V，低电平为 0V。</li>
<li><strong>特点</strong>：这是微控制器（如 Arduino、ESP32）内部直接使用的电压电平。</li>
<li><strong>应用</strong>：设备内部通信、短距离（通常小于 1-2 米）通信。</li>
</ul>
</li>
<li><strong>RS-232 UART</strong>：<ul>
<li><strong>电压电平</strong>：<ul>
<li>逻辑 ‘0’ (空闲&#x2F;停止位)：+3V 到 +15V</li>
<li>逻辑 ‘1’ (起始位&#x2F;数据位)：-3V 到 -15V</li>
</ul>
</li>
<li><strong>特点</strong>：RS-232 是一种标准，需要一个电平转换芯片（如 MAX232）将 TTL 电平转换为 RS-232 电平，反之亦然。</li>
<li><strong>应用</strong>：与传统计算机的串行端口、工业设备进行通信。</li>
<li><strong>连接器</strong>：通常使用 DB9 或 DB25 连接器。</li>
</ul>
</li>
</ol>
<p><strong>重要提示</strong>：直接连接 TTL UART 和 RS-232 端口会导致电压不匹配，可能损坏设备！始终使用电平转换模块。</p>
<h2 id="四、UART-在-Arduino-中的应用"><a href="#四、UART-在-Arduino-中的应用" class="headerlink" title="四、UART 在 Arduino 中的应用"></a>四、UART 在 Arduino 中的应用</h2><p>Arduino 板（如 Uno、Mega、ESP32）都集成了 UART 硬件模块，并提供了易于使用的软件库。</p>
<h3 id="4-1-Arduino-Uno-AVR-微控制器"><a href="#4-1-Arduino-Uno-AVR-微控制器" class="headerlink" title="4.1 Arduino Uno (AVR 微控制器)"></a>4.1 Arduino Uno (AVR 微控制器)</h3><ul>
<li><strong>硬件串口 (Serial)</strong>：<ul>
<li>Arduino Uno 有一个硬件 UART 模块，连接到 <code>RX (D0)</code> 和 <code>TX (D1)</code> 引脚。</li>
<li>这些引脚同时也被用于与 USB-to-Serial 芯片（如 ATmega16U2）通信，从而实现与电脑的 USB 串口通信和程序上传。</li>
<li><strong>注意</strong>：在使用 D0&#x2F;D1 进行外部设备通信时，可能会干扰 USB 调试和程序上传。</li>
</ul>
</li>
<li><strong>软件串口 (SoftwareSerial)</strong>：<ul>
<li>通过软件模拟 UART 功能，可以在任意数字引脚上创建额外的串口。</li>
<li><strong>优点</strong>：可以有多个串口，不占用硬件串口。</li>
<li><strong>缺点</strong>：占用 CPU 资源，最高波特率有限，精度不如硬件串口。</li>
</ul>
</li>
</ul>
<p><strong>示例：Arduino Uno 硬件串口通信</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>); <span class="comment">// 初始化硬件串口，设置波特率为 9600 bps</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Arduino Uno ready.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从串口读取数据</span></span><br><span class="line">  <span class="keyword">if</span> (Serial.<span class="built_in">available</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> incomingByte = Serial.<span class="built_in">read</span>(); <span class="comment">// 读取一个字节</span></span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;Received: &quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(incomingByte);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向串口发送数据</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Hello from Arduino!&quot;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>); <span class="comment">// 每秒发送一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-ESP32-Arduino"><a href="#4-2-ESP32-Arduino" class="headerlink" title="4.2 ESP32 Arduino"></a>4.2 ESP32 Arduino</h3><p>ESP32 拥有<strong>多个硬件 UART 模块</strong> (通常是 3 个：UART0, UART1, UART2)，这使得它在串行通信方面非常强大，可以同时与多个设备通信，而无需使用软件串口。</p>
<ul>
<li><strong><code>Serial</code> (UART0)</strong>：<ul>
<li>默认情况下，<code>Serial</code> 对象对应于 ESP32 的 UART0。</li>
<li>UART0 通常连接到 USB-to-Serial 芯片，用于与电脑通信、调试和上传程序。</li>
<li><strong>默认引脚</strong>：通常是 GPIO1 (TX) 和 GPIO3 (RX)。</li>
</ul>
</li>
<li><strong><code>Serial1</code> (UART1)</strong>：<ul>
<li>ESP32 的第二个硬件 UART。</li>
<li><strong>默认引脚</strong>：GPIO10 (TX) 和 GPIO9 (RX) 或 GPIO2 (TX) 和 GPIO13 (RX)，具体取决于开发板。</li>
<li>可以通过 <code>Serial1.begin()</code> 函数指定自定义的引脚。</li>
</ul>
</li>
<li><strong><code>Serial2</code> (UART2)</strong>：<ul>
<li>ESP32 的第三个硬件 UART。</li>
<li><strong>默认引脚</strong>：GPIO17 (TX) 和 GPIO16 (RX)。</li>
<li>同样可以通过 <code>Serial2.begin()</code> 指定自定义引脚。</li>
</ul>
</li>
</ul>
<p><strong>ESP32 优点</strong>：</p>
<ul>
<li>硬件 UART 性能稳定，速度快。</li>
<li>支持引脚重映射 (Pin Remapping)，可以在几乎所有 GPIO 引脚上使用 UART 功能，提供了极大的灵活性。</li>
</ul>
<p><strong>示例：ESP32 使用 <code>Serial1</code> 与外部设备通信</strong></p>
<p>假设你有一个 GPS 模块连接到 ESP32 的 GPIO17 (TX) 和 GPIO16 (RX)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">115200</span>); <span class="comment">// 初始化用于调试的 UART0</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;ESP32 UART Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 UART1，指定波特率和引脚</span></span><br><span class="line">  <span class="comment">// Serial1.begin(baudRate, config, rxPin, txPin);</span></span><br><span class="line">  Serial<span class="number">1.</span><span class="built_in">begin</span>(<span class="number">9600</span>, SERIAL_8N1, <span class="number">16</span>, <span class="number">17</span>); <span class="comment">// 波特率 9600, 8N1, RX: GPIO16, TX: GPIO17</span></span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Serial1 initialized on RX:16, TX:17&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从 Serial1 (GPS 模块) 读取数据并转发到 Serial (电脑)</span></span><br><span class="line">  <span class="keyword">if</span> (Serial<span class="number">1.</span><span class="built_in">available</span>()) &#123;</span><br><span class="line">    String data = Serial<span class="number">1.</span><span class="built_in">readStringUntil</span>(<span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 读取一行数据</span></span><br><span class="line">    Serial.<span class="built_in">print</span>(<span class="string">&quot;GPS Data: &quot;</span>);</span><br><span class="line">    Serial.<span class="built_in">println</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向 Serial1 发送数据 (如果外部设备需要)</span></span><br><span class="line">  <span class="comment">// Serial1.println(&quot;Request data...&quot;);</span></span><br><span class="line">  <span class="comment">// delay(1000);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、UART-的优缺点"><a href="#五、UART-的优缺点" class="headerlink" title="五、UART 的优缺点"></a>五、UART 的优缺点</h2><h3 id="5-1-优点"><a href="#5-1-优点" class="headerlink" title="5.1 优点"></a>5.1 优点</h3><ol>
<li><strong>简单易用</strong>：只需要两根线（TX&#x2F;RX）进行通信，硬件连接简单。</li>
<li><strong>全双工通信</strong>：可以同时发送和接收数据。</li>
<li><strong>广泛支持</strong>：几乎所有微控制器和许多外设都支持 UART。</li>
<li><strong>无需时钟线</strong>：异步通信，简化了布线。</li>
<li><strong>低成本</strong>：不需要额外的复杂硬件。</li>
</ol>
<h3 id="5-2-缺点"><a href="#5-2-缺点" class="headerlink" title="5.2 缺点"></a>5.2 缺点</h3><ol>
<li><strong>速度相对较慢</strong>：相比 SPI 或 I2C，UART 的传输速度通常较低（虽然现代 UART 模块也能达到很高的波特率）。</li>
<li><strong>无主从结构</strong>：UART 是点对点通信，不能像 I2C 那样挂载多个从设备。</li>
<li><strong>无错误检测&#x2F;纠正</strong>：标准的奇偶校验功能有限，对于高可靠性要求的数据传输，可能需要额外的协议层（如 CRC 校验）。</li>
<li><strong>距离有限</strong>：TTL 电平的 UART 通常适用于短距离通信。RS-232 虽然可以传输更远，但仍有距离限制。</li>
<li><strong>波特率匹配</strong>：发送方和接收方必须精确匹配波特率，否则会产生数据错误。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>UART 作为一种历史悠久且广泛应用的串行通信协议，因其简单、可靠和易于实现的特点，成为嵌入式系统中不可或缺的一部分。无论是调试输出、与传感器模块通信还是与其他微控制器交互，UART 都提供了一种高效的解决方案。理解其核心参数、数据帧结构以及在不同微控制器平台上的应用，是进行嵌入式开发的必备技能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-09-06_UART%20(%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E5%99%A8)%20%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2024/2024-09-06_UART%20(%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E5%99%A8)%20%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/">嵌入式系统</a><a class="post-meta__tags" href="/tags/%E7%A1%AC%E4%BB%B6%E7%BC%96%E7%A8%8B/">硬件编程</a><a class="post-meta__tags" href="/tags/%E7%A1%AC%E4%BB%B6%E5%8D%8F%E8%AE%AE/">硬件协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-09-09_MQTT%20(Message%20Queuing%20Telemetry%20Transport)%20%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" title="MQTT (Message Queuing Telemetry Transport) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MQTT (Message Queuing Telemetry Transport) 协议详解</div></div><div class="info-2"><div class="info-item-1"> MQTT (Message Queuing Telemetry Transport) 是一种基于 发布&#x2F;订阅 (Publish&#x2F;Subscribe) 模式的轻量级消息协议。它专门设计用于在资源受限的设备和低带宽、高延迟或不可靠的网络环境下，提供可靠的消息传输服务。MQTT 因其简洁、高效和对物联网 (IoT) 场景的良好支持而广受欢迎。  核心思想：MQTT 通过引入一个中心化的消息代理 (Broker) 来解耦消息的发布者 (Publisher) 和订阅者 (Subscriber)，实现异步通信。这种模式使得设备之间无需直接通信，降低了系统的复杂性和耦合度。   一、为什么需要 MQTT？传统的客户端&#x2F;服务器 (Client&#x2F;Server) 模式在物联网场景下存在一些局限性：  资源受限：物联网设备通常内存小、处理能力弱、功耗要求高，复杂的 HTTP&#x2F;HTTPS 协议开销较大。 网络环境恶劣：蜂窝网络、卫星网络等可能存在高延迟、低带宽、频繁断线等问题。 一对多&#x2F;多对一通信：许多物联网应用需要一个设备向多个接收者发送数...</div></div></div></a><a class="pagination-related" href="/2024/2024-09-05_SPI%20(Serial%20Peripheral%20Interface)%20%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" title="SPI (Serial Peripheral Interface) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SPI (Serial Peripheral Interface) 协议详解</div></div><div class="info-2"><div class="info-item-1"> SPI (Serial Peripheral Interface) 是一种高性能、全双工、同步串行通信协议，由 Motorola 公司在 1980 年代中期开发。它主要用于在微控制器 (Master) 和各种外设 (Slave) 之间进行短距离、高速的数据交换。SPI 协议因其简单、灵活和高速的特点，在闪存、EEPROM、传感器、实时时钟、LCD 驱动器等众多嵌入式应用中得到了广泛应用。  核心思想：基于四条线（SCLK、MOSI、MISO、CS）实现同步全双工通信，Master 驱动时钟，并通过 CS 选择 Slave。 速度快，但线材多且不具备地址分配能力。   一、SPI 协议概述SPI 是一种主从式 (Master-Slave) 架构的通信协议，通常有一个主设备 (Master) 和一个或多个从设备 (Slave)。  主设备 (Master)：负责启动和控制通信，提供时钟信号。 从设备 (Slave)：在主设备的控制下进行数据传输。  主要特点：  全双工 (Full-Duplex)：主设备和从设备可以同时发送和接收数据。 同步 (Synchronous)：通信由一个...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-09-04_I2C%20(Inter-Integrated%20Circuit)%20%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" title="I2C (Inter-Integrated Circuit) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-04</div><div class="info-item-2">I2C (Inter-Integrated Circuit) 协议详解</div></div><div class="info-2"><div class="info-item-1"> I2C (Inter-Integrated Circuit) 是一种多主从、半双工、同步串行通信协议，由 Philips Semiconductors (现 NXP) 在 1982 年开发。它以其简单的两线接口（SDA 和 SCL）而闻名，广泛应用于微控制器和各种外设之间进行短距离、中低速的数据交换。I2C 协议因其引脚少、易于扩展等特点，在传感器、EEPROM、LCD 驱动器、实时时钟等众多嵌入式系统中扮演着重要角色。  核心思想：基于两条线（SDA、SCL）实现多主多从通信，通过设备地址进行寻址，并有应答机制确保数据传输可靠性。 线材少、可扩展性强，但速度相对较慢。   一、I2C 协议概述I2C 是一种多主多从 (Multi-Master, Multi-Slave) 架构的通信协议，允许总线上有多个主设备和多个从设备。  主设备 (Master)：发起和终止通信，生成时钟信号 (SCL)，并向从设备发送或请求数据。 从设备 (Slave)：响应主设备的请求，根据分配的唯一地址进行通信。  主要特点：  两线接口：仅需要两条线——SDA (串行数据线) 和 SCL (串行时...</div></div></div></a><a class="pagination-related" href="/2024/2024-09-05_SPI%20(Serial%20Peripheral%20Interface)%20%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" title="SPI (Serial Peripheral Interface) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-05</div><div class="info-item-2">SPI (Serial Peripheral Interface) 协议详解</div></div><div class="info-2"><div class="info-item-1"> SPI (Serial Peripheral Interface) 是一种高性能、全双工、同步串行通信协议，由 Motorola 公司在 1980 年代中期开发。它主要用于在微控制器 (Master) 和各种外设 (Slave) 之间进行短距离、高速的数据交换。SPI 协议因其简单、灵活和高速的特点，在闪存、EEPROM、传感器、实时时钟、LCD 驱动器等众多嵌入式应用中得到了广泛应用。  核心思想：基于四条线（SCLK、MOSI、MISO、CS）实现同步全双工通信，Master 驱动时钟，并通过 CS 选择 Slave。 速度快，但线材多且不具备地址分配能力。   一、SPI 协议概述SPI 是一种主从式 (Master-Slave) 架构的通信协议，通常有一个主设备 (Master) 和一个或多个从设备 (Slave)。  主设备 (Master)：负责启动和控制通信，提供时钟信号。 从设备 (Slave)：在主设备的控制下进行数据传输。  主要特点：  全双工 (Full-Duplex)：主设备和从设备可以同时发送和接收数据。 同步 (Synchronous)：通信由一个...</div></div></div></a><a class="pagination-related" href="/2024/2024-09-09_MQTT%20(Message%20Queuing%20Telemetry%20Transport)%20%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" title="MQTT (Message Queuing Telemetry Transport) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-09</div><div class="info-item-2">MQTT (Message Queuing Telemetry Transport) 协议详解</div></div><div class="info-2"><div class="info-item-1"> MQTT (Message Queuing Telemetry Transport) 是一种基于 发布&#x2F;订阅 (Publish&#x2F;Subscribe) 模式的轻量级消息协议。它专门设计用于在资源受限的设备和低带宽、高延迟或不可靠的网络环境下，提供可靠的消息传输服务。MQTT 因其简洁、高效和对物联网 (IoT) 场景的良好支持而广受欢迎。  核心思想：MQTT 通过引入一个中心化的消息代理 (Broker) 来解耦消息的发布者 (Publisher) 和订阅者 (Subscriber)，实现异步通信。这种模式使得设备之间无需直接通信，降低了系统的复杂性和耦合度。   一、为什么需要 MQTT？传统的客户端&#x2F;服务器 (Client&#x2F;Server) 模式在物联网场景下存在一些局限性：  资源受限：物联网设备通常内存小、处理能力弱、功耗要求高，复杂的 HTTP&#x2F;HTTPS 协议开销较大。 网络环境恶劣：蜂窝网络、卫星网络等可能存在高延迟、低带宽、频繁断线等问题。 一对多&#x2F;多对一通信：许多物联网应用需要一个设备向多个接收者发送数...</div></div></div></a><a class="pagination-related" href="/2024/2024-05-12_STM32%E5%8D%95%E7%89%87%E6%9C%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E9%80%9A%E7%94%A8%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8/" title="STM32单片机详解：高性能通用微控制器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-12</div><div class="info-item-2">STM32单片机详解：高性能通用微控制器</div></div><div class="info-2"><div class="info-item-1"> STM32 单片机 是由意法半导体（STMicroelectronics）基于 ARM Cortex-M 内核（如 Cortex-M0&#x2F;M0+&#x2F;M3&#x2F;M4&#x2F;M7）设计生产的 32 位微控制器系列。它以其高性能、低功耗、丰富的外设、强大的生态系统和广泛的应用领域，成为当今嵌入式开发领域最受欢迎的处理器之一，广泛应用于物联网、工业控制、医疗设备、消费电子、汽车电子等各类产品中。  核心思想：STM32 是高性能、低功耗的 32 位 ARM Cortex-M 微控制器，集成了丰富的外设和强大的处理能力，并通过庞大的生态系统和开发工具，为复杂的嵌入式应用提供了灵活且强大的解决方案。   一、STM32 单片机的起源与家族STM32 系列微控制器最初于 2007 年推出，以其强大的处理能力（相对于传统的 8 位&#x2F;16 位单片机）、合理的成本和全面的生态系统迅速占领市场。它不是特指某一款芯片，而是一个庞大的产品家族，涵盖了从超低功耗到高性能的各种应用需求。 1.1 ARM Cortex-M 系列内核STM32 采用的 ARM Cortex-...</div></div></div></a><a class="pagination-related" href="/2024/2024-05-08_51%E5%8D%95%E7%89%87%E6%9C%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%85%A5%E9%97%A8%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8/" title="51单片机详解：经典嵌入式入门微控制器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-08</div><div class="info-item-2">51单片机详解：经典嵌入式入门微控制器</div></div><div class="info-2"><div class="info-item-1"> 51单片机，通常指基于 Intel MCS-51 架构的微控制器，是微控制器发展史上一个里程碑式的产品系列。它因其结构简单、指令系统精炼、价格低廉、易于上手等特点，在教育、工业控制、消费电子等领域得到了广泛应用，至今仍是许多入门级嵌入式系统设计和学习的首选平台。虽然其性能可能不及现代的 ARM 等32位微控制器，但其经典的架构和丰富的外设资源，使其成为理解微控制器工作原理、学习底层编程的绝佳工具。  核心思想：51单片机集成了 CPU、RAM、ROM、并行I&#x2F;O口、定时器&#x2F;计数器、串行通信口等基本功能于一体的微型计算机，在一个芯片上实现了“控制”的核心功能，是嵌入式系统最基础的构成单元。   一、51单片机的起源与发展51单片机最初由 Intel 公司于 1980 年代推出，型号为 80C51&#x2F;8051，属于其 MCS-51 系列。其经典的哈佛指令结构、8位数据宽度、16位地址宽度等特性，迅速成为市场上的主流微控制器。随着技术发展，多家厂商（如 Atmel、NXP、STC、华大等）推出了兼容 MCS-51 指令集的增强型或改进型单片机，如 AT89...</div></div></div></a><a class="pagination-related" href="/2024/2024-05-27_ESP32%20%E8%8A%AF%E7%89%87%E8%AF%A6%E8%A7%A3/" title="ESP32 芯片详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-27</div><div class="info-item-2">ESP32 芯片详解</div></div><div class="info-2"><div class="info-item-1"> ESP32 是由乐鑫科技 (Espressif Systems) 开发的一系列低成本、低功耗的系统级芯片 (SoC)，集成了 Wi-Fi 和双模蓝牙功能。它专为物联网 (IoT) 应用、移动设备、可穿戴电子产品以及其他新兴的物联网领域而设计。凭借其强大的性能、丰富的硬件资源和极具竞争力的价格，ESP32 已经成为全球创客、开发者和公司在物联网项目中的首选芯片之一。  核心思想：将强大的双核处理器、Wi-Fi、双模蓝牙、大量外设集成在一个小巧的芯片中，并通过成本效益极高的方式提供给开发者，极大地降低了物联网开发的门槛。   一、ESP32 简介与发展历程1.1 ESP 系列芯片概述乐鑫科技的 ESP 系列芯片在物联网领域取得了巨大成功，主要包括：  ESP8266：乐鑫的第一款里程碑式产品，集成了 Wi-Fi 功能。它凭借极低的成本和开源社区的强大支持，迅速占领了物联网市场，成为智能家居、远程控制等应用的首选。 ESP32：在 ESP8266 的基础上进行了全面升级，引入了双核处理器、双模蓝牙（经典蓝牙 + 低功耗蓝牙 BLE）以及更丰富的外设接口，性能和功能都有了质的飞跃。 E...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">194</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">170</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">59</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-UART%EF%BC%9F"><span class="toc-text">一、为什么需要 UART？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81UART-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%8F%82%E6%95%B0"><span class="toc-text">二、UART 的核心概念与通信参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-UART-%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">2.1 UART 数据帧结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81UART-%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-RS-232-TTL"><span class="toc-text">三、UART 的硬件实现 (RS-232, TTL)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81UART-%E5%9C%A8-Arduino-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">四、UART 在 Arduino 中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Arduino-Uno-AVR-%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">4.1 Arduino Uno (AVR 微控制器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ESP32-Arduino"><span class="toc-text">4.2 ESP32 Arduino</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81UART-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">五、UART 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BC%98%E7%82%B9"><span class="toc-text">5.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">5.2 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-21.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>