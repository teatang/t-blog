<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CIDR和子网掩码详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CIDR (Classless Inter-Domain Routing，无类别域间路由) 和子网掩码 (Subnet Mask) 是 IP 地址管理和路由技术中的两个核心概念。它们共同解决了传统 IP 地址分类的局限性，实现了更高效的 IP 地址分配和更灵活的网络划分。理解这两个概念对于构建和管理现代 IP 网络至关重要。  核心思想：CIDR 使用“IP 地址&#x2F;前缀长度”的格式，通">
<meta property="og:type" content="article">
<meta property="og:title" content="CIDR和子网掩码详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-04-28_CIDR%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="CIDR (Classless Inter-Domain Routing，无类别域间路由) 和子网掩码 (Subnet Mask) 是 IP 地址管理和路由技术中的两个核心概念。它们共同解决了传统 IP 地址分类的局限性，实现了更高效的 IP 地址分配和更灵活的网络划分。理解这两个概念对于构建和管理现代 IP 网络至关重要。  核心思想：CIDR 使用“IP 地址&#x2F;前缀长度”的格式，通">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg">
<meta property="article:published_time" content="2024-04-27T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-28T03:02:33.847Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="网络技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CIDR和子网掩码详解",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-04-28_CIDR%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg",
  "datePublished": "2024-04-27T22:24:00.000Z",
  "dateModified": "2025-10-28T03:02:33.847Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-04-28_CIDR%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CIDR和子网掩码详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">167</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">57</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-22.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">CIDR和子网掩码详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CIDR和子网掩码详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-04-27T22:24:00.000Z" title="发表于 2024-04-28 06:24:00">2024-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-04-28_CIDR%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>CIDR (Classless Inter-Domain Routing，无类别域间路由)</strong> 和<strong>子网掩码 (Subnet Mask)</strong> 是 IP 地址管理和路由技术中的两个核心概念。它们共同解决了传统 IP 地址分类的局限性，实现了更高效的 IP 地址分配和更灵活的网络划分。理解这两个概念对于构建和管理现代 IP 网络至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>CIDR 使用“IP 地址&#x2F;前缀长度”的格式，通过前缀长度直接表示网络部分和主机部分，从而废除了传统的 A&#x2F;B&#x2F;C 类地址概念。子网掩码则是这种前缀长度的二进制表示，用于在 IP 地址中区分网络地址和主机地址。</strong></p>
</div>

<h2 id="一、IP-地址基础回顾"><a href="#一、IP-地址基础回顾" class="headerlink" title="一、IP 地址基础回顾"></a>一、IP 地址基础回顾</h2><p>在深入 CIDR 和子网掩码之前，我们先快速回顾一下 IP 地址的基础知识：</p>
<ul>
<li><strong>IP 地址 (IPv4)</strong>：一个 32 位的二进制数字，通常表示为四个十进制数（0-255）由点分隔的形式，例如 <code>192.168.1.1</code>。</li>
<li><strong>网络地址 (Network Address)</strong>：用于标识一个 IP 子网，所有在该子网内的主机都共享相同的网络地址。</li>
<li><strong>主机地址 (Host Address)</strong>：用于标识子网内的一台特定设备。</li>
<li><strong>广播地址 (Broadcast Address)</strong>：用于向子网内所有设备发送数据包的特殊地址。</li>
</ul>
<h3 id="1-1-传统-IP-地址分类的局限性"><a href="#1-1-传统-IP-地址分类的局限性" class="headerlink" title="1.1 传统 IP 地址分类的局限性"></a>1.1 传统 IP 地址分类的局限性</h3><p>在 CIDR 出现之前，IPv4 地址被分为 A、B、C、D、E 五类。其中：</p>
<ul>
<li><strong>A 类地址</strong>：第一位为 0，网络部分占 8 位 (<code>0-127.x.x.x</code>)，最多有 126 个网络，每个网络可容纳 1600 多万台主机。</li>
<li><strong>B 类地址</strong>：前两位为 10，网络部分占 16 位 (<code>128-191.x.x.x</code>)，最多有 16000 多个网络，每个网络可容纳 65000 多台主机。</li>
<li><strong>C 类地址</strong>：前三位为 110，网络部分占 24 位 (<code>192-223.x.x.x</code>)，最多有 200 多万个网络，每个网络可容纳 254 台主机。</li>
</ul>
<p><strong>问题在于：</strong></p>
<ol>
<li><strong>地址浪费</strong>：B 类地址对于大多数组织来说主机位太多，容易造成大量 IP 地址闲置。而 C 类地址主机位又太少，不够用。</li>
<li><strong>路由表膨胀</strong>：随着互联网的发展，大量的 A&#x2F;B&#x2F;C 类网络都需要在路由表中维护，导致路由器负载增加。</li>
</ol>
<p>CIDR 和子网掩码正是为了解决这些问题而诞生的。</p>
<h2 id="二、子网掩码-Subnet-Mask"><a href="#二、子网掩码-Subnet-Mask" class="headerlink" title="二、子网掩码 (Subnet Mask)"></a>二、子网掩码 (Subnet Mask)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>子网掩码</strong>是一个 32 位的二进制数字，与 IP 地址结合使用，用于<strong>区分 IP 地址中的网络部分和主机部分。</strong></p>
<ul>
<li>子网掩码中<strong>网络部分</strong>对应的二进制位全部为 <code>1</code>。</li>
<li>子网掩码中<strong>主机部分</strong>对应的二进制位全部为 <code>0</code>。</li>
</ul>
<h3 id="2-2-格式与表示"><a href="#2-2-格式与表示" class="headerlink" title="2.2 格式与表示"></a>2.2 格式与表示</h3><p>子网掩码通常以与 IP 地址相同的点分十进制形式表示，例如 <code>255.255.255.0</code>。</p>
<p><strong>示例：</strong><br>一个 IP 地址 <code>192.168.1.100</code> 搭配子网掩码 <code>255.255.255.0</code>。</p>
<table>
<thead>
<tr>
<th align="left">部分</th>
<th align="left">IP地址 (点分十进制)</th>
<th align="left">IP地址 (二进制)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">第一段</td>
<td align="left">192</td>
<td align="left"><code>11000000</code></td>
</tr>
<tr>
<td align="left">第二段</td>
<td align="left">168</td>
<td align="left"><code>10101000</code></td>
</tr>
<tr>
<td align="left">第三段</td>
<td align="left">1</td>
<td align="left"><code>00000001</code></td>
</tr>
<tr>
<td align="left">第四段</td>
<td align="left">100</td>
<td align="left"><code>01100100</code></td>
</tr>
<tr>
<td align="left"><strong>合计</strong></td>
<td align="left"><strong>192.168.1.100</strong></td>
<td align="left"><code>11000000.10101000.00000001.01100100</code></td>
</tr>
<tr>
<td align="left"><strong>子网掩码</strong></td>
<td align="left"><strong>255.255.255.0</strong></td>
<td align="left"><code>11111111.11111111.11111111.00000000</code></td>
</tr>
</tbody></table>
<h3 id="2-3-如何利用子网掩码获取网络地址和主机地址？"><a href="#2-3-如何利用子网掩码获取网络地址和主机地址？" class="headerlink" title="2.3 如何利用子网掩码获取网络地址和主机地址？"></a>2.3 如何利用子网掩码获取网络地址和主机地址？</h3><p>通过将 IP 地址和子网掩码进行<strong>按位与 (AND)</strong> 运算，可以得到网络地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[IP地址 (Binary)] -- 按位与 (AND) --&gt; C[网络地址 (Binary)]</span><br><span class="line">    B[子网掩码 (Binary)] -- 按位与 (AND) --&gt; C</span><br></pre></td></tr></table></figure>

<p><strong>示例：<code>192.168.1.100</code> 和 <code>255.255.255.0</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP 地址:   11000000.10101000.00000001.01100100  (192.168.1.100)</span><br><span class="line">子网掩码:  11111111.11111111.11111111.00000000  (255.255.255.0)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">网络地址:  11000000.10101000.00000001.00000000  (192.168.1.0)</span><br></pre></td></tr></table></figure>
<p>获取到网络地址后，主机地址就是 IP 地址中，子网掩码为 <code>0</code> 的那部分。</p>
<h2 id="三、CIDR-Classless-Inter-Domain-Routing"><a href="#三、CIDR-Classless-Inter-Domain-Routing" class="headerlink" title="三、CIDR (Classless Inter-Domain Routing)"></a>三、CIDR (Classless Inter-Domain Routing)</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p><strong>CIDR (无类别域间路由)</strong> 是一种 IP 地址表示方法，它废弃了传统的 A、B、C 类地址概念，允许 IP 地址的网络部分长度是可变的，从而实现更灵活的 IP 地址分配。</p>
<h3 id="3-2-格式"><a href="#3-2-格式" class="headerlink" title="3.2 格式"></a>3.2 格式</h3><p>CIDR 地址表示为 <code>IP地址/前缀长度</code>。</p>
<ul>
<li><strong>IP地址</strong>：可以是网络地址或主机地址。</li>
<li><strong>前缀长度 (Prefix Length)</strong>：一个十进制数字 (1-32)，表示 IP 地址中<strong>网络部分</strong>的位数。它等同于子网掩码中 <code>1</code> 的个数。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>192.168.1.0/24</code>：表示 IP 地址 <code>192.168.1.0</code>，网络部分占 24 位。</li>
<li><code>10.0.0.0/8</code>：表示 IP 地址 <code>10.0.0.0</code>，网络部分占 8 位。</li>
</ul>
<h3 id="3-3-CIDR-与子网掩码的对应关系"><a href="#3-3-CIDR-与子网掩码的对应关系" class="headerlink" title="3.3 CIDR 与子网掩码的对应关系"></a>3.3 CIDR 与子网掩码的对应关系</h3><p>CIDR 的前缀长度可以直接转换为子网掩码：</p>
<table>
<thead>
<tr>
<th align="left">CIDR 前缀长度</th>
<th align="left">子网掩码</th>
<th align="left">十进制表示</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x2F;8</td>
<td align="left">11111111.00000000.00000000.00000000</td>
<td align="left">255.0.0.0</td>
</tr>
<tr>
<td align="left">&#x2F;16</td>
<td align="left">11111111.11111111.00000000.00000000</td>
<td align="left">255.255.0.0</td>
</tr>
<tr>
<td align="left">&#x2F;24</td>
<td align="left">11111111.11111111.11111111.00000000</td>
<td align="left">255.255.255.0</td>
</tr>
<tr>
<td align="left">&#x2F;28</td>
<td align="left">11111111.11111111.11111111.11110000</td>
<td align="left">255.255.255.240</td>
</tr>
<tr>
<td align="left">&#x2F;30</td>
<td align="left">11111111.11111111.11111111.11111100</td>
<td align="left">255.255.255.252</td>
</tr>
</tbody></table>
<h3 id="3-4-CIDR-的优势"><a href="#3-4-CIDR-的优势" class="headerlink" title="3.4 CIDR 的优势"></a>3.4 CIDR 的优势</h3><ol>
<li><p><strong>IP 地址高效利用 (子网划分 - Subnetting)</strong>：<br>通过调整前缀长度，可以将一个大的网络划分为多个小的子网，或将多个小的子网聚合成一个大的网络 (路由聚合&#x2F;超网)。</p>
<ul>
<li><strong>例子</strong>：传统 C 类地址只能是 <code>/24</code>，只能有 254 个可用 IP。但通过 CIDR，可以将一个 <code>/24</code> 的网络划分为两个 <code>/25</code> 的子网，每个子网有 126 个可用 IP，提高了地址利用率。</li>
</ul>
</li>
<li><p><strong>减少路由表项 (路由聚合 - Route Aggregation&#x2F;Supernetting)</strong>：<br>多个连续的 IP 地址块可以聚合成一个更大的 CIDR 块，路由器只需维护一个聚合路由条目，大大减少了路由器的负担和路由表的规模。</p>
<ul>
<li><strong>例子</strong>：如果一个组织拥有 <code>192.168.0.0/24</code>、<code>192.168.1.0/24</code>、<code>192.168.2.0/24</code>、<code>192.168.3.0/24</code> 这四个网络，通过路由聚合，可以将它们表示为 <code>192.168.0.0/22</code> 一个路由条目。</li>
</ul>
</li>
</ol>
<h2 id="四、子网划分-Subnetting-实践"><a href="#四、子网划分-Subnetting-实践" class="headerlink" title="四、子网划分 (Subnetting) 实践"></a>四、子网划分 (Subnetting) 实践</h2><p>假设我们有一个网络 <code>192.168.1.0/24</code>，包含了 254 个可用 IP。现在我们想把它划分为 4 个子网。</p>
<h3 id="4-1-确定主机位借位数"><a href="#4-1-确定主机位借位数" class="headerlink" title="4.1 确定主机位借位数"></a>4.1 确定主机位借位数</h3><ul>
<li><code>/24</code> 表示网络部分 24 位，主机部分 8 位 (32-24&#x3D;8)。</li>
<li>我们需要 4 个子网。<code>2^n &gt;= 4</code>，所以 <code>n=2</code>。我们需要从主机位借 2 位来做子网位。</li>
<li>新的网络部分长度为 <code>24 + 2 = 26</code> 位。</li>
<li>新的主机部分为 <code>32 - 26 = 6</code> 位。</li>
</ul>
<h3 id="4-2-计算新子网掩码"><a href="#4-2-计算新子网掩码" class="headerlink" title="4.2 计算新子网掩码"></a>4.2 计算新子网掩码</h3><ul>
<li>新的 CIDR 前缀为 <code>/26</code>。</li>
<li>子网掩码：前 26 位为 <code>1</code>，后 6 位为 <code>0</code>。<br><code>11111111.11111111.11111111.11000000</code><br>转换成十进制：<code>255.255.255.192</code>。</li>
</ul>
<h3 id="4-3-计算每个子网的网络地址、广播地址和可用-IP-范围"><a href="#4-3-计算每个子网的网络地址、广播地址和可用-IP-范围" class="headerlink" title="4.3 计算每个子网的网络地址、广播地址和可用 IP 范围"></a>4.3 计算每个子网的网络地址、广播地址和可用 IP 范围</h3><ul>
<li>每个子网可用主机数：<code>2^6 - 2 = 64 - 2 = 62</code> 台。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">子网号</th>
<th align="left">网络地址</th>
<th align="left">主机位 (最后一段)</th>
<th align="left">广播地址</th>
<th align="left">可用 IP 范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>0</strong></td>
<td align="left"><code>192.168.1.0/26</code></td>
<td align="left"><code>00xxxxxx</code></td>
<td align="left"><code>192.168.1.63</code></td>
<td align="left"><code>192.168.1.1</code> - <code>192.168.1.62</code></td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left"><code>192.168.1.64/26</code></td>
<td align="left"><code>01xxxxxx</code></td>
<td align="left"><code>192.168.1.127</code></td>
<td align="left"><code>192.168.1.65</code> - <code>192.168.1.126</code></td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left"><code>192.168.1.128/26</code></td>
<td align="left"><code>10xxxxxx</code></td>
<td align="left"><code>192.168.1.191</code></td>
<td align="left"><code>192.168.1.129</code> - <code>192.168.1.190</code></td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left"><code>192.168.1.192/26</code></td>
<td align="left"><code>11xxxxxx</code></td>
<td align="left"><code>192.168.1.255</code></td>
<td align="left"><code>192.168.1.193</code> - <code>192.168.1.254</code></td>
</tr>
</tbody></table>
<p><strong>表格说明：</strong></p>
<ul>
<li><strong>子网号</strong>：通过借用的主机位 (两位) 的组合 (00, 01, 10, 11) 来区分。</li>
<li><strong>网络地址</strong>：主机位全部为 <code>0</code> 的地址。</li>
<li><strong>广播地址</strong>：主机位全部为 <code>1</code> 的地址。</li>
<li><strong>可用 IP 范围</strong>：除了网络地址和广播地址之外的所有地址。</li>
</ul>
<h2 id="五、VLSM-变长子网掩码"><a href="#五、VLSM-变长子网掩码" class="headerlink" title="五、VLSM (变长子网掩码)"></a>五、VLSM (变长子网掩码)</h2><p>CIDR 的核心思想就是允许不同的子网使用不同长度的子网掩码，这被称为 <strong>VLSM (Variable Length Subnet Masking)</strong>。</p>
<p><strong>场景</strong>：<br>假设一个公司有一个部门需要 50 台主机，另一个部门需要 10 台主机。如果都使用 <code>/26</code> (62 台可用主机)，那么 10 台主机的部门将浪费 50 多个 IP。<br>使用 VLSM，我们可以：</p>
<ul>
<li>为 50 台主机的部门分配一个 <code>/26</code> 的子网 (62 台可用)。</li>
<li>为 10 台主机的部门分配一个 <code>/28</code> 的子网 (14 台可用)。<br>这样可以更有效地利用 IP 地址资源。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul>
<li><strong>子网掩码</strong>：一个 32 位数字，用于划分 IP 地址的网络部分和主机部分。网络部分为 <code>1</code>，主机部分为 <code>0</code>。</li>
<li><strong>CIDR (无类别域间路由)</strong>：一种 IP 地址表示方法 (<code>IP地址/前缀长度</code>)，废弃了传统地址分类，实现了 IP 地址的灵活分配和路由聚合。前缀长度即为子网掩码中 <code>1</code> 的数量。</li>
<li><strong>子网划分</strong>：通过增加子网掩码的长度（借用主机位），将一个大网络划分为多个小网络，提高 IP 地址利用率。</li>
<li><strong>路由聚合</strong>：通过缩短子网掩码的长度（归还网络位），将多个小网络聚合成一个大网络，减少路由表条目。</li>
<li><strong>VLSM (变长子网掩码)</strong>：允许同一网络内部存在不同长度子网掩码的子网，进一步提高了 IP 地址利用效率。</li>
</ul>
<p>CIDR 和子网掩码是现代 IP 网络设计的基石，它们优化了 IP 地址的分配和路由效率，是理解网络拓扑和 IP 通信的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-04-28_CIDR%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2024/2024-04-28_CIDR%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-22.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-05-03_RPC(Remote%20Procedure%20Call)%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3/" title="RPC(Remote Procedure Call)远程过程调用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RPC(Remote Procedure Call)远程过程调用详解</div></div><div class="info-2"><div class="info-item-1"> RPC (Remote Procedure Call)，即 远程过程调用，是一种允许程序执行位于另一台计算机上的子程序（或函数）的技术，而无需程序员显式地为这种远程交互编写代码。简而言之，它使得调用远程服务就像调用本地函数一样简单，极大地简化了分布式系统的开发。  “The basic idea of RPC is to make remote procedure calls appear as similar as possible to local procedure calls for the programmer.”   一、RPC 简介与核心思想1. 什么是 RPC？RPC 是一种进程间通信 (IPC) 机制，它允许一个计算机程序在不了解底层网络技术细节的情况下，请求另一个地址空间（通常是另一台计算机上的进程）的服务。当客户端程序调用一个远程函数时，RPC 系统会负责处理所有网络通信的细节，包括数据序列化、网络传输、错误处理等，最终返回结果给客户端，就像本地函数调用一样。 2. 核心思想 透明性 (Transparency): 尽量让程序员感觉不到调用的是远程服务还是...</div></div></div></a><a class="pagination-related" href="/2024/2024-04-17_Python%20%E7%BB%93%E6%9E%84%E5%8C%96%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%20(Structural%20Pattern%20Matching)%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3/" title="Python 结构化模式匹配 (Structural Pattern Matching) 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python 结构化模式匹配 (Structural Pattern Matching) 深度详解</div></div><div class="info-2"><div class="info-item-1"> Python 的结构化模式匹配 (Structural Pattern Matching) 是在 Python 3.10 中引入的一项强大新特性，灵感来源于其他函数式编程语言。该特性通过 match 和 case 语句，提供了一种简洁、富有表现力的方式来根据数据结构和值进行分支逻辑处理。它不仅是对传统 if/elif/else 语句的补充，更是一种处理复杂数据结构（如列表、字典、对象）的新范式，能够显著提高代码的可读性、可维护性和健壮性。  核心思想：模式匹配允许你将一个主题 (subject) 值与一系列模式 (patterns) 进行比较。当一个模式成功匹配主题值时，相关的代码块将被执行。在此过程中，模式还可以解构 (destructure) 主题值，并将其中的部分绑定到新的变量上，从而直接获取所需的数据。   一、为什么需要结构化模式匹配？背景与痛点在 Python 3.10 之前，处理复杂的数据结构，特别是当需要根据其形状、类型或包含的值进行条件判断时，代码往往会变得冗长且难以阅读。例如，考虑处理来自不同来源的 JSON 数据，或者解析命令行参数，传统的方法通常涉及： ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-02-13_NAT%20%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%A9%BF%E8%B6%8A%E6%9C%BA%E5%88%B6/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a><a class="pagination-related" href="/2024/2024-03-18_%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%20CMI%20%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/" title="中国移动 CMI 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-18</div><div class="info-item-2">中国移动 CMI 网络详解</div></div><div class="info-2"><div class="info-item-1"> CMI (China Mobile International)，即中国移动国际网络，是中国移动的国际出口骨干网络。与中国电信的 CN2 和中国联通的 AS4837&#x2F;AS9929 类似，CMI 专注于提供中国移动用户的高质量国际互联服务。它随着中国移动国际业务的扩张而迅速发展，成为连接中国大陆与全球各地的重要网络基础设施之一。  核心思想：CMI 是中国移动为提升其用户国际访问体验而建立的国际骨干网络。它通过建设自有海缆和海外节点，提供相对稳定、大带宽的国际互联通道。   一、为什么需要 CMI？1.1 中国移动网络的挑战在早期的国际互联方面，中国移动（China Mobile）主要依靠租用其他运营商的国际出口带宽，或者将流量转接到中国电信或中国联通的网络进行国际互联。这种方式存在一些固有的问题：  网络质量不稳定：路由路径通常较长，经过的中间运营商和节点多，导致延迟高、丢包率大。 带宽不足：租用带宽的成本和可用性限制，使得在国际流量高峰期容易出现拥堵。 服务不可控：缺乏对国际链路的端到端控制，难以保证服务质量 (QoS)。 成本高昂：长期租用国际带宽的成本较高。  ...</div></div></div></a><a class="pagination-related" href="/2024/2024-03-19_%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%20CN2%20%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/" title="中国电信 CN2 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="info-item-2">中国电信 CN2 网络详解</div></div><div class="info-2"><div class="info-item-1"> CN2 (ChinaNet Next Generation Carrying Network)，即中国电信下一代承载网络，是中国电信于 2005 年推出的新一代骨干网络。它旨在提供高质量、高可靠、低延迟的网络服务，主要面向政府、企业和高端个人用户。CN2 与传统的 ChinaNet (AS4134，163骨干网) 在架构和技术上都有显著区别，以提供更优质的国际互联体验。  核心思想：将互联网流量分为“优质”和“普通”两类通道，CN2 提供优质通道，通过更少的跳数、更小的丢包率和更低的延迟，显著提升国际互联的稳定性和速度。   一、为什么需要 CN2？1.1 ChinaNet (163骨干网) 的局限性传统的中国电信互联网骨干网，通常被称为 163 网（因其 AS 号为 4134，而 163 是其常用接入号），是国内用户最广泛使用的网络。然而，163 网在国际互联方面存在一些固有的问题：  链路拥堵：作为最常用的骨干网，163 网承载了大量流量，尤其在国际出口处容易出现拥堵，导致延迟高、丢包率大。 路由跳数多：在国际互联时，163 网的路由路径通常较长，经过的中间节点和运营商较多...</div></div></div></a><a class="pagination-related" href="/2024/2024-03-20_%E4%B8%AD%E5%9B%BD%E8%81%94%E9%80%9A%20AS4837%20AS9929%20%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a><a class="pagination-related" href="/2024/2024-10-18_CDN%20(%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C)%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3/" title="CDN (内容分发网络) 服务详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">CDN (内容分发网络) 服务详解</div></div><div class="info-2"><div class="info-item-1"> CDN (Content Delivery Network)，即内容分发网络，是一种构建在现有网络基础之上的智能虚拟网络。它通过将站点内容发布到离用户最近的全球边缘节点，使用户在请求内容时，能够从距离自己最近的服务器获取数据，从而显著加速内容传输、减轻源站负载、提高用户体验和保障服务可用性。  核心思想：将内容缓存到离用户近的地方，让用户就近获取，缩短物理距离，从而缩短加载时间。   一、为什么需要 CDN？在没有 CDN 的情况下，用户访问网站的所有请求都会直接发送到源服务器。这存在几个问题：  访问速度慢：当用户与源服务器之间地理距离较远时，数据传输路径长，网络延迟高，导致页面加载缓慢，尤其是对于图片、视频等大文件。 网络拥堵：跨国或跨洲际网络传输容易受到骨干网带宽限制和拥堵的影响。 源站负载高：所有用户的请求都直接冲击源服务器，在高并发场景下可能导致源服务器过载、响应变慢甚至崩溃。 单点故障风险：源服务器一旦出现故障或遭受攻击，整个网站将无法访问。 安全性弱：源站直接暴露在公网，容易成为 DDoS 攻击的目标。  CDN 旨在解决上述问题，提供以下核心价值：  加速访问：...</div></div></div></a><a class="pagination-related" href="/2024/2024-10-23_DNAT%20(Destination%20Network%20Address%20Translation)%20%E8%AF%A6%E8%A7%A3/" title="DNAT (Destination Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">DNAT (Destination Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> DNAT (Destination Network Address Translation)，即目的网络地址转换，是 NAT (Network Address Translation) 技术的一种重要形式。它主要用于修改 IP 数据包的目的 IP 地址和&#x2F;或目的端口号。在外部网络（如互联网）访问内部私有网络服务器的场景中，DNAT 扮演着核心角色，通常被称为端口转发 (Port Forwarding) 或入站 NAT (Inbound NAT)。通过 DNAT，外部请求可以被透明地重定向到内部的特定服务器，从而允许私有网络内的服务向外部公开，同时又保持内部网络的私密性。  核心思想：将外部请求的目标 IP&#x2F;端口映射到内部私有网络的 IP&#x2F;端口。 实现外部访问内部服务，是服务器对外发布服务的关键技术之一。   一、为什么需要 DNAT？在现代网络架构中，尤其是私有 IP 地址（如 192.168.x.x, 10.x.x.x, 172.16.x.x-172.31.x.x）的广泛使用， DNAT 解决了以下关键问题：  发布内部服务：私有 IP 地址无法...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">167</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">57</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81IP-%E5%9C%B0%E5%9D%80%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE"><span class="toc-text">一、IP 地址基础回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%A0%E7%BB%9F-IP-%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1.1 传统 IP 地址分类的局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81-Subnet-Mask"><span class="toc-text">二、子网掩码 (Subnet Mask)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%A1%A8%E7%A4%BA"><span class="toc-text">2.2 格式与表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-text">2.3 如何利用子网掩码获取网络地址和主机地址？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81CIDR-Classless-Inter-Domain-Routing"><span class="toc-text">三、CIDR (Classless Inter-Domain Routing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A0%BC%E5%BC%8F"><span class="toc-text">3.2 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-CIDR-%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">3.3 CIDR 与子网掩码的对应关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-CIDR-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">3.4 CIDR 的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86-Subnetting-%E5%AE%9E%E8%B7%B5"><span class="toc-text">四、子网划分 (Subnetting) 实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%A1%AE%E5%AE%9A%E4%B8%BB%E6%9C%BA%E4%BD%8D%E5%80%9F%E4%BD%8D%E6%95%B0"><span class="toc-text">4.1 确定主机位借位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%AE%A1%E7%AE%97%E6%96%B0%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-text">4.2 计算新子网掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E5%AD%90%E7%BD%91%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E3%80%81%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8F%AF%E7%94%A8-IP-%E8%8C%83%E5%9B%B4"><span class="toc-text">4.3 计算每个子网的网络地址、广播地址和可用 IP 范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81VLSM-%E5%8F%98%E9%95%BF%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-text">五、VLSM (变长子网掩码)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-22.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>