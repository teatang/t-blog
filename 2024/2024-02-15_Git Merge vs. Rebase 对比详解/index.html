<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git Merge vs. Rebase 对比详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在使用 Git 进行团队协作或分支管理时，git merge 和 git rebase 是两种最常用的将一个分支的修改整合到另一个分支的方法。它们都能达到相同的最终目标——将不同分支历史上的修改合并——但在实现方式、提交历史的呈现以及适用场景上有着显著的区别。理解这两者的不同是熟练掌握 Git 的关键。  核心对比：  Merge (合并)：保留所有分支的原始提交历史，通过产生一个新的合并提交来">
<meta property="og:type" content="article">
<meta property="og:title" content="Git Merge vs. Rebase 对比详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-02-15_Git%20Merge%20vs.%20Rebase%20%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在使用 Git 进行团队协作或分支管理时，git merge 和 git rebase 是两种最常用的将一个分支的修改整合到另一个分支的方法。它们都能达到相同的最终目标——将不同分支历史上的修改合并——但在实现方式、提交历史的呈现以及适用场景上有着显著的区别。理解这两者的不同是熟练掌握 Git 的关键。  核心对比：  Merge (合并)：保留所有分支的原始提交历史，通过产生一个新的合并提交来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg">
<meta property="article:published_time" content="2024-02-14T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-06T05:53:08.143Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="Git">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git Merge vs. Rebase 对比详解",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-02-15_Git%20Merge%20vs.%20Rebase%20%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg",
  "datePublished": "2024-02-14T22:24:00.000Z",
  "dateModified": "2025-10-06T05:53:08.143Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-02-15_Git%20Merge%20vs.%20Rebase%20%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git Merge vs. Rebase 对比详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">39</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-24.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Git Merge vs. Rebase 对比详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git Merge vs. Rebase 对比详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-02-14T22:24:00.000Z" title="发表于 2024-02-15 06:24:00">2024-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-02-15_Git%20Merge%20vs.%20Rebase%20%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在使用 Git 进行团队协作或分支管理时，<code>git merge</code> 和 <code>git rebase</code> 是两种最常用的将一个分支的修改整合到另一个分支的方法。它们都能达到相同的最终目标——将不同分支历史上的修改合并——但在实现方式、提交历史的呈现以及适用场景上有着显著的区别。理解这两者的不同是熟练掌握 Git 的关键。</p>
</blockquote>
<div class="note info flat"><p>核心对比：</p>
<ul>
<li><strong>Merge (合并)</strong>：保留所有分支的原始提交历史，通过产生一个新的合并提交来连接不同的历史。</li>
<li><strong>Rebase (变基)</strong>：将一个分支上的所有提交“移动”到另一个分支的末端，从而形成一个线性的、没有合并提交的提交历史。</li>
</ul>
</div>

<h2 id="一、Git-Merge-合并"><a href="#一、Git-Merge-合并" class="headerlink" title="一、Git Merge (合并)"></a>一、Git Merge (合并)</h2><h3 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h3><p><code>git merge</code> 将两个或多个分支的开发历史整合到一个新的提交中。它会找到两个分支最新的共同祖先，然后将这两个分支从共同祖先到各自最新的提交的所有修改整合到一个新的合并提交 (merge commit) 中。</p>
<h3 id="1-2-提交历史"><a href="#1-2-提交历史" class="headerlink" title="1.2 提交历史"></a>1.2 提交历史</h3><ul>
<li><strong>非线性历史</strong>：<code>git merge</code> 会保留所有分支的原始提交历史，包括每个分支上的每一次提交。当从一个特性分支合并回主分支时，会在主分支上创建一个新的合并提交，这个提交会有两个或更多的父提交。</li>
<li><strong>可追溯性强</strong>：由于所有提交都保留，合并提交明确指示了何时何地进行了合并操作，因此历史是真实的、完整的。</li>
</ul>
<h3 id="1-3-示例场景"><a href="#1-3-示例场景" class="headerlink" title="1.3 示例场景"></a>1.3 示例场景</h3><p>假设 <code>master</code> 分支和 <code>feature</code> 分支并行开发：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A --- B --- C (master)</span><br><span class="line">       \</span><br><span class="line">        D --- E (feature)</span><br></pre></td></tr></table></figure>

<p>在 <code>master</code> 分支上执行 <code>git merge feature</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A --- B --- C --- F (master, feature)</span><br><span class="line">       \         /</span><br><span class="line">        D --- E</span><br></pre></td></tr></table></figure>

<p><code>F</code> 就是那个新的合并提交。它包含了 <code>C</code> 和 <code>E</code> 的所有修改，它的父提交是 <code>C</code> 和 <code>E</code>。</p>
<h3 id="1-4-优点"><a href="#1-4-优点" class="headerlink" title="1.4 优点"></a>1.4 优点</h3><ul>
<li><strong>保留完整历史</strong>：分支的开发痕迹、合并点都清晰可见，更容易理解项目的演变过程。</li>
<li><strong>操作安全简单</strong>：不会重写历史，合并失败可以轻易回滚到合并前的状态。</li>
<li><strong>适用于团队协作</strong>：特别是对于<strong>公共分支</strong>（如 <code>master</code>、<code>develop</code>），普遍采用 <code>merge</code>，避免重写历史给其他团队成员带来困扰。</li>
</ul>
<h3 id="1-5-缺点"><a href="#1-5-缺点" class="headerlink" title="1.5 缺点"></a>1.5 缺点</h3><ul>
<li><strong>提交历史可能混乱</strong>：频繁的特性分支合并会导致大量的合并提交，提交图（commit graph）变得复杂，像“毛线团”，难以阅读。</li>
<li><strong>额外的合并提交</strong>：每次合并都会产生一个新的提交，即使没有实际的代码冲突。</li>
</ul>
<h2 id="二、Git-Rebase-变基"><a href="#二、Git-Rebase-变基" class="headerlink" title="二、Git Rebase (变基)"></a>二、Git Rebase (变基)</h2><h3 id="2-1-工作原理"><a href="#2-1-工作原理" class="headerlink" title="2.1 工作原理"></a>2.1 工作原理</h3><p><code>git rebase</code> 的字面意思是“变基”，即将一个分支的“基础点”改变到另一个分支的最新提交上。它会找到两个分支最新的共同祖先，然后将当前分支上<strong>从共同祖先以来的所有提交</strong>，在目标分支的最新提交之后<strong>重新应用一遍</strong>。</p>
<p>在这个过程中，它并不是简单地移动提交，而是<strong>创建了新的提交</strong>。原有分支上的提交会被丢弃，取而代之的是新的、拥有相同修改内容但不同 SHA-1 值的提交。这就是“重写历史”。</p>
<h3 id="2-2-提交历史"><a href="#2-2-提交历史" class="headerlink" title="2.2 提交历史"></a>2.2 提交历史</h3><ul>
<li><strong>线性历史</strong>：<code>git rebase</code> 会“压平”分支历史，使其看起来像是在目标分支的最新提交之后，线性地进行开发。没有合并提交。</li>
<li><strong>历史被重写</strong>：由于 <code>rebase</code> 会创建新的提交，如果这些提交已经被推送到远程仓库，并且被其他开发者拉取，那么重写历史会带来问题。</li>
</ul>
<h3 id="2-3-示例场景"><a href="#2-3-示例场景" class="headerlink" title="2.3 示例场景"></a>2.3 示例场景</h3><p>仍然是上面的分支结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A --- B --- C (master)</span><br><span class="line">       \</span><br><span class="line">        D --- E (feature)</span><br></pre></td></tr></table></figure>

<p>现在，在 <code>feature</code> 分支上执行 <code>git rebase master</code>：</p>
<ol>
<li>Git 会找到 <code>feature</code> 和 <code>master</code> 的共同祖先 <code>B</code>。</li>
<li>将 <code>feature</code> 分支上在 <code>B</code> 之后的提交 (<code>D</code>, <code>E</code>) 暂时存储起来。</li>
<li>将 <code>feature</code> 分支的头部移动到 <code>master</code> 分支的最新提交 <code>C</code> 上。</li>
<li>然后，将之前存储的提交 (<code>D</code>, <code>E</code>) 在 <code>C</code> 之后<strong>依序重新应用</strong>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A --- B --- C --- D&#x27; --- E&#x27; (feature)</span><br><span class="line">            ^</span><br><span class="line">        (master)</span><br></pre></td></tr></table></figure>

<p>注意 <code>D&#39;</code> 和 <code>E&#39;</code> 是新的提交，它们的 SHA-1 值与 <code>D</code> 和 <code>E</code> 不同，但包含了相同的代码修改。</p>
<p>现在，如果 <code>master</code> 分支想要整合 <code>feature</code> 分支的修改，只需要在 <code>master</code> 上执行 <code>git merge feature</code> (或者更常见的 <code>git pull --rebase</code>，或者如果 <code>master</code> 没有新的提交，直接使用 <code>git push</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A --- B --- C --- D&#x27; --- E&#x27; (master, feature)</span><br></pre></td></tr></table></figure>

<p>这被称为<strong>快进合并 (Fast-Forward Merge)</strong>，因为 <code>master</code> 可以直接将指针移动到 <code>feature</code> 的最新提交，而无需创建新的合并提交。</p>
<h3 id="2-4-优点"><a href="#2-4-优点" class="headerlink" title="2.4 优点"></a>2.4 优点</h3><ul>
<li><strong>提交历史清晰、线性</strong>：提交图非常整洁，易于阅读和理解。</li>
<li><strong>没有额外合并提交</strong>：减少了不必要的提交，使得 <code>git log</code> 输出更干净。</li>
<li><strong>更易进行代码审查</strong>：由于提交是线性的，可以更容易地按顺序审查每个独立的修改。</li>
</ul>
<h3 id="2-5-缺点"><a href="#2-5-缺点" class="headerlink" title="2.5 缺点"></a>2.5 缺点</h3><ul>
<li><strong>重写历史</strong>：这是最主要和最危险的缺点。<strong>永远不要对已经推送到公共仓库的提交进行 <code>rebase</code>！</strong> 因为这会改变这些提交的 SHA-1 值，导致其他开发者在 <code>pull</code> 时遇到严重冲突，甚至可能丢失代码。</li>
<li><strong>冲突解决可能重复</strong>：如果在 <code>rebase</code> 过程中遇到冲突，你需要逐个解决每个重新应用的提交的冲突，可能需要多次解决相同的冲突。</li>
<li><strong>操作复杂性和风险高</strong>：相比 <code>merge</code>，<code>rebase</code> 在处理冲突或回滚时更复杂，更容易出错。</li>
</ul>
<h2 id="三、Merge-vs-Rebase-对比总结"><a href="#三、Merge-vs-Rebase-对比总结" class="headerlink" title="三、Merge vs. Rebase 对比总结"></a>三、Merge vs. Rebase 对比总结</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>git merge</code></th>
<th align="left"><code>git rebase</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left">创建一个合并提交，将不同分支历史连接起来。</td>
<td align="left">将当前分支的提交“移动”并重新应用到目标分支的末端。</td>
</tr>
<tr>
<td align="left"><strong>提交历史</strong></td>
<td align="left"><strong>非线性</strong>，包含所有分支和合并提交。</td>
<td align="left"><strong>线性</strong>，看起来像一条直线，没有合并提交。</td>
</tr>
<tr>
<td align="left"><strong>提交对象</strong></td>
<td align="left">保留原有提交，生成新的合并提交。</td>
<td align="left">重写历史，<strong>生成新的提交对象</strong>。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>高</strong>，不会重写历史，可以随时回滚。</td>
<td align="left"><strong>低</strong>，会重写历史，已推送的提交绝对不能 <code>rebase</code>。</td>
</tr>
<tr>
<td align="left"><strong>易读性</strong></td>
<td align="left">易于追溯分支的实际开发轨迹和合并点。</td>
<td align="left">提交历史简洁、整洁，易于阅读。</td>
</tr>
<tr>
<td align="left"><strong>冲突解决</strong></td>
<td align="left">通常只需解决一次合并提交的冲突。</td>
<td align="left">每一个重新应用的提交都可能需要解决冲突。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>公共分支</strong>（<code>master</code>, <code>develop</code>）的合并；需要保留完整历史。</td>
<td align="left"><strong>个人特性分支</strong>的本地清理（在推送到远程前）；追求线性整洁历史。</td>
</tr>
<tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">“我把我所做的事情整合到你的工作里。”</td>
<td align="left">“把我的工作放在你的工作<strong>之后</strong>，模拟我一直在你的基础上工作。”</td>
</tr>
</tbody></table>
<h2 id="四、何时使用-Merge？何时使用-Rebase？"><a href="#四、何时使用-Merge？何时使用-Rebase？" class="headerlink" title="四、何时使用 Merge？何时使用 Rebase？"></a>四、何时使用 Merge？何时使用 Rebase？</h2><h3 id="1-优先使用-git-merge-的场景"><a href="#1-优先使用-git-merge-的场景" class="headerlink" title="1. 优先使用 git merge 的场景"></a>1. 优先使用 <code>git merge</code> 的场景</h3><ul>
<li><strong>所有已经共享给其他开发者的公共分支</strong>：这是最严格的准则。一旦你的提交被推送到公共仓库，并且其他开发者可能已经拉取了这些提交，就<strong>绝对不要</strong>对这些提交进行 <code>rebase</code>。<code>master</code>、<code>develop</code> 分支的合并总是使用 <code>merge</code>。</li>
<li><strong>需要保留完整的项目演进历史</strong>：如果团队认为合并提交以及分支的真实轨迹是项目重要的一部分，那么 <code>merge</code> 是更好的选择。</li>
<li><strong>对 Git 操作不熟悉或追求安全性</strong>：<code>merge</code> 相对更安全，出现问题更容易解决。</li>
</ul>
<h3 id="2-优先使用-git-rebase-的场景"><a href="#2-优先使用-git-rebase-的场景" class="headerlink" title="2. 优先使用 git rebase 的场景"></a>2. 优先使用 <code>git rebase</code> 的场景</h3><ul>
<li><strong>你的本地特性分支，且未推送到远程（或只推送到你一个人使用的远程分支）</strong>：这是 <code>rebase</code> 最常见的用例。当你在一个特性分支上工作了一段时间，而 <code>master</code> 分支已经有新的更新时，可以在将特性分支合并回 <code>master</code> 之前，先在 <code>feature</code> 分支上 <code>git rebase master</code>，将 <code>master</code> 最新的修改合并到 <code>feature</code> 中，再进行 <code>git merge master</code> (通常是 fast-forward)。</li>
<li><strong>清理提交历史</strong>：在将特性分支推送到远程或合并到主分支之前，使用 <code>git rebase -i</code> (交互式 rebase) 可以 squash（压缩）多个提交、reword（修改提交信息）、fixup（合并提交但丢弃提交信息）甚至删除提交，从而形成一个干净、有意义的提交历史。</li>
<li><strong>追求极度线性的提交历史</strong>：一些团队偏爱没有合并提交的线性历史，认为这样更易于回溯和查看。</li>
</ul>
<h3 id="3-工作流建议"><a href="#3-工作流建议" class="headerlink" title="3. 工作流建议"></a>3. 工作流建议</h3><p>一个常见的 Git 工作流是：</p>
<ol>
<li>从 <code>master</code> (或 <code>develop</code>) 分支创建特性分支 <code>feature-xyz</code>。</li>
<li>在 <code>feature-xyz</code> 上进行多次提交。</li>
<li>在推送到远程之前或合并回 <code>master</code> 之前，检查 <code>master</code> 是否有新的更新。如果有：<ul>
<li><strong>方法 A (使用 <code>rebase</code> 清理)</strong>：在 <code>feature-xyz</code> 上执行 <code>git pull --rebase origin master</code> (或者先 <code>git fetch origin</code>，然后 <code>git rebase origin/master</code>)，将 <code>master</code> 最新的修改同步到 <code>feature-xyz</code> 上，并保持 <code>feature-xyz</code> 的历史线性。解决冲突后，再将 <code>feature-xyz</code> 推送到远程。</li>
<li><strong>方法 B (使用 <code>merge</code> 保留历史)</strong>：在 <code>feature-xyz</code> 上执行 <code>git merge origin/master</code>，将 <code>master</code> 最新的修改合并到 <code>feature-xyz</code> 中，并产生一个合并提交。</li>
</ul>
</li>
<li>当 <code>feature-xyz</code> 完成开发并测试通过后：<ul>
<li>切换回 <code>master</code>。</li>
<li>执行 <code>git merge feature-xyz</code>。如果之前已经 <code>rebase</code> 过了，此时通常会是快进合并；如果之前是 <code>merge</code>，则会产生一个新的合并提交。</li>
</ul>
</li>
</ol>
<p><strong>重点理解：<code>rebase</code> 主要用于</strong>清理你自己的本地本地提交**，而 <code>merge</code> 用于<strong>整合已经存在的、被共享的提交历史</strong>。</p>
<h2 id="五、冲突解决"><a href="#五、冲突解决" class="headerlink" title="五、冲突解决"></a>五、冲突解决</h2><p>无论 <code>merge</code> 还是 <code>rebase</code>，都可能遇到代码冲突。</p>
<ul>
<li><strong><code>merge</code> 冲突</strong>：当你在 <code>git merge</code> 时遇到冲突，Git 会停下来，让你手动解决冲突。解决完冲突后，<code>git add .</code> 然后 <code>git commit</code>，完成合并提交。</li>
<li><strong><code>rebase</code> 冲突</strong>：<code>rebase</code> 可能会在每个重新应用的提交上都遇到冲突。当遇到冲突时，Git 也会停下来。你需要解决冲突，然后 <code>git add .</code>，接着最重要的是运行 <code>git rebase --continue</code> 来继续应用下一个提交。如果你想放弃整个 rebase 过程，可以运行 <code>git rebase --abort</code>。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p><code>git merge</code> 和 <code>git rebase</code> 都是合并分支的重要工具，但它们对项目历史的呈现方式截然不同。</p>
<ul>
<li><strong><code>merge</code> 保留真实、完整的历史，但可能使提交图复杂。</strong></li>
<li><strong><code>rebase</code> 创建线性、整洁的历史，但会重写历史，且不适用于已共享分支。</strong></li>
</ul>
<p>选择哪种方式取决于团队的工作流、对历史可追溯性的需求以及对提交图整洁度的偏好。在团队协作中，最佳实践通常是：<strong>对自己的本地特性分支使用 <code>rebase</code> 来清理提交，而对公共共享分支（如 <code>master</code>）使用 <code>merge</code> 来整合修改。</strong></p>
<p>熟练运用它们，将有助于你和你的团队更高效、更有序地管理项目代码。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-02-15_Git%20Merge%20vs.%20Rebase%20%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2024/2024-02-15_Git%20Merge%20vs.%20Rebase%20%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/Git/">Git</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-24.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-02-22_%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%90%86%E8%A7%A3%E4%B8%8E%E9%80%89%E6%8B%A9%E7%9A%84%E8%89%BA%E6%9C%AF/" title="开源协议详解：理解与选择的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">开源协议详解：理解与选择的艺术</div></div><div class="info-2"><div class="info-item-1"> 在开源软件的世界里，开源协议 (Open Source License) 扮演着至关重要的角色。它定义了你对开源代码的权利和义务：你可以做什么，不能做什么，以及当你修改或分发代码时需要遵守哪些规则。理解这些协议对于开发者、公司和代码使用者来说都至关重要，它不仅关乎合法合规，更影响着项目的成长、社区的形成以及商业模式的选择。  “开源协议是开源世界的宪法，明确了游戏规则，确保了开放与合作的平衡。”   一、什么是开源协议？为什么需要它？开源协议是一份法律文件，它授予用户使用、修改和分发开源软件的权利，但同时也会施加一定的条件和限制。 为什么需要开源协议？  界定权利与义务：明确使用者可以对代码做什么（使用、修改、分发），以及必须做什么（保留版权信息、公开源码等）。 保护贡献者：允许贡献者保留版权，同时授权他人使用，确保其辛勤工作不会被恶意独占。 促进创新：降低了他人基于现有代码进行二次开发和创新的门槛。 建立信任：协议的公开透明有助于社区形成共识，促进协作。 避免法律纠纷：明确的协议条款可以减少因代码使用引起的所有权、责任和版权争议。  核心问题：任何没有明确开源协议的代码，默认...</div></div></div></a><a class="pagination-related" href="/2024/2024-02-05_%E8%BE%B9%E7%BC%98%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%AB%98%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%BA%94%E7%94%A8/" title="边缘函数与边缘计算详解：构建下一代高性能与低延迟应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">边缘函数与边缘计算详解：构建下一代高性能与低延迟应用</div></div><div class="info-2"><div class="info-item-1"> 随着互联网应用越来越复杂，用户对响应速度和体验的要求也越来越高。传统的中心化数据中心模式逐渐暴露出延迟高、带宽成本高等问题。边缘计算和在其之上发展起来的 边缘函数 (Edge Functions)，正是为了解决这些问题而生，它们将计算和数据处理能力推向离用户更近的网络边缘，从而开启了构建高性能、低延迟应用的全新范式。  “边缘计算的核心理念是**‘计算靠近数据和用户’**。它打破了传统云计算的地域限制，让服务响应速度更快，数据处理更高效，是面向未来分布式应用和 IoT 场景的关键技术。”   一、什么是边缘计算 (Edge Computing)？边缘计算是一种分布式计算范式，它将计算、存储和网络资源部署在网络边缘，即靠近数据源和最终用户的物理位置。与将所有数据发送到集中式数据中心进行处理的传统云计算模式不同，边缘计算旨在减少数据传输的距离和延迟，从而提高响应速度、降低带宽消耗并提升数据安全性。 1.1 核心理念 数据本地化处理：在数据生成或靠近用户的地方进行初步处理和分析。 低延迟：减少数据往返中心数据中心的距离，显著降低响应时间。 带宽优化：只将经过处理和有价值的数据传回中心...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-11-02_Git%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="Git命令详解与实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-02</div><div class="info-item-2">Git命令详解与实践</div></div><div class="info-2"><div class="info-item-1"> Git 是一款免费、开源的分布式版本控制系统，旨在快速、高效地处理从小规模到超大规模的所有项目。它由 Linux 内核的创建者 Linus Torvalds 于 2005 年创建。Git 的核心理念是跟踪内容而非文件，并支持非线性开发（即多人并行开发，合并不同的工作流）。  本文将深入介绍 Git 的核心概念、常用命令、工作流程、分支管理策略以及一些最佳实践。 “Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.” —— Git 官方 Slogan   一、Git 核心概念在使用 Git 命令之前，理解其核心概念至关重要。 1. 工作区 (Working Directory) 你电脑上当前可见的目录，包含你项目的所有文件。 你正在进行修改和编辑的地方。  2. 暂存区 (Staging Area &#x2F; Index)...</div></div></div></a><a class="pagination-related" href="/2024/2024-06-04_Mermaid%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%E6%96%87%E6%9C%AC%E6%8F%8F%E8%BF%B0%E7%94%9F%E6%88%90%E5%90%84%E7%A7%8D%E6%BC%82%E4%BA%AE%E5%9B%BE%E8%A1%A8/" title="Mermaid详解：用文本描述生成各种漂亮图表"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-04</div><div class="info-item-2">Mermaid详解：用文本描述生成各种漂亮图表</div></div><div class="info-2"><div class="info-item-1"> 在软件开发、项目管理和技术文档编写中，图表是传达复杂信息、说明系统架构、业务流程或交互逻辑的强大工具。然而，传统上绘制图表往往需要专门的图形编辑软件，操作繁琐，不易版本控制，也难以在文本文件中直接嵌入。这时，Mermaid 应运而生。Mermaid 是一个基于 JavaScript 的库，它允许你使用简单的类 Markdown 文本语法来定义和渲染各种图表，并将其嵌入到 Markdown、HTML 或其他 Web 环境中。它极大地简化了图表的创建、维护和版本控制，是现代文档编写的利器。  “Mermaid 的核心思想是‘图表即代码’。这意味着你可以像编写代码一样编写图表的逻辑，从而实现图表的版本控制、自动化生成和轻松分享。它让复杂的可视化变得触手可及。”   一、Mermaid 简介 官方网站：mermaid.live (在线编辑器) GitHub 仓库：mermaid-js&#x2F;mermaid  Mermaid 是一款基于 JavaScript 的图表绘制工具，它采用文本描述语言来定义图表结构，然后将其渲染成 SVG 或 PNG 格式的图形。它的目标是：  简化图表创建...</div></div></div></a><a class="pagination-related" href="/2024/2024-09-14_FiraCode%E5%AD%97%E4%BD%93%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/" title="FiraCode字体实用教程"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-14</div><div class="info-item-2">FiraCode字体实用教程</div></div><div class="info-2"><div class="info-item-1"> Fira Code 是一款专为程序员设计、广受欢迎的免费等宽字体。它最显著的特点是其独特的 编程连字 (Programming Ligatures) 功能，能够将常用的编程运算符和符号组合渲染成更具可读性和语义化的单一图形符号，极大地提升了代码的可读性和美观度。  “Fira Code is a monospaced font with programming ligatures. This is a font for developers.” —— Fira Code Official Repository   一、Fira Code 简介 项目起源: Fira Code 是基于 Mozilla 的 Fira Mono 字体开发而来的。Fira Mono 是一款优秀且可读性强的等宽字体，Fira Code 在此基础上增加了连字特性。 等宽字体: 作为一款编程字体，Fira Code 是等宽的 (Monospaced)，这意味着所有字符（包括空格）占据相同的宽度，这对于代码对齐和避免视觉混乱至关重要。 免费开源: Fira Code 是免费且开源的，可以在 GitHub 上找到...</div></div></div></a><a class="pagination-related" href="/2025/2025-06-01_LazyGit%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9A%84Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/" title="LazyGit使用解析：你的Git命令行效率神器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-01</div><div class="info-item-2">LazyGit使用解析：你的Git命令行效率神器</div></div><div class="info-2"><div class="info-item-1"> 本文将带你深入了解 LazyGit，一个简单直观的终端 UI Git 客户端。如果你厌倦了反复输入 Git 命令，又觉得 GUI 客户端不够灵活，那么 LazyGit 可能会成为你的新宠。它将终端的强大与 GUI 的便捷完美结合，让你的 Git 工作流变得前所未有的高效和愉悦。  对于开发者而言，Git 无疑是日常工作中不可或缺的工具。然而，即使是最熟练的 Git 用户，也可能被一些重复、繁琐的命令行操作所困扰，例如 git add ., git status, git commit -m &quot;...&quot;, git log --oneline 等等。虽然有各种图形化 Git 客户端，但它们往往意味着脱离终端环境，或多或少牺牲了速度和灵活性。LazyGit 正是为了解决这一痛点而生的——它提供了一个文本用户界面 (TUI)，让你在终端中就能以图形化的方式快速、直观地执行 Git 操作，大幅提升工作效率。   一、为什么选择 LazyGit？LazyGit 并不是简单的 Git 命令别名集合，它提供了一个交互式的视图，将 git status, git branch...</div></div></div></a><a class="pagination-related" href="/2025/2025-04-24_Node.js%20%E6%9C%AC%E5%9C%B0%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3%EF%BC%9Ahttp-server%20%E4%B8%8E%20live-server/" title="Node.js 本地静态服务详解：http-server 与 live-server"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-24</div><div class="info-item-2">Node.js 本地静态服务详解：http-server 与 live-server</div></div><div class="info-2"><div class="info-item-1"> 在前端开发过程中，我们经常需要一个本地服务器来预览 HTML、CSS、JavaScript 等静态文件。虽然许多现代前端框架（如 React, Vue, Angular）都自带了开发服务器，但对于一些简单的项目、纯静态网站或快速原型开发，使用 Node.js 提供轻量级的本地静态服务器会更加方便快捷。本文将详细介绍两个广受欢迎的 Node.js 静态服务器工具：http-server 和 live-server。  “好的本地开发服务器，让你的前端工作流如丝般顺滑。”   一、为什么需要本地静态服务？在浏览器中直接打开本地的 HTML 文件（file:/// 协议）通常会有一些限制和问题：  AJAX&#x2F;Fetch 请求受限：浏览器出于安全考虑（同源策略），不允许 file:/// 协议下的页面进行跨域 AJAX 请求，甚至无法加载本地其他文件的 AJAX 请求。 动态加载问题：某些 JavaScript 模块加载器（如 ES Module import 语句）在 file:/// 协议下可能无法正常工作。 开发工具功能不全：一些浏览器扩展或开发工具可能依赖于 HTTP...</div></div></div></a><a class="pagination-related" href="/2025/2025-05-06_Caddy%20Web%20Server%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E9%9B%85%E9%80%89%E6%8B%A9/" title="Caddy Web Server详解：现代Web服务器的优雅选择"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">Caddy Web Server详解：现代Web服务器的优雅选择</div></div><div class="info-2"><div class="info-item-1"> Caddy 是一款用 Go 语言编写的开源 Web 服务器，以其自动 HTTPS 功能、简洁的配置以及强大的功能而闻名。它被设计成现代 Web 的瑞士军刀，能够胜任静态文件服务、反向代理、负载均衡、API 网关等多种任务，并且在安全性和易用性方面表现出色。  “Caddy 是未来 Web 服务器的样子：默认安全、易于管理、功能强大，并且能够自动处理 HTTPS 证书的申请和续期，让你的网站在几秒钟内上线并享受加密连接。”   一、Caddy 简介1.1 什么是 Caddy？Caddy 是一个高性能、可扩展的 Web 服务器，其核心特性包括：  自动 HTTPS：这是 Caddy 最吸引人的特性之一。对于绝大多数公共可访问的域名，Caddy 可以自动从 Let’s Encrypt 申请、配置和续期 SSL&#x2F;TLS 证书，无需手动干预。 配置简洁：Caddyfile 配置文件语法非常直观易懂，相比 Nginx 和 Apache 更加简洁。 HTTP&#x2F;2 和 HTTP&#x2F;3 支持：Caddy 默认启用 HTTP&#x2F;2，并且是首批支持 QUIC (H...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">92</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">39</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Git-Merge-%E5%90%88%E5%B9%B6"><span class="toc-text">一、Git Merge (合并)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.1 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2"><span class="toc-text">1.2 提交历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><span class="toc-text">1.3 示例场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E4%BC%98%E7%82%B9"><span class="toc-text">1.4 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%BC%BA%E7%82%B9"><span class="toc-text">1.5 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Git-Rebase-%E5%8F%98%E5%9F%BA"><span class="toc-text">二、Git Rebase (变基)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2.1 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2"><span class="toc-text">2.2 提交历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><span class="toc-text">2.3 示例场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%98%E7%82%B9"><span class="toc-text">2.4 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%BC%BA%E7%82%B9"><span class="toc-text">2.5 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Merge-vs-Rebase-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">三、Merge vs. Rebase 对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-Merge%EF%BC%9F%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-Rebase%EF%BC%9F"><span class="toc-text">四、何时使用 Merge？何时使用 Rebase？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-git-merge-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">1. 优先使用 git merge 的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-git-rebase-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2. 优先使用 git rebase 的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BB%BA%E8%AE%AE"><span class="toc-text">3. 工作流建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-text">五、冲突解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-28_HTMX%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8HTML%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E9%A9%B1%E5%8A%A8AJAX%E3%80%81CSS%E8%BF%87%E6%B8%A1%E5%92%8CWebSocket/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"/></a><div class="content"><a class="title" href="/2025/2025-09-28_HTMX%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8HTML%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E9%A9%B1%E5%8A%A8AJAX%E3%80%81CSS%E8%BF%87%E6%B8%A1%E5%92%8CWebSocket/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</a><time datetime="2025-09-27T22:24:00.000Z" title="发表于 2025-09-28 06:24:00">2025-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2详解：在Windows运行Linux的新标准"/></a><div class="content"><a class="title" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准">WSL2详解：在Windows运行Linux的新标准</a><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GoLang Wails 框架详解：用 Web 技术构建桌面应用"/></a><div class="content"><a class="title" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用">GoLang Wails 框架详解：用 Web 技术构建桌面应用</a><time datetime="2025-09-17T22:24:00.000Z" title="发表于 2025-09-18 06:24:00">2025-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis持久化深度解析：RDB与AOF的终极对决与实战优化"/></a><div class="content"><a class="title" href="/2025/2025-09-14_Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9ARDB%E4%B8%8EAOF%E7%9A%84%E7%BB%88%E6%9E%81%E5%AF%B9%E5%86%B3%E4%B8%8E%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96/" title="Redis持久化深度解析：RDB与AOF的终极对决与实战优化">Redis持久化深度解析：RDB与AOF的终极对决与实战优化</a><time datetime="2025-09-13T22:24:00.000Z" title="发表于 2025-09-14 06:24:00">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-24.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2022 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>