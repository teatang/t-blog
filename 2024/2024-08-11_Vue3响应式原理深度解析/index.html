<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Vue3响应式原理深度解析 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vue 3 响应式系统是其 MVVM 框架的核心基石，它让前端开发者能够以声明式的方式构建用户界面，而无需手动操作 DOM。与 Vue 2 基于 Object.defineProperty 的实现不同，Vue 3 借助 ES6 的 Proxy 对象，彻底重构了响应式系统，带来了更高性能、更强大的功能和更灵活的 API。  “Vue 3 的响应式系统是一个优雅而强大的解决方案，它通过 Proxy">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3响应式原理深度解析">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Vue 3 响应式系统是其 MVVM 框架的核心基石，它让前端开发者能够以声明式的方式构建用户界面，而无需手动操作 DOM。与 Vue 2 基于 Object.defineProperty 的实现不同，Vue 3 借助 ES6 的 Proxy 对象，彻底重构了响应式系统，带来了更高性能、更强大的功能和更灵活的 API。  “Vue 3 的响应式系统是一个优雅而强大的解决方案，它通过 Proxy">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg">
<meta property="article:published_time" content="2024-08-10T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-09T15:46:41.749Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="Vue">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Vue3响应式原理深度解析",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg",
  "datePublished": "2024-08-10T22:24:00.000Z",
  "dateModified": "2025-10-09T15:46:41.749Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue3响应式原理深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">103</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">43</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-12.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Vue3响应式原理深度解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/tags/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/tags/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Vue3响应式原理深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-10T22:24:00.000Z" title="发表于 2024-08-11 06:24:00">2024-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/Vue/">Vue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Vue 3 响应式系统</strong>是其 MVVM 框架的核心基石，它让前端开发者能够以声明式的方式构建用户界面，而无需手动操作 DOM。与 Vue 2 基于 <code>Object.defineProperty</code> 的实现不同，Vue 3 借助 ES6 的 <strong><code>Proxy</code></strong> 对象，彻底重构了响应式系统，带来了更高性能、更强大的功能和更灵活的 API。</p>
</blockquote>
<div class="note info flat"><p>“Vue 3 的响应式系统是一个优雅而强大的解决方案，它通过 <code>Proxy</code> 和一套高效的依赖追踪机制，实现了数据与视图的紧密双向绑定，极大地提升了开发体验。”</p>
</div>

<h2 id="一、响应式系统的核心概念"><a href="#一、响应式系统的核心概念" class="headerlink" title="一、响应式系统的核心概念"></a>一、响应式系统的核心概念</h2><p>在深入 Vue 3 响应式原理之前，我们需要理解几个核心概念：</p>
<ol>
<li><strong>数据劫持 (Data Interception)</strong>：当访问或修改数据时，能够执行自定义逻辑。</li>
<li><strong>依赖收集 (Dependency Collection)</strong>：追踪哪些组件或函数正在使用哪些响应式数据。</li>
<li><strong>派发更新 (Trigger Update)</strong>：当响应式数据发生变化时，通知所有依赖于该数据的组件或函数进行更新。</li>
</ol>
<h2 id="二、Vue-2-与-Vue-3-响应式原理对比"><a href="#二、Vue-2-与-Vue-3-响应式原理对比" class="headerlink" title="二、Vue 2 与 Vue 3 响应式原理对比"></a>二、Vue 2 与 Vue 3 响应式原理对比</h2><p>理解 Vue 3 的优势，最好从对比 Vue 2 开始。</p>
<h3 id="2-1-Vue-2：基于-Object-defineProperty"><a href="#2-1-Vue-2：基于-Object-defineProperty" class="headerlink" title="2.1 Vue 2：基于 Object.defineProperty"></a>2.1 Vue 2：基于 <code>Object.defineProperty</code></h3><ul>
<li><strong>实现方式</strong>：在初始化时遍历数据的每个属性，使用 <code>Object.defineProperty</code> 为每个属性设置 <code>getter</code> 和 <code>setter</code>。</li>
<li><strong>优点</strong>：<ul>
<li>在 ES5 环境下工作良好，兼容性好。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ol>
<li><strong>无法检测到属性的添加或删除</strong>：由于 <code>defineProperty</code> 只能劫持已存在的属性，直接添加或删除对象属性无法触发视图更新。需要使用 <code>$set</code> 或 <code>$delete</code>。</li>
<li><strong>无法监听数组索引和长度变化</strong>：对于 <code>arr[index] = newValue</code> 或 <code>arr.length = 0</code> 这样的操作，无法被 <code>defineProperty</code> 捕获。Vue 2 通过<strong>劫持数组的原生方法</strong>（如 <code>push</code>, <code>pop</code>, <code>splice</code> 等）来解决。</li>
<li><strong>深层嵌套对象性能开销大</strong>：初始化时需要深层递归遍历所有属性，如果数据层级很深或数据量很大，性能开销较大。</li>
<li><strong>编码复杂</strong>：需要处理各种边界情况和数组方法的劫持。</li>
</ol>
</li>
</ul>
<h3 id="2-2-Vue-3：基于-Proxy"><a href="#2-2-Vue-3：基于-Proxy" class="headerlink" title="2.2 Vue 3：基于 Proxy"></a>2.2 Vue 3：基于 <code>Proxy</code></h3><ul>
<li><strong>实现方式</strong>：使用 ES6 的 <code>Proxy</code> 对象，代理整个目标对象，拦截所有对该对象的<code>操作</code> (如 <code>get</code>、<code>set</code>、<code>deleteProperty</code>、<code>has</code> 等)。</li>
<li><strong>优点</strong>：<ol>
<li><strong>能够检测到属性的添加和删除</strong>：<code>Proxy</code> 可以拦截 <code>set</code> 和 <code>deleteProperty</code> 操作，因此无论是修改已有属性还是添加&#x2F;删除新属性，都能被捕获。</li>
<li><strong>能够监听数组索引和长度变化</strong>：<code>Proxy</code> 可以拦截<code>get</code> （当访问数组索引时）和 <code>set</code>（修改索引或长度时）操作。</li>
<li><strong>惰性求值 (Lazy Evaluation)</strong>：<code>Proxy</code> 只在访问数据时劫持，不需要在初始化时深层递归遍历，大大减少了初始化开销。只有当属性被访问时，才会被“代理”。</li>
<li><strong>原生 API 支持</strong>：直接使用原生 <code>Proxy</code>，API 更简洁，更易于维护。</li>
<li><strong>更好的 TypeScript 支持</strong>：<code>Proxy</code> 的类型推导能力更强。</li>
</ol>
</li>
<li><strong>缺点</strong>：<ol>
<li><strong>浏览器兼容性要求</strong>：<code>Proxy</code> 是 ES6 新特性，无法在 IE 浏览器中工作。</li>
<li><strong>性能开销</strong>：虽然初始化开销小，但在某些极端情况下，<code>Proxy</code> 的拦截器调用可能会比直接的 <code>defineProperty</code> 多一些，但通常在现代浏览器中性能表现更优。</li>
</ol>
</li>
</ul>
<h2 id="三、Vue-3-响应式系统的核心-API"><a href="#三、Vue-3-响应式系统的核心-API" class="headerlink" title="三、Vue 3 响应式系统的核心 API"></a>三、Vue 3 响应式系统的核心 API</h2><p>Vue 3 响应式系统通过 <code>reactive</code> 和 <code>ref</code> 这两个核心 API 暴露给开发者。</p>
<h3 id="3-1-reactive-函数"><a href="#3-1-reactive-函数" class="headerlink" title="3.1 reactive() 函数"></a>3.1 <code>reactive()</code> 函数</h3><p><code>reactive()</code> 用于创建一个响应式对象或数组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">items</span>: [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>); <span class="comment">// 0</span></span><br><span class="line">state.<span class="property">count</span>++;           <span class="comment">// 触发更新</span></span><br><span class="line">state.<span class="property">user</span>.<span class="property">age</span> = <span class="number">4</span>;      <span class="comment">// 触发更新</span></span><br><span class="line">state.<span class="property">items</span>.<span class="title function_">push</span>(<span class="string">&#x27;orange&#x27;</span>); <span class="comment">// 触发更新</span></span><br><span class="line">state.<span class="property">newProp</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 也可以响应式地添加新属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">user</span>.<span class="property">name</span>;  <span class="comment">// 也可以响应式地删除属性</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li><strong>深层响应式</strong>：<code>reactive</code> 会深层地转换其所有嵌套属性为响应式。</li>
<li><strong>只能作用于对象类型</strong>：参数必须是对象 (plain objects, arrays, Map, Set)。对于原始类型（如 string, number, boolean），请使用 <code>ref</code>。</li>
<li><strong>解构丢失响应性</strong>：直接解构 <code>state</code> 对象会使其属性失去响应性，因为解构出的变量不再是 <code>Proxy</code> 对象的属性了。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; count &#125; = state; <span class="comment">// count 此时是 0 (原始值)，不再是响应式的</span></span><br><span class="line">count++; <span class="comment">// 不会影响 state.count，也不会触发更新</span></span><br></pre></td></tr></table></figure>
解决办法是使用 <code>toRefs</code> 或 <code>toRef</code>。</li>
</ul>
<h3 id="3-2-ref-函数"><a href="#3-2-ref-函数" class="headerlink" title="3.2 ref() 函数"></a>3.2 <code>ref()</code> 函数</h3><p><code>ref()</code> 用于创建一个包装原始类型值（或对象）的响应式引用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello Vue 3&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">ref</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Ref User&#x27;</span> &#125;); <span class="comment">// 也可以包装对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>); <span class="comment">// 访问值时需要 .value</span></span><br><span class="line">count.<span class="property">value</span>++;            <span class="comment">// 修改值时需要 .value，并触发更新</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">value</span>);</span><br><span class="line">message.<span class="property">value</span> = <span class="string">&#x27;New message&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">value</span>.<span class="property">name</span>);</span><br><span class="line">user.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;Updated Ref User&#x27;</span>; <span class="comment">// 内部对象仍由 reactive 处理</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li><strong>包装原始值</strong>：主要用于使原始类型值具有响应性。</li>
<li><strong>通过 <code>.value</code> 访问和修改</strong>：在 JavaScript 中访问或修改 <code>ref</code> 的值时，必须使用 <code>.value</code> 属性。</li>
<li><strong>在模板中自动解包</strong>：在 Vue 模板中，如果 <code>ref</code> 处于顶层属性位置，会自动解包，无需 <code>.value</code>。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 模板中直接使用 count --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>内部 <code>reactive</code> 转换</strong>：如果 <code>ref</code> 包装的是一个对象，Vue 会自动地将这个对象用 <code>reactive</code> 转换，使其内部属性也具有深层响应性。</li>
</ul>
<h3 id="3-3-toRefs-toRef-函数"><a href="#3-3-toRefs-toRef-函数" class="headerlink" title="3.3 toRefs() &#x2F; toRef() 函数"></a>3.3 <code>toRefs()</code> &#x2F; <code>toRef()</code> 函数</h3><ul>
<li><strong><code>toRefs(reactiveObject)</code></strong>：将一个响应式对象的所有<strong>顶层</strong>属性转换为 <code>ref</code> 对象。这在解构响应式对象时非常有用，可以保持响应性。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = <span class="title function_">toRefs</span>(state); <span class="comment">// stateAsRefs 是 &#123; foo: Ref&lt;1&gt;, bar: Ref&lt;2&gt; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = stateAsRefs; <span class="comment">// foo 和 bar 都是 Ref 对象，可以被解构</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">value</span>); <span class="comment">// 访问时仍需 .value</span></span><br><span class="line">foo.<span class="property">value</span>++;            <span class="comment">// 触发更新</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>toRef(reactiveObject, key)</code></strong>：为响应式对象的一个属性创建 <code>ref</code>。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = <span class="title function_">toRef</span>(state, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooRef.<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line">fooRef.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">foo</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四、Vue-3-响应式原理内部实现"><a href="#四、Vue-3-响应式原理内部实现" class="headerlink" title="四、Vue 3 响应式原理内部实现"></a>四、Vue 3 响应式原理内部实现</h2><p>Vue 3 的响应式系统由 <code>@vue/reactivity</code> 包提供，其核心是 <code>Proxy</code> 和一套高效的依赖追踪机制。</p>
<h3 id="4-1-reactive-内部工作原理"><a href="#4-1-reactive-内部工作原理" class="headerlink" title="4.1 reactive 内部工作原理"></a>4.1 <code>reactive</code> 内部工作原理</h3><p>当我们调用 <code>reactive(obj)</code> 时：</p>
<ol>
<li><strong>创建 Proxy</strong>：Vue 会返回一个 <code>obj</code> 的 <code>Proxy</code> 实例。这个 <code>Proxy</code> 会拦截对 <code>obj</code> 的所有操作。</li>
<li><strong><code>track</code> (依赖收集)</strong>：<ul>
<li>当 <code>Proxy</code> 对象的属性被<strong>读取</strong> (通过 <code>get</code> 拦截器) 时，Vue 会检查当前是否存在一个活跃的“副作用函数” (effect function，也就是需要响应式更新的函数或组件渲染函数)。</li>
<li>如果存在，Vue 就会将这个副作用函数与当前被读取的属性建立<strong>依赖关系</strong>。这个关系存储在一个全局的 <code>WeakMap</code> 和 <code>Map</code> 结构中。<ul>
<li><code>targetMap</code> (WeakMap): <code>target</code> -&gt; <code>Map</code> (每个响应式对象)</li>
<li><code>depsMap</code> (Map): <code>key</code> -&gt; <code>Set</code> (每个属性对应的副作用函数集合)</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>trigger</code> (派发更新)</strong>：<ul>
<li>当 <code>Proxy</code> 对象的属性被<strong>修改</strong> (<code>set</code> 拦截器) 或<strong>删除</strong> (<code>deleteProperty</code> 拦截器) 时，Vue 会查找 <code>depsMap</code>，找到所有依赖于该属性的副作用函数。</li>
<li>然后，Vue 会执行这些副作用函数，通常会导致组件重新渲染。</li>
</ul>
</li>
</ol>
<p><strong>简化的伪代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>(); <span class="comment">// 存储对象及其属性的依赖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span>; <span class="comment">// 没有活跃的副作用函数，无需收集</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (dep = <span class="keyword">new</span> <span class="title class_">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  dep.<span class="title function_">add</span>(activeEffect); <span class="comment">// 将当前副作用函数添加到依赖集合中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> dep = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">    dep.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>()); <span class="comment">// 执行所有依赖的副作用函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="title function_">track</span>(target, key); <span class="comment">// 依赖收集</span></span><br><span class="line">      <span class="comment">// 如果是对象，继续对内部对象进行 reactive 转换</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span> ? <span class="title function_">reactive</span>(res) : res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">      <span class="title function_">trigger</span>(target, key); <span class="comment">// 派发更新</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">      <span class="title function_">trigger</span>(target, key); <span class="comment">// 派发更新</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-ref-内部工作原理"><a href="#4-2-ref-内部工作原理" class="headerlink" title="4.2 ref 内部工作原理"></a>4.2 <code>ref</code> 内部工作原理</h3><p><code>ref()</code> 的实现比 <code>reactive()</code> 稍微复杂一点：</p>
<ol>
<li><strong>创建 <code>RefImpl</code> 实例</strong>：<code>ref</code> 返回一个 <code>RefImpl</code> 类的实例。这个实例有一个 <code>_value</code> 属性来存储实际的值。</li>
<li><strong><code>getter</code> 和 <code>setter</code></strong>：<code>RefImpl</code> 的 <code>value</code> 属性通过 <code>getter</code> 和 <code>setter</code> 实现了依赖收集和派发更新。</li>
<li><strong>自动 <code>reactive</code> 转换</strong>：<ul>
<li>在 <code>setter</code> 中，如果新设置的值是一个对象，Vue 会自动将其转换为 <code>reactive</code> 对象。</li>
<li>这意味着 <code>ref(obj)</code> 实际上是 <code>reactive(obj)</code> 加上一个 <code>RefImpl</code> 包装。</li>
</ul>
</li>
<li><strong>模板自动解包</strong>：Vue 编译器在处理模板时，会识别出顶层的 <code>ref</code> 对象，并在编译时自动添加 <code>.value</code>，所以你在模板中无需手动写 <code>.value</code>。</li>
</ol>
<p><strong>简化的伪代码</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">convert</span>(value); <span class="comment">// 如果是对象，会用 reactive() 转换</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 存储依赖这个 ref 的副作用函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="title function_">trackRef</span>(<span class="variable language_">this</span>); <span class="comment">// 收集依赖</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue !== <span class="variable language_">this</span>.<span class="property">_value</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="title function_">convert</span>(newValue); <span class="comment">// 如果是对象，再次转换</span></span><br><span class="line">      <span class="title function_">triggerRef</span>(<span class="variable language_">this</span>); <span class="comment">// 派发更新</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">convert</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> &amp;&amp; val !== <span class="literal">null</span> ? <span class="title function_">reactive</span>(val) : val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trackRef 和 triggerRef 类似于 track 和 trigger，但作用于 RefImpl 实例的 dep</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trackRef</span>(<span class="params">refInstance</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">        refInstance.<span class="property">dep</span>.<span class="title function_">add</span>(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerRef</span>(<span class="params">refInstance</span>) &#123;</span><br><span class="line">    refInstance.<span class="property">dep</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、深入理解依赖追踪-Effect-Functions"><a href="#五、深入理解依赖追踪-Effect-Functions" class="headerlink" title="五、深入理解依赖追踪 (Effect Functions)"></a>五、深入理解依赖追踪 (Effect Functions)</h2><p>在 Vue 3 响应式系统中，组件的渲染函数和 <code>watchEffect</code>、<code>watch</code>、<code>computed</code> 等 API 内部的函数都被视为“副作用函数”（或者可称为“响应式作用” Effect Function）。</p>
<ol>
<li><strong><code>effect</code> 函数</strong>：<br>Vue 内部有一个 <code>effect</code> 函数，它接收一个函数作为参数，并在执行该函数时，将其设置为当前的 <code>activeEffect</code>。<br>当 <code>activeEffect</code> 存在时，所有被访问的响应式属性都会将 <code>activeEffect</code> 添加为自己的依赖。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; effect, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这是一个副作用函数</span></span><br><span class="line">  <span class="comment">// 在这里访问 state.count，就会将这个 effect 函数添加到 state.count 的依赖集合中</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Count changed:&#x27;</span>, state.<span class="property">count</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span>++; <span class="comment">// 输出 &quot;Count changed: 1&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>调度器 (Scheduler)</strong>：<br>当一个响应式数据被修改并触发更新时，绑定的 <code>effect</code> 函数并不会立即执行。Vue 内部有一个调度器，它会将所有触发的 <code>effect</code> 函数放入一个工作队列中，并在下一个微任务（microtask）或宏任务（macrotask）周期统一执行，以优化性能，避免不必要的重复渲染。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Vue 3 的响应式系统凭借 ES6 <code>Proxy</code> 的强大能力，彻底解决了 Vue 2 中 <code>Object.defineProperty</code> 的痛点，带来了：</p>
<ul>
<li><strong>更全面的响应式支持</strong>：能够监听属性的添加、删除和数组的变化。</li>
<li><strong>更高的性能</strong>：初始化时无需深层递归，采用惰性求值。</li>
<li><strong>更简洁的 API</strong>：通过 <code>reactive</code> 和 <code>ref</code> 提供了清晰的响应式声明方式。</li>
<li><strong>更强大的功能</strong>：为 Composition API 提供了坚实的基础，使得逻辑复用和组织更加灵活。</li>
</ul>
<p>理解 <code>Proxy</code> 的拦截机制、<code>track</code> (依赖收集) 和 <code>trigger</code> (派发更新) 的过程，以及 <code>reactive</code> 和 <code>ref</code> 这两个核心 API 的作用和内部实现，是掌握 Vue 3 并高效开发的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">https://blog.tbf1211.xx.kg/2024/2024-08-11_Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-09-02_GoLang%20gRPC%20%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="GoLang gRPC 详解：构建高性能、跨语言的微服务"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">GoLang gRPC 详解：构建高性能、跨语言的微服务</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是 Google 开发的一个高性能、开源的 RPC 框架，支持多种编程语言。它基于 HTTP&#x2F;2 协议传输，并使用 Protocol Buffers (Protobuf) 作为接口定义语言 (IDL) 和数据序列化机制。Go 语言作为云原生时代的明星语言，与 gRPC 的结合更是如虎添翼，是构建高性能、跨语言微服务系统的理想选择。  “gRPC aims to bring the benefits of modern RPC to everyone.”   一、gRPC 简介1. 什么是 gRPC？gRPC 是一种现代的 RPC (远程过程调用) 框架，它允许你在一个语言中定义服务（使用 Protobuf），然后在任何支持 gRPC 的语言中实现客户端和服务器。其核心特性包括：  高性能: 基于 HTTP&#x2F;2 和 Protobuf，提供更快的传输速度和更小的消息体。 多语言支持: 通过代码生成，支持 Go、Java、Python、C++、Node.js、C# 等多种语言。 强类型接口: ...</div></div></div></a><a class="pagination-related" href="/2024/2024-08-03_Go%20Context%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E5%88%A9%E5%99%A8/" title="Go Context详解：并发控制与数据传递的利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go Context详解：并发控制与数据传递的利器</div></div><div class="info-2"><div class="info-item-1"> Go Context (上下文) 包是 Go 语言中用于在 goroutine 之间传递截止时间(deadline)、取消信号(cancellation signal)以及请求范围值(request-scoped values) 的一种标准机制。在编写并发程序时，尤其是在微服务架构中，处理请求的生命周期、超时控制和优雅中止 goroutine 变得至关重要，context 包就是为了解决这些问题而生。  “context 包提供了一种标准的方式来管理并发操作的生命周期。它使得我们能够更加优雅地控制 goroutine 的取消、超时，并方便地在调用链中传递请求相关数据。”   一、为什么需要 Context？设想一个场景：你的 Web 服务接收到一个请求，这个请求会触发一系列的数据库操作、RPC 调用、文件读写等。这些操作可能分布在多个 goroutine 中。 如果没有 context：  超时控制：如果请求长时间未完成，用户可能会失去耐心。你希望能在一定时间后自动取消所有相关的耗时操作。如何通知所有 goroutine 停止工作？ 取消信号：如果用户主动取消了请求，或者上游服...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/2023-10-04_Vue3%20ref%E5%92%8Creactive%E5%AF%B9%E6%AF%94%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE/" title="Vue3 ref和reactive对比解析：深入理解响应式数据"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-04</div><div class="info-item-2">Vue3 ref和reactive对比解析：深入理解响应式数据</div></div><div class="info-2"><div class="info-item-1"> Vue 3 引入的 Composition API (组合式 API) 为我们提供了更强大、更灵活的逻辑组织和复用能力。在 Composition API 中，管理响应式状态的核心就是 ref 和 reactive 这两个函数。理解它们的异同和适用场景，是掌握 Vue 3 响应式系统、编写高效且可维护组件的关键。  本文将详细对比 ref 和 reactive，从原理、用法、优缺点及适用场景等方面进行深入解析，帮助你更好地在 Vue 3 项目中做出选择。   一、 响应式数据的核心概念在 Vue 3 中，响应式数据指的是当数据发生变化时，相关的 DOM 会自动更新。这是通过 ES2015 的 Proxy 对象实现的，Vue 3 利用 Proxy 代理数据对象，从而能够侦测到对象属性的读取和修改。 无论是 ref 还是 reactive，它们最终目的都是创建响应式数据。 二、 reactive 详解1. 概念reactive 函数接收一个 普通 JavaScript 对象（包括数组），并返回该对象的响应式代理 (Proxy)。这个代理对象具有 深度响应性，即对象内部嵌套的所有对象...</div></div></div></a><a class="pagination-related" href="/2023/2023-11-15_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%20DOM%20%E4%B8%8E%20Vue%20%E6%A0%B8%E5%BF%83%E8%A1%A5%E4%B8%81%E6%9C%BA%E5%88%B6%EF%BC%9Apatch(),%20patchVnode(),%20updateChildren()/" title="深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="info-item-2">深入理解虚拟 DOM 与 Vue 核心补丁机制：patch(), patchVnode(), updateChildren()</div></div><div class="info-2"><div class="info-item-1"> 现代前端框架如 Vue 和 React 之所以能提供高性能和优秀的开发体验，很大程度上要归功于 虚拟 DOM (Virtual DOM) 及其配套的 Diff 算法 (补丁机制)。虚拟 DOM 充当了真实 DOM 的一个轻量级抽象层，而 Vue 的补丁机制则负责将虚拟 DOM 的变化高效地反映到真实的浏览器 DOM 上。本文将深入解析虚拟 DOM 的概念，并聚焦 Vue 2 中驱动这一机制的三个核心函数：patch(), patchVnode(), 和 updateChildren()，并辅以 Mermaid 流程图进行可视化说明。  “虚拟 DOM 是前端性能优化的基石，而 Vue 的 patch() 系列函数正是将这块基石转化为实际渲染效率的魔法棒。”   一、虚拟 DOM (Virtual DOM) 再探1.1 什么是虚拟 DOM？虚拟 DOM 是一个用 JavaScript 对象来模拟真实 DOM 节点的数据结构。它是一个轻量级的、内存中的真实 DOM 树的抽象。每一个虚拟节点（VNode）都包含构建一个真实 DOM 节点所需的所有信息，例如：  tag：标签名（如 d...</div></div></div></a><a class="pagination-related" href="/2023/2023-12-04_Vue3%20Hook(%E7%BB%84%E5%90%88%E5%BC%8F%20API)%E4%B8%8EMixin%E5%AF%B9%E6%AF%94%E8%AF%A6%E8%A7%A3/" title="Vue3 Hook(组合式 API)与Mixin对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="info-item-2">Vue3 Hook(组合式 API)与Mixin对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin 两种逻辑复用模式，从多方面进行对比分析，帮助开发者理解它们各自的优缺点，并选择最适合自己项目和团队的模式。   一、 理解 Vue 中的逻辑复用在 Vue 组件开发中，我们经常会遇到需要在多个组件中共享相同的逻辑（例如：处理鼠标位置、计时器、表单验证、主题切换等）。如果没有有效的复用机制，这些逻辑就会在不同组件中重复编写，导致代码冗余、难以维护。  Vue 提供了以下主要方式来解决逻辑复用问题：  Mixin (混入)：Vue 2 的主要逻辑复用方式，也在 Vue 3 中继续支持。 Composition API (组合式 API &#x2F; Vue 3 Hook)：Vue 3 引入...</div></div></div></a><a class="pagination-related" href="/2024/2024-04-06_%E6%89%8B%E5%86%99Promise%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90JS%20Promise%E5%8E%9F%E7%90%86/" title="手写Promise：深入解析JS Promise原理"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-06</div><div class="info-item-2">手写Promise：深入解析JS Promise原理</div></div><div class="info-2"><div class="info-item-1"> JavaScript Promise 是异步编程的核心，它解决了回调地狱（Callback Hell）的问题，让异步代码的编写更加优雅和可维护。然而，Promises 究竟是如何工作的？它背后隐藏了哪些状态管理和回调机制？本文将通过从零开始手写一个简化的 Promise 实现，来深入解析其核心原理。  “理解 Promise 的精髓，就是理解异步状态管理和时序控制。”   一、Promise 的基本概念复习在开始手写之前，我们先快速回顾 Promise 的几个核心概念：  三种状态 (States):  pending (待定): 初始状态，既没有成功，也没有失败。 fulfilled (已成功&#x2F;已兑现): 操作成功完成。 rejected (已失败&#x2F;已拒绝): 操作失败。 Promise 的状态一旦从 pending 变为 fulfilled 或 rejected，就不可逆转，称为 settled (已敲定)。   构造函数: new Promise(executor)  executor 是一个执行器函数，它在 Promise 构造时同步执行。 exec...</div></div></div></a><a class="pagination-related" href="/2024/2024-06-11_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20JavaScript%20Fetch%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E6%AC%A1%20await/" title="深入理解 JavaScript Fetch：为什么需要两次 await？"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-11</div><div class="info-item-2">深入理解 JavaScript Fetch：为什么需要两次 await？</div></div><div class="info-2"><div class="info-item-1"> JavaScript 中的 fetch API 提供了一种现代、强大的方式来发送网络请求。然而，初学者在使用 async/await 语法处理 fetch 请求时，经常会遇到一个困惑：为什么需要两次 await 才能获取到实际的数据？本文将深入探讨 fetch API 的设计原理，解释这“两次等待”背后的逻辑。  “Fetch API 的设计哲学：将 HTTP 响应的元数据与实际数据流分离处理。”   一、fetch API 概览fetch API 是 Web API 的一部分，用于替代老旧的 XMLHttpRequest 对象，提供了一个更强大、更灵活的用于获取资源的接口。它基于 Promise，使得异步请求的处理更加简洁。 一个典型的 fetch 请求（不使用 async/await）看起来是这样的： 123456789101112131415fetch(&#x27;https://api.example.com/data&#x27;)  .then(response =&gt; &#123;    // 第一次 then: 处理响应头和状态    if (!respons...</div></div></div></a><a class="pagination-related" href="/2024/2024-07-04_Electron%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/" title="Electron 开发详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-04</div><div class="info-item-2">Electron 开发详解</div></div><div class="info-2"><div class="info-item-1"> Electron 是 GitHub 开发的一个开源框架，它允许你使用 Web 技术 (HTML, CSS, JavaScript) 构建跨平台的桌面应用程序。这意味着你可以利用已有的前端技能，开发出像 VS Code、Slack、Discord 等专业桌面应用。本文将深入探讨 Electron 的核心概念、开发流程、最佳实践和常见问题。  “Build cross-platform desktop apps with JavaScript, HTML, and CSS.” —— Electron 官方 Slogan   一、Electron 简介Electron 结合了 Chromium 用于渲染页面和 Node.js 用于操作底层系统。  Chromium: 提供强大的 Web 渲染能力，负责界面显示。 Node.js: 提供访问操作系统底层 API 的能力，例如文件系统、网络、进程管理等。  这种结合使得 Web 开发者能够轻松地构建功能丰富的桌面应用程序，并且这些应用可以运行在 Windows、macOS 和 Linux 三大主流操作系统上。 二、核心概念Electron...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">103</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">43</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">一、响应式系统的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Vue-2-%E4%B8%8E-Vue-3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-text">二、Vue 2 与 Vue 3 响应式原理对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Vue-2%EF%BC%9A%E5%9F%BA%E4%BA%8E-Object-defineProperty"><span class="toc-text">2.1 Vue 2：基于 Object.defineProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Vue-3%EF%BC%9A%E5%9F%BA%E4%BA%8E-Proxy"><span class="toc-text">2.2 Vue 3：基于 Proxy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Vue-3-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%B8%E5%BF%83-API"><span class="toc-text">三、Vue 3 响应式系统的核心 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-reactive-%E5%87%BD%E6%95%B0"><span class="toc-text">3.1 reactive() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ref-%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 ref() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-toRefs-toRef-%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 toRefs() &#x2F; toRef() 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Vue-3-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">四、Vue 3 响应式原理内部实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-reactive-%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 reactive 内部工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ref-%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.2 ref 内部工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BE%9D%E8%B5%96%E8%BF%BD%E8%B8%AA-Effect-Functions"><span class="toc-text">五、深入理解依赖追踪 (Effect Functions)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言指向指针的指针(Pointer to Pointer)详解"/></a><div class="content"><a class="title" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解">Go语言指向指针的指针(Pointer to Pointer)详解</a><time datetime="2025-09-30T22:24:00.000Z" title="发表于 2025-10-01 06:24:00">2025-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-28_HTMX%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8HTML%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E9%A9%B1%E5%8A%A8AJAX%E3%80%81CSS%E8%BF%87%E6%B8%A1%E5%92%8CWebSocket/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"/></a><div class="content"><a class="title" href="/2025/2025-09-28_HTMX%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8HTML%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E9%A9%B1%E5%8A%A8AJAX%E3%80%81CSS%E8%BF%87%E6%B8%A1%E5%92%8CWebSocket/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</a><time datetime="2025-09-27T22:24:00.000Z" title="发表于 2025-09-28 06:24:00">2025-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2详解：在Windows运行Linux的新标准"/></a><div class="content"><a class="title" href="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/" title="WSL2详解：在Windows运行Linux的新标准">WSL2详解：在Windows运行Linux的新标准</a><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GoLang Wails 框架详解：用 Web 技术构建桌面应用"/></a><div class="content"><a class="title" href="/2025/2025-09-18_GoLang%20Wails%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8%20Web%20%E6%8A%80%E6%9C%AF%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用">GoLang Wails 框架详解：用 Web 技术构建桌面应用</a><time datetime="2025-09-17T22:24:00.000Z" title="发表于 2025-09-18 06:24:00">2025-09-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-12.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><script src="/self/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="150,150,150" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>