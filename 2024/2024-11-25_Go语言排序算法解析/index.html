<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go语言排序算法解析 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序 (Sorting) 是计算机科学中最基础且最重要的算法之一，其目标是将一组数据按照特定的顺序排列。Go 语言作为一门现代编程语言，提供了强大而灵活的排序机制，既包括内置的标准库 sort 包，也允许用户通过实现特定接口来自定义排序逻辑。理解 Go 语言的排序方式，对于编写高效、可维护的代码至关重要。  核心思想：Go 语言的 sort 包提供了一种通用的排序接口和多种高效的排序算法实现。无">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言排序算法解析">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-11-25_Go%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="排序 (Sorting) 是计算机科学中最基础且最重要的算法之一，其目标是将一组数据按照特定的顺序排列。Go 语言作为一门现代编程语言，提供了强大而灵活的排序机制，既包括内置的标准库 sort 包，也允许用户通过实现特定接口来自定义排序逻辑。理解 Go 语言的排序方式，对于编写高效、可维护的代码至关重要。  核心思想：Go 语言的 sort 包提供了一种通用的排序接口和多种高效的排序算法实现。无">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg">
<meta property="article:published_time" content="2024-11-24T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-13T09:18:32.707Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go语言排序算法解析",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-11-25_Go%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg",
  "datePublished": "2024-11-24T22:24:00.000Z",
  "dateModified": "2025-11-13T09:18:32.707Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-11-25_Go%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go语言排序算法解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">187</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-14.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Go语言排序算法解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Go语言排序算法解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-11-24T22:24:00.000Z" title="发表于 2024-11-25 06:24:00">2024-11-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-11-25_Go%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>排序 (Sorting)</strong> 是计算机科学中最基础且最重要的算法之一，其目标是将一组数据按照特定的顺序排列。Go 语言作为一门现代编程语言，提供了强大而灵活的排序机制，既包括内置的<strong>标准库 <code>sort</code> 包</strong>，也允许用户通过实现特定接口来<strong>自定义排序逻辑</strong>。理解 Go 语言的排序方式，对于编写高效、可维护的代码至关重要。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：Go 语言的 <code>sort</code> 包提供了一种通用的排序接口和多种高效的排序算法实现。无论是对基本类型切片还是自定义结构体切片进行排序，都可以通过简单地实现 <code>sort.Interface</code> 接口来完成，而无需关心底层具体的排序算法。</p>
</div>
<hr>
<h2 id="一、Go-语言标准库-sort-包"><a href="#一、Go-语言标准库-sort-包" class="headerlink" title="一、Go 语言标准库 sort 包"></a>一、Go 语言标准库 <code>sort</code> 包</h2><p>Go 语言的标准库 <code>sort</code> 包是进行排序操作的首选。它提供了一套通用的接口和高效的排序函数。</p>
<h3 id="1-1-1-sort-Interface-接口"><a href="#1-1-1-sort-Interface-接口" class="headerlink" title="1.1 1. sort.Interface 接口"></a>1.1 1. <code>sort.Interface</code> 接口</h3><p><code>sort</code> 包的核心是 <code>sort.Interface</code> 接口。任何实现了这个接口的类型都可以使用 <code>sort</code> 包提供的排序函数。<code>sort.Interface</code> 接口定义了三个方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len 返回集合中的元素数量。</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less 报告索引 i 的元素是否应排在索引 j 的元素之前。</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap 交换索引 i 和索引 j 的元素。</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Len()</code>：返回待排序集合的长度。</li>
<li><code>Less(i, j int) bool</code>：比较第 <code>i</code> 个元素和第 <code>j</code> 个元素，如果第 <code>i</code> 个元素应该排在第 <code>j</code> 个元素之前，则返回 <code>true</code>。这是定义排序规则的关键。</li>
<li><code>Swap(i, j int)</code>：交换第 <code>i</code> 个元素和第 <code>j</code> 个元素的位置。</li>
</ul>
<h3 id="1-2-2-对基本类型切片排序"><a href="#1-2-2-对基本类型切片排序" class="headerlink" title="1.2 2. 对基本类型切片排序"></a>1.2 2. 对基本类型切片排序</h3><p><code>sort</code> 包为 Go 语言的内置基本类型切片 (<code>[]int</code>, <code>[]float64</code>, <code>[]string</code>) 提供了便捷的排序函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对整数切片排序</span></span><br><span class="line">	ints := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Original ints:&quot;</span>, ints)</span><br><span class="line">	sort.Ints(ints)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted ints:&quot;</span>, ints) <span class="comment">// Output: [1 2 3 4 6 8]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断整数切片是否已排序</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Is ints sorted?&quot;</span>, sort.IntsAreSorted(ints)) <span class="comment">// Output: true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对浮点数切片排序</span></span><br><span class="line">	floats := []<span class="type">float64</span>&#123;<span class="number">3.14</span>, <span class="number">1.618</span>, <span class="number">2.718</span>, <span class="number">0.577</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Original floats:&quot;</span>, floats)</span><br><span class="line">	sort.Float64s(floats)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted floats:&quot;</span>, floats) <span class="comment">// Output: [0.577 1.618 2.718 3.14]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对字符串切片排序</span></span><br><span class="line">	strings := []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Original strings:&quot;</span>, strings)</span><br><span class="line">	sort.Strings(strings)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted strings:&quot;</span>, strings) <span class="comment">// Output: [apple banana cherry date]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些便捷函数（如 <code>sort.Ints</code>）的底层实现，其实就是为对应的切片类型实现了 <code>sort.Interface</code> 接口，然后调用通用排序函数 <code>sort.Sort()</code>。</p>
<h3 id="1-3-3-对自定义结构体切片排序"><a href="#1-3-3-对自定义结构体切片排序" class="headerlink" title="1.3 3. 对自定义结构体切片排序"></a>1.3 3. 对自定义结构体切片排序</h3><p>当需要对自定义结构体切片进行排序时，我们需要手动为该切片类型实现 <code>sort.Interface</code> 接口的三个方法。</p>
<p><strong>示例：按年龄排序人员列表</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 结构体定义</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Persons 是 Person 结构体切片的别名，我们需要为它实现 sort.Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> Persons []Person</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Len() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Less() 方法：按年龄从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p[i].Age &lt; p[j].Age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Swap() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Persons)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	p[i], p[j] = p[j], p[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := Persons&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;David&quot;</span>, <span class="number">25</span>&#125;, <span class="comment">// 相同年龄的 Bob, David 顺序不确定</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Original people:&quot;</span>, people)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用 sort.Sort 函数进行排序</span></span><br><span class="line">	sort.Sort(people)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted by Age:&quot;</span>, people)</span><br><span class="line">	<span class="comment">// Output: [&#123;Bob 25&#125; &#123;David 25&#125; &#123;Alice 30&#125; &#123;Charlie 35&#125;] 或 [&#123;David 25&#125; &#123;Bob 25&#125; &#123;Alice 30&#125; &#123;Charlie 35&#125;]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反向排序：按年龄从大到小排序</span></span><br><span class="line">	<span class="comment">// 可以重新实现一个 Less 方法，或者使用 sort.Reverse 包装器</span></span><br><span class="line">	sort.Sort(sort.Reverse(people))</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted by Age (Reverse):&quot;</span>, people)</span><br><span class="line">	<span class="comment">// Output: [&#123;Charlie 35&#125; &#123;Alice 30&#125; &#123;David 25&#125; &#123;Bob 25&#125;] 或 [&#123;Charlie 35&#125; &#123;Alice 30&#125; &#123;Bob 25&#125; &#123;David 25&#125;]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复杂排序：先按年龄升序，年龄相同则按名字升序</span></span><br><span class="line">	sort.Sort(sort.By(<span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> people[i].Age != people[j].Age &#123;</span><br><span class="line">			<span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> people[i].Name &lt; people[j].Name</span><br><span class="line">	&#125;))</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted by Age then Name:&quot;</span>, people)</span><br><span class="line">	<span class="comment">// Output: [&#123;Bob 25&#125; &#123;David 25&#125; &#123;Alice 30&#125; &#123;Charlie 35&#125;] - 这里的 Bob 和 David 顺序固定了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>sort.Reverse</code> 辅助函数</strong>：</p>
<p><code>sort.Reverse</code> 是 <code>sort</code> 包提供的一个辅助函数，它接受一个实现了 <code>sort.Interface</code> 的类型，并返回一个新的 <code>sort.Interface</code>，其 <code>Less</code> 方法与原始的 <code>Less</code> 方法逻辑相反。</p>
<h3 id="1-4-4-sort-Slice-和-sort-SliceStable-Go-1-8"><a href="#1-4-4-sort-Slice-和-sort-SliceStable-Go-1-8" class="headerlink" title="1.4 4. sort.Slice 和 sort.SliceStable (Go 1.8+)"></a>1.4 4. <code>sort.Slice</code> 和 <code>sort.SliceStable</code> (Go 1.8+)</h3><p>为了进一步简化自定义类型切片的排序，Go 1.8 引入了 <code>sort.Slice</code> 和 <code>sort.SliceStable</code> 函数。它们不再要求你为切片类型定义三个方法，而是直接接受一个切片和一个 <code>less</code> 函数作为参数。</p>
<ul>
<li><strong><code>sort.Slice(slice interface&#123;&#125;, less func(i, j int) bool)</code></strong>：对任意切片进行排序。</li>
<li><strong><code>sort.SliceStable(slice interface&#123;&#125;, less func(i, j int) bool)</code></strong>：对任意切片进行<strong>稳定排序</strong>。稳定排序意味着相等元素的相对顺序在排序后不会改变。</li>
</ul>
<p><strong>示例：使用 <code>sort.Slice</code> 排序人员列表</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	people := []Person&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;David&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Original people:&quot;</span>, people)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按年龄从小到大排序</span></span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted by Age (Slice):&quot;</span>, people)</span><br><span class="line">	<span class="comment">// Output: [&#123;Bob 25&#125; &#123;David 25&#125; &#123;Alice 30&#125; &#123;Charlie 35&#125;] 或 [&#123;David 25&#125; &#123;Bob 25&#125; &#123;Alice 30&#125; &#123;Charlie 35&#125;]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 SliceStable 保证相同年龄的顺序不变 (这里的初始顺序是 Bob -&gt; David)</span></span><br><span class="line">	people = []Person&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;David&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.SliceStable(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted by Age (Stable Slice):&quot;</span>, people)</span><br><span class="line">	<span class="comment">// Output: [&#123;Bob 25&#125; &#123;David 25&#125; &#123;Alice 30&#125; &#123;Charlie 35&#125;] (Bob 始终在 David 之前)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按年龄降序排序</span></span><br><span class="line">	sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> people[i].Age &gt; people[j].Age <span class="comment">// 注意这里是 &gt;</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Sorted by Age Desc (Slice):&quot;</span>, people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sort.Slice</code> 和 <code>sort.SliceStable</code> 大大简化了自定义结构体切片的排序，特别是对于一次性排序场景。它们是目前Go语言中最推荐的排序方式。</p>
<h3 id="1-5-5-排序算法的选择-底层实现"><a href="#1-5-5-排序算法的选择-底层实现" class="headerlink" title="1.5 5. 排序算法的选择 (底层实现)"></a>1.5 5. 排序算法的选择 (底层实现)</h3><p>Go 语言 <code>sort</code> 包的底层实现会根据切片的大小和特性，<strong>动态选择不同的混合排序算法</strong>以达到最佳性能：</p>
<ul>
<li><strong>对小规模数据</strong>：使用<strong>插入排序 (Insertion Sort)</strong>。插入排序在数据量较小时性能很好，且是稳定的。</li>
<li><strong>对中等规模数据</strong>：使用<strong>堆排序 (Heap Sort)</strong>。堆排序具有 O(N log N) 的最坏时间复杂度，且不需要额外的存储空间。</li>
<li><strong>对大规模数据</strong>：使用<strong>快速排序 (Quicksort)</strong>。快速排序平均性能最佳，时间复杂度为 O(N log N)。</li>
<li><strong><code>sort.Stable</code> (稳定排序)</strong>：使用<strong>归并排序 (Merge Sort)</strong> 或其他稳定的排序算法。归并排序的时间复杂度为 O(N log N)，但需要 O(N) 的额外空间。</li>
</ul>
<p>这种混合排序策略确保了在各种场景下都能获得良好的性能。你无需手动选择排序算法，<code>sort</code> 包会为你处理。</p>
<h2 id="二、各种常见排序算法详解与-Go-语言实现"><a href="#二、各种常见排序算法详解与-Go-语言实现" class="headerlink" title="二、各种常见排序算法详解与 Go 语言实现"></a>二、各种常见排序算法详解与 Go 语言实现</h2><p>虽然 Go 语言的 <code>sort</code> 包已经足够强大，但在某些特定场景下，或者为了学习目的，我们可能需要自己实现一些经典排序算法。以下是一些常见的排序算法及其 Go 语言实现。</p>
<h3 id="2-1-1-冒泡排序-Bubble-Sort"><a href="#2-1-1-冒泡排序-Bubble-Sort" class="headerlink" title="2.1 1. 冒泡排序 (Bubble Sort)"></a>2.1 1. 冒泡排序 (Bubble Sort)</h3><p><strong>思想</strong>：重复遍历列表，比较相邻元素并按正确顺序交换它们。每一轮遍历，最大的元素“冒泡”到列表末尾。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N^2) (平均、最坏、最好)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>何时使用</strong>：非常简单，但效率极低，不推荐用于实际生产环境。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 标志位：如果一轮遍历没有交换发生，说明已经有序</span></span><br><span class="line">		swapped := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; j++ &#123; <span class="comment">// 每轮结束后，最大的元素已在末尾，所以下一轮可少遍历一个</span></span><br><span class="line">			<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">				arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">				swapped = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !swapped &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// 没有元素交换，提前结束</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-选择排序-Selection-Sort"><a href="#2-2-2-选择排序-Selection-Sort" class="headerlink" title="2.2 2. 选择排序 (Selection Sort)"></a>2.2 2. 选择排序 (Selection Sort)</h3><p><strong>思想</strong>：每一轮遍历，从待排序部分选择最小（或最大）的元素，并将其放到已排序部分的末尾。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N^2) (平均、最坏、最好)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>何时使用</strong>：与冒泡排序类似，效率低，不推荐。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		minIdx := i</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> arr[j] &lt; arr[minIdx] &#123;</span><br><span class="line">				minIdx = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i], arr[minIdx] = arr[minIdx], arr[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-插入排序-Insertion-Sort"><a href="#2-3-3-插入排序-Insertion-Sort" class="headerlink" title="2.3 3. 插入排序 (Insertion Sort)"></a>2.3 3. 插入排序 (Insertion Sort)</h3><p><strong>思想</strong>：将一个元素插入到已经排序好的部分。每次取一个未排序的元素，与已排序部分的元素从后往前比较，找到其正确位置并插入。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N^2) (平均、最坏)，O(N) (最好，当数据部分有序时表现出色)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>何时使用</strong>：在数据量较小或数据接近有序时，效率很高。Go 标准库在小规模数据排序时可能使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		key := arr[i] <span class="comment">// 待插入的元素</span></span><br><span class="line">		j := i - <span class="number">1</span></span><br><span class="line">		<span class="comment">// 将比 key 大的元素向右移动</span></span><br><span class="line">		<span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key &#123;</span><br><span class="line">			arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j+<span class="number">1</span>] = key <span class="comment">// 插入 key</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-4-快速排序-Quick-Sort"><a href="#2-4-4-快速排序-Quick-Sort" class="headerlink" title="2.4 4. 快速排序 (Quick Sort)"></a>2.4 4. 快速排序 (Quick Sort)</h3><p><strong>思想</strong>：选择一个“基准元素”(pivot)，通过一趟排序将待排序序列分割成独立的两部分，其中一部分的所有元素都比基准元素小，另一部分的所有元素都比基准元素大。然后对这两部分子序列递归进行快速排序。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N log N) (平均)，O(N^2) (最坏，选择不好基准元素时)</li>
<li><strong>空间复杂度</strong>：O(log N) (递归栈空间)</li>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>何时使用</strong>：平均性能最好的排序算法之一，广泛用于各种场景。Go 标准库在大规模数据排序时使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	quickSortRecursive(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSortRecursive</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">		<span class="comment">// 找到基准元素的最终位置</span></span><br><span class="line">		pivotIndex := partition(arr, low, high)</span><br><span class="line">		<span class="comment">// 对基准元素左右两边的子数组递归排序</span></span><br><span class="line">		quickSortRecursive(arr, low, pivotIndex<span class="number">-1</span>)</span><br><span class="line">		quickSortRecursive(arr, pivotIndex+<span class="number">1</span>, high)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	pivot := arr[high] <span class="comment">// 简单以最后一个元素作为基准</span></span><br><span class="line">	i := low - <span class="number">1</span>       <span class="comment">// 指向小于基准的元素的右边界</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := low; j &lt; high; j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[j] &lt; pivot &#123;</span><br><span class="line">			i++</span><br><span class="line">			arr[i], arr[j] = arr[j], arr[i] <span class="comment">// 交换到左侧</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[i+<span class="number">1</span>], arr[high] = arr[high], arr[i+<span class="number">1</span>] <span class="comment">// 将基准元素放到正确位置</span></span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-5-归并排序-Merge-Sort"><a href="#2-5-5-归并排序-Merge-Sort" class="headerlink" title="2.5 5. 归并排序 (Merge Sort)"></a>2.5 5. 归并排序 (Merge Sort)</h3><p><strong>思想</strong>：分治法。将待排序序列递归地分成左右两个子序列，直到每个子序列只有一个元素。然后将子序列两两合并，每次合并都使子序列有序。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N log N) (平均、最坏、最好)</li>
<li><strong>空间复杂度</strong>：O(N) (需要额外的空间来存储合并的临时数组)</li>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>何时使用</strong>：总是能保证 O(N log N) 性能，常用于需要稳定排序的场景。Go 标准库在实现 <code>sort.Stable</code> 时可能使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mid := <span class="built_in">len</span>(arr) / <span class="number">2</span></span><br><span class="line">	left := MergeSort(arr[:mid])</span><br><span class="line">	right := MergeSort(arr[mid:])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">		<span class="keyword">if</span> left[i] &lt; right[j] &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将剩余元素添加到结果中</span></span><br><span class="line">	result = <span class="built_in">append</span>(result, left[i:]...)</span><br><span class="line">	result = <span class="built_in">append</span>(result, right[j:]...)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-6-堆排序-Heap-Sort"><a href="#2-6-6-堆排序-Heap-Sort" class="headerlink" title="2.6 6. 堆排序 (Heap Sort)"></a>2.6 6. 堆排序 (Heap Sort)</h3><p><strong>思想</strong>：利用堆这种数据结构进行排序。首先将待排序序列构建成一个大顶堆（或小顶堆），然后将堆顶元素（最大或最小）与末尾元素交换，并调整剩余元素使其再次成为堆，重复此过程直到堆为空。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N log N) (平均、最坏、最好)</li>
<li><strong>空间复杂度</strong>：O(1)</li>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>何时使用</strong>：在空间复杂度要求严格，同时需要 O(N log N) 性能的场景。Go 标准库在对中规模数据排序时可能使用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Build max-heap (从第一个非叶子节点开始向上调整)</span></span><br><span class="line">	<span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		heapify(arr, n, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extract elements one by one from heap</span></span><br><span class="line">	<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="comment">// Move current root to end</span></span><br><span class="line">		arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">		<span class="comment">// Call max heapify on the reduced heap</span></span><br><span class="line">		heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapify 函数：维护堆的性质</span></span><br><span class="line"><span class="comment">// n 是堆的大小，i 是要进行堆化操作的根节点索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	largest := i    <span class="comment">// Initialize largest as root</span></span><br><span class="line">	left := <span class="number">2</span>*i + <span class="number">1</span> <span class="comment">// left child</span></span><br><span class="line">	right := <span class="number">2</span>*i + <span class="number">2</span> <span class="comment">// right child</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If left child is larger than root</span></span><br><span class="line">	<span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">		largest = left</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If right child is larger than largest so far</span></span><br><span class="line">	<span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">		largest = right</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If largest is not root</span></span><br><span class="line">	<span class="keyword">if</span> largest != i &#123;</span><br><span class="line">		arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">		<span class="comment">// Recursively heapify the affected sub-tree</span></span><br><span class="line">		heapify(arr, n, largest)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-7-计数排序-Counting-Sort"><a href="#2-7-7-计数排序-Counting-Sort" class="headerlink" title="2.7 7. 计数排序 (Counting Sort)"></a>2.7 7. 计数排序 (Counting Sort)</h3><p><strong>思想</strong>：非比较排序。适用于待排序元素是整数，且范围不大的情况。统计每个数字出现的次数，然后根据计数结果依次填充到输出数组。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N + K) (N为元素数量，K为数据范围)</li>
<li><strong>空间复杂度</strong>：O(K)</li>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>何时使用</strong>：整数范围 K 不大时，性能优于比较排序。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountingSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到最大值，确定计数数组大小</span></span><br><span class="line">	maxVal := arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; maxVal &#123;</span><br><span class="line">			maxVal = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count := <span class="built_in">make</span>([]<span class="type">int</span>, maxVal+<span class="number">1</span>) <span class="comment">// 计数数组</span></span><br><span class="line">	output := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(arr)) <span class="comment">// 输出数组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		count[v]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// count[i] 存储的是小于或等于 i 的元素个数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= maxVal; i++ &#123;</span><br><span class="line">		count[i] += count[i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从后往前遍历原始数组，将元素放到正确位置</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(arr) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		output[count[arr[i]]<span class="number">-1</span>] = arr[i] <span class="comment">// 放在 count[arr[i]] 的前一个位置 (因为 count 是累计数量)</span></span><br><span class="line">		count[arr[i]]--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-8-桶排序-Bucket-Sort"><a href="#2-8-8-桶排序-Bucket-Sort" class="headerlink" title="2.8 8. 桶排序 (Bucket Sort)"></a>2.8 8. 桶排序 (Bucket Sort)</h3><p><strong>思想</strong>：非比较排序。将数据分到有限数量的桶里，每个桶再单独排序（可以递归使用桶排序，或使用其他排序算法），最后合并所有桶中的数据。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>时间复杂度</strong>：O(N + K) (平均，如果数据均匀分布)</li>
<li><strong>空间复杂度</strong>：O(N + K)</li>
<li><strong>稳定性</strong>：依赖于桶内排序算法的稳定性</li>
<li><strong>何时使用</strong>：数据均匀分布在某个范围内时效果最佳。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的桶排序实现 (非通用，假设数据在 0-maxVal 之间)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BucketSort</span><span class="params">(arr []<span class="type">float64</span>)</span></span> []<span class="type">float64</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(arr)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">float64</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到最大值以确定桶的数量或范围</span></span><br><span class="line">	maxVal := arr[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; maxVal &#123;</span><br><span class="line">			maxVal = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建桶，这里创建 n 个桶</span></span><br><span class="line">	buckets := <span class="built_in">make</span>([][]<span class="type">float64</span>, n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将元素分散到桶中</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		idx := <span class="type">int</span>(v * <span class="type">float64</span>(n) / (maxVal + <span class="number">1</span>)) <span class="comment">// 简单的映射函数，将元素分到 n 个桶中</span></span><br><span class="line">		buckets[idx] = <span class="built_in">append</span>(buckets[idx], v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对每个桶内的元素进行排序 (可以使用插入排序或其他算法)</span></span><br><span class="line">	output := <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">0</span>, n)</span><br><span class="line">	<span class="keyword">for</span> _, bucket := <span class="keyword">range</span> buckets &#123;</span><br><span class="line">		sort.Float64s(bucket) <span class="comment">// Go 标准库的浮点数排序</span></span><br><span class="line">		output = <span class="built_in">append</span>(output, bucket...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、总结与排序算法选择建议"><a href="#三、总结与排序算法选择建议" class="headerlink" title="三、总结与排序算法选择建议"></a>三、总结与排序算法选择建议</h2><p>Go 语言在排序方面提供了非常完善和高效的解决方案。</p>
<ul>
<li><strong>对于大多数场景</strong>：优先使用 <strong>Go 标准库 <code>sort</code> 包</strong>。<ul>
<li><strong>基本类型切片</strong> (<code>[]int</code>, <code>[]float64</code>, <code>[]string</code>)：直接使用 <code>sort.Ints()</code>, <code>sort.Float64s()</code>, <code>sort.Strings()</code>。</li>
<li><strong>自定义结构体切片</strong>：推荐使用 <strong><code>sort.Slice()</code> 或 <code>sort.SliceStable()</code></strong>，传入一个匿名 <code>less</code> 函数，代码简洁高效。</li>
<li>如果需要更高程度的封装或与其他方法结合，可以实现 <code>sort.Interface</code> 接口。</li>
</ul>
</li>
<li><strong>Go 标准库的排序算法</strong>：底层采用了<strong>混合排序</strong>策略 (插排、堆排、快排、归并排)，针对不同数据规模和稳定性要求进行了优化，通常能提供最佳性能。</li>
<li><strong>手动实现排序算法</strong>：主要用于<strong>学习理解</strong>或者在非常特殊的、对特定算法有硬性要求的场景（例如，当你知道数据总是部分有序或者数据范围极端小且是整数时，可以考虑非比较排序如计数排序）。但在大多数生产环境中，还是信任标准库的实现为佳。</li>
</ul>
<p>通过掌握 <code>sort.Interface</code>、<code>sort.Slice</code> 以及常见的排序算法原理，你将能有效地在 Go 语言中处理各种排序需求，编写出高效且优雅的代码。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-11-25_Go%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/">https://blog.tbf1211.xx.kg/2024/2024-11-25_Go%E8%AF%AD%E8%A8%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-12-02_WebDAV%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/" title="WebDAV详解：基于HTTP的分布式文件管理协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">WebDAV详解：基于HTTP的分布式文件管理协议</div></div><div class="info-2"><div class="info-item-1"> WebDAV (Web Distributed Authoring and Versioning) 是一种基于 HTTP 协议的扩展协议，它允许客户端直接通过 Web 远程地执行文件和文件夹的操作，包括创建、移动、复制、删除、读取以及管理文件属性和锁机制。简而言之，WebDAV 将 Web 服务器从一个简单的内容消费者转变为一个可供用户直接进行创作和协同工作的平台，将 Web 页面视为可编辑的文档集合。  核心思想：WebDAV 在不改变 HTTP 核心语义的前提下，增加了 HTTP 缺乏的文件锁定、属性管理、命名空间管理等功能，使其能够支持分布式文件系统的基本操作。它将传统的“请求-响应”模式扩展为“文档创作-协作”模式。   一、为什么需要 WebDAV？HTTP 的局限性HTTP (Hypertext Transfer Protocol) 在设计之初，主要是为了实现信息的单向传输，即客户端请求资源，服务器提供资源。它的主要方法 (GET, POST, PUT, DELETE, HEAD, OPTIONS) 专注于获取、提交和替换&#x2F;删除单个资源。 然而，对于 We...</div></div></div></a><a class="pagination-related" href="/2024/2024-11-24_js%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/" title="js特殊运算符的使用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">js特殊运算符的使用</div></div><div class="info-2"><div class="info-item-1">JavaScript中存在一些特殊的运算符，如 ||=、&amp;&amp;=、??=、?.、??，它们在特定的场景下能够帮助开发者简化代码逻辑或增强代码的健壮性。   1. |&#x3D; 逻辑或赋值运算符 (Logical OR assignment)  定义：||&#x3D; 运算符用于指定变量在其值为假（Falsy）时才进行赋值操作。语法：a ||&#x3D; b，意为若 a 为假，则将 b 赋值给 a。使用场景：当需要为一个变量赋值，但仅在其当前值为假时执行赋值操作。  1234let x = 10;let y = 0;x ||= 5; // x 仍为 10，因为 10 被视为真值y ||= 5; // y 现在为 5，因为 0 被视为假值  2. &amp;&amp;&#x3D; 逻辑与赋值运算符 (Logical AND assignment)  定义： &amp;&amp;&#x3D; 运算符用于指定变量在其值为真（Truthy）时才进行赋值操作。语法： a &amp;&amp;&#x3D; b，意为若 a 为真，则将 b 赋值给 a。使用场景： 在需要确保变量已...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-07-12_Go%E8%AF%AD%E8%A8%80%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC(Multiple%20Assignment)%E8%AF%A6%E8%A7%A3/" title="Go语言多重赋值(Multiple Assignment)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-12</div><div class="info-item-2">Go语言多重赋值(Multiple Assignment)详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言的“多重赋值”（Multiple Assignment）是其语言特性中一个非常简洁且强大的功能。它允许你在一个语句中同时给多个变量赋值。这不仅仅是一种语法糖，更是 Go 语言在设计上强调简洁性和实用性的体现，尤其在错误处理、函数返回多个值等方面发挥着核心作用。  核心思想：Go 语言的多重赋值允许在单条语句中同时为多个变量赋值，其核心机制是先评估右侧所有表达式，然后按顺序赋给左侧变量，常用于函数多返回值（尤其是错误处理）、交换变量、接收通道值等场景。   一、多重赋值的基本语法多重赋值的通用格式如下： 1var1, var2, ..., varN = expr1, expr2, ..., exprN  或者使用短变量声明： 1var1, var2, ..., varN := expr1, expr2, ..., exprN  关键点：  左侧 (LHS)：一系列变量名，用逗号 , 分隔。 右侧 (RHS)：一系列表达式，用逗号 , 分隔。 数量匹配：左侧变量的数量必须与右侧表达式值的数量严格匹配。 类型匹配：每个变量的类型必须与对应表达式的值的类型兼容。 求值顺序：右...</div></div></div></a><a class="pagination-related" href="/2024/2024-09-02_GoLang%20gRPC%20%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="GoLang gRPC 详解：构建高性能、跨语言的微服务"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-02</div><div class="info-item-2">GoLang gRPC 详解：构建高性能、跨语言的微服务</div></div><div class="info-2"><div class="info-item-1"> Golang (Go) 因其并发特性、高效的运行时和优秀的网络编程能力，成为开发高性能后端服务，特别是微服务和 RPC 服务的热门选择。gRPC 作为 Google 主导的 RPC 框架，与 Go 语言有着天然的契合。本文将详细介绍如何使用 Go 语言开发 gRPC 项目，包括环境搭建、.proto 文件定义、代码生成、客户端与服务器实现，以及高级特性。  前置条件： 读者需要对 Go 语言有基本的了解，并已安装 Go 开发环境。   一、环境准备在开始 Go gRPC 项目开发之前，需要安装以下工具：  Go 语言环境：确保 Go 已正确安装，并配置好 GOPATH 和 GOROOT。1go version Protobuf 编译器 (protoc)：用于将 .proto 文件编译成 Go 代码。 下载地址：Protocol Buffers GitHub Releases 根据操作系统下载对应版本，解压后将 bin 目录添加到系统 PATH 环境变量中。 验证安装：1protoc --version   Go gRPC 插件：用于 protoc 生成 Go 语言的 gRPC ...</div></div></div></a><a class="pagination-related" href="/2024/2024-10-11_Go%20Modules(go%20mod)%E8%AF%A6%E8%A7%A3/" title="Go Modules(go mod)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-11</div><div class="info-item-2">Go Modules(go mod)详解</div></div><div class="info-2"><div class="info-item-1"> Go Modules 是 Go 语言官方推荐的依赖管理系统，自 Go 1.11 版本引入，并在 Go 1.13 版本中作为默认方案。它旨在解决 Go 语言在依赖管理方面存在的痛点，提供了一种更可靠、可重现且易于使用的模块化方式来组织和管理 Go 项目及其外部依赖。  “Go modules are the future of dependency management in Go.” —— Go 官方博客   一、为什么需要 Go Modules？在 Go Modules 之前，Go 语言的依赖管理主要面临以下挑战：  GOPATH 痛点: 所有项目必须放在 GOPATH 目录下。 所有项目共享同一份依赖库版本，导致不同项目可能需要不同版本的库，容易冲突。 对个人开发者而言，项目结构僵硬，跨项目共享代码不便。   社区工具碎片化: 为了解决 GOPATH 问题，社区涌现了 dep、glide、go-vendor 等第三方依赖管理工具，但没有一个成为官方标准。 这些工具各有优缺点，增加了学习和使用的成本。   版本不确定性: 在没有明确版本控制的情况下，go get 会拉取依赖库...</div></div></div></a><a class="pagination-related" href="/2024/2024-12-04_GoLang%20%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3%20(Go%201.0%20%E8%87%B3%20Go%201.25)/" title="GoLang 各版本新特性详解 (Go 1.0 至 Go 1.25)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-04</div><div class="info-item-2">GoLang 各版本新特性详解 (Go 1.0 至 Go 1.25)</div></div><div class="info-2"><div class="info-item-1"> Go 语言 (Golang) 自 2009 年由 Google 推出以来，以其简洁的语法、内置的并发支持、高效的编译速度和强大的标准库迅速获得了开发者的青睐。自 2012 年发布 Go 1.0 以来，Go 语言每半年发布一个主要版本，持续引入新特性、性能优化、工具改进和安全增强。理解这些版本特性对于 Go 开发者来说至关重要，它能帮助我们编写更高效、更现代且更具可维护性的代码。  核心思想： Go 语言的版本迭代始终秉持“简单性、可靠性、高效性”的原则，聚焦于提升开发效率、运行时性能、内存管理、工具链功能以及语言表达力。   一、Go 1.0 - 1.5：奠基与自举 (Bootstrapping)Go 语言在早期版本主要关注语言的稳定、核心功能的完善以及工具链的成熟。Go 1.5 是一个里程碑，实现了 Go 语言的自举。 1.1 Go 1.0 (2012-03-28) Go 语言的第一个稳定版本：标志着 Go 语言正式可以用于生产环境。 语言规范稳定：承诺 Go 1 兼容性，确保未来版本不会破坏 Go 1.0 代码的兼容性。 核心并发模型：Goroutine 和 Channel...</div></div></div></a><a class="pagination-related" href="/2025/2025-06-13_Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" title="Go语言常用设计模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-13</div><div class="info-item-2">Go语言常用设计模式详解</div></div><div class="info-2"><div class="info-item-1"> 设计模式是对在特定情境下，反复出现的问题提供一套成熟的、可复用的解决方案。Go 语言以其简洁、并发优先的特性，在实现设计模式时通常会有其独特的“Go 惯例”，有时会与传统面向对象设计模式的实现有所不同。本篇将探讨 Go 语言中常用的设计模式，并结合 Go 的特性给出实现示例。  核心思想：Go 语言的设计模式实现通常倾向于简洁、组合而非继承、接口优先以及利用 Goroutine 和 Channel 进行并发处理。   一、Go 语言与设计模式的哲学Go 语言在设计模式的实践上，有一些与传统 OOP 语言不同的哲学：  组合优于继承：Go 没有类继承的概念，而是通过结构体嵌入（Composition）和接口（Interfaces）来实现代码复用和多态。 接口优先：Go 的接口是隐式实现的（implicit interface satisfaction），任何类型只要实现了接口定义的所有方法，就自然地实现了该接口。这使得接口更加灵活，鼓励“小接口，大组合”的原则。 并发原语：Goroutine 和 Channel 是 Go 语言的核心并发原语，许多设计模式在 Go 中会自然融入并发...</div></div></div></a><a class="pagination-related" href="/2023/2023-06-01_MySQL%20%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/" title="MySQL EXPLAIN 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="info-item-2">MySQL EXPLAIN 详解</div></div><div class="info-2"><div class="info-item-1"> EXPLAIN 是 MySQL 提供的一个非常强大的工具，用于分析 SELECT 语句的执行计划。通过 EXPLAIN 的输出结果，我们可以了解查询是如何执行的，包括使用了哪些索引、扫描了多少行、是否进行了文件排序等信息。这是数据库性能调优不可或缺的一环，能够帮助我们发现 SQL 语句中的性能瓶颈并进行优化。  “优化前，先 EXPLAIN。没有 EXPLAIN 的优化都是盲人摸象。” - 数据库优化格言   一、什么是 EXPLAIN？EXPLAIN 命令实际上是用来获取 MySQL 执行查询语句的执行计划的。执行计划描述了 MySQL 如何处理 SQL 语句，包括：  表的连接顺序 每个表使用的索引 是否使用了临时表 是否进行了文件排序 扫描的行数预估  通过分析这些信息，我们可以判断查询是否高效，是否可以进一步优化。 二、如何使用 EXPLAIN？使用 EXPLAIN 非常简单，只需将 EXPLAIN 关键字放在任何 SELECT 语句的前面。 1234EXPLAIN SELECT * FROM users WHERE username = &#x27;Alice&#x2...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">187</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">65</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Go-%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93-sort-%E5%8C%85"><span class="toc-text">一、Go 语言标准库 sort 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-sort-Interface-%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.1 1. sort.Interface 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%AF%B9%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8F"><span class="toc-text">1.2 2. 对基本类型切片排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8F"><span class="toc-text">1.3 3. 对自定义结构体切片排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-sort-Slice-%E5%92%8C-sort-SliceStable-Go-1-8"><span class="toc-text">1.4 4. sort.Slice 和 sort.SliceStable (Go 1.8+)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-5-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.5 5. 排序算法的选择 (底层实现)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%90%84%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8E-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">二、各种常见排序算法详解与 Go 语言实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="toc-text">2.1 1. 冒泡排序 (Bubble Sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Selection-Sort"><span class="toc-text">2.2 2. 选择排序 (Selection Sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insertion-Sort"><span class="toc-text">2.3 3. 插入排序 (Insertion Sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="toc-text">2.4 4. 快速排序 (Quick Sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="toc-text">2.5 5. 归并排序 (Merge Sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-6-%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="toc-text">2.6 6. 堆排序 (Heap Sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-7-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-Counting-Sort"><span class="toc-text">2.7 7. 计数排序 (Counting Sort)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-8-%E6%A1%B6%E6%8E%92%E5%BA%8F-Bucket-Sort"><span class="toc-text">2.8 8. 桶排序 (Bucket Sort)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-text">三、总结与排序算法选择建议</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-11-07_Codex%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9AOpenAI%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codex 详解与使用技巧：OpenAI 的代码智能模型"/></a><div class="content"><a class="title" href="/2025/2025-11-07_Codex%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9AOpenAI%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型">Codex 详解与使用技巧：OpenAI 的代码智能模型</a><time datetime="2025-11-06T22:24:00.000Z" title="发表于 2025-11-07 06:24:00">2025-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-11-05_Claude%20Code%20%E8%AF%A6%E8%A7%A3%EF%BC%9AAnthropic%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Claude Code 详解：Anthropic 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Claude Code 详解：Anthropic 的代码智能模型"/></a><div class="content"><a class="title" href="/2025/2025-11-05_Claude%20Code%20%E8%AF%A6%E8%A7%A3%EF%BC%9AAnthropic%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Claude Code 详解：Anthropic 的代码智能模型">Claude Code 详解：Anthropic 的代码智能模型</a><time datetime="2025-11-04T22:24:00.000Z" title="发表于 2025-11-05 06:24:00">2025-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-11-01_Ubuntu%20UFW%20(Uncomplicated%20Firewall)%20%E8%AF%A6%E8%A7%A3/" title="Ubuntu UFW (Uncomplicated Firewall) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu UFW (Uncomplicated Firewall) 详解"/></a><div class="content"><a class="title" href="/2025/2025-11-01_Ubuntu%20UFW%20(Uncomplicated%20Firewall)%20%E8%AF%A6%E8%A7%A3/" title="Ubuntu UFW (Uncomplicated Firewall) 详解">Ubuntu UFW (Uncomplicated Firewall) 详解</a><time datetime="2025-10-31T22:24:00.000Z" title="发表于 2025-11-01 06:24:00">2025-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-14.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>