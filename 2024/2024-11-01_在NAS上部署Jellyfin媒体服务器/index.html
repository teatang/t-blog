<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>在NAS上部署Jellyfin媒体服务器 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Jellyfin 是一个免费、开源的媒体系统，可以帮助你管理、播放和流式传输你的电影、电视节目、音乐、照片等媒体内容。它是一个强大的替代品，适用于那些希望完全控制自己数据的用户，与 Emby 和 Plex 类似，但完全免费且无任何订阅限制。将 Jellyfin 部署在 NAS 上，可以充分利用 NAS 的存储能力、稳定性和网络共享特性，打造专属的家庭影音中心。  “拥有自己的媒体服务器，意味着你">
<meta property="og:type" content="article">
<meta property="og:title" content="在NAS上部署Jellyfin媒体服务器">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2024/2024-11-01_%E5%9C%A8NAS%E4%B8%8A%E9%83%A8%E7%BD%B2Jellyfin%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Jellyfin 是一个免费、开源的媒体系统，可以帮助你管理、播放和流式传输你的电影、电视节目、音乐、照片等媒体内容。它是一个强大的替代品，适用于那些希望完全控制自己数据的用户，与 Emby 和 Plex 类似，但完全免费且无任何订阅限制。将 Jellyfin 部署在 NAS 上，可以充分利用 NAS 的存储能力、稳定性和网络共享特性，打造专属的家庭影音中心。  “拥有自己的媒体服务器，意味着你">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg">
<meta property="article:published_time" content="2024-10-31T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-04T14:38:45.812Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="NAS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "在NAS上部署Jellyfin媒体服务器",
  "url": "https://blog.tbf1211.xx.kg/2024/2024-11-01_%E5%9C%A8NAS%E4%B8%8A%E9%83%A8%E7%BD%B2Jellyfin%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg",
  "datePublished": "2024-10-31T22:24:00.000Z",
  "dateModified": "2025-11-04T14:38:45.812Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2024/2024-11-01_%E5%9C%A8NAS%E4%B8%8A%E9%83%A8%E7%BD%B2Jellyfin%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '在NAS上部署Jellyfin媒体服务器',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">217</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">173</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">62</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-13.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">在NAS上部署Jellyfin媒体服务器</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">在NAS上部署Jellyfin媒体服务器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-10-31T22:24:00.000Z" title="发表于 2024-11-01 06:24:00">2024-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NAS/">NAS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NAS/%E5%BD%B1%E9%9F%B3%E5%A8%B1%E4%B9%90/">影音娱乐</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2024/2024-11-01_%E5%9C%A8NAS%E4%B8%8A%E9%83%A8%E7%BD%B2Jellyfin%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>Jellyfin 是一个免费、开源的媒体系统，可以帮助你管理、播放和流式传输你的电影、电视节目、音乐、照片等媒体内容。它是一个强大的替代品，适用于那些希望完全控制自己数据的用户，与 Emby 和 Plex 类似，但完全免费且无任何订阅限制。将 Jellyfin 部署在 NAS 上，可以充分利用 NAS 的存储能力、稳定性和网络共享特性，打造专属的家庭影音中心。</p>
</blockquote>
<div class="note info flat"><p>“拥有自己的媒体服务器，意味着你的影音世界，你做主。”</p>
</div>
<hr>
<h2 id="一、为什么选择-Jellyfin-和-NAS？"><a href="#一、为什么选择-Jellyfin-和-NAS？" class="headerlink" title="一、为什么选择 Jellyfin 和 NAS？"></a>一、为什么选择 Jellyfin 和 NAS？</h2><h3 id="为什么是-Jellyfin？"><a href="#为什么是-Jellyfin？" class="headerlink" title="为什么是 Jellyfin？"></a>为什么是 Jellyfin？</h3><ul>
<li><strong>完全免费且开源</strong>：无需任何订阅费用，社区活跃，持续更新。</li>
<li><strong>私有化部署</strong>：所有数据（元数据、观看记录）都存储在你的服务器上，完全掌控。</li>
<li><strong>跨平台客户端</strong>：支持 Web 浏览器、Android、iOS、Apple TV、Roku、Fire TV、Kodi 插件等多种设备。</li>
<li><strong>硬件加速</strong>：支持多种硬件解码&#x2F;编码，提供流畅的转码体验（如果你的 NAS 支持）。</li>
<li><strong>强大的媒体管理</strong>：自动抓取电影、电视节目的元数据、海报、预告片，整理媒体库。</li>
</ul>
<h3 id="为什么部署在-NAS-上？"><a href="#为什么部署在-NAS-上？" class="headerlink" title="为什么部署在 NAS 上？"></a>为什么部署在 NAS 上？</h3><ul>
<li><strong>集中存储</strong>：NAS 天然就是存储海量媒体文件的最佳场所。</li>
<li><strong>24&#x2F;7 运行</strong>：NAS 通常设计为低功耗、长时间运行，非常适合作为媒体服务器。</li>
<li><strong>网络共享</strong>：方便家庭内网甚至外网访问。</li>
<li><strong>数据安全</strong>：NAS 通常支持 RAID，提供一定的数据冗余和保护。</li>
<li><strong>Docker 支持</strong>：主流 NAS 都支持 Docker，使得 Jellyfin 的部署和管理变得轻而易举。</li>
</ul>
<h2 id="二、部署前的准备"><a href="#二、部署前的准备" class="headerlink" title="二、部署前的准备"></a>二、部署前的准备</h2><p>本教程主要以 <strong>Docker 部署</strong>为例，因为这是最通用、最灵活、最推荐的方式。</p>
<h3 id="1-NAS-要求"><a href="#1-NAS-要求" class="headerlink" title="1. NAS 要求"></a>1. NAS 要求</h3><ul>
<li><strong>支持 Docker</strong>：确保你的 NAS 型号和操作系统版本支持 Docker。群晖 (Synology) 和威联通 (QNology) 的大部分型号都支持。</li>
<li><strong>足够的存储空间</strong>：存储你的媒体文件。</li>
<li><strong>足够的内存</strong>：建议 4GB 及以上，如果需要进行转码，内存和 CPU 都更重要。</li>
<li><strong>CPU 性能（可选，但推荐）</strong>：如果需要进行实时转码，CPU 性能（尤其是集成核显 Quick Sync 或支持其他转码技术的 CPU）至关重要。</li>
</ul>
<h3 id="2-软件准备"><a href="#2-软件准备" class="headerlink" title="2. 软件准备"></a>2. 软件准备</h3><ul>
<li><strong>Docker</strong>：确保你的 NAS 上已安装 Docker。</li>
<li><strong>SSH 客户端</strong>：如 PuTTY (Windows) 或终端 (macOS&#x2F;Linux)，用于连接 NAS 进行命令行操作。</li>
<li><strong>文件管理器</strong>：用于在 NAS 上创建媒体文件夹。</li>
</ul>
<h3 id="3-理解-Docker-部署的好处"><a href="#3-理解-Docker-部署的好处" class="headerlink" title="3. 理解 Docker 部署的好处"></a>3. 理解 Docker 部署的好处</h3><ul>
<li><strong>环境隔离</strong>：Jellyfin 运行在独立的容器中，不会污染 NAS 系统环境。</li>
<li><strong>易于部署和管理</strong>：使用 Docker Compose 可以一行命令启动整个服务。</li>
<li><strong>版本控制</strong>：方便升级和回滚 Jellyfin 版本。</li>
<li><strong>可移植性</strong>：配置一旦完成，可以轻松迁移到其他支持 Docker 的平台。</li>
</ul>
<h2 id="三、部署步骤（以-Docker-Compose-为例）"><a href="#三、部署步骤（以-Docker-Compose-为例）" class="headerlink" title="三、部署步骤（以 Docker Compose 为例）"></a>三、部署步骤（以 Docker Compose 为例）</h2><h3 id="1-登录-NAS，启用-SSH"><a href="#1-登录-NAS，启用-SSH" class="headerlink" title="1. 登录 NAS，启用 SSH"></a>1. 登录 NAS，启用 SSH</h3><p>大多数 NAS 厂商会提供一个控制面板。请查找并启用 SSH 功能。</p>
<ul>
<li><strong>群晖 (Synology)</strong>: <code>控制面板</code> -&gt; <code>终端机和 SNMP</code> -&gt; <code>启用 SSH 功能</code></li>
<li><strong>威联通 (QNOLOGY)</strong>: <code>控制台</code> -&gt; <code>网络和文件服务</code> -&gt; <code>Telnet/SSH</code> -&gt; <code>允许 SSH 连接</code></li>
</ul>
<p>记下 NAS 的 IP 地址和 SSH 端口（通常是 22）。</p>
<h3 id="2-创建目录结构"><a href="#2-创建目录结构" class="headerlink" title="2. 创建目录结构"></a>2. 创建目录结构</h3><p>通过 NAS 的文件管理器或 SSH 命令，创建用于 Jellyfin 存储配置和媒体文件的目录。</p>
<p><strong>推荐目录结构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/volume1/docker/jellyfin/       # Jellyfin 配置目录</span><br><span class="line">/volume1/data/media/            # 媒体文件总目录</span><br><span class="line">/volume1/data/media/movies/     # 电影</span><br><span class="line">/volume1/data/media/tvshows/    # 电视节目</span><br><span class="line">/volume1/data/media/music/      # 音乐</span><br><span class="line">/volume1/data/media/photos/     # 照片</span><br></pre></td></tr></table></figure>

<p><strong>SSH 命令示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录 NAS</span></span><br><span class="line">ssh your_nas_username@your_nas_ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Docker 配置目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /volume1/docker/jellyfin/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /volume1/docker/jellyfin/cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建媒体文件目录</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /volume1/data/media/movies</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /volume1/data/media/tvshows</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /volume1/data/media/music</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /volume1/data/media/photos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授予 Jellyfin 访问这些媒体目录的权限（重要！）</span></span><br><span class="line"><span class="comment"># Jellyfin 容器通常以 UID 1000, GID 100 运行。</span></span><br><span class="line"><span class="comment"># 确保 jellyfin 用户或用户组有读写这些目录的权限。</span></span><br><span class="line"><span class="comment"># 最简单粗暴的方式是给 777 权限，但生产环境不推荐。</span></span><br><span class="line"><span class="comment"># 更好的方式是改变这些目录的所有者或组，使其匹配 Jellyfin 容器内的用户/组。</span></span><br><span class="line"><span class="comment"># 例如，如果你的 NAS 上有一个 &#x27;docker&#x27; 用户组，可以将媒体目录的组改为 &#x27;docker&#x27;</span></span><br><span class="line"><span class="comment"># 并且确保 jellyfin 容器内的 UID/GID 有权限，或者容器启动时指定 UID/GID。</span></span><br><span class="line"><span class="comment"># 这里我们先用最简单的方式测试，后续可以优化权限。</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 777 /volume1/data/media</span><br></pre></td></tr></table></figure>

<h3 id="3-创建-Docker-Compose-文件"><a href="#3-创建-Docker-Compose-文件" class="headerlink" title="3. 创建 Docker Compose 文件"></a>3. 创建 Docker Compose 文件</h3><p>在 <code>/volume1/docker/jellyfin/</code> 目录下创建一个名为 <code>docker-compose.yml</code> 的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /volume1/docker/jellyfin/</span><br><span class="line"><span class="built_in">sudo</span> nano docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>将以下内容粘贴到 <code>docker-compose.yml</code> 文件中：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jellyfin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nyanmisaka/jellyfin:latest</span> <span class="comment"># 官方镜像为：jellyfin/jellyfin:latest 国内建议使用：nyanmisaka/jellyfin:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jellyfin</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span>              <span class="comment"># 如果使用 host 网络模式，方便端口映射和硬件加速，无需手动映射端口</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8096</span><span class="string">:8096</span>  <span class="comment"># Web UI 端口</span></span><br><span class="line">      <span class="comment"># - 8920:8920  # HTTPS 端口 (可选)</span></span><br><span class="line">      <span class="comment"># - 1900:1900/udp # DLNA 发现端口</span></span><br><span class="line">      <span class="comment"># - 7359:7359/udp # Android TV 发现端口</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 根据自己的NAS目录调整</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/volume1/docker/jellyfin/config:/config</span> <span class="comment"># 配置文件目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/volume1/docker/jellyfin/cache:/cache</span>   <span class="comment"># 缓存文件目录</span></span><br><span class="line">      <span class="comment"># 映射你的媒体文件路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/volume1/data/media/movies:/media/movies:ro</span>   <span class="comment"># 只读挂载电影</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/volume1/data/media/tvshows:/media/tvshows:ro</span> <span class="comment"># 只读挂载电视剧</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/volume1/data/media/music:/media/music:ro</span>     <span class="comment"># 只读挂载音乐</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/volume1/data/media/photos:/media/photos:ro</span>   <span class="comment"># 只读挂载照片</span></span><br><span class="line">      <span class="comment"># 如有需要，可以添加更多媒体文件夹</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># **硬件加速配置 (根据你的 NAS 硬件选择)**</span></span><br><span class="line">      <span class="comment"># 1. Intel 核显 Quick Sync (群晖大部分 Intel CPU NAS 适用)</span></span><br><span class="line">      <span class="comment">#    确保你的NAS系统已安装i915驱动</span></span><br><span class="line">      <span class="comment">#    - /dev/dri:/dev/dri</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 2. NVIDIA GPU (如果有支持的独立显卡)</span></span><br><span class="line">      <span class="comment">#    确保已安装NVIDIA Docker runtime</span></span><br><span class="line">      <span class="comment">#    runtime: nvidia</span></span><br><span class="line">      <span class="comment">#    environment:</span></span><br><span class="line">      <span class="comment">#      - NVIDIA_VISIBLE_DEVICES=all</span></span><br><span class="line">      <span class="comment">#      - NVIDIA_DRIVER_CAPABILITIES=all</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># - PUID=1000 # 容器内用户ID，通常是 default user，可能需要根据自己NAS的用户ID调整</span></span><br><span class="line">      <span class="comment"># - PGID=100 # 容器内用户组ID，通常是 users group，可能需要根据自己NAS的用户组ID调整</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span> <span class="comment"># 设置时区</span></span><br><span class="line">      <span class="comment"># - JELLYFIN_FFMPEG=/usr/lib/jellyfin-ffmpeg/ffmpeg # 指定FFmpeg路径（高级用户，通常不需要）</span></span><br><span class="line">  </span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span> <span class="comment"># 容器崩溃或NAS重启后自动重启</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 推荐设定资源限制，防止 Jellyfin 占用过多资源</span></span><br><span class="line">    <span class="comment"># deploy:</span></span><br><span class="line">    <span class="comment">#   resources:</span></span><br><span class="line">    <span class="comment">#     limits:</span></span><br><span class="line">    <span class="comment">#       cpus: &#x27;2.0&#x27; # 限制为2个CPU核心</span></span><br><span class="line">    <span class="comment">#       memory: 4G  # 限制为4GB内存</span></span><br></pre></td></tr></table></figure>

<p><strong>关于 <code>PUID</code> 和 <code>PGID</code>：</strong><br>这两个环境变量是为了让 Jellyfin 容器里的进程拥有正确的用户ID和用户组ID，从而能够访问 NAS 文件系统上的媒体文件。</p>
<ul>
<li>你可以通过 SSH 登录 NAS 后，运行 <code>id your_nas_username</code> 命令来查看你当前用户的 <code>uid</code> (<code>PUID</code>) 和 <code>gid</code> (<code>PGID</code>)。</li>
<li>通常，<code>uid=1000</code> (<code>admin</code> 或第一个创建的用户) 和 <code>gid=100</code> (<code>users</code> 组) 是比较常见的默认值。</li>
<li>如果 Jellyfin 无法访问媒体文件，这通常是权限问题，检查 <code>PUID</code> 和 <code>PGID</code> 是第一步。</li>
</ul>
<p><strong>关于硬件加速：</strong></p>
<ul>
<li><strong>Intel 核显 (<code>/dev/dri</code>)</strong>: 对于群晖等大部分内置 Intel CPU 带核显的 NAS，挂载 <code>/dev/dri</code> 即可利用 Quick Sync 进行转码。你需要确保 NAS 系统已正确安装驱动。</li>
<li><strong>NVIDIA GPU</strong>: 如果你的 NAS 有独立 NVIDIA 显卡（较少见），你需要安装 NVIDIA Docker Runtime，并配置 <code>runtime</code> 和 <code>environment</code>。</li>
<li><strong>其他</strong>：检查 Jellyfin 官方文档和你的 NAS 硬件手册，了解具体支持的硬件加速方式。如果不需要转码或者 NAS 性能足够，可以不配置。</li>
</ul>
<p>按 <code>Ctrl + X</code>，然后按 <code>Y</code> 确认保存，再按 <code>Enter</code> 退出 <code>nano</code> 编辑器。</p>
<h3 id="4-启动-Jellyfin-容器"><a href="#4-启动-Jellyfin-容器" class="headerlink" title="4. 启动 Jellyfin 容器"></a>4. 启动 Jellyfin 容器</h3><p>在 <code>docker-compose.yml</code> 文件所在的目录下，执行以下命令来启动 Jellyfin：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker compose up -d</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker compose up</code>：根据 <code>docker-compose.yml</code> 文件创建并启动服务。（旧版本 Docker 可能需要用 <code>docker-compose</code> 命令）</li>
<li><code>-d</code>：表示在后台运行容器。</li>
</ul>
<p>如果一切顺利，Jellyfin 容器应该已经启动并运行。</p>
<h3 id="5-检查容器状态"><a href="#5-检查容器状态" class="headerlink" title="5. 检查容器状态"></a>5. 检查容器状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker ps -a | grep jellyfin</span><br></pre></td></tr></table></figure>

<p>你应该看到 <code>jellyfin</code> 容器的状态是 <code>Up ...</code>。</p>
<h3 id="6-访问-Jellyfin-Web-UI-进行初始化"><a href="#6-访问-Jellyfin-Web-UI-进行初始化" class="headerlink" title="6. 访问 Jellyfin Web UI 进行初始化"></a>6. 访问 Jellyfin Web UI 进行初始化</h3><p>打开你的浏览器，访问 <code>http://你的NAS_IP:8096</code>。</p>
<p>你将看到 Jellyfin 的安装向导：</p>
<ol>
<li><strong>Welcome</strong>: 选择语言。</li>
<li><strong>Create your first user</strong>: 创建管理员账户。这是 Jellyfin 内部的账户，与 NAS 账户无关。</li>
<li><strong>Add Media Library</strong>: 添加你的媒体库。<ul>
<li>点击 <code>+ 添加媒体库</code>。</li>
<li>选择 <code>内容类型</code> (例如：电影、电视节目、音乐)。</li>
<li>为媒体库起一个名称 (例如：我的电影)。</li>
<li>选择 <code>文件夹</code>，然后点击 <code>+</code>。你会看到你在 <code>docker-compose.yml</code> 中映射的 <code>/media/movies</code>、<code>/media/tvshows</code> 等目录。选择对应的目录。</li>
<li>其他选项可以根据需要自行配置（如 <code>下载元数据</code>、<code>抓取图片</code> 等），通常默认即可。</li>
<li>重复此步骤添加所有媒体库。</li>
</ul>
</li>
<li><strong>Preferred Metadata Language</strong>: 选择媒体元数据语言。</li>
<li><strong>Configure Remote Access</strong>: 如果你想从外网访问，这里可以选择允许远程访问。<strong>请确保你了解网络安全风险，并配置好路由器端口转发和防火墙。</strong></li>
<li><strong>Done!</strong>: 完成设置。</li>
</ol>
<p>现在，Jellyfin 会开始扫描你的媒体文件，自动匹配元数据、海报等。你可以在 <code>仪表盘</code> -&gt; <code>任务</code> 中查看扫描进度。</p>
<h2 id="四、高级配置与优化"><a href="#四、高级配置与优化" class="headerlink" title="四、高级配置与优化"></a>四、高级配置与优化</h2><h3 id="1-硬件解码-编码（Hardware-Transcoding）"><a href="#1-硬件解码-编码（Hardware-Transcoding）" class="headerlink" title="1. 硬件解码&#x2F;编码（Hardware Transcoding）"></a>1. 硬件解码&#x2F;编码（Hardware Transcoding）</h3><p>这是提升观看体验的关键，特别是当你需要在低带宽或不支持 Jellyfin 直播的设备上观看高码率视频时。</p>
<ul>
<li><strong>确认 NAS 支持</strong>：检查你的 NAS CPU 是否支持 Intel Quick Sync Video (QSV)、AMD VCE&#x2F;VCN 或 NVIDIA NVENC&#x2F;NVDEC。</li>
<li><strong>Docker 配置</strong>：在 <code>docker-compose.yml</code> 中正确挂载硬件设备（参考前面 <code>volumes</code> 部分的 <code>/dev/dri</code> 或 NVIDIA 配置）。</li>
<li><strong>Jellyfin 设置</strong>：<ol>
<li>登录 Jellyfin Web UI。</li>
<li>点击右上角 <code>管理员仪表盘</code> (齿轮图标)。</li>
<li>选择 <code>播放</code> -&gt; <code>转码</code>。</li>
<li>启用 <code>启用硬件加速</code>。</li>
<li>选择正确的 <code>硬件加速设备</code> (例如：<code>VAAPI</code> for Intel QSV, <code>NVENC</code> for NVIDIA)。</li>
<li>保存设置，并尝试播放一个高码率视频，在 <code>仪表盘</code> 的 <code>活动</code> 中，你会看到转码信息，确认是否使用了硬件加速。</li>
</ol>
</li>
</ul>
<h3 id="2-端口转发与外网访问"><a href="#2-端口转发与外网访问" class="headerlink" title="2. 端口转发与外网访问"></a>2. 端口转发与外网访问</h3><p>如果你想从家庭网络外部访问 Jellyfin，你需要：</p>
<ol>
<li><strong>NAS 上固定 IP</strong>：为你的 NAS 设置一个静态 IP 地址。</li>
<li><strong>路由器端口转发 (Port Forwarding)</strong>：在你的路由器设置中，将外部端口（例如 8096 或自定义的）转发到 NAS 的内部 IP 地址和 Jellyfin 的 8096 端口。</li>
<li><strong>域名和 SSL (可选，但非常推荐)</strong>：<ul>
<li>注册一个域名。</li>
<li>使用 DDNS (动态 DNS) 服务，将你的域名解析到你家庭网络的公网 IP。</li>
<li>通过 Nginx Proxy Manager 或 Caddy 等工具设置反向代理，并配置 SSL 证书（如 Let’s Encrypt），实现 HTTPS 安全访问。</li>
<li>这会增加复杂度，但能大大提高安全性。</li>
</ul>
</li>
</ol>
<h3 id="3-用户管理"><a href="#3-用户管理" class="headerlink" title="3. 用户管理"></a>3. 用户管理</h3><p>在 <code>管理员仪表盘</code> -&gt; <code>用户</code> 中，你可以创建新的用户，为他们分配查看不同媒体库的权限，以及设置是否允许转码等。</p>
<h3 id="4-优化媒体文件命名"><a href="#4-优化媒体文件命名" class="headerlink" title="4. 优化媒体文件命名"></a>4. 优化媒体文件命名</h3><p>Jellyfin 的元数据抓取严重依赖媒体文件的命名规范。遵循 Jellyfin 官方推荐的命名规范可以大大提高元数据匹配的准确性。</p>
<ul>
<li><strong>电影</strong>：<code>电影名称 (年份)/电影名称 (年份).ext</code> (例如: <code>Inception (2010)/Inception (2010).mkv</code>)</li>
<li><strong>电视节目</strong>：<code>节目名称/Season XX/节目名称 - SXXEXX - 剧集标题.ext</code> (例如: <code>Game of Thrones/Season 01/Game of Thrones - S01E01 - Winter Is Coming.mkv</code>)</li>
</ul>
<h3 id="5-容器升级"><a href="#5-容器升级" class="headerlink" title="5. 容器升级"></a>5. 容器升级</h3><p>当 Jellyfin 有新版本发布时，升级非常简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /volume1/docker/jellyfin/ <span class="comment"># 进入 docker-compose.yml 所在目录</span></span><br><span class="line"><span class="built_in">sudo</span> docker compose pull     <span class="comment"># 拉取最新镜像</span></span><br><span class="line"><span class="built_in">sudo</span> docker compose up -d    <span class="comment"># 用新镜像重建并启动容器</span></span><br></pre></td></tr></table></figure>

<h2 id="五、常见问题排查"><a href="#五、常见问题排查" class="headerlink" title="五、常见问题排查"></a>五、常见问题排查</h2><ul>
<li><strong>Jellyfin 无法启动或连接</strong>：<ul>
<li>检查 Docker 容器是否正在运行 (<code>sudo docker ps -a | grep jellyfin</code>)。</li>
<li>检查端口 8096 是否被占用 (<code>sudo netstat -tuln | grep 8096</code>)。</li>
<li>检查 <code>docker-compose.yml</code> 文件是否有语法错误。</li>
</ul>
</li>
<li><strong>Jellyfin 无法访问媒体文件</strong>：<ul>
<li><strong>最常见的问题是权限不足。</strong> 检查 <code>PUID</code> 和 <code>PGID</code> 是否正确对应 NAS 上的用户&#x2F;组 ID。</li>
<li>检查 NAS 媒体文件夹的权限，确保 <code>jellyfin</code> 容器的用户有读（和部分写，如元数据）权限。可以尝试 <code>sudo chmod -R 777 /volume1/data/media</code> (临时测试用，不推荐长期使用)。</li>
<li>检查 <code>volumes</code> 映射路径是否正确。</li>
</ul>
</li>
<li><strong>媒体文件元数据抓取失败或不准确</strong>：<ul>
<li>检查媒体文件命名是否规范。</li>
<li>在 Jellyfin 媒体库设置中，尝试 <code>刷新元数据</code>。</li>
<li>检查网络连接，确保 Jellyfin 可以访问外网获取元数据。</li>
</ul>
</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过 Docker 在 NAS 上部署 Jellyfin 是一个强大且灵活的私有媒体中心解决方案。它让你能够完全掌控自己的媒体库，并在家庭网络中的各种设备上自由播放。虽然涉及到一些命令行操作和网络配置，但一旦设置完成，你将拥有一个稳定、高效、免费的影音娱乐平台。</p>
<p>希望本教程能够帮助你成功搭建属于自己的 Jellyfin 媒体服务器！尽情享受你的数字内容吧！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2024/2024-11-01_%E5%9C%A8NAS%E4%B8%8A%E9%83%A8%E7%BD%B2Jellyfin%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/">https://blog.tbf1211.xx.kg/2024/2024-11-01_%E5%9C%A8NAS%E4%B8%8A%E9%83%A8%E7%BD%B2Jellyfin%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/NAS/">NAS</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/2024-11-05_Web3%E8%A7%84%E6%A8%A1%E5%8C%96%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%8B%E4%B8%80%E4%BB%A3%E4%BA%92%E8%81%94%E7%BD%91%E6%84%BF%E6%99%AF%E7%9A%84%E6%8C%91%E6%88%98%E4%B8%8E%E8%B7%AF%E5%BE%84/" title="Web3规模化详解：实现下一代互联网愿景的挑战与路径"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Web3规模化详解：实现下一代互联网愿景的挑战与路径</div></div><div class="info-2"><div class="info-item-1"> Web3，作为下一代互联网的愿景，承载着去中心化、用户所有权和开放性等核心理念。它旨在打破少数中心化巨头对数据和权力垄断的格局，将互联网的控制权重新交还给用户。然而，要实现 Web3 的大规模普及和应用，仅仅有理想是远远不够的，其底层技术（主要是区块链）目前在规模化 (Scalability) 方面仍面临严峻挑战。  Web3 规模化，指的是区块链网络和去中心化应用 (dApps) 在保持去中心化和安全性的前提下，处理海量用户和交易的能力。它是 Web3 从小众技术走向主流应用，从概念走向实际落地的必经之路。    目录 引言：Web3 愿景与规模化困境 1.1 Web3 的核心理念 1.2 现有 Web3 基础设施的局限性   Web3 规模化的核心挑战 2.1 区块链的“不可能三角” 2.2 高昂的交易成本 (Gas Fee) 2.3 低下的交易吞吐量 (TPS) 2.4 糟糕的用户体验 (UX) 2.5 数据存储与可用性问题   Web3 规模化的主要技术路径 3.1 Layer1 (主链) 优化 3.1.1 共识机制改进 (PoS、DPoS) 3.1.2 分片技术 (S...</div></div></div></a><a class="pagination-related" href="/2024/2024-10-23_DNAT%20(Destination%20Network%20Address%20Translation)%20%E8%AF%A6%E8%A7%A3/" title="DNAT (Destination Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DNAT (Destination Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> DNAT (Destination Network Address Translation)，即目的网络地址转换，是 NAT (Network Address Translation) 技术的一种重要形式。它主要用于修改 IP 数据包的目的 IP 地址和&#x2F;或目的端口号。在外部网络（如互联网）访问内部私有网络服务器的场景中，DNAT 扮演着核心角色，通常被称为端口转发 (Port Forwarding) 或入站 NAT (Inbound NAT)。通过 DNAT，外部请求可以被透明地重定向到内部的特定服务器，从而允许私有网络内的服务向外部公开，同时又保持内部网络的私密性。  核心思想：将外部请求的目标 IP&#x2F;端口映射到内部私有网络的 IP&#x2F;端口。 实现外部访问内部服务，是服务器对外发布服务的关键技术之一。   一、为什么需要 DNAT？在现代网络架构中，尤其是私有 IP 地址（如 192.168.x.x, 10.x.x.x, 172.16.x.x-172.31.x.x）的广泛使用， DNAT 解决了以下关键问题：  发布内部服务：私有 IP 地址无法...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-10-21_Dockge%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3%20Docker%20Compose%20UI/" title="Dockge介绍与部署：下一代 Docker Compose UI"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-21</div><div class="info-item-2">Dockge介绍与部署：下一代 Docker Compose UI</div></div><div class="info-2"><div class="info-item-1"> 如果你经常使用 Docker Compose 来管理容器应用，并且厌倦了命令行界面，或者觉得 Portainer 过于庞大复杂，那么 Dockge 可能会成为你的新宠。Dockge 是一个轻量级、直观且专注于 Docker Compose 的 Web UI 工具，它旨在简化 Docker Compose 项目的创建、编辑、部署和管理，让你能够更高效地维护你的容器化服务。  “好的工具让复杂的事情变得简单，Dockge 就是让 Docker Compose 更友好的工具。”   一、Dockge 是什么？Dockge 是一个开源的 Docker Compose 管理工具，它提供了一个简洁的 Web 界面，让你可以：  可视化管理 Docker Compose 项目：轻松查看所有 Docker Compose 堆栈（Stack）的状态。 在线编辑 docker-compose.yml 文件：直接在浏览器中编辑并保存更改，无需 SSH 到服务器。 一键部署和管理堆栈：启动、停止、重启、删除整个 Docker Compose 堆栈。 查看容器日志：实时查看容器的输出日志。 管理容器卷：...</div></div></div></a><a class="pagination-related" href="/2024/2024-12-10_Home%20Assistant%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%9A%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%B8%AD%E6%9E%A2/" title="Home Assistant介绍与部署：打造你的智能家居中枢"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">Home Assistant介绍与部署：打造你的智能家居中枢</div></div><div class="info-2"><div class="info-item-1"> Home Assistant (HA) 是一个免费开源的智能家居自动化平台，它致力于将你家中所有不同品牌的智能设备连接起来，并提供统一的控制界面，实现设备间的联动自动化。与依赖云端的智能家居平台不同，Home Assistant 强调本地化控制和隐私保护。它是智能家居爱好者的终极控制中心，让你真正掌控自己的智能生活。  “拥有 Home Assistant，意味着拥有一个由你完全掌控的智能家居大脑。”   一、Home Assistant 是什么？Home Assistant 是一个用 Python 编写的开源项目，它能让你本地运行智能家居控制中心。它支持超过 2000 个集成（integrations），可以与市面上绝大多数智能设备和服务进行连接，包括但不限于：  各种协议设备：Wi-Fi、Zigbee、Z-Wave、蓝牙、MQTT 等。 主流品牌设备：飞利浦 Hue、小米、宜家、Sonos、谷歌 Home、亚马逊 Alexa、各种智能插座、传感器等。 服务集成：天气预报、日历、邮件、通知服务、网络设备（路由器、NAS）监控等。  核心优势：  本地控制，注重隐私：大部分功能...</div></div></div></a><a class="pagination-related" href="/2024/2024-12-15_Frigate%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%83%A8%E7%BD%B2%EF%BC%9A%E5%9F%BA%E4%BA%8EAI%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/" title="Frigate介绍与部署：基于AI的本地视频监控系统"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-15</div><div class="info-item-2">Frigate介绍与部署：基于AI的本地视频监控系统</div></div><div class="info-2"><div class="info-item-1"> Frigate 是一个开源的、高性能的本地视频监控系统，它利用 AI （特别是通过 Google Coral TPU 进行边缘计算）来实现实时目标检测，例如检测人、车辆、宠物等。与传统监控系统只是录像不同，Frigate 能够智能识别画面中的物体，并只在检测到感兴趣的事件时进行录像或发送通知，大大减少了存储空间和误报，同时提高了事件分析的效率。  “让你的摄像头变得更智能，只记录你真正关心的事件。”   一、Frigate 是什么？Frigate 是一个基于 FFmpeg 和 TensorFlow 的 AI 目标检测视频监控系统。它的核心思想是利用神经网络在本地对视频流进行实时分析，识别预定义的目标（如人、车），然后根据这些识别结果进行录制、快照捕捉或触发自动化。 核心优势：  本地处理：所有视频流和 AI 推理都在本地完成，保障隐私，不依赖云服务。 实时目标检测：利用 Google Coral TPU 等硬件加速，实现毫秒级的实时检测。 智能录像与快照：只在检测到目标时录制完整的视频片段，并捕捉关键帧快照。 集成度高：与 Home Assistant 深度集成，可以作为强大的...</div></div></div></a><a class="pagination-related" href="/2024/2024-12-02_WebDAV%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE/" title="WebDAV详解：基于HTTP的分布式文件管理协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-02</div><div class="info-item-2">WebDAV详解：基于HTTP的分布式文件管理协议</div></div><div class="info-2"><div class="info-item-1"> WebDAV (Web Distributed Authoring and Versioning) 是一种基于 HTTP 协议的扩展协议，它允许客户端直接通过 Web 远程地执行文件和文件夹的操作，包括创建、移动、复制、删除、读取以及管理文件属性和锁机制。简而言之，WebDAV 将 Web 服务器从一个简单的内容消费者转变为一个可供用户直接进行创作和协同工作的平台，将 Web 页面视为可编辑的文档集合。  核心思想：WebDAV 在不改变 HTTP 核心语义的前提下，增加了 HTTP 缺乏的文件锁定、属性管理、命名空间管理等功能，使其能够支持分布式文件系统的基本操作。它将传统的“请求-响应”模式扩展为“文档创作-协作”模式。   一、为什么需要 WebDAV？HTTP 的局限性HTTP (Hypertext Transfer Protocol) 在设计之初，主要是为了实现信息的单向传输，即客户端请求资源，服务器提供资源。它的主要方法 (GET, POST, PUT, DELETE, HEAD, OPTIONS) 专注于获取、提交和替换&#x2F;删除单个资源。 然而，对于 We...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-01_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%9A%E6%89%93%E9%80%A0%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/" title="Docker镜像构建与管理：打造标准化、可复用的容器镜像"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="info-item-2">Docker镜像构建与管理：打造标准化、可复用的容器镜像</div></div><div class="info-2"><div class="info-item-1"> 原文地址 mp.weixin.qq.com  Docker 镜像构建与管理：打造标准化、可复用的容器镜像开篇：你是否也在镜像管理上栽过跟头？凌晨 2 点，生产环境突然告警，新部署的容器启动失败。排查后发现：开发环境用的镜像 800MB，生产环境的却有 3.2GB，里面塞满了编译工具、测试数据，甚至还有开发同学的 SSH 私钥… 这种 “镜像肥胖症” 你遇到过吗？或者更糟糕的：  同一个服务，测试环境能跑，生产环境启动就报错 镜像仓库里堆满了 latest、v1、v1-final、v1-final-final 这种让人崩溃的标签 构建一次镜像要等 20 分钟，因为每次都要重新下载依赖包  今天这篇文章，我会基于 5 年运维实战经验，教你构建一套标准化的镜像管理体系：从多阶段构建优化到镜像安全扫描，从版本管理策略到自动化构建流程，让你的镜像体积缩小 70%、构建速度提升 5 倍，并且永远不会再出现 “这个镜像到底能不能用” 的灵魂拷问。 一、镜像构建的三大核心原则（90% 的人都忽略了）1. 最小化原则：镜像里只放 “必需品”很多人写 Dockerfile 就像搬家，什么都往里塞。...</div></div></div></a><a class="pagination-related" href="/2023/2023-02-05_Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8EDockerfile%E5%88%B0%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5/" title="Docker镜像构建详解：从Dockerfile到高效实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-05</div><div class="info-item-2">Docker镜像构建详解：从Dockerfile到高效实践</div></div><div class="info-2"><div class="info-item-1"> Docker 镜像是 Docker 的核心组成部分之一。它是一个轻量级、独立、可执行的软件包，包含运行应用程序所需的一切：代码、运行时、系统工具、系统库和设置。构建 Docker 镜像是实现应用程序容器化的关键步骤，通过 Dockerfile 文件，我们可以定义镜像的构建过程。  “Docker 镜像本质上是文件系统和配置的组合，它通过层（Layer）的概念实现了高效的存储和复用。理解 Dockerfile 的每一条指令以及如何优化构建过程，是成为 Docker 高手的必经之路。”   一、Docker 镜像构建概述 Dockerfile：一个文本文件，包含一系列指令，用于自动化地在 Docker 环境中构建镜像。 构建上下文 (Build Context)：在执行 docker build 命令时，你指定了一个路径（通常是当前目录）。这个路径下的所有文件和目录都会被发送到 Docker daemon，作为构建上下文。只有在构建上下文中包含的文件才能被 Dockerfile 中的指令（如 ADD, COPY）访问。 镜像层 (Image Layer)：Docker 镜像由一系列...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">217</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">173</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">62</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-Jellyfin-%E5%92%8C-NAS%EF%BC%9F"><span class="toc-text">一、为什么选择 Jellyfin 和 NAS？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-Jellyfin%EF%BC%9F"><span class="toc-text">为什么是 Jellyfin？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%A8%E7%BD%B2%E5%9C%A8-NAS-%E4%B8%8A%EF%BC%9F"><span class="toc-text">为什么部署在 NAS 上？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%83%A8%E7%BD%B2%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87"><span class="toc-text">二、部署前的准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-NAS-%E8%A6%81%E6%B1%82"><span class="toc-text">1. NAS 要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E5%87%86%E5%A4%87"><span class="toc-text">2. 软件准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%90%86%E8%A7%A3-Docker-%E9%83%A8%E7%BD%B2%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">3. 理解 Docker 部署的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%83%A8%E7%BD%B2%E6%AD%A5%E9%AA%A4%EF%BC%88%E4%BB%A5-Docker-Compose-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-text">三、部署步骤（以 Docker Compose 为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%99%BB%E5%BD%95-NAS%EF%BC%8C%E5%90%AF%E7%94%A8-SSH"><span class="toc-text">1. 登录 NAS，启用 SSH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">2. 创建目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA-Docker-Compose-%E6%96%87%E4%BB%B6"><span class="toc-text">3. 创建 Docker Compose 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%AF%E5%8A%A8-Jellyfin-%E5%AE%B9%E5%99%A8"><span class="toc-text">4. 启动 Jellyfin 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A3%80%E6%9F%A5%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81"><span class="toc-text">5. 检查容器状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%BF%E9%97%AE-Jellyfin-Web-UI-%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">6. 访问 Jellyfin Web UI 进行初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">四、高级配置与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%A7%A3%E7%A0%81-%E7%BC%96%E7%A0%81%EF%BC%88Hardware-Transcoding%EF%BC%89"><span class="toc-text">1. 硬件解码&#x2F;编码（Hardware Transcoding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE"><span class="toc-text">2. 端口转发与外网访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-text">3. 用户管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E5%8C%96%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D"><span class="toc-text">4. 优化媒体文件命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%B9%E5%99%A8%E5%8D%87%E7%BA%A7"><span class="toc-text">5. 容器升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-text">五、常见问题排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-13.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>