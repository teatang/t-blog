<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025) | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript，正式名称为 ECMAScript (ES)，自 1997 年标准化以来，一直在不断发展。尤其是从 ES6 (ES2015) 开始，它进入了一个快速迭代的时代，每年都会发布一个新版本，引入大量的新特性、语法糖和标准库改进。理解这些新特性对于现代 JavaScript 开发者至关重要，它能帮助我们编写更简洁、更强大、更符合未来趋势的代码。  核心思想： ECMAScript 的">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/e208a03b114e/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="JavaScript，正式名称为 ECMAScript (ES)，自 1997 年标准化以来，一直在不断发展。尤其是从 ES6 (ES2015) 开始，它进入了一个快速迭代的时代，每年都会发布一个新版本，引入大量的新特性、语法糖和标准库改进。理解这些新特性对于现代 JavaScript 开发者至关重要，它能帮助我们编写更简洁、更强大、更符合未来趋势的代码。  核心思想： ECMAScript 的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg">
<meta property="article:published_time" content="2025-04-14T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-29T10:03:28.107Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="语言版本">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)",
  "url": "https://blog.tbf1211.xx.kg/e208a03b114e/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-02.jpg",
  "datePublished": "2025-04-14T22:24:00.000Z",
  "dateModified": "2026-01-29T10:03:28.107Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/e208a03b114e/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">533</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-04-14T22:24:00.000Z" title="发表于 2025-04-15 06:24:00">2025-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/JavaScript/">JavaScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>JavaScript</strong>，正式名称为 <strong>ECMAScript (ES)</strong>，自 1997 年标准化以来，一直在不断发展。尤其是从 ES6 (ES2015) 开始，它进入了一个快速迭代的时代，每年都会发布一个新版本，引入大量的新特性、语法糖和标准库改进。理解这些新特性对于现代 JavaScript 开发者至关重要，它能帮助我们编写更简洁、更强大、更符合未来趋势的代码。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想：</strong> ECMAScript 的版本迭代致力于提升开发效率、代码可读性、执行性能，并引入现代编程范式（如异步编程、模块化），同时保持向后兼容性。</p>
</div>
<hr>
<h2 id="一、早期版本：奠定基础-ES1-ES5"><a href="#一、早期版本：奠定基础-ES1-ES5" class="headerlink" title="一、早期版本：奠定基础 (ES1 - ES5)"></a>一、早期版本：奠定基础 (ES1 - ES5)</h2><p>早期版本的 ECMAScript 奠定了 JavaScript 的基本语法和核心功能，但发展速度相对较慢。</p>
<h3 id="1-1-ES1-1997-ES3-1999"><a href="#1-1-ES1-1997-ES3-1999" class="headerlink" title="1.1 ES1 (1997) - ES3 (1999)"></a>1.1 ES1 (1997) - ES3 (1999)</h3><ul>
<li><strong>基本语法</strong>：变量声明 (<code>var</code>)、函数、条件语句、循环、基本数据类型（字符串、数字、布尔、null、undefined）。</li>
<li><strong>对象和数组</strong>：字面量创建、属性访问。</li>
<li><strong>原型继承</strong>：基于原型的继承机制。</li>
<li><strong>函数作用域</strong>：变量作用域规则。</li>
<li><strong><code>try...catch</code></strong>：错误处理。</li>
<li><strong><code>eval()</code></strong>：动态执行代码。</li>
</ul>
<h3 id="1-2-ES5-2009"><a href="#1-2-ES5-2009" class="headerlink" title="1.2 ES5 (2009)"></a>1.2 ES5 (2009)</h3><p>这是一个重要的里程碑版本，引入了许多实用特性并为未来打下基础。</p>
<ul>
<li><strong><code>&quot;use strict&quot;</code> 严格模式</strong>：通过在脚本或函数开头添加 <code>&quot;use strict&quot;</code> 启用，强制执行更严格的 JavaScript 规则，有助于编写更安全、更易调试的代码。</li>
<li><strong><code>JSON.parse()</code> 和 <code>JSON.stringify()</code></strong>：内置的 JSON 解析和序列化方法，极大方便了 Web 数据交换。</li>
<li><strong><code>Object.create()</code></strong>：创建一个新对象，使用现有对象作为其原型。</li>
<li><strong><code>Object.defineProperty()</code> 和 <code>Object.defineProperties()</code></strong>：允许精确控制对象的属性（可写、可枚举、可配置）。</li>
<li><strong><code>Object.getPrototypeOf()</code></strong>：获取对象的原型。</li>
<li><strong><code>Array.isArray()</code></strong>：判断一个值是否为数组。</li>
<li><strong>数组的迭代方法</strong>：<code>forEach()</code>, <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>some()</code>, <code>every()</code> 等。</li>
<li><strong><code>String.prototype.trim()</code></strong>：移除字符串两端的空白字符。</li>
<li><strong>函数 <code>bind()</code> 方法</strong>：创建一个新的函数，在调用时将其 <code>this</code> 关键字设置为提供的值。</li>
<li><strong>Getter 和 Setter (访问器属性)</strong>：通过对象字面量语法定义属性的访问器。</li>
</ul>
<h2 id="二、ES6-ES2015-：现代-JavaScript-的起点"><a href="#二、ES6-ES2015-：现代-JavaScript-的起点" class="headerlink" title="二、ES6 (ES2015)：现代 JavaScript 的起点"></a>二、ES6 (ES2015)：现代 JavaScript 的起点</h2><p>ES6 是 JavaScript 发展史上最重要的版本，引入了大量革命性的新特性，彻底改变了 JavaScript 的编写方式。</p>
<ul>
<li><strong><code>let</code> 和 <code>const</code> 关键字</strong>：<ul>
<li><code>let</code>：块级作用域变量声明，解决了 <code>var</code> 的变量提升和作用域混乱问题。</li>
<li><code>const</code>：块级作用域常量声明，一旦赋值不能重新分配（对于对象和数组，其内容可变）。</li>
</ul>
</li>
<li><strong>箭头函数 (Arrow Functions)</strong>：<ul>
<li>更简洁的函数语法 (<code>(param1, param2) =&gt; expression</code>)。</li>
<li>没有自己的 <code>this</code> 绑定，<code>this</code> 绑定到定义时所在的上下文。</li>
</ul>
</li>
<li><strong>模板字面量 (Template Literals)</strong>：<ul>
<li>使用反引号 <code>`</code> 定义多行字符串和内嵌表达式 (`${expression}`)。</li>
<li>const name &#x3D; “World”; console.log(`Hello, ${name}!`);</li>
</ul>
</li>
<li><strong>解构赋值 (Destructuring Assignment)</strong>：<ul>
<li>从数组或对象中提取值并赋给变量，简化了数据提取。</li>
<li><code>const [a, b] = [1, 2];</code></li>
<li><code>const &#123; name, age &#125; = person;</code></li>
</ul>
</li>
<li><strong>默认参数值 (Default Parameters)</strong>：<ul>
<li>函数参数可以有默认值。</li>
<li><code>function greet(name = &quot;Guest&quot;) &#123; ... &#125;</code></li>
</ul>
</li>
<li><strong>剩余参数 (Rest Parameters)</strong>：<ul>
<li>允许将不定数量的参数表示为数组。</li>
<li><code>function sum(...numbers) &#123; ... &#125;</code></li>
</ul>
</li>
<li><strong>扩展运算符 (Spread Operator)</strong>：<ul>
<li>将数组或可迭代对象展开为独立的元素。</li>
<li><code>const arr = [1, ...[2, 3], 4];</code> (合并数组)</li>
<li><code>const newObj = &#123; ...oldObj, newProp: &#39;value&#39; &#125;;</code> (合并对象)</li>
</ul>
</li>
<li><strong>类 (Classes)</strong>：<ul>
<li>提供了更接近传统面向对象语言的语法糖来定义构造函数和方法（本质仍是原型继承）。</li>
<li><code>class MyClass &#123; constructor() &#123;...&#125; method() &#123;...&#125; &#125;</code></li>
</ul>
</li>
<li><strong>模块 (Modules)</strong>：<ul>
<li><code>import</code> 和 <code>export</code> 关键字，实现了 JavaScript 的模块化，有助于代码组织和复用。</li>
<li><code>export default myFunc; import myFunc from &#39;./module.js&#39;;</code></li>
</ul>
</li>
<li><strong>Promise</strong>：<ul>
<li>用于处理异步操作的抽象，解决了回调地狱问题。</li>
<li><code>fetch(&#39;/api/data&#39;).then(response =&gt; response.json()).then(data =&gt; console.log(data));</code></li>
</ul>
</li>
<li><strong>生成器 (Generators)</strong>：<ul>
<li>通过 <code>function*</code> 和 <code>yield</code> 关键字创建可暂停和恢复的函数，用于处理异步操作或生成序列。</li>
</ul>
</li>
<li><strong>迭代器 (Iterators) 和 <code>for...of</code> 循环</strong>：<ul>
<li>新的循环结构，用于遍历所有可迭代对象（数组、字符串、Map、Set 等）。</li>
</ul>
</li>
<li><strong>Map 和 Set</strong>：<ul>
<li>新的数据结构：<code>Map</code> (键值对集合，键可以是任意类型)，<code>Set</code> (唯一值集合)。</li>
</ul>
</li>
<li><strong>Symbol 类型</strong>：<ul>
<li>新的原始数据类型，表示独一无二的值，常用于创建对象私有属性或元编程。</li>
</ul>
</li>
<li><strong>代理 (Proxies)</strong> 和 <strong>反射 (Reflect)</strong>：<ul>
<li><code>Proxy</code> 允许你拦截并自定义对对象的操作（如属性查找、赋值、函数调用）。</li>
<li><code>Reflect</code> 提供了一组静态方法，与 <code>Proxy</code> 拦截的方法一一对应。</li>
</ul>
</li>
<li><strong>尾调用优化 (Tail Call Optimization - TCO)</strong>：<ul>
<li>在特定条件下，优化递归函数的调用栈，防止栈溢出（支持情况因 JS 引擎而异）。</li>
</ul>
</li>
</ul>
<h2 id="三、ES2016-ES7"><a href="#三、ES2016-ES7" class="headerlink" title="三、ES2016 (ES7)"></a>三、ES2016 (ES7)</h2><p>相对较小的更新，但包含两个重要特性。</p>
<ul>
<li><strong><code>Array.prototype.includes()</code></strong>：<ul>
<li>判断数组是否包含某个元素，返回布尔值。</li>
<li><code>[1, 2, 3].includes(2); // true</code></li>
</ul>
</li>
<li><strong>指数运算符 <code>**</code></strong>：<ul>
<li><code>2 ** 3; // 8</code> (等同于 <code>Math.pow(2, 3)</code>)</li>
</ul>
</li>
</ul>
<h2 id="四、ES2017-ES8"><a href="#四、ES2017-ES8" class="headerlink" title="四、ES2017 (ES8)"></a>四、ES2017 (ES8)</h2><p>异步编程再次得到增强，引入了 <code>async/await</code>。</p>
<ul>
<li><strong><code>async</code> 和 <code>await</code></strong>：<ul>
<li>基于 Promise 的语法糖，使异步代码看起来像同步代码，极大地简化了异步流程控制。</li>
<li><code>async function fetchData() &#123; const response = await fetch(&#39;/api/data&#39;); const data = await response.json(); return data; &#125;</code></li>
</ul>
</li>
<li><strong><code>Object.values()</code> 和 <code>Object.entries()</code></strong>：<ul>
<li><code>Object.values()</code> 返回对象自身所有可枚举属性值的数组。</li>
<li><code>Object.entries()</code> 返回对象自身所有可枚举属性的键值对数组。</li>
</ul>
</li>
<li><strong><code>String.prototype.padStart()</code> 和 <code>String.prototype.padEnd()</code></strong>：<ul>
<li>用于字符串填充，使其达到指定长度。</li>
<li><code>&#39;5&#39;.padStart(2, &#39;0&#39;); // &quot;05&quot;</code></li>
</ul>
</li>
<li><strong>尾逗号 (Trailing Commas)</strong>：<ul>
<li>允许在函数参数、数组、对象字面量的最后一个元素后添加逗号，方便版本控制。</li>
</ul>
</li>
<li><strong>共享内存和 Atomics (Shared Memory and Atomics)</strong>：<ul>
<li><code>SharedArrayBuffer</code> 允许在 Web Workers 之间共享内存。</li>
<li><code>Atomics</code> 提供原子操作，用于避免共享内存时的竞态条件。</li>
</ul>
</li>
</ul>
<h2 id="五、ES2018-ES9"><a href="#五、ES2018-ES9" class="headerlink" title="五、ES2018 (ES9)"></a>五、ES2018 (ES9)</h2><ul>
<li><strong>异步迭代器和 <code>for await...of</code> 循环</strong>：<ul>
<li>允许在 <code>for await...of</code> 循环中迭代异步可迭代对象（例如，每次迭代都需要等待 Promise 完成）。</li>
</ul>
</li>
<li><strong>剩余&#x2F;扩展属性 (Rest&#x2F;Spread Properties for Objects)</strong>：<ul>
<li>允许对象解构时使用 <code>...rest</code> 收集剩余属性。</li>
<li>允许对象字面量使用 <code>...obj</code> 展开属性。</li>
<li><code>const &#123; a, b, ...rest &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;; // rest: &#123; c: 3, d: 4 &#125;</code></li>
<li><code>const merged = &#123; ...obj1, ...obj2 &#125;;</code></li>
</ul>
</li>
<li><strong><code>Promise.prototype.finally()</code></strong>：<ul>
<li>无论 Promise 成功或失败，都会执行的回调函数，用于清理资源。</li>
</ul>
</li>
<li><strong>正则表达式改进</strong>：<ul>
<li><code>s</code> 标志 (dotAll 模式)：<code>.</code> 匹配包括换行符在内的所有字符。</li>
<li>命名捕获组 (Named Capture Groups)：<code>/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)/.exec(&#39;2023-10&#39;)</code>。</li>
<li>后行断言 (Lookbehind Assertions)：<code>(?&lt;=...)</code> 和 <code>(?&lt;!...)</code>。</li>
</ul>
</li>
</ul>
<h2 id="六、ES2019-ES10"><a href="#六、ES2019-ES10" class="headerlink" title="六、ES2019 (ES10)"></a>六、ES2019 (ES10)</h2><ul>
<li><strong><code>Array.prototype.flat()</code> 和 <code>Array.prototype.flatMap()</code></strong>：<ul>
<li><code>flat()</code>：展平嵌套数组，可指定深度。</li>
<li><code>flatMap()</code>：先 <code>map</code> 再 <code>flat</code>。</li>
<li><code>[1, [2, [3]]].flat(2); // [1, 2, 3]</code></li>
</ul>
</li>
<li><strong><code>Object.fromEntries()</code></strong>：<ul>
<li>与 <code>Object.entries()</code> 相反，将键值对列表转换为对象。</li>
<li><code>Object.fromEntries([[&#39;a&#39;, 1], [&#39;b&#39;, 2]]); // &#123; a: 1, b: 2 &#125;</code></li>
</ul>
</li>
<li><strong><code>String.prototype.trimStart()</code> 和 <code>String.prototype.trimEnd()</code></strong>：<ul>
<li>分别移除字符串开头和结尾的空白符。</li>
</ul>
</li>
<li><strong><code>Symbol.prototype.description</code></strong>：<ul>
<li>获取 Symbol 的描述。</li>
</ul>
</li>
<li><strong><code>Function.prototype.toString()</code> 改进</strong>：<ul>
<li>现在返回函数源代码的精确表示，包括注释和空格。</li>
</ul>
</li>
<li><strong>JSON 超集 (Well-formed JSON.stringify)</strong>：<ul>
<li><code>JSON.stringify</code> 现在可以正确处理 Unicode 字符 U+2028 (行分隔符) 和 U+2029 (段落分隔符)，避免了意外的语法错误。</li>
</ul>
</li>
</ul>
<h2 id="七、ES2020-ES11"><a href="#七、ES2020-ES11" class="headerlink" title="七、ES2020 (ES11)"></a>七、ES2020 (ES11)</h2><ul>
<li><strong><code>BigInt</code></strong>：<ul>
<li>新的原始数据类型，支持任意精度的整数，解决了 JavaScript 数字类型 (<code>Number</code>) 的精度限制（<code>Number.MAX_SAFE_INTEGER</code>）。</li>
<li><code>10n + 20n; // 30n</code></li>
</ul>
</li>
<li><strong>空值合并运算符 <code>??</code> (Nullish Coalescing Operator)</strong>：<ul>
<li>当左侧操作数为 <code>null</code> 或 <code>undefined</code> 时，返回右侧操作数，否则返回右侧。</li>
<li><code>const foo = null ?? &#39;default string&#39;; // &quot;default string&quot;</code></li>
<li><code>const bar = 0 ?? &#39;default string&#39;; // 0</code></li>
</ul>
</li>
<li><strong>可选链运算符 <code>?.</code> (Optional Chaining Operator)</strong>：<ul>
<li>允许在访问嵌套对象属性时，如果路径中的某个引用是 <code>null</code> 或 <code>undefined</code>，则不会报错，而是短路返回 <code>undefined</code>。</li>
<li><code>const name = obj?.user?.address?.street;</code></li>
</ul>
</li>
<li><strong><code>Promise.allSettled()</code></strong>：<ul>
<li>等待所有 Promise 都已解决 (settled，无论是 fulfilled 还是 rejected) 后，返回一个包含所有 Promise 结果的数组。</li>
<li><code>Promise.allSettled([p1, p2, p3]).then(results =&gt; ...)</code></li>
</ul>
</li>
<li><strong><code>globalThis</code></strong>：<ul>
<li>提供了一个标准化的方式来访问全局对象，无论在浏览器 (<code>window</code>)、Node.js (<code>global</code>) 还是 Web Workers (<code>self</code>) 环境下。</li>
</ul>
</li>
<li><strong><code>import()</code> 动态导入</strong>：<ul>
<li>允许在运行时按需加载模块，返回一个 Promise。</li>
<li><code>import(&#39;/modules/my-module.js&#39;).then(module =&gt; &#123; /* ... */ &#125;);</code></li>
</ul>
</li>
<li><strong><code>String.prototype.matchAll()</code></strong>：<ul>
<li>返回一个迭代器，其中包含字符串与全局正则表达式的所有匹配项。</li>
</ul>
</li>
</ul>
<h2 id="八、ES2021-ES12"><a href="#八、ES2021-ES12" class="headerlink" title="八、ES2021 (ES12)"></a>八、ES2021 (ES12)</h2><ul>
<li><strong><code>String.prototype.replaceAll()</code></strong>：<ul>
<li>替换字符串中所有匹配的子串，无需使用正则表达式的 <code>g</code> 标志。</li>
<li><code>&#39;foo bar foo&#39;.replaceAll(&#39;foo&#39;, &#39;baz&#39;); // &quot;baz bar baz&quot;</code></li>
</ul>
</li>
<li><strong><code>Promise.any()</code></strong>：<ul>
<li>接收一个 Promise 数组，只要其中任何一个 Promise 成功，就返回该成功 Promise 的值。如果所有 Promise 都失败，则抛出 <code>AggregateError</code>。</li>
</ul>
</li>
<li><strong>逻辑赋值运算符 (<code>&amp;&amp;=</code>, <code>||=</code>, <code>??=</code>)</strong>：<ul>
<li><code>a &amp;&amp;= b</code> 等同于 <code>if (a) a = b;</code></li>
<li><code>a ||= b</code> 等同于 <code>if (!a) a = b;</code></li>
<li><code>a ??= b</code> 等同于 <code>if (a === null || a === undefined) a = b;</code></li>
</ul>
</li>
<li><strong>数字分隔符 (Numeric Separators)</strong>：<ul>
<li>允许在数字字面量中使用下划线 <code>_</code> 作为分隔符，提高大数字的可读性。</li>
<li><code>1_000_000_000</code></li>
</ul>
</li>
<li><strong><code>WeakRefs</code> 和 <code>FinalizationRegistry</code></strong>：<ul>
<li><code>WeakRef</code> 允许持有对象的弱引用，不会阻止垃圾回收。</li>
<li><code>FinalizationRegistry</code> 允许在对象被垃圾回收时执行回调。主要用于内存管理高级场景。</li>
</ul>
</li>
</ul>
<h2 id="九、ES2022-ES13"><a href="#九、ES2022-ES13" class="headerlink" title="九、ES2022 (ES13)"></a>九、ES2022 (ES13)</h2><ul>
<li><strong>顶层 <code>await</code> (Top-level <code>await</code>)</strong>：<ul>
<li>允许在模块的顶层直接使用 <code>await</code> 关键字，而无需将其包裹在 <code>async</code> 函数中。</li>
<li>简化了模块初始化时的异步操作。</li>
</ul>
</li>
<li><strong><code>Object.hasOwn()</code></strong>：<ul>
<li>一个更安全、更简洁的替代 <code>Object.prototype.hasOwnProperty.call(obj, prop)</code> 的方法。</li>
<li><code>Object.hasOwn(obj, &#39;prop&#39;);</code></li>
</ul>
</li>
<li><strong>类字段声明 (Class Field Declarations)</strong>：<ul>
<li>允许在类的构造函数外部直接声明类属性（公有和私有）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    publicField = <span class="number">1</span>;</span><br><span class="line">    #privateField = <span class="number">2</span>; <span class="comment">// 私有字段</span></span><br><span class="line">    <span class="keyword">static</span> staticField = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>私有方法和访问器 (Private Class Methods and Accessors)</strong>：<ul>
<li>使用 <code>#</code> 前缀定义私有方法和 getter&#x2F;setter。</li>
</ul>
</li>
<li><strong><code>Array</code> 和 <code>String</code> 的 <code>at()</code> 方法</strong>：<ul>
<li>允许使用负索引访问数组和字符串的元素，方便从末尾开始索引。</li>
<li><code>arr.at(-1); // 访问最后一个元素</code></li>
</ul>
</li>
<li><strong><code>Error</code> 对象的 <code>cause</code> 属性</strong>：<ul>
<li>允许在创建新错误时指定其根本原因，方便错误链追踪。</li>
</ul>
</li>
<li><strong>正则表达式匹配索引 (RegExp Match Indices)</strong>：<ul>
<li>在匹配结果中包含每个捕获组的起始和结束索引。</li>
</ul>
</li>
</ul>
<h2 id="十、ES2023-ES14"><a href="#十、ES2023-ES14" class="headerlink" title="十、ES2023 (ES14)"></a>十、ES2023 (ES14)</h2><ul>
<li><strong><code>Array.prototype.toReversed()</code>、<code>toSorted()</code>、<code>toSpliced()</code></strong>：<ul>
<li>这些是 <code>reverse()</code>, <code>sort()</code>, <code>splice()</code> 的非破坏性版本。它们返回一个新数组，而不是修改原数组。</li>
<li><code>const newArr = oldArr.toSorted();</code></li>
</ul>
</li>
<li><strong><code>Array.prototype.with()</code></strong>：<ul>
<li>非破坏性地更新数组中指定索引的元素，并返回一个新数组。</li>
<li><code>const newArr = oldArr.with(index, value);</code></li>
</ul>
</li>
<li><strong><code>Promise.withResolvers()</code></strong>：<ul>
<li>提供了一种更便捷的方式来创建 <code>Promise</code>，并直接暴露 <code>resolve</code> 和 <code>reject</code> 函数。</li>
<li><code>const &#123; promise, resolve, reject &#125; = Promise.withResolvers();</code></li>
</ul>
</li>
<li><strong><code>Map</code> 和 <code>WeakMap</code> 支持 Symbol 作为键</strong>：<ul>
<li>以前 <code>WeakMap</code> 只支持对象作为键，现在也支持 Symbol。</li>
</ul>
</li>
<li><strong>Hashbang Grammars (Shebang)</strong>：<ul>
<li>允许 JavaScript 文件以 <code>#!</code> 开头，指向解释器路径，通常用于 Node.js CLI 工具。</li>
<li><code>#!/usr/bin/env node</code></li>
</ul>
</li>
<li><strong>从 <code>ArrayBuffer</code> 解耦合 <code>ArrayBuffer.prototype.transfer()</code> 方法</strong>：<ul>
<li>用于将 <code>ArrayBuffer</code> 的所有权从一个上下文转移到另一个上下文。</li>
</ul>
</li>
</ul>
<h2 id="十一、ES2024-ES15"><a href="#十一、ES2024-ES15" class="headerlink" title="十一、ES2024 (ES15)"></a>十一、ES2024 (ES15)</h2><p>ES2024 仍在开发中，以下是几个已达到 Stage 4 阶段（准备发布）或即将达到 Stage 4 的提案，它们预计将成为 ES2024 的一部分：</p>
<ul>
<li><strong>装饰器 (Decorators)</strong>：<ul>
<li>允许通过一种简洁的语法来修改类、方法、属性和访问器。它是一个元编程功能，可以用于例如日志、验证、依赖注入等。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@logMethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  @timeMethod</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong><code>Promise.withResolvers()</code></strong>：<ul>
<li>简化了创建 <code>Promise</code> 的方式，直接返回 <code>promise</code> 本身以及 <code>resolve</code> 和 <code>reject</code> 函数，而无需嵌套构造函数。这个特性在 ES2023 讨论中，但更可能在 ES2024 中正式落地。</li>
<li><code>const &#123; promise, resolve, reject &#125; = Promise.withResolvers();</code></li>
</ul>
</li>
<li><strong>新的 <code>Set</code> 方法</strong>：<ul>
<li><code>intersection()</code>: 返回两个 Set 的交集。</li>
<li><code>union()</code>: 返回两个 Set 的并集。</li>
<li><code>difference()</code>: 返回一个 Set 相对于另一个 Set 的差集。</li>
<li><code>symmetricDifference()</code>: 返回两个 Set 的对称差集。</li>
<li><code>isSubsetOf()</code>: 判断一个 Set 是否是另一个 Set 的子集。</li>
<li><code>isSupersetOf()</code>: 判断一个 Set 是否是另一个 Set 的超集。</li>
<li><code>isDisjointFrom()</code>: 判断两个 Set 是否不相交。</li>
</ul>
</li>
<li><strong><code>ArrayBuffer.prototype.transfer()</code> 和 <code>transferToFixedLength()</code></strong><ul>
<li>用于在不同 realm (例如主线程和 Worker 线程) 之间高效地转移 <code>ArrayBuffer</code> 的所有权，而不是复制。</li>
</ul>
</li>
</ul>
<h2 id="十二、ES2025-ES16-及未来展望"><a href="#十二、ES2025-ES16-及未来展望" class="headerlink" title="十二、ES2025 (ES16) 及未来展望"></a>十二、ES2025 (ES16) 及未来展望</h2><p>ES2025 的特性仍在早期提案阶段，以下是目前处于 Stage 3 阶段（有望在未来版本中包含）或被广泛讨论的提案：</p>
<ul>
<li><strong>Records 和 Tuples (Stage 2&#x2F;3)</strong>：<ul>
<li>引入了深度不可变的数据结构，类似于 Python 的元组和命名元组。它们将解决 JavaScript 中对象和数组的可变性问题，并允许通过值进行比较。</li>
<li><code>const record = #&#123; x: 1, y: 2 &#125;;</code></li>
<li><code>const tuple = #[1, 2, 3];</code></li>
</ul>
</li>
<li><strong><code>Temporal</code> API (Stage 3)</strong>：<ul>
<li>一个全新的、现代的日期时间 API，旨在替代 <code>Date</code> 对象的所有痛点。它提供了对日期、时间、时区、持续时间等的强大支持，并解决了 <code>Date</code> 对象的许多设计缺陷。</li>
<li><code>Temporal.Now.plainDateTimeISO();</code></li>
<li><code>Temporal.Duration.from(&#123; hours: 5, minutes: 30 &#125;);</code></li>
</ul>
</li>
<li><strong>模块导入断言 (Import Assertions) (Stage 3)</strong>：<ul>
<li>允许在 <code>import</code> 语句中包含额外的元数据，以帮助 JavaScript 运行时理解如何加载模块。例如，指定模块的类型（JSON、CSS 模块等）。</li>
<li><code>import json from &quot;./foo.json&quot; assert &#123; type: &quot;json&quot; &#125;;</code></li>
</ul>
</li>
<li><strong>迭代器助手 (Iterator Helpers) (Stage 3)</strong>：<ul>
<li>为所有迭代器提供类似数组方法（如 <code>map</code>, <code>filter</code>, <code>reduce</code>）的实用工具，使得操作迭代器更加方便，无需先转换为数组。</li>
<li><code>getNumbers().map(n =&gt; n * 2).filter(n =&gt; n &gt; 10).toArray();</code></li>
</ul>
</li>
<li><strong>异步上下文 (Asynchronous Context) (Stage 3)</strong>：<ul>
<li>为异步操作提供一种跟踪上下文（例如请求 ID、链路追踪 ID）的机制，类似于线程局部存储 (thread-local storage)，对于调试和可观测性非常有用。</li>
</ul>
</li>
<li><strong>可选链运算符的扩展 (Extended <code>?.</code> behavior)</strong>：<ul>
<li>例如，在 <code>delete</code> 操作中使用可选链。</li>
<li><code>delete obj?.prop;</code></li>
</ul>
</li>
<li><strong><code>ArrayBuffer</code> 上的 <code>resizable()</code> 和 <code>growable()</code> 属性</strong>：<ul>
<li>允许创建可调整大小的 <code>ArrayBuffer</code>。</li>
</ul>
</li>
</ul>
<h2 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h2><p>JavaScript 已经从一个简单的网页脚本语言发展成为一个功能强大、应用广泛的通用编程语言。从 ES6 开始的每年一次的版本发布，确保了它能够快速适应行业需求和开发者期望。掌握每个版本的新特性不仅能够帮助我们编写更现代、更高效的代码，还能保持与前端和后端技术栈的同步，从而在不断变化的 Web 开发领域保持竞争力。开发者应持续关注 ECMAScript 提案的进展，以便在生产环境中应用最新和最稳定的特性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/e208a03b114e/">https://blog.tbf1211.xx.kg/e208a03b114e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/">语言版本</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/c1df397eedad/" title="TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)</div></div><div class="info-2"><div class="info-item-1"> TypeScript 是由 Microsoft 开发和维护的一种开源编程语言。它是 JavaScript 的一个超集，添加了可选的静态类型、类、接口等特性，旨在提高大型应用开发的效率和可维护性。自 2012 年首次发布以来，TypeScript 社区每月或每季度发布一个新版本，不断引入新的语言特性、编译器优化、工具改进和类型系统增强。理解这些版本特性对于 TypeScript 开发者来说至关重要，它能帮助我们编写更健壮、更现代化且更易于维护的代码。  核心思想： TypeScript 的版本迭代始终围绕着“提升开发者体验、增强类型安全性、更好地支持 JavaScript 新特性、改进工具链”这些目标，旨在弥合 JavaScript 的动态性与大型应用开发对静态分析需求的差距。   一、TypeScript 1.0 - 1.8：早期奠基与核心功能TypeScript 在早期版本主要关注语言的稳定、核心功能的完善以及与 JavaScript 的兼容性。 1.1 TypeScript 1.0 (2014-04-02) 第一个稳定版本：标志着 TypeScript 正式可以用于生产环境...</div></div></div></a><a class="pagination-related" href="/bb47c1f6baff/" title="两侧胸膜增厚详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">两侧胸膜增厚详解</div></div><div class="info-2"><div class="info-item-1"> 胸膜增厚是指胸膜组织因炎症、损伤、肿瘤等各种原因，导致其结构发生纤维化和硬化，从而变得比正常胸膜更厚、更致密。两侧胸膜增厚则意味着双侧肺部表面的胸膜或胸壁内侧的胸膜都出现了这种病理变化。这通常是胸膜疾病的后遗症或慢性病理过程的表现，而非一种独立的疾病。  核心思想：两侧胸膜增厚通常是胸膜炎症或损伤（如胸膜炎、胸腔积液、感染、创伤、职业暴露）长期或反复发作后的瘢痕形成，是继发性病变。其临床意义需结合病史、影像学特征及患者症状综合评估。   一、胸膜的解剖与生理在理解胸膜增厚之前，首先回顾一下胸膜的基本知识：  胸膜 (Pleura)：是一层薄而光滑的浆膜，分为两层： 脏层胸膜 (Visceral Pleura)：紧密覆盖在肺表面，深入肺裂。 壁层胸膜 (Parietal Pleura)：衬于胸腔内壁、膈肌上表面和纵隔侧面。   胸膜腔 (Pleural Cavity)：脏层胸膜和壁层胸膜之间的潜在间隙，内含少量浆液（约10-20ml），起到润滑作用，使肺在呼吸时能够平滑地在胸腔内滑动。 功能：胸膜的主要功能是减少呼吸时肺与胸壁之间的摩擦，并参与维持肺的膨胀状态。  二、两侧胸膜增...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/902d004f5ccc/" title="浏览器指纹 (Browser Fingerprinting) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">浏览器指纹 (Browser Fingerprinting) 详解</div></div><div class="info-2"><div class="info-item-1"> 浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是浏览器指纹？浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。 这个“指纹”的强大之处在于其持久性和隐蔽性，用户很难通过常规手段进行清除或规避。 二、浏览器指纹的工作原理网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括： 1. HTTP 请求头信息 (HTT...</div></div></div></a><a class="pagination-related" href="/5341a0037256/" title="CSS-in-JS 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-26</div><div class="info-item-2">CSS-in-JS 详解</div></div><div class="info-2"><div class="info-item-1"> CSS-in-JS 是一种前端开发范式，它将 CSS 代码编写在 JavaScript 文件中，而不是传统的 .css 或 .scss 文件。这种方式通常通过 JavaScript 库（如 Styled Components, Emotion, JSS 等）实现，允许开发者使用 JavaScript 的强大功能（如变量、函数、组件逻辑）来创建和管理组件的样式。最终，这些 JavaScript 代码会在运行时或编译时生成实际的 CSS 样式，并将其注入到 DOM 中。  核心思想：将样式与组件逻辑紧密耦合，实现高度模块化、动态化和可维护的组件样式。 它解决了传统 CSS 在大型应用中面临的全局作用域、命名冲突、样式复用和动态化难题。   一、为什么需要 CSS-in-JS？传统的 CSS 开发模式，尤其是在大型、组件化的应用中，存在一些固有的痛点：  全局作用域 (Global Scope)：  CSS 默认是全局的，所有样式都共享同一个作用域。这导致了严重的命名冲突问题，需要使用 BEM (Block Element Modifier) 等命名约定来规避，增加了心智负担。 高特...</div></div></div></a><a class="pagination-related" href="/c1df397eedad/" title="TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="info-item-2">TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)</div></div><div class="info-2"><div class="info-item-1"> TypeScript 是由 Microsoft 开发和维护的一种开源编程语言。它是 JavaScript 的一个超集，添加了可选的静态类型、类、接口等特性，旨在提高大型应用开发的效率和可维护性。自 2012 年首次发布以来，TypeScript 社区每月或每季度发布一个新版本，不断引入新的语言特性、编译器优化、工具改进和类型系统增强。理解这些版本特性对于 TypeScript 开发者来说至关重要，它能帮助我们编写更健壮、更现代化且更易于维护的代码。  核心思想： TypeScript 的版本迭代始终围绕着“提升开发者体验、增强类型安全性、更好地支持 JavaScript 新特性、改进工具链”这些目标，旨在弥合 JavaScript 的动态性与大型应用开发对静态分析需求的差距。   一、TypeScript 1.0 - 1.8：早期奠基与核心功能TypeScript 在早期版本主要关注语言的稳定、核心功能的完善以及与 JavaScript 的兼容性。 1.1 TypeScript 1.0 (2014-04-02) 第一个稳定版本：标志着 TypeScript 正式可以用于生产环境...</div></div></div></a><a class="pagination-related" href="/b25babd84514/" title="Vue3 defineModel详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-03</div><div class="info-item-2">Vue3 defineModel详解</div></div><div class="info-2"><div class="info-item-1"> defineModel 是 Vue 3.4 版本中引入的一个新的宏 (macro)，旨在简化组件中双向绑定 v-model 的实现。在 Composition API 的 setup 语法糖 (&lt;script setup&gt;) 中使用时，它极大地减少了为组件实现 v-model 所需的样板代码，使其更加直观和便捷。  核心思想：defineModel 是 defineProps 和 defineEmits 的语法糖，它声明了一个可双向绑定的 props，并自动处理了 modelValue prop 的接收和相应的 update:modelValue 事件的触发，让自定义组件的 v-model 用法变得和原生表单元素一样简洁。   一、为什么需要 defineModel？在 defineModel 出现之前，如果你想在 Vue 3 的自定义组件中实现 v-model 双向绑定，你需要手动完成以下步骤：  通过 defineProps 声明一个名为 modelValue 的 prop 来接收父组件传递的值。 通过 defineEmits 声明一个名为 update:mod...</div></div></div></a><a class="pagination-related" href="/f1d2005549f2/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-28</div><div class="info-item-2">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</div></div><div class="info-2"><div class="info-item-1"> 在过去十年中，前端开发领域由 JavaScript 框架（如 React, Vue, Angular）占据主导地位，它们将整个用户界面放在客户端，通过 API 与后端交互。然而，这种“单页应用 (SPA)”模式并非总是最佳选择，它带来了复杂的构建流程、初始加载性能问题、SEO 挑战以及较高的开发和维护成本。 HTMX 的出现，挑战了这一主流范式。它主张将交互逻辑回归到服务器端，通过简单的 HTML 属性就能实现 AJAX 请求、CSS 过渡、WebSocket 和服务器发送事件 (SSE)，在不编写一行 JavaScript 代码的情况下，实现丰富的动态用户体验。  本文将深入探讨 HTMX 的核心理念、工作原理、主要特性、优缺点以及适用场景，帮助你理解这个“返璞归真”但又极具创新力的工具。   一、 HTMX 是什么？核心理念与哲学HTMX 是一个小型 (约 15KB gzipped) 的 JavaScript 库，它通过扩展 HTML 原生能力，允许你在 HTML 元素上直接指定 AJAX 请求、CSS 动画、WebSocket 和服务器发送事件 (SSE) 行为。 其核心...</div></div></div></a><a class="pagination-related" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-08</div><div class="info-item-2">Bun.js 深度解析：冷启动与边缘函数优化</div></div><div class="info-2"><div class="info-item-1"> Bun.js 是一个现代化的 JavaScript 运行时、工具包和包管理器，旨在提供极致的性能和一体化的开发体验。它由 Jarred Sumner 创建，使用 Zig 语言开发，并基于 WebKit 的 JavaScriptCore 引擎。Bun 的一个突出优势是其极快的冷启动速度，这使其成为在边缘计算 (Edge Computing) 和 Serverless 函数环境中运行 JavaScript&#x2F;TypeScript 代码的理想选择。  核心思想：Bun 通过利用 JavaScriptCore 引擎的快速启动特性和 Zig 语言的底层优化，显著缩短了 JavaScript&#x2F;TypeScript 应用的冷启动时间。这种性能优势使其特别适合部署到边缘函数和 Serverless 平台，从而提供更低的延迟和更高的资源利用效率。   一、Bun.js 概述与性能基石1.1 什么是 Bun.js？Bun 是一个多功能一体的 JavaScript 工具链，它集成了一个高性能的 JavaScript&#x2F;TypeScript 运行时、包管理器、打包器、转译器和...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">533</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%97%A9%E6%9C%9F%E7%89%88%E6%9C%AC%EF%BC%9A%E5%A5%A0%E5%AE%9A%E5%9F%BA%E7%A1%80-ES1-ES5"><span class="toc-text">一、早期版本：奠定基础 (ES1 - ES5)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-ES1-1997-ES3-1999"><span class="toc-text">1.1 ES1 (1997) - ES3 (1999)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-ES5-2009"><span class="toc-text">1.2 ES5 (2009)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ES6-ES2015-%EF%BC%9A%E7%8E%B0%E4%BB%A3-JavaScript-%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-text">二、ES6 (ES2015)：现代 JavaScript 的起点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ES2016-ES7"><span class="toc-text">三、ES2016 (ES7)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ES2017-ES8"><span class="toc-text">四、ES2017 (ES8)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ES2018-ES9"><span class="toc-text">五、ES2018 (ES9)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ES2019-ES10"><span class="toc-text">六、ES2019 (ES10)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81ES2020-ES11"><span class="toc-text">七、ES2020 (ES11)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81ES2021-ES12"><span class="toc-text">八、ES2021 (ES12)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81ES2022-ES13"><span class="toc-text">九、ES2022 (ES13)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81ES2023-ES14"><span class="toc-text">十、ES2023 (ES14)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81ES2024-ES15"><span class="toc-text">十一、ES2024 (ES15)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81ES2025-ES16-%E5%8F%8A%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-text">十二、ES2025 (ES16) 及未来展望</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">十三、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-02.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>