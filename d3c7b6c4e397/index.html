<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SHA-256 算法详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SHA-256 (Secure Hash Algorithm 256) 是 SHA-2 (Secure Hash Algorithm 2) 系列中最常用和最广为人知的加密散列函数之一。它由美国国家标准与技术研究院 (NIST) 于 2001 年发布，作为 MD5 和 SHA-1 的替代品，旨在提供更高的安全强度。SHA-256 能够将任意长度的输入数据（消息）通过哈希运算转换成一个固定长度的 2">
<meta property="og:type" content="article">
<meta property="og:title" content="SHA-256 算法详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/d3c7b6c4e397/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="SHA-256 (Secure Hash Algorithm 256) 是 SHA-2 (Secure Hash Algorithm 2) 系列中最常用和最广为人知的加密散列函数之一。它由美国国家标准与技术研究院 (NIST) 于 2001 年发布，作为 MD5 和 SHA-1 的替代品，旨在提供更高的安全强度。SHA-256 能够将任意长度的输入数据（消息）通过哈希运算转换成一个固定长度的 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg">
<meta property="article:published_time" content="2024-06-20T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-09T03:59:00.785Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="哈希算法">
<meta property="article:tag" content="加密算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SHA-256 算法详解",
  "url": "https://blog.tbf1211.xx.kg/d3c7b6c4e397/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg",
  "datePublished": "2024-06-20T22:24:00.000Z",
  "dateModified": "2025-12-09T03:59:00.785Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/d3c7b6c4e397/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SHA-256 算法详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">359</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">210</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">75</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-32.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">SHA-256 算法详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SHA-256 算法详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-06-20T22:24:00.000Z" title="发表于 2024-06-21 06:24:00">2024-06-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/d3c7b6c4e397/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>SHA-256 (Secure Hash Algorithm 256)</strong> 是 SHA-2 (Secure Hash Algorithm 2) 系列中最常用和最广为人知的加密散列函数之一。它由美国国家标准与技术研究院 (NIST) 于 2001 年发布，作为 MD5 和 SHA-1 的替代品，旨在提供更高的安全强度。SHA-256 能够将任意长度的输入数据（消息）通过哈希运算转换成一个固定长度的 256 位（32 字节）散列值，通常以 64 位十六进制字符串表示。它广泛应用于数字签名、数据完整性校验、密码存储以及区块链技术等领域，是目前主流且被认为安全的哈希算法。</p>
</blockquote>
<h2 id="一、加密哈希函数的基本特性"><a href="#一、加密哈希函数的基本特性" class="headerlink" title="一、加密哈希函数的基本特性"></a>一、加密哈希函数的基本特性</h2><p>在深入 SHA-256 之前，理解一个安全的加密哈希函数应具备的关键特性至关重要：</p>
<ul>
<li><strong>确定性 (Deterministic)</strong>：相同的输入消息总是产生相同的哈希值。</li>
<li><strong>计算效率 (Computational Efficiency)</strong>：对于任意输入消息，计算其哈希值是高效的。</li>
<li><strong>抗原像性 &#x2F; 单向性 (Preimage Resistance &#x2F; One-Way)</strong>：给定一个哈希值，从计算上不可能找到原始输入消息。</li>
<li><strong>抗第二原像性 (Second Preimage Resistance)</strong>：给定一个输入消息和它的哈希值，从计算上不可能找到另一个不同的输入消息，使其产生相同的哈希值。</li>
<li><strong>抗碰撞性 (Collision Resistance)</strong>：从计算上不可能找到任意两个不同的输入消息，使其产生相同的哈希值。</li>
</ul>
<p>SHA-256 被设计为满足上述所有特性，尤其是在抗碰撞性方面远超 MD5 和 SHA-1。</p>
<h2 id="二、SHA-256-算法原理"><a href="#二、SHA-256-算法原理" class="headerlink" title="二、SHA-256 算法原理"></a>二、SHA-256 算法原理</h2><p>SHA-256 算法基于 <strong>Merkle-Damgård 结构</strong>，它将输入消息分割成固定大小的块，并对每个块进行迭代处理。整个过程可以概括为以下几个主要步骤：</p>
<h3 id="2-1-填充-Padding"><a href="#2-1-填充-Padding" class="headerlink" title="2.1 填充 (Padding)"></a>2.1 填充 (Padding)</h3><p>首先，原始消息需要进行填充，使其长度（以位为单位）在模 512 之后余 448。也就是说，填充后的消息长度应为 $512n - 64$ 位，其中 $n$ 是某个正整数。<br>填充过程如下：</p>
<ol>
<li>在消息末尾添加一个 <code>1</code> 位。</li>
<li>接着添加尽可能多的 <code>0</code> 位，直到消息的长度满足 $length \equiv 448 \pmod{512}$。<ul>
<li>即使消息长度已经满足此条件，也需要进行一轮完整的填充（添加一个 <code>1</code> 和 511 个 <code>0</code>）。</li>
</ul>
</li>
</ol>
<h3 id="2-2-附加长度-Appending-Length"><a href="#2-2-附加长度-Appending-Length" class="headerlink" title="2.2 附加长度 (Appending Length)"></a>2.2 附加长度 (Appending Length)</h3><p>在填充完毕的消息之后，附加 64 位的原始消息长度（以位为单位）。这个 64 位长度值以大端序 (big-endian) 形式附加。<br>经过填充和附加长度后，消息的总长度将是 512 位的整数倍。这些 512 位的块将是算法处理的基本单位。</p>
<h3 id="2-3-初始化哈希值-Initialize-Hash-Values-IVs"><a href="#2-3-初始化哈希值-Initialize-Hash-Values-IVs" class="headerlink" title="2.3 初始化哈希值 (Initialize Hash Values - IVs)"></a>2.3 初始化哈希值 (Initialize Hash Values - IVs)</h3><p>SHA-256 使用 8 个 32 位的初始哈希值 (Initial Hash Values, IVs) $H_0$ 到 $H_7$。这些值是根据前 8 个素数（2, 3, 5, 7, 11, 13, 17, 19）的平方根的小数部分取前 32 位得到的。<br>这些常量以十六进制表示为：</p>
<ul>
<li>$H_0 &#x3D; \text{0x6a09e667}$</li>
<li>$H_1 &#x3D; \text{0xbb67ae85}$</li>
<li>$H_2 &#x3D; \text{0x3c6ef372}$</li>
<li>$H_3 &#x3D; \text{0xa54ff53a}$</li>
<li>$H_4 &#x3D; \text{0x510e527f}$</li>
<li>$H_5 &#x3D; \text{0x9b05688c}$</li>
<li>$H_6 &#x3D; \text{0x1f83d9ab}$</li>
<li>$H_7 &#x3D; \text{0x5be0cd19}$</li>
</ul>
<h3 id="2-4-消息处理循环-Message-Processing-Loop"><a href="#2-4-消息处理循环-Message-Processing-Loop" class="headerlink" title="2.4 消息处理循环 (Message Processing Loop)"></a>2.4 消息处理循环 (Message Processing Loop)</h3><p>将经过填充和附加长度处理后的消息划分为 N 个 512 位的消息块 $M^{(1)}, M^{(2)}, \dots, M^{(N)}$。算法依次处理每个块。<br>对于每个 512 位的消息块 $M^{(i)}$，都通过一个<strong>压缩函数 (Compression Function)</strong> 进行处理。压缩函数接收当前的 512 位消息块和前一个块产生的 256 位哈希值（即当前的 $H_0, \dots, H_7$），并输出一个新的 256 位哈希值。</p>
<p>压缩函数的核心步骤如下：</p>
<h4 id="2-4-1-消息扩展-Message-Schedule"><a href="#2-4-1-消息扩展-Message-Schedule" class="headerlink" title="2.4.1 消息扩展 (Message Schedule)"></a>2.4.1 消息扩展 (Message Schedule)</h4><p>将输入的 512 位消息块 $M^{(i)}$ 分解成 16 个 32 位的字 $W_0, W_1, \dots, W_{15}$。然后，将这 16 个字扩展成 64 个 32 位的字 $W_0, W_1, \dots, W_{63}$。<br>对于 $t$ 从 16 到 63：<br>$$<br>W_t &#x3D; \sigma_1(W_{t-2}) + W_{t-7} + \sigma_0(W_{t-15}) + W_{t-16}<br>$$<br>其中，<code>+</code> 表示模 $2^{32}$ 的加法。<br>两个辅助函数 $\sigma_0$ 和 $\sigma_1$ 定义为：<br>$$<br>\sigma_0(x) &#x3D; \text{ROTR}^7(x) \oplus \text{ROTR}^{18}(x) \oplus \text{SHR}^3(x) \<br>\sigma_1(x) &#x3D; \text{ROTR}^{17}(x) \oplus \text{ROTR}^{19}(x) \oplus \text{SHR}^{10}(x)<br>$$</p>
<ul>
<li><code>ROTR^n(x)</code>：表示将 32 位字 $x$ 循环右移 $n$ 位。</li>
<li><code>SHR^n(x)</code>：表示将 32 位字 $x$ 逻辑右移 $n$ 位。</li>
<li><code>$\oplus$</code>：表示按位异或。</li>
</ul>
<h4 id="2-4-2-压缩函数主循环-64-轮"><a href="#2-4-2-压缩函数主循环-64-轮" class="headerlink" title="2.4.2 压缩函数主循环 (64 轮)"></a>2.4.2 压缩函数主循环 (64 轮)</h4><p>每个消息块的处理包含 64 轮迭代。每轮迭代都会更新 8 个 32 位的<strong>工作变量 (working variables)</strong> $a, b, c, d, e, f, g, h$。<br>初始时，这些工作变量被赋值为当前的哈希值：$a&#x3D;H_0, b&#x3D;H_1, \dots, h&#x3D;H_7$。</p>
<p>在每一轮 $t$ (从 0 到 63) 中，执行以下操作：</p>
<ol>
<li><strong>轮常数 ($K_t$)</strong>：SHA-256 定义了 64 个 32 位常数 $K_0, K_1, \dots, K_{63}$。这些常数是根据前 64 个素数的立方根的小数部分取前 32 位得到的。</li>
<li><strong>逻辑函数</strong>：<ul>
<li><strong>选择函数 (Ch)</strong>: $Ch(x, y, z) &#x3D; (x \land y) \oplus (\neg x \land z)$</li>
<li><strong>多数函数 (Maj)</strong>: $Maj(x, y, z) &#x3D; (x \land y) \oplus (x \land z) \oplus (y \land z)$</li>
<li><strong>大写Sigma函数 ($\Sigma_0, \Sigma_1$)</strong>:<ul>
<li>$\Sigma_0(x) &#x3D; \text{ROTR}^2(x) \oplus \text{ROTR}^{13}(x) \oplus \text{ROTR}^{22}(x)$</li>
<li>$\Sigma_1(x) &#x3D; \text{ROTR}^6(x) \oplus \text{ROTR}^{11}(x) \oplus \text{ROTR}^{25}(x)$</li>
</ul>
</li>
</ul>
</li>
<li><strong>计算两个临时变量 <code>temp1</code> 和 <code>temp2</code></strong>:<br>$$<br>temp1 &#x3D; h + \Sigma_1(e) + Ch(e,f,g) + K_t + W_t \<br>temp2 &#x3D; \Sigma_0(a) + Maj(a,b,c)<br>$$<br>所有加法都是模 $2^{32}$ 的加法。</li>
<li><strong>更新工作变量</strong>:<br>$$<br>h &#x3D; g \<br>g &#x3D; f \<br>f &#x3D; e \<br>e &#x3D; d + temp1 \<br>d &#x3D; c \<br>c &#x3D; b \<br>b &#x3D; a \<br>a &#x3D; temp1 + temp2<br>$$<br>这个循环重复 64 次。</li>
</ol>
<p><strong>SHA-256 压缩函数单轮示意图 (简化)：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph Inputs for Round t
        A(a) -- Current A --&gt; A_Sigma0(&quot;Σ0(a)&quot;)
        B(b)
        C(c)
        D(d)
        E(e) -- Current E --&gt; E_Sigma1(&quot;Σ1(e)&quot;)
        F(f)
        G(g)
        H(h)
        Kt[Kt]
        Wt[Wt]
    end

    A_Sigma0 --&gt; Maj[&quot;Maj(a,b,c)&quot;]
    B --&gt; Maj
    C --&gt; Maj

    E_Sigma1 --&gt; Ch[&quot;Ch(e,f,g)&quot;]
    F --&gt; Ch
    G --&gt; Ch

    temp1_calc(&quot;h + Σ1(e) + Ch(e,f,g) + Kt + Wt&quot;)
    temp2_calc(&quot;Σ0(a) + Maj(a,b,c)&quot;)

    H --&gt; temp1_calc
    E_Sigma1 --&gt; temp1_calc
    Ch --&gt; temp1_calc
    Kt --&gt; temp1_calc
    Wt --&gt; temp1_calc

    A_Sigma0 --&gt; temp2_calc
    Maj --&gt; temp2_calc

    temp1_calc --&gt; next_e[e &#x3D; d + temp1]
    temp1_calc --&gt; next_a[a &#x3D; temp1 + temp2]
    temp2_calc --&gt; next_a

    D --&gt; next_e
  
    A --&gt; next_b[b &#x3D; a]
    B --&gt; next_c[c &#x3D; b]
    C --&gt; next_d[d &#x3D; c]
    E --&gt; next_f[f &#x3D; e]
    F --&gt; next_g[g &#x3D; f]
    G --&gt; next_h[h &#x3D; g]

    next_a --&gt; OutputA[New a]
    next_b --&gt; OutputB[New b]
    next_c --&gt; OutputC[New c]
    next_d --&gt; OutputD[New d]
    next_e --&gt; OutputE[New e]
    next_f --&gt; OutputF[New f]
    next_g --&gt; OutputG[New g]
    next_h --&gt; OutputH[New h]

    OutputA &amp; OutputB &amp; OutputC &amp; OutputD &amp; OutputE &amp; OutputF &amp; OutputG &amp; OutputH --&gt; Z{Update A-H for next round}
  </pre></div>

<h4 id="2-4-3-更新哈希值"><a href="#2-4-3-更新哈希值" class="headerlink" title="2.4.3 更新哈希值"></a>2.4.3 更新哈希值</h4><p>在对当前 512 位消息块的 64 轮处理完成后，将初始的工作变量 $a, b, \dots, h$ (即本轮开始时的 $H_0, \dots, H_7$) 与本轮结束后的工作变量进行模 $2^{32}$ 的加法，更新哈希值：<br>$$<br>H_0 &#x3D; H_0 + a \<br>H_1 &#x3D; H_1 + b \<br>\dots \<br>H_7 &#x3D; H_7 + h<br>$$<br>这个更新后的 256 位哈希值将作为下一个消息块处理的输入。</p>
<h3 id="2-5-输出-Output"><a href="#2-5-输出-Output" class="headerlink" title="2.5 输出 (Output)"></a>2.5 输出 (Output)</h3><p>当所有 512 位的消息块都处理完毕后，最终的 8 个 32 位哈希值 $H_0, H_1, \dots, H_7$ 按大端序连接起来，就构成了最终的 256 位（32 字节）SHA-256 消息摘要。</p>
<h2 id="三、SHA-256-的安全性与应用"><a href="#三、SHA-256-的安全性与应用" class="headerlink" title="三、SHA-256 的安全性与应用"></a>三、SHA-256 的安全性与应用</h2><ul>
<li><strong>安全性</strong>：SHA-256 被认为是安全的加密哈希函数，目前尚未发现任何实际可行的碰撞攻击或原像攻击。其设计复杂度、大哈希值长度和位操作的结合，使其在计算上抵抗各种已知密码分析攻击。</li>
<li><strong>应用</strong>：<ul>
<li><strong>数字签名</strong>：广泛用于 TLS&#x2F;SSL 证书、代码签名、文件签名，确保数据来源的真实性和完整性。</li>
<li><strong>密码存储</strong>：用于存储用户密码的哈希值。为了增强安全性，通常会结合<strong>盐值 (Salt)</strong> 和密钥派生函数 (KDF)，如 PBKDF2、scrypt 或 Argon2，来抵御彩虹表攻击和暴力破解。</li>
<li><strong>数据完整性校验</strong>：通过比较文件或数据的 SHA-256 哈希值来验证其在传输或存储过程中是否被篡改。</li>
<li><strong>区块链和加密货币</strong>：比特币的核心工作量证明 (Proof of Work) 机制就严重依赖 SHA-256 算法。</li>
<li><strong>伪随机数生成器</strong>：可以作为构建安全伪随机数生成器的组件。</li>
</ul>
</li>
</ul>
<h2 id="四、Go-语言实现示例"><a href="#四、Go-语言实现示例" class="headerlink" title="四、Go 语言实现示例"></a>四、Go 语言实现示例</h2><p>Go 语言的 <code>crypto/sha256</code> 包提供了 SHA-256 算法的标准实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculateSHA256String 计算给定字符串的 SHA-256 哈希值，并返回 64 位十六进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateSHA256String</span><span class="params">(input <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	hasher := sha256.New()           <span class="comment">// 创建一个新的 SHA-256 哈希器</span></span><br><span class="line">	hasher.Write([]<span class="type">byte</span>(input))      <span class="comment">// 将输入字符串写入哈希器</span></span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(hasher.Sum(<span class="literal">nil</span>)) <span class="comment">// 计算哈希值并转换为十六进制字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculateSHA256File 计算给定文件的 SHA-256 哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateSHA256File</span><span class="params">(filePath <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	file, err := os.Open(filePath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;打开文件失败: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close() <span class="comment">// 确保文件在函数结束时关闭</span></span><br><span class="line"></span><br><span class="line">	hasher := sha256.New()</span><br><span class="line">	<span class="comment">// 将文件内容复制到哈希器中进行计算</span></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(hasher, file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;读取文件内容失败: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(hasher.Sum(<span class="literal">nil</span>)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 计算字符串的 SHA-256 值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;--- 计算字符串 SHA-256 ---&quot;</span>)</span><br><span class="line">	message1 := <span class="string">&quot;Hello, SHA-256!&quot;</span></span><br><span class="line">	hash1 := calculateSHA256String(message1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;消息: \&quot;%s\&quot;\nSHA-256: %s (长度: %d 字节)\n&quot;</span>, message1, hash1, <span class="built_in">len</span>(hash1)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	message2 := <span class="string">&quot;hello, sha-256!&quot;</span> <span class="comment">// 哪怕一个字符或大小写不同，哈希值也完全不同</span></span><br><span class="line">	hash2 := calculateSHA256String(message2)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;消息: \&quot;%s\&quot;\nSHA-256: %s (长度: %d 字节)\n&quot;</span>, message2, hash2, <span class="built_in">len</span>(hash2)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 演示 SHA-256 的确定性</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 确定性演示 ---&quot;</span>)</span><br><span class="line">	message3 := <span class="string">&quot;Go语言SHA-256示例&quot;</span></span><br><span class="line">	hash3a := calculateSHA256String(message3)</span><br><span class="line">	hash3b := calculateSHA256String(message3)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;消息: \&quot;%s\&quot;\n第一次SHA-256: %s\n第二次SHA-256: %s\n&quot;</span>, message3, hash3a, hash3b)</span><br><span class="line">	<span class="keyword">if</span> hash3a == hash3b &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;✅ 相同输入产生相同输出。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 计算文件的 SHA-256 值 (需要先创建一个测试文件)</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 计算文件 SHA-256 ---&quot;</span>)</span><br><span class="line">	testFileName := <span class="string">&quot;sha256_testfile.txt&quot;</span></span><br><span class="line">	fileContent := <span class="string">&quot;这是一个测试文件的内容，用于计算SHA-256哈希值。\n&quot;</span> +</span><br><span class="line">		<span class="string">&quot;您可以修改这个文件，然后再次运行程序，观察MD5值的变化。&quot;</span></span><br><span class="line">	</span><br><span class="line">	err := os.WriteFile(testFileName, []<span class="type">byte</span>(fileContent), <span class="number">0644</span>) <span class="comment">// 0644 是文件权限</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;创建测试文件失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;已创建测试文件: %s\n&quot;</span>, testFileName)</span><br><span class="line"></span><br><span class="line">	fileSHA256, err := calculateSHA256File(testFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;计算文件 SHA-256 失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件 \&quot;%s\&quot; 的 SHA-256: %s\n&quot;</span>, testFileName, fileSHA256)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. (可选) 演示文件修改会导致 SHA-256 改变</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- 演示文件修改 (雪崩效应) ---&quot;</span>)</span><br><span class="line">	modifiedContent := fileContent + <span class="string">&quot;\n末尾添加了一行内容，观察哈希值的剧烈变化。&quot;</span></span><br><span class="line">	err = os.WriteFile(testFileName, []<span class="type">byte</span>(modifiedContent), <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;修改测试文件失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;已修改测试文件: %s\n&quot;</span>, testFileName)</span><br><span class="line"></span><br><span class="line">	modifiedFileSHA256, err := calculateSHA256File(testFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;计算修改后文件 SHA-256 失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;修改后文件 \&quot;%s\&quot; 的 SHA-256: %s\n&quot;</span>, testFileName, modifiedFileSHA256)</span><br><span class="line">	<span class="keyword">if</span> fileSHA256 != modifiedFileSHA256 &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;✅ SHA-256 值发生变化，证明数据被修改 (体现了雪崩效应)。&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;❌ SHA-256 值未变化，但文件内容已修改 (这不可能发生，除非是碰撞攻击)。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清理测试文件 (可选)</span></span><br><span class="line">	<span class="comment">// os.Remove(testFileName)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>SHA-256 算法以其 256 位的固定输出长度、强大的抗碰撞性和抗原像性，成为了现代密码学中不可或缺的工具。尽管其内部结构比 MD5 或 SHA-1 更为复杂，但这些复杂性正是其安全性的保证。在需要数据完整性验证、数字签名、密码存储以及区块链等对安全性要求极高的应用中，SHA-256 是一个可靠且广泛推荐的选择。理解其基本原理和正确使用方式，对于构建安全的数字系统至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/d3c7b6c4e397/">https://blog.tbf1211.xx.kg/d3c7b6c4e397/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/">哈希算法</a><a class="post-meta__tags" href="/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/89605e120615/" title="Solr 全文检索服务器详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Solr 全文检索服务器详解</div></div><div class="info-2"><div class="info-item-1"> Solr 是 Apache Lucene 项目的开源搜索平台，它基于 Java 构建，提供强大的全文检索功能、分布式搜索、高亮显示、分面搜索、实时索引等功能。作为一个独立的、企业级的搜索服务器，Solr 允许开发者通过 RESTful HTTP&#x2F;XML&#x2F;JSON 接口来索引、查询数据，使其成为构建高性能搜索应用的理想选择。  核心思想：Solr 是一个基于 Lucene 的企业级搜索服务器，提供 RESTful API，支持全文检索、分布式、高亮、分面、实时索引等功能，通过配置 Schema 和数据源，实现高效、灵活的搜索服务。   一、Solr 简介1.1 什么是 Solr？Solr 是 Apache Lucene 项目的一个子项目。Lucene 是一个高性能的全文检索库，而 Solr 则是在 Lucene 的基础上，提供了一个生产级的搜索服务器，它解决了 Lucene 本身只是一个库，需要大量开发工作包一层才能对外提供服务的问题。Solr 提供了更完整、更易用的搜索解决方案，包括：  RESTful API：通过 HTTP 提供 JSON、XML、CSV...</div></div></div></a><a class="pagination-related" href="/e3c3e34cbfa2/" title="SHA (Secure Hash Algorithm) 系列算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SHA (Secure Hash Algorithm) 系列算法详解</div></div><div class="info-2"><div class="info-item-1"> SHA (Secure Hash Algorithm) 是一系列由美国国家安全局 (NSA) 设计，并由美国国家标准与技术研究院 (NIST) 发布的安全散列算法。与 MD5 类似，SHA 算法家族将任意长度的输入数据（消息）转换为固定长度的小型字节串，即消息摘要 (Message Digest) 或 哈希值 (Hash Value)。SHA 系列算法在密码学和信息安全领域扮演着至关重要的角色，广泛应用于数字签名、数据完整性校验、密码存储和区块链等场景。  核心思想：通过设计精密的数学和逻辑运算，确保输入数据的微小改变会导致输出哈希值的巨大、不可预测的变化（雪崩效应），并使其具有单向性和抗碰撞性，从而提供数据的完整性和认证功能。   一、SHA 算法家族概述SHA 家族包括以下主要算法版本：  SHA-0：1993 年发布，很快发现安全漏洞，被 SHA-1 取代。 SHA-1：1995 年发布，输出 160 位哈希值。曾被广泛使用，但现在已被认为不安全。 SHA-2：2001 年发布，是一个包含多个变体的家族，包括 SHA-224, SHA-256, SHA-384, SHA-...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6ae53edcb727/" title="MD5 (Message-Digest Algorithm 5)算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-18</div><div class="info-item-2">MD5 (Message-Digest Algorithm 5)算法详解</div></div><div class="info-2"><div class="info-item-1"> MD5 (Message Digest Algorithm 5) 是一种广泛使用的加密散列函数，由 Ronald Rivest 于 1991 年设计。它能够将任意长度的输入数据（通常称为“消息”或“原文”）通过哈希运算转换成一个固定长度的 128 位（16 字节）散列值，通常以 32 位十六进制字符串表示。MD5 的设计初衷是用于验证数据完整性，即确保数据在传输或存储过程中未被篡改。  重要安全提示： MD5 算法已被证实存在严重的碰撞漏洞。这意味着可以找到两个不同的输入数据，它们会产生完全相同的 MD5 散列值。因此，MD5 已不再被认为是安全的加密哈希函数，不应再用于需要密码学安全性的场景，如数字签名、密码存储（即使加盐也不推荐）或生成 SSL 证书。 它主要仍用于非安全敏感场景下的文件完整性校验和快速数据比对。   一、引言：哈希函数的基本概念哈希函数 (Hash Function)，也称为散列函数，是一类将任意大小的数据映射到固定大小值的函数。在密码学领域，加密哈希函数 (Cryptographic Hash Function) 需要满足更严格的特性：  确定性 (De...</div></div></div></a><a class="pagination-related" href="/e3c3e34cbfa2/" title="SHA (Secure Hash Algorithm) 系列算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-20</div><div class="info-item-2">SHA (Secure Hash Algorithm) 系列算法详解</div></div><div class="info-2"><div class="info-item-1"> SHA (Secure Hash Algorithm) 是一系列由美国国家安全局 (NSA) 设计，并由美国国家标准与技术研究院 (NIST) 发布的安全散列算法。与 MD5 类似，SHA 算法家族将任意长度的输入数据（消息）转换为固定长度的小型字节串，即消息摘要 (Message Digest) 或 哈希值 (Hash Value)。SHA 系列算法在密码学和信息安全领域扮演着至关重要的角色，广泛应用于数字签名、数据完整性校验、密码存储和区块链等场景。  核心思想：通过设计精密的数学和逻辑运算，确保输入数据的微小改变会导致输出哈希值的巨大、不可预测的变化（雪崩效应），并使其具有单向性和抗碰撞性，从而提供数据的完整性和认证功能。   一、SHA 算法家族概述SHA 家族包括以下主要算法版本：  SHA-0：1993 年发布，很快发现安全漏洞，被 SHA-1 取代。 SHA-1：1995 年发布，输出 160 位哈希值。曾被广泛使用，但现在已被认为不安全。 SHA-2：2001 年发布，是一个包含多个变体的家族，包括 SHA-224, SHA-256, SHA-384, SHA-...</div></div></div></a><a class="pagination-related" href="/6bc2a8397773/" title="AES (Advanced Encryption Standard) 加密算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-15</div><div class="info-item-2">AES (Advanced Encryption Standard) 加密算法详解</div></div><div class="info-2"><div class="info-item-1"> AES (Advanced Encryption Standard)，即高级加密标准，是目前应用最广泛的对称密钥分组加密算法。它于 2001 年由美国国家标准与技术研究院 (NIST) 发布，取代了 DES (Data Encryption Standard) 成为联邦政府推荐的加密标准。AES 的设计基于替代-置换网络 (Substitution-Permutation Network, SPN) 结构，具有高效、安全和易于实现的特点，被广泛应用于网络通信、数据存储、文件加密等各种场景。  一、引言：对称加密的王者在现代密码学中，对称加密算法因其加解密速度快而常用于对大量数据进行加密。AES 是其中的翘楚，被认为是当今最安全的对称加密算法之一。  对称加密 (Symmetric Encryption)：使用相同的密钥进行加密和解密。优点是效率高，适合加密大量数据；缺点是密钥分发和管理复杂。 分组密码 (Block Cipher)：将明文数据分成固定大小的块（例如 AES 是 128 位），对每个块独立进行加密。  AES 具有以下关键特性：  块大小 (Block Size)...</div></div></div></a><a class="pagination-related" href="/4ef6c4138b39/" title="ChaCha20 流密码加密算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-16</div><div class="info-item-2">ChaCha20 流密码加密算法详解</div></div><div class="info-2"><div class="info-item-1"> ChaCha20 是一种高性能、高安全性的对称流密码算法，由 Google 的 Dan Bernstein 于 2008 年设计。它是 Salsa20 算法的改进版本，旨在提供比其前辈更高的抗攻击能力和更简洁的实现。ChaCha20 因其卓越的性能和安全性，已成为 TLS 协议中的重要组成部分，特别是在移动设备和低功耗环境中，替代了传统的 AES-GCM。  核心思想：通过一个密钥 (Key) 和一个随机数 (Nonce) 生成一个无限长的伪随机密钥流，然后将密钥流与明文进行异或 (XOR) 操作得到密文。解密时，使用相同的密钥和随机数生成相同的密钥流，再与密文异或即可还原明文。   一、流密码 (Stream Cipher) 简介流密码是一种对称加密算法，它将明文的每个比特或每个字节与一个伪随机密钥流的对应比特或字节进行组合（通常是异或）来生成密文。 1.1 与分组密码 (Block Cipher) 的区别   特性 流密码 (Stream Cipher) 分组密码 (Block Cipher)    工作方式 逐位&#x2F;逐字节加密 将明文分成固定大小的块，逐块加密  ...</div></div></div></a><a class="pagination-related" href="/75b66b0f0910/" title="RSA (Rivest–Shamir–Adleman) 加密算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-18</div><div class="info-item-2">RSA (Rivest–Shamir–Adleman) 加密算法详解</div></div><div class="info-2"><div class="info-item-1"> RSA 是一种非对称加密算法，由 Ron Rivest、Adi Shamir 和 Leonard Adleman 于 1977 年提出，并以他们姓氏的首字母命名。它是目前应用最广泛的公钥密码算法之一，广泛用于数据加密、数字签名以及密钥交换等领域。RSA 的安全性基于大整数分解的困难性，即给定两个大素数 p 和 q，计算它们的乘积 n = p * q 是容易的，但给定 n 却很难反向分解出 p 和 q。  一、引言：公钥密码学的基石在密码学领域，我们通常将加密算法分为两大类：对称加密和非对称加密。  对称加密 (Symmetric Encryption)：使用相同的密钥进行加密和解密。优点是速度快，但密钥分发和管理是其主要挑战。 非对称加密 (Asymmetric Encryption &#x2F; Public-key Cryptography)：使用一对密钥，即一个公钥 (Public Key) 和一个私钥 (Private Key)。公钥可以公开，用于加密或验证签名；私钥必须严格保密，用于解密或生成签名。  RSA 算法是公钥密码学的代表，解决了对称加密中密钥分发的难题。其...</div></div></div></a><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-03</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">359</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">210</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">75</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8A%A0%E5%AF%86%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">一、加密哈希函数的基本特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SHA-256-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">二、SHA-256 算法原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A1%AB%E5%85%85-Padding"><span class="toc-text">2.1 填充 (Padding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%99%84%E5%8A%A0%E9%95%BF%E5%BA%A6-Appending-Length"><span class="toc-text">2.2 附加长度 (Appending Length)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%93%88%E5%B8%8C%E5%80%BC-Initialize-Hash-Values-IVs"><span class="toc-text">2.3 初始化哈希值 (Initialize Hash Values - IVs)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF-Message-Processing-Loop"><span class="toc-text">2.4 消息处理循环 (Message Processing Loop)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%B6%88%E6%81%AF%E6%89%A9%E5%B1%95-Message-Schedule"><span class="toc-text">2.4.1 消息扩展 (Message Schedule)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0%E4%B8%BB%E5%BE%AA%E7%8E%AF-64-%E8%BD%AE"><span class="toc-text">2.4.2 压缩函数主循环 (64 轮)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%9B%B4%E6%96%B0%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-text">2.4.3 更新哈希值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%BE%93%E5%87%BA-Output"><span class="toc-text">2.5 输出 (Output)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SHA-256-%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-text">三、SHA-256 的安全性与应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">四、Go 语言实现示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bun.js 深度解析：冷启动与边缘函数优化"/></a><div class="content"><a class="title" href="/28f993be5cfe/" title="Bun.js 深度解析：冷启动与边缘函数优化">Bun.js 深度解析：冷启动与边缘函数优化</a><time datetime="2025-12-07T22:24:00.000Z" title="发表于 2025-12-08 06:24:00">2025-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go Jaeger 深度解析：分布式追踪实践"/></a><div class="content"><a class="title" href="/bcbe0f78ef1d/" title="Go Jaeger 深度解析：分布式追踪实践">Go Jaeger 深度解析：分布式追踪实践</a><time datetime="2025-12-04T22:24:00.000Z" title="发表于 2025-12-05 06:24:00">2025-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/15920229f914/" title="Supabase 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supabase 深度解析"/></a><div class="content"><a class="title" href="/15920229f914/" title="Supabase 深度解析">Supabase 深度解析</a><time datetime="2025-12-02T22:24:00.000Z" title="发表于 2025-12-03 06:24:00">2025-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1ae20d2726d8/" title="MiniRTC 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MiniRTC 详解"/></a><div class="content"><a class="title" href="/1ae20d2726d8/" title="MiniRTC 详解">MiniRTC 详解</a><time datetime="2025-11-28T22:24:00.000Z" title="发表于 2025-11-29 06:24:00">2025-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/be24ef88e59a/" title="WebRTC 技术详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebRTC 技术详解"/></a><div class="content"><a class="title" href="/be24ef88e59a/" title="WebRTC 技术详解">WebRTC 技术详解</a><time datetime="2025-11-27T22:24:00.000Z" title="发表于 2025-11-28 06:24:00">2025-11-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-32.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>