<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Golang 中，内置的 map 类型不是并发安全的。当多个 goroutine 同时对 map 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 map，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 sync.Mutex 保护 map、使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2e2570e368f1/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在 Golang 中，内置的 map 类型不是并发安全的。当多个 goroutine 同时对 map 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 map，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 sync.Mutex 保护 map、使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg">
<meta property="article:published_time" content="2025-12-31T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-28T09:37:21.890Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="goroutine">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比",
  "url": "https://blog.tbf1211.xx.kg/2e2570e368f1/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg",
  "datePublished": "2025-12-31T22:24:00.000Z",
  "dateModified": "2026-02-28T09:37:21.890Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2e2570e368f1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-14.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-12-31T22:24:00.000Z" title="发表于 2026-01-01 06:24:00">2026-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/goroutine/">goroutine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在 Golang 中，内置的 <code>map</code> 类型不是并发安全的。当多个 goroutine 同时对 <code>map</code> 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 <code>map</code>，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 <code>sync.Mutex</code> 保护 <code>map</code>、使用 <code>sync.RWMutex</code> 保护 <code>map</code>，以及 Go 1.9 引入的 <code>sync.Map</code>，并对它们的特点、适用场景和性能进行对比分析。</p>
</blockquote>
<div class="note info flat"><p><strong>核心问题</strong>：Go 内置 <code>map</code> 非并发安全。<br><strong>核心解决方案</strong>：</p>
<ol>
<li><strong><code>sync.Mutex</code></strong>：最简单粗暴，读写都加排他锁。</li>
<li><strong><code>sync.RWMutex</code></strong>：读写分离锁，允许多个读操作并行，写操作独占。</li>
<li><strong><code>sync.Map</code></strong>：专为读多写少、键不冲突或键值对持续增长的场景优化，内置无锁或乐观锁机制。</li>
</ol>
</div>

<hr>
<h2 id="一、Go-内置-map-的并发问题"><a href="#一、Go-内置-map-的并发问题" class="headerlink" title="一、Go 内置 map 的并发问题"></a>一、Go 内置 <code>map</code> 的并发问题</h2><p>Go 语言设计者有意将内置 <code>map</code> 设计为非并发安全的，主要出于以下考虑：</p>
<ol>
<li><strong>性能</strong>：为了避免在每次 <code>map</code> 操作时都承担锁的开销，从而在单线程场景下达到最佳性能。</li>
<li><strong>灵活性</strong>：让开发者根据具体并发需求选择最合适的同步策略。</li>
</ol>
<p>当多个 goroutine 同时修改 <code>map</code> (包括插入、删除或修改值) 时，或者一个 goroutine 修改而另一个 goroutine 读取时，Go 运行时会检测到竞争条件并抛出 <code>fatal error: concurrent map writes</code> 错误，导致程序崩溃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m[i] = i <span class="comment">// 多个 goroutine 同时写入</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// go func() &#123;</span></span><br><span class="line">	<span class="comment">// 	for &#123;</span></span><br><span class="line">	<span class="comment">// 		_ = m[0] // 一个 goroutine 读取，另一个写入也会崩溃</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// &#125;()</span></span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Map size:&quot;</span>, <span class="built_in">len</span>(m)) <span class="comment">// 多数情况下会崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码几乎必然导致 <code>fatal error: concurrent map writes</code>。</p>
<h2 id="二、使用-sync-Mutex-保护-map"><a href="#二、使用-sync-Mutex-保护-map" class="headerlink" title="二、使用 sync.Mutex 保护 map"></a>二、使用 <code>sync.Mutex</code> 保护 <code>map</code></h2><p><code>sync.Mutex</code> 是 Go 语言提供的最基本的互斥锁。它提供排他性的访问，任何时候只有一个 goroutine 可以持有锁并访问受保护的资源。</p>
<h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>当使用 <code>sync.Mutex</code> 保护 <code>map</code> 时，无论是读取还是写入操作，都需要先获取锁，操作完成后再释放锁。这确保了在任何给定时刻，只有一个 goroutine 在访问 <code>map</code>，从而避免了竞争条件。</p>
<h3 id="2-2-实现示例"><a href="#2-2-实现示例" class="headerlink" title="2.2 实现示例"></a>2.2 实现示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MutexMap 是一个使用 sync.Mutex 保护的并发安全 map</span></span><br><span class="line"><span class="keyword">type</span> MutexMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   sync.Mutex</span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMutexMap 创建一个新的 MutexMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutexMap</span><span class="params">()</span></span> *MutexMap &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MutexMap&#123;</span><br><span class="line">		data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store 将键值对存储到 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Store(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock() <span class="comment">// 确保释放写锁</span></span><br><span class="line">	m.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load 从 map 中加载值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Load(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.Lock() <span class="comment">// 获取读锁 (这里由于 Mutex 是排他锁，读也需要获取排他锁)</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	val, ok := m.data[key]</span><br><span class="line">	<span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 从 map 中删除键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Delete(key <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="built_in">delete</span>(m.data, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range 遍历 map 中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m.data &#123;</span><br><span class="line">		<span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := NewMutexMap()</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发写入</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Store(i, i*<span class="number">2</span>)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;MutexMap after writes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			val, ok := m.Load(i)</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">// fmt.Printf(&quot;Key %d, Value %d\n&quot;, i, val)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发删除</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Delete(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;MutexMap after deletes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Range 遍历</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续遍历</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;MutexMap elements after range:&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>简单易懂</strong>：实现逻辑直接，容易理解和使用。</li>
<li><strong>适用于所有读写比例</strong>：无论是读多写少、写多读少还是读写均衡，它都能保证正确性。</li>
<li><strong>通用性强</strong>：不仅可以保护 <code>map</code>，还可以保护任何共享数据。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>性能瓶颈</strong>：当并发读操作很多时，<code>sync.Mutex</code> 会成为性能瓶颈。因为读操作之间也需要排他锁，导致所有读操作都串行化执行，无法利用多核 CPU 的优势。</li>
</ul>
</li>
</ul>
<h2 id="三、使用-sync-RWMutex-保护-map"><a href="#三、使用-sync-RWMutex-保护-map" class="headerlink" title="三、使用 sync.RWMutex 保护 map"></a>三、使用 <code>sync.RWMutex</code> 保护 <code>map</code></h2><p><code>sync.RWMutex</code> 是读写互斥锁。它允许多个读者 (Reader) 同时持有读锁，但写者 (Writer) 必须独占写锁。当写者持有写锁时，任何读者或写者都无法获取锁；当读者持有读锁时，其他读者可以继续获取读锁，但写者必须等待所有读者释放读锁后才能获取写锁。</p>
<h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p><code>sync.RWMutex</code> 的设计思想是“读读共享，读写互斥，写写互斥”。</p>
<ul>
<li><strong>读操作</strong>：使用 <code>RLock()</code> 和 <code>RUnlock()</code>。多个 goroutine 可以同时获取读锁进行读取。</li>
<li><strong>写操作</strong>：使用 <code>Lock()</code> 和 <code>Unlock()</code>。写锁是排他性的，在写入期间，任何其他读写操作都会被阻塞。</li>
</ul>
<h3 id="3-2-实现示例"><a href="#3-2-实现示例" class="headerlink" title="3.2 实现示例"></a>3.2 实现示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RWMutexMap 是一个使用 sync.RWMutex 保护的并发安全 map</span></span><br><span class="line"><span class="keyword">type</span> RWMutexMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   sync.RWMutex</span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRWMutexMap 创建一个新的 RWMutexMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRWMutexMap</span><span class="params">()</span></span> *RWMutexMap &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RWMutexMap&#123;</span><br><span class="line">		data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store 将键值对存储到 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Store(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock() <span class="comment">// 确保释放写锁</span></span><br><span class="line">	m.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load 从 map 中加载值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Load(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.RLock() <span class="comment">// 获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.RUnlock() <span class="comment">// 确保释放读锁</span></span><br><span class="line">	val, ok := m.data[key]</span><br><span class="line">	<span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 从 map 中删除键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Delete(key <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="built_in">delete</span>(m.data, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range 遍历 map 中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.RLock() <span class="comment">// 遍历通常视为读操作，可以获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.RUnlock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m.data &#123;</span><br><span class="line">		<span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := NewRWMutexMap()</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发写入</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Store(i, i*<span class="number">2</span>)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;RWMutexMap after writes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发读取 (多个 goroutine 可以并行读取)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123; <span class="comment">// 增加读取 goroutine 数量，模拟读多场景</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			val, ok := m.Load(i % <span class="number">1000</span>) <span class="comment">// 确保读取已存在的键</span></span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">// fmt.Printf(&quot;Key %d, Value %d\n&quot;, i % 1000, val)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发删除</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Delete(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;RWMutexMap after deletes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Range 遍历</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;RWMutexMap elements after range:&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>读性能提升</strong>：在读多写少的场景下，多个并发读操作可以并行执行，显著优于 <code>sync.Mutex</code>。</li>
<li><strong>相对简单</strong>：比 <code>sync.Map</code> 更容易理解和实现。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>写操作仍是瓶颈</strong>：写操作仍然需要独占锁，并且在有大量读者持有读锁时，写者可能会被长时间阻塞（写饥饿）。</li>
<li><strong>开销略高于 <code>sync.Mutex</code></strong>：在读写均衡或写多的场景下，<code>sync.RWMutex</code> 的管理开销可能略高于 <code>sync.Mutex</code>。</li>
</ul>
</li>
</ul>
<h2 id="四、使用-sync-Map"><a href="#四、使用-sync-Map" class="headerlink" title="四、使用 sync.Map"></a>四、使用 <code>sync.Map</code></h2><p><code>sync.Map</code> 是 Go 1.9 引入的开箱即用的并发安全 <code>map</code>。它不是使用传统的互斥锁来保护底层 <code>map</code>，而是通过一种更复杂的无锁或乐观锁机制来优化某些特定场景下的性能。</p>
<h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p><code>sync.Map</code> 内部维护了两个 <code>map</code>：</p>
<ol>
<li><code>read</code>：一个只读的 <code>map</code>，用于高效的读取操作。大多数读取操作会直接访问这个 <code>map</code>，通常不需要加锁。</li>
<li><code>dirty</code>：一个可写的 <code>map</code>，包含了所有最新的写入和更新。当 <code>read</code> map 中不存在某个键时，会回退到 <code>dirty</code> map 中查找。</li>
</ol>
<p>其核心优化策略是：</p>
<ul>
<li><strong>读操作优化</strong>：首次读取时，如果键在 <code>read</code> 中存在，则不需要任何锁。如果不在 <code>read</code> 中，会回退到 <code>dirty</code> 中查找，此时可能需要加锁。</li>
<li><strong>写操作优化</strong>：新的写入或更新会首先写入 <code>dirty</code> map。当 <code>read</code> map 上的查找失败次数达到阈值，或者 <code>dirty</code> map 变得太大时，<code>dirty</code> map 的内容会被提升到 <code>read</code> map。</li>
<li><strong>删除优化</strong>：删除操作会标记 <code>read</code> map 中的条目为“已删除”，并在 <code>dirty</code> map 中执行实际删除。</li>
</ul>
<h3 id="4-2-实现示例"><a href="#4-2-实现示例" class="headerlink" title="4.2 实现示例"></a>4.2 实现示例</h3><p><code>sync.Map</code> 没有像内置 <code>map</code> 那样直接的 <code>len()</code> 方法，它提供 <code>Store</code>, <code>Load</code>, <code>Delete</code>, <code>Range</code> 等方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map <span class="comment">// 直接声明使用</span></span><br><span class="line"></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发写入</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Store(i, i*<span class="number">2</span>) <span class="comment">// Store 方法</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;sync.Map after writes.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			val, ok := m.Load(i % <span class="number">1000</span>) <span class="comment">// Load 方法</span></span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">// fmt.Printf(&quot;Key %d, Value %v\n&quot;, i % 1000, val)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发删除</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Delete(i) <span class="comment">// Delete 方法</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;sync.Map after deletes.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Range 遍历 (需要传入一个处理函数)</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123; <span class="comment">// key 和 value 都是 interface&#123;&#125; 类型</span></span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 返回 true 继续遍历，返回 false 停止遍历</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;sync.Map elements after range:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LoadOrStore 示例</span></span><br><span class="line">	val, loaded := m.LoadOrStore(<span class="number">1001</span>, <span class="number">10010</span>) <span class="comment">// 如果键 1001 不存在则存储，并返回存储的值和 false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;LoadOrStore 1001: value=%v, loaded=%v\n&quot;</span>, val, loaded)</span><br><span class="line"></span><br><span class="line">	val, loaded = m.LoadOrStore(<span class="number">1001</span>, <span class="number">20020</span>) <span class="comment">// 如果键 1001 存在，则返回当前值和 true，不存储新值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;LoadOrStore 1001 again: value=%v, loaded=%v\n&quot;</span>, val, loaded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-优缺点"><a href="#4-3-优缺点" class="headerlink" title="4.3 优缺点"></a>4.3 优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>读性能极高</strong>：在读多写少且键稳定 (不频繁删除或更新) 的场景下，性能远超 <code>sync.RWMutex</code>。因为它大多数读操作是无锁的。</li>
<li><strong>无需手动加锁</strong>：开箱即用，代码简洁。</li>
<li><strong>针对特定场景优化</strong>：特别适用于“键只写入一次或很少写入，但会被频繁读取”的缓存场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>不适用于所有场景</strong>：<ul>
<li><strong>写多读少或读写均衡</strong>：性能可能不如 <code>sync.Mutex</code> 或 <code>sync.RWMutex</code>。频繁的写入会导致 <code>dirty</code> map 频繁升级到 <code>read</code> map，带来额外开销。</li>
<li><strong>键频繁删除或更新</strong>：会导致 <code>read</code> 和 <code>dirty</code> map 之间状态同步的复杂性增加，性能下降。</li>
</ul>
</li>
<li><strong><code>interface&#123;&#125;</code> 类型开销</strong>：<code>Store</code>, <code>Load</code> 方法接受和返回 <code>interface&#123;&#125;</code> 类型，需要进行类型断言，可能带来少量的运行时开销和潜在的类型错误。</li>
<li><strong>没有 <code>Len()</code> 方法</strong>：获取元素数量需要遍历 <code>Range</code> 方法，效率较低。</li>
<li><strong>不保证遍历顺序</strong>：<code>Range</code> 方法遍历顺序不确定。</li>
</ul>
</li>
</ul>
<h2 id="五、性能对比与适用场景"><a href="#五、性能对比与适用场景" class="headerlink" title="五、性能对比与适用场景"></a>五、性能对比与适用场景</h2><table>
<thead>
<tr>
<th align="left">特性&#x2F;解决方案</th>
<th align="left"><code>sync.Mutex</code> with <code>map</code></th>
<th align="left"><code>sync.RWMutex</code> with <code>map</code></th>
<th align="left"><code>sync.Map</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>并发读</strong></td>
<td align="left">串行</td>
<td align="left">并行 (共享读锁)</td>
<td align="left">大多数情况无锁，极快</td>
</tr>
<tr>
<td align="left"><strong>并发写</strong></td>
<td align="left">串行</td>
<td align="left">串行</td>
<td align="left">内部优化，某些情况较快</td>
</tr>
<tr>
<td align="left"><strong>读写均衡</strong></td>
<td align="left">一般</td>
<td align="left">较好</td>
<td align="left">一般，可能差于 <code>Mutex</code></td>
</tr>
<tr>
<td align="left"><strong>读多写少</strong></td>
<td align="left">较差</td>
<td align="left">优秀</td>
<td align="left"><strong>最优</strong> (键不常删除)</td>
</tr>
<tr>
<td align="left"><strong>写多读少</strong></td>
<td align="left">较好</td>
<td align="left">一般</td>
<td align="left">较差</td>
</tr>
<tr>
<td align="left"><strong>API 复杂度</strong></td>
<td align="left">中</td>
<td align="left">中</td>
<td align="left">简单 (开箱即用)</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">良好 (自定义结构体)</td>
<td align="left">良好 (自定义结构体)</td>
<td align="left">弱 (<code>interface&#123;&#125;</code>)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">通用，简单粗暴</td>
<td align="left">读远多于写，需要高并发读</td>
<td align="left">键稳定，读远多于写的缓存</td>
</tr>
</tbody></table>
<h3 id="5-1-何时选择哪种方案？"><a href="#5-1-何时选择哪种方案？" class="headerlink" title="5.1 何时选择哪种方案？"></a>5.1 何时选择哪种方案？</h3><ol>
<li><p><strong>首选 <code>sync.Mutex</code></strong>：</p>
<ul>
<li><strong>简单场景</strong>：对性能要求不高，或者读写操作都很少的场景。</li>
<li><strong>读写均衡</strong>：当读写操作频率大致相同，或者写操作相对较多时，<code>Mutex</code> 的性能可能与 <code>RWMutex</code> 相当，甚至略优于 <code>sync.Map</code>。</li>
</ul>
</li>
<li><p><strong>考虑 <code>sync.RWMutex</code></strong>：</p>
<ul>
<li><strong>读多写少</strong>：当读操作频率远高于写操作时，<code>RWMutex</code> 能显著提高并发读的性能。这是最常见的优化场景之一。</li>
</ul>
</li>
<li><p><strong>慎用 <code>sync.Map</code></strong>：</p>
<ul>
<li><strong>键稳定且读远多于写 (Append-Only 或类似缓存)</strong>：如果你的 <code>map</code> 倾向于只增加新的键值对，或者现有键值对不常删除、更新，且有大量的并发读取，那么 <code>sync.Map</code> 能够提供最佳性能。</li>
<li><strong>避免在以下场景使用 <code>sync.Map</code></strong>：<ul>
<li><strong>写多读少</strong>：<code>dirty</code> map 的频繁提升会带来不小的开销。</li>
<li><strong>键频繁删除&#x2F;更新</strong>：<code>sync.Map</code> 对删除和更新的优化相对复杂，可能导致性能下降。</li>
<li><strong>需要 <code>Len()</code> 方法或遍历顺序</strong>：<code>sync.Map</code> 不直接支持这些功能。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>在 Golang 中实现并发安全的 <code>map</code>，并非只有一种“最佳”方案，而是需要根据具体的应用场景和读写模式来选择最合适的同步策略。</p>
<ul>
<li><strong><code>sync.Mutex</code></strong> 提供了最简单、最通用的解决方案，但在高并发读场景下性能不佳。</li>
<li><strong><code>sync.RWMutex</code></strong> 在读多写少的场景下表现出色，允许多个并发读，但在写操作时仍有阻塞。</li>
<li><strong><code>sync.Map</code></strong> 是一种为特定场景（读多写少且键稳定）高度优化的特殊 <code>map</code>，能提供近乎无锁的读取性能，但在其他场景下可能表现不佳，并且存在 <code>interface&#123;&#125;</code> 类型和缺乏 <code>Len()</code> 方法的限制。</li>
</ul>
<p>理解它们的内部机制和优缺点，是编写高效、健壮 Go 并发程序的关键。在选择之前，最好能对应用的读写模式进行预估或测试，以做出明智的决策。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2e2570e368f1/">https://blog.tbf1211.xx.kg/2e2570e368f1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/goroutine/">goroutine</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang sqlc 框架详解</div></div><div class="info-2"><div class="info-item-1"> sqlc 是一个SQL 编译器 (SQL Compiler)，它能够根据用户定义的 SQL 查询和数据库 Schema 自动生成类型安全 (type-safe) 的 Go 代码。与传统的 ORM (Object-Relational Mapping) 工具不同，sqlc 的核心理念是“写 SQL，生成 Go (Write SQL, Get Go)”。开发者专注于编写原生的 SQL 查询，sqlc 则负责将其转换为易于在 Go 应用程序中使用的、无反射、高性能的 API。  核心思想：保持 SQL 源码作为事实的唯一来源，并通过代码生成器将其无缝集成到 Go 代码中，实现类型安全和高效的数据库操作。 它不尝试将 SQL 抽象化，而是将 SQL 语句转换为可直接调用的 Go 函数。    一、为什么选择 sqlc？在 Golang 中进行数据库操作，开发者通常面临几种选择：  直接使用 database/sql 库：最底层、最灵活，但需要手动处理行扫描、错误检查、参数绑定等，代码量大且容易出错。 使用传统 ORM (如 GORM, XORM)：提供了高层次的抽象，通过 Go 结构体...</div></div></div></a><a class="pagination-related" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">如何防止 Golang Goroutine 泄漏</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是轻量级的并发执行单元，相比操作系统线程，其创建和销毁的开销极小。然而，这并不意味着我们可以随意创建 Goroutine 而不进行管理。当一个 Goroutine 启动后，如果它无法正常退出，就会一直占用内存和 CPU 资源，这种现象称为 Goroutine 泄漏 (Goroutine Leak)。Goroutine 泄漏会导致程序内存持续增长，最终耗尽系统资源，甚至引发 OOM (Out Of Memory) 错误，严重影响程序的稳定性和性能。  核心思想：Goroutine 泄漏的本质是，一个 Goroutine 完成了其预期的任务，但由于某种原因无法终止或被回收，持续占用资源。防止泄漏的关键在于确保每个 Goroutine 都有明确的退出条件和机制。   一、什么是 Goroutine 泄漏？Goroutine 泄漏是指 Goroutine 在其生命周期结束后未能被 Go 运行时回收，从而持续驻留在内存中。一个泄漏的 Goroutine 会一直占用：  栈内存：每个 Goroutine 都会分配栈空间 (初始 2KB 并动态伸缩)。大...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/9ed85cc18e8a/" title="CSP并发模型详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-16</div><div class="info-item-2">CSP并发模型详解</div></div><div class="info-2"><div class="info-item-1">在构建现代高性能、可伸缩的软件系统时，并发编程是不可或缺的。众多并发模型中，Communicating Sequential Processes (CSP) 以其独特的通信机制和强大的概念简洁性，在业界，特别是在 Go 语言中，获得了广泛应用。  Communicating Sequential Processes (CSP)，即通信顺序进程，是由英国计算机科学家 Tony Hoare 于 1978 年提出的一种形式化语言和数学理论。CSP 的核心思想是，独立运行的顺序进程通过消息传递进行通信和同步，而不是通过共享内存来协作。 这种模型极大地简化了并发程序的推理和安全性，避免了传统共享内存模型中常见的竞态条件（Race Condition）和死锁（Deadlock）等问题。  核心原则：并发实体不通过共享内存进行通信；相反，它们通过通信来共享内存。 （”Do not communicate by sharing memory; instead, share memory by communicating.” - Go Proverb）    一、并发与并行：基本概念澄清在深入 C...</div></div></div></a><a class="pagination-related" href="/6a755772301d/" title="Golang errgroup.Group 并发模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-04</div><div class="info-item-2">Golang errgroup.Group 并发模式详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，sync/errgroup 包提供了一个 Group 类型，它是对 sync.WaitGroup 和 context 包的封装，旨在更优雅地处理并发 goroutine 组的错误和取消。它使得在多个 goroutine 中执行任务，并在任何一个 goroutine 返回错误时，能够及时通知并取消其他 goroutine，同时等待所有 goroutine 完成变得更简单。  核心思想：errgroup.Group 允许你并行执行一组任务。如果其中任何一个任务失败，它会自动取消所有正在运行的任务，并聚合它们的错误。它简化了并行任务的启动、context 信号传递、错误收集和等待所有任务完成的逻辑。   一、为什么需要 errgroup.Group？在 Go 语言中进行并发编程时，经常会遇到以下场景：  启动多个 goroutine 处理子任务：一个大任务可能需要分解成多个独立的子任务，并行的由不同的 goroutine 执行。 等待所有 goroutine 完成：主 goroutine 需要知道所有子任务都已完成才能继续或返回。 处理子任务的错误：任何一个子任务的...</div></div></div></a><a class="pagination-related" href="/98c39f8e2307/" title="Go 语言协程设计与调度原理"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-05</div><div class="info-item-2">Go 语言协程设计与调度原理</div></div><div class="info-2"><div class="info-item-1"> Go 语言以其强大的并发特性而闻名，其核心是轻量级协程 (Goroutine) 和高效的调度器。理解 Goroutine 的设计理念以及 Go 运行时如何调度这些协程，对于编写高性能、高并发的 Go 应用程序至关重要。本文将深入探讨 Go 语言协程的设计哲学，并详细解析其背后支撑的 GMP 调度模型。  核心概念：  Goroutine：Go 语言的轻量级并发单元，用户态线程。 GMP 模型：Go 语言运行时调度 Goroutine 的核心模型，由 G (Goroutine)、M (Machine&#x2F;Thread)、P (Processor) 三要素组成。     一、Go 语言协程 (Goroutine) 的设计哲学传统的并发编程通常基于操作系统线程。虽然线程提供了并发能力，但它们也带来了不小的开销：  创建&#x2F;销毁开销大：创建和销毁线程需要向操作系统内核申请资源，涉及系统调用，开销较大。 上下文切换开销大：线程的上下文切换由操作系统内核完成，需要保存和恢复大量的寄存器信息，开销较大。 内存消耗大：每个线程通常需要 MB 级别的栈空间，大量线程会导致内存消耗巨...</div></div></div></a><a class="pagination-related" href="/9f5a2c0e7ea7/" title="Goroutine 相比 OS 线程，为什么能规模化？"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">Goroutine 相比 OS 线程，为什么能规模化？</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是其并发模型的核心。与传统的操作系统 (OS) 线程相比，Goroutine 展现出了惊人的规模化能力，使得 Go 程序能够轻松地并发处理成千上万甚至数百万的任务。这种规模化的差异并非偶然，而是由 Goroutine 独特的设计哲学和 Go 运行时（runtime）的智能调度机制所决定的。  核心思想：Goroutine 之所以能规模化，是因为它是一种轻量级的用户态协程，由 Go 运行时在少数 OS 线程上进行多路复用和调度，从而避免了 OS 线程的高开销和上下文切换代价。   一、Goroutine 与 OS 线程的本质区别在深入探讨为什么 Goroutine 能够规模化之前，我们需要理解它与 OS 线程之间的根本不同。 1.1 OS 线程 (Operating System Thread) 内核态实体：OS 线程是由操作系统内核调度的执行单元。每次创建、销毁或切换线程都需要进行系统调用（进入内核态），这会带来较大的开销。 内存开销大：每个 OS 线程通常会分配一个固定大小的栈（例如，Linux 上默认 8MB），即使实际只使用了很小一部...</div></div></div></a><a class="pagination-related" href="/7642665c9bbb/" title="Golang context 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-03</div><div class="info-item-2">Golang context 详解</div></div><div class="info-2"><div class="info-item-1"> context 包 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递请求范围的数据 (request-scoped data)、取消信号 (cancellation signals) 和截止时间 (deadlines) 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，context 包是管理 Goroutine 生命周期和避免资源泄露的基石。  核心思想：context.Context 接口允许在 Goroutine 树中安全地传递控制流信息。其核心价值在于实现对计算任务的统一取消、超时控制和值传递，从而提升程序的健壮性和资源利用效率。   一、context 包的必要性在 Go 语言中，Goroutine 是轻量级并发的基础。然而，当应用程序的并发逻辑变得复杂时，以下问题会变得突出：  并发操作的取消：当一个上游操作（如用户取消请求）不再需要其下游的所有并发子任务时，如何有效地通知并停止这些子任务，避免不必要的计算和资源消耗？ 操作超时控制：如何在复杂的请求链中，为整个链条或其中某个环节设置统一的...</div></div></div></a><a class="pagination-related" href="/7601ab41dda6/" title="Go语言并发与并行详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-23</div><div class="info-item-2">Go语言并发与并行详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言（Golang） 被设计为一门天然支持并发的语言，其并发模型是基于 CSP (Communicating Sequential Processes) 理论的实现。Go 语言通过轻量级的 Goroutine (协程) 和原生的 Channel (管道) 机制，极大地简化了并发编程的复杂性，使得开发者能够更容易地编写出高并发、高性能的应用程序。  核心思想：不要通过共享内存来通信；相反，通过通信来共享内存。 这是 Go 并发哲学中的核心原则。   一、并发 (Concurrency) 与并行 (Parallelism)在深入 Go 语言的并发机制之前，理解并发与并行的区别至关重要。 1.1 并发 (Concurrency) 定义：并发是指系统能够同时处理多个任务的能力。这些任务不一定在同一时刻运行，它们可能在单个 CPU 核心上通过时间片轮转的方式快速切换执行，给人一种“同时进行”的错觉。 特性： 处理多个任务：关注如何设计程序来处理事件流，即使只有一个处理器。 任务切换：通过快速切换执行上下文来模拟同时执行。 目的：提高程序的吞吐量和响应速度。   类比：一个厨师可以在...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Go-%E5%86%85%E7%BD%AE-map-%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">一、Go 内置 map 的并发问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8-sync-Mutex-%E4%BF%9D%E6%8A%A4-map"><span class="toc-text">二、使用 sync.Mutex 保护 map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8E%9F%E7%90%86"><span class="toc-text">2.1 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.2 实现示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.3 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8-sync-RWMutex-%E4%BF%9D%E6%8A%A4-map"><span class="toc-text">三、使用 sync.RWMutex 保护 map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8E%9F%E7%90%86"><span class="toc-text">3.1 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.2 实现示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3.3 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8-sync-Map"><span class="toc-text">四、使用 sync.Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.2 实现示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4.3 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、性能对比与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BD%95%E6%97%B6%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">5.1 何时选择哪种方案？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d819fc26cbc7/" title="共识算法详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="共识算法详解"/></a><div class="content"><a class="title" href="/d819fc26cbc7/" title="共识算法详解">共识算法详解</a><time datetime="2026-02-19T22:24:00.000Z" title="发表于 2026-02-20 06:24:00">2026-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1c5cbb334a2a/" title="计算机中熵的详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机中熵的详解"/></a><div class="content"><a class="title" href="/1c5cbb334a2a/" title="计算机中熵的详解">计算机中熵的详解</a><time datetime="2026-02-17T22:24:00.000Z" title="发表于 2026-02-18 06:24:00">2026-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/9ed85cc18e8a/" title="CSP并发模型详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSP并发模型详解"/></a><div class="content"><a class="title" href="/9ed85cc18e8a/" title="CSP并发模型详解">CSP并发模型详解</a><time datetime="2026-02-15T22:24:00.000Z" title="发表于 2026-02-16 06:24:00">2026-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0d177e0002e6/" title="程序错误处理详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序错误处理详解"/></a><div class="content"><a class="title" href="/0d177e0002e6/" title="程序错误处理详解">程序错误处理详解</a><time datetime="2026-02-13T22:24:00.000Z" title="发表于 2026-02-14 06:24:00">2026-02-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-14.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>