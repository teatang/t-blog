<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Golang 中，内置的 map 类型不是并发安全的。当多个 goroutine 同时对 map 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 map，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 sync.Mutex 保护 map、使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2e2570e368f1/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在 Golang 中，内置的 map 类型不是并发安全的。当多个 goroutine 同时对 map 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 map，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 sync.Mutex 保护 map、使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg">
<meta property="article:published_time" content="2025-12-31T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-19T01:57:35.899Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="goroutine">
<meta property="article:tag" content="2026">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比",
  "url": "https://blog.tbf1211.xx.kg/2e2570e368f1/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-18.jpg",
  "datePublished": "2025-12-31T22:24:00.000Z",
  "dateModified": "2026-01-19T01:57:35.899Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2e2570e368f1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">500</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-18.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-12-31T22:24:00.000Z" title="发表于 2026-01-01 06:24:00">2026-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/goroutine/">goroutine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在 Golang 中，内置的 <code>map</code> 类型不是并发安全的。当多个 goroutine 同时对 <code>map</code> 进行读写操作时，会导致竞争条件 (Race Condition)，甚至引发程序崩溃 (fatal error: concurrent map writes)。为了在并发环境下安全地使用 <code>map</code>，我们需要引入同步机制。本文将深入探讨三种常见的解决方案：使用 <code>sync.Mutex</code> 保护 <code>map</code>、使用 <code>sync.RWMutex</code> 保护 <code>map</code>，以及 Go 1.9 引入的 <code>sync.Map</code>，并对它们的特点、适用场景和性能进行对比分析。</p>
</blockquote>
<div class="note info flat"><p><strong>核心问题</strong>：Go 内置 <code>map</code> 非并发安全。<br><strong>核心解决方案</strong>：</p>
<ol>
<li><strong><code>sync.Mutex</code></strong>：最简单粗暴，读写都加排他锁。</li>
<li><strong><code>sync.RWMutex</code></strong>：读写分离锁，允许多个读操作并行，写操作独占。</li>
<li><strong><code>sync.Map</code></strong>：专为读多写少、键不冲突或键值对持续增长的场景优化，内置无锁或乐观锁机制。</li>
</ol>
</div>

<hr>
<h2 id="一、Go-内置-map-的并发问题"><a href="#一、Go-内置-map-的并发问题" class="headerlink" title="一、Go 内置 map 的并发问题"></a>一、Go 内置 <code>map</code> 的并发问题</h2><p>Go 语言设计者有意将内置 <code>map</code> 设计为非并发安全的，主要出于以下考虑：</p>
<ol>
<li><strong>性能</strong>：为了避免在每次 <code>map</code> 操作时都承担锁的开销，从而在单线程场景下达到最佳性能。</li>
<li><strong>灵活性</strong>：让开发者根据具体并发需求选择最合适的同步策略。</li>
</ol>
<p>当多个 goroutine 同时修改 <code>map</code> (包括插入、删除或修改值) 时，或者一个 goroutine 修改而另一个 goroutine 读取时，Go 运行时会检测到竞争条件并抛出 <code>fatal error: concurrent map writes</code> 错误，导致程序崩溃。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m[i] = i <span class="comment">// 多个 goroutine 同时写入</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// go func() &#123;</span></span><br><span class="line">	<span class="comment">// 	for &#123;</span></span><br><span class="line">	<span class="comment">// 		_ = m[0] // 一个 goroutine 读取，另一个写入也会崩溃</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// &#125;()</span></span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Map size:&quot;</span>, <span class="built_in">len</span>(m)) <span class="comment">// 多数情况下会崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码几乎必然导致 <code>fatal error: concurrent map writes</code>。</p>
<h2 id="二、使用-sync-Mutex-保护-map"><a href="#二、使用-sync-Mutex-保护-map" class="headerlink" title="二、使用 sync.Mutex 保护 map"></a>二、使用 <code>sync.Mutex</code> 保护 <code>map</code></h2><p><code>sync.Mutex</code> 是 Go 语言提供的最基本的互斥锁。它提供排他性的访问，任何时候只有一个 goroutine 可以持有锁并访问受保护的资源。</p>
<h3 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h3><p>当使用 <code>sync.Mutex</code> 保护 <code>map</code> 时，无论是读取还是写入操作，都需要先获取锁，操作完成后再释放锁。这确保了在任何给定时刻，只有一个 goroutine 在访问 <code>map</code>，从而避免了竞争条件。</p>
<h3 id="2-2-实现示例"><a href="#2-2-实现示例" class="headerlink" title="2.2 实现示例"></a>2.2 实现示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MutexMap 是一个使用 sync.Mutex 保护的并发安全 map</span></span><br><span class="line"><span class="keyword">type</span> MutexMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   sync.Mutex</span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMutexMap 创建一个新的 MutexMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMutexMap</span><span class="params">()</span></span> *MutexMap &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;MutexMap&#123;</span><br><span class="line">		data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store 将键值对存储到 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Store(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock() <span class="comment">// 确保释放写锁</span></span><br><span class="line">	m.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load 从 map 中加载值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Load(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.Lock() <span class="comment">// 获取读锁 (这里由于 Mutex 是排他锁，读也需要获取排他锁)</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	val, ok := m.data[key]</span><br><span class="line">	<span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 从 map 中删除键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Delete(key <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="built_in">delete</span>(m.data, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range 遍历 map 中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m.data &#123;</span><br><span class="line">		<span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := NewMutexMap()</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发写入</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Store(i, i*<span class="number">2</span>)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;MutexMap after writes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			val, ok := m.Load(i)</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">// fmt.Printf(&quot;Key %d, Value %d\n&quot;, i, val)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发删除</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Delete(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;MutexMap after deletes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Range 遍历</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续遍历</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;MutexMap elements after range:&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>简单易懂</strong>：实现逻辑直接，容易理解和使用。</li>
<li><strong>适用于所有读写比例</strong>：无论是读多写少、写多读少还是读写均衡，它都能保证正确性。</li>
<li><strong>通用性强</strong>：不仅可以保护 <code>map</code>，还可以保护任何共享数据。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>性能瓶颈</strong>：当并发读操作很多时，<code>sync.Mutex</code> 会成为性能瓶颈。因为读操作之间也需要排他锁，导致所有读操作都串行化执行，无法利用多核 CPU 的优势。</li>
</ul>
</li>
</ul>
<h2 id="三、使用-sync-RWMutex-保护-map"><a href="#三、使用-sync-RWMutex-保护-map" class="headerlink" title="三、使用 sync.RWMutex 保护 map"></a>三、使用 <code>sync.RWMutex</code> 保护 <code>map</code></h2><p><code>sync.RWMutex</code> 是读写互斥锁。它允许多个读者 (Reader) 同时持有读锁，但写者 (Writer) 必须独占写锁。当写者持有写锁时，任何读者或写者都无法获取锁；当读者持有读锁时，其他读者可以继续获取读锁，但写者必须等待所有读者释放读锁后才能获取写锁。</p>
<h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h3><p><code>sync.RWMutex</code> 的设计思想是“读读共享，读写互斥，写写互斥”。</p>
<ul>
<li><strong>读操作</strong>：使用 <code>RLock()</code> 和 <code>RUnlock()</code>。多个 goroutine 可以同时获取读锁进行读取。</li>
<li><strong>写操作</strong>：使用 <code>Lock()</code> 和 <code>Unlock()</code>。写锁是排他性的，在写入期间，任何其他读写操作都会被阻塞。</li>
</ul>
<h3 id="3-2-实现示例"><a href="#3-2-实现示例" class="headerlink" title="3.2 实现示例"></a>3.2 实现示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RWMutexMap 是一个使用 sync.RWMutex 保护的并发安全 map</span></span><br><span class="line"><span class="keyword">type</span> RWMutexMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   sync.RWMutex</span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRWMutexMap 创建一个新的 RWMutexMap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRWMutexMap</span><span class="params">()</span></span> *RWMutexMap &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RWMutexMap&#123;</span><br><span class="line">		data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store 将键值对存储到 map 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Store(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock() <span class="comment">// 确保释放写锁</span></span><br><span class="line">	m.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load 从 map 中加载值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Load(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.RLock() <span class="comment">// 获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.RUnlock() <span class="comment">// 确保释放读锁</span></span><br><span class="line">	val, ok := m.data[key]</span><br><span class="line">	<span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 从 map 中删除键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Delete(key <span class="type">int</span>) &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="built_in">delete</span>(m.data, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range 遍历 map 中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *RWMutexMap)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">	m.mu.RLock() <span class="comment">// 遍历通常视为读操作，可以获取读锁</span></span><br><span class="line">	<span class="keyword">defer</span> m.mu.RUnlock()</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m.data &#123;</span><br><span class="line">		<span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := NewRWMutexMap()</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发写入</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Store(i, i*<span class="number">2</span>)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;RWMutexMap after writes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发读取 (多个 goroutine 可以并行读取)</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123; <span class="comment">// 增加读取 goroutine 数量，模拟读多场景</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			val, ok := m.Load(i % <span class="number">1000</span>) <span class="comment">// 确保读取已存在的键</span></span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">// fmt.Printf(&quot;Key %d, Value %d\n&quot;, i % 1000, val)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发删除</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Delete(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;RWMutexMap after deletes, size:&quot;</span>, <span class="built_in">len</span>(m.data))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Range 遍历</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;RWMutexMap elements after range:&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>读性能提升</strong>：在读多写少的场景下，多个并发读操作可以并行执行，显著优于 <code>sync.Mutex</code>。</li>
<li><strong>相对简单</strong>：比 <code>sync.Map</code> 更容易理解和实现。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>写操作仍是瓶颈</strong>：写操作仍然需要独占锁，并且在有大量读者持有读锁时，写者可能会被长时间阻塞（写饥饿）。</li>
<li><strong>开销略高于 <code>sync.Mutex</code></strong>：在读写均衡或写多的场景下，<code>sync.RWMutex</code> 的管理开销可能略高于 <code>sync.Mutex</code>。</li>
</ul>
</li>
</ul>
<h2 id="四、使用-sync-Map"><a href="#四、使用-sync-Map" class="headerlink" title="四、使用 sync.Map"></a>四、使用 <code>sync.Map</code></h2><p><code>sync.Map</code> 是 Go 1.9 引入的开箱即用的并发安全 <code>map</code>。它不是使用传统的互斥锁来保护底层 <code>map</code>，而是通过一种更复杂的无锁或乐观锁机制来优化某些特定场景下的性能。</p>
<h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p><code>sync.Map</code> 内部维护了两个 <code>map</code>：</p>
<ol>
<li><code>read</code>：一个只读的 <code>map</code>，用于高效的读取操作。大多数读取操作会直接访问这个 <code>map</code>，通常不需要加锁。</li>
<li><code>dirty</code>：一个可写的 <code>map</code>，包含了所有最新的写入和更新。当 <code>read</code> map 中不存在某个键时，会回退到 <code>dirty</code> map 中查找。</li>
</ol>
<p>其核心优化策略是：</p>
<ul>
<li><strong>读操作优化</strong>：首次读取时，如果键在 <code>read</code> 中存在，则不需要任何锁。如果不在 <code>read</code> 中，会回退到 <code>dirty</code> 中查找，此时可能需要加锁。</li>
<li><strong>写操作优化</strong>：新的写入或更新会首先写入 <code>dirty</code> map。当 <code>read</code> map 上的查找失败次数达到阈值，或者 <code>dirty</code> map 变得太大时，<code>dirty</code> map 的内容会被提升到 <code>read</code> map。</li>
<li><strong>删除优化</strong>：删除操作会标记 <code>read</code> map 中的条目为“已删除”，并在 <code>dirty</code> map 中执行实际删除。</li>
</ul>
<h3 id="4-2-实现示例"><a href="#4-2-实现示例" class="headerlink" title="4.2 实现示例"></a>4.2 实现示例</h3><p><code>sync.Map</code> 没有像内置 <code>map</code> 那样直接的 <code>len()</code> 方法，它提供 <code>Store</code>, <code>Load</code>, <code>Delete</code>, <code>Range</code> 等方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map <span class="comment">// 直接声明使用</span></span><br><span class="line"></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发写入</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Store(i, i*<span class="number">2</span>) <span class="comment">// Store 方法</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;sync.Map after writes.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			val, ok := m.Load(i % <span class="number">1000</span>) <span class="comment">// Load 方法</span></span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="comment">// fmt.Printf(&quot;Key %d, Value %v\n&quot;, i % 1000, val)</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发删除</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			m.Delete(i) <span class="comment">// Delete 方法</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;sync.Map after deletes.&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Range 遍历 (需要传入一个处理函数)</span></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123; <span class="comment">// key 和 value 都是 interface&#123;&#125; 类型</span></span><br><span class="line">		count++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 返回 true 继续遍历，返回 false 停止遍历</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;sync.Map elements after range:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LoadOrStore 示例</span></span><br><span class="line">	val, loaded := m.LoadOrStore(<span class="number">1001</span>, <span class="number">10010</span>) <span class="comment">// 如果键 1001 不存在则存储，并返回存储的值和 false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;LoadOrStore 1001: value=%v, loaded=%v\n&quot;</span>, val, loaded)</span><br><span class="line"></span><br><span class="line">	val, loaded = m.LoadOrStore(<span class="number">1001</span>, <span class="number">20020</span>) <span class="comment">// 如果键 1001 存在，则返回当前值和 true，不存储新值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;LoadOrStore 1001 again: value=%v, loaded=%v\n&quot;</span>, val, loaded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-优缺点"><a href="#4-3-优缺点" class="headerlink" title="4.3 优缺点"></a>4.3 优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>读性能极高</strong>：在读多写少且键稳定 (不频繁删除或更新) 的场景下，性能远超 <code>sync.RWMutex</code>。因为它大多数读操作是无锁的。</li>
<li><strong>无需手动加锁</strong>：开箱即用，代码简洁。</li>
<li><strong>针对特定场景优化</strong>：特别适用于“键只写入一次或很少写入，但会被频繁读取”的缓存场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>不适用于所有场景</strong>：<ul>
<li><strong>写多读少或读写均衡</strong>：性能可能不如 <code>sync.Mutex</code> 或 <code>sync.RWMutex</code>。频繁的写入会导致 <code>dirty</code> map 频繁升级到 <code>read</code> map，带来额外开销。</li>
<li><strong>键频繁删除或更新</strong>：会导致 <code>read</code> 和 <code>dirty</code> map 之间状态同步的复杂性增加，性能下降。</li>
</ul>
</li>
<li><strong><code>interface&#123;&#125;</code> 类型开销</strong>：<code>Store</code>, <code>Load</code> 方法接受和返回 <code>interface&#123;&#125;</code> 类型，需要进行类型断言，可能带来少量的运行时开销和潜在的类型错误。</li>
<li><strong>没有 <code>Len()</code> 方法</strong>：获取元素数量需要遍历 <code>Range</code> 方法，效率较低。</li>
<li><strong>不保证遍历顺序</strong>：<code>Range</code> 方法遍历顺序不确定。</li>
</ul>
</li>
</ul>
<h2 id="五、性能对比与适用场景"><a href="#五、性能对比与适用场景" class="headerlink" title="五、性能对比与适用场景"></a>五、性能对比与适用场景</h2><table>
<thead>
<tr>
<th align="left">特性&#x2F;解决方案</th>
<th align="left"><code>sync.Mutex</code> with <code>map</code></th>
<th align="left"><code>sync.RWMutex</code> with <code>map</code></th>
<th align="left"><code>sync.Map</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>并发读</strong></td>
<td align="left">串行</td>
<td align="left">并行 (共享读锁)</td>
<td align="left">大多数情况无锁，极快</td>
</tr>
<tr>
<td align="left"><strong>并发写</strong></td>
<td align="left">串行</td>
<td align="left">串行</td>
<td align="left">内部优化，某些情况较快</td>
</tr>
<tr>
<td align="left"><strong>读写均衡</strong></td>
<td align="left">一般</td>
<td align="left">较好</td>
<td align="left">一般，可能差于 <code>Mutex</code></td>
</tr>
<tr>
<td align="left"><strong>读多写少</strong></td>
<td align="left">较差</td>
<td align="left">优秀</td>
<td align="left"><strong>最优</strong> (键不常删除)</td>
</tr>
<tr>
<td align="left"><strong>写多读少</strong></td>
<td align="left">较好</td>
<td align="left">一般</td>
<td align="left">较差</td>
</tr>
<tr>
<td align="left"><strong>API 复杂度</strong></td>
<td align="left">中</td>
<td align="left">中</td>
<td align="left">简单 (开箱即用)</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">良好 (自定义结构体)</td>
<td align="left">良好 (自定义结构体)</td>
<td align="left">弱 (<code>interface&#123;&#125;</code>)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">通用，简单粗暴</td>
<td align="left">读远多于写，需要高并发读</td>
<td align="left">键稳定，读远多于写的缓存</td>
</tr>
</tbody></table>
<h3 id="5-1-何时选择哪种方案？"><a href="#5-1-何时选择哪种方案？" class="headerlink" title="5.1 何时选择哪种方案？"></a>5.1 何时选择哪种方案？</h3><ol>
<li><p><strong>首选 <code>sync.Mutex</code></strong>：</p>
<ul>
<li><strong>简单场景</strong>：对性能要求不高，或者读写操作都很少的场景。</li>
<li><strong>读写均衡</strong>：当读写操作频率大致相同，或者写操作相对较多时，<code>Mutex</code> 的性能可能与 <code>RWMutex</code> 相当，甚至略优于 <code>sync.Map</code>。</li>
</ul>
</li>
<li><p><strong>考虑 <code>sync.RWMutex</code></strong>：</p>
<ul>
<li><strong>读多写少</strong>：当读操作频率远高于写操作时，<code>RWMutex</code> 能显著提高并发读的性能。这是最常见的优化场景之一。</li>
</ul>
</li>
<li><p><strong>慎用 <code>sync.Map</code></strong>：</p>
<ul>
<li><strong>键稳定且读远多于写 (Append-Only 或类似缓存)</strong>：如果你的 <code>map</code> 倾向于只增加新的键值对，或者现有键值对不常删除、更新，且有大量的并发读取，那么 <code>sync.Map</code> 能够提供最佳性能。</li>
<li><strong>避免在以下场景使用 <code>sync.Map</code></strong>：<ul>
<li><strong>写多读少</strong>：<code>dirty</code> map 的频繁提升会带来不小的开销。</li>
<li><strong>键频繁删除&#x2F;更新</strong>：<code>sync.Map</code> 对删除和更新的优化相对复杂，可能导致性能下降。</li>
<li><strong>需要 <code>Len()</code> 方法或遍历顺序</strong>：<code>sync.Map</code> 不直接支持这些功能。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>在 Golang 中实现并发安全的 <code>map</code>，并非只有一种“最佳”方案，而是需要根据具体的应用场景和读写模式来选择最合适的同步策略。</p>
<ul>
<li><strong><code>sync.Mutex</code></strong> 提供了最简单、最通用的解决方案，但在高并发读场景下性能不佳。</li>
<li><strong><code>sync.RWMutex</code></strong> 在读多写少的场景下表现出色，允许多个并发读，但在写操作时仍有阻塞。</li>
<li><strong><code>sync.Map</code></strong> 是一种为特定场景（读多写少且键稳定）高度优化的特殊 <code>map</code>，能提供近乎无锁的读取性能，但在其他场景下可能表现不佳，并且存在 <code>interface&#123;&#125;</code> 类型和缺乏 <code>Len()</code> 方法的限制。</li>
</ul>
<p>理解它们的内部机制和优缺点，是编写高效、健壮 Go 并发程序的关键。在选择之前，最好能对应用的读写模式进行预估或测试，以做出明智的决策。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2e2570e368f1/">https://blog.tbf1211.xx.kg/2e2570e368f1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/goroutine/">goroutine</a><a class="post-meta__tags" href="/tags/2026/">2026</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-18.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang sqlc 框架详解</div></div><div class="info-2"><div class="info-item-1"> sqlc 是一个SQL 编译器 (SQL Compiler)，它能够根据用户定义的 SQL 查询和数据库 Schema 自动生成类型安全 (type-safe) 的 Go 代码。与传统的 ORM (Object-Relational Mapping) 工具不同，sqlc 的核心理念是“写 SQL，生成 Go (Write SQL, Get Go)”。开发者专注于编写原生的 SQL 查询，sqlc 则负责将其转换为易于在 Go 应用程序中使用的、无反射、高性能的 API。  核心思想：保持 SQL 源码作为事实的唯一来源，并通过代码生成器将其无缝集成到 Go 代码中，实现类型安全和高效的数据库操作。 它不尝试将 SQL 抽象化，而是将 SQL 语句转换为可直接调用的 Go 函数。    一、为什么选择 sqlc？在 Golang 中进行数据库操作，开发者通常面临几种选择：  直接使用 database/sql 库：最底层、最灵活，但需要手动处理行扫描、错误检查、参数绑定等，代码量大且容易出错。 使用传统 ORM (如 GORM, XORM)：提供了高层次的抽象，通过 Go 结构体...</div></div></div></a><a class="pagination-related" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">如何防止 Golang Goroutine 泄漏</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是轻量级的并发执行单元，相比操作系统线程，其创建和销毁的开销极小。然而，这并不意味着我们可以随意创建 Goroutine 而不进行管理。当一个 Goroutine 启动后，如果它无法正常退出，就会一直占用内存和 CPU 资源，这种现象称为 Goroutine 泄漏 (Goroutine Leak)。Goroutine 泄漏会导致程序内存持续增长，最终耗尽系统资源，甚至引发 OOM (Out Of Memory) 错误，严重影响程序的稳定性和性能。  核心思想：Goroutine 泄漏的本质是，一个 Goroutine 完成了其预期的任务，但由于某种原因无法终止或被回收，持续占用资源。防止泄漏的关键在于确保每个 Goroutine 都有明确的退出条件和机制。   一、什么是 Goroutine 泄漏？Goroutine 泄漏是指 Goroutine 在其生命周期结束后未能被 Go 运行时回收，从而持续驻留在内存中。一个泄漏的 Goroutine 会一直占用：  栈内存：每个 Goroutine 都会分配栈空间 (初始 2KB 并动态伸缩)。大...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/099de403ef3d/" title="Golang 缓冲Channel和无缓冲Channel的区别"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Golang 缓冲Channel和无缓冲Channel的区别</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言的并发编程模型中，Channel 是 Goroutine 之间通信和同步的核心机制。Channel 提供了一种安全、同步的方式来传递数据。根据其容量大小，Channel 可以分为两种类型：无缓冲 Channel (Unbuffered Channel) 和 缓冲 Channel (Buffered Channel)。理解这两种 Channel 的区别以及它们各自的适用场景，是编写高效、正确 Go 并发代码的关键。  核心思想：无缓冲 Channel 强调“同步”通信，发送方和接收方必须同时就绪。缓冲 Channel 则允许“异步”通信，发送方可以在接收方未就绪时发送数据，但容量有限。   一、Channel 简介在 Go 中，Channel 是类型化的管道，可以通过它们发送和接收特定类型的值。它遵循“通过通信共享内存，而不是通过共享内存来通信”的并发哲学。 声明 Channel 的基本语法： 12345// 声明一个传递 int 类型数据的无缓冲 Channelvar ch1 chan int// 声明一个传递 string 类型数据的缓冲 Channel，容量为...</div></div></div></a><a class="pagination-related" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-31</div><div class="info-item-2">如何防止 Golang Goroutine 泄漏</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是轻量级的并发执行单元，相比操作系统线程，其创建和销毁的开销极小。然而，这并不意味着我们可以随意创建 Goroutine 而不进行管理。当一个 Goroutine 启动后，如果它无法正常退出，就会一直占用内存和 CPU 资源，这种现象称为 Goroutine 泄漏 (Goroutine Leak)。Goroutine 泄漏会导致程序内存持续增长，最终耗尽系统资源，甚至引发 OOM (Out Of Memory) 错误，严重影响程序的稳定性和性能。  核心思想：Goroutine 泄漏的本质是，一个 Goroutine 完成了其预期的任务，但由于某种原因无法终止或被回收，持续占用资源。防止泄漏的关键在于确保每个 Goroutine 都有明确的退出条件和机制。   一、什么是 Goroutine 泄漏？Goroutine 泄漏是指 Goroutine 在其生命周期结束后未能被 Go 运行时回收，从而持续驻留在内存中。一个泄漏的 Goroutine 会一直占用：  栈内存：每个 Goroutine 都会分配栈空间 (初始 2KB 并动态伸缩)。大...</div></div></div></a><a class="pagination-related" href="/f93f336b1901/" title="Golang 底层的多路复用和调度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-21</div><div class="info-item-2">Golang 底层的多路复用和调度详解</div></div><div class="info-2"><div class="info-item-1"> 多路复用 (Multiplexing) 在计算机网络编程中，通常指的是 I&#x2F;O 多路复用 (I&#x2F;O Multiplexing)，它是一种允许单个进程或线程监视多个 I&#x2F;O 事件（如网络连接、文件描述符）并在任何一个 I&#x2F;O 事件准备就绪时通知应用程序的机制。相较于传统的“一个连接一个线程&#x2F;进程”模型，I&#x2F;O 多路复用能够以更低的资源消耗处理大量并发连接，是构建高性能网络服务的基础。  核心思想：Go 语言通过其独特的运行时 (Runtime) 调度器和轻量级协程 (Goroutine) 机制，巧妙地将底层操作系统的 I&#x2F;O 多路复用能力抽象化，为开发者提供了编写简洁、高效且易于并发的网络服务的能力，让 I&#x2F;O 操作看起来像阻塞的，实则在底层是非阻塞的。   一、为什么需要多路复用？在理解 Go 语言如何实现多路复用之前，我们首先需要理解为什么它如此重要，以及它解决了哪些传统网络编程模型的痛点。 1.1 传统模型的问题1.1.1 阻塞 I&#x2F;O (Blocking I&#x2F;O)传统的阻塞...</div></div></div></a><a class="pagination-related" href="/5798c9959389/" title="Golang select 多路复用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-22</div><div class="info-item-2">Golang select 多路复用详解</div></div><div class="info-2"><div class="info-item-1"> select 语句 是 Go 语言中专为并发通信设计的一种控制结构，它允许 Goroutine 在多个通信操作上等待，并在其中任意一个准备就绪时执行相应的代码块。它提供了一种强大的机制，可以监听多个 Channel 的发送和接收操作，实现通信多路复用。这使得 Go 语言能够优雅地处理并发模式，例如超时、取消、扇入 (fan-in) 和任务调度等。  核心思想：select 语句是 Go 语言实现 CSP (Communicating Sequential Processes) 并发模型的核心工具之一，它能够协调和同步多个 Goroutine 之间的通信，使其能够响应最先准备就绪的 Channel 操作，避免了传统多线程编程中复杂的锁和条件变量。   一、为什么需要 select？在 Go 语言中，Goroutine 和 Channel 是构建并发程序的基础。当一个 Goroutine 需要从多个 Channel 中接收数据，或向多个 Channel 发送数据，并且希望响应其中任意一个 Channel 上的第一个就绪事件时，就引入了等待多路通信的需求。 考虑以下场景：  超时处理...</div></div></div></a><a class="pagination-related" href="/8f9f1342d7a2/" title="Golang 如何等待多个 Goroutine"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">Golang 如何等待多个 Goroutine</div></div><div class="info-2"><div class="info-item-1"> Goroutine 是 Go 语言轻量级并发的核心，它使得在程序中同时运行多个任务变得简单高效。然而，当启动多个 Goroutine 后，主程序或管理 Goroutine 常常需要知道这些并发任务何时完成，或者需要等待它们全部完成后再继续执行。这种“等待 Goroutine 完成”的机制是并发编程中至关重要的一环，确保了程序的正确性、资源的有序释放以及结果的汇总。  核心思想：管理 Goroutine 的生命周期是并发编程的关键。Go 提供了 sync.WaitGroup、Channels 以及 context.Context 结合 errgroup.Group 等多种机制，以适应不同复杂度和需求的 Goroutine 等待场景。   一、为什么需要等待 Goroutine？在 Go 语言中，main 函数的 Goroutine 启动后，即使它退出了，其他未完成的 Goroutine 也会继续运行。但通常情况下，我们希望：  确保任务完成：等待所有子 Goroutine 完成计算、I&#x2F;O 操作或数据处理，以避免数据丢失或不完整。 结果汇总：在所有 Goroutine ...</div></div></div></a><a class="pagination-related" href="/7642665c9bbb/" title="Golang context 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-03</div><div class="info-item-2">Golang context 详解</div></div><div class="info-2"><div class="info-item-1"> context 包 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递请求范围的数据 (request-scoped data)、取消信号 (cancellation signals) 和截止时间 (deadlines) 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，context 包是管理 Goroutine 生命周期和避免资源泄露的基石。  核心思想：context.Context 接口允许在 Goroutine 树中安全地传递控制流信息。其核心价值在于实现对计算任务的统一取消、超时控制和值传递，从而提升程序的健壮性和资源利用效率。   一、context 包的必要性在 Go 语言中，Goroutine 是轻量级并发的基础。然而，当应用程序的并发逻辑变得复杂时，以下问题会变得突出：  并发操作的取消：当一个上游操作（如用户取消请求）不再需要其下游的所有并发子任务时，如何有效地通知并停止这些子任务，避免不必要的计算和资源消耗？ 操作超时控制：如何在复杂的请求链中，为整个链条或其中某个环节设置统一的...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">500</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Go-%E5%86%85%E7%BD%AE-map-%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">一、Go 内置 map 的并发问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8-sync-Mutex-%E4%BF%9D%E6%8A%A4-map"><span class="toc-text">二、使用 sync.Mutex 保护 map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8E%9F%E7%90%86"><span class="toc-text">2.1 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.2 实现示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">2.3 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8-sync-RWMutex-%E4%BF%9D%E6%8A%A4-map"><span class="toc-text">三、使用 sync.RWMutex 保护 map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8E%9F%E7%90%86"><span class="toc-text">3.1 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.2 实现示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3.3 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8-sync-Map"><span class="toc-text">四、使用 sync.Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">4.2 实现示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4.3 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、性能对比与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BD%95%E6%97%B6%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">5.1 何时选择哪种方案？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-18.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>