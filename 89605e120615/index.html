<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Solr 全文检索服务器详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Solr 是 Apache Lucene 项目的开源搜索平台，它基于 Java 构建，提供强大的全文检索功能、分布式搜索、高亮显示、分面搜索、实时索引等功能。作为一个独立的、企业级的搜索服务器，Solr 允许开发者通过 RESTful HTTP&#x2F;XML&#x2F;JSON 接口来索引、查询数据，使其成为构建高性能搜索应用的理想选择。  核心思想：Solr 是一个基于 Lucene 的企">
<meta property="og:type" content="article">
<meta property="og:title" content="Solr 全文检索服务器详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/89605e120615/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Solr 是 Apache Lucene 项目的开源搜索平台，它基于 Java 构建，提供强大的全文检索功能、分布式搜索、高亮显示、分面搜索、实时索引等功能。作为一个独立的、企业级的搜索服务器，Solr 允许开发者通过 RESTful HTTP&#x2F;XML&#x2F;JSON 接口来索引、查询数据，使其成为构建高性能搜索应用的理想选择。  核心思想：Solr 是一个基于 Lucene 的企">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg">
<meta property="article:published_time" content="2024-06-23T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-30T10:18:03.462Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="中间件">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="Solr">
<meta property="article:tag" content="大数据">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Solr 全文检索服务器详解",
  "url": "https://blog.tbf1211.xx.kg/89605e120615/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg",
  "datePublished": "2024-06-23T22:24:00.000Z",
  "dateModified": "2026-01-30T10:18:03.462Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/89605e120615/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Solr 全文检索服务器详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-01.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Solr 全文检索服务器详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Solr 全文检索服务器详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-06-23T22:24:00.000Z" title="发表于 2024-06-24 06:24:00">2024-06-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Solr/">Solr</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>Solr 是 Apache Lucene 项目的开源搜索平台，它基于 Java 构建，提供强大的全文检索功能、分布式搜索、高亮显示、分面搜索、实时索引等功能。作为一个独立的、企业级的搜索服务器，Solr 允许开发者通过 RESTful HTTP&#x2F;XML&#x2F;JSON 接口来索引、查询数据，使其成为构建高性能搜索应用的理想选择。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>Solr 是一个基于 Lucene 的企业级搜索服务器，提供 RESTful API，支持全文检索、分布式、高亮、分面、实时索引等功能，通过配置 Schema 和数据源，实现高效、灵活的搜索服务。</strong></p>
</div>
<hr>
<h2 id="一、Solr-简介"><a href="#一、Solr-简介" class="headerlink" title="一、Solr 简介"></a>一、Solr 简介</h2><h3 id="1-1-什么是-Solr？"><a href="#1-1-什么是-Solr？" class="headerlink" title="1.1 什么是 Solr？"></a>1.1 什么是 Solr？</h3><p>Solr 是 Apache Lucene 项目的一个子项目。Lucene 是一个高性能的全文检索库，而 Solr 则是在 Lucene 的基础上，提供了一个<strong>生产级</strong>的搜索服务器，它解决了 Lucene 本身只是一个库，需要大量开发工作包一层才能对外提供服务的问题。Solr 提供了更完整、更易用的搜索解决方案，包括：</p>
<ul>
<li><strong>RESTful API</strong>：通过 HTTP 提供 JSON、XML、CSV 等多种格式的查询和索引接口。</li>
<li><strong>企业级搜索功能</strong>：全文检索、相关性排序、高亮显示、分面搜索 (Faceting)、过滤 (Filtering)。</li>
<li><strong>分布式搜索</strong>：支持 SolrCloud，实现高可用和水平扩展。</li>
<li><strong>强大而灵活的配置</strong>：通过 <code>schema.xml</code> 和 <code>solrconfig.xml</code> 可以高度定制索引和查询行为。</li>
<li><strong>多种数据源支持</strong>：可以从数据库、文件系统、Web 爬虫等多种来源获取数据。</li>
<li><strong>缓存机制</strong>：查询结果缓存、过滤器缓存等，提高查询性能。</li>
</ul>
<h3 id="1-2-Solr-的优势"><a href="#1-2-Solr-的优势" class="headerlink" title="1.2 Solr 的优势"></a>1.2 Solr 的优势</h3><ul>
<li><strong>开箱即用</strong>：下载部署即可提供搜索服务。</li>
<li><strong>功能丰富</strong>：满足几乎所有搜索需求。</li>
<li><strong>高性能</strong>：基于 Lucene，查询速度快。</li>
<li><strong>可伸缩性</strong>：SolrCloud 提供分布式和高可用性。</li>
<li><strong>社区活跃</strong>：Apache 顶级项目，拥有庞大活跃的社区支持。</li>
<li><strong>集成简单</strong>：通过 HTTP 请求进行交互，与各种编程语言和框架集成都很方便。</li>
</ul>
<h3 id="1-3-Solr-与-Lucene-的关系"><a href="#1-3-Solr-与-Lucene-的关系" class="headerlink" title="1.3 Solr 与 Lucene 的关系"></a>1.3 Solr 与 Lucene 的关系</h3><ul>
<li><strong>Lucene</strong>：是底层<strong>核心</strong>的全文检索库。它提供了索引和搜索文档的算法和数据结构。你无法直接运行 Lucene，它是一个 Java 库。</li>
<li><strong>Solr</strong>：是一个<strong>应用</strong>，它建立在 Lucene 之上，将 Lucene 的功能封装成一个独立的、可部署的搜索服务器。Solr 提供了用户友好的 RESTful API，内部使用 Lucene 进行实际的索引和搜索操作。</li>
</ul>
<h3 id="1-4-Solr-与-Elasticsearch-的异同"><a href="#1-4-Solr-与-Elasticsearch-的异同" class="headerlink" title="1.4 Solr 与 Elasticsearch 的异同"></a>1.4 Solr 与 Elasticsearch 的异同</h3><p>两者都是基于 Lucene 的流行的搜索解决方案，都支持分布式和高可用。</p>
<p><strong>异同点概述：</strong></p>
<ul>
<li><strong>起源和哲学</strong>：<ul>
<li><strong>Solr</strong>：更注重传统的搜索服务器功能，拥有丰富的配置选项，更像一个“配置驱动”的搜索引擎。</li>
<li><strong>Elasticsearch (ES)</strong>：更注重实时数据分析和分布式文档存储，更像一个“API 驱动”的搜索引擎，RESTful API 更为简洁。</li>
</ul>
</li>
<li><strong>部署和管理</strong>：<ul>
<li><strong>Solr</strong>：通常需要部署在 Java Web 服务器 (如 Tomcat&#x2F;Jetty) 中，配置复杂但灵活。</li>
<li><strong>ES</strong>：开箱即用，自带 Jetty 服务器，集群搭建和管理相对 SolrCloud 更简单，但也牺牲了一些灵活性。</li>
</ul>
</li>
<li><strong>索引更新</strong>：<ul>
<li><strong>Solr</strong>：实时性稍逊于 ES，但 <code>commit</code> 操作提供了更精细的控制。</li>
<li><strong>ES</strong>：以近实时 (Near Real Time, NRT) 方式快速更新索引，文档可立即搜索。</li>
</ul>
</li>
<li><strong>生态系统</strong>：<ul>
<li><strong>Solr</strong>：与 Hadoop、Spark 等大数据生态系统有良好集成。</li>
<li><strong>ES</strong>：拥有 Kibana (可视化)、Logstash (数据采集) 等 ELK Stack 全家桶，在大数据日志分析领域独树一帜。</li>
</ul>
</li>
<li><strong>社区活跃度与用户群体</strong>：两者都有庞大和活跃的社区，ES 近年来在云计算和日志分析领域发展更为迅猛。</li>
</ul>
<p><strong>总结</strong>：如果你的主要需求是强大的全文搜索、复杂的分面、精确的排序控制，且对配置的灵活性有较高要求，Solr 是一个很好的选择。如果你的需求是实时数据分析、日志管理、快速扩展、更简洁的 RESTful API，并且希望通过 API 尽可能完成所有操作，那么 Elasticsearch 可能更适合。</p>
<h2 id="二、Solr-的基本架构与核心概念"><a href="#二、Solr-的基本架构与核心概念" class="headerlink" title="二、Solr 的基本架构与核心概念"></a>二、Solr 的基本架构与核心概念</h2><h3 id="2-1-核心组件"><a href="#2-1-核心组件" class="headerlink" title="2.1 核心组件"></a>2.1 核心组件</h3><ul>
<li><strong>Solr Core</strong>：Solr 的核心，每个 Core 代表一个独立的索引。一个 Solr 实例可以运行多个 Core，每个 Core 有自己的配置 (<code>schema.xml</code>, <code>solrconfig.xml</code>) 和数据。</li>
<li><strong>SolrCloud</strong>：分布式部署模式，允许多个 Solr 实例（节点）组成一个集群，实现自动化分片 (Sharding)、副本 (Replication)、故障转移 (Failover) 和负载均衡。依赖 ZooKeeper 管理集群状态。</li>
<li><strong>ZooKeeper</strong>：SolrCloud 模式下，ZooKeeper 用于存储和同步集群配置、管理集群拓扑、选举 Leader 等。</li>
</ul>
<h3 id="2-2-索引与查询流程"><a href="#2-2-索引与查询流程" class="headerlink" title="2.2 索引与查询流程"></a>2.2 索引与查询流程</h3><p><strong>索引 (Indexing) 流程：</strong></p>
<ol>
<li><strong>数据源</strong>：从数据库、文件、Web 页面等获取原始数据。</li>
<li><strong>数据导入</strong>：通过 Solr 的 RESTful API（HTTP POST&#x2F;GET）将数据发送给 Solr。数据格式可以是 XML, JSON, CSV 等。</li>
<li><strong>Schema 处理</strong>：Solr 根据 <code>schema.xml</code> 中定义的字段类型、字段设置，对数据进行处理。</li>
<li><strong>文本分析</strong>：对于文本字段，会经过分词器 (Tokenizer)、过滤器 (Filter) 等组成的分析链 (Analysis Chain) 进行处理，生成术语 (Terms)。</li>
<li><strong>写入 Lucene 索引</strong>：处理后的数据片段（术语及元数据）被写入 Lucene 的倒排索引。</li>
<li><strong>提交 (Commit)</strong>：索引操作完成后，需要提交 (Commit) 才能使更改可见。</li>
</ol>
<p><strong>查询 (Querying) 流程：</strong></p>
<ol>
<li><strong>客户端请求</strong>：通过 HTTP GET 请求，带着查询参数发送给 Solr。</li>
<li><strong>解析查询</strong>：Solr 解析查询字符串，识别查询字段、查询关键字、过滤条件等。</li>
<li><strong>查询 Lucene 索引</strong>：根据查询条件，在 Lucene 倒排索引中查找匹配的文档。</li>
<li><strong>结果集处理</strong>：对原始匹配结果进行排序、分页、高亮处理、相关性评分等。</li>
<li><strong>返回结果</strong>：将查询结果以指定格式（JSON, XML 等）返回给客户端。</li>
</ol>
<h3 id="2-3-关键配置文件"><a href="#2-3-关键配置文件" class="headerlink" title="2.3 关键配置文件"></a>2.3 关键配置文件</h3><ul>
<li><code>solr.xml</code> (或 <code>solr.properties</code>)：Solr 实例级别的配置，定义了 Solr Home、Core 的加载方式等。</li>
<li><code>solrconfig.xml</code> (每个 Core 一个)：核心级别配置，定义了请求处理器 (Request Handlers)、更新处理器 (Update Handlers)、缓存设置、分析链配置等。</li>
<li><code>schema.xml</code> (每个 Core 一个)：核心级别配置，<strong>定义了所有字段及其类型、属性（是否可索引、可存储、是否分词等）</strong>。是 Solr 最重要的配置之一。</li>
</ul>
<h2 id="三、Solr-的安装与使用"><a href="#三、Solr-的安装与使用" class="headerlink" title="三、Solr 的安装与使用"></a>三、Solr 的安装与使用</h2><h3 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h3><ul>
<li><strong>Java 运行时环境 (JRE)</strong>：Solr 是 Java 应用，需要安装 JRE 8 或更高版本。</li>
</ul>
<h3 id="3-2-下载与启动"><a href="#3-2-下载与启动" class="headerlink" title="3.2 下载与启动"></a>3.2 下载与启动</h3><ol>
<li><p><strong>下载 Solr</strong>：从 Apache Solr 官网下载最新稳定版本：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://solr.apache.org/downloads.html">https://solr.apache.org/downloads.html</a></p>
</li>
<li><p><strong>解压</strong>：将下载的 <code>.tgz</code> 或 <code>.zip</code> 文件解压到你选择的目录，例如 <code>/opt/solr-9.x.x</code>。</p>
</li>
<li><p><strong>启动 Solr 服务器</strong>：进入解压目录，运行 bin 目录下的 <code>solr</code> 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/solr-9.x.x</span><br><span class="line">bin/solr start -p 8983 <span class="comment"># 启动 Solr 服务器，默认端口 8983</span></span><br><span class="line">bin/solr status        <span class="comment"># 查看 Solr 状态</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>访问 Solr Admin UI</strong>：在浏览器中访问 <code>http://localhost:8983/solr/</code>，可以看到 Solr 的管理界面。</p>
</li>
</ol>
<h3 id="3-3-创建一个-Core"><a href="#3-3-创建一个-Core" class="headerlink" title="3.3 创建一个 Core"></a>3.3 创建一个 Core</h3><p>在 Solr Admin UI 或通过命令行创建一个新的 Core。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 &quot;my_collection&quot; 的集合 (在 SolrCloud 模式下叫集合，单机模式也用这个命令创建 Core)</span></span><br><span class="line"><span class="comment"># -c 代表 collectionName</span></span><br><span class="line"><span class="comment"># -s 代表 shards, 分片数量</span></span><br><span class="line"><span class="comment"># -rf 代表 replicationFactor, 副本数量</span></span><br><span class="line">bin/solr create -c my_collection</span><br></pre></td></tr></table></figure>
<p>创建成功后，在 Admin UI 左侧的 Core Selector 下拉菜单中，可以看到 <code>my_collection</code>。</p>
<h3 id="3-4-定义-Schema-schema-xml"><a href="#3-4-定义-Schema-schema-xml" class="headerlink" title="3.4 定义 Schema (schema.xml)"></a>3.4 定义 Schema (schema.xml)</h3><p><code>schema.xml</code> 定义了你的索引结构。它位于每个 Core 的 <code>conf</code> 目录下。例如 <code>server/solr/my_collection/conf/schema.xml</code>。</p>
<p><strong>关键元素：</strong></p>
<ul>
<li><strong><code>field</code></strong>：定义一个字段及其属性。<ul>
<li><code>name</code>：字段名。</li>
<li><code>type</code>：字段类型（在 pre-Solr 7.x 中定义在 <code>fieldTypes</code> 中，新版本可以直接使用内置类型或在 <code>managed-schema</code> 中定义）。</li>
<li><code>indexed</code>：是否可索引（可在查询中使用）。</li>
<li><code>stored</code>：是否存储（查询结果中是否返回原始值）。</li>
<li><code>multiValued</code>：是否多值字段（一个文档可以有多个值）。</li>
<li><code>required</code>：是否必需。</li>
</ul>
</li>
<li><strong><code>fieldType</code></strong>：定义字段类型，包括其分析链 (<code>analyzer</code>)。<ul>
<li><code>name</code>：类型名。</li>
<li><code>class</code>：实现该类型处理的 Java 类。</li>
<li><code>analyzer</code>：定义字段的文本处理流程，包含 <code>tokenizer</code> 和 <code>filter</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例 <code>schema.xml</code> (简化版)：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;my_collection&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.7&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意：实际生产环境可能使用 managed-schema 模式，或者 solrconfig.xml 中配置 schemaFactory --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 定义字段类型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;string&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.StrField&quot;</span> <span class="attr">sortMissingLast</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.LongPointField&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;text_general&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.TextField&quot;</span> <span class="attr">positionIncrementGap</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">analyzer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">&quot;solr.StandardTokenizerFactory&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;solr.LowerCaseFilterFactory&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 更多过滤器可以放在这里，例如 solr.StopFilterFactory, solr.PorterStemFilterFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.DatePointField&quot;</span> <span class="attr">docValues</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 定义字段 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> <span class="attr">multiValued</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text_general&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text_general&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;category&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">multiValued</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;publish_date&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 动态字段 (Dynamic Fields)：用于处理未知字段，例如 _s, _l, _txt --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dynamicField</span> <span class="attr">name</span>=<span class="string">&quot;*_s&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dynamicField</span> <span class="attr">name</span>=<span class="string">&quot;*_t&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text_general&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 默认搜索字段和唯一键 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uniqueKey</span>&gt;</span>id<span class="tag">&lt;/<span class="name">uniqueKey</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultSearchField</span>&gt;</span>title<span class="tag">&lt;/<span class="name">defaultSearchField</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 现代 Solr 版本 (7.x+) 默认使用 <code>managed-schema</code>，它可以通过 API 动态修改 Schema，而不需要手动编辑 <code>schema.xml</code>。但理解 <code>schema.xml</code> 的结构仍然是基础。</p>
<h3 id="3-5-索引数据-HTTP-POST"><a href="#3-5-索引数据-HTTP-POST" class="headerlink" title="3.5 索引数据 (HTTP POST)"></a>3.5 索引数据 (HTTP POST)</h3><p>可以使用 <code>curl</code> 或任何 HTTP 客户端将 JSON 数据 POST 到 Solr。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设你的 Solr 运行在 8983 端口，Core 名为 my_collection</span></span><br><span class="line"><span class="comment"># 将数据添加到索引</span></span><br><span class="line">curl -X POST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">     <span class="string">&#x27;http://localhost:8983/solr/my_collection/update?commit=true&#x27;</span> \</span><br><span class="line">     --data-binary <span class="string">&#x27;[</span></span><br><span class="line"><span class="string">       &#123;</span></span><br><span class="line"><span class="string">         &quot;id&quot;: &quot;book001&quot;,</span></span><br><span class="line"><span class="string">         &quot;title&quot;: &quot;Learning Solr Search&quot;,</span></span><br><span class="line"><span class="string">         &quot;content&quot;: &quot;A comprehensive guide to building search applications with Apache Solr.&quot;,</span></span><br><span class="line"><span class="string">         &quot;category&quot;: [&quot;books&quot;, &quot;technology&quot;],</span></span><br><span class="line"><span class="string">         &quot;price&quot;: 35,</span></span><br><span class="line"><span class="string">         &quot;publish_date&quot;: &quot;2023-01-15T10:00:00Z&quot;</span></span><br><span class="line"><span class="string">       &#125;,</span></span><br><span class="line"><span class="string">       &#123;</span></span><br><span class="line"><span class="string">         &quot;id&quot;: &quot;article002&quot;,</span></span><br><span class="line"><span class="string">         &quot;title&quot;: &quot;Introduction to SolrCloud&quot;,</span></span><br><span class="line"><span class="string">         &quot;content&quot;: &quot;Understanding the distributed architecture of SolrCloud for high availability.&quot;,</span></span><br><span class="line"><span class="string">         &quot;category&quot;: [&quot;articles&quot;, &quot;distributed systems&quot;],</span></span><br><span class="line"><span class="string">         &quot;price&quot;: 0,</span></span><br><span class="line"><span class="string">         &quot;publish_date&quot;: &quot;2023-03-20T14:30:00Z&quot;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">     ]&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>commit=true</code> 会立即提交索引，使其可搜索。对于大量数据，通常会批量添加后手动 <code>commit</code>。</p>
<h3 id="3-6-查询数据-HTTP-GET"><a href="#3-6-查询数据-HTTP-GET" class="headerlink" title="3.6 查询数据 (HTTP GET)"></a>3.6 查询数据 (HTTP GET)</h3><p>通过 HTTP GET 请求向 <code>/solr/&#123;your_core_name&#125;/select</code> 端点发送查询。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有文档</span></span><br><span class="line">curl <span class="string">&#x27;http://localhost:8983/solr/my_collection/select?q=*:*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单查询 title 包含 &quot;Solr&quot; 的文档</span></span><br><span class="line">curl <span class="string">&#x27;http://localhost:8983/solr/my_collection/select?q=title:Solr&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂查询：查询 title 或 content 包含 &quot;Solr&quot; 或 &quot;分布式&quot;，并进行分面统计 category</span></span><br><span class="line">curl <span class="string">&#x27;http://localhost:8983/solr/my_collection/select?q=title:Solr+OR+content:分布式&amp;facet=true&amp;facet.field=category&amp;rows=10&amp;wt=json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤查询：查询 category 为 &quot;books&quot; 且 price 大于 30 的文档 (fq=filter query)</span></span><br><span class="line">curl <span class="string">&#x27;http://localhost:8983/solr/my_collection/select?q=*:*&amp;fq=category:books&amp;fq=price:[30+TO+*]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高亮显示查询结果 (hl=highlight)</span></span><br><span class="line">curl <span class="string">&#x27;http://localhost:8983/solr/my_collection/select?q=Solr&amp;hl=true&amp;hl.fl=title,content&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>常用查询参数：</strong></p>
<ul>
<li><code>q</code>：主查询字符串。</li>
<li><code>fq</code> (Filter Query)：过滤查询，不影响相关性评分，但能有效过滤结果集。多个 <code>fq</code> 是 AND 关系。</li>
<li><code>fl</code> (Field List)：指定返回的字段列表。</li>
<li><code>sort</code>：排序规则，例如 <code>field_name asc/desc</code>。</li>
<li><code>start</code>：分页起始位置。</li>
<li><code>rows</code>：每页返回的文档数量。</li>
<li><code>wt</code> (Writer Type)：结果格式，例如 <code>json</code>, <code>xml</code>, <code>csv</code>。</li>
<li><code>df</code> (Default Field)：如果 <code>q</code> 没有指定字段，则在此字段中搜索。</li>
<li><code>facet=true</code>：开启分面。</li>
<li><code>facet.field</code>：指定需要分面的字段。</li>
<li><code>hl=true</code>：开启高亮。</li>
<li><code>hl.fl</code>：指定需要高亮的字段。</li>
</ul>
<h2 id="四、高级特性"><a href="#四、高级特性" class="headerlink" title="四、高级特性"></a>四、高级特性</h2><h3 id="4-1-SolrCloud-分布式搜索"><a href="#4-1-SolrCloud-分布式搜索" class="headerlink" title="4.1 SolrCloud (分布式搜索)"></a>4.1 SolrCloud (分布式搜索)</h3><p>SolrCloud 是 Solr 提供的高可用和可伸缩方案。</p>
<ul>
<li><strong>Sharding (分片)</strong>：将大型索引数据分成多个逻辑片 (Shard)，每个 Shard 可以部署在不同的 Solr 节点上。查询会并行在所有 Shard 上执行，然后合并结果。</li>
<li><strong>Replication (副本)</strong>：每个 Shard 可以有多个副本 (Replica)。当一个节点故障时，其他副本可以接管，保证服务不中断。</li>
<li><strong>Leader&#x2F;Replica</strong>：每个 Shard 有一个 Leader，负责接收索引请求；其他 Replica 用于查询和故障转移。</li>
<li><strong>ZooKeeper</strong>：负责管理集群状态、配置、选举 Leader、监控节点健康等。</li>
</ul>
<p><strong>部署 SolrCloud 步骤 (简化)：</strong></p>
<ol>
<li>启动 ZooKeeper 集群。</li>
<li>将 Solr 配置上传到 ZooKeeper (<code>bin/solr zk upconfig</code>)。</li>
<li>启动多个 Solr 节点，并指定 ZooKeeper 地址 (<code>bin/solr start -cloud -p 8983 -z localhost:2181</code>)。</li>
<li>创建 Collection 时指定分片和副本数量 (<code>bin/solr create -c my_cloud_collection -shards 2 -replicationFactor 2 -d basic_configs</code>)。</li>
</ol>
<h3 id="4-2-数据导入处理器-Data-Import-Handler-DIH"><a href="#4-2-数据导入处理器-Data-Import-Handler-DIH" class="headerlink" title="4.2 数据导入处理器 (Data Import Handler, DIH)"></a>4.2 数据导入处理器 (Data Import Handler, DIH)</h3><p>DIH 允许开发者从关系型数据库、XML 文件、CSV 文件、Web 站点等多种数据源中提取数据，并将其导入到 Solr 索引中。</p>
<ul>
<li>配置 XML (<code>data-config.xml</code>) 描述数据源和映射关系。</li>
<li>通过 HTTP 请求触发 DIH 的全量 (<code>full-import</code>) 或增量 (<code>delta-import</code>) 导入。</li>
</ul>
<h3 id="4-3-实时索引-Real-time-Get-和近实时搜索-NRT"><a href="#4-3-实时索引-Real-time-Get-和近实时搜索-NRT" class="headerlink" title="4.3 实时索引 (Real-time Get) 和近实时搜索 (NRT)"></a>4.3 实时索引 (Real-time Get) 和近实时搜索 (NRT)</h3><ul>
<li><strong>NRT</strong>：通过硬提交 (hard commit) 和软提交 (soft commit) 机制，Solr 可以实现准实时的搜索。软提交不会写入磁盘，但会使新的文档立即可搜索，而硬提交则确保变更持久化。</li>
<li><strong>Real-time Get</strong>：Solr 甚至可以在文档被索引但尚未提交时，通过 ID 实时获取文档，这在一些需要极低延迟的场景中很有用。</li>
</ul>
<h3 id="4-4-语言处理"><a href="#4-4-语言处理" class="headerlink" title="4.4 语言处理"></a>4.4 语言处理</h3><ul>
<li><strong>分词器 (Tokenizer)</strong>：将文本分解成单独的词 (Token)。例如 <code>StandardTokenizer</code> (默认，根据空格和标点分词)、<code>CJKTokenizer</code> (中文&#x2F;日文&#x2F;韩文分词)。</li>
<li><strong>过滤器 (Filter)</strong>：对分词后的 Token 进行处理。<ul>
<li><code>LowerCaseFilter</code>：转换为小写。</li>
<li><code>StopFilter</code>：移除停用词 (如 “的”, “是”, “a”, “the”)。</li>
<li><code>StemmerFilter</code>：词干提取 (如 “running” -&gt; “run”)。</li>
<li><code>SynonymFilter</code>：同义词替换。</li>
</ul>
</li>
<li><strong>中文分词</strong>：Solr 默认不包含高质量的中文分词器。通常需要集成第三方插件，如 IK Analyzer, HanLP, Jieba 等。</li>
</ul>
<h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h2><ul>
<li><strong>网站&#x2F;电商搜索</strong>：提供商品搜索、内容搜索、博客搜索等。</li>
<li><strong>企业内部搜索</strong>：搜索公司文档、知识库、邮件等。</li>
<li><strong>大数据分析</strong>：将数据导入 Solr，进行快速的过滤、分面和聚合分析。</li>
<li><strong>日志搜索</strong>：虽然 Elasticsearch 更常用，但 Solr 也能处理日志搜索。</li>
</ul>
<h2 id="六、最佳实践与注意事项"><a href="#六、最佳实践与注意事项" class="headerlink" title="六、最佳实践与注意事项"></a>六、最佳实践与注意事项</h2><ul>
<li><strong>合理设计 Schema</strong>：这决定了你的搜索效果和性能。<ul>
<li>为需要搜索的字段设置 <code>indexed=true</code>。</li>
<li>为需要返回的字段设置 <code>stored=true</code>。</li>
<li>为多值字段设置 <code>multiValued=true</code>。</li>
<li>为需要排序&#x2F;分面的字段 <code>docValues=true</code> (Solr 4.x 引入)。</li>
<li>选择合适 <code>fieldType</code> 和 <code>analyzer</code>，特别是对于多语言或特定领域的文本。</li>
</ul>
</li>
<li><strong>优化查询性能</strong>：<ul>
<li>大量使用 <code>fq</code> (Filter Query) 进行过滤，因为它不参与相关性计算，可以被缓存，非常高效。</li>
<li>尽量避免 <code>q=*:*</code> (全匹配，性能开销大)，除非有强过滤条件。</li>
<li>使用分页 (<code>start</code>, <code>rows</code>) 控制返回结果集大小。</li>
<li>合理配置缓存 (查询结果缓存、过滤器缓存)。</li>
</ul>
</li>
<li><strong>SolrCloud 规划</strong>：<ul>
<li>根据数据量和查询负载，合理规划 Shard 和 Replica 数量。</li>
<li>确保 ZooKeeper 集群的稳定性和可用性。</li>
</ul>
</li>
<li><strong>监控与维护</strong>：<ul>
<li>实时监控 Solr 实例的 CPU、内存、QPS、延迟等指标。</li>
<li>定期进行索引优化 (Optimize) 来提升查询性能，但要注意其资源消耗。</li>
<li>定期备份索引。</li>
</ul>
</li>
<li><strong>安全性</strong>：<ul>
<li>Solr 默认没有严格的认证和授权机制。在生产环境中，需要确保 Solr 实例运行在受保护的网络中，并考虑在 Solr 前面部署反向代理 (如 Nginx) 进行权限控制。</li>
</ul>
</li>
</ul>
<h2 id="七、结语"><a href="#七、结语" class="headerlink" title="七、结语"></a>七、结语</h2><p>Solr 作为 Apache Lucene 项目的顶级开源搜索引擎，凭借其强大的功能、灵活的配置、良好的扩展性，在企业级搜索领域占据着举足轻重的地位。无论是构建网站搜索、电商搜索，还是支持复杂的数据分析，Solr 都能提供稳定高效的解决方案。理解其核心概念、掌握基本操作和高级特性，将是前端后开发都将受益的技能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/89605e120615/">https://blog.tbf1211.xx.kg/89605e120615/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/Solr/">Solr</a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7c33482df9e8/" title="RAID 技术深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RAID 技术深度解析</div></div><div class="info-2"><div class="info-item-1"> RAID (Redundant Array of Independent Disks)，最初是 Redundant Array of Inexpensive Disks 的缩写，后演变为 Redundant Array of Independent Disks。它是一种数据存储虚拟化技术，将多个物理硬盘组合成一个逻辑单元，以提供数据冗余 (Data Redundancy) 和&#x2F;或性能提升 (Performance Improvement)。RAID 技术通过不同的组合方式（即不同的 RAID 级别），在容量、性能和数据可靠性之间实现权衡。  核心思想：将多块物理硬盘智能地组织起来，以解决单块硬盘在性能、容量和可靠性上的局限性，提供比单个硬盘更优越的存储解决方案。   一、为什么需要 RAID？在早期计算机系统中，单个硬盘的容量、读写速度和可靠性都相对有限。为了克服这些限制，研究人员提出了 RAID 技术，其主要目标包括：  提高数据可靠性 (Fault Tolerance)：通过数据冗余机制，如镜像或奇偶校验，即使阵列中部分硬盘发生故障，数据仍然可以恢复或持续可用，避...</div></div></div></a><a class="pagination-related" href="/d3c7b6c4e397/" title="SHA-256 算法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SHA-256 算法详解</div></div><div class="info-2"><div class="info-item-1"> SHA-256 (Secure Hash Algorithm 256-bit) 是密码学哈希函数家族 SHA-2 (Secure Hash Algorithm 2) 的成员。它是一个单向 (One-way) 函数，能够接收任意长度的输入数据，并生成一个固定长度为 256 位的（32 字节）哈希值（或称为“消息摘要”）。SHA-256 广泛应用于数字签名、证书验证、数据完整性检查、区块链技术（如比特币）等领域，是目前最受信任和广泛部署的哈希算法之一。  核心思想：SHA-256 通过将输入消息进行填充、分块、迭代压缩，最终生成一个固定长度的 256 位哈希值。其设计利用了一系列复杂的位运算（逻辑运算、循环移位），以确保哈希值的单向性、抗碰撞性、抗原像攻击和抗第二原像攻击，从而提供数据的完整性和身份验证。   一、加密哈希函数的基本特性在深入 SHA-256 之前，理解一个安全的加密哈希函数应具备的关键特性至关重要：  确定性 (Deterministic)：相同的输入消息总是产生相同的哈希值。 计算效率 (Computational Efficiency)：对于任意输入消息，计算...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6f8ef9bd5860/" title="SQLite 详细教程：从入门到实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-17</div><div class="info-item-2">SQLite 详细教程：从入门到实践</div></div><div class="info-2"><div class="info-item-1"> SQLite 是一个非常流行且强大的嵌入式关系型数据库管理系统。它与其他数据库（如 MySQL、PostgreSQL）最大的不同在于，它不是一个独立的服务器进程，而是以库的形式被集成到应用程序中。这意味着 SQLite 数据库是一个单一的文件，易于部署、备份和传输。它零配置、无服务器、自包含的特性，使其成为移动应用、桌面应用、小型网站、物联网设备以及开发测试等场景的理想选择。  核心思想：将一个完整的关系型数据库引擎，集成到一个文件和最小的内存占用中，提供 SQL 能力且无需独立服务器进程。    一、什么是 SQLite？SQLite 是一个 C 语言库，实现了一个小型、快速、自包含的 SQL 数据库引擎。它的名字“Lite”就说明了它的轻量级特性。 核心特点：  无服务器 (Serverless): 与传统的客户端-服务器模式数据库不同，SQLite 应用程序直接读写磁盘上的数据库文件，无需独立的数据库服务器进程。 零配置 (Zero-configuration): 无需安装、配置或管理。你只需直接使用其库。 自包含 (Self-contained): 作为一个单一的文件，...</div></div></div></a><a class="pagination-related" href="/17bcd938fa86/" title="NDP (Neighbor Discovery Protocol) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-29</div><div class="info-item-2">NDP (Neighbor Discovery Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> NDP (Neighbor Discovery Protocol)，即邻居发现协议，是 IPv6 (Internet Protocol version 6) 中的一个关键协议。它属于 ICMPv6 (Internet Control Message Protocol for IPv6) 的一部分，旨在替代 IPv4 中的 ARP (Address Resolution Protocol)、ICMP Router Discovery (路由器发现) 和 ICMP Redirect (重定向) 等功能，为 IPv6 主机和路由器提供在同一链路 (link) 上发现彼此、确定链路层地址、发现路由器、处理地址自动配置以及检测重复地址等服务。  核心思想：为 IPv6 提供无状态、多功能、更安全且效率更高的本地链路通信机制。它通过一系列 ICMPv6 消息，实现了 IPv4 中分散的多个协议功能，支持 IPv6 的核心特性如无状态地址自动配置 (SLAAC) 和高效的邻居管理。   一、为什么需要 NDP？(与 IPv4 协议的对比)IPv4 网络中的一些协议在 IPv6 环境下存在局限...</div></div></div></a><a class="pagination-related" href="/f7642a181610/" title="CDN (内容分发网络) 服务详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">CDN (内容分发网络) 服务详解</div></div><div class="info-2"><div class="info-item-1"> CDN (Content Delivery Network)，即内容分发网络，是一种构建在现有网络基础之上的智能虚拟网络。它通过将站点内容发布到离用户最近的全球边缘节点，使用户在请求内容时，能够从距离自己最近的服务器获取数据，从而显著加速内容传输、减轻源站负载、提高用户体验和保障服务可用性。  核心思想：将内容缓存到离用户近的地方，让用户就近获取，缩短物理距离，从而缩短加载时间。   一、为什么需要 CDN？在没有 CDN 的情况下，用户访问网站的所有请求都会直接发送到源服务器。这存在几个问题：  访问速度慢：当用户与源服务器之间地理距离较远时，数据传输路径长，网络延迟高，导致页面加载缓慢，尤其是对于图片、视频等大文件。 网络拥堵：跨国或跨洲际网络传输容易受到骨干网带宽限制和拥堵的影响。 源站负载高：所有用户的请求都直接冲击源服务器，在高并发场景下可能导致源服务器过载、响应变慢甚至崩溃。 单点故障风险：源服务器一旦出现故障或遭受攻击，整个网站将无法访问。 安全性弱：源站直接暴露在公网，容易成为 DDoS 攻击的目标。  CDN 旨在解决上述问题，提供以下核心价值：  加速访问：...</div></div></div></a><a class="pagination-related" href="/e4ac942e6528/" title="深入理解JavaScript原型链（Prototype Chain）"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-27</div><div class="info-item-2">深入理解JavaScript原型链（Prototype Chain）</div></div><div class="info-2"><div class="info-item-1"> JavaScript 的原型链 (Prototype Chain) 是其实现继承的核心机制，也是理解 JavaScript 面向对象编程的关键。与 C++ 或 Java 等传统面向对象语言通过类（class）来实现继承不同，JavaScript 是一种基于原型 (Prototype-based) 的语言。这意味着对象可以直接从其他对象继承属性和方法。  核心思想：每个 JavaScript 对象都有一个指向其原型 (prototype) 的内部链接。当访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着这条链向上查找，直到找到该属性或方法，或者查找到原型链的末端（null）。   一、理解原型链的基石：[[Prototype]]、__proto__ 和 prototype在深入原型链之前，我们需要区分三个核心概念： 1.1 1. [[Prototype]] (隐式原型) 这是一个存在于每个 JavaScript 对象上的内部属性。 它指向该对象的原型对象。 它是真正构成原型链的链接。 在 ES5 之后，可以通过 Object.getPro...</div></div></div></a><a class="pagination-related" href="/876a758cde0d/" title=".gitignore 与 .gitattributes 文件详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="info-item-2">.gitignore 与 .gitattributes 文件详解</div></div><div class="info-2"><div class="info-item-1"> .gitignore 和 .gitattributes 是 Git 版本控制系统中两个重要的配置文件，它们帮助开发者精细地控制 Git 如何处理工作目录中的文件。gitignore 主要用于忽略不应该被版本控制的文件，而 gitattributes 则用于定义不同文件的属性，影响 Git 存储和比较文件的方式。理解和正确使用这两个文件对于维护干净、高效且一致的 Git 仓库至关重要。  核心思想：  .gitignore 告诉 Git 哪些文件或目录应该被忽略，不纳入版本控制。 .gitattributes 告诉 Git 如何对待特定类型的文件，例如行尾符、合并策略、文本转换等。    一、.gitignore 文件详解.gitignore 文件用于指定 Git 应该忽略哪些文件或目录。 这些被忽略的文件不会被 Git 跟踪，也不会被添加到仓库中。这对于排除构建产物、日志文件、敏感配置、IDE 特定文件等内容非常有用，可以保持仓库的整洁，避免提交不必要的文件，并减少仓库大小。 1.1 工作原理Git 在执行 git add 或 git commit 等命令时，会检查工作目录中是...</div></div></div></a><a class="pagination-related" href="/3286b8aa1630/" title="The Elm Architecture (TEA) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-30</div><div class="info-item-2">The Elm Architecture (TEA) 详解</div></div><div class="info-2"><div class="info-item-1"> The Elm Architecture (TEA) 是一种用于构建交互式 Web 应用程序的函数式架构模式。它最初由 Elm 语言社区设计和推广，但其核心思想和模式因其可预测性、可测试性和易于理解性而非常成功，并被广泛借鉴和应用于其他前端框架和语言，如 React (特别是 Redux)、Vue (Vuex)、ReasonML (Redux-Like)、甚至 Swift (The Composable Architecture) , Rust (Relm) 和 Golang (bubbletea) 等。  核心思想：将应用程序状态、状态更新逻辑和 UI 渲染逻辑清晰地分离为三个核心部分：Model、Update 和 View，并通过一个单向数据流进行管理。   一、为什么需要 The Elm Architecture？在传统的命令式或面向对象编程中，UI 应用程序的状态管理往往是复杂且容易出错的部分：  状态分散：应用程序状态可能散布在各个组件中，难以追踪和同步。 多向数据流：数据可以在组件之间以多种方式流动，导致难以预测状态变化。 调试困难：当出现 bug 时，很难确定是哪...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Solr-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Solr 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-Solr%EF%BC%9F"><span class="toc-text">1.1 什么是 Solr？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Solr-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">1.2 Solr 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Solr-%E4%B8%8E-Lucene-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1.3 Solr 与 Lucene 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Solr-%E4%B8%8E-Elasticsearch-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">1.4 Solr 与 Elasticsearch 的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Solr-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Solr 的基本架构与核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">2.1 核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2 索引与查询流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%85%B3%E9%94%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">2.3 关键配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Solr-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">三、Solr 的安装与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">3.1 环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="toc-text">3.2 下载与启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Core"><span class="toc-text">3.3 创建一个 Core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AE%9A%E4%B9%89-Schema-schema-xml"><span class="toc-text">3.4 定义 Schema (schema.xml)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE-HTTP-POST"><span class="toc-text">3.5 索引数据 (HTTP POST)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE-HTTP-GET"><span class="toc-text">3.6 查询数据 (HTTP GET)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">四、高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-SolrCloud-%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2"><span class="toc-text">4.1 SolrCloud (分布式搜索)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%A4%84%E7%90%86%E5%99%A8-Data-Import-Handler-DIH"><span class="toc-text">4.2 数据导入处理器 (Data Import Handler, DIH)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AE%9E%E6%97%B6%E7%B4%A2%E5%BC%95-Real-time-Get-%E5%92%8C%E8%BF%91%E5%AE%9E%E6%97%B6%E6%90%9C%E7%B4%A2-NRT"><span class="toc-text">4.3 实时索引 (Real-time Get) 和近实时搜索 (NRT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86"><span class="toc-text">4.4 语言处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">六、最佳实践与注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%BB%93%E8%AF%AD"><span class="toc-text">七、结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-01.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>