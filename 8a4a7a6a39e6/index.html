<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>灰度发布详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在软件开发和运维过程中，发布新版本往往伴随着风险。即使经过了严格的测试，新功能或代码仍然可能在生产环境中暴露出意想不到的问题，对用户造成影响。为了最大限度地降低这种风险，灰度发布 (Canary Release) 应运而生，成为现代软件交付流程中不可或缺的一部分。  灰度发布 (Canary Release) 是一种逐渐将新版本软件或功能发布给一小部分用户或服务器，然后逐步扩大发布范围的策略。其目">
<meta property="og:type" content="article">
<meta property="og:title" content="灰度发布详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/8a4a7a6a39e6/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在软件开发和运维过程中，发布新版本往往伴随着风险。即使经过了严格的测试，新功能或代码仍然可能在生产环境中暴露出意想不到的问题，对用户造成影响。为了最大限度地降低这种风险，灰度发布 (Canary Release) 应运而生，成为现代软件交付流程中不可或缺的一部分。  灰度发布 (Canary Release) 是一种逐渐将新版本软件或功能发布给一小部分用户或服务器，然后逐步扩大发布范围的策略。其目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg">
<meta property="article:published_time" content="2025-07-28T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-28T09:37:21.882Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="CI&#x2F;CD">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "灰度发布详解",
  "url": "https://blog.tbf1211.xx.kg/8a4a7a6a39e6/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-01.jpg",
  "datePublished": "2025-07-28T22:24:00.000Z",
  "dateModified": "2026-02-28T09:37:21.882Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/8a4a7a6a39e6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '灰度发布详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-01.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">灰度发布详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">灰度发布详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-07-28T22:24:00.000Z" title="发表于 2025-07-29 06:24:00">2025-07-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/CI-CD/">CI/CD</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>在软件开发和运维过程中，发布新版本往往伴随着风险。即使经过了严格的测试，新功能或代码仍然可能在生产环境中暴露出意想不到的问题，对用户造成影响。为了最大限度地降低这种风险，<strong>灰度发布 (Canary Release)</strong> 应运而生，成为现代软件交付流程中不可或缺的一部分。</p>
<blockquote>
<p><strong>灰度发布 (Canary Release)</strong> 是一种逐渐将新版本软件或功能发布给一小部分用户或服务器，然后逐步扩大发布范围的策略。其目的是在全面发布之前，通过真实用户环境中的小范围验证，尽早发现潜在问题，并允许在出现故障时快速回滚，从而最大限度地降低风险对整体用户体验的影响。</p>
</blockquote>
<div class="note info flat"><p>核心思想：如同煤矿中的金丝雀，新版本（金丝雀）先进入生产环境，如果它“存活”良好，则逐渐扩大发布范围。</p>
</div>

<hr>
<h2 id="一、为什么需要灰度发布？"><a href="#一、为什么需要灰度发布？" class="headerlink" title="一、为什么需要灰度发布？"></a>一、为什么需要灰度发布？</h2><p>传统的一次性全量发布 (Big Bang Release) 模式存在巨大风险：</p>
<ul>
<li><strong>高风险</strong>：一旦新版本存在严重 Bug 或性能问题，会立即影响所有用户，造成大面积故障和业务损失。</li>
<li><strong>难以快速回滚</strong>：全量发布后，如果发现问题，回滚到旧版本通常复杂且耗时，可能需要停机或进行数据修复。</li>
<li><strong>真实环境差异</strong>：测试环境往往难以完全模拟生产环境的复杂性（如真实数据量、用户并发、网络延迟等），一些问题只有在生产环境中才会暴露。</li>
<li><strong>用户体验受损</strong>：突发问题导致的服务中断或功能异常严重损害用户信任和品牌形象。</li>
</ul>
<p>灰度发布旨在解决上述问题，通过“试点”的方式，在风险可控的范围内验证新版本。</p>
<h2 id="二、灰度发布的工作原理"><a href="#二、灰度发布的工作原理" class="headerlink" title="二、灰度发布的工作原理"></a>二、灰度发布的工作原理</h2><p>灰度发布的核心思想是<strong>逐步放量</strong>。它通常涉及以下几个关键阶段和技术：</p>
<h3 id="2-1-阶段式发布流程"><a href="#2-1-阶段式发布流程" class="headerlink" title="2.1 阶段式发布流程"></a>2.1 阶段式发布流程</h3><p>灰度发布并非一次性的操作，而是一个分阶段、持续监控和决策的过程：</p>
<ol>
<li><p><strong>阶段 0：稳定版本 (Baseline)</strong></p>
<ul>
<li>当前所有用户都在使用稳定、健康的旧版本。</li>
<li>这是进行灰度发布的基线。</li>
</ul>
</li>
<li><p><strong>阶段 1：小流量灰度 (Canary Group)</strong></p>
<ul>
<li>部署新版本到一小组服务器或一小部分用户群体（例如 1%~5% 的流量）。这部分用户就是“金丝雀用户”。</li>
<li><strong>目标</strong>：在最小化影响范围的同时，在真实生产环境中验证新版本的功能性、稳定性和性能。</li>
<li><strong>用户群体选择</strong>：可以是内部员工、特定地区用户、随机选择的用户。</li>
</ul>
</li>
<li><p><strong>阶段 2：指标监控与评估 (Monitoring &amp; Evaluation)</strong></p>
<ul>
<li>在灰度发布的整个过程中，对新旧版本的关键业务指标和技术指标进行实时监控和对比。</li>
<li><strong>技术指标</strong>：CPU 利用率、内存、网络延迟、错误率 (HTTP 5xx)、日志异常、响应时间 P99 等。</li>
<li><strong>业务指标</strong>：转化率、点击率、关键业务流程成功率、用户反馈等。</li>
<li><strong>决策点</strong>：根据监控数据评估新版本的表现。<ul>
<li><strong>如果发现问题</strong>：立即回滚新版本，恢复到稳定版本。</li>
<li><strong>如果一切正常</strong>：继续下一阶段放量。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阶段 3：逐步扩大范围 (Phased Rollout)</strong></p>
<ul>
<li>如果金丝雀版本表现良好，则根据预设策略，逐步增加新版本所承担的流量比例或覆盖的服务器数量（例如 10%、25%、50%）。</li>
<li>每个阶段都需要充分的监控和评估时间。</li>
</ul>
</li>
<li><p><strong>阶段 4：全量发布 (Full Rollout)</strong></p>
<ul>
<li>当新版本灰度到足够大的范围且各项指标表现稳定后，即可将剩余流量全部切换到新版本。</li>
<li>旧版本可以下线或作为备用。</li>
</ul>
</li>
</ol>
<h3 id="2-2-流量路由与用户分流策略"><a href="#2-2-流量路由与用户分流策略" class="headerlink" title="2.2 流量路由与用户分流策略"></a>2.2 流量路由与用户分流策略</h3><p>实现灰度发布的关键技术是<strong>流量的精细化控制和路由</strong>：</p>
<ul>
<li><strong>负载均衡器 (Load Balancer)</strong>：通过配置负载均衡器的权重，将不同比例的流量导向新旧版本服务。<ul>
<li>例如：Nginx, HAProxy, F5 等。</li>
</ul>
</li>
<li><strong>API 网关 (API Gateway)</strong>：在 API 网关层面进行流量分发，根据用户 ID、地理位置、请求头等信息将请求路由到不同版本的后端服务。<ul>
<li>例如：Kong, Envoy, Spring Cloud Gateway 等。</li>
</ul>
</li>
<li><strong>服务网格 (Service Mesh)</strong>：在微服务架构中，服务网格（如 Istio, Linkerd）提供了强大的流量管理能力。<ul>
<li>可以根据 HTTP Header、用户百分比进行流量切分。</li>
<li>支持 L7 路由、故障注入、流量镜像等高级功能。</li>
</ul>
</li>
<li><strong>DNS 路由</strong>：通过修改 DNS 记录实现流量切换，但通常有 DNS 缓存延迟，不适合快速渐进式发布。</li>
<li><strong>客户端配置</strong>：移动应用或桌面应用可以通过客户端配置（如 A&#x2F;B 测试平台）控制用户使用哪个版本。</li>
</ul>
<p><strong>用户分流方式</strong>:</p>
<ul>
<li><strong>按比例随机分流</strong>：例如 5% 的请求访问新版本。</li>
<li><strong>按用户属性</strong>：内部员工、特定 IP 段、指定地区用户、VIP 用户。</li>
<li><strong>按请求特征</strong>：特定的 HTTP Header、URL 路径、Cookie 信息。</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    %% --- 1. 流量入口 ---
    subgraph Traffic [&quot;&nbsp; 1. User Traffic (用户流量) &nbsp;&quot;]
        A([&quot;🌎 所有用户请求&lt;br&#x2F;&gt;(100% Incoming)&quot;])
    end

    %% --- 2. 控制层 ---
    subgraph Gateway [&quot;&nbsp; 2. Orchestration (流量编排) &nbsp;&quot;]
        LB[[&quot;⚖️ 负载均衡 &#x2F; 网关&lt;br&#x2F;&gt;(Traffic Splitter)&quot;]]
    end

    %% --- 3. 服务版本 (新旧对比) ---
    subgraph Versions [&quot;&nbsp; 3. Service Versions (服务实例) &nbsp;&quot;]
        V1[&quot;&lt;b&gt;Stable (V1)&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;旧版本服务&lt;br&#x2F;&gt;(95% 流量)&quot;]
        V2[&quot;🚀 &lt;b&gt;Canary (V2)&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;新版本服务&lt;br&#x2F;&gt;(5% 灰度)&quot;]
    end

    %% --- 4. 智能观测 ---
    subgraph Observability [&quot;&nbsp; 4. Analysis (监控与反馈) &nbsp;&quot;]
        E[&quot;📊 指标监控&lt;br&#x2F;&gt;(Latency&#x2F;Err Rate)&quot;]
        F[&quot;📄 日志分析&lt;br&#x2F;&gt;(Trace&#x2F;Log)&quot;]
        G[&quot;💬 用户反馈&lt;br&#x2F;&gt;(User Sentiment)&quot;]
    end

    %% --- 5. 决策中心 ---
    D{&quot;⚖️ &lt;b&gt;发布决策&lt;&#x2F;b&gt;&lt;br&#x2F;&gt;(Deployment Decision)&quot;}

    %% --- 逻辑流转 ---
    A &#x3D;&#x3D;&gt; LB
    LB -- &quot;稳定路由&quot; --&gt; V1
    LB -- &quot;动态路由&quot; --&gt; V2

    V1 &amp; V2 -.-&gt;|数据上报| E &amp; F
    V2 -.-&gt;|体验追踪| G

    E &amp; F &amp; G --&gt; D

    %% --- 决策反馈环路 ---
    D -- &quot;✅ 继续推进&quot; --&gt; LB
    D -- &quot;❌ 回滚 (Rollback)&quot; --&gt; LB
    D -- &quot;🏁 全量上线&quot; --&gt; LB

    %% --- 样式与颜色优化 (黑暗模式高对比度) ---
    %% 流量与网关
    style A fill:#1f6feb,stroke:#58a6ff,color:#fff
    style LB fill:#161b22,stroke:#58a6ff,stroke-width:2px,color:#fff
    
    %% V1 旧版本：灰色，代表低存在感
    style V1 fill:#21262d,stroke:#8b949e,color:#8b949e
    
    %% V2 新版本：青色，代表重点观测
    style V2 fill:#0d443a,stroke:#39d353,stroke-width:2px,color:#39d353
    
    %% 监控层：深蓝色
    style E fill:#161b22,stroke:#58a6ff,color:#c9d1d9
    style F fill:#161b22,stroke:#58a6ff,color:#c9d1d9
    style G fill:#161b22,stroke:#58a6ff,color:#c9d1d9
    
    %% 决策：琥珀色
    style D fill:#d29922,stroke:#f1e05a,stroke-width:2px,color:#000
    
    %% 连线美化
    linkStyle 0,1,2 stroke-width:2px
    linkStyle 1 stroke:#8b9
  </pre></div>

<h2 id="三、灰度发布的优势"><a href="#三、灰度发布的优势" class="headerlink" title="三、灰度发布的优势"></a>三、灰度发布的优势</h2><ol>
<li><strong>风险最小化</strong>：将新版本可能带来的负面影响限制在一小部分用户，避免大面积故障。</li>
<li><strong>真实环境验证</strong>：在最接近生产环境的条件下运行和测试新代码，发现仅在生产中才会出现的问题。</li>
<li><strong>快速故障发现与回滚</strong>：通过持续监控，能及早发现问题并快速回滚到稳定版本，降低故障修复成本和平均恢复时间 (MTTR)。</li>
<li><strong>用户反馈收集</strong>：对于面向用户的功能更新，可以在小范围发布时收集真实用户反馈，用于进一步优化。</li>
<li><strong>性能和扩展性验证</strong>：在生产流量下验证新版本的性能表现和扩展能力。</li>
<li><strong>并行迭代能力</strong>：可以在不影响主版本稳定的前提下，并行开发和测试新功能。</li>
</ol>
<h2 id="四、灰度发布的挑战与考量"><a href="#四、灰度发布的挑战与考量" class="headerlink" title="四、灰度发布的挑战与考量"></a>四、灰度发布的挑战与考量</h2><p>虽然灰度发布优势显著，但也面临一些挑战：</p>
<ol>
<li><strong>监控复杂性</strong>：需要建立完善的监控体系，包括业务指标和技术指标，并能够区分新旧版本的表现。这要求精细的度量、日志收集和告警机制。</li>
<li><strong>数据一致性问题</strong>：如果新旧版本之间存在数据库模式变更或数据格式不兼容，可能导致数据损坏或不一致。需要仔细设计数据库迁移和回滚策略，通常采用“向前与向后兼容”的设计。</li>
<li><strong>用户体验一致性</strong>：同一用户可能在不同请求中访问不同版本的服务，可能导致混乱或不一致的用户体验，尤其是对于有状态或会话敏感的应用。</li>
<li><strong>基础设施复杂性</strong>：实现流量的精细化控制需要强大的基础设施支持，如高级负载均衡器、API 网关或服务网格。</li>
<li><strong>回滚策略</strong>：除了代码回滚，还需要考虑数据回滚（如数据库 Schema 变更）。</li>
<li><strong>测试的“生产化”</strong>：灰度发布本质上是将部分测试延伸到生产环境，需要对可能出现的问题有所准备。</li>
<li><strong>“僵尸服务”</strong>：如果旧版本无法安全下线或清除，可能造成资源浪费或潜在风险。</li>
</ol>
<h2 id="五、灰度发布的实施步骤-实践指南"><a href="#五、灰度发布的实施步骤-实践指南" class="headerlink" title="五、灰度发布的实施步骤 (实践指南)"></a>五、灰度发布的实施步骤 (实践指南)</h2><ol>
<li><p><strong>定义发布策略</strong>：</p>
<ul>
<li><strong>确定灰度比例</strong>：初始流量、逐步递增的比例（例如 1%、5%、10%、25%、50%、100%）。</li>
<li><strong>定义灰度组</strong>：是随机用户？内部员工？特定 IP？</li>
<li><strong>设定灰度时间</strong>：每个阶段的持续时间、观察周期。</li>
<li><strong>明确评估指标</strong>：最重要的业务指标、SLA&#x2F;SLO（服务等级协议&#x2F;目标）指标，以及技术稳定性指标。</li>
<li><strong>制定回滚策略</strong>：什么条件下触发回滚，回滚的流程。</li>
</ul>
</li>
<li><p><strong>准备基础设施</strong>：</p>
<ul>
<li><strong>部署新版本</strong>：将新版本应用部署到独立的服务器组或容器实例中。</li>
<li><strong>配置流量路由</strong>：在负载均衡器、API 网关或服务网格中配置流量分发规则，将少量请求路由到新版本。</li>
<li><strong>确保可观察性</strong>：为新旧版本配置独立的监控、日志和追踪，以便对比分析。</li>
</ul>
</li>
<li><p><strong>执行灰度发布</strong>：</p>
<ul>
<li>将预设的少量流量切换到新版本。</li>
</ul>
</li>
<li><p><strong>持续监控与评估</strong>：</p>
<ul>
<li>密切关注各项指标，特别是错误率、响应时间、资源使用率和业务转化率。</li>
<li>收集用户反馈。</li>
<li>与旧版本进行横向对比。</li>
</ul>
</li>
<li><p><strong>决策与推进&#x2F;回滚</strong>：</p>
<ul>
<li><strong>如果指标显示异常</strong>：立即执行回滚操作，将所有流量切回旧版本，分析问题并修复。</li>
<li><strong>如果指标显示正常</strong>：按照预定策略逐步增加新版本的流量比例。在每个增量步骤之后，重复监控和评估。</li>
</ul>
</li>
<li><p><strong>全量发布与清理</strong>：</p>
<ul>
<li>当新版本成功承载所有流量并稳定运行一段时间后，即可认为全量发布成功。</li>
<li>下线或归档旧版本实例。</li>
</ul>
</li>
</ol>
<h2 id="六、常用工具和技术"><a href="#六、常用工具和技术" class="headerlink" title="六、常用工具和技术"></a>六、常用工具和技术</h2><p>现代的云原生和 DevOps 工具链极大地简化了灰度发布：</p>
<ul>
<li><strong>容器编排平台</strong>：<ul>
<li><strong>Kubernetes</strong>：通过 <code>Deployment</code>、<code>Service</code>、<code>Ingress</code> 或更高级的 <code>Traffic Shifting</code> 资源，可以方便地管理不同版本的 Pod，并控制流量路由。</li>
<li><strong>OpenShift (基于 Kubernetes)</strong>：提供类似的功能，并增加了企业级特性。</li>
</ul>
</li>
<li><strong>服务网格 (Service Mesh)</strong>：<ul>
<li><strong>Istio</strong>：通过 <code>VirtualService</code> 和 <code>DestinationRule</code> 资源，可以实现非常精细的流量切分（按百分比、HTTP Header、Cookie 等）。</li>
<li><strong>Linkerd</strong>：提供类似的功能，注重简洁和性能。</li>
</ul>
</li>
<li><strong>API 网关</strong>：<ul>
<li><strong>Nginx&#x2F;Envoy (作为边缘代理)</strong>：可以配置路由规则和负载均衡权重。</li>
<li><strong>Kong&#x2F;Tyk&#x2F;Apigee</strong>：商业或开源的 API 网关，提供强大的流量管理功能。</li>
</ul>
</li>
<li><strong>云服务平台</strong>：<ul>
<li><strong>AWS (Route 53, ALB, App Mesh)</strong>：提供多种流量路由和灰度发布支持。</li>
<li><strong>Azure (Traffic Manager, Application Gateway)</strong>：Azure 蓝绿部署和槽位切换功能。</li>
<li><strong>Google Cloud (Cloud Load Balancing, Anthos Service Mesh)</strong>：提供灵活的流量管理。</li>
</ul>
</li>
<li><strong>CI&#x2F;CD 工具</strong>：<ul>
<li><strong>Jenkins, GitLab CI&#x2F;CD, ArgoCD, Spinnaker</strong>：自动化灰度发布的部署、监控和回滚流程。</li>
</ul>
</li>
<li><strong>监控和日志工具</strong>：<ul>
<li><strong>Prometheus + Grafana</strong>：用于指标收集、存储和可视化。</li>
<li><strong>ELK Stack (Elasticsearch, Logstash, Kibana)</strong>：用于日志收集、分析和可视化。</li>
<li><strong>Datadog, New Relic, Dynatrace</strong>：商业 APM (应用性能管理) 工具，提供全面的监控和告警。</li>
</ul>
</li>
</ul>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>灰度发布是现代软件开发中不可或缺的风险管理策略。它通过在小范围内逐步验证新版本，将发布风险降到最低，同时提供了在真实生产环境中获取宝贵反馈的机会。尽管实施灰度发布会增加基础设施和监控的复杂性，但在高可用性、快速迭代和客户满意度方面带来的巨大收益，使其成为交付高质量软件的黄金标准。通过合理设计策略、构建自动化流程并利用适当的工具，团队可以安全、高效地进行新功能的发布和部署。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/8a4a7a6a39e6/">https://blog.tbf1211.xx.kg/8a4a7a6a39e6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CI-CD/">CI/CD</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7420d7912dc7/" title="CSS 注入 (CSS Injection) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CSS 注入 (CSS Injection) 详解</div></div><div class="info-2"><div class="info-item-1"> CSS 注入 (CSS Injection) 是一种客户端攻击技术，攻击者通过在网页中注入恶意的 Cascading Style Sheets (CSS) 代码，从而实现对页面样式、布局的篡改，甚至是窃取用户信息、进行用户行为监控、绕过某些安全机制等目的。它与常见的 XSS (Cross-Site Scripting) 攻击有所不同，CSS 注入本身不会直接执行 JavaScript 代码，但其危害不容小觑。  CSS 注入通常发生在 Web 应用程序未能正确净化或编码用户提供的输入，并将其不加识别地插入到 HTML &lt;style&gt; 标签、HTML 元素的 style 属性或外部 CSS 文件链接中时。它的强大之处在于能够利用 CSS 选择器和属性的特性，实现一些意想不到的攻击效果。   一、CSS 注入的产生机制CSS 注入的核心在于攻击者能够控制页面中 CSS 的一部分或全部。这通常发生在以下几种情况：  用户输入直接插入 &lt;style&gt; 标签内部：当应用程序允许用户输入的数据直接被渲染到 HTML 页面中的 &lt;style&gt; 标签内部时，...</div></div></div></a><a class="pagination-related" href="/c1538f7d98a1/" title="DevOps 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DevOps 深度解析</div></div><div class="info-2"><div class="info-item-1"> DevOps 是一种文化理念、一套实践和一套工具的集合，旨在缩短系统开发生命周期，同时高质量、持续不断地交付软件。它强调开发 (Development) 团队与运维 (Operations) 团队之间的协作与沟通，通过自动化流程、持续反馈和共享责任，打破传统上这两个团队之间的壁垒。  核心思想：DevOps 不仅仅是工具链，更是一种文化转型。它关注整个软件交付价值流的优化，从构思到最终用户，实现快速、可靠、高质量的软件交付。   一、为什么需要 DevOps？在传统的软件开发模式中（如瀑布模型），开发和运维团队通常是分离的，各自有不同的目标和激励机制：  开发团队：追求快速迭代、新功能发布，偏好频繁变更。 运维团队：追求系统稳定、高可用性，偏好减少变更。  这种分离导致了许多问题：  “推诿墙” (Wall of Confusion)：开发和运维之间缺乏沟通和协作，导致部署和维护阶段出现大量冲突和瓶颈。 发布周期长：软件从开发完成到最终上线需要漫长的测试、部署和配置过程。 部署风险高：由于变更频率低且批次大，每次发布都可能带来巨大的风险。 反馈回路慢：问题发现到解决的周期长，难...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/1beef2825d33/" title="CMake 与 Make：构建系统之辨"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="info-item-2">CMake 与 Make：构建系统之辨</div></div><div class="info-2"><div class="info-item-1"> 在 C&#x2F;C++ 等编译型语言的开发中，构建系统 (Build System) 是将源代码转换成可执行程序、库或其他目标文件的核心环节。CMake 和 Make 是其中两个最常用但职责不同的工具。简单来说，CMake 是一个高级的构建系统生成器 (Build System Generator)，而 Make 是一个低级的构建工具 (Build Tool)，用于执行构建任务。  核心思想：CMake 负责“生成”跨平台的构建配置 (如 Makefile)，而 Make 负责“执行”这些配置来实际编译代码。   一、Make：低级构建工具1.1 什么是 Make？Make 是一个自动化构建工具 (Build Automation Tool)，它的核心职责是读取一个名为 Makefile 的文件，根据文件中定义的规则和依赖关系，执行相应的命令来构建项目。Make 在 Unix&#x2F;Linux 系统上历史悠久且广泛应用，是构建 C&#x2F;C++ 项目的基础工具之一。 1.2 MakefileMakefile 是 Make 工具的配置文件，它定义了：  目标 (Targ...</div></div></div></a><a class="pagination-related" href="/340c8b6e7b0a/" title="SAST (Static Application Security Testing) 工具详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-30</div><div class="info-item-2">SAST (Static Application Security Testing) 工具详解</div></div><div class="info-2"><div class="info-item-1"> SAST (Static Application Security Testing，静态应用安全测试) 是一种白盒 (White-box) 安全测试方法，它通过不执行代码的方式，对应用程序的源代码、字节码或二进制代码进行分析，以识别潜在的安全漏洞和缺陷。SAST 工具旨在开发生命周期 (SDLC) 的早期阶段（“左移”）发现问题，使得开发者可以在发布前修复这些漏洞。  SAST 工具通过深入分析代码逻辑、数据流和控制流，识别出可能导致安全问题的编码模式、配置错误或不安全的API使用。它是 DevSecOps 实践中不可或缺的一部分，能够帮助团队在开发早期以自动化方式持续保障软件质量和安全性。   一、为什么需要 SAST？在现代软件开发流程中，应用程序的复杂性不断增加，发布周期日益缩短。传统的后期安全测试（例如渗透测试）往往在开发周期的末尾进行，此时发现的漏洞修复成本高昂，且可能延误发布。SAST 旨在解决以下问题：  “左移”安全 (Shift-Left Security)：在编码阶段就发现并修复漏洞，避免其进入后续开发阶段，从而降低修复成本和时间。 早期漏洞检测：在不运行代...</div></div></div></a><a class="pagination-related" href="/55b69d9a9473/" title="Ruff 详解：极速 Python 代码检查与格式化工具"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-31</div><div class="info-item-2">Ruff 详解：极速 Python 代码检查与格式化工具</div></div><div class="info-2"><div class="info-item-1"> Ruff 是一个用 Rust 编写的极速 Python 代码检查 (Lint) 和格式化工具。它旨在提供一个高性能的替代方案，结合了 Flake8、isort、Black 等多种工具的功能，以显著提升 Python 项目的代码质量检查和格式化效率。  Ruff 的核心优势在于其极致的速度：由于底层使用 Rust 编写，它比传统的 Python 代码检查工具快 10 到 100 倍，这对于大型项目和 CI&#x2F;CD 流程来说是一个巨大的改进。   一、为什么选择 Ruff？在 Python 开发中，我们通常会使用一系列工具来维护代码质量和风格：  Linter (代码检查器)：如 Flake8、Pylint，用于发现潜在的 bug、代码异味、不遵循最佳实践的代码。 Formatter (代码格式化器)：如 Black、autopep8、YAPF，用于统一代码风格，使其符合 PEP 8 规范。 Import Sorter (导入排序器)：如 isort，用于自动排序和整理 import 语句。  管理和配置这些独立的工具会增加项目的复杂性。Ruff 的出现旨在简化这一过程，将...</div></div></div></a><a class="pagination-related" href="/18a421861554/" title="Golang 项目的 Makefile 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-17</div><div class="info-item-2">Golang 项目的 Makefile 详解</div></div><div class="info-2"><div class="info-item-1"> Makefile 是一种自动化构建工具，它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者管理和自动化项目中的各种任务。尽管 Golang 自身提供了强大的内置工具链 (go build, go test, go run 等)，Makefile 在 Go 项目中依然扮演着重要角色，尤其是在需要协调多个任务、管理复杂构建流程、实现跨平台编译、集成外部工具或自动化部署脚本的场景下。  核心思想：将一系列 go 命令、Shell 脚本以及其他工具的调用封装成可复用的、有依赖关系的任务，实现一键式项目管理和自动化。   一、为什么 Go 项目需要 Makefile？Go 语言的工具链设计得非常出色，go build 能够自动处理依赖，go test 能够运行测试，go run 可以直接运行源代码。那么，为什么我们还需要 Makefile 呢？  任务编排与自动化： 一个 Go 项目通常不仅仅是编译代码。它可能涉及代码格式化 (go fmt)、静态分析 (go vet, golangci-lint)、代码生成 (go generate)、测试、构建 Docker 镜像、部署、清...</div></div></div></a><a class="pagination-related" href="/cf091f115151/" title="GitHub Actions 详解：自动化你的开发工作流"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">GitHub Actions 详解：自动化你的开发工作流</div></div><div class="info-2"><div class="info-item-1"> GitHub Actions 是 GitHub 推出的一项持续集成&#x2F;持续部署 (CI&#x2F;CD) 服务，它允许用户在 GitHub 仓库中直接自动化、自定义和执行软件开发工作流。它可以响应 GitHub 上的各种事件，例如代码推送、Pull Request 创建、Issue 评论等，从而触发一系列自动化任务。通过 GitHub Actions，开发者可以在不离开 GitHub 环境的情况下实现代码的构建、测试、部署、发布等自动化流程，极大地提高了开发效率和质量。  核心思想：将开发流程中的重复性任务自动化，并通过事件驱动的方式集成到 GitHub 生态系统中。   一、为什么需要 GitHub Actions？在现代软件开发中，持续集成 (CI) 和持续部署 (CD) 是不可或缺的实践。它们帮助开发团队：  快速反馈：每次代码提交后立即运行测试，快速发现并修复错误。 提高质量：自动化测试确保代码质量，减少人工错误。 加速交付：自动化构建和部署流程，使软件能够更快地交付到用户手中。 消除重复工作：将重复性的任务（如格式检查、依赖安装、构建、部署）自动化，释放开发人...</div></div></div></a><a class="pagination-related" href="/195d130ae5a4/" title="Ansible 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">Ansible 深度解析</div></div><div class="info-2"><div class="info-item-1"> Ansible 是一个开源的自动化引擎，用于配置管理 (Configuration Management)、应用部署 (Application Deployment)、任务自动化 (Task Automation) 和编排 (Orchestration)。它以其无代理 (Agentless)、简单易用和人性化的特点而广受欢迎。Ansible 使用标准的 SSH 协议连接到目标机器，并使用 YAML 语法编写自动化任务，使得编写、理解和维护自动化脚本变得直观。  核心思想：Ansible 通过 SSH 远程执行操作，无需在被管理节点上安装任何客户端或代理程序。它采用声明式 YAML 语言描述期望的状态，并确保系统达到该状态，同时保证操作的幂等性。   一、为什么选择 Ansible？传统的服务器管理和应用部署往往涉及大量重复、手工且容易出错的任务。随着 IT 基础设施的规模不断扩大，这种手工操作的弊端日益凸显：  效率低下：手动操作耗时且重复。 易出错：人为失误在重复性任务中难以避免。 配置漂移 (Configuration Drift)：不同服务器的配置可能因手工操作而逐渐不一...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%EF%BC%9F"><span class="toc-text">一、为什么需要灰度发布？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、灰度发布的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%98%B6%E6%AE%B5%E5%BC%8F%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B"><span class="toc-text">2.1 阶段式发布流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%B5%81%E9%87%8F%E8%B7%AF%E7%94%B1%E4%B8%8E%E7%94%A8%E6%88%B7%E5%88%86%E6%B5%81%E7%AD%96%E7%95%A5"><span class="toc-text">2.2 流量路由与用户分流策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">三、灰度发布的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%9A%84%E6%8C%91%E6%88%98%E4%B8%8E%E8%80%83%E9%87%8F"><span class="toc-text">四、灰度发布的挑战与考量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E7%9A%84%E5%AE%9E%E6%96%BD%E6%AD%A5%E9%AA%A4-%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97"><span class="toc-text">五、灰度发布的实施步骤 (实践指南)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF"><span class="toc-text">六、常用工具和技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d819fc26cbc7/" title="共识算法详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="共识算法详解"/></a><div class="content"><a class="title" href="/d819fc26cbc7/" title="共识算法详解">共识算法详解</a><time datetime="2026-02-19T22:24:00.000Z" title="发表于 2026-02-20 06:24:00">2026-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1c5cbb334a2a/" title="计算机中熵的详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机中熵的详解"/></a><div class="content"><a class="title" href="/1c5cbb334a2a/" title="计算机中熵的详解">计算机中熵的详解</a><time datetime="2026-02-17T22:24:00.000Z" title="发表于 2026-02-18 06:24:00">2026-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/9ed85cc18e8a/" title="CSP并发模型详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSP并发模型详解"/></a><div class="content"><a class="title" href="/9ed85cc18e8a/" title="CSP并发模型详解">CSP并发模型详解</a><time datetime="2026-02-15T22:24:00.000Z" title="发表于 2026-02-16 06:24:00">2026-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0d177e0002e6/" title="程序错误处理详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序错误处理详解"/></a><div class="content"><a class="title" href="/0d177e0002e6/" title="程序错误处理详解">程序错误处理详解</a><time datetime="2026-02-13T22:24:00.000Z" title="发表于 2026-02-14 06:24:00">2026-02-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-01.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>