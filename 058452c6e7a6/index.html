<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP (Transmission Control Protocol)，即传输控制协议，是 Internet 协议套件 (Internet Protocol Suite) 中的核心协议之一，位于传输层。它提供可靠的、面向连接的、基于字节流的全双工通信服务。TCP 协议确保了数据能够按序、无差错地从一个应用进程传输到另一个应用进程。  核心思想：在不可靠的 IP 层之上，通过一系列机制（如序号、确">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/058452c6e7a6/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="TCP (Transmission Control Protocol)，即传输控制协议，是 Internet 协议套件 (Internet Protocol Suite) 中的核心协议之一，位于传输层。它提供可靠的、面向连接的、基于字节流的全双工通信服务。TCP 协议确保了数据能够按序、无差错地从一个应用进程传输到另一个应用进程。  核心思想：在不可靠的 IP 层之上，通过一系列机制（如序号、确">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg">
<meta property="article:published_time" content="2023-03-09T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-23T09:57:33.174Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="TCP">
<meta property="article:tag" content="2023">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石",
  "url": "https://blog.tbf1211.xx.kg/058452c6e7a6/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg",
  "datePublished": "2023-03-09T22:24:00.000Z",
  "dateModified": "2026-01-23T09:57:33.174Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/058452c6e7a6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">514</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-09T22:24:00.000Z" title="发表于 2023-03-10 06:24:00">2023-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>TCP (Transmission Control Protocol)</strong>，即<strong>传输控制协议</strong>，是 <strong>Internet 协议套件 (Internet Protocol Suite)</strong> 中的核心协议之一，位于<strong>传输层</strong>。它提供<strong>可靠的、面向连接的、基于字节流的全双工通信服务</strong>。TCP 协议确保了数据能够按序、无差错地从一个应用进程传输到另一个应用进程。</p>
</blockquote>
<div class="note info flat"><p>核心思想：在不可靠的 IP 层之上，通过一系列机制（如序号、确认、重传、流量控制、拥塞控制）构建一个高度可靠、有序的数据传输通道。</p>
</div>
<hr>
<h2 id="一、为什么需要-TCP？"><a href="#一、为什么需要-TCP？" class="headerlink" title="一、为什么需要 TCP？"></a>一、为什么需要 TCP？</h2><p>在网络模型中，IP 协议（网络层）提供了<strong>尽力而为 (best-effort)</strong> 的数据报服务，它不保证数据包的到达、顺序或不重复。然而，大多数应用（如网页浏览、文件传输、电子邮件）都需要一个可靠的数据传输服务。TCP 正是为了弥补 IP 协议的这些不足而设计的，它在应用层和网络层之间提供了一个可靠的、虚拟的通信管道。</p>
<p>TCP 的主要职责包括：</p>
<ol>
<li><strong>可靠性</strong>：确保数据无损、无错地到达目的地。</li>
<li><strong>有序性</strong>：确保数据包以正确的顺序交付给接收方。</li>
<li><strong>流量控制</strong>：防止发送方发送数据过快，导致接收方缓冲区溢出。</li>
<li><strong>拥塞控制</strong>：防止发送方发送数据过快，导致网络整体性能下降甚至崩溃。</li>
<li><strong>面向连接</strong>：在数据传输前，发送方和接收方需要建立连接；传输结束后，需要释放连接。</li>
</ol>
<h2 id="二、TCP-报文段结构"><a href="#二、TCP-报文段结构" class="headerlink" title="二、TCP 报文段结构"></a>二、TCP 报文段结构</h2><p>TCP 报文段 (segment) 是 TCP 层进行数据传输的基本单位。每个 TCP 报文段都包含一个 TCP 头部和数据部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| Source Port (16 bits)     | Destination Port (16 bits)    |</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| Sequence Number (32 bits)                                   |</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| Acknowledgment Number (32 bits)                             |</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| Data Offset | Reserved | Flags (9 bits) | Window Size (16 bits)    |</span><br><span class="line">+-------------+----------+----------------+--------------------------+</span><br><span class="line">| Checksum (16 bits)        | Urgent Pointer (16 bits)                |</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| Options (variable, 0-320 bits)                              |</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">| Padding (for 32-bit alignment)                              |</span><br><span class="line">+-------------------------------------------------------------+</span><br><span class="line">|                                                             |</span><br><span class="line">|                          Data (Payload)                     |</span><br><span class="line">|                                                             |</span><br><span class="line">+-------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="2-1-头部字段详解"><a href="#2-1-头部字段详解" class="headerlink" title="2.1 头部字段详解"></a>2.1 头部字段详解</h3><ol>
<li><strong>源端口号 (Source Port, 16 bits)</strong>：发送方的端口号，用于标识发送数据的应用进程。</li>
<li><strong>目的端口号 (Destination Port, 16 bits)</strong>：接收方的端口号，用于标识接收数据的应用进程。</li>
<li><strong>序号 (Sequence Number, 32 bits)</strong>：<ul>
<li>TCP 是面向字节流的，一个 TCP 连接传输的数据流的每个字节都编有序号。</li>
<li>序号字段的值指的是本报文段所发送的数据的<strong>第一个字节的序号</strong>。</li>
<li>用于解决网络包乱序和重复问题。</li>
</ul>
</li>
<li><strong>确认号 (Acknowledgement Number, 32 bits)</strong>：<ul>
<li>期望收到对方下一个报文段的第一个字节的序号。</li>
<li>若确认号为 <code>N</code>，则表示发送方已成功接收到序号 <code>N-1</code> 之前的所有数据。</li>
<li>只有当 ACK 标志位为 1 时，确认号字段才有效。</li>
</ul>
</li>
<li><strong>数据偏移 (Data Offset, 4 bits)</strong>：<ul>
<li>表示 TCP 头部长度，以 4 字节为单位。</li>
<li>最小值为 5 (无选项字段)，最大值为 15 (即 15 * 4 &#x3D; 60 字节)。</li>
</ul>
</li>
<li><strong>保留 (Reserved, 6 bits)</strong>：保留为今后使用，目前必须置为 0。</li>
<li><strong>标志位 (Flags, 6 bits)</strong>：<ul>
<li><strong>URG (Urgent)</strong>：紧急指针有效。表示此报文段包含紧急数据，应优先处理。</li>
<li><strong>ACK (Acknowledgement)</strong>：确认号字段有效。这是最常用的标志。</li>
<li><strong>PSH (Push)</strong>：推送功能。请求接收方立即将数据交付给应用层，而不必等待缓冲区满。</li>
<li><strong>RST (Reset)</strong>：复位连接。用于异常终止连接或拒绝非法的报文段。</li>
<li><strong>SYN (Synchronize)</strong>：同步序号。用于在建立连接时同步序号，即发起连接请求。</li>
<li><strong>FIN (Finish)</strong>：终止连接。用于释放一个连接。</li>
</ul>
</li>
<li><strong>窗口大小 (Window Size, 16 bits)</strong>：<ul>
<li>发送方用于通知接收方，自己当前可接受的<strong>数据量 (字节数)</strong>。</li>
<li>用于实现流量控制，防止发送方发送速度过快导致接收方来不及处理。</li>
</ul>
</li>
<li><strong>校验和 (Checksum, 16 bits)</strong>：<ul>
<li>由发送方计算，接收方验证。</li>
<li>用于检测报文段在传输过程中是否出现差错。</li>
<li>覆盖整个 TCP 报文段 (头部和数据)。</li>
</ul>
</li>
<li><strong>紧急指针 (Urgent Pointer, 16 bits)</strong>：<ul>
<li>只有当 URG 标志位为 1 时才有效。</li>
<li>指出紧急数据在报文段中的偏移量，配合序号字段指示紧急数据结束的位置。</li>
</ul>
</li>
<li><strong>选项 (Options, 可变)</strong>：<ul>
<li>常见选项：最大报文段长度 (MSS)、窗口扩大因子 (Window Scale)、时间戳 (Timestamps)、选择性确认 (SACK) 等。</li>
</ul>
</li>
<li><strong>填充 (Padding, 可变)</strong>：确保 TCP 头部长度是 4 字节的整数倍。</li>
</ol>
<h2 id="三、TCP-的核心机制"><a href="#三、TCP-的核心机制" class="headerlink" title="三、TCP 的核心机制"></a>三、TCP 的核心机制</h2><h3 id="3-1-面向连接：三次握手建立连接-Three-Way-Handshake"><a href="#3-1-面向连接：三次握手建立连接-Three-Way-Handshake" class="headerlink" title="3.1 面向连接：三次握手建立连接 (Three-Way Handshake)"></a>3.1 面向连接：三次握手建立连接 (Three-Way Handshake)</h3><p>在数据传输之前，TCP 需要在客户端和服务器之间建立一个逻辑连接。这个过程通过三次握手完成。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: SYN (seq&#x3D;x)  (第一次握手：客户端发送连接请求)
    Server-&gt;&gt;Client: SYN-ACK (seq&#x3D;y, ack&#x3D;x+1) (第二次握手：服务器确认并发送自己的连接请求)
    Client-&gt;&gt;Server: ACK (ack&#x3D;y+1) (第三次握手：客户端确认，连接建立)
  </pre></div>

<p><strong>步骤详解：</strong></p>
<ol>
<li><strong>SYN (同步)</strong>：客户端发送一个 <code>SYN</code> 报文段，包含一个随机生成的<strong>初始序号 (ISN)</strong> <code>x</code>。客户端进入 <code>SYN_SENT</code> 状态。</li>
<li><strong>SYN-ACK (同步-确认)</strong>：服务器收到 <code>SYN</code> 后，发送一个 <code>SYN-ACK</code> 报文段。其中包含服务器的 ISN <code>y</code>，同时 <code>ACK</code> 字段置 1，<code>确认号</code> 为 <code>x+1</code> (确认已收到客户端的 <code>SYN</code>)。服务器进入 <code>SYN_RCVD</code> 状态。</li>
<li><strong>ACK (确认)</strong>：客户端收到 <code>SYN-ACK</code> 后，发送一个 <code>ACK</code> 报文段。其中 <code>ACK</code> 字段置 1，<code>确认号</code> 为 <code>y+1</code> (确认已收到服务器的 <code>SYN</code>)。客户端和服务器都进入 <code>ESTABLISHED</code> 状态，连接建立成功，可以开始数据传输。</li>
</ol>
<p><strong>为什么是三次握手而不是两次？</strong><br>主要是为了防止<strong>历史连接请求</strong>（旧的重复连接请求报文段）干扰。如果只有两次握手，客户端发送的连接请求在网络中滞留，服务器收到后会回复 ACK。如果客户端在等待 ACK 时超时重发了 SYN，并且之前的 SYN 报文段在网络中游荡了一段时间后也到达服务器，服务器会误认为客户端要建立新的连接，发送 ACK。但此时客户端可能已经关闭了连接，或者正在与另一个服务器通信。这会导致服务器单方面建立一个实际上不存在的连接，浪费资源。三次握手可以确保客户端和服务器都明确对方能够正常收发数据，避免了这种“死锁”情况。</p>
<p><strong>Golang 示例：简单 TCP 客户端和服务器</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;处理新的客户端连接：%s\n&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟数据接收</span></span><br><span class="line">	buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second)) <span class="comment">// 设置读取超时</span></span><br><span class="line">		n, err := conn.Read(buffer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;读取超时，客户端可能已关闭连接：%s\n&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;读取错误：%s, 连接关闭：%s\n&quot;</span>, err.Error(), conn.RemoteAddr().String())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="comment">// 客户端关闭连接</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;客户端已关闭连接：%s\n&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		received := <span class="type">string</span>(buffer[:n])</span><br><span class="line">		fmt.Printf(<span class="string">&quot;从 %s 接收到：%s\n&quot;</span>, conn.RemoteAddr().String(), received)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟数据发送</span></span><br><span class="line">		response := fmt.Sprintf(<span class="string">&quot;服务器收到您的消息：%s&quot;</span>, received)</span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(response))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;写入错误：%s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;连接处理结束：%s\n&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listenAddr := <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, listenAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;无法监听：%s\n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;TCP 服务器正在监听：%s\n&quot;</span>, listenAddr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;接受连接错误：%s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> handleConnection(conn) <span class="comment">// 为每个新连接启动一个 goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	serverAddr := <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, serverAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;连接服务器失败：%s\n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;成功连接到服务器：%s\n&quot;</span>, serverAddr)</span><br><span class="line"></span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Print(<span class="string">&quot;请输入消息 (&#x27;exit&#x27; 退出): &quot;</span>)</span><br><span class="line">		input, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		input = strings.TrimSpace(input)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> input == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;正在关闭连接...&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送数据</span></span><br><span class="line">		_, err = conn.Write([]<span class="type">byte</span>(input))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;发送数据失败：%s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读取服务器响应</span></span><br><span class="line">		conn.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second)) <span class="comment">// 设置读取超时</span></span><br><span class="line">		buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		n, err := conn.Read(buffer)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;读取服务器响应超时&quot;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;读取服务器响应失败：%s\n&quot;</span>, err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;收到服务器响应：%s\n&quot;</span>, <span class="type">string</span>(buffer[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;客户端程序退出。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-可靠数据传输：序号、确认与重传"><a href="#3-2-可靠数据传输：序号、确认与重传" class="headerlink" title="3.2 可靠数据传输：序号、确认与重传"></a>3.2 可靠数据传输：序号、确认与重传</h3><p>TCP 通过以下机制确保数据可靠传输：</p>
<ol>
<li><strong>序号 (Sequence Number)</strong>：<ul>
<li>TCP 为每个发送的字节分配一个序号。报文段中的序号是该报文段第一个数据字节的序号。</li>
<li>接收方使用序号来识别重复的数据包，并按照正确的顺序重新组装乱序的数据包。</li>
</ul>
</li>
<li><strong>确认 (Acknowledgement - ACK)</strong>：<ul>
<li>接收方成功收到数据后，会发送一个确认报文段 (<code>ACK</code> 标志位为 1)，其中包含<strong>期望接收的下一个字节的序号</strong>（即已收到数据最后一个字节的序号加 1）。这被称为<strong>累积确认 (Cumulative ACK)</strong>。</li>
<li>例如，如果收到的 ACK 号为 <code>N</code>，表示 <code>N-1</code> 及其之前的所有数据都已成功接收。</li>
</ul>
</li>
<li><strong>重传 (Retransmission)</strong>：<ul>
<li><strong>超时重传 (Timeout Retransmission)</strong>：发送方发送一个报文段后，会启动一个定时器 (RTO - Retransmission Timeout)。如果在定时器到期前没有收到对应的 ACK，发送方会认为该报文段丢失，并重传该报文段。RTO 是动态计算的，通常基于往返时间 (RTT - Round Trip Time)。</li>
<li><strong>快速重传 (Fast Retransmit)</strong>：当发送方收到<strong>三个重复的 ACK</strong> (即收到了四次对同一个数据包的 ACK) 时，会立即重传丢失的报文段，而不需要等待 RTO 超时。这通常意味着网络中某个报文段丢失了，但后续的报文段到达了接收方。</li>
</ul>
</li>
</ol>
<h3 id="3-3-流量控制-Flow-Control"><a href="#3-3-流量控制-Flow-Control" class="headerlink" title="3.3 流量控制 (Flow Control)"></a>3.3 流量控制 (Flow Control)</h3><p>流量控制是为了防止发送方发送数据过快，导致接收方的缓冲区溢出。TCP 使用<strong>滑动窗口协议 (Sliding Window Protocol)</strong> 来实现流量控制。</p>
<ul>
<li><strong>窗口大小 (Window Size)</strong>：TCP 头部中的 16 位窗口字段，表示接收方当前可接收的字节数。</li>
<li><strong>接收方通告窗口 (Receiver Advertised Window - rwnd)</strong>：接收方在 ACK 报文段中向发送方通告自己的接收缓冲区可用空间大小，即 <code>rwnd</code>。发送方被限制只能发送不超过 <code>rwnd</code> 字节的数据。</li>
<li><strong>零窗口探测 (Zero Window Probe)</strong>：如果接收方通告的窗口大小为 0，发送方会停止发送数据。为了防止接收方窗口一直为 0 导致死锁，发送方会周期性地发送<strong>零窗口探测报文段</strong>，询问接收方窗口是否已打开。</li>
</ul>
<h3 id="3-4-拥塞控制-Congestion-Control"><a href="#3-4-拥塞控制-Congestion-Control" class="headerlink" title="3.4 拥塞控制 (Congestion Control)"></a>3.4 拥塞控制 (Congestion Control)</h3><p>拥塞控制是为了防止过多的数据注入到网络中，导致网络过载，从而降低吞吐量甚至造成网络崩溃。拥塞控制是全局性的，关注整个网络的承载能力；流量控制是端到端的，关注接收方的处理能力。</p>
<p>TCP 拥塞控制主要包括以下四个算法：</p>
<ol>
<li><strong>慢启动 (Slow Start)</strong>：<ul>
<li>连接建立初期，为了避免立即向网络中发送大量数据导致拥塞，发送方会从一个很小的<strong>拥塞窗口 (Congestion Window - <code>cwnd</code>)</strong> 开始。</li>
<li>初始 <code>cwnd</code> 通常为 1-10 MSS (Maximum Segment Size)。</li>
<li>每当收到一个 ACK，<code>cwnd</code> 就会翻倍式增长 (指数增长)。</li>
<li>直到 <code>cwnd</code> 达到<strong>慢启动阈值 (ssthresh)</strong>。</li>
<li>公式表示：<code>cwnd = cwnd * 2</code> (每个 RTT)</li>
</ul>
</li>
<li><strong>拥塞避免 (Congestion Avoidance)</strong>：<ul>
<li>当 <code>cwnd</code> 达到 <code>ssthresh</code> 后，慢启动阶段结束，进入拥塞避免阶段。</li>
<li>此时 <code>cwnd</code> 增长方式变为线性增长：每收到一个 ACK，<code>cwnd</code> 增加 <code>1/cwnd</code> 个 MSS。或者说，每个 RTT 周期 <code>cwnd</code> 增加 1 MSS。</li>
<li>公式表示：<code>cwnd = cwnd + MSS / cwnd</code> (每个 ACK) 或 <code>cwnd = cwnd + MSS</code> (每个 RTT)</li>
</ul>
</li>
<li><strong>快速重传 (Fast Retransmit)</strong>：<ul>
<li>前面提到，当发送方收到<strong>三个重复 ACK</strong> 时，立即重传丢失的报文段。</li>
<li>这表明网络可能发生了轻微的拥塞，但并非严重到需要慢启动。</li>
</ul>
</li>
<li><strong>快速恢复 (Fast Recovery)</strong>：<ul>
<li>与快速重传结合使用。当触发快速重传时（收到 3 个重复 ACK）：<ul>
<li>将 <code>ssthresh</code> 设置为当前 <code>cwnd</code> 的一半。</li>
<li>将 <code>cwnd</code> 设置为 <code>ssthresh</code> + 3 * MSS (因为收到了 3 个重复 ACK，每个 ACK 表示一个报文段离开了网络)。</li>
<li>每收到一个重复 ACK，<code>cwnd</code> 增加 1 MSS。</li>
<li>当收到新的 ACK (确认了重传的数据包)，<code>cwnd</code> 设置为 <code>ssthresh</code>，进入拥塞避免阶段。</li>
</ul>
</li>
<li>如果发生<strong>超时</strong>事件（而不是 3 个重复 ACK），则认为拥塞更严重：<ul>
<li><code>ssthresh</code> 设置为 <code>cwnd</code> 的一半。</li>
<li><code>cwnd</code> 设置为 1 MSS。</li>
<li>重新进入慢启动阶段。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这些算法的协同工作，使得 TCP 能够在网络拥塞时自动调整发送速率，从而维护网络的稳定性和效率。</p>
<h3 id="3-5-全双工通信"><a href="#3-5-全双工通信" class="headerlink" title="3.5 全双工通信"></a>3.5 全双工通信</h3><p>TCP 连接是全双工的，意味着数据可以在两个方向上同时传输。每个方向都拥有独立的发送和接收缓冲区。</p>
<h3 id="3-6-面向字节流"><a href="#3-6-面向字节流" class="headerlink" title="3.6 面向字节流"></a>3.6 面向字节流</h3><p>TCP 不关心应用层发送的数据块边界，它将所有数据视为一个无结构的字节流。当应用进程向 TCP 传输数据时，TCP 会将数据切分成合适的报文段大小 (通常受限于 MSS)，然后向下传递给 IP 层。接收方 TCP 收到数据后，将其放入接收缓冲区，应用进程可以以任意大小读取这些字节。</p>
<h2 id="四、TCP-连接的释放：四次挥手-Four-Way-Handshake"><a href="#四、TCP-连接的释放：四次挥手-Four-Way-Handshake" class="headerlink" title="四、TCP 连接的释放：四次挥手 (Four-Way Handshake)"></a>四、TCP 连接的释放：四次挥手 (Four-Way Handshake)</h2><p>当数据传输完成，双方需要关闭 TCP 连接，这个过程称为四次挥手。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: FIN (seq&#x3D;u) (第一次挥手：客户端通知没有数据要发送了)
    Server-&gt;&gt;Client: ACK (ack&#x3D;u+1) (第二次挥手：服务器确认收到客户端的FIN)
    Note over Server,Client: 服务器可能还有数据要发送，可以继续发送数据
    Server-&gt;&gt;Client: FIN (seq&#x3D;v, ack&#x3D;u+1) (第三次挥手：服务器发送完数据，通知关闭)
    Client-&gt;&gt;Server: ACK (ack&#x3D;v+1) (第四次挥手：客户端确认收到服务器的FIN)
    Note over Client: 客户端进入 TIME_WAIT 状态，等待 2MSL 后关闭
    Note over Server: 服务器收到 ACK 后关闭
  </pre></div>

<p><strong>步骤详解：</strong></p>
<ol>
<li><strong>FIN (终止)</strong>：客户端应用进程通知 TCP 准备关闭连接。客户端发送一个 <code>FIN</code> 报文段，包含一个序号 <code>u</code>。客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li><strong>ACK (确认)</strong>：服务器收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 报文段，<code>确认号</code> 为 <code>u+1</code>。服务器进入 <code>CLOSE_WAIT</code> 状态。此时，服务器仍可以向客户端发送数据（半关闭状态）。</li>
<li><strong>FIN (终止)</strong>：当服务器也没有数据要发送时，服务器应用进程也通知 TCP 准备关闭连接。服务器发送一个 <code>FIN</code> 报文段，包含一个序号 <code>v</code>。服务器进入 <code>LAST_ACK</code> 状态。</li>
<li><strong>ACK (确认)</strong>：客户端收到服务器的 <code>FIN</code> 后，发送一个 <code>ACK</code> 报文段，<code>确认号</code> 为 <code>v+1</code>。客户端进入 <code>TIME_WAIT</code> 状态。<ul>
<li>客户端在 <code>TIME_WAIT</code> 状态会等待 <code>2MSL</code> (Max Segment Lifetime - 最大报文段寿命) 的时间，以确保服务器收到了最后的 ACK 报文段，并处理网络中可能存在的延迟或重传的报文段。</li>
<li>2MSL 之后，客户端才真正关闭连接。</li>
<li>服务器收到最后的 ACK 报文段后，立即关闭连接。</li>
</ul>
</li>
</ol>
<p><strong>为什么是四次挥手而不是三次？</strong><br>因为 TCP 是全双工的，每个方向的传输都需要独立关闭。客户端发送 <code>FIN</code> 只是表示它没有数据要发送了，但服务器可能还有数据要发送给客户端。因此，服务器会先回复一个 <code>ACK</code> (表示收到客户端的关闭请求)，然后等待自己发送完所有数据后，再发送 <code>FIN</code> 请求关闭自己的发送方向。所以，关闭通常需要两个 <code>FIN</code> 和两个 <code>ACK</code>，共四次挥手。</p>
<h2 id="五、TCP-与-UDP-对比"><a href="#五、TCP-与-UDP-对比" class="headerlink" title="五、TCP 与 UDP 对比"></a>五、TCP 与 UDP 对比</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">TCP (传输控制协议)</th>
<th align="left">UDP (用户数据报协议)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>连接类型</strong></td>
<td align="left">面向连接 (Connection-Oriented)</td>
<td align="left">无连接 (Connectionless)</td>
</tr>
<tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left">可靠 (Reliable)：有确认、重传、序号</td>
<td align="left">不可靠 (Unreliable)：无确认、无重传</td>
</tr>
<tr>
<td align="left"><strong>有序性</strong></td>
<td align="left">有序 (Ordered)：保证数据按序到达</td>
<td align="left">无序 (Unordered)：数据可能乱序到达</td>
</tr>
<tr>
<td align="left"><strong>数据边界</strong></td>
<td align="left">面向字节流 (Byte Stream)：无消息边界</td>
<td align="left">面向数据报 (Datagram-Oriented)：保留消息边界</td>
</tr>
<tr>
<td align="left"><strong>流量控制</strong></td>
<td align="left">有 (使用滑动窗口)</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left">有 (慢启动、拥塞避免、快速重传、快速恢复)</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong>头部开销</strong></td>
<td align="left">较大 (至少 20 字节)</td>
<td align="left">较小 (8 字节)</td>
</tr>
<tr>
<td align="left"><strong>速度</strong></td>
<td align="left">较慢 (因可靠性机制和连接建立&#x2F;关闭开销)</td>
<td align="left">较快 (传输效率高)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">文件传输、网页浏览 (HTTP&#x2F;HTTPS)、电子邮件 (SMTP&#x2F;POP3)</td>
<td align="left">实时应用 (视频会议、VoIP)、DNS 查询、网络管理 (SNMP)</td>
</tr>
</tbody></table>
<h2 id="六、安全性考虑"><a href="#六、安全性考虑" class="headerlink" title="六、安全性考虑"></a>六、安全性考虑</h2><p>尽管 TCP 自身提供了可靠性，但它并非天生安全。一些常见的攻击包括：</p>
<ol>
<li><strong>SYN Flood 攻击</strong>：攻击者发送大量伪造源 IP 的 SYN 报文段，使得服务器创建大量半开连接，耗尽资源。</li>
<li><strong>TCP RST 攻击</strong>：攻击者伪造 RST 报文段，强制终止正常的 TCP 连接。</li>
<li><strong>会话劫持 (Session Hijacking)</strong>：攻击者通过窃听 TCP 序号和确认号，伪装成合法用户，劫持现有连接。</li>
<li><strong>IP Spoofing (IP 欺骗)</strong>：攻击者伪造源 IP 地址，但 TCP 的三次握手和序号机制使得伪造完整的连接相对困难。</li>
</ol>
<p>为了增强 TCP 连接的安全性，通常会在应用层或传输层之上使用加密协议，如 <strong>TLS&#x2F;SSL</strong> (Transport Layer Security &#x2F; Secure Sockets Layer)，它提供数据加密、身份认证和消息完整性验证。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>TCP 协议是互联网的基石之一，其复杂而精巧的机制在不可靠的网络环境中构建了可靠、高效的通信服务。它通过序号、确认、重传确保数据无错有序；通过滑动窗口实现流量控制；通过慢启动、拥塞避免等算法实现拥塞控制。理解 TCP 的工作原理对于网络编程、性能优化以及问题排查至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/058452c6e7a6/">https://blog.tbf1211.xx.kg/058452c6e7a6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/TCP/">TCP</a><a class="post-meta__tags" href="/tags/2023/">2023</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/7bd4a820ad36/" title="TCP/IP协议栈深度详解：因特网的核心基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TCP/IP协议栈深度详解：因特网的核心基石</div></div><div class="info-2"><div class="info-item-1"> TCP&#x2F;IP 协议 (Transmission Control Protocol&#x2F;Internet Protocol) 是一组用于互联网通信的协议集合，通常被称为 TCP&#x2F;IP 协议族 (TCP&#x2F;IP Protocol Suite) 或 TCP&#x2F;IP 协议栈 (TCP&#x2F;IP Protocol Stack)。它是现代互联网和局域网 (LAN) 的基石，定义了数据如何在网络中传输、路由和接收。TCP&#x2F;IP 协议族以其分层结构而闻名，将复杂的网络通信任务分解为更小、更易于管理的子任务。  核心思想：将复杂的网络通信过程划分为独立的层次，每层负责特定的功能，并通过协议进行协作，从而实现高效、可靠且可扩展的全球通信。   一、为什么需要 TCP&#x2F;IP 协议？在计算机网络发展的早期，各种网络设备和操作系统拥有各自不兼容的通信协议，导致不同厂商的设备之间难以互联互通。为了解决这一问题，美国国防部高级研究计划局 (ARPA) 资助开发了 ARPANET 项目，并在此基础上逐步发展出了 TCP&#x2F;IP 协议。...</div></div></div></a><a class="pagination-related" href="/af680ba7073c/" title="Go 语言关键字 (Keywords) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go 语言关键字 (Keywords) 详解</div></div><div class="info-2"><div class="info-item-1"> 关键字 (Keywords) 是编程语言中预先定义并具有特殊含义的标识符，它们被语言编译器或解释器保留，用于执行特定的操作或声明特定的结构。在 Go 语言中，关键字的数量相对较少，这种设计哲学旨在保持语言的简洁性和易学性，避免不必要的复杂性。理解 Go 语言的关键字是掌握其语法和语义的基础。  核心思想：Go 语言通过精简的关键字集，实现了强大的功能和清晰的语法结构。每个关键字都承担着明确的职责，共同构建了 Go 简洁高效的编程范式。    一、Go 语言关键字概述Go 语言的关键字总数为 24 个（在 Go 1.0+ 版本中）。它们可以根据其在程序中的作用，大致分为以下几类：  声明 (Declarations)：用于定义程序中的各种元素，如包、引入、变量、常量、函数和自定义类型。 控制流 (Control Flow)：用于控制程序执行的顺序和逻辑，如条件判断、循环、分支和跳转。 并发 (Concurrency)：用于支持 Go 语言内置的并发编程模型。 类型与结构 (Types &amp; Structures)：用于定义复杂的数据类型和接口。 其他特殊目的 (Other ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/c5be75f3ed25/" title="WebSocket 详解：实现全双工实时通信"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="info-item-2">WebSocket 详解：实现全双工实时通信</div></div><div class="info-2"><div class="info-item-1"> WebSocket 是一种在单个 TCP 连接上进行全双工（Full-Duplex）通信的网络协议。它在 Web 浏览器和服务器之间提供了一个持久化的连接，允许双方在任何时候发送消息，而无需像传统的 HTTP 请求那样需要先发送请求再接收响应。WebSocket 解决了传统 Web 应用中实现实时通信的诸多难题，是构建实时 Web 应用的关键技术之一。  核心思想：从 HTTP 协议“握手”后，将底层 TCP 连接“升级”为 WebSocket 连接，实现客户端与服务器之间长时间、双向、无阻塞的消息传输，从而大幅降低通信开销，提升实时应用的性能。   一、为什么需要 WebSocket？传统 HTTP 的局限性在 WebSocket 出现之前，Web 应用程序要实现实时通信，如聊天室、股票行情、在线游戏、推送通知等，面临着传统 HTTP 协议的固有局限性：  半双工 (Half-Duplex) 通信：HTTP 协议是单向请求-响应模型。客户端发送请求，服务器返回响应。服务器无法主动向客户端发送消息，除非客户端先发起请求。 效率低下： 频繁连接建立与断开：每个 HTTP 请求都需...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/33c4660f6509/" title="SSH (Secure Shell) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-07</div><div class="info-item-2">SSH (Secure Shell) 协议详解</div></div><div class="info-2"><div class="info-item-1"> SSH (Secure Shell) 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。  核心思想：通过在不可信网络上建立加密通道，保障客户端与服务器之间通信的机密性、完整性和认证性。   一、为什么需要 SSH？在 SSH 出现之前，远程管理和文件传输主要依赖 Telnet、RSH (Remote Shell)、FTP (File Transfer Protocol) 等协议。这些协议存在严重的安全缺陷：  明文传输：用户名、密码和所有数据在网络中以明文形式传输，极易被窃听。 缺乏认证：无法有效验证远程主机的身份，容易遭受中间人攻击 (Man-in-the-Middle, MITM)。  SSH 的设计目标就是解决这些问题，提供一个安全的替代方案：  数据加密：所有传输数据（包括登录凭证和操作命令）都经过加密，防止窃听。 强大的...</div></div></div></a><a class="pagination-related" href="/65edca489ee4/" title="DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="info-item-2">DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS over TLS (DoT) 和 DNS over HTTPS (DoH) 是旨在增强 DNS (Domain Name System) 查询和响应隐私性 (Privacy) 与安全性 (Security) 的两种协议。它们通过对 DNS 流量进行加密，防止网络中间方（如 ISP、政府机构或恶意攻击者）窥探用户的域名解析请求或篡改 DNS 响应，从而解决了传统 DNS 协议固有的安全和隐私缺陷。  核心思想：将明文传输的 DNS 查询封装到加密的传输层安全 (TLS) 或超文本传输安全 (HTTPS) 连接中，以保护用户隐私、防止 DNS 劫持和对抗网络审查。   一、传统 DNS 的隐私与安全痛点传统的 DNS 协议通常通过 UDP (User Datagram Protocol) 或 TCP (Transmission Control Protocol) 的 53 号端口进行通信。这种通信方式存在以下固有的安全和隐私缺陷：  明文传输 (Plaintext Transmission)：DNS 查询和响应在网络上以明文形式传输。  隐私泄露：任何能够嗅探网络流量的中间...</div></div></div></a><a class="pagination-related" href="/55a0c7732ea3/" title="QUIC (Quick UDP Internet Connections) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="info-item-2">QUIC (Quick UDP Internet Connections) 详解</div></div><div class="info-2"><div class="info-item-1"> QUIC (Quick UDP Internet Connections) 是由 Google 最早开发的一种通用的传输层网络协议，它旨在通过在 UDP 协议之上实现可靠性和安全性来加速 HTTP 流量。QUIC 合并了 TCP、TLS 和 HTTP&#x2F;2 的最佳特性，并针对现代互联网环境进行了优化，解决了 TCP 的一些固有局限性。目前，QUIC 已经由 IETF (Internet Engineering Task Force) 标准化为 RFC 9000 系列，并作为 HTTP&#x2F;3 的底层传输协议。  核心思想：QUIC 将 TCP 连接管理、TLS 加密和 HTTP&#x2F;2 多路复用等功能集成到 UDP 上，通过 0-RTT 连接、独立流、更快的连接迁移和可插拔拥塞控制，实现了低延迟、高吞吐量和强大的安全性。   一、为什么需要 QUIC？尽管 TCP&#x2F;IP 协议栈在过去几十年中支撑了整个互联网，但随着网络应用的发展和移动设备的普及，TCP 的一些固有缺陷逐渐显现出来：  TCP 三次握手延迟 (3-RTT)：每次建立新的 TCP 连接...</div></div></div></a><a class="pagination-related" href="/6479020306f5/" title="HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="info-item-2">HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;3 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 QUIC (Quick UDP Internet Connections) 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全性及在复杂网络环境下的韧性，从而彻底改变 Web 资源的传输方式。  核心思想：HTTP&#x2F;3 运行在 QUIC 协议之上，而 QUIC 又运行在 UDP 协议之上。通过在传输层而非应用层引入多路复用、内置 TLS 1.3 加密、连接迁移等特性，HTTP&#x2F;3 提供了一个比 HTTP&#x2F;2 更快、更稳定、更安全的 Web 体验，尤其在移动网络和有损网络环境下表现突出。   一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景HTTP&#x2F;2 作为 HTTP&#x2F;1.1 的继任者，通过头部压缩、多路复用和服务器推送等机制，显著提升了...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">514</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TCP%EF%BC%9F"><span class="toc-text">一、为什么需要 TCP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TCP-%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="toc-text">二、TCP 报文段结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.1 头部字段详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TCP-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="toc-text">三、TCP 的核心机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%EF%BC%9A%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-Three-Way-Handshake"><span class="toc-text">3.1 面向连接：三次握手建立连接 (Three-Way Handshake)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A%E5%BA%8F%E5%8F%B7%E3%80%81%E7%A1%AE%E8%AE%A4%E4%B8%8E%E9%87%8D%E4%BC%A0"><span class="toc-text">3.2 可靠数据传输：序号、确认与重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-Flow-Control"><span class="toc-text">3.3 流量控制 (Flow Control)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-Congestion-Control"><span class="toc-text">3.4 拥塞控制 (Congestion Control)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">3.5 全双工通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">3.6 面向字节流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE%EF%BC%9A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-Four-Way-Handshake"><span class="toc-text">四、TCP 连接的释放：四次挥手 (Four-Way Handshake)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81TCP-%E4%B8%8E-UDP-%E5%AF%B9%E6%AF%94"><span class="toc-text">五、TCP 与 UDP 对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">六、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-21.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>