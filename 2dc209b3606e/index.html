<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OSI 七层模型详解 (The OSI 7-Layer Model Explained) | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的">
<meta property="og:type" content="article">
<meta property="og:title" content="OSI 七层模型详解 (The OSI 7-Layer Model Explained)">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2dc209b3606e/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="OSI (Open Systems Interconnection) 参考模型 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为七个不同的功能层，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg">
<meta property="article:published_time" content="2023-12-11T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-23T09:57:33.188Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="2023">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OSI 七层模型详解 (The OSI 7-Layer Model Explained)",
  "url": "https://blog.tbf1211.xx.kg/2dc209b3606e/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-31.jpg",
  "datePublished": "2023-12-11T22:24:00.000Z",
  "dateModified": "2026-01-23T09:57:33.188Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2dc209b3606e/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OSI 七层模型详解 (The OSI 7-Layer Model Explained)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">514</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-31.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OSI 七层模型详解 (The OSI 7-Layer Model Explained)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-12-11T22:24:00.000Z" title="发表于 2023-12-12 06:24:00">2023-12-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>OSI (Open Systems Interconnection) 参考模型</strong> 是由国际标准化组织 (ISO) 于 1980 年代初期推出的一套概念性框架，旨在提供一个开放、标准化的通信协议分层结构。它将网络通信过程划分为<strong>七个不同的功能层</strong>，每个层级负责特定的网络通信任务，并向上层提供服务，向下层请求服务。OSI 模型是一个重要的理论基石，帮助人们理解和设计复杂的网络系统，尽管在实际应用中更常见的是 TCP&#x2F;IP 四层或五层模型，但 OSI 模型的分层思想对网络学科产生了深远影响。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将复杂的网络通信过程分解为七个逻辑上独立的功能层，每层只关注自己的职责，通过标准接口与相邻层交互，从而简化网络设计、实现和故障排除。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-OSI-模型？"><a href="#一、为什么需要-OSI-模型？" class="headerlink" title="一、为什么需要 OSI 模型？"></a>一、为什么需要 OSI 模型？</h2><p>在早期，计算机网络发展非常混乱，各个厂商都有自己独有的网络架构和协议，导致不同厂商的设备之间无法通信。为了解决这种“信息孤岛”的问题，急需一个<strong>统一的标准</strong>来指导网络系统的设计和实现。OSI 模型应运而生，其主要目标包括：</p>
<ol>
<li><strong>标准化</strong>：提供一个通用的框架，使得不同厂商、不同系统之间可以进行互操作。</li>
<li><strong>模块化</strong>：将复杂的网络通信过程分解为独立的、易于管理和理解的模块（层），每层只关注自身的特定任务。</li>
<li><strong>互操作性</strong>：促进不同供应商开发的网络产品之间的兼容性。</li>
<li><strong>简化设计</strong>：允许开发者专注于特定层的功能，而不必关心其他层的具体实现细节。</li>
<li><strong>故障排除</strong>：当网络出现问题时，可以逐层排查，更快速地定位问题所在。</li>
<li><strong>学习与教学</strong>：提供一个清晰的网络通信概念框架，便于学习和理解网络技术。</li>
</ol>
<h2 id="二、OSI-七层模型结构及各层功能"><a href="#二、OSI-七层模型结构及各层功能" class="headerlink" title="二、OSI 七层模型结构及各层功能"></a>二、OSI 七层模型结构及各层功能</h2><p>OSI 模型从下到上依次分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。数据在发送端从上层向下层传输，每层会添加自己的<strong>协议头 (Header)</strong> 或帧尾 (Trailer) 进行封装 (Encapsulation)；在接收端则从下层向上层传输，每层剥离 (Decapsulation) 自己的协议头。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[&quot;应用层 (Application Layer)&quot;] -- 提供网络服务给应用程序 --&gt; A_DATA(应用数据)
    P[&quot;表示层 (Presentation Layer)&quot;] -- 数据格式化, 加解密 --&gt; P_DATA(格式化数据)
    S[&quot;会话层 (Session Layer)&quot;] -- 管理会话、同步 --&gt; S_DATA(会话数据)
    T[&quot;传输层 (Transport Layer)&quot;] -- 端到端可靠传输、流量控制 --&gt; T_SEGMENT(段 Segment)
    N[&quot;网络层 (Network Layer)&quot;] -- 逻辑寻址、路由 --&gt; N_PACKET(包 Packet)
    D[&quot;数据链路层 (Data Link Layer)&quot;] -- 物理寻址、帧封装、错误检测 --&gt; D_FRAME(帧 Frame)
    H[&quot;物理层 (Physical Layer)&quot;] -- 传输比特流 --&gt; H_BIT(比特流 Bit)

    A_DATA --&gt; P_DATA
    P_DATA --&gt; S_DATA
    S_DATA --&gt; T_SEGMENT
    T_SEGMENT --&gt; N_PACKET
    N_PACKET --&gt; D_FRAME
    D_FRAME --&gt; H_BIT

    subgraph 发送方
        A
        P
        S
        T
        N
        D
        H
    end

    subgraph 接收方
        H_R[&quot;物理层 (Physical Layer)&quot;] -- 接收比特流 --&gt; H_R_BIT(比特流 Bit)
        D_R[&quot;数据链路层 (Data Link Layer)&quot;] -- 帧解析、错误检测 --&gt; D_R_FRAME(帧 Frame)
        N_R[&quot;网络层 (Network Layer)&quot;] -- 路由、逻辑寻址 --&gt; N_R_PACKET(包 Packet)
        T_R[&quot;传输层 (Transport Layer)&quot;] -- 端到端传输、流控 --&gt; T_R_SEGMENT(段 Segment)
        S_R[&quot;会话层 (Session Layer)&quot;] -- 会话管理、同步 --&gt; S_R_DATA(会话数据)
        P_R[&quot;表示层 (Presentation Layer)&quot;] -- 数据解析、解密 --&gt; P_R_DATA(格式化数据)
        A_R[&quot;应用层 (Application Layer)&quot;] -- 应用程序接收数据 --&gt; A_R_DATA(应用数据)
    end

    H_BIT --&gt; H_R_BIT
    H_R_BIT --&gt; D_R_FRAME
    D_R_FRAME --&gt; N_R_PACKET
    N_R_PACKET --&gt; T_R_SEGMENT
    T_R_SEGMENT --&gt; S_R_DATA
    S_R_DATA --&gt; P_R_DATA
    P_R_DATA --&gt; A_R_DATA
  </pre></div>

<h3 id="2-1-物理层-Physical-Layer-第-1-层"><a href="#2-1-物理层-Physical-Layer-第-1-层" class="headerlink" title="2.1 物理层 (Physical Layer) - 第 1 层"></a>2.1 物理层 (Physical Layer) - 第 1 层</h3><ul>
<li><strong>功能</strong>：定义了传输数据的物理特性、电气特性、机械特性和过程特性。它负责在物理媒体上透明地传输原始的<strong>比特流 (Bits)</strong>。</li>
<li><strong>主要任务</strong>：<ul>
<li>定义传输介质 (网线、光纤、无线电波)。</li>
<li>定义数据编码方式 (如何将比特转换为电信号、光信号等)。</li>
<li>定义传输速率和接口标准 (RJ45、USB 等)。</li>
<li>发送和接收原始比特流。</li>
</ul>
</li>
<li><strong>网络设备</strong>：网卡、集线器 (Hub)、中继器 (Repeater)、调制解调器 (Modem) 等。</li>
<li><strong>协议举例</strong>：EIA&#x2F;TIA-232, V.35, ISDN, DSL 等物理接口标准。</li>
</ul>
<h3 id="2-2-数据链路层-Data-Link-Layer-第-2-层"><a href="#2-2-数据链路层-Data-Link-Layer-第-2-层" class="headerlink" title="2.2 数据链路层 (Data Link Layer) - 第 2 层"></a>2.2 数据链路层 (Data Link Layer) - 第 2 层</h3><ul>
<li><strong>功能</strong>：在不可靠的物理层上建立、维护和终止逻辑连接，将物理层提供的比特流封装成<strong>帧 (Frames)</strong>，并进行错误检测和纠正，提供物理寻址 (MAC 地址)。它负责在直接相连的节点之间可靠地传输数据。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>帧的封装和解封装</strong>：将网络层的数据报封装成帧，添加帧头和帧尾。</li>
<li><strong>物理寻址 (MAC 寻址)</strong>：根据 MAC 地址识别网络中的设备。</li>
<li><strong>错误检测和纠正</strong>：通过 CRC 校验码等机制检测传输错误。</li>
<li><strong>流量控制</strong>：调节发送速率，避免接收方溢出。</li>
<li><strong>访问控制</strong>：协调多个设备对共享物理介质的访问 (如 CSMA&#x2F;CD)。</li>
</ul>
</li>
<li><strong>子层</strong>：逻辑链路控制 (LLC) 和媒体访问控制 (MAC)。</li>
<li><strong>网络设备</strong>：网桥 (Bridge)、交换机 (Switch)、网卡。</li>
<li><strong>协议举例</strong>：Ethernet (以太网)、PPP (点对点协议)、HDLC (高级数据链路控制)。</li>
</ul>
<h3 id="2-3-网络层-Network-Layer-第-3-层"><a href="#2-3-网络层-Network-Layer-第-3-层" class="headerlink" title="2.3 网络层 (Network Layer) - 第 3 层"></a>2.3 网络层 (Network Layer) - 第 3 层</h3><ul>
<li><strong>功能</strong>：负责对数据包进行<strong>逻辑寻址 (IP 地址)</strong>，实现不同网络之间的<strong>路由 (Routing)</strong>。它确保数据包能够从源主机传输到目的主机，即使它们不在同一个局域网中。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>逻辑寻址</strong>：使用 IP 地址唯一标识网络中的设备。</li>
<li><strong>路由选择</strong>：根据路由表决定数据包转发的最佳路径。</li>
<li><strong>拥塞控制</strong>：试图避免网络拥塞。</li>
<li><strong>分包与重组</strong>：将过大的数据包分割成小块以适应底层网络，并在接收端重新组装。</li>
</ul>
</li>
<li><strong>数据单元</strong>：数据包 (Packet)。</li>
<li><strong>网络设备</strong>：路由器 (Router)、三层交换机。</li>
<li><strong>协议举例</strong>：IP (Internet Protocol)、ICMP (Internet Control Message Protocol)、ARP (Address Resolution Protocol)。</li>
</ul>
<h3 id="2-4-传输层-Transport-Layer-第-4-层"><a href="#2-4-传输层-Transport-Layer-第-4-层" class="headerlink" title="2.4 传输层 (Transport Layer) - 第 4 层"></a>2.4 传输层 (Transport Layer) - 第 4 层</h3><ul>
<li><strong>功能</strong>：提供<strong>端到端 (End-to-End)</strong> 的可靠或不可靠数据传输服务。它负责将应用层的数据分成更小的<strong>段 (Segments)</strong>，并在接收端重新组装，确保数据完整、有序地到达正确的应用程序。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>端到端连接管理</strong>：建立、维护和终止连接。</li>
<li><strong>分段与重组</strong>：将应用数据分割成合适的段，并在接收端重新组装。</li>
<li><strong>面向连接或无连接传输</strong>：<ul>
<li><strong>TCP (Transmission Control Protocol)</strong>：提供可靠的、面向连接的传输，保证数据有序、无差错地到达。</li>
<li><strong>UDP (User Datagram Protocol)</strong>：提供不可靠的、无连接的传输，效率高但不管数据是否到达。</li>
</ul>
</li>
<li><strong>端口寻址</strong>：通过端口号识别不同的应用程序。</li>
<li><strong>流量控制</strong>：调节发送方发送数据的速率，防止淹没接收方。</li>
<li><strong>差错控制</strong>：检测并纠正传输错误（对于 TCP）。</li>
</ul>
</li>
<li><strong>数据单元</strong>：段 (Segment) 或数据报 (Datagram)。</li>
<li><strong>协议举例</strong>：TCP、UDP。</li>
</ul>
<h3 id="2-5-会话层-Session-Layer-第-5-层"><a href="#2-5-会话层-Session-Layer-第-5-层" class="headerlink" title="2.5 会话层 (Session Layer) - 第 5 层"></a>2.5 会话层 (Session Layer) - 第 5 层</h3><ul>
<li><strong>功能</strong>：管理和协调应用程序之间的会话（通信链路）。它负责建立、管理和终止应用程序之间的对话，提供数据交换的同步点。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>会话的建立、管理和终止</strong>。</li>
<li><strong>对话控制</strong>：决定是双向同时通信 (全双工) 还是轮流通信 (半双工)。</li>
<li><strong>同步与恢复</strong>：在数据流中插入同步点，当发生故障时，可以从最近的同步点恢复会话，避免重新传输所有数据。</li>
</ul>
</li>
<li><strong>数据单元</strong>：通常是会话消息。</li>
<li><strong>协议举例</strong>：NetBIOS, RPC (远程过程调用), AppleTalk Session Protocol (ASP)。在现代网络中，这部分功能常由传输层或应用层协议来隐式处理。</li>
</ul>
<h3 id="2-6-表示层-Presentation-Layer-第-6-层"><a href="#2-6-表示层-Presentation-Layer-第-6-层" class="headerlink" title="2.6 表示层 (Presentation Layer) - 第 6 层"></a>2.6 表示层 (Presentation Layer) - 第 6 层</h3><ul>
<li><strong>功能</strong>：处理两个通信系统之间的数据表示方式，确保应用程序之间可以理解彼此的数据格式。它负责数据<strong>格式化、数据加密&#x2F;解密、数据压缩&#x2F;解压缩</strong>等。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>数据格式化</strong>：将应用程序的数据转换为标准格式，或将标准格式转换回应用程序的特定格式 (如 ASCII, EBCDIC, JPEG, MPEG)。</li>
<li><strong>数据加密和解密</strong>：保护数据传输的安全性。</li>
<li><strong>数据压缩和解压缩</strong>：减少传输数据量，提高传输效率。</li>
</ul>
</li>
<li><strong>数据单元</strong>：表示层消息。</li>
<li><strong>协议举例</strong>：JPEG, MPEG, ASCII, EBCDIC, SSL&#x2F;TLS (部分功能如加密&#x2F;解密)。</li>
</ul>
<h3 id="2-7-应用层-Application-Layer-第-7-层"><a href="#2-7-应用层-Application-Layer-第-7-层" class="headerlink" title="2.7 应用层 (Application Layer) - 第 7 层"></a>2.7 应用层 (Application Layer) - 第 7 层</h3><ul>
<li><strong>功能</strong>：OSI 模型的最高层，直接为用户的<strong>应用程序</strong>提供网络服务。它定义了应用程序如何与网络进行交互，提供用户与网络之间的接口。</li>
<li><strong>主要任务</strong>：<ul>
<li><strong>用户接口</strong>：与应用程序直接交互，提供各种网络应用服务。</li>
<li><strong>资源访问</strong>：如文件传输、电子邮件、远程登录、Web 浏览等。</li>
<li><strong>网络服务</strong>：DNS (域名系统)、HTTP (超文本传输协议)、FTP (文件传输协议)、SMTP (简单邮件传输协议) 等。</li>
</ul>
</li>
<li><strong>数据单元</strong>：应用层数据。</li>
<li><strong>协议举例</strong>：HTTP, FTP, SMTP, POP3, IMAP, DNS, Telnet, SSH, SNMP。</li>
</ul>
<h2 id="三、数据传输过程中的封装与解封装"><a href="#三、数据传输过程中的封装与解封装" class="headerlink" title="三、数据传输过程中的封装与解封装"></a>三、数据传输过程中的封装与解封装</h2><p>当数据从发送方流向接收方时，会经历一个<strong>封装 (Encapsulation)</strong> 和<strong>解封装 (Decapsulation)</strong> 的过程：</p>
<p><strong>发送方 (Encapsulation)</strong>：</p>
<ol>
<li><strong>应用层</strong>：应用程序数据 (Data)。</li>
<li><strong>表示层&#x2F;会话层</strong>：对数据进行格式化、压缩、加密等处理，形成 <code>数据</code>。</li>
<li><strong>传输层</strong>：将数据分割成小块，添加 TCP&#x2F;UDP <strong>Header</strong>，形成<strong>段 (Segment)</strong> &#x2F; <strong>数据报 (Datagram)</strong>。</li>
<li><strong>网络层</strong>：为段&#x2F;数据报添加 IP <strong>Header</strong> (包含源&#x2F;目的 IP 地址)，形成<strong>包 (Packet)</strong>。</li>
<li><strong>数据链路层</strong>：为包添加 MAC <strong>Header</strong> (包含源&#x2F;目的 MAC 地址) 和 <strong>Trailer</strong> (CRC 校验)，形成<strong>帧 (Frame)</strong>。</li>
<li><strong>物理层</strong>：将帧转换为原始的<strong>比特流</strong>，通过物理介质发送出去。</li>
</ol>
<p><strong>接收方 (Decapsulation)</strong>：</p>
<ol>
<li><strong>物理层</strong>：接收比特流，重新组装成<strong>帧</strong>。</li>
<li><strong>数据链路层</strong>：检查帧头帧尾、CRC 校验，剥离 MAC <code>Header</code> 和 <code>Trailer</code>，将剩下的<strong>包</strong>交给网络层。</li>
<li><strong>网络层</strong>：检查 IP <code>Header</code>，根据目的 IP 地址判断是否发给自己，剥离 IP <code>Header</code>，将剩下的<strong>段</strong>交给传输层。</li>
<li><strong>传输层</strong>：检查 TCP&#x2F;UDP <code>Header</code>，根据端口号识别目标应用程序，剥离 TCP&#x2F;UDP <code>Header</code>，将重新组装好的<strong>数据</strong>交给会话层。</li>
<li><strong>会话层&#x2F;表示层</strong>：进行解密、解压缩、数据格式转换等操作。</li>
<li><strong>应用层</strong>：应用程序接收最终处理好的<strong>数据</strong>。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    App_Data(应用数据)
    Transport_Segment(传输层段)&lt;--TCP&#x2F;UDP Header--&gt;App_Data
    Network_Packet(网络层包)&lt;--IP Header--&gt;Transport_Segment
    DataLink_Frame(数据链路层帧)&lt;--MAC Header + Trailer--&gt;Network_Packet
    Physical_Bits(物理层比特流)&lt;--编码--&gt;DataLink_Frame

    subgraph &quot;Data Flow (发送方)&quot;
        App_Data --[应用层]--&gt; Transport_Segment
        Transport_Segment --[传输层]--&gt; Network_Packet
        Network_Packet --[网络层]--&gt; DataLink_Frame
        DataLink_Frame --[数据链路层]--&gt; Physical_Bits
    end

    subgraph &quot;Data Flow (接收方)&quot;
        Physical_Bits_R(物理层比特流) --&gt; DataLink_Frame_R
        DataLink_Frame_R(数据链路层帧) --&gt; Network_Packet_R
        Network_Packet_R(网络层包) --&gt; Transport_Segment_R
        Transport_Segment_R(传输层段) --&gt; App_Data_R
        App_Data_R(应用数据)

        Physical_Bits_R --[物理层]--&gt; DataLink_Frame_R
        DataLink_Frame_R --[数据链路层]--&gt; Network_Packet_R
        Network_Packet_R --[网络层]--&gt; Transport_Segment_R
        Transport_Segment_R --[传输层]--&gt; App_Data_R
    end
  </pre></div>

<h2 id="四、与-TCP-IP-模型的比较"><a href="#四、与-TCP-IP-模型的比较" class="headerlink" title="四、与 TCP&#x2F;IP 模型的比较"></a>四、与 TCP&#x2F;IP 模型的比较</h2><p>尽管 OSI 模型是理论标准，但在实际网络中，广泛使用的是更为简洁的 <strong>TCP&#x2F;IP 模型</strong>。TCP&#x2F;IP 模型通常被描述为四层或五层：</p>
<p><strong>TCP&#x2F;IP 四层模型 (简化版)</strong></p>
<ol>
<li><strong>应用层 (Application Layer)</strong>：对应 OSI 的应用层、表示层、会话层。</li>
<li><strong>传输层 (Transport Layer)</strong>：对应 OSI 的传输层。</li>
<li><strong>网络层 (Internet Layer)</strong>：对应 OSI 的网络层。</li>
<li><strong>网络接口层 (Network Access Layer)</strong>：对应 OSI 的数据链路层和物理层。</li>
</ol>
<p><strong>TCP&#x2F;IP 五层模型 (常用版)</strong></p>
<ol>
<li><strong>应用层 (Application Layer)</strong>：对应 OSI 的应用层、表示层、会话层 (例如 HTTP, FTP, DNS)。</li>
<li><strong>传输层 (Transport Layer)</strong>：对应 OSI 的传输层 (例如 TCP, UDP)。</li>
<li><strong>网络层 (Network Layer)</strong>：对应 OSI 的网络层 (例如 IP, ICMP)。</li>
<li><strong>数据链路层 (Data Link Layer)</strong>：对应 OSI 的数据链路层 (例如 Ethernet, PPP)。</li>
<li><strong>物理层 (Physical Layer)</strong>：对应 OSI 的物理层。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">OSI 模型</th>
<th align="left">TCP&#x2F;IP 五层模型</th>
<th align="left">TCP&#x2F;IP 四层模型</th>
<th align="left">主要协议&#x2F;数据单元</th>
<th align="left">典型设备</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7. 应用层 (Application)</td>
<td align="left">5. 应用层 (Application)</td>
<td align="left">4. 应用层 (Application)</td>
<td align="left">HTTP, FTP, SMTP, DNS, SSH &#x2F; 数据</td>
<td align="left">主机&#x2F;客户端</td>
</tr>
<tr>
<td align="left">6. 表示层 (Presentation)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">SSL&#x2F;TLS (部分), JPEG, MPEG &#x2F; 数据</td>
<td align="left">主机&#x2F;客户端</td>
</tr>
<tr>
<td align="left">5. 会话层 (Session)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">NetBIOS, RPC &#x2F; 数据</td>
<td align="left">主机&#x2F;客户端</td>
</tr>
<tr>
<td align="left">4. 传输层 (Transport)</td>
<td align="left">4. 传输层 (Transport)</td>
<td align="left">3. 传输层 (Transport)</td>
<td align="left">TCP, UDP &#x2F; 段 (Segment)</td>
<td align="left">主机&#x2F;操作系统</td>
</tr>
<tr>
<td align="left">3. 网络层 (Network)</td>
<td align="left">3. 网络层 (Network)</td>
<td align="left">2. 网际层 (Internet)</td>
<td align="left">IP, ICMP, ARP &#x2F; 包 (Packet)</td>
<td align="left">路由器</td>
</tr>
<tr>
<td align="left">2. 数据链路层 (Data Link)</td>
<td align="left">2. 数据链路层 (Data Link)</td>
<td align="left">1. 网络接口层 (Network Access)</td>
<td align="left">Ethernet, PPP, MAC &#x2F; 帧 (Frame)</td>
<td align="left">交换机、网卡</td>
</tr>
<tr>
<td align="left">1. 物理层 (Physical)</td>
<td align="left">1. 物理层 (Physical)</td>
<td align="left"></td>
<td align="left">各种物理介质、RJ45, USB &#x2F; 比特 (Bit)</td>
<td align="left">集线器、中继器</td>
</tr>
</tbody></table>
<p><strong>为什么 TCP&#x2F;IP 模型更常用？</strong></p>
<ul>
<li><strong>实用性</strong>：TCP&#x2F;IP 是在互联网的兴起中实际应用的协议栈，它更注重工程实现而非理论上的完美划分。</li>
<li><strong>简洁性</strong>：TCP&#x2F;IP 模型将 OSI 的上三层合并为一层，下两层合并为一层，减少了层数，使得模型更简洁易懂。</li>
<li><strong>灵活性</strong>：TCP&#x2F;IP 模型不严格区分表示层和会话层，其功能通常由应用层协议自身或传输层协议的扩展来处理。</li>
</ul>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>OSI 七层模型作为网络通信的理论基石，提供了一个理解复杂网络功能的标准化框架。它将网络通信过程划分为七个逻辑清晰的层级，每个层级负责不同的任务，并通过接口与相邻层交互。尽管在实际应用中 TCP&#x2F;IP 模型更为流行，但 OSI 模型的分层思想，如封装、解封装、模块化和抽象，仍然是网络学习和理解不可或缺的重要概念。理解 OSI 模型有助于开发者、网络管理员更好地设计、部署、维护和排查网络系统，是所有网络专业人士的必备知识。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2dc209b3606e/">https://blog.tbf1211.xx.kg/2dc209b3606e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/2023/">2023</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/5d5f7c78ff8d/" title="五层因特网协议栈深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">五层因特网协议栈深度详解</div></div><div class="info-2"><div class="info-item-1"> 五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。  核心思想：将互联网的通信过程划分为五个逻辑层级，自顶向下依次为应用层、传输层、网络层、数据链路层和物理层，每层负责不同的通信职责，协同工作以实现全球互联。   一、为什么选择五层协议栈？尽管 OSI 七层模型提供了非常详细的理论分层，但由于其设计时在标准制定上花费了大量时间，并且部分层次划分在实际实现中显得过于细致，导致其未能大规模落地。相反，TCP&#x2F;IP 协议族在互联网的早期发展中迅速崛起并成为事实标准。五层协议栈结合了二者的优点：  实用性：它直接反映了 TCP&#x2F;IP 协议族栈的工作方式，是互联网实际运行的写照。 简洁性：相比 OSI 七层模型，它将 OSI 的...</div></div></div></a><a class="pagination-related" href="/f19c839c8b2e/" title="BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">BBR 算法 (Bottleneck Bandwidth and Round-trip Propagation Time) 详解</div></div><div class="info-2"><div class="info-item-1"> BBR (Bottleneck Bandwidth and Round-trip Propagation Time) 是由 Google 开发的一种 TCP 拥塞控制算法。与传统的基于丢包的拥塞控制算法（如 Cubic, Reno）不同，BBR 专注于测量网络瓶颈带宽 (Bottleneck Bandwidth) 和往返传播时间 (Round-trip Propagation Time)，并以此为基础来控制发送速率，旨在达到高吞吐量和低延迟的最佳平衡。  核心思想：基于带宽和 RTT 测量，而不是丢包，来探知网络的实际容量，从而更精准地控制发送速率，避免不必要的丢包，并充分利用带宽。   一、为什么需要 BBR？传统的 TCP 拥塞控制算法（如 Cubic、Reno）主要依赖于丢包作为网络拥塞的信号。它们的工作原理是：  不断增加发送窗口，直到出现丢包。 丢包发生后，认为网络拥塞，降低发送窗口。 循环往复，形成“锯齿状”的发送速率。  这种基于丢包的机制存在以下问题：  “缓冲区膨胀” (Bufferbloat)： 现代网络设备通常拥有较大的缓冲区。当网络开始拥塞时，数据包不会...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/c5be75f3ed25/" title="WebSocket 详解：实现全双工实时通信"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="info-item-2">WebSocket 详解：实现全双工实时通信</div></div><div class="info-2"><div class="info-item-1"> WebSocket 是一种在单个 TCP 连接上进行全双工（Full-Duplex）通信的网络协议。它在 Web 浏览器和服务器之间提供了一个持久化的连接，允许双方在任何时候发送消息，而无需像传统的 HTTP 请求那样需要先发送请求再接收响应。WebSocket 解决了传统 Web 应用中实现实时通信的诸多难题，是构建实时 Web 应用的关键技术之一。  核心思想：从 HTTP 协议“握手”后，将底层 TCP 连接“升级”为 WebSocket 连接，实现客户端与服务器之间长时间、双向、无阻塞的消息传输，从而大幅降低通信开销，提升实时应用的性能。   一、为什么需要 WebSocket？传统 HTTP 的局限性在 WebSocket 出现之前，Web 应用程序要实现实时通信，如聊天室、股票行情、在线游戏、推送通知等，面临着传统 HTTP 协议的固有局限性：  半双工 (Half-Duplex) 通信：HTTP 协议是单向请求-响应模型。客户端发送请求，服务器返回响应。服务器无法主动向客户端发送消息，除非客户端先发起请求。 效率低下： 频繁连接建立与断开：每个 HTTP 请求都需...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/55a0c7732ea3/" title="QUIC (Quick UDP Internet Connections) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="info-item-2">QUIC (Quick UDP Internet Connections) 详解</div></div><div class="info-2"><div class="info-item-1"> QUIC (Quick UDP Internet Connections) 是由 Google 最早开发的一种通用的传输层网络协议，它旨在通过在 UDP 协议之上实现可靠性和安全性来加速 HTTP 流量。QUIC 合并了 TCP、TLS 和 HTTP&#x2F;2 的最佳特性，并针对现代互联网环境进行了优化，解决了 TCP 的一些固有局限性。目前，QUIC 已经由 IETF (Internet Engineering Task Force) 标准化为 RFC 9000 系列，并作为 HTTP&#x2F;3 的底层传输协议。  核心思想：QUIC 将 TCP 连接管理、TLS 加密和 HTTP&#x2F;2 多路复用等功能集成到 UDP 上，通过 0-RTT 连接、独立流、更快的连接迁移和可插拔拥塞控制，实现了低延迟、高吞吐量和强大的安全性。   一、为什么需要 QUIC？尽管 TCP&#x2F;IP 协议栈在过去几十年中支撑了整个互联网，但随着网络应用的发展和移动设备的普及，TCP 的一些固有缺陷逐渐显现出来：  TCP 三次握手延迟 (3-RTT)：每次建立新的 TCP 连接...</div></div></div></a><a class="pagination-related" href="/33c4660f6509/" title="SSH (Secure Shell) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-07</div><div class="info-item-2">SSH (Secure Shell) 协议详解</div></div><div class="info-2"><div class="info-item-1"> SSH (Secure Shell) 是一种加密的网络协议，用于在不安全的网络上安全地进行远程操作。它提供了一种强大的、加密的方式来访问远程计算机、执行命令、传输文件，并提供端口转发、X11 转发等多种功能。SSH 旨在替代 Telnet、FTP、RSH 等传统的不安全协议，因为这些协议在传输过程中不进行加密，容易受到窃听和中间人攻击。  核心思想：通过在不可信网络上建立加密通道，保障客户端与服务器之间通信的机密性、完整性和认证性。   一、为什么需要 SSH？在 SSH 出现之前，远程管理和文件传输主要依赖 Telnet、RSH (Remote Shell)、FTP (File Transfer Protocol) 等协议。这些协议存在严重的安全缺陷：  明文传输：用户名、密码和所有数据在网络中以明文形式传输，极易被窃听。 缺乏认证：无法有效验证远程主机的身份，容易遭受中间人攻击 (Man-in-the-Middle, MITM)。  SSH 的设计目标就是解决这些问题，提供一个安全的替代方案：  数据加密：所有传输数据（包括登录凭证和操作命令）都经过加密，防止窃听。 强大的...</div></div></div></a><a class="pagination-related" href="/378a51590e55/" title="HTTP&#x2F;1.1 协议深度详解：Web 通信的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="info-item-2">HTTP&#x2F;1.1 协议深度详解：Web 通信的基石</div></div><div class="info-2"><div class="info-item-1"> HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。  核心思想：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于请求-响应模型，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。   一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：  短连接 (Short Connection)：HTTP&#x2F;1.0 默认每个请求&#x2F;响应...</div></div></div></a><a class="pagination-related" href="/bfc3178a0093/" title="FRP (Fast Reverse Proxy) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="info-item-2">FRP (Fast Reverse Proxy) 详解</div></div><div class="info-2"><div class="info-item-1"> FRP (Fast Reverse Proxy) 是一个高性能的内网穿透和反向代理工具，它允许您将位于内网（局域网）中的服务（如 Web 服务器、SSH、数据库等）通过一台具有公网 IP 的服务器暴露给公网用户访问。在当前 IPv4 地址资源日益紧张，许多家庭和小型办公室难以获取公网 IP 的背景下，FRP 提供了便捷、高效的解决方案。  核心思想：FRP 通过在公网服务器上运行一个 frps (服务端) 和在内网机器上运行一个 frpc (客户端) 来建立连接。内网流量经由 frpc 转发到 frps，再由 frps 转发到公网用户，实现内网服务的公网访问。   一、为什么需要 FRP？在许多场景下，我们需要从外部网络访问位于内网的服务，但常常面临以下问题：  没有公网 IP：大多数家庭宽带用户和一些小型企业用户不再拥有独立的公网 IPv4 地址。他们处于运营商的 NAT (Network Address Translation) 之后，无法直接从外部访问内网设备。 端口转发困难：即使有公网 IP，也可能需要手动在路由器上配置端口转发规则，这对于不熟悉网络配置的用户来说可能比...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">514</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">228</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-OSI-%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">一、为什么需要 OSI 模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%8A%E5%90%84%E5%B1%82%E5%8A%9F%E8%83%BD"><span class="toc-text">二、OSI 七层模型结构及各层功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%89%A9%E7%90%86%E5%B1%82-Physical-Layer-%E7%AC%AC-1-%E5%B1%82"><span class="toc-text">2.1 物理层 (Physical Layer) - 第 1 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-Data-Link-Layer-%E7%AC%AC-2-%E5%B1%82"><span class="toc-text">2.2 数据链路层 (Data Link Layer) - 第 2 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%BD%91%E7%BB%9C%E5%B1%82-Network-Layer-%E7%AC%AC-3-%E5%B1%82"><span class="toc-text">2.3 网络层 (Network Layer) - 第 3 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%A0%E8%BE%93%E5%B1%82-Transport-Layer-%E7%AC%AC-4-%E5%B1%82"><span class="toc-text">2.4 传输层 (Transport Layer) - 第 4 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%BC%9A%E8%AF%9D%E5%B1%82-Session-Layer-%E7%AC%AC-5-%E5%B1%82"><span class="toc-text">2.5 会话层 (Session Layer) - 第 5 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%A1%A8%E7%A4%BA%E5%B1%82-Presentation-Layer-%E7%AC%AC-6-%E5%B1%82"><span class="toc-text">2.6 表示层 (Presentation Layer) - 第 6 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%BA%94%E7%94%A8%E5%B1%82-Application-Layer-%E7%AC%AC-7-%E5%B1%82"><span class="toc-text">2.7 应用层 (Application Layer) - 第 7 层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%B0%81%E8%A3%85"><span class="toc-text">三、数据传输过程中的封装与解封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%8E-TCP-IP-%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">四、与 TCP&#x2F;IP 模型的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-31.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>