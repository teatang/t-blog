<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kafka 详解 (Apache Kafka Explained) | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Apache Kafka 是一个开源的分布式流处理平台。它最初由 LinkedIn 开发并于 2011 年开源，后来成为 Apache 基金会的顶级项目。Kafka 的核心特性是能够以高吞吐量、低延迟的方式处理实时数据流，并支持数据的持久化、发布&#x2F;订阅模式以及容错性。它不仅仅是一个消息队列，更是作为一个分布式提交日志 (Distributed Commit Log)，提供高可靠性、高可">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka 详解 (Apache Kafka Explained)">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/527bcf16e9a1/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Apache Kafka 是一个开源的分布式流处理平台。它最初由 LinkedIn 开发并于 2011 年开源，后来成为 Apache 基金会的顶级项目。Kafka 的核心特性是能够以高吞吐量、低延迟的方式处理实时数据流，并支持数据的持久化、发布&#x2F;订阅模式以及容错性。它不仅仅是一个消息队列，更是作为一个分布式提交日志 (Distributed Commit Log)，提供高可靠性、高可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg">
<meta property="article:published_time" content="2024-09-28T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-30T03:20:58.353Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="云服务">
<meta property="article:tag" content="消息队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kafka 详解 (Apache Kafka Explained)",
  "url": "https://blog.tbf1211.xx.kg/527bcf16e9a1/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-19.jpg",
  "datePublished": "2024-09-28T22:24:00.000Z",
  "dateModified": "2026-01-30T03:20:58.353Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/527bcf16e9a1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kafka 详解 (Apache Kafka Explained)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-19.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Kafka 详解 (Apache Kafka Explained)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kafka 详解 (Apache Kafka Explained)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-09-28T22:24:00.000Z" title="发表于 2024-09-29 06:24:00">2024-09-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Apache Kafka</strong> 是一个开源的分布式流处理平台。它最初由 LinkedIn 开发并于 2011 年开源，后来成为 Apache 基金会的顶级项目。Kafka 的核心特性是能够以<strong>高吞吐量、低延迟</strong>的方式处理实时数据流，并支持数据的<strong>持久化</strong>、<strong>发布&#x2F;订阅模式</strong>以及<strong>容错性</strong>。它不仅仅是一个消息队列，更是作为一个<strong>分布式提交日志 (Distributed Commit Log)</strong>，提供高可靠性、高可伸缩性的数据管道，用于构建实时流应用程序和数据集成。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将数据流处理抽象为发布者向主题发送消息，消费者从主题拉取消息，并通过集群提供持久化、可伸缩性和容错性。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-Kafka？"><a href="#一、为什么需要-Kafka？" class="headerlink" title="一、为什么需要 Kafka？"></a>一、为什么需要 Kafka？</h2><p>传统的分布式消息队列，如 RabbitMQ，更多地被设计用于点对点通信或处理少量消息。但在大数据和实时流处理场景下，它们往往面临性能瓶颈、数据丢失、扩展性差等问题。Kafka 的出现旨在解决这些挑战：</p>
<ol>
<li><strong>高吞吐量 (High Throughput)</strong>：能够处理每秒百万级的消息，这对于日志收集、用户活动跟踪等大数据场景至关重要。</li>
<li><strong>低延迟 (Low Latency)</strong>：消息从生产者发送到消费者之间的平均延迟通常在几毫秒内。</li>
<li><strong>高并发</strong>：支持数千个生产者和消费者客户端同时读写。</li>
<li><strong>持久性与可靠性 (Durability &amp; Reliability)</strong>：消息被持久化到磁盘，并通过多副本机制保证数据不丢失，即使部分节点故障也能自动恢复。</li>
<li><strong>可伸缩性 (Scalability)</strong>：通过横向扩展集群，可以轻松应对数据量的增长。</li>
<li><strong>分布式与容错性 (Distributed &amp; Fault-Tolerant)</strong>：Kafka 集群由多个 Broker 组成，并通过 Zookeeper 进行协调和管理，单个节点的故障不会导致数据丢失或服务中断。</li>
<li><strong>实时流处理</strong>：不仅仅是传统的消息队列，更是一个流平台，支持实时数据管道、流处理应用。</li>
<li><strong>解耦</strong>：生产者和消费者之间完全解耦，无需知道对方的存在。</li>
<li><strong>回溯能力 (Replayability)</strong>：消费者可以从主题中的任何一个偏移量 (Offset) 开始消费消息，这对于数据重处理、调试和回溯历史数据非常有价值。</li>
</ol>
<h2 id="二、Kafka-的核心概念"><a href="#二、Kafka-的核心概念" class="headerlink" title="二、Kafka 的核心概念"></a>二、Kafka 的核心概念</h2><p>要理解 Kafka，需要掌握以下几个关键概念：</p>
<h3 id="2-1-生产者-Producer"><a href="#2-1-生产者-Producer" class="headerlink" title="2.1 生产者 (Producer)"></a>2.1 生产者 (Producer)</h3><p>生产者负责创建消息并将其发布 (Publish) 到 Kafka 集群中的<strong>主题 (Topic)</strong>。</p>
<ul>
<li>生产者可以将消息发送到特定主题的分区 (Partition)，也可以让 Kafka 自动选择分区（如通过消息键的哈希值）。</li>
<li>消息发送可以是同步的或异步的。</li>
<li>默认情况下，生产者会进行消息压缩，减少网络传输和存储开销。</li>
</ul>
<h3 id="2-2-消费者-Consumer"><a href="#2-2-消费者-Consumer" class="headerlink" title="2.2 消费者 (Consumer)"></a>2.2 消费者 (Consumer)</h3><p>消费者订阅 (Subscribe) 一个或多个主题，并且从这些主题中拉取 (Pull) 消息。</p>
<ul>
<li><strong>消费者组 (Consumer Group)</strong>：多个消费者可以组成一个消费者组，共同消费一个主题。在同一个消费者组内，每个分区只能被组内的一个消费者消费。这样可以实现负载均衡和容错，提高消费能力。</li>
<li><strong>偏移量 (Offset)</strong>：消费者在每个分区中都有一个偏移量，记录了它已经消费到的消息的位置。Kafka 会定期将这些偏移量提交到内部主题 <code>__consumer_offsets</code> 中，以便在消费者重启后能够从上次消费的位置继续。</li>
<li><strong>拉取模式</strong>：Kafka 采用拉取 (Pull) 模型，消费者主动从 Broker 拉取消息，而不是 Broker 推送消息给消费者。这允许消费者根据自身处理能力控制拉取速率。</li>
</ul>
<h3 id="2-3-消息-Message-Record"><a href="#2-3-消息-Message-Record" class="headerlink" title="2.3 消息 (Message&#x2F;Record)"></a>2.3 消息 (Message&#x2F;Record)</h3><p>Kafka 中的消息是字节数组，可以包含键 (Key)、值 (Value) 和时间戳 (Timestamp)。</p>
<ul>
<li><strong>键 (Key)</strong>：可选字段。如果提供键，所有具有相同键的消息将被发送到同一个分区。这对于需要保证消息顺序的场景非常重要。</li>
<li><strong>值 (Value)</strong>：消息的主要内容。</li>
<li><strong>时间戳 (Timestamp)</strong>：消息创建或存储的时间。</li>
</ul>
<h3 id="2-4-主题-Topic"><a href="#2-4-主题-Topic" class="headerlink" title="2.4 主题 (Topic)"></a>2.4 主题 (Topic)</h3><p>主题是 Kafka 中消息的类别或名称。生产者向主题发布消息，消费者从主题订阅消息。</p>
<ul>
<li>主题是逻辑概念，用于将消息进行分类。</li>
<li>每个主题可以被划分为一个或多个<strong>分区 (Partition)</strong>。</li>
</ul>
<h3 id="2-5-分区-Partition"><a href="#2-5-分区-Partition" class="headerlink" title="2.5 分区 (Partition)"></a>2.5 分区 (Partition)</h3><p>分区是主题物理上的概念，是 Kafka 能够实现高吞吐量和可伸缩性的关键。</p>
<ul>
<li><strong>并行度</strong>：每个分区是一个有序的、不可变的消息序列。生产者将消息追加到分区末尾，消费者从分区头部读取。</li>
<li><strong>消息顺序</strong>：Kafka 只保证一个分区内的消息顺序，不保证跨分区的消息顺序。</li>
<li><strong>分布式</strong>：一个主题的多个分区可以分布在 Kafka 集群的不同 Broker 上。</li>
<li><strong>副本 (Replica)</strong>：每个分区都可以有多个副本，分布在不同的 Broker 上。这提供了数据的持久性和容错性。</li>
</ul>
<h3 id="2-6-副本-Replica-与-主导者-Leader-、追随者-Follower"><a href="#2-6-副本-Replica-与-主导者-Leader-、追随者-Follower" class="headerlink" title="2.6 副本 (Replica) 与 主导者 (Leader)、追随者 (Follower)"></a>2.6 副本 (Replica) 与 主导者 (Leader)、追随者 (Follower)</h3><ul>
<li><strong>副本</strong>：分区的副本是其消息序列的完整拷贝。</li>
<li><strong>主分区 (Leader Partition)</strong>：每个分区都指定一个副本作为主分区，所有的生产者和消费者都只与主分区进行交互（读写）。</li>
<li><strong>从分区 (Follower Partition)</strong>：其他副本作为从分区，它们异步地从主分区复制数据。</li>
<li><strong>容错性</strong>：如果主分区所在的 Broker 发生故障，Kafka 会从剩余的从分区中选举一个新的主分区，确保服务不中断。</li>
</ul>
<h3 id="2-7-Broker-代理"><a href="#2-7-Broker-代理" class="headerlink" title="2.7 Broker (代理)"></a>2.7 Broker (代理)</h3><p>Broker 是 Kafka 集群中的一个节点，负责存储分区的数据，并处理生产者和消费者的请求。</p>
<ul>
<li>一个 Kafka 集群由一个或多个 Broker 组成。</li>
<li>每个 Broker 都有一个唯一的 ID。</li>
<li>每个 Broker 包含一部分主题的分区。</li>
</ul>
<h3 id="2-8-ZooKeeper"><a href="#2-8-ZooKeeper" class="headerlink" title="2.8 ZooKeeper"></a>2.8 ZooKeeper</h3><p>Kafka 使用 Apache ZooKeeper 来协调和管理其集群。</p>
<ul>
<li><strong>集群元数据管理</strong>：存储 Kafka 集群的元数据，如 Broker 注册信息、主题和分区配置、Leader 选举结果等。</li>
<li><strong>Leader 选举</strong>：当任何分区的主分区所在 Broker 宕机时，ZooKeeper 负责协调选举新的主分区。</li>
<li><strong>故障检测</strong>：Broker 通过与 ZooKeeper 保持心跳来汇报健康状态。</li>
<li><strong>消费者组管理</strong>：旧版本 Kafka 使用 ZooKeeper 存储消费者组的偏移量。新版本 Kafka (0.那之后) 使用 Kafka 内部主题 <code>__consumer_offsets</code> 管理偏移量。</li>
</ul>
<h2 id="三、Kafka-架构概览"><a href="#三、Kafka-架构概览" class="headerlink" title="三、Kafka 架构概览"></a>三、Kafka 架构概览</h2><p>Kafka 集群由多个 Broker 节点组成，通常由 ZooKeeper 集群协助管理。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph Kafka Cluster
        B1[&quot;Broker 1 (ID: 1)&quot;]
        B2[&quot;Broker 2 (ID: 2)&quot;]
        B3[&quot;Broker 3 (ID: 3)&quot;]
    end

    subgraph ZooKeeper Cluster
        Z1[&quot;Zookeeper 1&quot;]
        Z2[&quot;Zookeeper 2&quot;]
        Z3[&quot;Zookeeper 3&quot;]
    end

    P[Producer]--&gt;|Publish Messages| T1_L(Topic1: Partition0 Leader)
    P--&gt;|Publish Messages| T1_L(Topic1: Partition1 Leader)
    P--&gt;|Publish Messages| T2_L(Topic2: Partition0 Leader)

    T1_L --&gt; B1
    T1_L --&gt; B2
    T2_L --&gt; B3

    subgraph Consumer Group A
        CGA1[Consumer A1]
        CGA2[Consumer A2]
    end

    subgraph Consumer Group B
        CGB1[Consumer B1]
    end

    CGA1&#x3D;&#x3D;&gt;|Consume Partition 0| T1_L
    CGA2&#x3D;&#x3D;&gt;|Consume Partition 1| T1_L
    CGB1&#x3D;&#x3D;&gt;|Consume All Partitions| T2_L

    B1 --replication--&gt; T1_F(Topic1: Partition0 Follower)
    B2 --replication--&gt; T1_F
    B3 --replication--&gt; T1_F

    B1 --- Z1
    B2 --- Z2
    B3 --- Z3
  </pre></div>

<p><strong>架构解释：</strong></p>
<ol>
<li><strong>生产者 (Producer)</strong>：生产消息发送到指定主题。它们只与主题的主分区 (Leader Partition) 进行通信。</li>
<li><strong>主题 (Topic)</strong>：逻辑上组织消息的分类。</li>
<li><strong>分区 (Partition)</strong>：每个主题被划分为一个或多个分区。每个分区是一个独立的、有序的、不可变的消息序列。</li>
<li><strong>Broker</strong>：Kafka 服务器。每个分区可以有多个副本分散在不同的 Broker 上，其中一个副本是主分区 (Leader)，其他是从分区 (Follower)。</li>
<li><strong>消费者组 (Consumer Group)</strong>：多个消费者可以组成一个消费者组来消费一个主题。在同一个组内，每个分区只能由一个消费者消费。不同消费者组可以独立消费同一个主题的所有消息。</li>
<li><strong>ZooKeeper</strong>：用于管理 Kafka 集群的元数据、执行 Leader 选举等协调任务。</li>
</ol>
<h2 id="四、Kafka-的数据流和可靠性"><a href="#四、Kafka-的数据流和可靠性" class="headerlink" title="四、Kafka 的数据流和可靠性"></a>四、Kafka 的数据流和可靠性</h2><h3 id="4-1-生产者发送消息"><a href="#4-1-生产者发送消息" class="headerlink" title="4.1 生产者发送消息"></a>4.1 生产者发送消息</h3><ul>
<li>生产者将消息发送到主题的某个分区。</li>
<li>如果设置了消息键 (Key)，Kafka 会使用键的哈希值来决定发送到哪个分区，以保证相同键的消息进入同一分区，从而保证消息的局部有序性。</li>
<li><strong>acks 配置</strong>：生产者可以配置 <code>acks</code> 参数来控制消息的可靠性：<ul>
<li><code>acks=0</code>：生产者发送消息后，不等待 Broker 确认。吞吐量最高，但可靠性最低，可能丢失消息。</li>
<li><code>acks=1</code>：生产者等待主分区写入消息成功后返回确认。吞吐量和可靠性适中，主分区宕机可能丢失消息（如果未同步到从分区）。</li>
<li><code>acks=all</code> (或 <code>-1</code>)：生产者等待主分区以及所有同步从分区 (ISR - In-Sync Replicas) 都成功写入消息后才返回确认。可靠性最高，吞吐量最低。</li>
</ul>
</li>
</ul>
<h3 id="4-2-消息持久化和副本机制"><a href="#4-2-消息持久化和副本机制" class="headerlink" title="4.2 消息持久化和副本机制"></a>4.2 消息持久化和副本机制</h3><ul>
<li>消息一旦写入主分区，就会被立即持久化到磁盘。</li>
<li>从分区会持续从主分区拉取消息并同步数据。</li>
<li><strong>ISR (In-Sync Replicas)</strong>：是一个动态的列表，包含了与主分区保持同步的从分区。只有当消息被主分区和所有 ISR 中的从分区都确认写入后，才被认为是“已提交”的消息，可以被消费者消费。</li>
<li><strong>容错性</strong>：如果主分区宕机，会从 ISR 中选择一个新的主分区。如果所有副本都宕机，则该分区不可用。</li>
</ul>
<h3 id="4-3-消费者消费消息"><a href="#4-3-消费者消费消息" class="headerlink" title="4.3 消费者消费消息"></a>4.3 消费者消费消息</h3><ul>
<li>消费者通过轮询 (Poll) 的方式从其分配的分区中拉取消息。</li>
<li>消费者会定期提交其已消费消息的偏移量 (Offset) 到 Kafka 内部的 <code>__consumer_offsets</code> 主题中。</li>
<li>这样，即使消费者重启，也能从上次提交的偏移量处继续消费，避免重复消费或漏消费。</li>
</ul>
<h2 id="五、Kafka-的优缺点与适用场景"><a href="#五、Kafka-的优缺点与适用场景" class="headerlink" title="五、Kafka 的优缺点与适用场景"></a>五、Kafka 的优缺点与适用场景</h2><h3 id="5-1-优点："><a href="#5-1-优点：" class="headerlink" title="5.1 优点："></a>5.1 优点：</h3><ol>
<li><strong>高吞吐量、低延迟</strong>：适合处理大规模实时数据流。</li>
<li><strong>高并发</strong>：支持大量生产者和消费者。</li>
<li><strong>高可靠性和持久性</strong>：消息持久化到磁盘，多副本机制确保数据不丢失。</li>
<li><strong>高可伸缩性</strong>：水平扩展 Broker 节点和分区副本轻松应对数据增长。</li>
<li><strong>分布式，易于容错</strong>：Broker 故障自动恢复，不影响服务。</li>
<li><strong>消费者组设计</strong>：灵活的消费者模型，支持发布&#x2F;订阅和点对点模式。</li>
<li><strong>消息回溯能力</strong>：消费者可以从任意偏移量开始重新消费。</li>
<li><strong>生态系统丰富</strong>：与 Spark、Flink、Hadoop 等大数据工具集成紧密。</li>
</ol>
<h3 id="5-2-缺点："><a href="#5-2-缺点：" class="headerlink" title="5.2 缺点："></a>5.2 缺点：</h3><ol>
<li><strong>操作复杂性</strong>：部署和运维一个高可用的 Kafka 集群需要专业知识，依赖于 ZooKeeper 增加了复杂性。</li>
<li><strong>无法直接删除消息</strong>：消息是追加写入的日志，只能通过设置保留策略 (Retention Policy) 自动删除过期消息。</li>
<li><strong>消息严格有序性仅限于分区内</strong>：无法保证主题范围内消息的全局有序性。</li>
<li><strong>数据重复消费的可能性</strong>：在某些故障场景下，消费者提交偏移量可能失败，导致重启后重复消费一部分消息（需要消费者端实现幂等性）。</li>
<li><strong>不适合小文件存储</strong>：虽然消息可以存储文件数据，但 Kafka 的优势在于流式数据，不适合作为文件存储系统。</li>
</ol>
<h3 id="5-3-适用场景："><a href="#5-3-适用场景：" class="headerlink" title="5.3 适用场景："></a>5.3 适用场景：</h3><ul>
<li><strong>实时数据管道 (Real-time Data Pipelines)</strong>：将不同系统（数据库、传感器、日志文件等）的数据实时抽取、传输到数据仓库、Hadoop 或其他系统。</li>
<li><strong>日志收集与聚合 (Log Aggregation)</strong>：收集服务器、应用日志，集中处理和分析。</li>
<li><strong>用户活动跟踪 (User Activity Tracking)</strong>：记录用户在网站、APP 上的行为，用于实时分析、个性化推荐。</li>
<li><strong>指标监控 (Metrics &amp; Monitoring)</strong>：收集各种系统和应用性能指标，进行实时监控和报警。</li>
<li><strong>流式处理 (Stream Processing)</strong>：与 Apache Flink、Spark Streaming 等流处理框架结合，构建实时数据分析应用。</li>
<li><strong>事件源 (Event Sourcing)</strong>：作为应用状态变更的事件日志。</li>
<li><strong>消息系统 (Messaging System)</strong>：替代传统消息队列，用于服务间的异步通信和解耦。</li>
</ul>
<h2 id="六、代码示例-Python"><a href="#六、代码示例-Python" class="headerlink" title="六、代码示例 (Python)"></a>六、代码示例 (Python)</h2><p>以下是一个使用 Python <code>kafka-python</code> 库进行 Kafka 生产者和消费者操作的简化示例。</p>
<p>首先，确保你已经安装了 <code>kafka-python</code> 库：<br><code>pip install kafka-python</code></p>
<p>并确保你的 Kafka 和 ZooKeeper 是运行状态。例如，你可以使用 Docker:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure>
<p>(其中 <code>docker-compose.yml</code> 包含 Kafka 和 Zookeeper 的定义)</p>
<p><strong>Kafka 生产者 (<code>kafka_producer.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">KAFKA_BROKER = <span class="string">&#x27;localhost:9092&#x27;</span></span><br><span class="line">TOPIC_NAME = <span class="string">&#x27;my_test_topic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_producer</span>():</span><br><span class="line">    producer = KafkaProducer(</span><br><span class="line">        bootstrap_servers=[KAFKA_BROKER],</span><br><span class="line">        value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">&#x27;utf-8&#x27;</span>), <span class="comment"># 序列化为JSON</span></span><br><span class="line">        acks=<span class="string">&#x27;all&#x27;</span> <span class="comment"># 确保消息可靠性</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">producer, message_value, message_key=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> message_key:</span><br><span class="line">            <span class="comment"># 键也需要序列化</span></span><br><span class="line">            key_bytes = <span class="built_in">str</span>(message_key).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            future = producer.send(TOPIC_NAME, key=key_bytes, value=message_value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            future = producer.send(TOPIC_NAME, value=message_value)</span><br><span class="line"></span><br><span class="line">        record_metadata = future.get(timeout=<span class="number">10</span>) <span class="comment"># 阻塞等待发送成功</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] Message sent successfully!&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Topic: <span class="subst">&#123;record_metadata.topic&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Partition: <span class="subst">&#123;record_metadata.partition&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Offset: <span class="subst">&#123;record_metadata.offset&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  Value: <span class="subst">&#123;message_value&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error sending message: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    producer = create_producer()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Kafka Producer connected to <span class="subst">&#123;KAFKA_BROKER&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sending messages to topic: <span class="subst">&#123;TOPIC_NAME&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        msg_key = <span class="string">f&quot;user_<span class="subst">&#123;i % <span class="number">2</span>&#125;</span>&quot;</span> <span class="comment"># 模拟两个用户，用于演示分区局部有序性</span></span><br><span class="line">        msg_value = &#123;<span class="string">&quot;id&quot;</span>: i, <span class="string">&quot;timestamp&quot;</span>: time.time(), <span class="string">&quot;data&quot;</span>: <span class="string">f&quot;test message <span class="subst">&#123;i&#125;</span>&quot;</span>&#125;</span><br><span class="line">        send_message(producer, msg_value, msg_key)</span><br><span class="line">        time.sleep(<span class="number">1</span>) <span class="comment"># 每秒发送一条消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送一个没有 key 的消息</span></span><br><span class="line">    send_message(producer, &#123;<span class="string">&quot;event_type&quot;</span>: <span class="string">&quot;no_key_event&quot;</span>, <span class="string">&quot;data&quot;</span>: <span class="string">&quot;This message might go to any partition&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    producer.flush() <span class="comment"># 确保所有待发送消息都已发送</span></span><br><span class="line">    producer.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Producer closed.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Kafka 消费者 (<code>kafka_consumer.py</code>)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">KAFKA_BROKER = <span class="string">&#x27;localhost:9092&#x27;</span></span><br><span class="line">TOPIC_NAME = <span class="string">&#x27;my_test_topic&#x27;</span></span><br><span class="line">CONSUMER_GROUP_ID = <span class="string">&#x27;my_temp_consumer_group&#x27;</span> <span class="comment"># 消费者组ID，用于区分不同的消费进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_consumer</span>():</span><br><span class="line">    consumer = KafkaConsumer(</span><br><span class="line">        TOPIC_NAME,</span><br><span class="line">        bootstrap_servers=[KAFKA_BROKER],</span><br><span class="line">        group_id=CONSUMER_GROUP_ID, <span class="comment"># 标识消费者组</span></span><br><span class="line">        auto_offset_reset=<span class="string">&#x27;earliest&#x27;</span>, <span class="comment"># 从最早的可用偏移量开始消费，如果是新的组，会从头消费</span></span><br><span class="line">        enable_auto_commit=<span class="literal">True</span>, <span class="comment"># 自动提交偏移量</span></span><br><span class="line">        auto_commit_interval_ms=<span class="number">1000</span>, <span class="comment"># 每秒自动提交一次</span></span><br><span class="line">        value_deserializer=<span class="keyword">lambda</span> x: json.loads(x.decode(<span class="string">&#x27;utf-8&#x27;</span>)), <span class="comment"># 反序列化JSON</span></span><br><span class="line">        key_deserializer=<span class="keyword">lambda</span> x: x.decode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">if</span> x <span class="keyword">else</span> <span class="literal">None</span> <span class="comment"># 反序列化 key</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> consumer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consume_messages</span>(<span class="params">consumer</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Kafka Consumer connected to <span class="subst">&#123;KAFKA_BROKER&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Consuming messages from topic: <span class="subst">&#123;TOPIC_NAME&#125;</span>, group: <span class="subst">&#123;CONSUMER_GROUP_ID&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> consumer:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[<span class="subst">&#123;time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)&#125;</span>] Received message:&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  Topic: <span class="subst">&#123;message.topic&#125;</span>, Partition: <span class="subst">&#123;message.partition&#125;</span>, Offset: <span class="subst">&#123;message.offset&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  Key: <span class="subst">&#123;message.key&#125;</span>, Value: <span class="subst">&#123;message.value&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 模拟消息处理</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>) </span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nConsumer interrupted. Shutting down...&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error consuming messages: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        consumer.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Consumer closed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    consumer = create_consumer()</span><br><span class="line">    consume_messages(consumer)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行步骤：</strong></p>
<ol>
<li>启动 Kafka 和 ZooKeeper (例如用 Docker Compose)。</li>
<li>在一个终端运行生产者：<code>python kafka_producer.py</code></li>
<li>在另一个终端运行消费者：<code>python kafka_consumer.py</code></li>
</ol>
<p>你会看到生产者发送消息并打印出其分区和偏移量，消费者则接收并打印这些消息。尝试运行多个消费者实例，但使用相同的 <code>CONSUMER_GROUP_ID</code>，你会发现它们会共同消费主题的负载，每个分区只被一个消费者处理。如果使用不同的 <code>CONSUMER_GROUP_ID</code>，它们将独立消费主题的所有消息。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Kafka 凭借其独特的设计理念和强大的功能，已经成为大数据和实时流处理领域的基石。它不仅仅是一个高性能的消息队列，更是一个能够处理数万亿事件的分布式流处理平台。无论是作为数据中心间的数据管道、日志聚合系统，还是实时事件流的中心枢纽，Kafka 都展现出卓越的性能和稳定性。深入理解其核心概念，合理地设计和部署 Kafka 集群，是构建现代分布式系统不可或缺的一部分。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/527bcf16e9a1/">https://blog.tbf1211.xx.kg/527bcf16e9a1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-19.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/17997196b139/" title="现代医学与传统医学详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">现代医学与传统医学详解</div></div><div class="info-2"><div class="info-item-1"> 当我们谈论医疗健康时，常常会提到“现代医学”和“传统医学”这两个概念。它们代表着两种截然不同的理论体系、诊疗方法和哲学观念。理解这两种医学的异同及其各自的优势与局限性，有助于我们更全面、理性地看待疾病与健康，并做出更适合自己的健康选择。  核心思想：现代医学以实证科学为基础，注重微观层面、精准诊断和靶向治疗；传统医学则立足于数千年的实践经验，强调宏观视角、整体观念和个体化调理。两者并非相互排斥，而是可以在不同层面、不同阶段互补共赢。   一、现代医学 (Western Medicine &#x2F; Allopathic Medicine)1.1 概念与发展现代医学，通常指以西方科学为基础发展起来的医学体系，也被称为西医、生物医学或对抗疗法。它在17世纪科学革命之后逐渐成形，并在20世纪取得了飞速发展，尤其是在分子生物学、病理学、药理学、影像学等领域取得突破后，形成了以循证医学为核心的科学实践体系。 1.2 核心特点 科学基础与实证： 以科学为基础：依赖物理、化学、生物学等自然科学理论，通过实验、数据分析和临床试验来验证其理论和疗效。 循证医学 (Evidence-Based ...</div></div></div></a><a class="pagination-related" href="/cab4ffe9ff8f/" title="ZooKeeper 详解 (Apache ZooKeeper Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ZooKeeper 详解 (Apache ZooKeeper Explained)</div></div><div class="info-2"><div class="info-item-1"> Apache ZooKeeper 是一个开源的分布式协调服务，用于管理大型分布式系统中的配置信息、命名服务、提供分布式同步以及组服务。它提供了一个高性能、高可用且具有强一致性的文件系统式数据模型，帮助开发者更轻松地构建可靠的分布式应用程序。简单的说，ZooKeeper 就像是分布式系统的“管家”或“协调员”，负责处理分布式应用程序中常见但又难以正确实现的协调任务。  核心思想：提供一个类似于文件系统的、高性能的、一致的分布式数据存储，以及一套事件通知机制，用于协调分布式系统中的各个节点。   一、为什么需要 ZooKeeper？在分布式系统中，由于网络延迟、节点故障、并发访问等复杂性，协调各个节点以达成一致性是一个巨大的挑战。传统上，开发者需要自行实现各种复杂的协议来解决这些问题，这不仅耗时耗力，而且极易出错。ZooKeeper 的出现正是为了解决这些痛点：  一致性问题：在分布式环境中，如何保证所有节点对某个共享配置或状态的看法是一致的？ZooKeeper 提供强一致性保证。 可用性问题：部分节点故障时，如何确保协调服务仍然可用？ZooKeeper 通过集群部署和 Leade...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6842deb76626/" title="AWS Lambda与Serverless详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-13</div><div class="info-item-2">AWS Lambda与Serverless详解</div></div><div class="info-2"><div class="info-item-1"> AWS Lambda 是亚马逊网络服务 (Amazon Web Services, AWS) 提供的核心 Serverless 计算服务，也是函数即服务 (Function-as-a-Service, FaaS) 的开创者和领导者。它允许开发者运行代码，而无需配置或管理服务器。开发者只需上传代码，Lambda 会自动处理运行代码所需的一切，包括容量预置、扩展、打补丁和维护。  核心思想：AWS Lambda 是 AWS Serverless 生态的核心，它将代码作为“函数”运行在无服务器环境中，由各种 AWS 事件触发，按需执行，自动伸缩，并按实际使用量计费。   一、AWS Lambda 概览AWS Lambda 于 2014 年推出，彻底改变了云计算的开发和部署模式。它让开发者能够将后端逻辑解耦为一系列独立、短生命周期的函数，从而极大地简化了运维。 1.1 Lambda 的核心概念 函数 (Function)：这是 Lambda 中的基本部署单元，包含你的代码和相关配置（如运行时、内存、超时时间、环境变量）。 事件 (Event)：触发 Lambda 函数执行的任何操作。事...</div></div></div></a><a class="pagination-related" href="/cc0334bd16dd/" title="Vercel介绍"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">Vercel介绍</div></div><div class="info-2"><div class="info-item-1"> Vercel 是一家领先的前端云 (Frontend Cloud) 平台，专注于为前端开发者提供极速的部署、自动化的CI&#x2F;CD、全球化的内容分发 (CDN) 和 Serverless 功能。它以其与 Next.js 框架的深度集成而闻名，旨在帮助开发者以最快速度将 Web 项目从构思变为全球可用的产品，同时提供卓越的性能和开发者体验。  核心思想：Vercel 是一个将前端部署、构建、Hosting 和 Serverless 后端能力融为一体的平台，特别优化了 Next.js 等现代化框架的开发和部署流程，让开发者能够专注于代码，无需管理基础设施。   一、为什么选择 Vercel？在现代 Web 开发中，前端项目的部署和运维变得越来越复杂：  构建优化：代码打包、压缩、Tree Shaking。 性能优化：CDN 分发、图片优化、SEO 优化。 开发体验：持续集成&#x2F;持续部署 (CI&#x2F;CD)、预览部署、分支管理。 后端需求：API 路由、Server-Side Rendering (SSR)、数据获取等，需要 Serverless 或 Node.j...</div></div></div></a><a class="pagination-related" href="/cab4ffe9ff8f/" title="ZooKeeper 详解 (Apache ZooKeeper Explained)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-27</div><div class="info-item-2">ZooKeeper 详解 (Apache ZooKeeper Explained)</div></div><div class="info-2"><div class="info-item-1"> Apache ZooKeeper 是一个开源的分布式协调服务，用于管理大型分布式系统中的配置信息、命名服务、提供分布式同步以及组服务。它提供了一个高性能、高可用且具有强一致性的文件系统式数据模型，帮助开发者更轻松地构建可靠的分布式应用程序。简单的说，ZooKeeper 就像是分布式系统的“管家”或“协调员”，负责处理分布式应用程序中常见但又难以正确实现的协调任务。  核心思想：提供一个类似于文件系统的、高性能的、一致的分布式数据存储，以及一套事件通知机制，用于协调分布式系统中的各个节点。   一、为什么需要 ZooKeeper？在分布式系统中，由于网络延迟、节点故障、并发访问等复杂性，协调各个节点以达成一致性是一个巨大的挑战。传统上，开发者需要自行实现各种复杂的协议来解决这些问题，这不仅耗时耗力，而且极易出错。ZooKeeper 的出现正是为了解决这些痛点：  一致性问题：在分布式环境中，如何保证所有节点对某个共享配置或状态的看法是一致的？ZooKeeper 提供强一致性保证。 可用性问题：部分节点故障时，如何确保协调服务仍然可用？ZooKeeper 通过集群部署和 Leade...</div></div></div></a><a class="pagination-related" href="/487df70cf615/" title="Vercel Serverless Functions 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="info-item-2">Vercel Serverless Functions 深度详解</div></div><div class="info-2"><div class="info-item-1"> Vercel Serverless Functions 是 Vercel 平台的核心服务之一，它允许开发者部署并运行后端代码，而无需管理任何服务器基础设施。这些函数是轻量级的、按需执行的计算单元，能够根据流量自动扩缩容，并天然集成到 Vercel 的全球 CDN 和部署工作流中。Vercel Functions 不仅为 Next.js 提供了强大的 API 路由支持，还允许开发者使用多种编程语言（如 Node.js, Python, Go, Ruby 等）构建独立的后端服务。  核心思想：Vercel Serverless Functions 提供了一种高效、自动扩缩容的无状态计算环境，使开发者能够将后端逻辑作为独立的函数部署到 Vercel 的全球边缘网络。其核心优势在于与前端框架的无缝集成、多语言支持、自动管理基础设施，并通过 Git 驱动的部署流程，极大地简化了全栈应用的开发和运维。   一、Vercel Serverless Functions 概览1.1 核心概念 无服务器 (Serverless)：你无需预置或管理任何服务器。Vercel 负责所有基础设施的配置、维...</div></div></div></a><a class="pagination-related" href="/3aa9e4c628f2/" title="在 Vercel 开发 Next.js 应用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-12</div><div class="info-item-2">在 Vercel 开发 Next.js 应用详解</div></div><div class="info-2"><div class="info-item-1"> Vercel 是 Next.js 的创建者，也是一个领先的云平台，专为部署和扩展 Web 应用程序而设计，特别是针对 Next.js 应用。它提供了一站式的开发、预览和部署工作流，集成了 Git 仓库，并支持无服务器功能、全球 CDN、自动 SSL 等，极大地简化了 Next.js 应用的部署和管理。  核心思想：在 Vercel 上开发 Next.js 应用，核心在于利用 Vercel 与 Next.js 的深度集成，实现从代码提交到全球部署的自动化工作流。这包括使用 Next.js 的特性（如数据获取、API 路由），配置 Vercel 项目，利用其预览部署、环境变量、无服务器函数等功能，实现高效且可扩展的开发和部署。   一、Next.js 基础在深入 Vercel 之前，确保你对 Next.js 的核心概念有所了解：  文件系统路由 (File-system Routing)：根据 pages (或 app 目录) 目录结构自动生成路由。 数据获取 (Data Fetching)： getServerSideProps (SSR): 服务端渲染，每次请求生成页面。 ge...</div></div></div></a><a class="pagination-related" href="/f5c29582f368/" title="Serverless 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="info-item-2">Serverless 详解</div></div><div class="info-2"><div class="info-item-1"> Serverless (无服务器) 是一种云计算的执行模型，它允许开发者构建和运行应用程序而无需管理服务器。在这种模型下，云服务提供商负责服务器的调配、维护和扩展，开发者只需关注自己的代码逻辑。Serverless 并不是指“没有服务器”，而是指“开发者不需要关心服务器”。它通常包含两种核心服务模式：函数即服务 (Function-as-a-Service, FaaS) 和 后端即服务 (Backend-as-a-Service, BaaS)。  核心思想：将基础设施管理完全交给云服务商，开发者只需编写代码并部署，按实际使用量付费，实现极致的弹性伸缩和降低运维成本。   一、为什么需要 Serverless？传统的应用部署模型（物理机、虚拟机、容器）都需要开发者或运维团队投入大量精力进行服务器管理：  资源调配：预估并配置合适的 CPU、内存、存储。 操作系统管理：安装、打补丁、更新。 运行时环境：安装语言运行时、库、依赖。 扩展性：根据流量变化手动或自动伸缩服务器集群。 高可用性：设置负载均衡、故障转移机制。 监控与日志：部署监控 agent，收集日志。  这些“非功能性需求...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">535</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Kafka%EF%BC%9F"><span class="toc-text">一、为什么需要 Kafka？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Kafka-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、Kafka 的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%94%9F%E4%BA%A7%E8%80%85-Producer"><span class="toc-text">2.1 生产者 (Producer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%B6%88%E8%B4%B9%E8%80%85-Consumer"><span class="toc-text">2.2 消费者 (Consumer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%B6%88%E6%81%AF-Message-Record"><span class="toc-text">2.3 消息 (Message&#x2F;Record)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%B8%BB%E9%A2%98-Topic"><span class="toc-text">2.4 主题 (Topic)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%88%86%E5%8C%BA-Partition"><span class="toc-text">2.5 分区 (Partition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%89%AF%E6%9C%AC-Replica-%E4%B8%8E-%E4%B8%BB%E5%AF%BC%E8%80%85-Leader-%E3%80%81%E8%BF%BD%E9%9A%8F%E8%80%85-Follower"><span class="toc-text">2.6 副本 (Replica) 与 主导者 (Leader)、追随者 (Follower)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Broker-%E4%BB%A3%E7%90%86"><span class="toc-text">2.7 Broker (代理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-ZooKeeper"><span class="toc-text">2.8 ZooKeeper</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Kafka-%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-text">三、Kafka 架构概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Kafka-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">四、Kafka 的数据流和可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">4.1 生产者发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="toc-text">4.2 消息持久化和副本机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-text">4.3 消费者消费消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Kafka-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">五、Kafka 的优缺点与适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">5.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">5.2 缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">5.3 适用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-Python"><span class="toc-text">六、代码示例 (Python)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-19.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>