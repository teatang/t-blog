<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WSL2详解：在Windows运行Linux的新标准 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="WSL 2 (Windows Subsystem for Linux 2) 是微软对 WSL 架构的重大革新，它提供了一个运行在轻量级虚拟机中的完整 Linux 内核。相较于其前身 WSL 1，WSL 2 实现了更强的 Linux 系统调用兼容性、显著提升的文件系统性能，并为 Docker Desktop 等需要原生 Linux 内核的工具提供了无缝集成。WSL 2 已经成为在 Windows">
<meta property="og:type" content="article">
<meta property="og:title" content="WSL2详解：在Windows运行Linux的新标准">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="WSL 2 (Windows Subsystem for Linux 2) 是微软对 WSL 架构的重大革新，它提供了一个运行在轻量级虚拟机中的完整 Linux 内核。相较于其前身 WSL 1，WSL 2 实现了更强的 Linux 系统调用兼容性、显著提升的文件系统性能，并为 Docker Desktop 等需要原生 Linux 内核的工具提供了无缝集成。WSL 2 已经成为在 Windows">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg">
<meta property="article:published_time" content="2025-09-21T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-17T10:11:50.522Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="虚拟机">
<meta property="article:tag" content="WSL2">
<meta property="article:tag" content="Hyper-V">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WSL2详解：在Windows运行Linux的新标准",
  "url": "https://blog.tbf1211.xx.kg/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg",
  "datePublished": "2025-09-21T22:24:00.000Z",
  "dateModified": "2025-11-17T10:11:50.522Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WSL2详解：在Windows运行Linux的新标准',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">278</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">189</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">67</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-22.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">WSL2详解：在Windows运行Linux的新标准</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">WSL2详解：在Windows运行Linux的新标准</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-09-21T22:24:00.000Z" title="发表于 2025-09-22 06:24:00">2025-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>WSL 2 (Windows Subsystem for Linux 2)</strong> 是微软对 WSL 架构的重大革新，它提供了一个运行在轻量级虚拟机中的完整 Linux 内核。相较于其前身 WSL 1，WSL 2 实现了更强的 Linux 系统调用兼容性、显著提升的文件系统性能，并为 Docker Desktop 等需要原生 Linux 内核的工具提供了无缝集成。WSL 2 已经成为在 Windows 上进行 Linux 开发体验的新标准。</p>
</blockquote>
<div class="note info flat"><p>“WSL 2 从根本上改变了 Windows 上的 Linux 体验，它提供了一个真正的 Linux 内核，这意味着你可以在 Windows 上运行更多原生的 Linux 应用和工具。”</p>
</div>
<hr>
<h2 id="一、WSL-2-的核心：轻量级虚拟机与真实-Linux-内核"><a href="#一、WSL-2-的核心：轻量级虚拟机与真实-Linux-内核" class="headerlink" title="一、WSL 2 的核心：轻量级虚拟机与真实 Linux 内核"></a>一、WSL 2 的核心：轻量级虚拟机与真实 Linux 内核</h2><h3 id="1-1-与-WSL-1-的根本区别"><a href="#1-1-与-WSL-1-的根本区别" class="headerlink" title="1.1 与 WSL 1 的根本区别"></a>1.1 与 WSL 1 的根本区别</h3><p>WSL 2 的核心在于采用了<strong>轻量级虚拟机 (VM)</strong> 的架构，而不是像 WSL 1 那样通过系统调用翻译层。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">WSL 1</th>
<th align="left">WSL 2</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层架构</strong></td>
<td align="left">系统调用翻译层（无虚拟机）</td>
<td align="left"><strong>基于 Hyper-V 的轻量级虚拟机</strong>，运行真实 Linux 内核</td>
</tr>
<tr>
<td align="left"><strong>Linux 内核</strong></td>
<td align="left">无，Windows NT 内核模拟</td>
<td align="left"><strong>有，微软定制的 Linux 4.19 (或更高)</strong></td>
</tr>
<tr>
<td align="left"><strong>系统调用兼容性</strong></td>
<td align="left">中等，部分应用（如 Docker）无法运行</td>
<td align="left"><strong>极高，几乎 100% 兼容</strong>，可运行 Docker、Fuse 等</td>
</tr>
<tr>
<td align="left"><strong>Linux 文件系统性能</strong></td>
<td align="left">较差（在 <code>/home</code> 等 Linux 内部路径）</td>
<td align="left"><strong>极佳</strong>（在 <code>/home</code> 等 Linux 内部路径，与原生 Linux 相当）</td>
</tr>
<tr>
<td align="left"><strong>Windows 文件系统性能</strong></td>
<td align="left">极佳（在 <code>/mnt/c</code> 等 Windows 挂载点）</td>
<td align="left">略逊于 WSL 1，但在 <code>\\wsl$\...</code> 路径下性能良好</td>
</tr>
<tr>
<td align="left"><strong>内存管理</strong></td>
<td align="left">共享 Windows 内存，占用低</td>
<td align="left"><strong>动态分配</strong>，启动时占用低，可按需增长，并在不使用时自动释放回 Windows（自 Win 10 2004 版本）</td>
</tr>
<tr>
<td align="left"><strong>网络模式</strong></td>
<td align="left">共享主机 IP</td>
<td align="left"><strong>独立的虚拟 IP 地址</strong>，默认 NAT 模式</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">轻量级脚本、简单命令行工具</td>
<td align="left"><strong>所有 Linux 开发场景</strong>，包括 Docker、Kubernetes、Web&#x2F;AI&#x2F;ML 开发等</td>
</tr>
</tbody></table>
<h3 id="1-2-工作原理概览"><a href="#1-2-工作原理概览" class="headerlink" title="1.2 工作原理概览"></a>1.2 工作原理概览</h3><ol>
<li><strong>Hyper-V 平台</strong>：WSL 2 利用 Windows 内置的 Hyper-V 虚拟化技术，但其管理方式远比传统的 Hyper-V VM 更轻量和自动化。</li>
<li><strong>精简 Linux 内核</strong>：微软维护并分发一个优化的 Linux 内核（通常基于最新稳定版），专门用于 WSL 2。这个内核被放置在一个 VHD (Virtual Hard Disk) 文件中，并由 Hyper-V VM 运行。</li>
<li><strong>VHD 文件</strong>：每个 WSL 2 发行版都有一个独立的 VHD 文件（通常位于 <code>C:\Users\&lt;YourUser&gt;\AppData\Local\Packages\&lt;DistroName&gt;\LocalState</code>），其中包含其文件系统。</li>
<li><strong>动态资源分配</strong>：WSL 2 虚拟机不会占用固定的大量 RAM。它会根据需要动态分配内存和 CPU 资源，并在你关闭所有 WSL 实例后自动释放大部分资源。</li>
</ol>
<h2 id="二、WSL-2-的安装与基本操作-快速指南"><a href="#二、WSL-2-的安装与基本操作-快速指南" class="headerlink" title="二、WSL 2 的安装与基本操作 (快速指南)"></a>二、WSL 2 的安装与基本操作 (快速指南)</h2><h3 id="2-1-安装要求"><a href="#2-1-安装要求" class="headerlink" title="2.1 安装要求"></a>2.1 安装要求</h3><ul>
<li>Windows 10 版本 2004 (Build 19041) 或更高版本，或 Windows 11。</li>
<li>主板 BIOS&#x2F;UEFI 中启用虚拟化技术（如 Intel VT-x &#x2F; AMD-V）。</li>
</ul>
<h3 id="2-2-推荐安装方式-Windows-11-或较新-Win-10"><a href="#2-2-推荐安装方式-Windows-11-或较新-Win-10" class="headerlink" title="2.2 推荐安装方式 (Windows 11 或较新 Win 10)"></a>2.2 推荐安装方式 (Windows 11 或较新 Win 10)</h3><p>只需一条命令（以管理员身份运行 PowerShell 或 CMD）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure>
<p>这条命令将自动：</p>
<ol>
<li>安装 WSL 所需的 Windows 可选组件。</li>
<li>下载并安装最新的 WSL 2 Linux 内核。</li>
<li>默认安装 Ubuntu 发行版。</li>
<li>设置 WSL 2 为默认版本。</li>
<li>首次启动 Ubuntu 并提示创建用户。</li>
</ol>
<h3 id="2-3-手动安装或升级现有发行版到-WSL-2"><a href="#2-3-手动安装或升级现有发行版到-WSL-2" class="headerlink" title="2.3 手动安装或升级现有发行版到 WSL 2"></a>2.3 手动安装或升级现有发行版到 WSL 2</h3><p>如果已安装 WSL 1 或需要特定步骤，可以：</p>
<ol>
<li><p><strong>确保已启用“适用于 Linux 的 Windows 子系统”和“虚拟机平台</strong>”：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows-Subsystem-Linux</span> /all /norestart</span><br><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>
<p>重启计算机。</p>
</li>
<li><p><strong>下载并安装 WSL 2 内核更新包</strong>：<br>前往 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual">微软官方文档</a> 下载并运行 <code>wsl_update_x64.msi</code>。</p>
</li>
<li><p><strong>将 WSL 2 设置为默认版本</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将现有发行版转换为 WSL 2</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-version</span> &lt;DistroName&gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>例如：<code>wsl --set-version Ubuntu-22.04 2</code>。此过程可能需要几分钟。</p>
</li>
</ol>
<h3 id="2-4-WSL-常用管理命令"><a href="#2-4-WSL-常用管理命令" class="headerlink" title="2.4 WSL 常用管理命令"></a>2.4 WSL 常用管理命令</h3><ul>
<li><code>wsl -l -v</code>：列出所有已安装的发行版、其状态和 WSL 版本。</li>
<li><code>wsl --shutdown</code>：停止所有运行中的发行版虚拟机。</li>
<li><code>wsl --terminate &lt;DistroName&gt;</code>：停止指定发行版。</li>
<li><code>wsl --unregister &lt;DistroName&gt;</code>：卸载并删除指定发行版的所有数据。</li>
</ul>
<h2 id="三、WSL-2-的核心优势与应用场景"><a href="#三、WSL-2-的核心优势与应用场景" class="headerlink" title="三、WSL 2 的核心优势与应用场景"></a>三、WSL 2 的核心优势与应用场景</h2><h3 id="3-1-极高的-Linux-系统调用兼容性"><a href="#3-1-极高的-Linux-系统调用兼容性" class="headerlink" title="3.1 极高的 Linux 系统调用兼容性"></a>3.1 极高的 Linux 系统调用兼容性</h3><p>这是 WSL 2 最重要的优势。由于运行的是真实 Linux 内核，WSL 2 支持所有 Linux 内核功能，这意味着你可以运行此前在 WSL 1 中无法工作的应用程序：</p>
<ul>
<li><strong>Docker Desktop</strong>：完美集成，无需 Hyper-V VM，直接在 WSL 2 后端运行 Linux 容器。</li>
<li><strong>Kubernetes</strong>：通过 Docker Desktop 的 Kubernetes 集成，或直接在 WSL 2 中安装 K3s&#x2F;Minikube 等轻量级 K8s 发行版。</li>
<li><strong>FUSE 文件系统</strong>：如 SSHFS, FUSE 驱动的文件系统。</li>
<li><strong>低级网络工具</strong>：如 <code>tcpdump</code>, <code>wireshark</code>。</li>
<li><strong>更多 Linux 发行版</strong>：可以运行更多依赖特定内核特性的 Linux 发行版。</li>
<li><strong>安全性</strong>：某些安全工具或渗透测试工具需要更完整的 Linux 内核特性。</li>
</ul>
<h3 id="3-2-卓越的-Linux-文件系统性能"><a href="#3-2-卓越的-Linux-文件系统性能" class="headerlink" title="3.2 卓越的 Linux 文件系统性能"></a>3.2 卓越的 Linux 文件系统性能</h3><p>如果你经常在 WSL 内部进行编译、Git 操作、大型项目文件处理，WSL 2 在其 Linux 文件系统 (Ext4) 内部的性能几乎与原生 Linux 持平。</p>
<ul>
<li><strong>最佳实践</strong>：将你的开发项目克隆到 WSL 内部（例如 <code>/home/user/projects</code>），而不是通过 <code>/mnt/c/</code> 访问 Windows 目录。在 WSL 内部对这些文件进行操作将获得最佳性能。</li>
</ul>
<h3 id="3-3-无缝的图形化应用程序支持-WSLg"><a href="#3-3-无缝的图形化应用程序支持-WSLg" class="headerlink" title="3.3 无缝的图形化应用程序支持 (WSLg)"></a>3.3 无缝的图形化应用程序支持 (WSLg)</h3><p>自 Windows 11 开始，WSLg (WSL Graphical Architecture) 成为了 WSL 2 的内置功能，极大地提升了 WSL 的可用性。</p>
<ul>
<li><strong>工作原理</strong>：WSLg 包含了一个轻量级的 Wayland&#x2F;X Server、PulseAudio Server 和必要的驱动，通过 RemoteFX 技术在 Windows 桌面无缝运行 Linux GUI 应用。</li>
<li><strong>使用方式</strong>：在 WSL 命令行中直接运行你安装的 Linux GUI 应用（例如 <code>firefox</code>、<code>gimp</code>、<code>code</code>、<code>pycharm</code>），它们会像原生 Windows 应用一样以独立的窗口启动。</li>
<li><strong>优势</strong>：<ul>
<li>可以在 Windows 上使用 Linux 专属的 IDE、开发工具、浏览器、图形设计软件等。</li>
<li>在开发环境下进行更真实的测试，无需额外的虚拟机或双启动。</li>
</ul>
</li>
</ul>
<h3 id="3-4-与-Windows-工具链的深度集成"><a href="#3-4-与-Windows-工具链的深度集成" class="headerlink" title="3.4 与 Windows 工具链的深度集成"></a>3.4 与 Windows 工具链的深度集成</h3><p>WSL 2 除了提供独立的 Linux 环境，还保持了与 Windows 的良好互操作性。</p>
<ul>
<li><strong>VS Code Remote Development</strong>：最佳开发体验。在 Windows 上运行 VS Code，但其所有开发工作都在 WSL 2 内部进行。</li>
<li><strong>命令行互操作</strong>：<ul>
<li>从 Windows CMD&#x2F;PowerShell 运行 Linux 命令：<code>wsl &lt;command&gt;</code>。</li>
<li>从 Linux Bash 运行 Windows 命令：<code>explorer.exe .</code>（在当前 Linux 路径打开 Windows 文件管理器），<code>cmd.exe</code>，<code>notepad.exe</code> 等。</li>
</ul>
</li>
<li><strong>网络访问</strong>：<ul>
<li>通过 <code>localhost</code> 访问 WSL 内部运行的服务（Windows 自动进行端口转发）。</li>
<li>从 WSL 访问 Windows 的服务（例如 <code>--host 192.168.X.X</code> 指向 Windows 主机 IP）。</li>
<li>从外部访问 WSL 服务通常需要手动进行端口转发 (<code>netsh interface portproxy ...</code>)。</li>
</ul>
</li>
</ul>
<h2 id="四、WSL-2-开发工作流示例"><a href="#四、WSL-2-开发工作流示例" class="headerlink" title="四、WSL 2 开发工作流示例"></a>四、WSL 2 开发工作流示例</h2><h4 id="4-1-全栈-Web-开发-React-Node-js-Python-Go-等"><a href="#4-1-全栈-Web-开发-React-Node-js-Python-Go-等" class="headerlink" title="4.1 全栈 Web 开发 (React, Node.js, Python, Go 等)"></a>4.1 全栈 Web 开发 (React, Node.js, Python, Go 等)</h4><ol>
<li><strong>安装 WSL 2 (Ubuntu 22.04 LTS)</strong>。</li>
<li>在 WSL 内部安装 Node.js&#x2F;NVM, Python&#x2F;Pyenv, GoLang, Git 等开发工具链。</li>
<li>在 WSL 内部克隆你的项目到 <code>/home/user/my-project</code>。</li>
<li>在 VS Code 中安装 <code>Remote - WSL</code> 扩展。</li>
<li>在 WSL 终端中进入项目目录，运行 <code>code .</code>，VS Code 会自动连接并打开项目。</li>
<li>在 VS Code 终端中运行 <code>npm install</code> 或 <code>pip install</code>，然后 <code>npm start</code> 或 <code>python app.py</code> 启动开发服务器。</li>
<li>在 Windows 浏览器中访问 <code>http://localhost:&lt;port&gt;</code>。</li>
</ol>
<h4 id="4-2-Docker-Kubernetes-开发"><a href="#4-2-Docker-Kubernetes-开发" class="headerlink" title="4.2 Docker&#x2F;Kubernetes 开发"></a>4.2 Docker&#x2F;Kubernetes 开发</h4><ol>
<li><strong>安装 Docker Desktop for Windows</strong>，并确保其配置为使用 WSL 2 后端。</li>
<li>在 WSL 内部，你可以像在原生 Linux 中一样使用 <code>docker</code> 和 <code>docker-compose</code> 命令。Docker Desktop 会自动将这些命令代理到 WSL 2 宿主机。</li>
<li>构建、运行、管理容器，甚至部署本地 Kubernetes 集群 (<code>minikube</code> 或 Docker Desktop 内置的 K8s)。</li>
</ol>
<h2 id="五、高级配置与优化"><a href="#五、高级配置与优化" class="headerlink" title="五、高级配置与优化"></a>五、高级配置与优化</h2><h3 id="5-1-wslconfig-文件"><a href="#5-1-wslconfig-文件" class="headerlink" title="5.1 .wslconfig 文件"></a>5.1 <code>.wslconfig</code> 文件</h3><p>这是一个全局配置文件，位于 <code>C:\Users\&lt;你的用户名&gt;\.wslconfig</code>。可以用来限制 WSL 2 虚拟机的资源。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="attr">memory</span>=<span class="number">4</span>GB         <span class="comment"># 限制 WSL 2 虚拟机的总内存为 4GB。默认是 Windows 主机内存的 50%。</span></span><br><span class="line"><span class="attr">processors</span>=<span class="number">2</span>       <span class="comment"># 限制 WSL 2 虚拟机使用的 CPU 核心数为 2。默认是所有核心。</span></span><br><span class="line"><span class="attr">swap</span>=<span class="number">2</span>GB           <span class="comment"># 设置虚拟机的交换空间大小。默认是内存的 25% 或 16GB。</span></span><br><span class="line"><span class="attr">localhostForwarding</span>=<span class="literal">true</span> <span class="comment"># 允许 localhost 转发，默认开启。</span></span><br></pre></td></tr></table></figure>
<p>保存后，需要运行 <code>wsl --shutdown</code> 然后重新启动 WSL 发行版才能生效。</p>
<h3 id="5-2-磁盘空间管理"><a href="#5-2-磁盘空间管理" class="headerlink" title="5.2 磁盘空间管理"></a>5.2 磁盘空间管理</h3><ul>
<li>WSL 2 的 VHD 文件会动态增长。</li>
<li><strong>压缩 VHD 文件</strong>：当 WSL 发行版占用磁盘空间过大时，可以对 VHD 文件进行压缩。<ol>
<li>停止所有 WSL 实例：<code>wsl --shutdown</code>。</li>
<li>打开 PowerShell (管理员身份)</li>
<li>运行 <code>diskpart</code>。</li>
<li>在 <code>DISKPART&gt;</code> 提示符下：<ul>
<li><code>select vdisk file=&quot;&lt;PathToVHDFile&gt;&quot;</code> （路径在 <code>wsl -l -v</code> 的 <code>Location</code> 字段中）</li>
<li><code>compact vdisk</code></li>
<li><code>exit</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="5-3-网络配置与端口转发"><a href="#5-3-网络配置与端口转发" class="headerlink" title="5.3 网络配置与端口转发"></a>5.3 网络配置与端口转发</h3><p>由于 WSL 2 的默认 NAT 网络模式，从 Windows 外部访问 WSL 内部服务需要端口转发。</p>
<ul>
<li><strong>永久端口转发 (PowerShell 管理员)</strong>：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 WSL 2 默认网关 IP (通常是 172.xx.xx.1)</span></span><br><span class="line"><span class="variable">$wsl_gateway</span> = (<span class="built_in">Get-NetIPAddress</span> <span class="literal">-AddressFamily</span> IPv4 <span class="literal">-PrefixLength</span> <span class="number">20</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.InterfaceAlias <span class="operator">-like</span> <span class="string">&quot;vEthernet (WSL)*&quot;</span> &#125;).IPAddress.ToString()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取你的 WSL 2 实例 IP</span></span><br><span class="line"><span class="variable">$wsl_ip</span> = (wsl <span class="literal">-d</span> Ubuntu<span class="literal">-22</span>.<span class="number">04</span> hostname <span class="literal">-I</span>).Trim() <span class="comment"># 替换为你的发行版名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加端口转发规则 (例如将 Windows 的 8000 转发到 WSL 的 8000)</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenport=<span class="number">8000</span> listenaddress=<span class="number">0.0</span>.<span class="number">0.0</span> connectaddress=<span class="variable">$wsl_ip</span> connectport=<span class="number">8000</span></span><br></pre></td></tr></table></figure></li>
<li><strong>防火墙规则</strong>：确保 Windows 防火墙允许入站连接到你转发的端口。</li>
</ul>
<h3 id="5-4-Dotfiles-管理"><a href="#5-4-Dotfiles-管理" class="headerlink" title="5.4 Dotfiles 管理"></a>5.4 Dotfiles 管理</h3><p>使用 Git 来管理 <code>.bashrc</code>, <code>.zshrc</code>, <code>.gitconfig</code> 等配置文件，方便在不同 WSL 实例或机器上同步你的 Linux 环境。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>WSL 2 彻底改变了 Windows 上的 Linux 开发范式，它不再是一个简单的兼容层，而是一个全功能的、高度集成的轻量级 Linux 虚拟机。其卓越的系统调用兼容性、文件系统性能、原生 Docker 支持以及突破性的 WSLg 功能，使其成为现代 Windows 开发者不可或缺的利器。通过理解其底层工作原理和掌握高级配置技巧，你可以充分发挥 WSL 2 的潜力，构建一个高效、灵活且强大的开发环境，真正实现 Windows 和 Linux 的优势互补。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/">https://blog.tbf1211.xx.kg/2025/2025-09-22_WSL2%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9C%A8Windows%E8%BF%90%E8%A1%8CLinux%E7%9A%84%E6%96%B0%E6%A0%87%E5%87%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Windows/">Windows</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a><a class="post-meta__tags" href="/tags/WSL2/">WSL2</a><a class="post-meta__tags" href="/tags/Hyper-V/">Hyper-V</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-22.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/2025-09-28_HTMX%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8HTML%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E9%A9%B1%E5%8A%A8AJAX%E3%80%81CSS%E8%BF%87%E6%B8%A1%E5%92%8CWebSocket/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</div></div><div class="info-2"><div class="info-item-1"> 在过去十年中，前端开发领域由 JavaScript 框架（如 React, Vue, Angular）占据主导地位，它们将整个用户界面放在客户端，通过 API 与后端交互。然而，这种“单页应用 (SPA)”模式并非总是最佳选择，它带来了复杂的构建流程、初始加载性能问题、SEO 挑战以及较高的开发和维护成本。 HTMX 的出现，挑战了这一主流范式。它主张将交互逻辑回归到服务器端，通过简单的 HTML 属性就能实现 AJAX 请求、CSS 过渡、WebSocket 和服务器发送事件 (SSE)，在不编写一行 JavaScript 代码的情况下，实现丰富的动态用户体验。  本文将深入探讨 HTMX 的核心理念、工作原理、主要特性、优缺点以及适用场景，帮助你理解这个“返璞归真”但又极具创新力的工具。   一、 HTMX 是什么？核心理念与哲学HTMX 是一个小型 (约 15KB gzipped) 的 JavaScript 库，它通过扩展 HTML 原生能力，允许你在 HTML 元素上直接指定 AJAX 请求、CSS 动画、WebSocket 和服务器发送事件 (SSE) 行为。 其核心...</div></div></div></a><a class="pagination-related" href="/2025/2025-09-20_OrbStack%20%E8%AF%A6%E8%A7%A3/" title="OrbStack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">OrbStack 详解</div></div><div class="info-2"><div class="info-item-1"> OrbStack 是一款专为 macOS 和 Linux 用户设计的高性能、轻量级工具，旨在成为 Docker Desktop 和 Colima&#x2F;Rancher Desktop 的替代品。它提供了一个闪电般快速的开发环境，用于运行 Docker 容器、Kubernetes 集群以及完整的 Linux 虚拟机，旨在提供原生级别的性能、更低的资源占用和更卓越的用户体验。  核心思想： OrbStack 专注于优化在 macOS 和 Linux 上运行容器和 Linux 环境的性能和资源效率，通过巧妙的虚拟化技术和精简设计，提供比传统解决方案更快启动、更少耗电、更流畅的体验。   一、为什么需要 OrbStack？传统的 Docker Desktop 或 Colima&#x2F;Rancher Desktop 在 macOS 上存在一些痛点：  性能问题： Docker Desktop 基于笨重的 HyperKit 或 QEMU 虚拟机，启动慢，文件 I&#x2F;O 性能差，尤其是在处理大量文件操作时（如 Node.js 或 PHP 项目的 node_modules）。 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-08</div><div class="info-item-2">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</div></div><div class="info-2"><div class="info-item-1"> Hyper-V 是微软提供的一款基于 Hypervisor 的虚拟化技术，它允许用户在单一物理服务器上运行多个独立的虚拟机 (Virtual Machines, VMs)。作为 Windows Server 操作系统的一个角色功能，以及 Windows 客户端操作系统（Pro、Enterprise、Education 版本）的一个可选功能，Hyper-V 提供了一个可靠、高效且可扩展的平台，用于创建、运行和管理虚拟机。它支持运行多种操作系统，包括 Windows、Linux 以及其他变体，是企业级数据中心、开发测试环境以及个人专业用户不可或缺的工具。  核心思想：Hyper-V 在硬件和操作系统之间插入一个薄薄的虚拟化层——Hypervisor (管理程序)。这个 Hypervisor 直接管理物理硬件资源，并高效地分配给多个虚拟机，每个虚拟机都像一台独立的物理机器一样运行，拥有自己的操作系统和应用程序，从而实现资源的隔离和高效利用。   一、虚拟化技术概述与 Hyper-V 的定位1.1 什么是虚拟化？虚拟化是一种创建事物虚拟版本（而不是物理版本）的技术，通常指创建虚拟计算机...</div></div></div></a><a class="pagination-related" href="/2025/2025-09-20_OrbStack%20%E8%AF%A6%E8%A7%A3/" title="OrbStack 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-20</div><div class="info-item-2">OrbStack 详解</div></div><div class="info-2"><div class="info-item-1"> OrbStack 是一款专为 macOS 和 Linux 用户设计的高性能、轻量级工具，旨在成为 Docker Desktop 和 Colima&#x2F;Rancher Desktop 的替代品。它提供了一个闪电般快速的开发环境，用于运行 Docker 容器、Kubernetes 集群以及完整的 Linux 虚拟机，旨在提供原生级别的性能、更低的资源占用和更卓越的用户体验。  核心思想： OrbStack 专注于优化在 macOS 和 Linux 上运行容器和 Linux 环境的性能和资源效率，通过巧妙的虚拟化技术和精简设计，提供比传统解决方案更快启动、更少耗电、更流畅的体验。   一、为什么需要 OrbStack？传统的 Docker Desktop 或 Colima&#x2F;Rancher Desktop 在 macOS 上存在一些痛点：  性能问题： Docker Desktop 基于笨重的 HyperKit 或 QEMU 虚拟机，启动慢，文件 I&#x2F;O 性能差，尤其是在处理大量文件操作时（如 Node.js 或 PHP 项目的 node_modules）。 ...</div></div></div></a><a class="pagination-related" href="/2025/2025-08-22_Chocolatey%20(Choco)%20%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E4%B8%8A%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/" title="Chocolatey (Choco) 详解：Windows 上的包管理器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-22</div><div class="info-item-2">Chocolatey (Choco) 详解：Windows 上的包管理器</div></div><div class="info-2"><div class="info-item-1"> Chocolatey (通常简称为 choco) 是 Windows 操作系统上一个开源的、社区驱动的命令行包管理器。它允许用户通过命令行界面（如 PowerShell 或 cmd）自动化地安装、升级、配置和卸载软件，从而简化了 Windows 上的软件管理流程。  核心思想：将 Linux&#x2F;macOS 上包管理器的便捷性带到 Windows 平台，实现软件安装、升级、卸载的自动化和批量管理。   一、为什么需要 Chocolatey？传统的 Windows 软件管理方式通常涉及：  手动下载安装包：访问每个软件的官方网站，下载 .exe 或 .msi 安装文件。 点击向导式安装：一步步完成安装向导，可能需要关注额外的选项（如捆绑软件）。 手动升级：软件更新时需要重复上述步骤。 寻找卸载程序：在“程序和功能”中查找并手动卸载。  这些手动操作耗时、易错且效率低下，尤其对于开发者、系统管理员或需要管理多台机器的用户而言。Chocolatey 旨在解决这些痛点：  自动化安装&#x2F;升级：只需一条命令即可安装或升级软件，无需手动干预。 批量管理：可以一次性安装或升级多...</div></div></div></a><a class="pagination-related" href="/2025/2025-08-20_PowerShell%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/" title="PowerShell 详解与使用技巧"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-20</div><div class="info-item-2">PowerShell 详解与使用技巧</div></div><div class="info-2"><div class="info-item-1"> PowerShell 是微软开发的一种命令行 shell 和脚本语言，专为系统管理和自动化设计。它基于 .NET Framework (Windows PowerShell) 或 .NET Core (PowerShell Core &#x2F; PowerShell 7+)，提供了比传统命令行工具（如 CMD 或 Bash）更强大、更统一且面向对象的管理体验。PowerShell 不仅限于 Windows 平台，现在已跨平台支持 Linux 和 macOS。  核心思想：“一切皆对象”。PowerShell 不像传统 shell 那样处理文本流，而是处理 .NET 对象。这意味着命令的输出可以直接作为另一个命令的输入，且数据类型和结构得以保留，极大地提升了脚本编写的效率和健壮性。   一、PowerShell 的起源与演进传统的 Windows 命令行工具（CMD）在自动化和复杂任务处理方面存在显著局限性，其主要问题是基于文本处理，使得数据解析和传递变得复杂且易出错。为了解决这些问题，微软开发了 PowerShell（最初名为 Monad），并于 2006 年发布。 1.1 ...</div></div></div></a><a class="pagination-related" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-25</div><div class="info-item-2">iptables 详解</div></div><div class="info-2"><div class="info-item-1"> iptables 是 Linux 系统中一个强大的防火墙工具，它基于 Netfilter 框架。Netfilter 是 Linux 内核中的一个数据包过滤和修改框架，而 iptables 是用于在用户空间配置 Netfilter 规则的命令行工具。通过 iptables，系统管理员可以定义各种规则来过滤、修改、转发或拦截网络数据包，从而实现网络流量控制、端口转发、地址伪装等功能。可以说，iptables 是 Linux 系统网络安全和流量管理的基石。  核心思想：基于规则链对数据包进行匹配和处理。 数据包在网络协议栈中穿行时，会根据定义好的规则链进行检查，并按照链中的规则顺序执行相应的动作。   一、Netfilter 框架与 iptables 关系理解 iptables，首先要了解它与 Netfilter 的关系：  Netfilter：位于 Linux 内核中，是一个用于网络数据包过滤、修改、转发和跟踪的框架。它定义了几个”钩子” (Hooks) 点，当数据包经过这些钩子点时，Netfilter 会检查是否有注册的规则需要处理该数据包。 iptables：是用户空间的命令行...</div></div></div></a><a class="pagination-related" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-28</div><div class="info-item-2">nftables 详解</div></div><div class="info-2"><div class="info-item-1"> nftables 是 Linux 内核 Netfilter 项目的下一代包过滤框架。它旨在逐步取代传统的 iptables (以及 ip6tables, arptables, ebtables) 工具集，提供一个统一的、高效的、更易于管理和扩展的防火墙解决方案。nftables 引入了一套全新的语法和设计理念，旨在解决 iptables 长期存在的一些问题，例如命令复杂性、重复代码以及 IPv4 和 IPv6 规则管理的独立性等。  核心思想：基于表达式的统一规则集，支持原子性更新，并针对 IPv4&#x2F;IPv6&#x2F;桥接等协议提供统一管理。 它的设计哲学是从指令式规则集转向声明式通用虚拟机指令，使得规则处理更高效、更灵活。   一、为什么需要 nftables？iptables 的局限性虽然 iptables 强大且稳定，但它在设计和使用上存在一些固有的局限性，促使 Netfilter 社区开发 nftables：  语法复杂且碎片化：  iptables (用于 IPv4)、ip6tables (用于 IPv6)、arptables (用于 ARP)、ebtab...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">278</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">189</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">67</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81WSL-2-%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E7%9C%9F%E5%AE%9E-Linux-%E5%86%85%E6%A0%B8"><span class="toc-text">一、WSL 2 的核心：轻量级虚拟机与真实 Linux 内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%8E-WSL-1-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB"><span class="toc-text">1.1 与 WSL 1 的根本区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88"><span class="toc-text">1.2 工作原理概览</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81WSL-2-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97"><span class="toc-text">二、WSL 2 的安装与基本操作 (快速指南)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%89%E8%A3%85%E8%A6%81%E6%B1%82"><span class="toc-text">2.1 安装要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8E%A8%E8%8D%90%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F-Windows-11-%E6%88%96%E8%BE%83%E6%96%B0-Win-10"><span class="toc-text">2.2 推荐安装方式 (Windows 11 或较新 Win 10)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%88%96%E5%8D%87%E7%BA%A7%E7%8E%B0%E6%9C%89%E5%8F%91%E8%A1%8C%E7%89%88%E5%88%B0-WSL-2"><span class="toc-text">2.3 手动安装或升级现有发行版到 WSL 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-WSL-%E5%B8%B8%E7%94%A8%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-text">2.4 WSL 常用管理命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81WSL-2-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">三、WSL 2 的核心优势与应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9E%81%E9%AB%98%E7%9A%84-Linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">3.1 极高的 Linux 系统调用兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8D%93%E8%B6%8A%E7%9A%84-Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD"><span class="toc-text">3.2 卓越的 Linux 文件系统性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%97%A0%E7%BC%9D%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%AF%E6%8C%81-WSLg"><span class="toc-text">3.3 无缝的图形化应用程序支持 (WSLg)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%B8%8E-Windows-%E5%B7%A5%E5%85%B7%E9%93%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%9B%86%E6%88%90"><span class="toc-text">3.4 与 Windows 工具链的深度集成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81WSL-2-%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">四、WSL 2 开发工作流示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%85%A8%E6%A0%88-Web-%E5%BC%80%E5%8F%91-React-Node-js-Python-Go-%E7%AD%89"><span class="toc-text">4.1 全栈 Web 开发 (React, Node.js, Python, Go 等)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Docker-Kubernetes-%E5%BC%80%E5%8F%91"><span class="toc-text">4.2 Docker&#x2F;Kubernetes 开发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">五、高级配置与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-wslconfig-%E6%96%87%E4%BB%B6"><span class="toc-text">5.1 .wslconfig 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">5.2 磁盘空间管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-text">5.3 网络配置与端口转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Dotfiles-%E7%AE%A1%E7%90%86"><span class="toc-text">5.4 Dotfiles 管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-11-07_Codex%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9AOpenAI%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codex 详解与使用技巧：OpenAI 的代码智能模型"/></a><div class="content"><a class="title" href="/2025/2025-11-07_Codex%20%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9AOpenAI%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型">Codex 详解与使用技巧：OpenAI 的代码智能模型</a><time datetime="2025-11-06T22:24:00.000Z" title="发表于 2025-11-07 06:24:00">2025-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-11-05_Claude%20Code%20%E8%AF%A6%E8%A7%A3%EF%BC%9AAnthropic%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Claude Code 详解：Anthropic 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Claude Code 详解：Anthropic 的代码智能模型"/></a><div class="content"><a class="title" href="/2025/2025-11-05_Claude%20Code%20%E8%AF%A6%E8%A7%A3%EF%BC%9AAnthropic%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B/" title="Claude Code 详解：Anthropic 的代码智能模型">Claude Code 详解：Anthropic 的代码智能模型</a><time datetime="2025-11-04T22:24:00.000Z" title="发表于 2025-11-05 06:24:00">2025-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-11-01_Ubuntu%20UFW%20(Uncomplicated%20Firewall)%20%E8%AF%A6%E8%A7%A3/" title="Ubuntu UFW (Uncomplicated Firewall) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu UFW (Uncomplicated Firewall) 详解"/></a><div class="content"><a class="title" href="/2025/2025-11-01_Ubuntu%20UFW%20(Uncomplicated%20Firewall)%20%E8%AF%A6%E8%A7%A3/" title="Ubuntu UFW (Uncomplicated Firewall) 详解">Ubuntu UFW (Uncomplicated Firewall) 详解</a><time datetime="2025-10-31T22:24:00.000Z" title="发表于 2025-11-01 06:24:00">2025-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-22.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>