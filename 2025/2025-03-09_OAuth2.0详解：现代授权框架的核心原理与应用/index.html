<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OAuth2.0详解：现代授权框架的核心原理与应用 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OAuth 2.0（Open Authorization）是一个开放标准，定义了一套授权流程，允许用户（资源所有者）授权第三方应用访问他们在另一个服务提供者（授权服务器）上的受保护资源（资源服务器），而无需将自己的用户名和密码直接提供给第三方应用。它主要解决的是委托授权的问题，即“我授权应用A去访问我在服务B上的某些数据”。  核心区分：OAuth 2.0 是一个授权（Authorization">
<meta property="og:type" content="article">
<meta property="og:title" content="OAuth2.0详解：现代授权框架的核心原理与应用">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2025/2025-03-09_OAuth2.0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="OAuth 2.0（Open Authorization）是一个开放标准，定义了一套授权流程，允许用户（资源所有者）授权第三方应用访问他们在另一个服务提供者（授权服务器）上的受保护资源（资源服务器），而无需将自己的用户名和密码直接提供给第三方应用。它主要解决的是委托授权的问题，即“我授权应用A去访问我在服务B上的某些数据”。  核心区分：OAuth 2.0 是一个授权（Authorization">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-05.jpg">
<meta property="article:published_time" content="2025-03-08T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-23T10:07:11.577Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="OAuth2.0">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-05.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OAuth2.0详解：现代授权框架的核心原理与应用",
  "url": "https://blog.tbf1211.xx.kg/2025/2025-03-09_OAuth2.0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-05.jpg",
  "datePublished": "2025-03-08T22:24:00.000Z",
  "dateModified": "2025-10-23T10:07:11.577Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2025/2025-03-09_OAuth2.0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OAuth2.0详解：现代授权框架的核心原理与应用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">166</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">160</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-05.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">OAuth2.0详解：现代授权框架的核心原理与应用</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OAuth2.0详解：现代授权框架的核心原理与应用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-03-08T22:24:00.000Z" title="发表于 2025-03-09 06:24:00">2025-03-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2025/2025-03-09_OAuth2.0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>OAuth 2.0</strong>（Open Authorization）是一个<strong>开放标准</strong>，定义了一套授权流程，允许用户（资源所有者）授权第三方应用访问他们在另一个服务提供者（授权服务器）上的受保护资源（资源服务器），而<strong>无需将自己的用户名和密码直接提供给第三方应用</strong>。它主要解决的是<strong>委托授权</strong>的问题，即“我授权应用A去访问我在服务B上的某些数据”。</p>
</blockquote>
<div class="note info flat"><p>核心区分：OAuth 2.0 是一个<strong>授权（Authorization）框架</strong>，而不是用来做认证（Authentication）。尽管它常常与认证机制（如 OpenID Connect）结合使用，但其核心职责是授予对资源的访问权限，而非验证用户身份。</p>
</div>

<h2 id="一、OAuth-2-0-产生的背景与解决的问题"><a href="#一、OAuth-2-0-产生的背景与解决的问题" class="headerlink" title="一、OAuth 2.0 产生的背景与解决的问题"></a>一、OAuth 2.0 产生的背景与解决的问题</h2><p>在 OAuth 出现之前，如果一个第三方应用需要访问用户在其他服务（如 Google 相册、GitHub 代码库）上的数据，用户通常需要将自己的账号密码直接告知第三方应用。这种做法带来了严重的安全和便捷性问题：</p>
<ol>
<li><strong>凭据泄露风险</strong>：第三方应用一旦被攻破，或恶意使用，用户的完整凭据就会泄露，导致所有关联服务面临风险。</li>
<li><strong>权限过大</strong>：第三方应用获得的是用户的完全控制权，无法限制其只能访问特定资源或特定权限。</li>
<li><strong>难以撤销</strong>：用户无法针对某个应用单独撤销授权，只能通过修改服务提供者的密码，这会影响其他所有应用。</li>
</ol>
<p>OAuth 2.0 引入了<strong>授权令牌 (Access Token)</strong> 机制，使得第三方应用能够获得一个<strong>有限权限、有时效性的令牌</strong>，而非用户凭据，从而解决了上述痛点。</p>
<h2 id="二、OAuth-2-0-中的核心角色"><a href="#二、OAuth-2-0-中的核心角色" class="headerlink" title="二、OAuth 2.0 中的核心角色"></a>二、OAuth 2.0 中的核心角色</h2><p>OAuth 2.0 定义了四个关键角色，它们在授权流程中协作完成：</p>
<ol>
<li><p><strong>资源所有者 (Resource Owner)</strong>：拥有受保护资源的实体，通常是一个人，能够授予对资源的访问权限。</p>
<ul>
<li><strong>示例</strong>：你本人，拥有你在百度网盘中的文件。</li>
</ul>
</li>
<li><p><strong>客户端 (Client)</strong>：请求访问受保护资源的应用程序。它必须获得资源所有者的授权。</p>
<ul>
<li><strong>示例</strong>：一个文件同步应用，需要访问你的百度网盘文件。</li>
</ul>
</li>
<li><p><strong>授权服务器 (Authorization Server - AS)</strong>：负责与资源所有者进行交互，验证资源所有者的身份（通常是用户登录），并根据授权结果向客户端颁发<strong>访问令牌 (Access Token)</strong>。</p>
<ul>
<li><strong>示例</strong>：百度网盘的 OAuth 服务器。</li>
</ul>
</li>
<li><p><strong>资源服务器 (Resource Server - RS)</strong>：托管受保护资源的服务器，它接收并验证客户端提交的访问令牌，然后根据令牌的权限和有效性，响应客户端的资源请求。</p>
<ul>
<li><strong>示例</strong>：百度网盘的 API 服务器，提供文件相关的 API。</li>
</ul>
</li>
</ol>
<p><strong>角色交互概览图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    A[资源所有者（用户）] -- 1. 尝试使用 --&gt; B[客户端（应用程序）];
    B -- 2. 请求授权 --&gt; C[授权服务器（Authorization Server）];
    C -- 3. 验证身份 &amp; 获取用户同意 --&gt; A;
    A -- 4. 用户同意授权 --&gt; C;
    C -- 5. 颁发授权 (Token) --&gt; B;
    B -- 6. 使用授权 (Token) 访问资源 --&gt; D[资源服务器（Resource Server）];
    D -- 7. 返回受保护资源 --&gt; B;
  </pre></div>

<h2 id="三、OAuth-2-0-授权模式-Grant-Types"><a href="#三、OAuth-2-0-授权模式-Grant-Types" class="headerlink" title="三、OAuth 2.0 授权模式 (Grant Types)"></a>三、OAuth 2.0 授权模式 (Grant Types)</h2><p>为了适应不同的客户端类型和安全需求，OAuth 2.0 定义了多种授权模式。选择合适的模式是安全性考量的重要一环。</p>
<h3 id="3-1-1-授权码模式-Authorization-Code-Grant-推荐！"><a href="#3-1-1-授权码模式-Authorization-Code-Grant-推荐！" class="headerlink" title="3.1 1. 授权码模式 (Authorization Code Grant) - 推荐！"></a>3.1 1. 授权码模式 (Authorization Code Grant) - <strong>推荐！</strong></h3><ul>
<li><strong>适用场景</strong>：最常用，安全性最高。适用于<strong>有服务器的 Web 应用（即保密客户端，可以安全存储客户端密钥）</strong>。结合 PKCE 扩展后，也适用于<strong>单页应用 (SPA)</strong> 和<strong>移动应用（即公共客户端）</strong>。</li>
<li><strong>核心思想</strong>：客户端先获取一个临时的“授权码 (Authorization Code)”，然后再用这个授权码在<strong>后端</strong>向授权服务器交换真正的 Access Token。这样，Access Token 永远不会经过用户的浏览器暴露给中间人。</li>
</ul>
<p><strong>流程图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant user as 用户 (Resource Owner)
    participant client_browser as 客户端浏览器
    participant client_backend as 客户端后端 (Client Application)
    participant auth_server as 授权服务器 (Authorization Server)
    participant resource_server as 资源服务器 (Resource Server)

    user-&gt;&gt;client_browser: 1. 访问客户端页面，点击“使用XX登录”
    client_browser-&gt;&gt;auth_server: 2. 重定向到授权服务器，携带 &#96;response_type&#x3D;code&#96;, &#96;client_id&#96;, &#96;redirect_uri&#96;, &#96;scope&#96;, &#96;state&#96;
    auth_server-&gt;&gt;user: 3. 验证身份 (可能要求登录)，显示授权提示
    user-&gt;&gt;auth_server: 4. 用户同意授权
    auth_server-&gt;&gt;client_browser: 5. 重定向回客户端的 &#96;redirect_uri&#96;，并携带 &#96;code&#96; 和 &#96;state&#96;
    client_browser-&gt;&gt;client_backend: 6. 浏览器将 &#96;code&#96; 传递给客户端后端
    client_backend-&gt;&gt;auth_server: 7. 在后端用 &#96;code&#96;, &#96;client_id&#96;, &#96;client_secret&#96;, &#96;redirect_uri&#96; 请求 Access Token
    auth_server-&gt;&gt;client_backend: 8. 授权服务器颁发 &#96;Access Token&#96; 和 &#96;Refresh Token&#96; (JSON格式)
    client_backend-&gt;&gt;client_browser: 9. 客户端后端登录成功，可设置会话或返回Token
    client_browser-&gt;&gt;resource_server: 10. 客户端使用 &#96;Access Token&#96; (通过 &#96;Authorization&#96; 头) 请求资源
    resource_server-&gt;&gt;client_browser: 11. 资源服务器返回受保护资源
  </pre></div>

<p><strong>安全性要点</strong>：</p>
<ul>
<li><code>client_secret</code> 仅在后端使用，不会暴露给用户。</li>
<li>授权码 <code>code</code> 是一次性的，且无法直接用于访问资源，被拦截风险较低。</li>
<li><code>state</code> 参数用于防止 CSRF 攻击。</li>
</ul>
<h4 id="授权码-PKCE-Proof-Key-for-Code-Exchange-推荐用于公共客户端！"><a href="#授权码-PKCE-Proof-Key-for-Code-Exchange-推荐用于公共客户端！" class="headerlink" title="授权码 + PKCE (Proof Key for Code Exchange) - 推荐用于公共客户端！"></a>授权码 + PKCE (Proof Key for Code Exchange) - <strong>推荐用于公共客户端！</strong></h4><p>专门为没有 <code>client_secret</code> 的公共客户端（如 SPA、移动应用）设计的授权码模式增强。它通过在授权请求和令牌交换过程中加入一个动态生成的“证明”，防止授权码被拦截后直接用于获取令牌。</p>
<h3 id="3-2-2-客户端凭据模式-Client-Credentials-Grant"><a href="#3-2-2-客户端凭据模式-Client-Credentials-Grant" class="headerlink" title="3.2 2. 客户端凭据模式 (Client Credentials Grant)"></a>3.2 2. 客户端凭据模式 (Client Credentials Grant)</h3><ul>
<li><strong>适用场景</strong>：服务器与服务器之间 (Machine-to-Machine) 的认证，客户端以自己的名义请求访问受保护资源，<strong>没有用户参与</strong>。</li>
<li><strong>核心思想</strong>：客户端直接使用 <code>client_id</code> 和 <code>client_secret</code> 从授权服务器获取 Access Token。</li>
</ul>
<p><strong>流程图：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant client_a as 客户端A (服务A Backend)
    participant auth_server as 授权服务器
    participant resource_server as 资源服务器 (服务B Backend)

    client_a-&gt;&gt;auth_server: 1. 发送 &#96;grant_type&#x3D;client_credentials&#96;, &#96;client_id&#96;, &#96;client_secret&#96;
    auth_server-&gt;&gt;client_a: 2. 授权服务器颁发 &#96;Access Token&#96;
    client_a-&gt;&gt;resource_server: 3. 使用 &#96;Access Token&#96; 请求受保护资源
    resource_server-&gt;&gt;client_a: 4. 资源服务器返回受保护资源
  </pre></div>

<h3 id="3-3-3-设备码模式-Device-Authorization-Grant-Device-Flow"><a href="#3-3-3-设备码模式-Device-Authorization-Grant-Device-Flow" class="headerlink" title="3.3 3. 设备码模式 (Device Authorization Grant - Device Flow)"></a>3.3 3. 设备码模式 (Device Authorization Grant - Device Flow)</h3><ul>
<li><strong>适用场景</strong>：输入受限的设备（如智能电视、打印机、命令行工具）进行授权。</li>
<li><strong>核心思想</strong>：设备向授权服务器获取一个<code>用户代码</code>和<code>验证URI</code>，用户在另一台功能更强大的设备（如手机&#x2F;电脑）上访问URI并输入代码完成授权，设备则轮询等待令牌。</li>
</ul>
<h3 id="4-隐式模式-Implicit-Grant-和-5-资源所有者密码凭据模式-Resource-Owner-Password-Credentials-Grant"><a href="#4-隐式模式-Implicit-Grant-和-5-资源所有者密码凭据模式-Resource-Owner-Password-Credentials-Grant" class="headerlink" title="4. 隐式模式 (Implicit Grant) 和 5. 资源所有者密码凭据模式 (Resource Owner Password Credentials Grant)"></a><strong>4. 隐式模式 (Implicit Grant)</strong> 和 <strong>5. 资源所有者密码凭据模式 (Resource Owner Password Credentials Grant)</strong></h3><p><strong>已不推荐，通常应避免使用。</strong></p>
<ul>
<li><strong>隐式模式</strong>：直接在浏览器重定向中返回 Access Token。安全性差，容易受到 XSS 和各种令牌泄露攻击，<strong>OAuth 2.1 规范已将其移除</strong>。现在推荐 SPA 使用授权码 + PKCE 模式。</li>
<li><strong>密码凭据模式</strong>：客户端直接获取用户账号密码去换取 Access Token。违背 OAuth 不触碰用户凭据的核心理念，仅适用于<strong>高度信任的第一方应用</strong>（如官方 App 登录），且功能上已被授权码模式替代，用户体验差，<strong>不推荐第三方应用使用</strong>。</li>
</ul>
<h2 id="四、刷新令牌-Refresh-Token"><a href="#四、刷新令牌-Refresh-Token" class="headerlink" title="四、刷新令牌 (Refresh Token)"></a>四、刷新令牌 (Refresh Token)</h2><p>访问令牌 (Access Token) 通常具有较短的有效期（如 15分钟），以限制其泄露后的危害。当 Access Token 过期后，客户端可以使用<strong>刷新令牌 (Refresh Token)</strong> 向授权服务器请求新的 Access Token，而无需用户重新登录或授权。</p>
<ul>
<li><strong>Access Token</strong>：用于访问资源，有效期短，生命周期暴露。</li>
<li><strong>Refresh Token</strong>：用于获取新的 Access Token，有效期长，敏感度高，通常只在客户端后端和授权服务器间交换。</li>
</ul>
<p><strong>刷新令牌流程：</strong></p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant client as 客户端 (后端或前端)
    participant auth_server as 授权服务器

    client-&gt;&gt;resource_server: 1. 使用 Access Token 请求资源
    resource_server--&gt;&gt;client: 2. Access Token 已过期 (HTTP 401 Unauthorized)

    client-&gt;&gt;auth_server: 3. 使用 Refresh Token 和 &#96;grant_type&#x3D;refresh_token&#96;, &#96;client_id&#96;, &#96;client_secret&#96; (如果有) 请求新的 Access Token
    auth_server-&gt;&gt;auth_server: 4. 验证 Refresh Token 有效性
    auth_server-&gt;&gt;client: 5. 颁发新的 Access Token (可附带新的 Refresh Token)
    client-&gt;&gt;resource_server: 6. 客户端使用新的 Access Token 重新请求资源
    resource_server--&gt;&gt;client: 7. 资源服务器返回受保护资源
  </pre></div>

<h2 id="五、安全性考虑与最佳实践"><a href="#五、安全性考虑与最佳实践" class="headerlink" title="五、安全性考虑与最佳实践"></a>五、安全性考虑与最佳实践</h2><p>OAuth 2.0 框架本身是安全的，但其实现和使用必须遵循以下最佳实践：</p>
<ol>
<li><strong>始终使用 HTTPS&#x2F;SSL</strong>：所有 OAuth 2.0 相关的通信都<strong>必须</strong>通过 HTTPS 进行，以防止令牌、授权码和凭据在传输过程中被窃听。</li>
<li><strong>严格的 <code>redirect_uri</code> 白名单</strong>：授权服务器必须严格验证 <code>redirect_uri</code>。只允许预先注册的完整 <code>URI</code>，防止授权码或令牌被重定向到恶意地址。</li>
<li><strong>使用 <code>state</code> 参数防范 CSRF</strong>：在所有授权请求中生成并使用不可预测的随机 <code>state</code> 参数，客户端发送请求时存储 <code>state</code>，接收回调时验证其是否匹配，防止跨站请求伪造。</li>
<li><strong>客户端密钥 (<code>client_secret</code>) 的安全存储</strong>：对于保密客户端，<code>client_secret</code> 必须安全地存储在服务器端，<strong>绝不能暴露在前端代码中</strong>。</li>
<li><strong>为公共客户端强制使用 PKCE</strong>：对于 SPA 和移动应用等公共客户端，<strong>必须使用</strong>授权码模式并集成 PKCE 扩展，以防范授权码拦截攻击。</li>
<li><strong>令牌生命周期管理</strong>：<ul>
<li><strong>Access Token 寿命短</strong>：建议设置为几分钟到几小时，减少泄露风险。</li>
<li><strong>Refresh Token 寿命长且安全</strong>：只用于获取新的 Access Token，应存储在安全的环境中（如客户端后端数据库或 <code>HttpOnly</code> Cookie），并通过撤销机制进行管理。</li>
</ul>
</li>
<li><strong>细粒度权限 (Scope)</strong>：客户端应只请求其业务所需的最小权限范围（遵循最小权限原则）。授权服务器应向用户清晰展示并允许用户选择授权范围。</li>
<li><strong>令牌撤销 (Token Revocation)</strong>：提供 API 允许资源所有者或客户端主动撤销（invalidate）已颁发的访问令牌和刷新令牌。</li>
</ol>
<h2 id="六、OAuth-2-0-与-OpenID-Connect-OIDC"><a href="#六、OAuth-2-0-与-OpenID-Connect-OIDC" class="headerlink" title="六、OAuth 2.0 与 OpenID Connect (OIDC)"></a>六、OAuth 2.0 与 OpenID Connect (OIDC)</h2><ul>
<li><strong>OAuth 2.0</strong>：主要用于<strong>授权 (Authorization)</strong>，即允许第三方应用访问用户资源。它只关心“谁”可以访问“什么”。</li>
<li><strong>OpenID Connect (OIDC)</strong>：是在 OAuth 2.0 基础之上构建的<strong>认证 (Authentication)</strong> 层。它在 OAuth 2.0 的授权流程之上，增加了用于验证用户身份的 <code>ID Token</code> (一个 JWT ），并提供用户身份信息。</li>
</ul>
<p>简单来说：</p>
<ul>
<li>OAuth 2.0 &#x3D; 授权协议（允许访问资源）</li>
<li>OpenID Connect &#x3D; 认证协议 + OAuth 2.0（允许访问资源 + 验证用户身份）</li>
</ul>
<p>许多“使用 Google&#x2F;GitHub 登录”的场景，实际上是结合了 OAuth 2.0 (授权) 和 OpenID Connect (认证) 的功能。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>OAuth 2.0 是现代互联网生态系统中不可或缺的授权框架，它通过引入令牌机制，在保证用户凭据安全的前提下，巧妙地解决了第三方应用访问用户资源的问题。理解其核心角色、授权模式（尤其是授权码+PKCE）和安全实践，对于构建安全的、面向 API 的应用和服务至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2025/2025-03-09_OAuth2.0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/">https://blog.tbf1211.xx.kg/2025/2025-03-09_OAuth2.0%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/OAuth2-0/">OAuth2.0</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/2025-03-15_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%20(Browser%20Fingerprinting)%20%E8%AF%A6%E8%A7%A3/" title="浏览器指纹 (Browser Fingerprinting) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">浏览器指纹 (Browser Fingerprinting) 详解</div></div><div class="info-2"><div class="info-item-1"> 浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是浏览器指纹？浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。 这个“指纹”的强大之处在于其持久性和隐蔽性，用户很难通过常规手段进行清除或规避。 二、浏览器指纹的工作原理网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括： 1. HTTP 请求头信息 (HTT...</div></div></div></a><a class="pagination-related" href="/2025/2025-03-01_%E5%93%88%E5%B8%8C%E8%A1%A8%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E8%AF%A6%E8%A7%A3(Load%20Factor)/" title="哈希表负载因子详解(Load Factor)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">哈希表负载因子详解(Load Factor)</div></div><div class="info-2"><div class="info-item-1"> 哈希表（Hash Table） 是一种非常高效的数据结构，它通过哈希函数将键（key）映射到数组的索引位置，从而实现常数时间复杂度 O(1) 的平均查找、插入和删除操作。然而，哈希表的性能并非总是 O(1)，它严重依赖于哈希函数、冲突解决策略以及一个关键的指标——负载因子（Load Factor）。  “The load factor of a hash table is a measure of how full the hash table is during its operation.” —— Wikipedia   一、什么是负载因子？负载因子 (Load Factor) 是衡量哈希表满载程度的一个指标。它定义为： $$\text{Load Factor} &#x3D; \frac{\text{Number of elements in the hash table (n)}}{\text{Total number of buckets (m)}}$$ 或者： $$\alpha &#x3D; \frac{n}{m}$$ 其中：  n (也可表示为 size) 是当前哈...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/2025-04-02_%20OAuth2.0%20PKCE%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%8F%90%E5%8D%87%E5%85%AC%E5%85%B1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E8%B7%B5/" title="OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-02</div><div class="info-item-2">OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0 是当前最流行的授权协议，广泛应用于各种场景，从单一登录到第三方应用授权。其中，授权码流 (Authorization Code Flow) 被认为是安全性最高的流程，因为它避免了 Access Token 直接暴露在前端。然而，对于公共客户端 (Public Clients)，如原生移动应用 (Native Apps) 和单页应用 (SPAs)，由于它们无法像传统 Web 服务器应用那样安全地存储客户端密钥 (Client Secret)，授权码流面临着一个安全漏洞：授权码拦截攻击 (Authorization Code Interception Attack)。为了解决这一问题，RFC 7636 引入了 PKCE (Proof Key for Code Exchange) 机制，极大地提升了公共客户端使用授权码流的安全性。  “PKCE 是 OAuth 2.0 授权码流的一个关键扩展，它专门为无法保密客户端密钥的公共客户端设计。它通过一种动态生成的验证机制，有效阻止了授权码被恶意拦截后用于获取 Access Token 的风险，是现代移动应用和 SPA 采...</div></div></div></a><a class="pagination-related" href="/2025/2025-03-15_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8C%87%E7%BA%B9%20(Browser%20Fingerprinting)%20%E8%AF%A6%E8%A7%A3/" title="浏览器指纹 (Browser Fingerprinting) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">浏览器指纹 (Browser Fingerprinting) 详解</div></div><div class="info-2"><div class="info-item-1"> 浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是浏览器指纹？浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。 这个“指纹”的强大之处在于其持久性和隐蔽性，用户很难通过常规手段进行清除或规避。 二、浏览器指纹的工作原理网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括： 1. HTTP 请求头信息 (HTT...</div></div></div></a><a class="pagination-related" href="/2023/2023-10-12_%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%A2%84%E9%98%B2%EF%BC%9A%E6%9E%84%E5%BB%BA%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8%E9%98%B2%E7%BA%BF/" title="常见网络攻击详解与预防：构建数字安全防线"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">常见网络攻击详解与预防：构建数字安全防线</div></div><div class="info-2"><div class="info-item-1"> 在数字时代，网络攻击已成为无处不在的威胁。从个人数据泄露到企业系统瘫痪，网络攻击的危害日益增长，形式也越来越多样化。理解这些S攻击类型、攻击原理以及如何有效预防它们，是构建强大数字安全防线的基石。本文将详细介绍一些最常见的网络攻击及其相应的防范措施。  “网络安全不是一蹴而就的，而是一个持续不断的过程，需要技术、策略和人的共同努力。”   一、概述：网络攻击的种类与威胁网络攻击通常利用系统、应用或协议的漏洞，试图破坏数据的机密性（Confidentiality）、完整性（Integrity）和可用性（Availability），即所谓的 CIA 三要素。 根据攻击目标和手段，网络攻击可以分为多种类型：  拒绝服务攻击 (DoS&#x2F;DDoS)：破坏系统的可用性。 数据窃取&#x2F;泄露：破坏数据的机密性。 数据篡改：破坏数据的完整性。 恶意程序感染：破坏系统的可控性，窃取数据或进行其他恶意活动。 社会工程学攻击：利用人性的弱点进行欺骗。  接下来，我们将详细解析几种最常见的攻击类型。 二、常见网络攻击详解与预防2.1 拒绝服务攻击 (DoS &#x2F; DDoS)2....</div></div></div></a><a class="pagination-related" href="/2023/2023-12-21_JWT%20(JSON%20Web%20Tokens)%20%E8%AF%A6%E8%A7%A3/" title="JWT (JSON Web Tokens) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="info-item-2">JWT (JSON Web Tokens) 详解</div></div><div class="info-2"><div class="info-item-1"> JWT (JSON Web Token) 是一个开放标准 (RFC 7519)，它定义了一种简洁、自包含且安全的方式，用于在各方之间安全地传输信息。这些信息通过数字签名进行验证，可以被信任。JWT 通常用作无状态 (Stateless) 认证机制，替代传统的 Session-Cookie 模式。  核心思想：将用户认证信息和少量授权信息编码进 Token 本身，并通过签名确保其不可篡改。 服务端无需存储 Session 状态，只需验证 Token 即可。   一、为什么需要 JWT？传统的基于 Session-Cookie 的认证方式有其局限性：  有状态 (Stateful)：服务端需要存储每个用户的 Session 信息。随着用户量增加，存储和管理 Session 成为负担，特别是分布式部署和微服务架构下，Session 共享和同步变得复杂。 跨域问题：Cookie 默认是同源策略，跨域请求携带 Cookie 会比较复杂，需要复杂的 CORS (Cross-Origin Resource Sharing) 配置。 移动端不友好：移动应用通常不依赖 Cookie，需要更灵活的...</div></div></div></a><a class="pagination-related" href="/2024/2024-01-18_%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0Token%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%8F%90%E5%8D%87%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%9A%84%E8%AE%A4%E8%AF%81%E7%AD%96%E7%95%A5/" title="无感刷新Token详解：提升用户体验与系统安全的认证策略"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-18</div><div class="info-item-2">无感刷新Token详解：提升用户体验与系统安全的认证策略</div></div><div class="info-2"><div class="info-item-1"> 在现代 Web 和移动应用中，基于 Token 的认证方式（如 JWT）已成为主流。它解决了传统 Session-Cookie 认证在分布式系统和跨域场景下的诸多痛点。然而，Token 的有效期问题又带来了新的挑战：如果 Access Token 长期有效，一旦泄露风险巨大；如果短期有效，用户又会频繁因 Token 过期而被迫重新登录，严重影响用户体验。无感刷新 Token (Silent Token Refresh) 正是为了解决这一矛盾而生，它旨在提升安全性、兼顾用户体验，让用户在不感知的情况下，始终保持登录状态。  “无感刷新 Token 的核心思想是：使用一个短期有效的 Access Token 负责日常业务访问，同时使用一个长期有效但受严密保护的 Refresh Token 来在 Access Token 过期时重新获取新的 Access Token，从而实现长期登录且不牺牲安全性的目标。”   一、为什么需要无感刷新 Token？在基于 Token 的认证系统中，通常会涉及到两种 Token：  Access Token (访问令牌)：  用途：用于访问受保护的资源...</div></div></div></a><a class="pagination-related" href="/2024/2024-03-16_%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2/" title="渗透测试原理详解：深入了解网络安全攻防"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-16</div><div class="info-item-2">渗透测试原理详解：深入了解网络安全攻防</div></div><div class="info-2"><div class="info-item-1"> 渗透测试（Penetration Testing） 是一种有目的、有计划的模拟攻击行为，旨在评估信息系统、网络、应用程序或组织的安全防护能力。它模拟恶意攻击者可能使用的技术和方法，主动发现系统中的安全漏洞、弱点和配置错误，并评估这些漏洞可能造成的潜在影响。渗透测试的最终目标是帮助组织识别并修复安全缺陷，提高整体的安全韧性，而非破坏或窃取数据。  核心思想：渗透测试像一次“模拟实战演习”，由专业的“红队”（渗透测试人员）扮演“黑客”，通过合法授权的攻击手段，挑战组织的“蓝队”（安全防护系统），从而发现真实世界中可能存在的安全盲点和薄弱环节。   一、为什么需要渗透测试？在当今高度互联的世界中，网络攻击日益频繁且复杂。传统的安全审计、漏洞扫描、代码审查等方法虽然重要，但它们往往局限于静态分析或已知漏洞的检测。渗透测试的价值在于：  主动发现未知漏洞：通过模拟真实攻击者的思维和手法，发现仅靠工具扫描难以识别的逻辑漏洞、业务漏洞和组合漏洞。 验证安全控制的有效性：测试已部署的安全设备（如防火墙、IDS&#x2F;IPS）、安全策略和人员响应机制是否能有效抵御攻击。 评估业务影响：清晰地...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">166</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">160</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81OAuth-2-0-%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF%E4%B8%8E%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">一、OAuth 2.0 产生的背景与解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81OAuth-2-0-%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2"><span class="toc-text">二、OAuth 2.0 中的核心角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81OAuth-2-0-%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F-Grant-Types"><span class="toc-text">三、OAuth 2.0 授权模式 (Grant Types)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F-Authorization-Code-Grant-%E6%8E%A8%E8%8D%90%EF%BC%81"><span class="toc-text">3.1 1. 授权码模式 (Authorization Code Grant) - 推荐！</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%A0%81-PKCE-Proof-Key-for-Code-Exchange-%E6%8E%A8%E8%8D%90%E7%94%A8%E4%BA%8E%E5%85%AC%E5%85%B1%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%81"><span class="toc-text">授权码 + PKCE (Proof Key for Code Exchange) - 推荐用于公共客户端！</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%AD%E6%8D%AE%E6%A8%A1%E5%BC%8F-Client-Credentials-Grant"><span class="toc-text">3.2 2. 客户端凭据模式 (Client Credentials Grant)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E8%AE%BE%E5%A4%87%E7%A0%81%E6%A8%A1%E5%BC%8F-Device-Authorization-Grant-Device-Flow"><span class="toc-text">3.3 3. 设备码模式 (Device Authorization Grant - Device Flow)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9A%90%E5%BC%8F%E6%A8%A1%E5%BC%8F-Implicit-Grant-%E5%92%8C-5-%E8%B5%84%E6%BA%90%E6%89%80%E6%9C%89%E8%80%85%E5%AF%86%E7%A0%81%E5%87%AD%E6%8D%AE%E6%A8%A1%E5%BC%8F-Resource-Owner-Password-Credentials-Grant"><span class="toc-text">4. 隐式模式 (Implicit Grant) 和 5. 资源所有者密码凭据模式 (Resource Owner Password Credentials Grant)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%88%B7%E6%96%B0%E4%BB%A4%E7%89%8C-Refresh-Token"><span class="toc-text">四、刷新令牌 (Refresh Token)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">五、安全性考虑与最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81OAuth-2-0-%E4%B8%8E-OpenID-Connect-OIDC"><span class="toc-text">六、OAuth 2.0 与 OpenID Connect (OIDC)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言并发与并行详解"/></a><div class="content"><a class="title" href="/2025/2025-10-23_Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AF%A6%E8%A7%A3/" title="Go语言并发与并行详解">Go语言并发与并行详解</a><time datetime="2025-10-22T22:24:00.000Z" title="发表于 2025-10-23 06:24:00">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-05.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>