<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go语言常用设计模式详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设计模式是对在特定情境下，反复出现的问题提供一套成熟的、可复用的解决方案。Go 语言以其简洁、并发优先的特性，在实现设计模式时通常会有其独特的“Go 惯例”，有时会与传统面向对象设计模式的实现有所不同。本篇将探讨 Go 语言中常用的设计模式，并结合 Go 的特性给出实现示例。  核心思想：Go 语言的设计模式实现通常倾向于简洁、组合而非继承、接口优先以及利用 Goroutine 和 Channe">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言常用设计模式详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2025/2025-06-13_Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="设计模式是对在特定情境下，反复出现的问题提供一套成熟的、可复用的解决方案。Go 语言以其简洁、并发优先的特性，在实现设计模式时通常会有其独特的“Go 惯例”，有时会与传统面向对象设计模式的实现有所不同。本篇将探讨 Go 语言中常用的设计模式，并结合 Go 的特性给出实现示例。  核心思想：Go 语言的设计模式实现通常倾向于简洁、组合而非继承、接口优先以及利用 Goroutine 和 Channe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg">
<meta property="article:published_time" content="2025-06-12T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-21T10:13:18.944Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="程序设计">
<meta property="article:tag" content="编程范式">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go语言常用设计模式详解",
  "url": "https://blog.tbf1211.xx.kg/2025/2025-06-13_Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-10.jpg",
  "datePublished": "2025-06-12T22:24:00.000Z",
  "dateModified": "2025-10-21T10:13:18.944Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2025/2025-06-13_Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go语言常用设计模式详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">155</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-10.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Go语言常用设计模式详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Go语言常用设计模式详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-06-12T22:24:00.000Z" title="发表于 2025-06-13 06:24:00">2025-06-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2025/2025-06-13_Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>设计模式是对在特定情境下，反复出现的问题提供一套成熟的、可复用的解决方案。Go 语言以其简洁、并发优先的特性，在实现设计模式时通常会有其独特的“Go 惯例”，有时会与传统面向对象设计模式的实现有所不同。本篇将探讨 Go 语言中常用的设计模式，并结合 Go 的特性给出实现示例。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>Go 语言的设计模式实现通常倾向于简洁、组合而非继承、接口优先以及利用 Goroutine 和 Channel 进行并发处理。</strong></p>
</div>

<h2 id="一、Go-语言与设计模式的哲学"><a href="#一、Go-语言与设计模式的哲学" class="headerlink" title="一、Go 语言与设计模式的哲学"></a>一、Go 语言与设计模式的哲学</h2><p>Go 语言在设计模式的实践上，有一些与传统 OOP 语言不同的哲学：</p>
<ol>
<li><strong>组合优于继承</strong>：Go 没有类继承的概念，而是通过结构体嵌入（Composition）和接口（Interfaces）来实现代码复用和多态。</li>
<li><strong>接口优先</strong>：Go 的接口是隐式实现的（implicit interface satisfaction），任何类型只要实现了接口定义的所有方法，就自然地实现了该接口。这使得接口更加灵活，鼓励“小接口，大组合”的原则。</li>
<li><strong>并发原语</strong>：Goroutine 和 Channel 是 Go 语言的核心并发原语，许多设计模式在 Go 中会自然融入并发考量。</li>
<li><strong>简洁性</strong>：Go 鼓励编写简洁、直接的代码，有时为了追求简洁会避免过度设计，一些复杂的设计模式可能会被更简单的 Go 风格代码所替代。</li>
</ol>
<h2 id="二、创建型设计模式-Creational-Design-Patterns"><a href="#二、创建型设计模式-Creational-Design-Patterns" class="headerlink" title="二、创建型设计模式 (Creational Design Patterns)"></a>二、创建型设计模式 (Creational Design Patterns)</h2><p>创建型模式关注对象的创建机制，旨在以一种安全、灵活的方式创建对象。</p>
<h3 id="2-1-单例模式-Singleton-Pattern"><a href="#2-1-单例模式-Singleton-Pattern" class="headerlink" title="2.1 单例模式 (Singleton Pattern)"></a>2.1 单例模式 (Singleton Pattern)</h3><p>确保一个类只有一个实例，并提供一个全局访问点。在 Go 中，通常使用 <code>sync.Once</code> 来保证线程安全的单例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	instance *singleton</span><br><span class="line">	once     sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetInstance 返回单例实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *singleton &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		instance = &amp;singleton&#123;name: <span class="string">&quot;Singleton Instance&quot;</span>&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Singleton instance created.&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoSomething 模拟单例实例的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *singleton)</span></span> DoSomething() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Doing something with %s\n&quot;</span>, s.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	s1 := singleton.GetInstance()</span></span><br><span class="line"><span class="comment">	s1.DoSomething()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	s2 := singleton.GetInstance()</span></span><br><span class="line"><span class="comment">	s2.DoSomething()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	if s1 == s2 &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;s1 and s2 are the same instance.&quot;)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-工厂模式-Factory-Pattern"><a href="#2-2-工厂模式-Factory-Pattern" class="headerlink" title="2.2 工厂模式 (Factory Pattern)"></a>2.2 工厂模式 (Factory Pattern)</h3><p>定义一个创建对象的接口，但由子类决定实例化哪个类。在 Go 中，通常使用一个函数返回接口类型，根据输入参数创建不同具体的结构体实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Product 是产品接口</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">	Use()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteProductA 是具体产品A</span></span><br><span class="line"><span class="keyword">type</span> ConcreteProductA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcreteProductA)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Using ConcreteProductA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteProductB 是具体产品B</span></span><br><span class="line"><span class="keyword">type</span> ConcreteProductB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcreteProductB)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Using ConcreteProductB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory 是工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Factory</span><span class="params">(productType <span class="type">string</span>)</span></span> Product &#123;</span><br><span class="line">	<span class="keyword">switch</span> productType &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;ConcreteProductA&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;ConcreteProductB&#123;&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	productA := factory.Factory(&quot;A&quot;)</span></span><br><span class="line"><span class="comment">	if productA != nil &#123;</span></span><br><span class="line"><span class="comment">		productA.Use()</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	productB := factory.Factory(&quot;B&quot;)</span></span><br><span class="line"><span class="comment">	if productB != nil &#123;</span></span><br><span class="line"><span class="comment">		productB.Use()</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	productC := factory.Factory(&quot;C&quot;)</span></span><br><span class="line"><span class="comment">	if productC == nil &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;Product C not found.&quot;)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-抽象工厂模式-Abstract-Factory-Pattern"><a href="#2-3-抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="2.3 抽象工厂模式 (Abstract Factory Pattern)"></a>2.3 抽象工厂模式 (Abstract Factory Pattern)</h3><p>提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。在 Go 中，这通常通过定义多个工厂函数或返回不同类型工厂的工厂来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstract_factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductA, ProductB ... 是产品族的接口</span></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">interface</span> &#123;</span><br><span class="line">	MethodA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">interface</span> &#123;</span><br><span class="line">	MethodB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === 产品族1 ===</span></span><br><span class="line"><span class="keyword">type</span> ConcreteProductA1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcreteProductA1)</span></span> MethodA() &#123; fmt.Println(<span class="string">&quot;ProductA1 MethodA&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcreteProductB1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcreteProductB1)</span></span> MethodB() &#123; fmt.Println(<span class="string">&quot;ProductB1 MethodB&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory1 是具体工厂1</span></span><br><span class="line"><span class="keyword">type</span> Factory1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory1)</span></span> CreateProductA() ProductA &#123; <span class="keyword">return</span> &amp;ConcreteProductA1&#123;&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory1)</span></span> CreateProductB() ProductB &#123; <span class="keyword">return</span> &amp;ConcreteProductB1&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === 产品族2 ===</span></span><br><span class="line"><span class="keyword">type</span> ConcreteProductA2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcreteProductA2)</span></span> MethodA() &#123; fmt.Println(<span class="string">&quot;ProductA2 MethodA&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcreteProductB2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ConcreteProductB2)</span></span> MethodB() &#123; fmt.Println(<span class="string">&quot;ProductB2 MethodB&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Factory2 是具体工厂2</span></span><br><span class="line"><span class="keyword">type</span> Factory2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory2)</span></span> CreateProductA() ProductA &#123; <span class="keyword">return</span> &amp;ConcreteProductA2&#123;&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Factory2)</span></span> CreateProductB() ProductB &#123; <span class="keyword">return</span> &amp;ConcreteProductB2&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractFactory 是抽象工厂接口</span></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreateProductA() ProductA</span><br><span class="line">	CreateProductB() ProductB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	var factory AbstractFactory</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 使用工厂1</span></span><br><span class="line"><span class="comment">	factory = &amp;abstract_factory.Factory1&#123;&#125;</span></span><br><span class="line"><span class="comment">	pa1 := factory.CreateProductA()</span></span><br><span class="line"><span class="comment">	pb1 := factory.CreateProductB()</span></span><br><span class="line"><span class="comment">	pa1.MethodA()</span></span><br><span class="line"><span class="comment">	pb1.MethodB()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 使用工厂2</span></span><br><span class="line"><span class="comment">	factory = &amp;abstract_factory.Factory2&#123;&#125;</span></span><br><span class="line"><span class="comment">	pa2 := factory.CreateProductA()</span></span><br><span class="line"><span class="comment">	pb2 := factory.CreateProductB()</span></span><br><span class="line"><span class="comment">	pa2.MethodA()</span></span><br><span class="line"><span class="comment">	pb2.MethodB()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-建造者模式-Builder-Pattern"><a href="#2-4-建造者模式-Builder-Pattern" class="headerlink" title="2.4 建造者模式 (Builder Pattern)"></a>2.4 建造者模式 (Builder Pattern)</h3><p>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Product 是最终要构建的复杂对象</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	PartA <span class="type">string</span></span><br><span class="line">	PartB <span class="type">string</span></span><br><span class="line">	PartC <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span></span> Show() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Product: PartA=%s, PartB=%s, PartC=%s\n&quot;</span>, p.PartA, p.PartB, p.PartC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder 是抽象建造者接口</span></span><br><span class="line"><span class="keyword">type</span> Builder <span class="keyword">interface</span> &#123;</span><br><span class="line">	BuildPartA()</span><br><span class="line">	BuildPartB()</span><br><span class="line">	BuildPartC()</span><br><span class="line">	GetProduct() *Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteBuilder 是具体建造者</span></span><br><span class="line"><span class="keyword">type</span> ConcreteBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">	product *Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteBuilder</span><span class="params">()</span></span> *ConcreteBuilder &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteBuilder&#123;product: &amp;Product&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span></span> BuildPartA() &#123;</span><br><span class="line">	b.product.PartA = <span class="string">&quot;PartA constructed&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span></span> BuildPartB() &#123;</span><br><span class="line">	b.product.PartB = <span class="string">&quot;PartB constructed&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span></span> BuildPartC() &#123;</span><br><span class="line">	b.product.PartC = <span class="string">&quot;PartC constructed&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *ConcreteBuilder)</span></span> GetProduct() *Product &#123;</span><br><span class="line">	<span class="keyword">return</span> b.product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Director 是指导者，负责按照特定顺序构建Product</span></span><br><span class="line"><span class="keyword">type</span> Director <span class="keyword">struct</span> &#123;</span><br><span class="line">	builder Builder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDirector</span><span class="params">(builder Builder)</span></span> *Director &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Director&#123;builder: builder&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Director)</span></span> Construct() *Product &#123;</span><br><span class="line">	d.builder.BuildPartA()</span><br><span class="line">	d.builder.BuildPartB()</span><br><span class="line">	d.builder.BuildPartC()</span><br><span class="line">	<span class="keyword">return</span> d.builder.GetProduct()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	builder := builder.NewConcreteBuilder()</span></span><br><span class="line"><span class="comment">	director := builder.NewDirector(builder)</span></span><br><span class="line"><span class="comment">	product := director.Construct()</span></span><br><span class="line"><span class="comment">	product.Show()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="三、结构型设计模式-Structural-Design-Patterns"><a href="#三、结构型设计模式-Structural-Design-Patterns" class="headerlink" title="三、结构型设计模式 (Structural Design Patterns)"></a>三、结构型设计模式 (Structural Design Patterns)</h2><p>结构型模式关注如何将类和对象组合成更大的结构，以实现新的功能。</p>
<h3 id="3-1-适配器模式-Adapter-Pattern"><a href="#3-1-适配器模式-Adapter-Pattern" class="headerlink" title="3.1 适配器模式 (Adapter Pattern)"></a>3.1 适配器模式 (Adapter Pattern)</h3><p>将一个类的接口转换成客户希望的另一个接口。适配器模式使原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Target 是客户端期望的接口</span></span><br><span class="line"><span class="keyword">type</span> Target <span class="keyword">interface</span> &#123;</span><br><span class="line">	Request() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adaptee 是需要被适配的接口（不兼容的接口）</span></span><br><span class="line"><span class="keyword">type</span> Adaptee <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Adaptee)</span></span> SpecificRequest() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Specific request from Adaptee&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter 是适配器，实现了 Target 接口，并包含 Adaptee 实例</span></span><br><span class="line"><span class="keyword">type</span> Adapter <span class="keyword">struct</span> &#123;</span><br><span class="line">	adaptee *Adaptee</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAdapter</span><span class="params">(adaptee *Adaptee)</span></span> *Adapter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Adapter&#123;adaptee: adaptee&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Adapter)</span></span> Request() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Adapter translated: &quot;</span> + a.adaptee.SpecificRequest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	adaptee := &amp;adapter.Adaptee&#123;&#125;</span></span><br><span class="line"><span class="comment">	target := adapter.NewAdapter(adaptee)</span></span><br><span class="line"><span class="comment">	fmt.Println(target.Request())</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-装饰器模式-Decorator-Pattern"><a href="#3-2-装饰器模式-Decorator-Pattern" class="headerlink" title="3.2 装饰器模式 (Decorator Pattern)"></a>3.2 装饰器模式 (Decorator Pattern)</h3><p>动态地给一个对象添加一些额外的职责。相比于使用继承，装饰器模式更加灵活。在 Go 中，通常通过结构体嵌入和接口来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Component 是被装饰的接口</span></span><br><span class="line"><span class="keyword">type</span> Component <span class="keyword">interface</span> &#123;</span><br><span class="line">	Operation() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteComponent 是具体组件</span></span><br><span class="line"><span class="keyword">type</span> ConcreteComponent <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteComponent)</span></span> Operation() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;ConcreteComponent&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorator 是抽象装饰器 - Go中通常直接定义具体的装饰器</span></span><br><span class="line"><span class="comment">// 或者一个结构体嵌入Component接口</span></span><br><span class="line"><span class="keyword">type</span> BaseDecorator <span class="keyword">struct</span> &#123;</span><br><span class="line">	component Component</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *BaseDecorator)</span></span> Operation() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> d.component.Operation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteDecoratorA 是具体装饰器A</span></span><br><span class="line"><span class="keyword">type</span> ConcreteDecoratorA <span class="keyword">struct</span> &#123;</span><br><span class="line">	BaseDecorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteDecoratorA</span><span class="params">(c Component)</span></span> *ConcreteDecoratorA &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteDecoratorA&#123;BaseDecorator&#123;component: c&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *ConcreteDecoratorA)</span></span> Operation() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;DecoratorA(&quot;</span> + d.BaseDecorator.Operation() + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteDecoratorB 是具体装饰器B</span></span><br><span class="line"><span class="keyword">type</span> ConcreteDecoratorB <span class="keyword">struct</span> &#123;</span><br><span class="line">	BaseDecorator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteDecoratorB</span><span class="params">(c Component)</span></span> *ConcreteDecoratorB &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteDecoratorB&#123;BaseDecorator&#123;component: c&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *ConcreteDecoratorB)</span></span> Operation() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;DecoratorB(&quot;</span> + d.BaseDecorator.Operation() + <span class="string">&quot;)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	component := &amp;decorator.ConcreteComponent&#123;&#125;</span></span><br><span class="line"><span class="comment">	fmt.Println(component.Operation()) // 输出: ConcreteComponent</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	decoratorA := decorator.NewConcreteDecoratorA(component)</span></span><br><span class="line"><span class="comment">	fmt.Println(decoratorA.Operation()) // 输出: DecoratorA(ConcreteComponent)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	decoratorB := decorator.NewConcreteDecoratorB(decoratorA) // 装饰器可以层层嵌套</span></span><br><span class="line"><span class="comment">	fmt.Println(decoratorB.Operation()) // 输出: DecoratorB(DecoratorA(ConcreteComponent))</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-代理模式-Proxy-Pattern"><a href="#3-3-代理模式-Proxy-Pattern" class="headerlink" title="3.3 代理模式 (Proxy Pattern)"></a>3.3 代理模式 (Proxy Pattern)</h3><p>为另一个对象提供一个替身或占位符，以控制对这个对象的访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject 是主题接口</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">	Request() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RealSubject 是真实主题</span></span><br><span class="line"><span class="keyword">type</span> RealSubject <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *RealSubject)</span></span> Request() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;RealSubject handling request&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy 是代理</span></span><br><span class="line"><span class="keyword">type</span> Proxy <span class="keyword">struct</span> &#123;</span><br><span class="line">	realSubject *RealSubject <span class="comment">// 持有真实主题的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProxy</span><span class="params">()</span></span> *Proxy &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Proxy&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Proxy)</span></span> Request() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 在访问真实主题之前/之后可以执行一些额外操作</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Proxy: Doing something before forwarding request.&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> p.realSubject == <span class="literal">nil</span> &#123;</span><br><span class="line">		p.realSubject = &amp;RealSubject&#123;&#125; <span class="comment">// 延迟初始化真实主题</span></span><br><span class="line">	&#125;</span><br><span class="line">	result := p.realSubject.Request()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Proxy: Doing something after forwarding request.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	proxy := proxy.NewProxy()</span></span><br><span class="line"><span class="comment">	fmt.Println(proxy.Request())</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-外观模式-Facade-Pattern"><a href="#3-4-外观模式-Facade-Pattern" class="headerlink" title="3.4 外观模式 (Facade Pattern)"></a>3.4 外观模式 (Facade Pattern)</h3><p>为子系统中的一组接口提供一个统一的接口。外观定义了一个高层接口，这个接口使得子系统更容易使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> facade</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SubsystemA, SubsystemB, SubsystemC 是子系统</span></span><br><span class="line"><span class="keyword">type</span> SubsystemA <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SubsystemA)</span></span> OperationA() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;SubsystemA Operation&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SubsystemB <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SubsystemB)</span></span> OperationB() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;SubsystemB Operation&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SubsystemC <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SubsystemC)</span></span> OperationC() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;SubsystemC Operation&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Facade 是外观模式的入口</span></span><br><span class="line"><span class="keyword">type</span> Facade <span class="keyword">struct</span> &#123;</span><br><span class="line">	subsystemA *SubsystemA</span><br><span class="line">	subsystemB *SubsystemB</span><br><span class="line">	subsystemC *SubsystemC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFacade</span><span class="params">()</span></span> *Facade &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Facade&#123;</span><br><span class="line">		subsystemA: &amp;SubsystemA&#123;&#125;,</span><br><span class="line">		subsystemB: &amp;SubsystemB&#123;&#125;,</span><br><span class="line">		subsystemC: &amp;SubsystemC&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OperateMethod1 提供了子系统A和B的组合操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Facade)</span></span> OperateMethod1() <span class="type">string</span> &#123;</span><br><span class="line">	result := f.subsystemA.OperationA() + <span class="string">&quot;\n&quot;</span></span><br><span class="line">	result += f.subsystemB.OperationB()</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OperateMethod2 提供了子系统C的简单操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Facade)</span></span> OperateMethod2() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f.subsystemC.OperationC()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	facade := facade.NewFacade()</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;--- Method 1 ---&quot;)</span></span><br><span class="line"><span class="comment">	fmt.Println(facade.OperateMethod1())</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;\n--- Method 2 ---&quot;)</span></span><br><span class="line"><span class="comment">	fmt.Println(facade.OperateMethod2())</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="四、行为型设计模式-Behavioral-Design-Patterns"><a href="#四、行为型设计模式-Behavioral-Design-Patterns" class="headerlink" title="四、行为型设计模式 (Behavioral Design Patterns)"></a>四、行为型设计模式 (Behavioral Design Patterns)</h2><p>行为型模式关注对象之间的职责分配和通信方式。</p>
<h3 id="4-1-观察者模式-Observer-Pattern"><a href="#4-1-观察者模式-Observer-Pattern" class="headerlink" title="4.1 观察者模式 (Observer Pattern)"></a>4.1 观察者模式 (Observer Pattern)</h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。Go 中通常通过 Channel 或回调函数实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer 是观察者接口</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Update(message <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteObserver 是具体观察者</span></span><br><span class="line"><span class="keyword">type</span> ConcreteObserver <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteObserver</span><span class="params">(id <span class="type">int</span>)</span></span> *ConcreteObserver &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteObserver&#123;id: id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ConcreteObserver)</span></span> Update(message <span class="type">string</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Observer %d received message: %s\n&quot;</span>, o.id, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject 是主题 (被观察者)</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">	observers []Observer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Attach(o Observer) &#123;</span><br><span class="line">	s.observers = <span class="built_in">append</span>(s.observers, o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Detach(o Observer) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, obs := <span class="keyword">range</span> s.observers &#123;</span><br><span class="line">		<span class="keyword">if</span> obs == o &#123;</span><br><span class="line">			s.observers = <span class="built_in">append</span>(s.observers[:i], s.observers[i+<span class="number">1</span>:]...)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Notify(message <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, o := <span class="keyword">range</span> s.observers &#123;</span><br><span class="line">		o.Update(message)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main()  &#123;</span></span><br><span class="line"><span class="comment">	subject := &amp;observer.Subject&#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	obs1 := observer.NewConcreteObserver(1)</span></span><br><span class="line"><span class="comment">	obs2 := observer.NewConcreteObserver(2)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	subject.Attach(obs1)</span></span><br><span class="line"><span class="comment">	subject.Attach(obs2)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	subject.Notify(&quot;State changed!&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	subject.Detach(obs1)</span></span><br><span class="line"><span class="comment">	subject.Notify(&quot;Another state change!&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>Go 风格的观察者模式</strong> 也可以利用 Channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> observer_channel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Event 是观察者传递的消息类型</span></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">	Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer 是一个接收 Event 的 Channel</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">chan</span> Event</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject 是主题</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">	subscribers []Observer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Register(obs Observer) &#123;</span><br><span class="line">	s.subscribers = <span class="built_in">append</span>(s.subscribers, obs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Unregister(obs Observer) &#123;</span><br><span class="line">	<span class="keyword">for</span> i, o := <span class="keyword">range</span> s.subscribers &#123;</span><br><span class="line">		<span class="keyword">if</span> o == obs &#123;</span><br><span class="line">			<span class="built_in">close</span>(o) <span class="comment">// 关闭 Channel</span></span><br><span class="line">			s.subscribers = <span class="built_in">append</span>(s.subscribers[:i], s.subscribers[i+<span class="number">1</span>:]...)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Notify(event Event) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, obs := <span class="keyword">range</span> s.subscribers &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> obs &lt;- event: <span class="comment">// 非阻塞发送</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">&quot;Observer channel is full, skipping event:&quot;</span>, event.Message)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	subject := &amp;observer_channel.Subject&#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	obs1 := make(observer_channel.Observer, 1) // 有缓冲 Channel</span></span><br><span class="line"><span class="comment">	obs2 := make(observer_channel.Observer, 1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	subject.Register(obs1)</span></span><br><span class="line"><span class="comment">	subject.Register(obs2)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	go func() &#123;</span></span><br><span class="line"><span class="comment">		for event := range obs1 &#123;</span></span><br><span class="line"><span class="comment">			fmt.Printf(&quot;Observer 1 received: %s\n&quot;, event.Message)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;Observer 1 stopped.&quot;)</span></span><br><span class="line"><span class="comment">	&#125;()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	go func() &#123;</span></span><br><span class="line"><span class="comment">		for event := range obs2 &#123;</span></span><br><span class="line"><span class="comment">			fmt.Printf(&quot;Observer 2 received: %s\n&quot;, event.Message)</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;Observer 2 stopped.&quot;)</span></span><br><span class="line"><span class="comment">	&#125;()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	subject.Notify(observer_channel.Event&#123;Message: &quot;First event&quot;&#125;)</span></span><br><span class="line"><span class="comment">	time.Sleep(100 * time.Millisecond) // 等待 goroutine 处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	subject.Unregister(obs1)</span></span><br><span class="line"><span class="comment">	subject.Notify(observer_channel.Event&#123;Message: &quot;Second event, obs1 removed&quot;&#125;)</span></span><br><span class="line"><span class="comment">	time.Sleep(100 * time.Millisecond)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 模拟阻塞情况</span></span><br><span class="line"><span class="comment">	subject.Notify(observer_channel.Event&#123;Message: &quot;Third event (will block if channel is full)&quot;&#125;)</span></span><br><span class="line"><span class="comment">	subject.Notify(observer_channel.Event&#123;Message: &quot;Fourth event (will be skipped)&quot;&#125;) // 如果没人读取，这个会被跳过</span></span><br><span class="line"><span class="comment">	time.Sleep(1 * time.Second) // 确保所有 goroutines 有时间完成</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-策略模式-Strategy-Pattern"><a href="#4-2-策略模式-Strategy-Pattern" class="headerlink" title="4.2 策略模式 (Strategy Pattern)"></a>4.2 策略模式 (Strategy Pattern)</h3><p>定义一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strategy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Strategy 是策略接口</span></span><br><span class="line"><span class="keyword">type</span> Strategy <span class="keyword">interface</span> &#123;</span><br><span class="line">	Execute(a, b <span class="type">int</span>) <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteStrategyAdd 是具体策略：加法</span></span><br><span class="line"><span class="keyword">type</span> ConcreteStrategyAdd <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ConcreteStrategyAdd)</span></span> Execute(a, b <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteStrategySubtract 是具体策略：减法</span></span><br><span class="line"><span class="keyword">type</span> ConcreteStrategySubtract <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ConcreteStrategySubtract)</span></span> Execute(a, b <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context 是上下文，持有策略对象</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	strategy Strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(strategy Strategy)</span></span> *Context &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;strategy: strategy&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SetStrategy(strategy Strategy) &#123;</span><br><span class="line">	c.strategy = strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PerformOperation(a, b <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.strategy.Execute(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	// 使用加法策略</span></span><br><span class="line"><span class="comment">	context := strategy.NewContext(&amp;strategy.ConcreteStrategyAdd&#123;&#125;)</span></span><br><span class="line"><span class="comment">	result := context.PerformOperation(10, 5)</span></span><br><span class="line"><span class="comment">	fmt.Printf(&quot;10 + 5 = %d\n&quot;, result) // Output: 10 + 5 = 15</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 切换到减法策略</span></span><br><span class="line"><span class="comment">	context.SetStrategy(&amp;strategy.ConcreteStrategySubtract&#123;&#125;)</span></span><br><span class="line"><span class="comment">	result = context.PerformOperation(10, 5)</span></span><br><span class="line"><span class="comment">	fmt.Printf(&quot;10 - 5 = %d\n&quot;, result) // Output: 10 - 5 = 5</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-模板方法模式-Template-Method-Pattern"><a href="#4-3-模板方法模式-Template-Method-Pattern" class="headerlink" title="4.3 模板方法模式 (Template Method Pattern)"></a>4.3 模板方法模式 (Template Method Pattern)</h3><p>定义一个算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些特定步骤。在 Go 中，通常通过接口和结构体嵌入结合实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> template_method</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractClass 是抽象类 (Go 中通过接口定义骨架，通过结构体嵌入实现公共行为)</span></span><br><span class="line"><span class="keyword">type</span> AbstractClass <span class="keyword">interface</span> &#123;</span><br><span class="line">	TemplateMethod()</span><br><span class="line">	step1() <span class="comment">// 抽象步骤1</span></span><br><span class="line">	step2() <span class="comment">// 抽象步骤2</span></span><br><span class="line">	hook()  <span class="comment">// 钩子方法 (可选)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template 实现公共的TemplateMethod，并依赖具体的step1和step2</span></span><br><span class="line"><span class="comment">// 它嵌入了 AbstractClass 接口，但更常见的是一个基结构体，包含对自身的接口引用</span></span><br><span class="line"><span class="keyword">type</span> template <span class="keyword">struct</span> &#123;</span><br><span class="line">	impl AbstractClass <span class="comment">// 保存具体实现的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *template)</span></span> TemplateMethod() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Starting Template Method...&quot;</span>)</span><br><span class="line">	t.impl.step1()</span><br><span class="line">	t.impl.step2()</span><br><span class="line">	t.impl.hook() <span class="comment">// 可选钩子</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Template Method Finished.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteClassA 是具体实现A</span></span><br><span class="line"><span class="keyword">type</span> ConcreteClassA <span class="keyword">struct</span> &#123;</span><br><span class="line">	template <span class="comment">// 嵌入模板结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteClassA</span><span class="params">()</span></span> *ConcreteClassA &#123;</span><br><span class="line">	c := &amp;ConcreteClassA&#123;&#125;</span><br><span class="line">	c.template.impl = c <span class="comment">// 将自身作为实现传递给模板</span></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteClassA)</span></span> step1() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteClassA: Step 1 executed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteClassA)</span></span> step2() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteClassA: Step 2 executed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteClassA)</span></span> hook() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteClassA: Hook executed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteClassB 是具体实现B</span></span><br><span class="line"><span class="keyword">type</span> ConcreteClassB <span class="keyword">struct</span> &#123;</span><br><span class="line">	template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConcreteClassB</span><span class="params">()</span></span> *ConcreteClassB &#123;</span><br><span class="line">	c := &amp;ConcreteClassB&#123;&#125;</span><br><span class="line">	c.template.impl = c</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteClassB)</span></span> step1() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteClassB: Step 1 executed differently.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteClassB)</span></span> step2() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteClassB: Step 2 executed differently.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ConcreteClassB)</span></span> hook() &#123;</span><br><span class="line">	<span class="comment">// ConcreteClassB choose not to implement the hook or do nothing</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;ConcreteClassB: Hook is optional.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;--- Using ConcreteClassA ---&quot;)</span></span><br><span class="line"><span class="comment">	classA := template_method.NewConcreteClassA()</span></span><br><span class="line"><span class="comment">	classA.TemplateMethod()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;\n--- Using ConcreteClassB ---&quot;)</span></span><br><span class="line"><span class="comment">	classB := template_method.NewConcreteClassB()</span></span><br><span class="line"><span class="comment">	classB.TemplateMethod()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-迭代器模式-Iterator-Pattern"><a href="#4-4-迭代器模式-Iterator-Pattern" class="headerlink" title="4.4 迭代器模式 (Iterator Pattern)"></a>4.4 迭代器模式 (Iterator Pattern)</h3><p>提供一种顺序访问聚合对象中各个元素的方法，而不暴露该对象的内部表示。Go 语言中，数组、切片、映射等有内置的 <code>for...range</code> 机制，通常无需手动实现迭代器。但在某些复杂数据结构 (如树、图) 中，自定义迭代器仍然有用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iterator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Item 是聚合中的元素</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Aggregate 是聚合接口</span></span><br><span class="line"><span class="keyword">type</span> Aggregate <span class="keyword">interface</span> &#123;</span><br><span class="line">	Iterator() Iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 是迭代器接口</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">	HasNext() <span class="type">bool</span></span><br><span class="line">	Next() *Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteAggregate 是具体聚合</span></span><br><span class="line"><span class="keyword">type</span> ConcreteAggregate <span class="keyword">struct</span> &#123;</span><br><span class="line">	items []*Item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *ConcreteAggregate)</span></span> AddItem(item *Item) &#123;</span><br><span class="line">	a.items = <span class="built_in">append</span>(a.items, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *ConcreteAggregate)</span></span> Iterator() Iterator &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ConcreteIterator&#123;</span><br><span class="line">		aggregate: a,</span><br><span class="line">		index:     <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteIterator 是具体迭代器</span></span><br><span class="line"><span class="keyword">type</span> ConcreteIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	aggregate *ConcreteAggregate</span><br><span class="line">	index     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *ConcreteIterator)</span></span> HasNext() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> it.index &lt; <span class="built_in">len</span>(it.aggregate.items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *ConcreteIterator)</span></span> Next() *Item &#123;</span><br><span class="line">	<span class="keyword">if</span> it.HasNext() &#123;</span><br><span class="line">		item := it.aggregate.items[it.index]</span><br><span class="line">		it.index++</span><br><span class="line">		<span class="keyword">return</span> item</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	aggregate := &amp;iterator.ConcreteAggregate&#123;&#125;</span></span><br><span class="line"><span class="comment">	aggregate.AddItem(&amp;iterator.Item&#123;Name: &quot;Item 1&quot;&#125;)</span></span><br><span class="line"><span class="comment">	aggregate.AddItem(&amp;iterator.Item&#123;Name: &quot;Item 2&quot;&#125;)</span></span><br><span class="line"><span class="comment">	aggregate.AddItem(&amp;iterator.Item&#123;Name: &quot;Item 3&quot;&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	it := aggregate.Iterator()</span></span><br><span class="line"><span class="comment">	for it.HasNext() &#123;</span></span><br><span class="line"><span class="comment">		item := it.Next()</span></span><br><span class="line"><span class="comment">		fmt.Printf(&quot;Processing item: %s\n&quot;, item.Name)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="五、Go-语言特有模式-惯用法"><a href="#五、Go-语言特有模式-惯用法" class="headerlink" title="五、Go 语言特有模式 &#x2F; 惯用法"></a>五、Go 语言特有模式 &#x2F; 惯用法</h2><p>除了经典的 GoF 设计模式，Go 语言因其独特的特性，也催生了一些独有的惯用模式。</p>
<h3 id="5-1-Goroutine-Channel-模式"><a href="#5-1-Goroutine-Channel-模式" class="headerlink" title="5.1 Goroutine &#x2F; Channel 模式"></a>5.1 Goroutine &#x2F; Channel 模式</h3><p>这是 Go 语言最核心的并发模式，广泛应用于各种并发场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> goroutine_channel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 是一个执行任务的 goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(id <span class="type">int</span>, tasks &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Worker %d started task %d\n&quot;</span>, id, task)</span><br><span class="line">		time.Sleep(time.Duration(task) * <span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟工作</span></span><br><span class="line">		results &lt;- fmt.Sprintf(<span class="string">&quot;Worker %d finished task %d&quot;</span>, id, task)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	numTasks := 10</span></span><br><span class="line"><span class="comment">	numWorkers := 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	tasks := make(chan int, numTasks)</span></span><br><span class="line"><span class="comment">	results := make(chan string, numTasks)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	var wg sync.WaitGroup</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 启动 worker goroutine</span></span><br><span class="line"><span class="comment">	for i := 1; i &lt;= numWorkers; i++ &#123;</span></span><br><span class="line"><span class="comment">		wg.Add(1)</span></span><br><span class="line"><span class="comment">		go func(id int) &#123;</span></span><br><span class="line"><span class="comment">			defer wg.Done()</span></span><br><span class="line"><span class="comment">			goroutine_channel.Worker(id, tasks, results)</span></span><br><span class="line"><span class="comment">		&#125;(i)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 分发任务</span></span><br><span class="line"><span class="comment">	for i := 1; i &lt;= numTasks; i++ &#123;</span></span><br><span class="line"><span class="comment">		tasks &lt;- i</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	close(tasks) // 关闭任务通道，表示没有更多任务了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 等待所有 worker 完成</span></span><br><span class="line"><span class="comment">	wg.Wait()</span></span><br><span class="line"><span class="comment">	close(results) // 关闭结果通道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 收集结果</span></span><br><span class="line"><span class="comment">	for result := range results &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(result)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;All tasks completed.&quot;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-Context-模式"><a href="#5-2-Context-模式" class="headerlink" title="5.2 Context 模式"></a>5.2 Context 模式</h3><p>Go 语言的 <code>context</code> 包用于在 API 边界之间携带截止时间、取消信号和其他请求范围的值。它在处理超时、取消请求、链路追踪等方面非常有用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> context_pattern</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoWork</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">		fmt.Println(<span class="string">&quot;Task completed successfully.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		<span class="comment">// 当 context 被取消或超时时，会收到信号</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Task cancelled or timed out:&quot;</span>, ctx.Err())</span><br><span class="line">		<span class="keyword">return</span> ctx.Err()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">	// 示例 1: 超时</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;--- Context with Timeout ---&quot;)</span></span><br><span class="line"><span class="comment">	ctxTimeout, cancelTimeout := context.WithTimeout(context.Background(), 1*time.Second)</span></span><br><span class="line"><span class="comment">	defer cancelTimeout()</span></span><br><span class="line"><span class="comment">	err := context_pattern.DoWork(ctxTimeout)</span></span><br><span class="line"><span class="comment">	if err != nil &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;Error:&quot;, err)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	time.Sleep(500 * time.Millisecond) // 稍微等待一下</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	// 示例 2: 取消</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;\n--- Context with Cancel ---&quot;)</span></span><br><span class="line"><span class="comment">	ctxCancel, cancelCancel := context.WithCancel(context.Background())</span></span><br><span class="line"><span class="comment">	go func() &#123;</span></span><br><span class="line"><span class="comment">		time.Sleep(1 * time.Second) // 0.5秒后取消任务</span></span><br><span class="line"><span class="comment">		cancelCancel()</span></span><br><span class="line"><span class="comment">	&#125;()</span></span><br><span class="line"><span class="comment">	err = context_pattern.DoWork(ctxCancel)</span></span><br><span class="line"><span class="comment">	if err != nil &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println(&quot;Error:&quot;, err)</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Go 语言的设计模式是其独特编程哲学和语言特性（尤其是接口、组合、并发原语）的体现。</p>
<ul>
<li><strong>创建型模式</strong>：通常利用函数和接口来抽象创建过程，<code>sync.Once</code> 是实现单例的关键。</li>
<li><strong>结构型模式</strong>：通过接口和结构体嵌入来实现对象的组合和间接访问。</li>
<li><strong>行为型模式</strong>：关注对象间的通信，Go 的 Channel 和 Goroutine 为实现并发行为模式提供了强大的原生支持。</li>
<li><strong>Go 惯用法</strong>：<code>context</code> 包用于跨 API 边界传递取消信号和截止时间，Goroutine 和 Channel 是 Go 并发编程的基石，而非传统 OOP 的设计模式。</li>
</ul>
<p>在学习 Go 语言设计模式时，应秉持 Go 的“实用主义”精神，避免盲目套用传统设计模式，而是结合 Go 的语言特性，选择最简洁、最 Go 风格的解决方案。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2025/2025-06-13_Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2025/2025-06-13_Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">编程范式</a><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/2025-07-14_Three.js%20%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BB%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%88%B0%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/" title="Three.js 进阶教程：从核心概念到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Three.js 进阶教程：从核心概念到高级应用</div></div><div class="info-2"><div class="info-item-1"> Three.js 不仅仅是一个库，它是一个通往 3D 世界的大门。通过它，我们可以在 Web 浏览器中构建出令人惊叹的交互式体验。本教程将带你超越入门，深入了解 Three.js 的核心组件、工作原理以及一些高级技巧，助你构建更复杂、更酷炫的 3D 应用。  “深入 Three.js，你将发现 Web 前端的无限可能性。”   一、Three.js 核心工作流回顾与进阶在入门教程中，我们介绍了 Three.js 的“四大件”：场景 (Scene)、相机 (Camera)、渲染器 (Renderer) 和物体 (Object &#x3D; Geometry + Material)。它们是构建任何 Three.js 应用的基础。 1.1 渲染管线概览     graph TD     A[JavaScript Code （Three.js）] --&gt; B(初始化: Scene, Camera, Renderer);     B --&gt; C(创建 Mesh: Geometry + Material);     C --&gt; D(添加 Lights);     C --...</div></div></div></a><a class="pagination-related" href="/2025/2025-06-01_LazyGit%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9A%84Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8/" title="LazyGit使用解析：你的Git命令行效率神器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">LazyGit使用解析：你的Git命令行效率神器</div></div><div class="info-2"><div class="info-item-1"> 本文将带你深入了解 LazyGit，一个简单直观的终端 UI Git 客户端。如果你厌倦了反复输入 Git 命令，又觉得 GUI 客户端不够灵活，那么 LazyGit 可能会成为你的新宠。它将终端的强大与 GUI 的便捷完美结合，让你的 Git 工作流变得前所未有的高效和愉悦。  对于开发者而言，Git 无疑是日常工作中不可或缺的工具。然而，即使是最熟练的 Git 用户，也可能被一些重复、繁琐的命令行操作所困扰，例如 git add ., git status, git commit -m &quot;...&quot;, git log --oneline 等等。虽然有各种图形化 Git 客户端，但它们往往意味着脱离终端环境，或多或少牺牲了速度和灵活性。LazyGit 正是为了解决这一痛点而生的——它提供了一个文本用户界面 (TUI)，让你在终端中就能以图形化的方式快速、直观地执行 Git 操作，大幅提升工作效率。   一、为什么选择 LazyGit？LazyGit 并不是简单的 Git 命令别名集合，它提供了一个交互式的视图，将 git status, git branch...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-07-12_Go%E8%AF%AD%E8%A8%80%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC(Multiple%20Assignment)%E8%AF%A6%E8%A7%A3/" title="Go语言多重赋值(Multiple Assignment)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-12</div><div class="info-item-2">Go语言多重赋值(Multiple Assignment)详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言的“多重赋值”（Multiple Assignment）是其语言特性中一个非常简洁且强大的功能。它允许你在一个语句中同时给多个变量赋值。这不仅仅是一种语法糖，更是 Go 语言在设计上强调简洁性和实用性的体现，尤其在错误处理、函数返回多个值等方面发挥着核心作用。  核心思想：Go 语言的多重赋值允许在单条语句中同时为多个变量赋值，其核心机制是先评估右侧所有表达式，然后按顺序赋给左侧变量，常用于函数多返回值（尤其是错误处理）、交换变量、接收通道值等场景。   一、多重赋值的基本语法多重赋值的通用格式如下： 1var1, var2, ..., varN = expr1, expr2, ..., exprN  或者使用短变量声明： 1var1, var2, ..., varN := expr1, expr2, ..., exprN  关键点：  左侧 (LHS)：一系列变量名，用逗号 , 分隔。 右侧 (RHS)：一系列表达式，用逗号 , 分隔。 数量匹配：左侧变量的数量必须与右侧表达式值的数量严格匹配。 类型匹配：每个变量的类型必须与对应表达式的值的类型兼容。 求值顺序：右...</div></div></div></a><a class="pagination-related" href="/2025/2025-04-11_%20Go%E8%AF%AD%E8%A8%80%E8%8C%83%E5%9E%8B%20(Generics)%20%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E5%AE%9E%E8%B7%B5/" title="Go语言范型 (Generics) 详解：从概念到实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">Go语言范型 (Generics) 详解：从概念到实践</div></div><div class="info-2"><div class="info-item-1"> Go 语言在诞生之初，以其简洁、高效和内置并发特性迅速崛起，但长期以来缺少一个重要的现代语言特性：范型 (Generics)。这导致开发者在处理通用数据结构和算法时，不得不依赖空接口 (interface&#123;&#125;) 加上类型断言，或者为每种类型复制粘贴代码，带来了类型不安全和代码冗余的问题。  随着 Go 1.18 版本的发布，Go 正式引入了范型，为 Go 语言的表达能力带来了革命性的提升。本文将深入解析 Go 语言范型的核心概念、语法、使用场景以及注意事项，帮助你理解并掌握这一重要特性。   一、 什么是范型 (Generics)？范型，也称作“泛型”或“类型参数”，是一种允许代码处理 多种类型数据 的编程机制。它使得我们能够编写不依赖于特定数据类型的函数、方法或数据结构，从而实现代码的重用和抽象。 在没有范型之前，如果你想写一个能比较两个 int 类型值的最大函数，然后又想比较两个 float64 类型值的最大函数，你需要这样写： 12345678910111213func MaxInt(a, b int) int &#123;    if a &gt; ...</div></div></div></a><a class="pagination-related" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-01</div><div class="info-item-2">Go语言指向指针的指针(Pointer to Pointer)详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，指针是一种重要的概念，它存储了一个变量的内存地址。我们通常通过 * 运算符来解引用指针，获取指针指向的值。但 Go 语言还支持更复杂的指针类型，例如指向指针的指针 (Pointer to Pointer)，也称为二级指针 (Double Pointer)。虽然在日常开发中不常用，但理解其工作原理对于深入理解内存管理、某些高级数据结构（如链表、树的修改操作）或在特定场景下修改指针本身的值至关重要。  核心概念：一个指针变量存储一个普通变量的地址，而指向指针的指针存储一个指针变量的地址。   一、基本指针回顾在深入指向指针的指针之前，我们先快速回顾一下 Go 语言中的基本指针：  定义指针：使用 * 符号和类型名来声明一个指针变量，例如 *int 表示一个指向 int 类型的指针。 获取地址：使用 &amp; 运算符来获取一个变量的内存地址。 解引用：使用 * 运算符来访问指针指向的内存中的值。  示例： 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &...</div></div></div></a><a class="pagination-related" href="/2024/2024-05-03_RPC(Remote%20Procedure%20Call)%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E8%AF%A6%E8%A7%A3/" title="RPC(Remote Procedure Call)远程过程调用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">RPC(Remote Procedure Call)远程过程调用详解</div></div><div class="info-2"><div class="info-item-1"> RPC (Remote Procedure Call)，即 远程过程调用，是一种允许程序执行位于另一台计算机上的子程序（或函数）的技术，而无需程序员显式地为这种远程交互编写代码。简而言之，它使得调用远程服务就像调用本地函数一样简单，极大地简化了分布式系统的开发。  “The basic idea of RPC is to make remote procedure calls appear as similar as possible to local procedure calls for the programmer.”   一、RPC 简介与核心思想1. 什么是 RPC？RPC 是一种进程间通信 (IPC) 机制，它允许一个计算机程序在不了解底层网络技术细节的情况下，请求另一个地址空间（通常是另一台计算机上的进程）的服务。当客户端程序调用一个远程函数时，RPC 系统会负责处理所有网络通信的细节，包括数据序列化、网络传输、错误处理等，最终返回结果给客户端，就像本地函数调用一样。 2. 核心思想 透明性 (Transparency): 尽量让程序员感觉不到调用的是远程服务还是...</div></div></div></a><a class="pagination-related" href="/2024/2024-09-02_GoLang%20gRPC%20%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="GoLang gRPC 详解：构建高性能、跨语言的微服务"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-02</div><div class="info-item-2">GoLang gRPC 详解：构建高性能、跨语言的微服务</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是 Google 开发的一个高性能、开源的 RPC 框架，支持多种编程语言。它基于 HTTP&#x2F;2 协议传输，并使用 Protocol Buffers (Protobuf) 作为接口定义语言 (IDL) 和数据序列化机制。Go 语言作为云原生时代的明星语言，与 gRPC 的结合更是如虎添翼，是构建高性能、跨语言微服务系统的理想选择。  “gRPC aims to bring the benefits of modern RPC to everyone.”   一、gRPC 简介1. 什么是 gRPC？gRPC 是一种现代的 RPC (远程过程调用) 框架，它允许你在一个语言中定义服务（使用 Protobuf），然后在任何支持 gRPC 的语言中实现客户端和服务器。其核心特性包括：  高性能: 基于 HTTP&#x2F;2 和 Protobuf，提供更快的传输速度和更小的消息体。 多语言支持: 通过代码生成，支持 Go、Java、Python、C++、Node.js、C# 等多种语言。 强类型接口: ...</div></div></div></a><a class="pagination-related" href="/2024/2024-10-11_Go%20Modules(go%20mod)%E8%AF%A6%E8%A7%A3/" title="Go Modules(go mod)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-11</div><div class="info-item-2">Go Modules(go mod)详解</div></div><div class="info-2"><div class="info-item-1"> Go Modules 是 Go 语言官方推荐的依赖管理系统，自 Go 1.11 版本引入，并在 Go 1.13 版本中作为默认方案。它旨在解决 Go 语言在依赖管理方面存在的痛点，提供了一种更可靠、可重现且易于使用的模块化方式来组织和管理 Go 项目及其外部依赖。  “Go modules are the future of dependency management in Go.” —— Go 官方博客   一、为什么需要 Go Modules？在 Go Modules 之前，Go 语言的依赖管理主要面临以下挑战：  GOPATH 痛点: 所有项目必须放在 GOPATH 目录下。 所有项目共享同一份依赖库版本，导致不同项目可能需要不同版本的库，容易冲突。 对个人开发者而言，项目结构僵硬，跨项目共享代码不便。   社区工具碎片化: 为了解决 GOPATH 问题，社区涌现了 dep、glide、go-vendor 等第三方依赖管理工具，但没有一个成为官方标准。 这些工具各有优缺点，增加了学习和使用的成本。   版本不确定性: 在没有明确版本控制的情况下，go get 会拉取依赖库...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">155</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Go-%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%93%B2%E5%AD%A6"><span class="toc-text">一、Go 语言与设计模式的哲学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Creational-Design-Patterns"><span class="toc-text">二、创建型设计模式 (Creational Design Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern"><span class="toc-text">2.1 单例模式 (Singleton Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Factory-Pattern"><span class="toc-text">2.2 工厂模式 (Factory Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory-Pattern"><span class="toc-text">2.3 抽象工厂模式 (Abstract Factory Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern"><span class="toc-text">2.4 建造者模式 (Builder Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Structural-Design-Patterns"><span class="toc-text">三、结构型设计模式 (Structural Design Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern"><span class="toc-text">3.1 适配器模式 (Adapter Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-Decorator-Pattern"><span class="toc-text">3.2 装饰器模式 (Decorator Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy-Pattern"><span class="toc-text">3.3 代理模式 (Proxy Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-Facade-Pattern"><span class="toc-text">3.4 外观模式 (Facade Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Behavioral-Design-Patterns"><span class="toc-text">四、行为型设计模式 (Behavioral Design Patterns)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-Observer-Pattern"><span class="toc-text">4.1 观察者模式 (Observer Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern"><span class="toc-text">4.2 策略模式 (Strategy Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Template-Method-Pattern"><span class="toc-text">4.3 模板方法模式 (Template Method Pattern)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-Iterator-Pattern"><span class="toc-text">4.4 迭代器模式 (Iterator Pattern)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Go-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%9C%89%E6%A8%A1%E5%BC%8F-%E6%83%AF%E7%94%A8%E6%B3%95"><span class="toc-text">五、Go 语言特有模式 &#x2F; 惯用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Goroutine-Channel-%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.1 Goroutine &#x2F; Channel 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Context-%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.2 Context 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言指向指针的指针(Pointer to Pointer)详解"/></a><div class="content"><a class="title" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解">Go语言指向指针的指针(Pointer to Pointer)详解</a><time datetime="2025-09-30T22:24:00.000Z" title="发表于 2025-10-01 06:24:00">2025-10-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-10.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>