<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>常用限流算法的Go语言实现详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="限流 (Rate Limiting) 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。  核心思想：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。   一、为什么">
<meta property="og:type" content="article">
<meta property="og:title" content="常用限流算法的Go语言实现详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="限流 (Rate Limiting) 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。  核心思想：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。   一、为什么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg">
<meta property="article:published_time" content="2025-10-15T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-20T10:13:56.679Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="限流算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "常用限流算法的Go语言实现详解",
  "url": "https://blog.tbf1211.xx.kg/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-12.jpg",
  "datePublished": "2025-10-15T22:24:00.000Z",
  "dateModified": "2025-10-20T10:13:56.679Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常用限流算法的Go语言实现详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">154</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">151</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-12.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">常用限流算法的Go语言实现详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">常用限流算法的Go语言实现详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>限流 (Rate Limiting)</strong> 是保护后端服务、API 接口和数据库等资源的重要手段，尤其在处理高并发请求时。通过限制在特定时间窗口内允许的请求数量，限流可以防止系统过载、拒绝服务攻击 (DoS&#x2F;DDoS) 和资源耗尽，从而保证服务的稳定性和可用性。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：限流算法通过控制请求的到达速率或处理速率，确保系统的负载在可接受的范围内，避免因突发流量导致服务崩溃。</p>
</div>

<h2 id="一、为什么需要限流？"><a href="#一、为什么需要限流？" class="headerlink" title="一、为什么需要限流？"></a>一、为什么需要限流？</h2><ol>
<li><strong>防止系统过载</strong>：当请求量超出系统处理能力时，限流可以拒绝一部分请求，保证剩余请求能够正常响应，而不是所有请求都失败。</li>
<li><strong>避免雪崩效应</strong>：在微服务架构中，一个服务过载可能导致其依赖的服务也跟着过载，最终演变成整个系统的瘫痪。限流可以切断这种连锁反应。</li>
<li><strong>保护下游资源</strong>：数据库、缓存、第三方 API 等资源通常更加脆弱，限流可以保护它们免受过高压力的冲击。</li>
<li><strong>资源公平分配</strong>：对于多租户或多用户系统，限流可以确保每个用户或租户都能获得公平的资源配额。</li>
<li><strong>防止恶意攻击</strong>：例如 DoS&#x2F;DDoS 攻击，通过限制请求速率可以有效缓解攻击对系统的影响。</li>
<li><strong>费用控制</strong>：对于按请求量付费的第三方服务，限流可以有效控制成本。</li>
</ol>
<h2 id="二、常用限流算法"><a href="#二、常用限流算法" class="headerlink" title="二、常用限流算法"></a>二、常用限流算法</h2><p>本节将详细介绍三种最常用的限流算法：<strong>固定窗口计数器</strong>、<strong>滑动窗口计数器</strong>、<strong>漏桶算法</strong> 和 <strong>令牌桶算法</strong>，并提供它们的 Go 语言实现。</p>
<h3 id="2-1-固定窗口计数器-Fixed-Window-Counter"><a href="#2-1-固定窗口计数器-Fixed-Window-Counter" class="headerlink" title="2.1 固定窗口计数器 (Fixed Window Counter)"></a>2.1 固定窗口计数器 (Fixed Window Counter)</h3><h4 id="2-1-1-算法原理"><a href="#2-1-1-算法原理" class="headerlink" title="2.1.1 算法原理"></a>2.1.1 算法原理</h4><p>固定窗口计数器算法是最简单、最容易理解的限流算法。它在一个固定的时间窗口（例如 1 分钟）内统计请求数量。当请求到来时，计数器加一。如果计数器值超过预设的阈值，则拒绝该请求。当时间窗口结束时，计数器清零，开始下一个窗口的计数。</p>
<p><strong>优点</strong>：实现简单，易于理解。<br><strong>缺点</strong>：存在“临界点问题”。在窗口的开始和结束交界处，可能会在短时间内涌入双倍于阈值的请求，导致瞬时流量超过系统承载能力。例如，限流 100 QPS，窗口是 1 秒。在第 0.9 秒时来了 100 个请求，在第 1.1 秒时又来了 100 个请求，那么在 0.9 到 1.1 秒这 0.2 秒内，系统处理了 200 个请求，是阈值的两倍。</p>
<h4 id="2-1-2-Go-语言实现"><a href="#2-1-2-Go-语言实现" class="headerlink" title="2.1.2 Go 语言实现"></a>2.1.2 Go 语言实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FixedWindowLimiter 固定窗口限流器</span></span><br><span class="line"><span class="keyword">type</span> FixedWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	windowSize time.Duration <span class="comment">// 窗口大小</span></span><br><span class="line">	threshold  <span class="type">int</span>           <span class="comment">// 阈值 (窗口内最大请求数)</span></span><br><span class="line">	counter    <span class="type">int</span>           <span class="comment">// 当前窗口内的请求计数</span></span><br><span class="line">	lastReset  time.Time     <span class="comment">// 上次窗口重置时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFixedWindowLimiter 创建一个新的固定窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFixedWindowLimiter</span><span class="params">(windowSize time.Duration, threshold <span class="type">int</span>)</span></span> *FixedWindowLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;FixedWindowLimiter&#123;</span><br><span class="line">		windowSize: windowSize,</span><br><span class="line">		threshold:  threshold,</span><br><span class="line">		counter:    <span class="number">0</span>,</span><br><span class="line">		lastReset:  time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *FixedWindowLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	now := time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前时间超过了上一个窗口的结束，则重置窗口</span></span><br><span class="line">	<span class="keyword">if</span> now.Sub(l.lastReset) &gt;= l.windowSize &#123;</span><br><span class="line">		l.counter = <span class="number">0</span></span><br><span class="line">		l.lastReset = now <span class="comment">// 重置 lastReset 为当前时间，开始新窗口</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前窗口内的请求数是否超过阈值</span></span><br><span class="line">	<span class="keyword">if</span> l.counter &lt; l.threshold &#123;</span><br><span class="line">		l.counter++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	limiter := NewFixedWindowLimiter(time.Second, <span class="number">3</span>) <span class="comment">// 每秒允许 3 个请求</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 固定窗口限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每隔 100 毫秒发出请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒后...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待窗口重置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== 固定窗口限流器测试 ===</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br><span class="line">请求 6 拒绝</span><br><span class="line">请求 7 拒绝</span><br><span class="line">请求 8 拒绝</span><br><span class="line">请求 9 拒绝</span><br><span class="line">请求 10 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒后...</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br></pre></td></tr></table></figure>

<h3 id="2-2-滑动窗口计数器-Sliding-Window-Counter"><a href="#2-2-滑动窗口计数器-Sliding-Window-Counter" class="headerlink" title="2.2 滑动窗口计数器 (Sliding Window Counter)"></a>2.2 滑动窗口计数器 (Sliding Window Counter)</h3><h4 id="2-2-1-算法原理"><a href="#2-2-1-算法原理" class="headerlink" title="2.2.1 算法原理"></a>2.2.1 算法原理</h4><p>滑动窗口计数器算法是固定窗口计数器的改进版，旨在解决临界点问题。它将一个大的时间窗口（如 1 分钟）划分为更多小的时间片（如 10 个 6 秒的窗口）。每个小时间片都有独立的计数器。</p>
<p>当请求到来时，它会落入当前的小时间片。我们计算当前大窗口内的请求总数，这个总数是当前小时间片的计数，加上前面若干个完整小时间片的计数，再加上前一个小时间片中未满部分的请求计数。</p>
<p><strong>更经典的实现方式</strong>：<br>存储每个请求的时间戳在一个队列 (或切片) 中。当新请求到来时，删除所有超过当前时间窗口的旧请求。然后判断剩余请求的数量是否小于阈值。</p>
<p><strong>优点</strong>：解决了固定窗口的临界点问题，平滑了流量。<br><strong>缺点</strong>：实现相对复杂，需要存储请求的时间戳，占用内存。如果请求量非常大，存储和清理时间戳的开销会比较高。</p>
<h4 id="2-2-2-Go-语言实现"><a href="#2-2-2-Go-语言实现" class="headerlink" title="2.2.2 Go 语言实现"></a>2.2.2 Go 语言实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SlidingWindowLimiter 滑动窗口限流器 (基于时间戳队列)</span></span><br><span class="line"><span class="keyword">type</span> SlidingWindowLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	windowSize time.Duration     <span class="comment">// 窗口大小</span></span><br><span class="line">	threshold  <span class="type">int</span>               <span class="comment">// 阈值 (窗口内最大请求数)</span></span><br><span class="line">	timestamps []time.Time       <span class="comment">// 存储请求到达的时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSlidingWindowLimiter 创建一个新的滑动窗口限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlidingWindowLimiter</span><span class="params">(windowSize time.Duration, threshold <span class="type">int</span>)</span></span> *SlidingWindowLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;SlidingWindowLimiter&#123;</span><br><span class="line">		windowSize: windowSize,</span><br><span class="line">		threshold:  threshold,</span><br><span class="line">		timestamps: <span class="built_in">make</span>([]time.Time, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *SlidingWindowLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	now := time.Now()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 清理过期的时间戳</span></span><br><span class="line">	<span class="comment">// 遍历并删除所有超出当前时间窗口的旧请求时间戳</span></span><br><span class="line">	<span class="comment">// 因为切片的删除操作效率较低，更高效的方式是使用双向链表或环形队列</span></span><br><span class="line">	<span class="comment">// 这里为简化演示，使用切片</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Two-pointer approach for efficient deletion</span></span><br><span class="line">	idx := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(l.timestamps); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> now.Sub(l.timestamps[i]) &lt; l.windowSize &#123;</span><br><span class="line">			l.timestamps[idx] = l.timestamps[i]</span><br><span class="line">			idx++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	l.timestamps = l.timestamps[:idx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查当前窗口内的请求数是否超过阈值</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l.timestamps) &lt; l.threshold &#123;</span><br><span class="line">		l.timestamps = <span class="built_in">append</span>(l.timestamps, now)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	limiter := NewSlidingWindowLimiter(time.Second, <span class="number">3</span>) <span class="comment">// 每秒允许 3 个请求</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 滑动窗口限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="comment">// 测试临界点效应</span></span><br><span class="line">	<span class="comment">// 在 0.9s 时发满 3 个请求</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在 0.9s 到 1.0s 之间，等待 0.4s (到 0.9s + 0.4s = 1.3s 时)</span></span><br><span class="line">	<span class="comment">// 期望在 1.0s 后，前面 0.1s 的请求才开始过期</span></span><br><span class="line">	time.Sleep(<span class="number">400</span> * time.Millisecond) </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时当前窗口的有效请求是 第 1.3s - 1s = 0.3s 之前的所有请求</span></span><br><span class="line">	<span class="comment">// 直到第 0.1s 的请求在 1.1s 时才过期</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 以 100ms 的频率再发 5 个请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">4</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">4</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    fmt.Println(<span class="string">&quot;\n等待 1 秒后 (大部分请求已从窗口中移除)...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待窗口中的大部分请求过期</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=== 滑动窗口限流器测试 ===</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br><span class="line">请求 6 拒绝</span><br><span class="line">请求 7 拒绝</span><br><span class="line">请求 8 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒后 (大部分请求已从窗口中移除)...</span><br><span class="line">请求 1 允许通过</span><br><span class="line">请求 2 允许通过</span><br><span class="line">请求 3 允许通过</span><br><span class="line">请求 4 拒绝</span><br><span class="line">请求 5 拒绝</span><br></pre></td></tr></table></figure>
<p>可以看到，在高频请求下，滑动窗口能更平滑地拒绝请求，避免固定窗口的瞬时流量峰值问题。</p>
<h3 id="2-3-漏桶算法-Leaky-Bucket"><a href="#2-3-漏桶算法-Leaky-Bucket" class="headerlink" title="2.3 漏桶算法 (Leaky Bucket)"></a>2.3 漏桶算法 (Leaky Bucket)</h3><h4 id="2-3-1-算法原理"><a href="#2-3-1-算法原理" class="headerlink" title="2.3.1 算法原理"></a>2.3.1 算法原理</h4><p>漏桶算法的核心思想是：所有的请求都会先进入一个“桶”中，桶的容量有限。请求以恒定的速率从桶中流出（被处理）。<br>如果请求到达时桶是满的，那么该请求会被丢弃（拒绝）。</p>
<p><strong>优点</strong>：能够平滑突发流量，使输出速率保持恒定。<br><strong>缺点</strong>：无法有效地处理突发流量。即使系统具备处理短时突发的能力，漏桶算法也会将请求均匀化处理，可能导致资源利用率不足。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    A[请求流入] --&gt; B[漏桶]
    B -- 容量满 --&gt; C{丢弃请求}
    B -- 固定速率流出 --&gt; D[请求处理]
  </pre></div>

<h4 id="2-3-2-Go-语言实现"><a href="#2-3-2-Go-语言实现" class="headerlink" title="2.3.2 Go 语言实现"></a>2.3.2 Go 语言实现</h4><p>漏桶算法通常使用一个固定大小的缓冲队列和 Goroutine 来模拟漏出过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeakyBucketLimiter 漏桶限流器</span></span><br><span class="line"><span class="keyword">type</span> LeakyBucketLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity      <span class="type">int</span>           <span class="comment">// 桶的容量</span></span><br><span class="line">	rate          time.Duration <span class="comment">// 请求流出速率 (每 rate 时间单位流出一个请求)</span></span><br><span class="line">	bucket        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 模拟桶的通道</span></span><br><span class="line">	closeChan     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 用于关闭漏桶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLeakyBucketLimiter 创建一个新的漏桶限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLeakyBucketLimiter</span><span class="params">(capacity <span class="type">int</span>, rate time.Duration)</span></span> *LeakyBucketLimiter &#123;</span><br><span class="line">	limiter := &amp;LeakyBucketLimiter&#123;</span><br><span class="line">		capacity:  capacity,</span><br><span class="line">		rate:      rate,</span><br><span class="line">		bucket:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, capacity), <span class="comment">// 缓冲通道模拟桶</span></span><br><span class="line">		closeChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> limiter.leak() <span class="comment">// 启动漏出 Goroutine</span></span><br><span class="line">	<span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak 模拟请求从桶中漏出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> leak() &#123;</span><br><span class="line">	ticker := time.NewTicker(l.rate) <span class="comment">// 设置漏出速率</span></span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C: <span class="comment">// 定时从桶中取出一个请求</span></span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-l.bucket: <span class="comment">// 尝试从桶中“漏出”一个请求</span></span><br><span class="line">				<span class="comment">// 请求被成功漏出，可以进行处理</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 桶为空，没有请求可漏出</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-l.closeChan:</span><br><span class="line">			fmt.Println(<span class="string">&quot;漏桶已关闭.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 尝试将请求放入桶中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> l.bucket &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="comment">// 尝试将请求放入桶中</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 成功放入，允许通过</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">// 桶已满，无法放入</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 拒绝请求</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭漏桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LeakyBucketLimiter)</span></span> Close() &#123;</span><br><span class="line">	<span class="built_in">close</span>(l.closeChan)</span><br><span class="line">	<span class="built_in">close</span>(l.bucket)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 容量 3，每 200 毫秒处理一个请求 (即 5 QPS)</span></span><br><span class="line">	limiter := NewLeakyBucketLimiter(<span class="number">3</span>, <span class="number">200</span> * time.Millisecond) </span><br><span class="line">	<span class="keyword">defer</span> limiter.Close()</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 漏桶限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 每 50ms 发一个请求 (即 20 QPS 突发流量)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (进入桶)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (桶已满)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待一段时间，看桶中请求是否漏出...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) </span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n再次测试漏桶...&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 以 100ms 频率发请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (进入桶)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (桶已满)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">=== 漏桶限流器测试 ===</span><br><span class="line">请求 1 允许通过 (进入桶)</span><br><span class="line">请求 2 允许通过 (进入桶)</span><br><span class="line">请求 3 允许通过 (进入桶)</span><br><span class="line">请求 4 拒绝 (桶已满)</span><br><span class="line">请求 5 拒绝 (桶已满)</span><br><span class="line">请求 6 拒绝 (桶已满)</span><br><span class="line">... (直到请求 15 都是拒绝)</span><br><span class="line"></span><br><span class="line">等待一段时间，看桶中请求是否漏出... (此处 Goroutine 在后台持续漏出请求)</span><br><span class="line"></span><br><span class="line">再次测试漏桶...</span><br><span class="line">请求 1 允许通过 (进入桶)</span><br><span class="line">请求 2 允许通过 (进入桶)</span><br><span class="line">请求 3 允许通过 (进入桶)</span><br><span class="line">请求 4 拒绝 (桶已满)</span><br><span class="line">请求 5 拒绝 (桶已满)</span><br></pre></td></tr></table></figure>
<p>可以看到，在突发流量下，漏桶很快就满了，后续请求都被拒绝。但桶内的请求仍然以恒定速率处理。</p>
<h3 id="2-4-令牌桶算法-Token-Bucket"><a href="#2-4-令牌桶算法-Token-Bucket" class="headerlink" title="2.4 令牌桶算法 (Token Bucket)"></a>2.4 令牌桶算法 (Token Bucket)</h3><h4 id="2-4-1-算法原理"><a href="#2-4-1-算法原理" class="headerlink" title="2.4.1 算法原理"></a>2.4.1 算法原理</h4><p>令牌桶算法是目前最常用且最灵活的限流算法之一。它的工作原理是：</p>
<ol>
<li>一个固定容量的“令牌桶”会以恒定的速率往里添加令牌。</li>
<li>每个请求到来时，需要从桶中获取一个令牌。</li>
<li>如果桶中有足够的令牌，请求就可以通过，并消耗一个令牌。</li>
<li>如果桶中没有令牌，请求可以选择等待令牌的生成，或者直接被拒绝。</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>允许一定程度的突发流量</strong>：桶的容量决定了可以累积的最大令牌数，也就是允许通过的最大突发请求数。</li>
<li><strong>输出速率可控</strong>：令牌生成速率控制了长期来看的平均处理速率。</li>
<li><strong>实现灵活</strong>：可以很容易地调整桶容量和生成速率。</li>
</ul>
<p><strong>缺点</strong>：实现比计数器复杂，但比漏桶更灵活。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    graph TD
    A[&quot;令牌生成器 (固定速率)&quot;] --&gt; B[令牌桶]
    B -- 含有令牌 --&gt; C[请求通过]
    D[请求到达] --&gt; B
    B -- 无令牌 --&gt; E{请求等待&#x2F;拒绝}
  </pre></div>

<h4 id="2-4-2-Go-语言实现"><a href="#2-4-2-Go-语言实现" class="headerlink" title="2.4.2 Go 语言实现"></a>2.4.2 Go 语言实现</h4><p>Go 语言标准库 <code>golang.org/x/time/rate</code> 包提供了高度优化和生产可用的令牌桶限流器。这里我们先实现一个简化版的，再介绍标准库的使用。</p>
<p><strong>简化版实现</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TokenBucketLimiter 令牌桶限流器</span></span><br><span class="line"><span class="keyword">type</span> TokenBucketLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	capacity    <span class="type">int</span>           <span class="comment">// 桶的容量 (最多能存多少令牌)</span></span><br><span class="line">	tokens      <span class="type">int</span>           <span class="comment">// 当前桶中令牌数量</span></span><br><span class="line">	rate        time.Duration <span class="comment">// 令牌生成速率 (每 rate 时间单位生成一个令牌)</span></span><br><span class="line">	lastRefill  time.Time     <span class="comment">// 上次补充令牌的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTokenBucketLimiter 创建一个新的令牌桶限流器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTokenBucketLimiter</span><span class="params">(capacity <span class="type">int</span>, rate time.Duration)</span></span> *TokenBucketLimiter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TokenBucketLimiter&#123;</span><br><span class="line">		capacity:    capacity,</span><br><span class="line">		tokens:      capacity, <span class="comment">// 初始时桶是满的</span></span><br><span class="line">		rate:        rate,</span><br><span class="line">		lastRefill:  time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// refill 补充令牌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TokenBucketLimiter)</span></span> refill() &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 计算距离上次补充令牌过去了多少个“rate”时间单位</span></span><br><span class="line">	duration := now.Sub(l.lastRefill)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// numberOfTokensToAdd = 过去的时间 / 每生成一个令牌的时间</span></span><br><span class="line">	tokensToAdd := <span class="type">int</span>(duration / l.rate) </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> tokensToAdd &gt; <span class="number">0</span> &#123;</span><br><span class="line">		l.tokens += tokensToAdd</span><br><span class="line">		<span class="keyword">if</span> l.tokens &gt; l.capacity &#123;</span><br><span class="line">			l.tokens = l.capacity <span class="comment">// 令牌数不能超过容量</span></span><br><span class="line">		&#125;</span><br><span class="line">		l.lastRefill = now <span class="comment">// 更新上次补充时间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow 检查是否允许请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TokenBucketLimiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">	l.Lock()</span><br><span class="line">	<span class="keyword">defer</span> l.Unlock()</span><br><span class="line"></span><br><span class="line">	l.refill() <span class="comment">// 每次请求前先补充令牌</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> l.tokens &gt;= <span class="number">1</span> &#123;</span><br><span class="line">		l.tokens--</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 容量 5 个令牌，每 200ms 生成 1 个令牌 (即 5 QPS 的平均速率)</span></span><br><span class="line">	limiter := NewTokenBucketLimiter(<span class="number">5</span>, <span class="number">200</span> * time.Millisecond) </span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 令牌桶限流器测试 ===&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 每 50ms 发一个请求 (即 20 QPS 突发流量)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (消耗令牌)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (无可用令牌)\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒钟，桶中应补充 5 个令牌...&quot;</span>)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待令牌重新生成</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每 100ms 发一个请求 (即 10 QPS)</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 允许通过 (消耗令牌)\n&quot;</span>, i+<span class="number">16</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;请求 %d 拒绝 (无可用令牌)\n&quot;</span>, i+<span class="number">16</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">=== 令牌桶限流器测试 ===</span><br><span class="line">请求 1 允许通过 (消耗令牌)</span><br><span class="line">请求 2 允许通过 (消耗令牌)</span><br><span class="line">请求 3 允许通过 (消耗令牌)</span><br><span class="line">请求 4 允许通过 (消耗令牌)</span><br><span class="line">请求 5 允许通过 (消耗令牌)</span><br><span class="line">请求 6 拒绝 (无可用令牌)</span><br><span class="line">请求 7 拒绝 (无可用令牌)</span><br><span class="line">请求 8 拒绝 (无可用令牌)</span><br><span class="line">请求 9 拒绝 (无可用令牌)</span><br><span class="line">请求 10 拒绝 (无可用令牌)</span><br><span class="line">请求 11 拒绝 (无可用令牌)</span><br><span class="line">请求 12 拒绝 (无可用令牌)</span><br><span class="line">请求 13 拒绝 (无可用令牌)</span><br><span class="line">请求 14 拒绝 (无可用令牌)</span><br><span class="line">请求 15 拒绝 (无可用令牌)</span><br><span class="line"></span><br><span class="line">等待 1 秒钟，桶中应补充 5 个令牌...</span><br><span class="line">请求 16 允许通过 (消耗令牌)</span><br><span class="line">请求 17 允许通过 (消耗令牌)</span><br><span class="line">请求 18 允许通过 (消耗令牌)</span><br><span class="line">请求 19 允许通过 (消耗令牌)</span><br><span class="line">请求 20 允许通过 (消耗令牌)</span><br><span class="line">请求 21 拒绝 (无可用令牌)</span><br><span class="line">请求 22 拒绝 (无可用令牌)</span><br><span class="line">请求 23 拒绝 (无可用令牌)</span><br><span class="line">请求 24 拒绝 (无可用令牌)</span><br><span class="line">请求 25 拒绝 (无可用令牌)</span><br></pre></td></tr></table></figure>
<p>可以看到，在突发流量下，令牌桶允许了前 5 个请求通过（容量为 5），超出容量的请求则被拒绝。等待一段时间后，桶中再次有了令牌，又能够处理请求。这说明它能有效缓冲突发流量。</p>
<p><strong>使用 <code>golang.org/x/time/rate</code> 标准库</strong></p>
<p>Go 语言官方提供了 <code>golang.org/x/time/rate</code> 包，它实现了令牌桶算法，并且经过了高度优化，是生产环境的首选。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/time/rate&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// r: 每秒允许生成的令牌数 (rate.Limit 类型，float64)</span></span><br><span class="line">	<span class="comment">// b: 桶的容量 (int)</span></span><br><span class="line">	<span class="comment">// limiter := rate.NewLimiter(rate.Every(time.Second/3), 3) // 每 333ms 产生一个令牌，桶容量为 3，即 3 QPS</span></span><br><span class="line">	limiter := rate.NewLimiter(rate.Limit(<span class="number">3</span>), <span class="number">5</span>) <span class="comment">// 每秒生成 3 个令牌，桶容量为 5</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;=== 标准库 rate.Limiter 测试 ===&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow 方法是非阻塞的，只检查是否允许通过</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Allow (非阻塞) ---&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 每 100ms 一个请求</span></span><br><span class="line">		<span class="keyword">if</span> limiter.Allow() &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Allow 请求 %d 允许通过\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Allow 请求 %d 拒绝\n&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n等待 1 秒，桶中应补充令牌...&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second) <span class="comment">// 等待令牌重新生成</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait 方法是阻塞的，会等待直到有令牌可用或上下文过期</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Wait (阻塞) ---&quot;</span>)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second) <span class="comment">// 最多等待 2 秒</span></span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		<span class="comment">// WaitN(ctx, n) 等待 n 个令牌。如果桶中没有 n 个令牌，它会阻塞直到有足够的令牌。</span></span><br><span class="line">		err := limiter.WaitN(ctx, <span class="number">1</span>) <span class="comment">// 等待 1 个令牌</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Wait 请求 %d 失败: %v (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, err, time.Since(start))</span><br><span class="line">			<span class="comment">// 如果上下文超时，后续请求也会失败</span></span><br><span class="line">			<span class="comment">// 可以选择 return 或 break</span></span><br><span class="line">			<span class="keyword">break</span> </span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Wait 请求 %d 允许通过 (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, time.Since(start))</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟处理时间</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n--- Burst (容量) 测试 ---&quot;</span>)</span><br><span class="line">	<span class="comment">// 初始桶容量为 5，平均速率 3 QPS</span></span><br><span class="line">	<span class="comment">// 预期前 5 个请求立即通过，之后以 3 QPS 通过 (或等待)</span></span><br><span class="line">	limiter2 := rate.NewLimiter(rate.Limit(<span class="number">3</span>), <span class="number">5</span>) </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		<span class="comment">// Wait() 等待一个令牌</span></span><br><span class="line">		err := limiter2.Wait(context.Background()) </span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Burst 请求 %d 失败: %v (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, err, time.Since(start))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Burst 请求 %d 允许通过 (耗时 %v)\n&quot;</span>, i+<span class="number">1</span>, time.Since(start))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">=== 标准库 rate.Limiter 测试 ===</span><br><span class="line"></span><br><span class="line">--- Allow (非阻塞) ---</span><br><span class="line">Allow 请求 1 允许通过</span><br><span class="line">Allow 请求 2 允许通过</span><br><span class="line">Allow 请求 3 允许通过</span><br><span class="line">Allow 请求 4 允许通过</span><br><span class="line">Allow 请求 5 允许通过</span><br><span class="line">Allow 请求 6 拒绝</span><br><span class="line">Allow 请求 7 拒绝</span><br><span class="line">Allow 请求 8 拒绝</span><br><span class="line">Allow 请求 9 拒绝</span><br><span class="line">Allow 请求 10 拒绝</span><br><span class="line"></span><br><span class="line">等待 1 秒，桶中应补充令牌...</span><br><span class="line"></span><br><span class="line">--- Wait (阻塞) ---</span><br><span class="line">Wait 请求 1 允许通过 (耗时 53.792µs)</span><br><span class="line">Wait 请求 2 允许通过 (耗时 333.399625ms)</span><br><span class="line">Wait 请求 3 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 4 允许通过 (耗时 333.35925ms)</span><br><span class="line">Wait 请求 5 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 6 允许通过 (耗时 333.359209ms)</span><br><span class="line">Wait 请求 7 允许通过 (耗时 333.359208ms)</span><br><span class="line">Wait 请求 8 失败: context deadline exceeded (耗时 333.359167ms)</span><br><span class="line">Wait 请求 9 失败: context deadline exceeded (耗时 0s)</span><br><span class="line">Wait 请求 10 失败: context deadline exceeded (耗时 0s)</span><br><span class="line"></span><br><span class="line">--- Burst (容量) 测试 ---</span><br><span class="line">Burst 请求 1 允许通过 (耗时 12.042µs)</span><br><span class="line">Burst 请求 2 允许通过 (耗时 6.417µs)</span><br><span class="line">Burst 请求 3 允许通过 (耗时 5.75µs)</span><br><span class="line">Burst 请求 4 允许通过 (耗时 6.042µs)</span><br><span class="line">Burst 请求 5 允许通过 (耗时 6.166µs)</span><br><span class="line">Burst 请求 6 允许通过 (耗时 333.359209ms)</span><br><span class="line">Burst 请求 7 允许通过 (耗时 333.359209ms)</span><br><span class="line">Burst 请求 8 允许通过 (耗时 333.359208ms)</span><br><span class="line">Burst 请求 9 允许通过 (耗时 333.359208ms)</span><br><span class="line">Burst 请求 10 允许通过 (耗时 333.359209ms)</span><br></pre></td></tr></table></figure>
<p>通过 <code>rate.Limiter</code> 的 <code>Allow()</code> 和 <code>Wait()</code> 方法，我们可以灵活地选择非阻塞或阻塞式的限流策略。<code>Wait()</code> 尤其适用于需要平滑输出速率的场景，因为它会主动等待直到服务容量允许。</p>
<h2 id="三、限流算法的选择与实践"><a href="#三、限流算法的选择与实践" class="headerlink" title="三、限流算法的选择与实践"></a>三、限流算法的选择与实践</h2><h4 id="3-1-选择哪个算法？"><a href="#3-1-选择哪个算法？" class="headerlink" title="3.1 选择哪个算法？"></a>3.1 选择哪个算法？</h4><ul>
<li><strong>固定窗口计数器</strong>：实现最简单，但有临界点问题，不推荐用于精确限流。</li>
<li><strong>滑动窗口计数器</strong>：解决了固定窗口的临界点问题，比固定窗口更平滑，但内存开销较大。适用于对平滑度要求较高，但请求量不是特别巨大的场景。</li>
<li><strong>漏桶算法</strong>：强制平滑输出速率，适合需要严格控制下游服务压力的场景，不适合处理突发流量。</li>
<li><strong>令牌桶算法</strong>：最常用和最灵活的算法。它既能控制平均速率，又允许一定程度的突发流量，能更好地利用系统资源。Go 语言的 <code>rate.Limiter</code> 是生产环境的理想选择。</li>
</ul>
<h4 id="3-2-实践中的考虑"><a href="#3-2-实践中的考虑" class="headerlink" title="3.2 实践中的考虑"></a>3.2 实践中的考虑</h4><ol>
<li><strong>限流粒度</strong>：<ul>
<li><strong>接口级别</strong>：通常对每个 API 接口进行限流。</li>
<li><strong>用户级别</strong>：限制每个用户的请求速率，防止单个用户滥用。</li>
<li><strong>服务级别</strong>：限制整个服务对外请求的总量。</li>
<li><strong>IP 级别</strong>：根据客户端 IP 进行限流，防止特定 IP 的攻击。</li>
</ul>
</li>
<li><strong>分布式限流</strong>：<br>上述实现都是单机限流。在分布式系统中，需要借助外部存储（如 Redis）来同步多个限流器的状态。<ul>
<li><strong>基于 Redis 的计数器</strong>：利用 Redis 的 <code>INCR</code> 和 <code>EXPIRE</code> 命令实现固定&#x2F;滑动窗口计数器。</li>
<li><strong>基于 Redis Sorted Set 的滑动窗口</strong>：将请求时间戳存入 Sorted Set，通过 <code>ZREMRANGEBYSCORE</code> 移除过期时间戳，<code>ZCARD</code> 获取总数。</li>
<li><strong>基于 Redis 的令牌桶(Redisssemphore)</strong>：利用 <code>SETNX</code> 和 <code>EXPIRE</code> 实现简单的令牌桶。也有更复杂的基于 Lua 脚本的实现，保证原子性。</li>
</ul>
</li>
<li><strong>熔断 (Circuit Breaker) 与降级 (Degradation)</strong>：限流是预防手段，而熔断和降级是系统在出现问题后的恢复手段。它们通常需要配合使用，共同提高系统的韧性。</li>
<li><strong>动态配置</strong>：生产环境中的限流参数（阈值、窗口大小等）最好能够动态调整，无需重启服务。</li>
<li><strong>监控与告警</strong>：对限流器的拒绝率、通过率等指标进行监控，并设置告警，及时发现和处理问题。</li>
</ol>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>限流是构建高可用、高并发系统的基石。根据不同的业务场景和对流量平滑性、突发处理能力的要求，可以选择合适的限流算法。在 Go 语言中，对于单机限流，<code>golang.org/x/time/rate</code> 包提供的令牌桶算法是功能最强大、最推荐的解决方案。对于分布式限流，则需要结合 Redis 等外部存储来实现。理解并正确应用这些限流策略，能够有效保护系统资源，提升服务的稳定性和用户体验。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/">https://blog.tbf1211.xx.kg/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">限流算法</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">NativeScript-Vue3详解</div></div><div class="info-2"><div class="info-item-1"> NativeScript-Vue 3 是一个强大的框架组合，它允许开发者使用熟悉的 Vue 3 语法和工具链来构建真正的原生 iOS 和 Android 移动应用程序。与传统 Hybrid 应用（如 Cordova 或 Ionic）不同，NativeScript 直接操作原生 UI 组件，因此能够提供一流的性能和用户体验，同时避免了 Web 视图的性能瓶颈。  核心亮点：使用 Vue 3 渲染原生 UI 组件，实现高性能、媲美原生体验的跨平台移动应用开发。   一、什么是 NativeScript-Vue 3？1.1 NativeScript 简介NativeScript 是一个开源框架，用于使用 JavaScript、TypeScript 或其他编译到 JavaScript 的语言来构建原生移动应用程序。它的核心能力在于：  直接访问原生 API：无需编写任何 Objective-C&#x2F;Swift 或 Java&#x2F;Kotlin 代码，开发者可以直接从 JavaScript 访问设备的所有原生 API。 原生 UI 渲染：不使用 WebView，而是将 Java...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/2024-08-03_Go%20Context%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E5%88%A9%E5%99%A8/" title="Go Context详解：并发控制与数据传递的利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-03</div><div class="info-item-2">Go Context详解：并发控制与数据传递的利器</div></div><div class="info-2"><div class="info-item-1"> Go Context (上下文) 包是 Go 语言中用于在 goroutine 之间传递截止时间(deadline)、取消信号(cancellation signal)以及请求范围值(request-scoped values) 的一种标准机制。在编写并发程序时，尤其是在微服务架构中，处理请求的生命周期、超时控制和优雅中止 goroutine 变得至关重要，context 包就是为了解决这些问题而生。  “context 包提供了一种标准的方式来管理并发操作的生命周期。它使得我们能够更加优雅地控制 goroutine 的取消、超时，并方便地在调用链中传递请求相关数据。”   一、为什么需要 Context？设想一个场景：你的 Web 服务接收到一个请求，这个请求会触发一系列的数据库操作、RPC 调用、文件读写等。这些操作可能分布在多个 goroutine 中。 如果没有 context：  超时控制：如果请求长时间未完成，用户可能会失去耐心。你希望能在一定时间后自动取消所有相关的耗时操作。如何通知所有 goroutine 停止工作？ 取消信号：如果用户主动取消了请求，或者上游服...</div></div></div></a><a class="pagination-related" href="/2025/2025-01-12_Go%E8%AF%AD%E8%A8%80embed%E5%8C%85%E8%AF%A6%E8%A7%A3/" title="Go语言embed包详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">Go语言embed包详解</div></div><div class="info-2"><div class="info-item-1"> Go 1.16 版本引入了 embed 包，它提供了一种将静态资源（如HTML、CSS、JavaScript、图片、配置文件等）直接嵌入 (embed) 到 Go 程序二进制文件中的功能。这极大地简化了应用程序的部署流程，尤其是对于需要捆绑前端资源或配置文件的后端服务。  “The embed package provides access to files embedded in the program during compilation.” —— Go embed 官方文档   一、为什么需要 embed 包？在 embed 包出现之前，Go 应用程序通常需要通过以下方式处理静态资源：  文件系统访问: 在运行时从文件系统加载资源。这意味着在部署时，除了可执行文件，还需要打包额外的资源文件。 go:generate 工具: 使用第三方工具（如 go-bindata、statik 等）将资源文件转换为 Go 源代码文件，然后在运行时加载这些生成的 Go 文件。这种方法引入了额外的构建步骤和依赖。  embed 包的出现，解决了上述痛点：  单一二进制文件: 应用程序和所有静...</div></div></div></a><a class="pagination-related" href="/2025/2025-04-11_%20Go%E8%AF%AD%E8%A8%80%E8%8C%83%E5%9E%8B%20(Generics)%20%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E5%AE%9E%E8%B7%B5/" title="Go语言范型 (Generics) 详解：从概念到实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">Go语言范型 (Generics) 详解：从概念到实践</div></div><div class="info-2"><div class="info-item-1"> Go 语言在诞生之初，以其简洁、高效和内置并发特性迅速崛起，但长期以来缺少一个重要的现代语言特性：范型 (Generics)。这导致开发者在处理通用数据结构和算法时，不得不依赖空接口 (interface&#123;&#125;) 加上类型断言，或者为每种类型复制粘贴代码，带来了类型不安全和代码冗余的问题。  随着 Go 1.18 版本的发布，Go 正式引入了范型，为 Go 语言的表达能力带来了革命性的提升。本文将深入解析 Go 语言范型的核心概念、语法、使用场景以及注意事项，帮助你理解并掌握这一重要特性。   一、 什么是范型 (Generics)？范型，也称作“泛型”或“类型参数”，是一种允许代码处理 多种类型数据 的编程机制。它使得我们能够编写不依赖于特定数据类型的函数、方法或数据结构，从而实现代码的重用和抽象。 在没有范型之前，如果你想写一个能比较两个 int 类型值的最大函数，然后又想比较两个 float64 类型值的最大函数，你需要这样写： 12345678910111213func MaxInt(a, b int) int &#123;    if a &gt; ...</div></div></div></a><a class="pagination-related" href="/2025/2025-05-06_Caddy%20Web%20Server%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E9%9B%85%E9%80%89%E6%8B%A9/" title="Caddy Web Server详解：现代Web服务器的优雅选择"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">Caddy Web Server详解：现代Web服务器的优雅选择</div></div><div class="info-2"><div class="info-item-1"> Caddy 是一款用 Go 语言编写的开源 Web 服务器，以其自动 HTTPS 功能、简洁的配置以及强大的功能而闻名。它被设计成现代 Web 的瑞士军刀，能够胜任静态文件服务、反向代理、负载均衡、API 网关等多种任务，并且在安全性和易用性方面表现出色。  “Caddy 是未来 Web 服务器的样子：默认安全、易于管理、功能强大，并且能够自动处理 HTTPS 证书的申请和续期，让你的网站在几秒钟内上线并享受加密连接。”   一、Caddy 简介1.1 什么是 Caddy？Caddy 是一个高性能、可扩展的 Web 服务器，其核心特性包括：  自动 HTTPS：这是 Caddy 最吸引人的特性之一。对于绝大多数公共可访问的域名，Caddy 可以自动从 Let’s Encrypt 申请、配置和续期 SSL&#x2F;TLS 证书，无需手动干预。 配置简洁：Caddyfile 配置文件语法非常直观易懂，相比 Nginx 和 Apache 更加简洁。 HTTP&#x2F;2 和 HTTP&#x2F;3 支持：Caddy 默认启用 HTTP&#x2F;2，并且是首批支持 QUIC (H...</div></div></div></a><a class="pagination-related" href="/2025/2025-08-11_Go%20%E8%AF%AD%E8%A8%80%E5%9B%9B%E7%A7%8D%E9%AB%98%E6%95%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/" title="告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-11</div><div class="info-item-2">告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解</div></div><div class="info-2"><div class="info-item-1"> 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  大家好！在 Go 语言的世界里，goroutine 是并发编程的核心，但主 goroutine 常常需要等待其他 goroutine 完成任务后才能继续执行或退出程序。这是并发同步的常见需求。今天，我将为大家介绍 4 种在 Go 中等待多个 goroutine 的核心方法，从基础到高级，帮助你在不同场景下都能优雅地处理并发任务等待问题。   一、sync.WaitGroup：最常用的并发任务协调员1.1 基础概念与工作原理sync.WaitGroup 是 Go 语言中最常用的并发同步工具，专为等待一组 goroutine 完成任务而设计。它通过一个计数器机制工作，特别适合主 goroutine 需要等待多个子 goroutine 的场景。 想象一下，你是一个老师，需要等待所有学生完成作业才能放学。sync.WaitGroup 就像是一个点名器，记录需要等待的学生数量，每个学生完成作业后就会报告一声，直到所有学生都报告完毕，老师才能放学。 1.2 代码示例与执行流程让我们通过一个简单的例子来理解...</div></div></div></a><a class="pagination-related" href="/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-04</div><div class="info-item-2">Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用</div></div><div class="info-2"><div class="info-item-1">🚀 一文掌握 Go 语言最核心的数据结构！掌握 Slice 助你高效开发，理解 Array 精髓更能体现你的 Go 语言功力。   在 Go 语言的世界里，数组 (Array) 和切片 (Slice) 是我们日常编程中接触最频繁的两种数据结构。它们虽然在表面上有些相似，但骨子里却有着根本性的区别，深刻理解这些差异是写出高效、可靠 Go 代码的关键。本文将带你深入剖析 Array 和 Slice 的核心原理、实战中的使用场景、常见陷阱，以及如何做出最明智的选择。 1. 基础定义：Array vs Slice 1.1 数组 (Array)：编译时确定的固定长度序列数组是一种固定长度的、连续存储的相同类型元素序列。它的长度在声明时就已确定，并且是其类型的一部分。这意味着 [3]int 和 [4]int 是两种完全不同的类型。 1234// 声明数组的几种常用方式var arr1 [3]int        // 声明一个长度为3的int数组，元素默认值 [0, 0, 0]arr2 := [3]int&#123;1, 2&#125;   // 长度为3，初始化前两个元素，[1, 2, ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">154</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">151</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-text">一、为什么需要限流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-text">二、常用限流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8-Fixed-Window-Counter"><span class="toc-text">2.1 固定窗口计数器 (Fixed Window Counter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.1.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.1.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%AE%A1%E6%95%B0%E5%99%A8-Sliding-Window-Counter"><span class="toc-text">2.2 滑动窗口计数器 (Sliding Window Counter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.2.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95-Leaky-Bucket"><span class="toc-text">2.3 漏桶算法 (Leaky Bucket)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.3.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.2 Go 语言实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95-Token-Bucket"><span class="toc-text">2.4 令牌桶算法 (Token Bucket)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-text">2.4.1 算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-Go-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.4.2 Go 语言实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-text">三、限流算法的选择与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-text">3.1 选择哪个算法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E8%80%83%E8%99%91"><span class="toc-text">3.2 实践中的考虑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言指向指针的指针(Pointer to Pointer)详解"/></a><div class="content"><a class="title" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解">Go语言指向指针的指针(Pointer to Pointer)详解</a><time datetime="2025-09-30T22:24:00.000Z" title="发表于 2025-10-01 06:24:00">2025-10-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-12.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>