<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  大家好！在 Go 语言的世界里，goroutine 是并发编程的核心，但主 goroutine 常常需要等待其他 goroutine 完成任务后才能继续执行或退出程序。这是并发同步的常见需求。今天，我将为大家介绍 4 种在 Go 中等待多个 goroutine 的核心方法，从基础到高级，帮助你在不同场景下都能优">
<meta property="og:type" content="article">
<meta property="og:title" content="告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/2025/2025-08-11_Go%20%E8%AF%AD%E8%A8%80%E5%9B%9B%E7%A7%8D%E9%AB%98%E6%95%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  大家好！在 Go 语言的世界里，goroutine 是并发编程的核心，但主 goroutine 常常需要等待其他 goroutine 完成任务后才能继续执行或退出程序。这是并发同步的常见需求。今天，我将为大家介绍 4 种在 Go 中等待多个 goroutine 的核心方法，从基础到高级，帮助你在不同场景下都能优">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg">
<meta property="article:published_time" content="2025-08-10T22:24:00.000Z">
<meta property="article:modified_time" content="2025-10-19T15:09:54.246Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="goroutine">
<meta property="article:tag" content="转载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解",
  "url": "https://blog.tbf1211.xx.kg/2025/2025-08-11_Go%20%E8%AF%AD%E8%A8%80%E5%9B%9B%E7%A7%8D%E9%AB%98%E6%95%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg",
  "datePublished": "2025-08-10T22:24:00.000Z",
  "dateModified": "2025-10-19T15:09:54.246Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/2025/2025-08-11_Go%20%E8%AF%AD%E8%A8%80%E5%9B%9B%E7%A7%8D%E9%AB%98%E6%95%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">150</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">147</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-22.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">告别 goroutine 等待烦恼：Go 语言四种高效同步方法详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-08-10T22:24:00.000Z" title="发表于 2025-08-11 06:24:00">2025-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/goroutine/">goroutine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/2025/2025-08-11_Go%20%E8%AF%AD%E8%A8%80%E5%9B%9B%E7%A7%8D%E9%AB%98%E6%95%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>本文由 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://mp.weixin.qq.com/s/r97DJ4GtQJ6ZyxarDp-9Ug">mp.weixin.qq.com</a></p>
</blockquote>
<div class="note info flat"><p>大家好！在 Go 语言的世界里，<code>goroutine</code> 是并发编程的核心，但主 goroutine 常常需要等待其他 <code>goroutine</code> 完成任务后才能继续执行或退出程序。这是并发同步的常见需求。今天，我将为大家介绍 4 种在 Go 中等待多个 goroutine 的核心方法，从基础到高级，帮助你在不同场景下都能优雅地处理并发任务等待问题。</p>
</div>

<h2 id="一、sync-WaitGroup：最常用的并发任务协调员"><a href="#一、sync-WaitGroup：最常用的并发任务协调员" class="headerlink" title="一、sync.WaitGroup：最常用的并发任务协调员"></a>一、sync.WaitGroup：最常用的并发任务协调员</h2><h3 id="1-1-基础概念与工作原理"><a href="#1-1-基础概念与工作原理" class="headerlink" title="1.1 基础概念与工作原理"></a>1.1 基础概念与工作原理</h3><p><code>sync.WaitGroup</code> 是 Go 语言中最常用的并发同步工具，专为等待一组 goroutine 完成任务而设计。它通过一个计数器机制工作，特别适合主 goroutine 需要等待多个子 goroutine 的场景。</p>
<p>想象一下，你是一个老师，需要等待所有学生完成作业才能放学。<code>sync.WaitGroup</code> 就像是一个点名器，记录需要等待的学生数量，每个学生完成作业后就会报告一声，直到所有学生都报告完毕，老师才能放学。</p>
<h3 id="1-2-代码示例与执行流程"><a href="#1-2-代码示例与执行流程" class="headerlink" title="1.2 代码示例与执行流程"></a>1.2 代码示例与执行流程</h3><p>让我们通过一个简单的例子来理解它的工作原理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">// 启动3个goroutine</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 增加计数器，表示有一个goroutine需要等待</span></span><br><span class="line">        gofunc(id <span class="type">int</span>) &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done() <span class="comment">// 任务完成后，计数器减1</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Goroutine %d is running\n&quot;</span>, id)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 主goroutine等待所有goroutine完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;All goroutines finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能的输出（顺序可能不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Goroutine 1 is running</span><br><span class="line">Goroutine 2 is running</span><br><span class="line">Goroutine 3 is running</span><br><span class="line">All goroutines finished</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>sync.WaitGroup</code> 的工作原理：</p>
<ul>
<li><p><code>wg.Add(n)</code>：增加计数器，表示有 n 个 goroutine 需要等待</p>
</li>
<li><p><code>wg.Done()</code>：通常在 <code>defer</code> 中调用，任务完成后计数器减 1</p>
</li>
<li><p><code>wg.Wait()</code>：阻塞主 goroutine，直到计数器变为 0</p>
</li>
</ul>
<h3 id="1-3-使用优势与局限性"><a href="#1-3-使用优势与局限性" class="headerlink" title="1.3 使用优势与局限性"></a>1.3 使用优势与局限性</h3><p>优势：</p>
<ul>
<li><p>简单易用，适合固定数量的 goroutine</p>
</li>
<li><p>不需要额外的 channel，性能开销低</p>
</li>
<li><p>是 Go 社区中最常用的并发同步工具</p>
</li>
</ul>
<p>局限性：</p>
<ul>
<li><p>不支持错误处理</p>
</li>
<li><p>不支持任务取消</p>
</li>
<li><p>无法动态调整等待的 goroutine 数量</p>
</li>
</ul>
<h2 id="二、Channel：灵活的信号传递机制"><a href="#二、Channel：灵活的信号传递机制" class="headerlink" title="二、Channel：灵活的信号传递机制"></a>二、Channel：灵活的信号传递机制</h2><hr>
<h3 id="2-1-基本概念与实现思路"><a href="#2-1-基本概念与实现思路" class="headerlink" title="2.1 基本概念与实现思路"></a>2.1 基本概念与实现思路</h3><p>当需要更灵活的控制，或者需要传递任务结果时，使用 channel 来等待多个 goroutine 是一个不错的选择。通过 channel 传递信号，主 goroutine 可以等待所有其他 goroutine 发送完成信号。</p>
<p>想象一下，每个 goroutine 完成任务后会向一个 “完成队列” 发送一个信号，主 goroutine 则从这个队列中收集所有信号，直到收到足够数量的信号才继续执行。</p>
<h3 id="2-2-代码示例与执行流程"><a href="#2-2-代码示例与执行流程" class="headerlink" title="2.2 代码示例与执行流程"></a>2.2 代码示例与执行流程</h3><p>让我们看看如何用 channel 实现等待多个 goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> done := <span class="built_in">make</span>(chanstruct&#123;&#125;) <span class="comment">// 创建一个无缓冲channel，用于发送完成信号</span></span><br><span class="line"> numGoroutines := <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= numGoroutines; i++ &#123;</span><br><span class="line">gofunc(id <span class="type">int</span>) &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;Goroutine %d is running\n&quot;</span>, id)</span><br><span class="line">   done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 任务完成后发送一个信号</span></span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 等待所有goroutine完成</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutines; i++ &#123;</span><br><span class="line">  &lt;-done <span class="comment">// 接收完成信号</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;All goroutines finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能的输出（顺序可能不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Goroutine 1 is running</span><br><span class="line">Goroutine 2 is running</span><br><span class="line">Goroutine 3 is running</span><br><span class="line">All goroutines finished</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>channel 方法的工作原理：</p>
<ul>
<li><p>每个 goroutine 完成任务后，向 done channel 发送一个信号</p>
</li>
<li><p>主 goroutine 通过循环接收 numGoroutines 次信号，确认所有任务完成</p>
</li>
<li><p>使用 struct {} 作为 channel 元素类型，因为不需要传递实际数据，只需要信号</p>
</li>
</ul>
<h3 id="2-3-使用优势与局限性"><a href="#2-3-使用优势与局限性" class="headerlink" title="2.3 使用优势与局限性"></a>2.3 使用优势与局限性</h3><p>优势：</p>
<ul>
<li><p>高度灵活，可以携带数据（如任务结果）</p>
</li>
<li><p>适合动态数量的 goroutine</p>
</li>
<li><p>可以与 select 语句结合使用，实现更复杂的同步逻辑</p>
</li>
</ul>
<p>局限性：</p>
<ul>
<li><p>需要手动管理接收次数，代码可能略显繁琐</p>
</li>
<li><p>不直接支持错误处理</p>
</li>
<li><p>容易导致 goroutine 泄漏，如果没有正确发送或接收信号</p>
</li>
</ul>
<h2 id="三、context：优雅的任务取消与超时控制"><a href="#三、context：优雅的任务取消与超时控制" class="headerlink" title="三、context：优雅的任务取消与超时控制"></a>三、context：优雅的任务取消与超时控制</h2><hr>
<h3 id="3-1-基本概念与适用场景"><a href="#3-1-基本概念与适用场景" class="headerlink" title="3.1 基本概念与适用场景"></a>3.1 基本概念与适用场景</h3><p>当需要更复杂的控制，如任务取消或超时机制时，<code>context</code> 包提供了强大的解决方案。通过 <code>context.Context</code>，主 goroutine 可以优雅地控制 goroutine 的退出，并等待所有任务完成。</p>
<p>想象一下，<code>context</code> 就像是一个远程控制，可以随时 “关闭” 所有相关的 goroutine，同时确保主 goroutine 等待它们完成清理工作后再继续执行。</p>
<h3 id="3-2-代码示例与执行流程"><a href="#3-2-代码示例与执行流程" class="headerlink" title="3.2 代码示例与执行流程"></a>3.2 代码示例与执行流程</h3><p>让我们看看如何结合 <code>context</code> 和 <code>WaitGroup</code> 来等待 goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">gofunc(id <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Goroutine %d cancelled\n&quot;</span>, id)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Goroutine %d is running\n&quot;</span>, id)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 模拟任务完成，发送取消信号</span></span><br><span class="line"> cancel()</span><br><span class="line"><span class="comment">// 等待所有goroutine退出</span></span><br><span class="line"> wg.Wait()</span><br><span class="line"> fmt.Println(<span class="string">&quot;All goroutines finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能的输出（取决于取消信号何时到达）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Goroutine 1 is running</span><br><span class="line">Goroutine 2 cancelled</span><br><span class="line">Goroutine 3 is running</span><br><span class="line">All goroutines finished</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>context</code> 方法的工作原理：</p>
<ul>
<li><p>使用 <code>context.WithCancel</code> 创建可取消的上下文</p>
</li>
<li><p>每个 goroutine 在执行前检查是否收到取消信号</p>
</li>
<li><p><code>cancel ()</code> 函数发送取消信号</p>
</li>
<li><p>WaitGroup 确保主 goroutine 等待所有 goroutine 完成清理工作</p>
</li>
</ul>
<h3 id="3-3-使用优势与局限性"><a href="#3-3-使用优势与局限性" class="headerlink" title="3.3 使用优势与局限性"></a>3.3 使用优势与局限性</h3><p>优势：</p>
<ul>
<li><p>支持任务取消和超时控制</p>
</li>
<li><p>可以传递截止时间或超时时间</p>
</li>
<li><p>适合复杂的并发场景，如网络请求处理</p>
</li>
</ul>
<p>局限性：</p>
<ul>
<li><p>代码复杂度略有增加</p>
</li>
<li><p>需要与其他同步机制（如 WaitGroup）结合使用</p>
</li>
<li><p>错误处理需要额外实现</p>
</li>
</ul>
<h2 id="四、errgroup：现代-Go-应用的最佳选择"><a href="#四、errgroup：现代-Go-应用的最佳选择" class="headerlink" title="四、errgroup：现代 Go 应用的最佳选择"></a>四、errgroup：现代 Go 应用的最佳选择</h2><hr>
<h3 id="4-1-基本概念与功能特点"><a href="#4-1-基本概念与功能特点" class="headerlink" title="4.1 基本概念与功能特点"></a>4.1 基本概念与功能特点</h3><p>errgroup 是 Go 语言中一个高级并发工具，它结合了 WaitGroup 的功能和错误处理能力，特别适合需要等待多个任务完成并处理可能出现的错误的场景。</p>
<p>想象一下，errgroup 就像是一个智能的任务管理器，它不仅能等待所有任务完成，还能处理任务中出现的错误，并且可以在任何一个任务出错时立即取消其他任务。</p>
<h3 id="4-2-代码示例与执行流程"><a href="#4-2-代码示例与执行流程" class="headerlink" title="4.2 代码示例与执行流程"></a>4.2 代码示例与执行流程</h3><p>让我们看看如何使用 errgroup 来等待多个 goroutine：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g errgroup.Group</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">  id := i</span><br><span class="line">  g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;Goroutine %d is running\n&quot;</span>, id)</span><br><span class="line">   returnnil<span class="comment">// 返回nil表示任务成功</span></span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 等待所有goroutine完成，并获取可能的错误</span></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;All goroutines finished successfully&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出（顺序可能不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Goroutine 1 is running</span><br><span class="line">Goroutine 2 is running</span><br><span class="line">Goroutine 3 is running</span><br><span class="line">All goroutines finished successfully</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>errgroup</code> 方法的工作原理：</p>
<ul>
<li><p>使用 <code>errgroup.Group</code> 来管理一组 goroutine</p>
</li>
<li><p><code>g.Go ()</code> 方法启动一个 goroutine，并自动管理计数器</p>
</li>
<li><p><code>g.Wait ()</code> 等待所有 goroutine 完成，并返回第一个非 nil 错误</p>
</li>
<li><p>所有 goroutine 在接收到错误信号后会立即停止</p>
</li>
</ul>
<h3 id="4-3-使用优势与局限性"><a href="#4-3-使用优势与局限性" class="headerlink" title="4.3 使用优势与局限性"></a>4.3 使用优势与局限性</h3><p>优势：</p>
<ul>
<li><p>内置错误处理机制，非常适合处理多个可能出错的任务</p>
</li>
<li><p>支持上下文取消（可以使用 <code>errgroup.WithContext</code>）</p>
</li>
<li><p>代码简洁优雅，现代 Go 项目推荐使用</p>
</li>
<li><p>自动处理 goroutine 泄漏</p>
</li>
</ul>
<p>局限性：</p>
<ul>
<li><p>需要导入额外的包：golang.org&#x2F;x&#x2F;sync&#x2F;errgroup</p>
</li>
<li><p>错误处理方式较为特殊，需要适应</p>
</li>
<li><p>不熟悉的开发者可能需要一些时间学习</p>
</li>
</ul>
<h2 id="五、如何选择适合的方法？"><a href="#五、如何选择适合的方法？" class="headerlink" title="五、如何选择适合的方法？"></a>五、如何选择适合的方法？</h2><p>根据不同的应用场景，我们应该如何选择合适的等待 goroutine 的方法呢？下面是一个简单的决策指南：</p>
<table><thead><tr><th><section>方法</section></th><th><section>适用场景</section></th><th><section>主要优势</section></th><th><section>主要劣势</section></th></tr></thead><tbody><tr><td><section>sync.WaitGroup</section></td><td><section>简单任务，固定数量 goroutine</section></td><td><section>简单高效，标准库内置</section></td><td><section>不支持错误处理和取消</section></td></tr><tr><td><section>Channel</section></td><td><section>动态任务数量或需要传递结果</section></td><td><section>高度灵活，可传递数据</section></td><td><section>手动管理较为复杂</section></td></tr><tr><td><section>context</section></td><td><section>需要取消或超时控制的复杂场景</section></td><td><section>支持取消和超时</section></td><td><section>代码复杂度增加</section></td></tr><tr><td><section>errgroup</section></td><td><section>需要错误处理的现代应用</section></td><td><section>强大的错误处理能力，优雅的 API</section></td><td><section>需要额外依赖</section></td></tr></tbody></table>

<h3 id="5-1-实际应用建议"><a href="#5-1-实际应用建议" class="headerlink" title="5.1 实际应用建议"></a>5.1 实际应用建议</h3><ol>
<li><p><strong>简单场景</strong>：如果你只需要等待固定数量的 goroutine 完成，并且不需要处理错误或取消，使用 sync.WaitGroup 是最佳选择。</p>
</li>
<li><p><strong>动态任务场景</strong>：当 goroutine 数量在运行时确定，或者需要收集任务结果时，考虑使用 channel 方法。</p>
</li>
<li><p><strong>复杂服务场景</strong>：在需要处理取消、超时或清理资源的服务器环境中，结合 context 和 WaitGroup 是一个好的选择。</p>
</li>
<li><p><strong>现代 Go 应用</strong>：对于新开发的 Go 应用，尤其是需要处理多个可能出错的任务时，推荐使用 errgroup，它提供了简洁而强大的解决方案。</p>
</li>
</ol>
<h3 id="5-2-为什么不直接让主-goroutine-休眠？"><a href="#5-2-为什么不直接让主-goroutine-休眠？" class="headerlink" title="5.2 为什么不直接让主 goroutine 休眠？"></a>5.2 为什么不直接让主 goroutine 休眠？</h3><p>你可能会想：”为什么不直接使用 time.Sleep 来等待 goroutine 完成呢？”</p>
<p>答案是：<strong>time.Sleep 只引入一个固定的延迟，并不能准确等待任务完成</strong>。这可能导致程序过早退出或不必要的长时间等待。使用专用的同步工具（如 WaitGroup 或 channel）可以确保程序正确性，避免资源泄漏和逻辑错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Go 语言中，主 goroutine 等待其他 goroutine 完成任务是并发编程的基础需求。本文介绍了四种常用的方法：</p>
<ol>
<li><p><strong>sync.WaitGroup</strong>：最常用的方法，简单高效，适合固定数量的 goroutine。</p>
</li>
<li><p><strong>Channel</strong>：高度灵活，适合动态任务或需要传递结果的场景。</p>
</li>
<li><p><strong>context</strong>：支持取消和超时控制，适合复杂的服务端应用。</p>
</li>
<li><p><strong>errgroup</strong>：现代 Go 应用推荐使用，结合了错误处理和等待功能。</p>
</li>
</ol>
<p>根据你的具体需求选择合适的工具，可以确保程序逻辑清晰，避免资源泄漏，提高代码的健壮性。</p>
<p>记住，<strong>没有放之四海而皆准的解决方案</strong>，根据实际需求选择合适的工具才是王道。希望本文的介绍能帮助你在 Go 并发编程的道路上更进一步！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/2025/2025-08-11_Go%20%E8%AF%AD%E8%A8%80%E5%9B%9B%E7%A7%8D%E9%AB%98%E6%95%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/">https://blog.tbf1211.xx.kg/2025/2025-08-11_Go%20%E8%AF%AD%E8%A8%80%E5%9B%9B%E7%A7%8D%E9%AB%98%E6%95%88%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/goroutine/">goroutine</a><a class="post-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-22.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/2025-08-15_PayFi%E8%AF%A6%E8%A7%A3%EF%BC%9AWeb3%E6%94%AF%E4%BB%98%E4%B8%8E%E9%87%91%E8%9E%8D%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/" title="PayFi详解：Web3支付与金融基础设施"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">PayFi详解：Web3支付与金融基础设施</div></div><div class="info-2"><div class="info-item-1"> PayFi 并非一个单一的产品或公司名称，而是对 Web3 支付和金融基础设施 的一个统称。随着 Web3 的兴起，对支持加密货币交易、提供去中心化金融服务以及连接传统金融与区块链世界的工具和协议的需求日益增长。PayFi 代表着这一新兴领域，致力于构建一个更高效、更透明、更去中心化的支付和金融生态系统。  “PayFi encapsulates the evolving landscape of decentralized payment solutions and financial primitives that bridge the gap between traditional commerce and the blockchain economy.”   一、理解 PayFi 的概念：Web3 支付与金融基础设施的集合广义上讲，PayFi 是指一系列旨在促进 Web3 领域内支付和金融活动的协议、平台、服务和工具。它包括但不限于：  加密支付网关: 允许商家接收加密货币付款。 法币入口&#x2F;出口 (On&#x2F;Off-Ramps): 连接区块链资产与传统法...</div></div></div></a><a class="pagination-related" href="/2025/2025-08-03_Vue3%20defineModel%E8%AF%A6%E8%A7%A3/" title="Vue3 defineModel详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Vue3 defineModel详解</div></div><div class="info-2"><div class="info-item-1"> defineModel 是 Vue 3.4+ 版本中引入的一个新的 &lt;script setup&gt; 宏，旨在简化 v-model 的实现。它将组件的 props 和 emit 事件的复杂性抽象化，使得声明和使用双向绑定属性变得前所未有的直观和简洁。本篇将详细解释 defineModel 的用法、原理以及它带来的优势。  “The defineModel macro simplifies the implementation of two-way binding props, providing idiomatic and easier-to-understand syntax for both child components and their parent components.” —— Vue.js Documentation   一、什么是 defineModel？在 Vue 中，v-model 是一个强大的语法糖，用于在表单输入元素或者组件上实现双向数据绑定。在 Vue 3 (以及 defineModel 之前)，组件要支持 v-model，需要手动声明一个...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/2025-09-05_Go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title="Go 语言协程设计与调度原理"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-05</div><div class="info-item-2">Go 语言协程设计与调度原理</div></div><div class="info-2"><div class="info-item-1"> 本文由 简悦 SimpRead 转码， 原文地址 mp.weixin.qq.com  协程设计 - GMP 模型线程是操作系统调度到 CPU 中执行的基本单位，多线程总是交替式地抢占 CPU 的时间片，线程在上下文的切换过程中需要经过操作系统用户态与内核态的切换。 golang 的协程 (G) 依然运行在工作线程 (M) 之上，但是借助语言的调度器，协程只需要在用户态即可完成切换，工作线程是感受不到协程存在的。 golang 在设计上通过逻辑处理器 (P) 建立起了工作线程与协程之间的联系。最简单的 GMP 关系模型为(图是静态的，在程序运行的过程中，GMP 三者之间的绑定关系都是不固定的):  工作线程 M工作线程是最终运行协程的实体。操作系统中的线程与在运行时代表线程的 m 结构体进行了绑定： 123456789101112// go/src/runtime/runtime2.gotype m struct &#123;    g0      *g     // goroutine with scheduling stack    tls           [tlsSlo...</div></div></div></a><a class="pagination-related" href="/2024/2024-08-03_Go%20Context%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E5%88%A9%E5%99%A8/" title="Go Context详解：并发控制与数据传递的利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-03</div><div class="info-item-2">Go Context详解：并发控制与数据传递的利器</div></div><div class="info-2"><div class="info-item-1"> Go Context (上下文) 包是 Go 语言中用于在 goroutine 之间传递截止时间(deadline)、取消信号(cancellation signal)以及请求范围值(request-scoped values) 的一种标准机制。在编写并发程序时，尤其是在微服务架构中，处理请求的生命周期、超时控制和优雅中止 goroutine 变得至关重要，context 包就是为了解决这些问题而生。  “context 包提供了一种标准的方式来管理并发操作的生命周期。它使得我们能够更加优雅地控制 goroutine 的取消、超时，并方便地在调用链中传递请求相关数据。”   一、为什么需要 Context？设想一个场景：你的 Web 服务接收到一个请求，这个请求会触发一系列的数据库操作、RPC 调用、文件读写等。这些操作可能分布在多个 goroutine 中。 如果没有 context：  超时控制：如果请求长时间未完成，用户可能会失去耐心。你希望能在一定时间后自动取消所有相关的耗时操作。如何通知所有 goroutine 停止工作？ 取消信号：如果用户主动取消了请求，或者上游服...</div></div></div></a><a class="pagination-related" href="/2025/2025-01-12_Go%E8%AF%AD%E8%A8%80embed%E5%8C%85%E8%AF%A6%E8%A7%A3/" title="Go语言embed包详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-12</div><div class="info-item-2">Go语言embed包详解</div></div><div class="info-2"><div class="info-item-1"> Go 1.16 版本引入了 embed 包，它提供了一种将静态资源（如HTML、CSS、JavaScript、图片、配置文件等）直接嵌入 (embed) 到 Go 程序二进制文件中的功能。这极大地简化了应用程序的部署流程，尤其是对于需要捆绑前端资源或配置文件的后端服务。  “The embed package provides access to files embedded in the program during compilation.” —— Go embed 官方文档   一、为什么需要 embed 包？在 embed 包出现之前，Go 应用程序通常需要通过以下方式处理静态资源：  文件系统访问: 在运行时从文件系统加载资源。这意味着在部署时，除了可执行文件，还需要打包额外的资源文件。 go:generate 工具: 使用第三方工具（如 go-bindata、statik 等）将资源文件转换为 Go 源代码文件，然后在运行时加载这些生成的 Go 文件。这种方法引入了额外的构建步骤和依赖。  embed 包的出现，解决了上述痛点：  单一二进制文件: 应用程序和所有静...</div></div></div></a><a class="pagination-related" href="/2025/2025-04-11_%20Go%E8%AF%AD%E8%A8%80%E8%8C%83%E5%9E%8B%20(Generics)%20%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E5%AE%9E%E8%B7%B5/" title="Go语言范型 (Generics) 详解：从概念到实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-11</div><div class="info-item-2">Go语言范型 (Generics) 详解：从概念到实践</div></div><div class="info-2"><div class="info-item-1"> Go 语言在诞生之初，以其简洁、高效和内置并发特性迅速崛起，但长期以来缺少一个重要的现代语言特性：范型 (Generics)。这导致开发者在处理通用数据结构和算法时，不得不依赖空接口 (interface&#123;&#125;) 加上类型断言，或者为每种类型复制粘贴代码，带来了类型不安全和代码冗余的问题。  随着 Go 1.18 版本的发布，Go 正式引入了范型，为 Go 语言的表达能力带来了革命性的提升。本文将深入解析 Go 语言范型的核心概念、语法、使用场景以及注意事项，帮助你理解并掌握这一重要特性。   一、 什么是范型 (Generics)？范型，也称作“泛型”或“类型参数”，是一种允许代码处理 多种类型数据 的编程机制。它使得我们能够编写不依赖于特定数据类型的函数、方法或数据结构，从而实现代码的重用和抽象。 在没有范型之前，如果你想写一个能比较两个 int 类型值的最大函数，然后又想比较两个 float64 类型值的最大函数，你需要这样写： 12345678910111213func MaxInt(a, b int) int &#123;    if a &gt; ...</div></div></div></a><a class="pagination-related" href="/2025/2025-05-06_Caddy%20Web%20Server%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%8E%B0%E4%BB%A3Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E9%9B%85%E9%80%89%E6%8B%A9/" title="Caddy Web Server详解：现代Web服务器的优雅选择"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-06</div><div class="info-item-2">Caddy Web Server详解：现代Web服务器的优雅选择</div></div><div class="info-2"><div class="info-item-1"> Caddy 是一款用 Go 语言编写的开源 Web 服务器，以其自动 HTTPS 功能、简洁的配置以及强大的功能而闻名。它被设计成现代 Web 的瑞士军刀，能够胜任静态文件服务、反向代理、负载均衡、API 网关等多种任务，并且在安全性和易用性方面表现出色。  “Caddy 是未来 Web 服务器的样子：默认安全、易于管理、功能强大，并且能够自动处理 HTTPS 证书的申请和续期，让你的网站在几秒钟内上线并享受加密连接。”   一、Caddy 简介1.1 什么是 Caddy？Caddy 是一个高性能、可扩展的 Web 服务器，其核心特性包括：  自动 HTTPS：这是 Caddy 最吸引人的特性之一。对于绝大多数公共可访问的域名，Caddy 可以自动从 Let’s Encrypt 申请、配置和续期 SSL&#x2F;TLS 证书，无需手动干预。 配置简洁：Caddyfile 配置文件语法非常直观易懂，相比 Nginx 和 Apache 更加简洁。 HTTP&#x2F;2 和 HTTP&#x2F;3 支持：Caddy 默认启用 HTTP&#x2F;2，并且是首批支持 QUIC (H...</div></div></div></a><a class="pagination-related" href="/2025/2025-09-04_Go%20%E8%AF%AD%E8%A8%80%20Array%20%E5%92%8C%20Slice%20%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" title="Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-04</div><div class="info-item-2">Go 语言 Array 与 Slice 深度解析：核心区别、实战指南与高效运用</div></div><div class="info-2"><div class="info-item-1">🚀 一文掌握 Go 语言最核心的数据结构！掌握 Slice 助你高效开发，理解 Array 精髓更能体现你的 Go 语言功力。   在 Go 语言的世界里，数组 (Array) 和切片 (Slice) 是我们日常编程中接触最频繁的两种数据结构。它们虽然在表面上有些相似，但骨子里却有着根本性的区别，深刻理解这些差异是写出高效、可靠 Go 代码的关键。本文将带你深入剖析 Array 和 Slice 的核心原理、实战中的使用场景、常见陷阱，以及如何做出最明智的选择。 1. 基础定义：Array vs Slice 1.1 数组 (Array)：编译时确定的固定长度序列数组是一种固定长度的、连续存储的相同类型元素序列。它的长度在声明时就已确定，并且是其类型的一部分。这意味着 [3]int 和 [4]int 是两种完全不同的类型。 1234// 声明数组的几种常用方式var arr1 [3]int        // 声明一个长度为3的int数组，元素默认值 [0, 0, 0]arr2 := [3]int&#123;1, 2&#125;   // 长度为3，初始化前两个元素，[1, 2, ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">150</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">147</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81sync-WaitGroup%EF%BC%9A%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1%E5%8D%8F%E8%B0%83%E5%91%98"><span class="toc-text">一、sync.WaitGroup：最常用的并发任务协调员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.1 基础概念与工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">1.2 代码示例与执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1.3 使用优势与局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Channel%EF%BC%9A%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-text">二、Channel：灵活的信号传递机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">2.1 基本概念与实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.2 代码示例与执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">2.3 使用优势与局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81context%EF%BC%9A%E4%BC%98%E9%9B%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88%E4%B8%8E%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-text">三、context：优雅的任务取消与超时控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.1 基本概念与适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.2 代码示例与执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">3.3 使用优势与局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81errgroup%EF%BC%9A%E7%8E%B0%E4%BB%A3-Go-%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E9%80%89%E6%8B%A9"><span class="toc-text">四、errgroup：现代 Go 应用的最佳选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8A%9F%E8%83%BD%E7%89%B9%E7%82%B9"><span class="toc-text">4.1 基本概念与功能特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">4.2 代码示例与执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">4.3 使用优势与局限性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">五、如何选择适合的方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-text">5.1 实际应用建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E8%AE%A9%E4%B8%BB-goroutine-%E4%BC%91%E7%9C%A0%EF%BC%9F"><span class="toc-text">5.2 为什么不直接让主 goroutine 休眠？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常用限流算法的Go语言实现详解"/></a><div class="content"><a class="title" href="/2025/2025-10-16_%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E7%9A%84Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/" title="常用限流算法的Go语言实现详解">常用限流算法的Go语言实现详解</a><time datetime="2025-10-15T22:24:00.000Z" title="发表于 2025-10-16 06:24:00">2025-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NativeScript-Vue3详解"/></a><div class="content"><a class="title" href="/2025/2025-10-10_NativeScript-Vue3%E8%AF%A6%E8%A7%A3/" title="NativeScript-Vue3详解">NativeScript-Vue3详解</a><time datetime="2025-10-09T22:24:00.000Z" title="发表于 2025-10-10 06:24:00">2025-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"/></a><div class="content"><a class="title" href="/2025/2025-10-08_Hyper-V%20%E6%B7%B1%E5%BA%A6%E8%AF%A6%E8%A7%A3%EF%BC%9AWindows%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E4%B8%93%E4%B8%9A%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</a><time datetime="2025-10-07T22:24:00.000Z" title="发表于 2025-10-08 06:24:00">2025-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TresJS详解：用Vue的方式构建Three.js场景"/></a><div class="content"><a class="title" href="/2025/2025-10-06_TresJS%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%94%A8Vue%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BAThree.js%E5%9C%BA%E6%99%AF/" title="TresJS详解：用Vue的方式构建Three.js场景">TresJS详解：用Vue的方式构建Three.js场景</a><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言指向指针的指针(Pointer to Pointer)详解"/></a><div class="content"><a class="title" href="/2025/2025-10-01_Go%E8%AF%AD%E8%A8%80%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88(Pointer%20to%20Pointer)%E8%AF%A6%E8%A7%A3/" title="Go语言指向指针的指针(Pointer to Pointer)详解">Go语言指向指针的指针(Pointer to Pointer)详解</a><time datetime="2025-09-30T22:24:00.000Z" title="发表于 2025-10-01 06:24:00">2025-10-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-22.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/tags/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/tags/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/tags/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><script src="/self/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.1"></script></div></div></body></html>