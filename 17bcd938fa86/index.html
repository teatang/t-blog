<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NDP (Neighbor Discovery Protocol) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NDP (Neighbor Discovery Protocol)，即邻居发现协议，是 IPv6 (Internet Protocol version 6) 中的一个关键协议。它属于 ICMPv6 (Internet Control Message Protocol for IPv6) 的一部分，旨在替代 IPv4 中的 ARP (Address Resolution Protocol)、ICM">
<meta property="og:type" content="article">
<meta property="og:title" content="NDP (Neighbor Discovery Protocol) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/17bcd938fa86/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="NDP (Neighbor Discovery Protocol)，即邻居发现协议，是 IPv6 (Internet Protocol version 6) 中的一个关键协议。它属于 ICMPv6 (Internet Control Message Protocol for IPv6) 的一部分，旨在替代 IPv4 中的 ARP (Address Resolution Protocol)、ICM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg">
<meta property="article:published_time" content="2024-01-28T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:34:25.609Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "NDP (Neighbor Discovery Protocol) 详解",
  "url": "https://blog.tbf1211.xx.kg/17bcd938fa86/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg",
  "datePublished": "2024-01-28T22:24:00.000Z",
  "dateModified": "2026-02-01T09:34:25.609Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/17bcd938fa86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NDP (Neighbor Discovery Protocol) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-09.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">NDP (Neighbor Discovery Protocol) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">NDP (Neighbor Discovery Protocol) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-01-28T22:24:00.000Z" title="发表于 2024-01-29 06:24:00">2024-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>NDP (Neighbor Discovery Protocol)</strong>，即<strong>邻居发现协议</strong>，是 <strong>IPv6 (Internet Protocol version 6)</strong> 中的一个关键协议。它属于 <strong>ICMPv6 (Internet Control Message Protocol for IPv6)</strong> 的一部分，旨在替代 IPv4 中的 ARP (Address Resolution Protocol)、ICMP Router Discovery (路由器发现) 和 ICMP Redirect (重定向) 等功能，为 IPv6 主机和路由器提供在同一链路 (link) 上发现彼此、确定链路层地址、发现路由器、处理地址自动配置以及检测重复地址等服务。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>为 IPv6 提供无状态、多功能、更安全且效率更高的本地链路通信机制</strong>。它通过一系列 ICMPv6 消息，实现了 IPv4 中分散的多个协议功能，支持 IPv6 的核心特性如无状态地址自动配置 (SLAAC) 和高效的邻居管理。</p>
</div>
<hr>
<h2 id="一、为什么需要-NDP？-与-IPv4-协议的对比"><a href="#一、为什么需要-NDP？-与-IPv4-协议的对比" class="headerlink" title="一、为什么需要 NDP？(与 IPv4 协议的对比)"></a>一、为什么需要 NDP？(与 IPv4 协议的对比)</h2><p>IPv4 网络中的一些协议在 IPv6 环境下存在局限性或不适用，主要包括：</p>
<ol>
<li><p><strong>ARP (Address Resolution Protocol)</strong>：</p>
<ul>
<li><strong>广播风暴</strong>：ARP 依赖于广播请求 (目标 MAC 地址为 <code>FF:FF:FF:FF:FF:FF</code>)，在大型局域网中会产生大量的广播流量，影响网络性能。</li>
<li><strong>无状态</strong>：缺乏内置的安全机制，容易受到 ARP 欺骗 (ARP Spoofing) 等攻击。</li>
</ul>
</li>
<li><p><strong>ICMP Router Discovery</strong>：</p>
<ul>
<li><strong>手动配置或额外协议</strong>：IPv4 主机需要通过 DHCP 或手动配置默认网关，或者使用独立的 ICMP Router Discovery 协议来发现本地路由器。</li>
</ul>
</li>
<li><p><strong>ICMP Redirect</strong>：</p>
<ul>
<li><strong>功能单一</strong>：仅用于通知主机存在更优的下一跳路由器。</li>
</ul>
</li>
</ol>
<p>NDP 旨在克服这些局限性，并为 IPv6 提供更高效、更健壮、更灵活的本地链路通信机制：</p>
<ul>
<li><strong>统一功能</strong>：NDP 将 IPv4 中 ARP、ICMP Router Discovery 和 ICMP Redirect 的功能整合到单一协议中。</li>
<li><strong>多播替代广播</strong>：NDP 使用<strong>多播 (Multicast)</strong> 地址而非广播。多播只发送给那些对特定信息感兴趣的设备（加入特定多播组的设备），从而减少了网络中的广播风暴，提高了网络效率。</li>
<li><strong>无状态地址自动配置 (SLAAC)</strong>：NDP 是 IPv6 实现 SLAAC 的核心，允许主机自动生成和配置自己的 IPv6 地址，无需 DHCP 服务器（尽管 DHCPv6 仍可作为补充）。</li>
<li><strong>更好的可扩展性与安全性</strong>：NDP 协议设计上更具可扩展性，并支持未来的安全增强，如 SEcure Neighbor Discovery (SEND)。</li>
</ul>
<h2 id="二、NDP-的核心概念"><a href="#二、NDP-的核心概念" class="headerlink" title="二、NDP 的核心概念"></a>二、NDP 的核心概念</h2><p>在深入了解 NDP 消息之前，理解以下概念至关重要：</p>
<ol>
<li><p><strong>链路本地地址 (Link-Local Address)</strong>：</p>
<ul>
<li>所有 IPv6 接口在启动时都会自动配置一个以 <code>FE80::/10</code> 开头的链路本地地址。</li>
<li>这些地址仅在<strong>同一物理链路</strong>上有效，不能路由到其他链路。</li>
<li>NDP 消息通常使用链路本地地址作为源地址或目标地址。</li>
</ul>
</li>
<li><p><strong>邻居缓存 (Neighbor Cache)</strong>：</p>
<ul>
<li>类似于 IPv4 的 ARP 缓存，存储了链路上的 IPv6 地址与其对应链路层地址 (MAC 地址) 的映射关系。</li>
<li>也存储了邻居的状态信息（如可达性）。</li>
</ul>
</li>
<li><p><strong>目标缓存 (Destination Cache)</strong>：</p>
<ul>
<li>存储了目标 IPv6 地址与下一跳地址的映射。</li>
</ul>
</li>
<li><p><strong>前缀列表 (Prefix List)</strong>：</p>
<ul>
<li>主机学习到的、在本地链路上有效的前缀列表，用于判断目标地址是否在本地链路上。</li>
</ul>
</li>
<li><p><strong>默认路由器列表 (Default Router List)</strong>：</p>
<ul>
<li>主机学习到的、在本地链路上可用的默认路由器列表。</li>
</ul>
</li>
<li><p><strong>请求节点多播地址 (Solicited-Node Multicast Address)</strong>：</p>
<ul>
<li>这是一个特殊的 IPv6 多播地址，用于 NDP 请求。它的格式是 <code>FF02::1:FFXX:XXXX</code>，其中 <code>XX:XXXX</code> 是被请求的 IPv6 地址的最后 24 位。</li>
<li>当一个主机想要解析某个 IPv6 地址的 MAC 地址时，它会将请求发送到该地址对应的请求节点多播组。只有拥有该 IPv6 地址的设备才会监听并响应这个多播组，从而避免了广播给所有设备。</li>
</ul>
</li>
</ol>
<h2 id="三、NDP-的五种-ICMPv6-消息类型"><a href="#三、NDP-的五种-ICMPv6-消息类型" class="headerlink" title="三、NDP 的五种 ICMPv6 消息类型"></a>三、NDP 的五种 ICMPv6 消息类型</h2><p>NDP 协议通过五种特定的 ICMPv6 消息类型实现其功能：</p>
<h3 id="3-1-邻居请求-Neighbor-Solicitation-NS"><a href="#3-1-邻居请求-Neighbor-Solicitation-NS" class="headerlink" title="3.1 邻居请求 (Neighbor Solicitation, NS)"></a>3.1 邻居请求 (Neighbor Solicitation, NS)</h3><ul>
<li><strong>目的</strong>：<ul>
<li><strong>地址解析</strong>：主机发送 NS 以查询链路上某个 IPv6 地址对应的链路层地址（类似于 ARP 请求）。</li>
<li><strong>重复地址检测 (Duplicate Address Detection, DAD)</strong>：主机在配置新 IPv6 地址时，会向该地址发送 NS，以确认该地址是否已被其他设备占用。</li>
<li><strong>邻居可达性确认</strong>：确认邻居是否仍然在线并可达。</li>
</ul>
</li>
<li><strong>发送方式</strong>：通常发送到目标 IPv6 地址对应的<strong>请求节点多播地址</strong>。在 DAD 过程中，发送到自己的请求节点多播地址。</li>
<li><strong>源地址</strong>：发送者的链路本地地址（DAD 时为未指定地址 <code>::</code>）。</li>
<li><strong>目标地址</strong>：请求节点多播地址。</li>
</ul>
<h3 id="3-2-邻居通告-Neighbor-Advertisement-NA"><a href="#3-2-邻居通告-Neighbor-Advertisement-NA" class="headerlink" title="3.2 邻居通告 (Neighbor Advertisement, NA)"></a>3.2 邻居通告 (Neighbor Advertisement, NA)</h3><ul>
<li><strong>目的</strong>：<ul>
<li><strong>响应 NS</strong>：对 NS 消息的响应，包含发送者的链路层地址。</li>
<li><strong>无故通告 (Unsolicited NA)</strong>：当链路层地址或配置发生变化时（如网卡故障切换），主机可以主动发送 NA 来更新邻居的邻居缓存（类似于 Gratuitous ARP）。</li>
<li><strong>DAD 响应</strong>：如果收到 DAD 的 NS 消息，且该地址已被占用，则会发送 NA 告知地址冲突。</li>
</ul>
</li>
<li><strong>发送方式</strong>：<ul>
<li>响应 NS 时，单播回 NS 的源地址。</li>
<li>无故通告时，多播到所有节点多播地址 (<code>FF02::1</code>)。</li>
</ul>
</li>
<li><strong>源地址</strong>：发送者的 IPv6 地址。</li>
<li><strong>目标地址</strong>：NS 的源地址（单播）或所有节点多播地址（多播）。</li>
</ul>
<h3 id="3-3-路由器请求-Router-Solicitation-RS"><a href="#3-3-路由器请求-Router-Solicitation-RS" class="headerlink" title="3.3 路由器请求 (Router Solicitation, RS)"></a>3.3 路由器请求 (Router Solicitation, RS)</h3><ul>
<li><strong>目的</strong>：<ul>
<li>主机启动时或接口上线时，发送 RS 消息以请求链路上路由器的信息（如前缀、默认路由器等）。</li>
</ul>
</li>
<li><strong>发送方式</strong>：多播到所有路由器多播地址 (<code>FF02::2</code>)。</li>
<li><strong>源地址</strong>：主机的链路本地地址。</li>
<li><strong>目标地址</strong>：所有路由器多播地址 (<code>FF02::2</code>)。</li>
</ul>
<h3 id="3-4-路由器通告-Router-Advertisement-RA"><a href="#3-4-路由器通告-Router-Advertisement-RA" class="headerlink" title="3.4 路由器通告 (Router Advertisement, RA)"></a>3.4 路由器通告 (Router Advertisement, RA)</h3><ul>
<li><strong>目的</strong>：<ul>
<li><strong>响应 RS</strong>：路由器对 RS 消息的响应。</li>
<li><strong>周期性通告</strong>：路由器会周期性地多播 RA 消息，告知链路上主机的配置信息。</li>
<li><strong>提供信息</strong>：包含网络前缀、链路 MTU、可达时间、默认路由器、自动配置标志 (M&#x2F;O 标志，指示是否需要 DHCPv6) 等。</li>
</ul>
</li>
<li><strong>发送方式</strong>：<ul>
<li>响应 RS 时，单播回 RS 的源地址。</li>
<li>周期性通告时，多播到所有节点多播地址 (<code>FF02::1</code>)。</li>
</ul>
</li>
<li><strong>源地址</strong>：路由器的链路本地地址。</li>
<li><strong>目标地址</strong>：RS 的源地址（单播）或所有节点多播地址 (<code>FF02::1</code>)。</li>
</ul>
<h3 id="3-5-重定向-Redirect"><a href="#3-5-重定向-Redirect" class="headerlink" title="3.5 重定向 (Redirect)"></a>3.5 重定向 (Redirect)</h3><ul>
<li><strong>目的</strong>：<ul>
<li>当路由器发现存在到达特定目标地址的更优的“第一跳”路由器时，会向发送流量的主机发送 Redirect 消息，建议主机更新其路由信息。</li>
</ul>
</li>
<li><strong>发送方式</strong>：单播到发送原始数据包的主机。</li>
<li><strong>源地址</strong>：发送 Redirect 的路由器链路本地地址。</li>
<li><strong>目标地址</strong>：被重定向的主机 IPv6 地址。</li>
</ul>
<h2 id="四、NDP-的主要工作流程"><a href="#四、NDP-的主要工作流程" class="headerlink" title="四、NDP 的主要工作流程"></a>四、NDP 的主要工作流程</h2><p>NDP 将上述五种消息结合起来，实现了多种关键功能。</p>
<h3 id="4-1-邻居地址解析-Address-Resolution"><a href="#4-1-邻居地址解析-Address-Resolution" class="headerlink" title="4.1 邻居地址解析 (Address Resolution)"></a>4.1 邻居地址解析 (Address Resolution)</h3><p>主机 A (2001:db8::10) 需要向主机 B (2001:db8::20) 发送数据，但不知道主机 B 的 MAC 地址：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant HostA as 主机 A (2001:db8::10)
    participant Switch as 交换机
    participant HostB as 主机 B (2001:db8::20)
    participant OtherHosts as 其他主机

    HostA-&gt;&gt;HostA: 1. 需要发送数据包到 2001:db8::20
    HostA-&gt;&gt;HostA: 2. 检查邻居缓存，未找到 2001:db8::20 的MAC
    HostA-&gt;&gt;Switch: 3. 发送 Neighbor Solicitation (NS)&lt;br&#x2F;&gt;(目标地址: Solicited-Node Multicast of 2001:db8::20)
    Switch--&gt;&gt;HostB: 4. 转发 NS 到多播组的成员 (包括 Host B)
    Switch--&gt;&gt;OtherHosts: 5. 转发 NS 到多播组的成员 (不包括大部分 OtherHosts)

    HostB-&gt;&gt;HostB: 6. 收到 NS，发现目标 IPv6 地址匹配
    HostB-&gt;&gt;HostA: 7. 发送 Neighbor Advertisement (NA)&lt;br&#x2F;&gt;(包含 Host B 的 MAC 地址，单播回 Host A)
    OtherHosts--xOtherHosts: 8. 未加入多播组或目标IP不匹配，忽略 NS

    HostA-&gt;&gt;HostA: 9. 收到 NA，获取 2001:db8::20 的 MAC 地址
    HostA-&gt;&gt;HostA: 10. 将映射加入邻居缓存
    HostA-&gt;&gt;Switch: 11. 封装数据包到帧，目标MAC: Host B 的MAC
    Switch-&gt;&gt;HostB: 12. 转发数据帧
  </pre></div>

<h3 id="4-2-路由器发现与无状态地址自动配置-SLAAC"><a href="#4-2-路由器发现与无状态地址自动配置-SLAAC" class="headerlink" title="4.2 路由器发现与无状态地址自动配置 (SLAAC)"></a>4.2 路由器发现与无状态地址自动配置 (SLAAC)</h3><p>新加入网络的主机或接口上线时，如何获取 IP 地址和网关信息：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant Host as 新主机
    participant Router as 路由器
    participant DHCPv6_Server as DHCPv6服务器 (可选)

    Host-&gt;&gt;Host: 1. 配置链路本地地址 (FE80::...)
    Host-&gt;&gt;Host: 2. (DAD) 发送 NS 探测链路本地地址是否冲突
    Host-&gt;&gt;Router: 3. 发送 Router Solicitation (RS)&lt;br&#x2F;&gt;(目标地址: All Routers Multicast FF02::2)

    Router-&gt;&gt;Host: 4. 发送 Router Advertisement (RA)&lt;br&#x2F;&gt;(包含网络前缀、默认路由器、M&#x2F;O标志等)
    Host-&gt;&gt;Host: 5. 基于 RA 中的前缀信息和接口标识符生成全局单播地址 (SLAAC)

    Host-&gt;&gt;Host: 6. (DAD) 发送 NS 探测生成的全局单播地址是否冲突
    alt M标志置位 (Stateful DHCPv6)
        Host-&gt;&gt;DHCPv6_Server: 7. 发送 DHCPv6 Solicit 请求获取更多地址&#x2F;配置
        DHCPv6_Server-&gt;&gt;Host: 8. DHCPv6 Advertise &#x2F; Reply
    end
    alt O标志置位 (Stateless DHCPv6)
        Host-&gt;&gt;DHCPv6_Server: 7. 发送 DHCPv6 Information-request 获取其他配置信息 (如DNS)
        DHCPv6_Server-&gt;&gt;Host: 8. DHCPv6 Reply
    end
    Host-&gt;&gt;Host: 9. 地址配置完成，可进行通信
  </pre></div>

<h2 id="五、NDP-的安全考量"><a href="#五、NDP-的安全考量" class="headerlink" title="五、NDP 的安全考量"></a>五、NDP 的安全考量</h2><p>虽然 NDP 旨在改进 IPv4 协议，但它在设计时仍面临与 ARP 相似的安全挑战，尤其是缺少内置的强认证机制。</p>
<h3 id="5-1-安全漏洞"><a href="#5-1-安全漏洞" class="headerlink" title="5.1 安全漏洞"></a>5.1 安全漏洞</h3><ol>
<li><strong>邻居缓存投毒 (Neighbor Cache Poisoning) &#x2F; NDP Spoofing</strong>：<ul>
<li>攻击者可以发送伪造的 NS 或 NA 消息，声称自己是合法主机的链路层地址，从而劫持流量。</li>
<li><strong>后果</strong>：中间人攻击 (MITM)、拒绝服务 (DoS)、会话劫持。</li>
</ul>
</li>
<li><strong>路由器通告欺骗 (Router Advertisement Spoofing)</strong>：<ul>
<li>攻击者可以发送伪造的 RA 消息，发布错误的网络前缀、默认路由器或 MTU 等信息。</li>
<li><strong>后果</strong>：将流量重定向到恶意路由器、导致 DoS、网络配置混乱。</li>
</ul>
</li>
<li><strong>地址冲突攻击 (Duplicate Address Attack)</strong>：<ul>
<li>攻击者在 DAD 过程中回应一个 NS 消息，声称新地址已在使用，阻止合法主机获取 IP 地址。</li>
</ul>
</li>
</ol>
<h3 id="5-2-防范措施"><a href="#5-2-防范措施" class="headerlink" title="5.2 防范措施"></a>5.2 防范措施</h3><ol>
<li><strong>SEcure Neighbor Discovery (SEND)</strong>：<ul>
<li>这是 IETF 为 NDP 定义的一个安全扩展协议，旨在通过<strong>密码学</strong>手段（如公钥基础设施 PKI）对 NDP 消息进行数字签名和验证。</li>
<li>SEND 允许主机和路由器在 NDP 消息中嵌入一个“CGA (Cryptographically Generated Address)”选项，从而验证消息的来源和完整性。</li>
<li><strong>挑战</strong>：部署复杂，需要 PKI 基础设施支持，目前部署不广泛。</li>
</ul>
</li>
<li><strong>端口安全 (Port Security)</strong>：<ul>
<li>在支持 IPv6 的交换机上，限制每个端口可学习的 MAC 地址数量或只允许特定 MAC 地址。</li>
</ul>
</li>
<li><strong>IPv6 接入控制列表 (ACLs)</strong>：<ul>
<li>在路由器上配置 ACL，过滤来自不可信源的恶意 NDP 消息，或阻止某些 IPv6 地址段的 NS&#x2F;NA 消息。</li>
</ul>
</li>
<li><strong>IPv6 源防护 (IPv6 Source Guard)</strong>：<ul>
<li>类似于 IPv4 的 IP Source Guard，通过绑定端口、IP 地址和 MAC 地址来防止欺骗。</li>
</ul>
</li>
<li><strong>网络监测和入侵检测系统 (NIDS)</strong>：<ul>
<li>部署工具来实时监测网络中的 NDP 流量，检测异常行为（如短时间内大量 RA 消息、异常的 NA 响应）并告警。</li>
</ul>
</li>
<li><strong>静态邻居条目</strong>：<ul>
<li>对于关键设备（如路由器、服务器），可以手动配置静态邻居缓存条目，防止其被动态修改。但这在大型网络中不切实际。</li>
</ul>
</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>NDP 是 IPv6 协议栈的基石之一，它通过统一 ARP、路由器发现和重定向等功能，并采用多播机制，大大提升了 IPv6 网络在本地链路上的效率和灵活性。它还是 IPv6 无状态地址自动配置 (SLAAC) 的核心驱动力。然而，NDP 也继承了类似 ARP 的安全漏洞，NDP 欺骗和 RA 欺骗是常见的攻击手段。因此，在部署和管理 IPv6 网络时，理解 NDP 的工作原理并采取适当的安全防护措施（如 SEND 或其他二层安全机制）至关重要，以确保网络的稳定、高效和安全运行。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/17bcd938fa86/">https://blog.tbf1211.xx.kg/17bcd938fa86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-09.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/6014745b242a/" title="ARP (Address Resolution Protocol) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ARP (Address Resolution Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> ARP (Address Resolution Protocol)，即地址解析协议，是一个在局域网 (LAN) 内使用的网络层协议，主要用于将IP 地址 (网络层地址)解析为MAC 地址 (数据链路层地址)。在 TCP&#x2F;IP 协议栈中，当一台主机知道目标主机的 IP 地址，但需要知道其在同一物理网络上的 MAC 地址才能进行数据帧的发送时，就会使用 ARP 协议。  核心思想：将逻辑地址 (IP) 映射到物理地址 (MAC)，使得 IP 数据包能够在数据链路层封装成帧并通过物理网络介质传输到正确的目标设备。   一、为什么需要 ARP？在理解 ARP 之前，我们需要明确 IP 地址和 MAC 地址在网络通信中的角色：  IP 地址 (Internet Protocol Address)：工作在 OSI 模型的第三层 (网络层)。它是一个逻辑地址，用于在不同网络之间识别和路由数据包。IP 地址是分层的，包含网络部分和主机部分，使得路由器能够根据网络部分将数据包转发到正确的网络。 MAC 地址 (Media Access Control Address)：工作在 OSI ...</div></div></div></a><a class="pagination-related" href="/51210e3963c9/" title="Next.js 服务端组件 (RSC) 与客户端组件详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Next.js 服务端组件 (RSC) 与客户端组件详解</div></div><div class="info-2"><div class="info-item-1"> 随着 React 18 引入的 Server Components (RSC) 和 Next.js 13+ App Router 的推出，前端的渲染模式和组件组织方式发生了根本性变化。理解服务端组件 (Server Components) 和客户端组件 (Client Components) 之间的差异、它们的工作原理以及何时使用它们，是掌握现代 Next.js 应用开发的关键。这种分离旨在优化性能、减少客户端 JavaScript 包大小、提升用户体验并简化服务器端数据获取。  核心思想：将组件的渲染工作按需划分到服务器端和客户端，以最大化性能优势、最小化客户端JS负载，并提升开发者体验。服务端组件是默认行为，旨在执行不依赖浏览器API和交互的逻辑；客户端组件则用于处理用户交互和浏览器侧功能。   一、概述：为何需要区分服务端和客户端组件？在传统的 React 应用中，所有组件（即使是那些只显示静态内容的组件）最终都会在客户端（浏览器）执行其渲染逻辑，并参与“水合”（hydration）过程。这意味着：  大 JavaScript 包：所有组件的代码都需要打包并发送到客户端，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/6014745b242a/" title="ARP (Address Resolution Protocol) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-31</div><div class="info-item-2">ARP (Address Resolution Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> ARP (Address Resolution Protocol)，即地址解析协议，是一个在局域网 (LAN) 内使用的网络层协议，主要用于将IP 地址 (网络层地址)解析为MAC 地址 (数据链路层地址)。在 TCP&#x2F;IP 协议栈中，当一台主机知道目标主机的 IP 地址，但需要知道其在同一物理网络上的 MAC 地址才能进行数据帧的发送时，就会使用 ARP 协议。  核心思想：将逻辑地址 (IP) 映射到物理地址 (MAC)，使得 IP 数据包能够在数据链路层封装成帧并通过物理网络介质传输到正确的目标设备。   一、为什么需要 ARP？在理解 ARP 之前，我们需要明确 IP 地址和 MAC 地址在网络通信中的角色：  IP 地址 (Internet Protocol Address)：工作在 OSI 模型的第三层 (网络层)。它是一个逻辑地址，用于在不同网络之间识别和路由数据包。IP 地址是分层的，包含网络部分和主机部分，使得路由器能够根据网络部分将数据包转发到正确的网络。 MAC 地址 (Media Access Control Address)：工作在 OSI ...</div></div></div></a><a class="pagination-related" href="/eb691cf6a7fb/" title="PPPoE (Point-to-Point Protocol over Ethernet) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-07</div><div class="info-item-2">PPPoE (Point-to-Point Protocol over Ethernet) 详解</div></div><div class="info-2"><div class="info-item-1"> PPPoE (Point-to-Point Protocol over Ethernet)，中文常译为“以太网上的点对点协议”，是一种将传统的点对点协议 (PPP) 封装在以太网数据帧中的网络协议。它主要用于在以太网局域网中实现点对点连接，最常见的应用场景是通过 DSL (数字用户线路) 或光纤等宽带接入技术向最终用户提供上网服务。PPPoE 允许 ISP (互联网服务提供商) 对用户进行身份验证 (Authentication)、会话管理以及基于会话的计费，同时为用户分配 IP 地址和其他网络参数。  核心思想：在以太网链路的基础上，模拟 PPP 连接的拨号体验，为每个用户提供独立的虚拟“隧道”，实现用户身份认证、IP地址分配和会话管理，以便进行计费和带宽控制。   一、什么是 PPPoE？在 ADSL (非对称数字用户线路) 和早期的光纤宽带时代，ISP 需要一种机制来管理大量拨号上网的用户。传统的拨号上网（通过电话线 Modem 连接）使用的是 PPP 协议，它能够提供用户认证、IP 地址分配和加密等功能。然而，随着局域网 (LAN) 和以太网的普及，人们希望在以太网环境...</div></div></div></a><a class="pagination-related" href="/322d9ce55371/" title="DHCP (动态主机配置协议) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-08</div><div class="info-item-2">DHCP (动态主机配置协议) 详解</div></div><div class="info-2"><div class="info-item-1"> DHCP (Dynamic Host Configuration Protocol)，即动态主机配置协议，是一个应用层协议，它允许服务器动态地为客户端（例如计算机、智能手机、物联网设备等）分配 IP 地址和其他网络配置参数。DHCP 是目前最常用的网络配置方式，极大地简化了网络管理，避免了手动配置 IP 地址可能出现的冲突和错误。  核心思想：自动化分配 IP 地址和其他网络参数，简化网络管理，提高效率。   一、为什么需要 DHCP？在没有 DHCP 的情况下，每台连接到 TCP&#x2F;IP 网络的设备都需要手动配置以下信息：  IP 地址：设备在网络上的唯一标识。 子网掩码：用于区分 IP 地址的网络部分和主机部分。 默认网关：设备访问外部网络的路由器的 IP 地址。 DNS 服务器地址：用于将域名解析为 IP 地址的服务器。  手动配置的弊端显而易见：  复杂且耗时：对于大型网络，手动配置数百甚至数千台设备的网络参数是一项繁琐且容易出错的工作。 易出错：人为输入错误可能导致网络连接问题或 IP 地址冲突。 IP 地址冲突：如果不小心将同一个 IP 地址分配给多台设备，...</div></div></div></a><a class="pagination-related" href="/0f6de86a0220/" title="STUN (Session Traversal Utilities for NAT) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-12</div><div class="info-item-2">STUN (Session Traversal Utilities for NAT) 详解</div></div><div class="info-2"><div class="info-item-1"> STUN (Session Traversal Utilities for NAT)，即 NAT 会话穿越工具，是一种网络协议，它允许位于NAT (Network Address Translation，网络地址转换) 设备之后的客户端发现其外部（公共）IP 地址和端口号，以及 NAT 设备的类型。STUN 的主要目的是协助建立对等连接 (P2P)，尤其是在 VoIP、视频会议和 WebRTC 等实时通信应用中。  核心思想：帮助内网主机探测 NAT 类型和获取公网 IP:Port，为 P2P 连接做准备。   一、为什么需要 STUN？现代互联网中，IPv4 地址资源日益枯竭，导致大多数终端设备都部署在 NAT 设备（如路由器）之后。NAT 设备通过将内部私有 IP 地址映射到外部公共 IP 地址和端口，允许多个内部设备共享一个公共 IP 地址访问互联网。 然而，NAT 给直接的点对点 (P2P) 通信带来了巨大的挑战：  内网 IP 地址不可路由：内部私有 IP 地址在公共互联网上是不可见的，外部设备无法直接通过私有 IP 地址联系到内部设备。 端口映射不确定：NAT 设备...</div></div></div></a><a class="pagination-related" href="/aeeb1d5d94e7/" title="WebDAV详解：基于HTTP的分布式文件管理协议"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-02</div><div class="info-item-2">WebDAV详解：基于HTTP的分布式文件管理协议</div></div><div class="info-2"><div class="info-item-1"> WebDAV (Web Distributed Authoring and Versioning) 是一种基于 HTTP 协议的扩展协议，它允许客户端直接通过 Web 远程地执行文件和文件夹的操作，包括创建、移动、复制、删除、读取以及管理文件属性和锁机制。简而言之，WebDAV 将 Web 服务器从一个简单的内容消费者转变为一个可供用户直接进行创作和协同工作的平台，将 Web 页面视为可编辑的文档集合。  核心思想：WebDAV 在不改变 HTTP 核心语义的前提下，增加了 HTTP 缺乏的文件锁定、属性管理、命名空间管理等功能，使其能够支持分布式文件系统的基本操作。它将传统的“请求-响应”模式扩展为“文档创作-协作”模式。   一、为什么需要 WebDAV？HTTP 的局限性HTTP (Hypertext Transfer Protocol) 在设计之初，主要是为了实现信息的单向传输，即客户端请求资源，服务器提供资源。它的主要方法 (GET, POST, PUT, DELETE, HEAD, OPTIONS) 专注于获取、提交和替换&#x2F;删除单个资源。 然而，对于 We...</div></div></div></a><a class="pagination-related" href="/06b4f10e9d05/" title="RTSP (Real-Time Streaming Protocol) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-16</div><div class="info-item-2">RTSP (Real-Time Streaming Protocol) 详解</div></div><div class="info-2"><div class="info-item-1"> RTSP (Real-Time Streaming Protocol) 是一种应用层协议，旨在为流媒体服务器提供对实时媒体流的控制功能。它允许客户端远程控制流媒体服务器，例如启动、暂停、快进、倒带或停止媒体流，而无需下载整个文件。RTSP 协议本身不负责传输实际的媒体数据，它主要负责媒体流的会话建立、控制和断开。实际的媒体数据通常由 RTP (Real-time Transport Protocol) 和 RTCP (RTP Control Protocol) 协议进行传输。  核心思想：RTSP 就像一个“远程遥控器”，用于指挥流媒体服务器发送或停止媒体数据，而具体的数据传输则交给其他协议（通常是 RTP&#x2F;RTCP）来完成。   一、为什么需要 RTSP？在流媒体领域，用户需要对媒体播放进行灵活的控制，类似于操作本地播放器。传统的 HTTP 协议虽然可以用于文件下载，但其“请求-响应”模式并不适合实时流媒体的互动控制：  缺乏实时控制能力：HTTP 主要用于文件传输，不支持播放、暂停、快进、倒带等实时媒体控制操作。 不适合长时间连接：HTTP 通常是短连接，每次操作...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-NDP%EF%BC%9F-%E4%B8%8E-IPv4-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">一、为什么需要 NDP？(与 IPv4 协议的对比)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81NDP-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">二、NDP 的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81NDP-%E7%9A%84%E4%BA%94%E7%A7%8D-ICMPv6-%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">三、NDP 的五种 ICMPv6 消息类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%82%BB%E5%B1%85%E8%AF%B7%E6%B1%82-Neighbor-Solicitation-NS"><span class="toc-text">3.1 邻居请求 (Neighbor Solicitation, NS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%82%BB%E5%B1%85%E9%80%9A%E5%91%8A-Neighbor-Advertisement-NA"><span class="toc-text">3.2 邻居通告 (Neighbor Advertisement, NA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AF%B7%E6%B1%82-Router-Solicitation-RS"><span class="toc-text">3.3 路由器请求 (Router Solicitation, RS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%B7%AF%E7%94%B1%E5%99%A8%E9%80%9A%E5%91%8A-Router-Advertisement-RA"><span class="toc-text">3.4 路由器通告 (Router Advertisement, RA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%87%8D%E5%AE%9A%E5%90%91-Redirect"><span class="toc-text">3.5 重定向 (Redirect)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81NDP-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">四、NDP 的主要工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%82%BB%E5%B1%85%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90-Address-Resolution"><span class="toc-text">4.1 邻居地址解析 (Address Resolution)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8F%91%E7%8E%B0%E4%B8%8E%E6%97%A0%E7%8A%B6%E6%80%81%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-SLAAC"><span class="toc-text">4.2 路由器发现与无状态地址自动配置 (SLAAC)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81NDP-%E7%9A%84%E5%AE%89%E5%85%A8%E8%80%83%E9%87%8F"><span class="toc-text">五、NDP 的安全考量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E"><span class="toc-text">5.1 安全漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD"><span class="toc-text">5.2 防范措施</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-09.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>