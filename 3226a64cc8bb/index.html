<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python元类(Metaclass)深度解析 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，">
<meta property="og:type" content="article">
<meta property="og:title" content="Python元类(Metaclass)深度解析">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/3226a64cc8bb/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg">
<meta property="article:published_time" content="2023-02-08T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-22T04:00:21.120Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="编程语法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python元类(Metaclass)深度解析",
  "url": "https://blog.tbf1211.xx.kg/3226a64cc8bb/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-09.jpg",
  "datePublished": "2023-02-08T22:24:00.000Z",
  "dateModified": "2025-11-22T04:00:21.120Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/3226a64cc8bb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python元类(Metaclass)深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">307</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-09.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python元类(Metaclass)深度解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python元类(Metaclass)深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-08T22:24:00.000Z" title="发表于 2023-02-09 06:24:00">2023-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/3226a64cc8bb/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Python-元类深度解析：从概念到实战"><a href="#Python-元类深度解析：从概念到实战" class="headerlink" title="Python 元类深度解析：从概念到实战"></a>Python 元类深度解析：从概念到实战</h1><hr>
<blockquote>
<p>“Everything is an object.” - Python之禅<br>“Classes are objects too.” - 元类的核心思想</p>
</blockquote>
<p>在 Python 中，万物皆对象。你用 <code>class</code> 关键字定义的类，例如 <code>str</code>、<code>int</code>、<code>list</code>，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，它允许我们在类被创建时对其行为进行定制，是 Python 中进行高级面向对象编程的强大工具。</p>
<h2 id="1-什么是元类？"><a href="#1-什么是元类？" class="headerlink" title="1. 什么是元类？"></a>1. 什么是元类？</h2><p>在 Python 中，当你定义一个类 <code>class MyClass: pass</code> 的时候，Python 解释器会自动执行以下步骤：</p>
<ol>
<li><strong>定义一个类对象</strong>：解释器读取 <code>MyClass</code> 的定义，并创建一个名为 <code>MyClass</code> 的<strong>类对象</strong>。</li>
<li><strong>将类对象绑定到命名空间</strong>：这个 <code>MyClass</code> 类对象被绑定到当前的命名空间中。</li>
</ol>
<p>然后，当你通过 <code>my_instance = MyClass()</code> 来创建实例时，<code>MyClass</code> 这个类对象就会被调用，从而创建并返回一个实例对象。</p>
<p><strong>元类</strong>就是用来<strong>创建这些类对象</strong>的。或者说，元类是<strong>类的模板</strong>，它控制着类的创建过程，可以拦截类的定义，修改类的属性、方法，甚至完全改变类的行为。</p>
<p><strong>简而言之：</strong></p>
<ul>
<li><strong>实例</strong>是由<strong>类</strong>创建的。</li>
<li><strong>类</strong>是由<strong>元类</strong>创建的。</li>
</ul>
<p>默认情况下，Python 中所有类的元类都是 <code>type</code>。<code>type</code> 是 Python 内置的元类，也是最基本的元类。</p>
<h2 id="2-type-元类：你的第一个元类"><a href="#2-type-元类：你的第一个元类" class="headerlink" title="2. type 元类：你的第一个元类"></a>2. <code>type</code> 元类：你的第一个元类</h2><p><code>type</code> 不仅可以检查一个对象的类型（例如 <code>type(1)</code> 返回 <code>&lt;class &#39;int&#39;&gt;</code>），它更是一个功能强大的函数，可以<strong>动态地创建类</strong>。这是理解元类的关键。</p>
<p><code>type</code> 函数有三种形式：</p>
<ol>
<li><code>type(object)</code>：返回 <code>object</code> 的类型。</li>
<li><code>type(name, bases, dict)</code>：用于动态创建类。</li>
</ol>
<p>我们主要关注第二种形式：<code>type(name, bases, dict)</code>。</p>
<ul>
<li><code>name</code>: 类的名称（字符串）。</li>
<li><code>bases</code>: 基类（父类）组成的元组。如果没有任何父类，传入一个空元组 <code>()</code>。</li>
<li><code>dict</code>: 类的属性和方法组成的字典。键是属性&#x2F;方法名，值是属性值或方法函数。</li>
</ul>
<p><strong>示例：使用 <code>type</code> 动态创建类</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规方式定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassRegular</span>:</span><br><span class="line">    attr = <span class="number">100</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello from MyClassRegular!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 type 动态创建与 MyClassRegular 相同的类</span></span><br><span class="line">MyClassDynamic = <span class="built_in">type</span>(</span><br><span class="line">    <span class="string">&#x27;MyClassDynamic&#x27;</span>,  <span class="comment"># name: 类的名称</span></span><br><span class="line">    (),                <span class="comment"># bases: 基类元组，这里没有基类</span></span><br><span class="line">    &#123;                  <span class="comment"># dict: 类的属性和方法字典</span></span><br><span class="line">        <span class="string">&#x27;attr&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="string">&#x27;method&#x27;</span>: <span class="keyword">lambda</span> <span class="variable language_">self</span>: <span class="built_in">print</span>(<span class="string">&quot;Hello from MyClassDynamic!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证两个类行为一致</span></span><br><span class="line"><span class="built_in">print</span>(MyClassRegular)       <span class="comment"># &lt;class &#x27;__main__.MyClassRegular&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(MyClassDynamic)       <span class="comment"># &lt;class &#x27;__main__.MyClassDynamic&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">instance_regular = MyClassRegular()</span><br><span class="line">instance_dynamic = MyClassDynamic()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instance_regular.attr)  <span class="comment"># 100</span></span><br><span class="line">instance_regular.method()     <span class="comment"># Hello from MyClassRegular!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instance_dynamic.attr)  <span class="comment"># 100</span></span><br><span class="line">instance_dynamic.method()     <span class="comment"># Hello from MyClassDynamic!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认它们的类型都是 type</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(MyClassRegular)) <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(MyClassDynamic)) <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子清晰地表明，<code>type</code> 函数正是幕后创建类的“元类”。当我们使用 <code>class</code> 关键字时，Python 解释器实际上就是通过 <code>type</code> 来创建这个类对象的。</p>
<h2 id="3-自定义元类：掌控类的创建过程"><a href="#3-自定义元类：掌控类的创建过程" class="headerlink" title="3. 自定义元类：掌控类的创建过程"></a>3. 自定义元类：掌控类的创建过程</h2><p>现在我们知道 <code>type</code> 是默认的元类。那么，我们能否创建自己的元类，来定制类的创建过程呢？当然可以！</p>
<p>一个自定义元类必须继承自 <code>type</code>。它的核心思想是：当你定义一个类时，如果你指定了一个自定义元类，那么 Python 不再调用 <code>type</code> 来创建你的类，而是会调用你指定的那个自定义元类。</p>
<p>自定义元类通常会重写 <code>__new__</code> 或 <code>__init__</code> 方法。</p>
<ul>
<li><p><strong><code>__new__(cls, name, bases, dct)</code></strong>:</p>
<ul>
<li>在类对象<strong>被创建之前</strong>调用。</li>
<li><code>cls</code>: 元类本身（例如，如果你自定义的元类叫 <code>MyMeta</code>，那么 <code>cls</code> 就是 <code>MyMeta</code>）。</li>
<li><code>name</code>: 即将被创建的类的名称。</li>
<li><code>bases</code>: 即将被创建的类的基类元组。</li>
<li><code>dct</code>: 即将被创建的类的属性字典（包括方法）。</li>
<li><strong>职责</strong>：创建并返回新的类对象。通常会调用 <code>super().__new__(cls, name, bases, dct)</code> 来完成实际的类创建。在这个方法里，你可以在类创建前修改 <code>name</code>、<code>bases</code> 或 <code>dct</code>。</li>
</ul>
</li>
<li><p><strong><code>__init__(cls, name, bases, dct)</code></strong>:</p>
<ul>
<li>在类对象<strong>被创建之后</strong>，但实例被创建之前调用。</li>
<li><code>cls</code>: 已经创建好的类对象（比如 <code>MyClass</code>）。</li>
<li><code>name</code>, <code>bases</code>, <code>dct</code>: 与 <code>__new__</code> 类似。</li>
<li><strong>职责</strong>：初始化已经创建好的类对象。通常用于在类创建后添加、修改或验证属性。</li>
</ul>
</li>
</ul>
<h3 id="3-1-定义一个简单的自定义元类"><a href="#3-1-定义一个简单的自定义元类" class="headerlink" title="3.1 定义一个简单的自定义元类"></a>3.1 定义一个简单的自定义元类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 定义一个自定义元类，它必须继承自 type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="comment"># __new__ 是在类对象创建之前被调用的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, dct</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __new__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: Bases: <span class="subst">&#123;bases&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: Dict: <span class="subst">&#123;dct&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在这里可以修改 dct，例如添加一个属性</span></span><br><span class="line">        dct[<span class="string">&#x27;added_by_meta&#x27;</span>] = <span class="string">&quot;This was added by MyMeta&quot;</span></span><br><span class="line">        dct[<span class="string">&#x27;upper_name&#x27;</span>] = name.upper() <span class="comment"># 添加大写类名属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 必须调用父类(type)的 __new__ 方法来实际创建类对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, dct)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __init__ 是在类对象创建之后被调用的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls_obj, name, bases, dct</span>): <span class="comment"># 注意：这里用 cls_obj 避免和前面参数名混淆</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __init__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: Class object created: <span class="subst">&#123;cls_obj&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(cls_obj, name, bases, dct) <span class="comment"># 也要调用父类的 __init__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用自定义元类创建类</span></span><br><span class="line"><span class="comment"># 在 `class` 语句中，通过 `metaclass` 关键字参数指定元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdvancedClass</span>(metaclass=MyMeta):</span><br><span class="line">    version = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello from <span class="subst">&#123;self.__class__.__name__&#125;</span>, version <span class="subst">&#123;self.version&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证 MyAdvancedClass 的行为</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- After MyAdvancedClass definition ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MyAdvancedClass type is: <span class="subst">&#123;<span class="built_in">type</span>(MyAdvancedClass)&#125;</span>&quot;</span>) <span class="comment"># &lt;class &#x27;__main__.MyMeta&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认元类添加的属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MyAdvancedClass.added_by_meta: <span class="subst">&#123;MyAdvancedClass.added_by_meta&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MyAdvancedClass.upper_name: <span class="subst">&#123;MyAdvancedClass.upper_name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">instance = MyAdvancedClass()</span><br><span class="line">instance.greeting()</span><br></pre></td></tr></table></figure>

<p>运行上述代码，你会看到输出的顺序：</p>
<ol>
<li><code>MyMeta.__new__</code> 会在 <code>MyAdvancedClass</code> 类定义被处理时立即执行。</li>
<li><code>MyMeta.__init__</code> 紧接着执行，完成类对象的初始化。</li>
<li>最后才是 <code>MyAdvancedClass</code> 自身的使用。</li>
</ol>
<p>这证明了元类确实在类创建的早期阶段就介入了。</p>
<h3 id="3-2-prepare-方法-Python-3-6"><a href="#3-2-prepare-方法-Python-3-6" class="headerlink" title="3.2 __prepare__ 方法 (Python 3.6+)"></a>3.2 <code>__prepare__</code> 方法 (Python 3.6+)</h3><p>在 Python 3.6 引入了 <code>__prepare__(name, bases)</code> 这个元类方法。它在 <code>__new__</code> 和 <code>__init__</code> 之前被调用，用于创建类的命名空间字典。</p>
<ul>
<li><strong>职责</strong>：返回一个字典（或字典类对象），用于存储类的属性和方法。默认情况下，Python 使用普通的 <code>dict</code>。你可以返回一个 <code>OrderedDict</code> 等，确保属性的定义顺序得到保留。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedClassMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__prepare__</span>(<span class="params">metacls, name, bases</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __prepare__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> OrderedDict() <span class="comment"># 返回一个有序字典</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">metacls, name, bases, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __new__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Meta: classdict type in __new__: <span class="subst">&#123;<span class="built_in">type</span>(classdict)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(metacls, name, bases, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, name, bases, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- Meta: __init__ called for class <span class="subst">&#123;name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(cls, name, bases, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOrderedClass</span>(metaclass=OrderedClassMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_a</span>(<span class="params">self</span>): <span class="keyword">pass</span></span><br><span class="line">    _property_x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_b</span>(<span class="params">self</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 MyOrderedClass 的属性字典将保留定义顺序</span></span><br><span class="line"><span class="comment"># 虽然通过 dir() 或 __dict__ 仍然会看到默认的排序，</span></span><br><span class="line"><span class="comment"># 但在元类创建类时，__prepare__ 提供的有序字典确保了处理属性的顺序性。</span></span><br><span class="line"><span class="comment"># 实际的应用场景可能在需要反射或代码生成时，依赖定义的顺序。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-call-方法：控制实例创建"><a href="#4-call-方法：控制实例创建" class="headerlink" title="4. __call__ 方法：控制实例创建"></a>4. <code>__call__</code> 方法：控制实例创建</h2><p>我们已经看到元类的 <code>__new__</code> 和 <code>__init__</code> 控制着<strong>类的创建</strong>过程。<br>但当我们通过 <code>MyClass()</code> 来创建<strong>实例</strong>时，幕后发生了什么呢？</p>
<p>实际上，当你调用 <code>MyClass()</code> 时，Python 会调用 <code>MyClass</code> 这个<strong>类对象</strong>的 <code>__call__</code> 方法。由于 <code>MyClass</code> 是由元类创建的，所以它的 <code>__call__</code> 方法实际上继承自它的元类（<code>type</code> 或你的自定义元类）。</p>
<p><code>type</code> 的 <code>__call__</code> 方法做了三件事：</p>
<ol>
<li>调用 <code>MyClass.__new__</code>(cls, *args, **kwargs) 创建实例对象。</li>
<li>如果 <code>__new__</code> 返回的是 <code>cls</code> 的实例，则调用 <code>MyClass.__init__</code>(self, *args, **kwargs) 初始化实例。</li>
<li>返回实例对象。</li>
</ol>
<p>因此，如果你想控制<strong>实例的创建过程</strong>（例如，实现单例模式、延迟加载等），你应该在自定义元类中重写 <code>__call__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 如果类的实例尚未被创建</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            <span class="comment"># 调用 type.__call__ 来创建实例，并存储它</span></span><br><span class="line">            cls._instances[cls] = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls] <span class="comment"># 返回已有的实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = data</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;MySingleton instance <span class="subst">&#123;<span class="built_in">id</span>(self)&#125;</span> with data &#x27;<span class="subst">&#123;self.data&#125;</span>&#x27; created.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次创建实例</span></span><br><span class="line">s1 = MySingleton(<span class="string">&quot;first_data&quot;</span>) <span class="comment"># 会输出创建信息</span></span><br><span class="line">s2 = MySingleton(<span class="string">&quot;second_data&quot;</span>) <span class="comment"># 不会再次创建，直接返回s1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s1 is s2: <span class="subst">&#123;s1 <span class="keyword">is</span> s2&#125;</span>&quot;</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s1.data: <span class="subst">&#123;s1.data&#125;</span>&quot;</span>)   <span class="comment"># first_data</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;s2.data: <span class="subst">&#123;s2.data&#125;</span>&quot;</span>)   <span class="comment"># first_data</span></span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何使用元类的 <code>__call__</code> 方法轻松实现单例模式。</p>
<h2 id="5-什么时候需要使用元类？"><a href="#5-什么时候需要使用元类？" class="headerlink" title="5. 什么时候需要使用元类？"></a>5. 什么时候需要使用元类？</h2><p>元类是一个高级工具，通常在以下场景中考虑使用：</p>
<ol>
<li><p><strong>框架级开发</strong>：在构建大型框架时，你可能需要对所有由该框架创建的类强制执行某些行为，例如：</p>
<ul>
<li><strong>自动注册类</strong>：所有继承自特定基类的类都被自动注册到一个列表中。</li>
<li><strong>注入通用方法&#x2F;属性</strong>：确保所有类都拥有某些特定的方法或属性（如ORM模型类自动拥有 <code>query</code> 方法）。</li>
<li><strong>接口&#x2F;抽象类的验证</strong>：在类定义时检查它是否实现了所有必须的方法。</li>
<li><strong>修改类的行为</strong>：如强制所有方法名以特定前缀开头。</li>
</ul>
</li>
<li><p><strong>API 定义</strong>：当你需要一个非常声明式的 API 时，元类能帮助你将一些“魔术”封装起来，让用户只需要声明性地定义类，而无需关心底层实现。</p>
</li>
<li><p><strong>ORM (Object-Relational Mapping)</strong>：ORM 中经常用到元类来将 Python 类映射到数据库表。例如，Django ORM 的 <code>models.Model</code> 就是通过元类实现的。当你定义 <code>class User(models.Model): ...</code> 时，元类会解析你的字段定义，并为其生成对应的数据库列以及 <code>save</code>, <code>filter</code> 等方法。</p>
</li>
<li><p><strong>单例模式</strong>：如上例所示，可以强制一个类只能有一个实例。</p>
</li>
<li><p><strong>插件系统</strong>：可以动态地发现并加载所有继承某个基类的插件。</p>
</li>
</ol>
<p><strong>然而，请记住：</strong></p>
<ul>
<li>元类是强大的，但也是复杂的。它们会增加代码的复杂性和理解难度。</li>
<li><strong>不要过度使用元类。</strong> 大部分情况下，继承、类装饰器甚至普通的函数就能解决问题。</li>
<li>只有当需要<strong>在类创建时修改类本身或其行为</strong>时，才考虑元类。</li>
</ul>
<h2 id="6-与类装饰器、继承的比较"><a href="#6-与类装饰器、继承的比较" class="headerlink" title="6. 与类装饰器、继承的比较"></a>6. 与类装饰器、继承的比较</h2><table>
<thead>
<tr>
<th align="left">特性&#x2F;功能</th>
<th align="left">元类 (Metaclass)</th>
<th align="left">类装饰器 (Class Decorator)</th>
<th align="left">继承 (Inheritance)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用时机</strong></td>
<td align="left"><strong>类创建时</strong>（在 <code>class</code> 语句执行时）</td>
<td align="left"><strong>类定义后</strong>（在类对象创建完成后）</td>
<td align="left">运行时，实例创建时</td>
</tr>
<tr>
<td align="left"><strong>影响范围</strong></td>
<td align="left">控制<strong>如何创建类</strong>本身，影响所有实例和类本身的行为</td>
<td align="left">接受一个已创建的类，返回一个新类或修改后的类</td>
<td align="left">改变子类的行为，通过方法重写、属性覆盖</td>
</tr>
<tr>
<td align="left"><strong>修改能力</strong></td>
<td align="left">可以修改 <code>类</code> 的 <code>__dict__</code>、基类、名称等，<strong>完全控制类创建过程</strong></td>
<td align="left">对已创建的类进行修改（如添加方法、属性）</td>
<td align="left">通过子类定义，增加或修改父类的属性和方法</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">框架级、ORM、自动注册、强制类结构、单例等</td>
<td align="left">常用工具、日志、权限、接口检查、添加 mixin</td>
<td align="left">代码复用、多态、LSP、组织代码结构</td>
</tr>
<tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left"><strong>高</strong>，引入了额外的抽象层</td>
<td align="left"><strong>中等</strong></td>
<td align="left"><strong>低-中等</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">仅在必要时使用（高级框架）</td>
<td align="left">常用，替代部分元类功能</td>
<td align="left">最常用，面向对象编程基石</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li><strong>继承</strong>是 Python 中最基本和常用的代码重用机制，用于定义“is-a”关系。</li>
<li><strong>类装饰器</strong>是在类已经完全创建之后，对其进行“包装”或“修改”。它比元类更简单，可以处理许多本需要元类才能解决的问题。</li>
<li><strong>元类</strong>则是在类诞生的那一刻就介入，控制着类的整个生产流程。</li>
</ul>
<p>如果你需要一个通用机制，让<strong>每个特定类或子类</strong>都能拥有一些额外的属性或方法，<strong>继承通常是最好的选择</strong>。<br>如果需要对<strong>某个特定的类</strong>进行非侵入性的修改或增强，<strong>类装饰器更简洁</strong>。<br>只有当你需要<strong>影响所有类的创建方式</strong>（无论它们是否通过继承共享基类，或是需要影响类的 <code>__dict__</code>、<code>bases</code> 等<strong>核心定义结构</strong>）时，才应该考虑元类。</p>
<h2 id="7-实例与类创建的流程回顾"><a href="#7-实例与类创建的流程回顾" class="headerlink" title="7. 实例与类创建的流程回顾"></a>7. 实例与类创建的流程回顾</h2><p>理解元类，最好回顾一下 Python 对象、类和元类之间的关系及创建流程：</p>
<ol>
<li><p><strong>定义一个类 <code>MyClass</code></strong>：</p>
<ul>
<li>Python 解释器发现 <code>class MyClass(metaclass=MyMeta): ...</code>。</li>
<li>它首先找到 <code>MyMeta</code> 这个元类。</li>
<li><strong>调用 <code>MyMeta.__prepare__</code></strong>：准备类的字典，默认是 <code>dict</code>。</li>
<li><strong>执行类体代码</strong>：将 <code>version = 1.0</code> 和 <code>greeting</code> 方法加入到准备好的字典中。</li>
<li><strong>调用 <code>MyMeta.__new__(MyMeta, &quot;MyClass&quot;, (object,), class_dict)</code></strong>：<code>MyMeta</code> 的 <code>__new__</code> 方法被调用。它会在此时创建 <code>MyClass</code> <strong>类对象</strong>。</li>
<li><strong>调用 <code>MyMeta.__init__(MyClass_obj, &quot;MyClass&quot;, (object,), class_dict)</code></strong>：<code>MyMeta</code> 的 <code>__init__</code> 方法被调用，用于初始化已经创建好的 <code>MyClass</code> 类对象。</li>
<li><strong>返回 <code>MyClass</code> 类对象</strong>。</li>
</ul>
</li>
<li><p><strong>创建 <code>MyClass</code> 的实例 <code>my_instance = MyClass()</code></strong>：</p>
<ul>
<li>Python 解释器发现 <code>MyClass()</code>，它会去调用 <code>MyClass</code> 这个类对象本身的 <code>__call__</code> 方法。</li>
<li>由于 <code>MyClass</code> 是由 <code>MyMeta</code> 创建的，<code>MyClass</code> 的 <code>__call__</code> 方法继承自 <code>MyMeta</code>（或 <code>type</code>）。</li>
<li><strong>调用 <code>MyMeta.__call__(MyClass, *args, **kwargs)</code></strong>：<ul>
<li>它首先会调用 <code>MyClass.__new__(MyClass, *args, **kwargs)</code> 来创建实例对象（<code>MyClass</code> 自己的 <code>__new__</code> 方法，如果定义了）。</li>
<li>如果 <code>MyClass.__new__</code> 返回的是 <code>MyClass</code> 的实例，它会接着调用 <code>MyClass.__init__(instance_obj, *args, **kwargs)</code> 来初始化实例对象。</li>
<li><strong>返回实例对象 <code>my_instance</code></strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这个流程图可以帮助你清晰地理解各个方法在哪个阶段发挥作用。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>元类是 Python 面向对象编程中最具魔力的特性之一，它将“一切皆对象”的哲学推向了极致。掌握元类，意味着你对 Python 对象的创建和生命周期有了更深层次的理解和掌控。然而，就像其他强大的工具一样，元类也需要谨慎使用。在决定使用元类之前，请始终评估是否可以通过继承或类装饰器来实现相同的功能。只有当你的需求确实落入元类的独特领域时，它才是你的最佳选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/3226a64cc8bb/">https://blog.tbf1211.xx.kg/3226a64cc8bb/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95/">编程语法</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-09.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/14a9adc4c65f/" title="乌合之众：群体心理学的经典洞察与当代反思"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">乌合之众：群体心理学的经典洞察与当代反思</div></div><div class="info-2"><div class="info-item-1"> 《乌合之众：大众心理研究》(Psychologie des Foules) 是法国社会心理学家古斯塔夫·勒庞 (Gustave Le Bon) 于 1895 年出版的经典著作。这本书深入剖析了群体的心理特征、行为模式及其对社会和政治的影响。勒庞以其独到的视角，揭示了个人融入群体后，理智的消退和非理性、情绪化倾向的凸显。  核心思想：个人一旦融入群体，其独立的思想、理智和判断力便会消失，取而代之的是群体共同的情感、冲动和无意识行为，群体会呈现出与构成它的个人截然不同的特征。   一、勒庞的时代背景与写作动机19 世纪末的欧洲，正经历着剧烈的社会变革。工业革命带来的城市化、大众教育的普及以及民主化进程，使得“大众”第一次登上历史舞台，成为不可忽视的社会力量。罢工、政治集会、社会骚乱此起彼伏，政治家们面临着如何理解和引导这股新生力量的挑战。 勒庞亲身经历了这些动荡，他观察到：  传统权威的瓦解：宗教、君主制等传统权威逐渐式微。 新兴力量的崛起：报纸、大众传媒的兴起，以及街头政治的活跃，使得群体情绪能够被迅速煽动和传播。 理性的局限性：启蒙运动倡导的理性主义似乎在群体面前失效，群体行为...</div></div></div></a><a class="pagination-related" href="/6a5fbe75d3cc/" title="PHP 内存溢出解决方案详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">PHP 内存溢出解决方案详解</div></div><div class="info-2"><div class="info-item-1"> PHP 内存溢出 (Memory Exhausted) 是 PHP 应用程序开发中一个常见的问题，通常表现为 Fatal error: Allowed memory size of X bytes exhausted。这意味着 PHP 脚本在执行过程中尝试分配的内存超出了配置允许的最大值。理解其原因并掌握有效的解决方案对于构建稳定、高性能的 PHP 应用至关重要。  核心思想：PHP 内存溢出通常源于：1. 配置限制；2. 代码中大量数据处理或未释放的资源；3. 内存泄漏。解决的关键在于合理配置、优化代码和有效管理内存。   一、理解 PHP 内存溢出的原因PHP 内存溢出主要有以下几方面的原因：  PHP 配置限制： memory_limit 配置项：这是 PHP 限制单个脚本可以使用的最大内存量。如果脚本尝试使用的内存超过这个值，就会触发内存溢出错误。 服务器资源限制：即使 memory_limit 很高，宿主机本身的内存资源也有限。   代码层面问题： 处理大量数据：一次性从数据库中查询大量记录、处理大型文件、或对大型数组&#x2F;字符串进行操作，都可能导致内存瞬时暴增...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/f52f9b242f1c/" title="Python装饰器详解：从基础到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-15</div><div class="info-item-2">Python装饰器详解：从基础到高级应用</div></div><div class="info-2"><div class="info-item-1"> Python 装饰器 (Decorators) 是一种强大而优雅的语法糖，它允许你在不修改原函数代码的情况下，给函数添加额外的功能或修改其行为。装饰器本质上是一个接受函数作为参数并返回一个新函数的函数。它广泛应用于日志记录、性能测试、事务处理、权限验证等场景，是 Python 高级编程中不可或缺的工具。  “装饰器是 Python 的一项强大功能，它使得代码更加模块化、可读性更高，能够优雅地实现功能的扩展和复用，而无需侵入式地修改原有代码。”   一、理解装饰器前的预备知识要真正理解装饰器，我们需要先掌握几个 Python 核心概念： 1.1 函数是第一类对象 (First-Class Objects)在 Python 中，函数与其他数据类型（如整数、字符串）一样，是第一类对象。这意味着你可以：  将函数赋值给变量 将函数作为参数传递给其他函数 将函数作为另一个函数的返回值 在数据结构中存储函数  示例： 123456789101112131415161718192021def greet(name):    return f&quot;Hello, &#123;name&#1...</div></div></div></a><a class="pagination-related" href="/cb923ba84dd9/" title="Python NumPy详解：科学计算的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="info-item-2">Python NumPy详解：科学计算的基石</div></div><div class="info-2"><div class="info-item-1"> NumPy (Numerical Python) 是 Python 中用于科学计算的核心库。它提供了一个高性能的多维数组对象 ndarray，以及用于处理这些数组的工具。NumPy 是 Python 数据科学和机器学习生态系统的基石，许多其他库（如 SciPy, Pandas, Matplotlib, Scikit-learn）都建立在 NumPy 数组之上。  核心思想：NumPy 引入了高效的 ndarray 数据结构，通过向量化操作显著提升了 Python 处理数值数据的性能。   一、为什么选择 NumPy？Python 语言本身处理列表等数据结构时效率较高，但对于大规模数值计算而言，原生的 Python 列表效率低下。NumPy 通过以下方式解决了这个问题：  高性能 ndarray 对象：ndarray 存储同类型数据，在内存中连续存储，相比 Python 列表，占用的内存更少，访问速度更快。 向量化操作：NumPy 允许对整个数组进行操作，而无需编写显式的循环。这些操作通常在 C 或 Fortran 中实现，执行速度远超 Python 循环。 广播 (Broadc...</div></div></div></a><a class="pagination-related" href="/dbdbe99385cd/" title="Python Pandas详解：数据处理与分析的瑞士军刀"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="info-item-2">Python Pandas详解：数据处理与分析的瑞士军刀</div></div><div class="info-2"><div class="info-item-1"> Pandas 是 Python 中用于数据分析和处理的核心库。它提供了一套高性能、易于使用的数据结构，最主要的是 DataFrame（二维表格数据）和 Series（一维带标签数组），用于快速处理和分析结构化数据（如 CSV、Excel、数据库表格数据）。Pandas 以其直观的语法和强大的功能，成为数据科学家和数据工程师的首选工具。  核心思想：Pandas 将表格数据抽象为 DataFrame 和 Series 对象，提供类似 SQL 和 Excel 的操作，通过向量化和 C&#x2F;Cython 实现的底层优化，极大提升了数据处理效率。   一、为什么选择 Pandas？在数据驱动的时代，我们经常需要处理各种形式的表格数据。Python 原生的数据结构（如列表、字典）虽然灵活，但在处理大量、复杂、异构的表格数据时显得力不从心。Pandas 解决了这些痛点：  直观的数据结构：DataFrame 和 Series 提供了强大的标签索引功能，使得数据操作更加直观，无需关注底层实现。 高效的数据操作：底层基于 NumPy 优化，利用 C 和 Cython 实现，对于大规模数据...</div></div></div></a><a class="pagination-related" href="/1b5035114ad1/" title="Python Requests库详解：HTTP请求的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="info-item-2">Python Requests库详解：HTTP请求的艺术</div></div><div class="info-2"><div class="info-item-1"> requests 库 是 Python 生态系统中最流行、最强大、也是最优雅的 HTTP 客户端库之一。它简化了复杂的 HTTP 请求操作，让开发者能够以极少量的代码发送各种类型的 HTTP 请求，并轻松处理响应。与 Python 内置的 urllib 模块相比，requests 提供了更友好、更直观的 API，被誉为“面向人类的 HTTP 服务”。  核心思想：requests 封装了底层 HTTP 协议的复杂性，提供简洁的 API，让开发者专注于业务逻辑而非网络通信的细节。   一、为什么选择 Requests？在 Python 中进行 HTTP 请求有多种方式，例如内置的 urllib 模块。但 requests 库之所以广受欢迎，主要得益于以下优势：  友好的 API：设计直观，易学易用，代码可读性高。 功能强大：支持几乎所有 HTTP 功能，包括 GET, POST, PUT, DELETE 等方法，以及请求头、数据、文件上传、Cookie、身份认证、代理、SSL 验证等。 自动处理：自动处理 URL 编码、重定向、会话管理等常见任务。 JSON 支持：内置 JSON...</div></div></div></a><a class="pagination-related" href="/a1d408b2ddbe/" title="Python多进程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="info-item-2">Python多进程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式概述模式构成：  生产者 (Producer)：负责生成数据，并将其放入共享的缓冲区（队列）中。 消费者 (Consumer)：负责从共享的缓冲区（队列）中取出数据进行处理。 缓冲区 (Buffer &#x2F; Queue)：一个共享的数据结构，通常是一个队列，用于存储生产者生产的数据和消费者消费的数据。它充当了生产者和消费者之间的桥梁。  解决的问题：  解耦：生产者和消费者可以独立运行，互不干扰，提高系统的灵活性。 并发：允许多个生产者和多个消费者同时存在，提高处理效率。 削峰填谷：当生产速度快于消费速度时，缓冲区可以存储多余的数据，防止数...</div></div></div></a><a class="pagination-related" href="/832eaf04ac40/" title="Python多线程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="info-item-2">Python多线程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模块实现多线程版的生产者-消费者模式。  核心思想：利用线程安全的共享队列作为缓冲，实现生产者与消费者解耦，并通过队列自带的互斥锁和条件变量进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式与多线程概述1.1 生产者-消费者模式参考 Python 多进程生产者-消费者模式详解 中的概述，其核心构成和解决的问题在多线程场景下是相同的：  生产者 (Producer)：生成数据并放入队列。 消费者 (Consumer)：从队列取出数据并处理。 缓冲区 (Queue)：共享的、线程安全的数据容器。  1.2 Python 多线程与 GIL threading 模块：Python 标...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">307</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">199</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">69</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-%E5%85%83%E7%B1%BB%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E5%AE%9E%E6%88%98"><span class="toc-text">Python 元类深度解析：从概念到实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%B1%BB%EF%BC%9F"><span class="toc-text">1. 什么是元类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-type-%E5%85%83%E7%B1%BB%EF%BC%9A%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B1%BB"><span class="toc-text">2. type 元类：你的第一个元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%EF%BC%9A%E6%8E%8C%E6%8E%A7%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">3. 自定义元类：掌控类的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB"><span class="toc-text">3.1 定义一个简单的自定义元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-prepare-%E6%96%B9%E6%B3%95-Python-3-6"><span class="toc-text">3.2 __prepare__ 方法 (Python 3.6+)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-call-%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">4. __call__ 方法：控制实例创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB%EF%BC%9F"><span class="toc-text">5. 什么时候需要使用元类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%8E%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">6. 与类装饰器、继承的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E4%BE%8B%E4%B8%8E%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%9E%E9%A1%BE"><span class="toc-text">7. 实例与类创建的流程回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"/></a><div class="content"><a class="title" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析">压缩字典树 (Radix Trie/Patricia Trie) 深度解析</a><time datetime="2025-11-17T22:24:00.000Z" title="发表于 2025-11-18 06:24:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c28be5a597e1/" title="Golang 内存对齐详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 内存对齐详解"/></a><div class="content"><a class="title" href="/c28be5a597e1/" title="Golang 内存对齐详解">Golang 内存对齐详解</a><time datetime="2025-11-12T22:24:00.000Z" title="发表于 2025-11-13 06:24:00">2025-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 空结构体 (struct{}) 详解"/></a><div class="content"><a class="title" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解">Golang 空结构体 (struct{}) 详解</a><time datetime="2025-11-10T22:24:00.000Z" title="发表于 2025-11-11 06:24:00">2025-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/b100840425a8/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codex 详解与使用技巧：OpenAI 的代码智能模型"/></a><div class="content"><a class="title" href="/b100840425a8/" title="Codex 详解与使用技巧：OpenAI 的代码智能模型">Codex 详解与使用技巧：OpenAI 的代码智能模型</a><time datetime="2025-11-06T22:24:00.000Z" title="发表于 2025-11-07 06:24:00">2025-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Claude Code 详解：Anthropic 的代码智能模型"/></a><div class="content"><a class="title" href="/6d28d801758d/" title="Claude Code 详解：Anthropic 的代码智能模型">Claude Code 详解：Anthropic 的代码智能模型</a><time datetime="2025-11-04T22:24:00.000Z" title="发表于 2025-11-05 06:24:00">2025-11-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-09.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2021 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>