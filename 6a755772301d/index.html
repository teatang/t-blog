<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Golang errgroup.Group 并发模式详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 Go 语言中，sync&#x2F;errgroup 包提供了一个 Group 类型，它是对 sync.WaitGroup 和 context 包的封装，旨在更优雅地处理并发 goroutine 组的错误和取消。它使得在多个 goroutine 中执行任务，并在任何一个 goroutine 返回错误时，能够及时通知并取消其他 goroutine，同时等待所有 goroutine 完成变得更简单。  核心">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang errgroup.Group 并发模式详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/6a755772301d/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在 Go 语言中，sync&#x2F;errgroup 包提供了一个 Group 类型，它是对 sync.WaitGroup 和 context 包的封装，旨在更优雅地处理并发 goroutine 组的错误和取消。它使得在多个 goroutine 中执行任务，并在任何一个 goroutine 返回错误时，能够及时通知并取消其他 goroutine，同时等待所有 goroutine 完成变得更简单。  核心">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2024-08-03T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:41:47.051Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="goroutine">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang errgroup.Group 并发模式详解",
  "url": "https://blog.tbf1211.xx.kg/6a755772301d/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2024-08-03T22:24:00.000Z",
  "dateModified": "2026-02-01T09:41:47.051Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/6a755772301d/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Golang errgroup.Group 并发模式详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Golang errgroup.Group 并发模式详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Golang errgroup.Group 并发模式详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-08-03T22:24:00.000Z" title="发表于 2024-08-04 06:24:00">2024-08-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/">Golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Golang/goroutine/">goroutine</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在 Go 语言中，<code>sync/errgroup</code> 包提供了一个 <code>Group</code> 类型，它是对 <code>sync.WaitGroup</code> 和 <code>context</code> 包的封装，旨在更优雅地处理<strong>并发 goroutine 组的错误</strong>和<strong>取消</strong>。它使得在多个 goroutine 中执行任务，并在任何一个 goroutine 返回错误时，能够及时通知并取消其他 goroutine，同时等待所有 goroutine 完成变得更简单。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<code>errgroup.Group</code> 允许你<strong>并行执行一组任务</strong>。如果其中任何一个任务失败，它会自动取消所有正在运行的任务，并聚合它们的错误。它简化了并行任务的启动、<code>context</code> 信号传递、错误收集和等待所有任务完成的逻辑。</p>
</div>
<hr>
<h2 id="一、为什么需要-errgroup-Group？"><a href="#一、为什么需要-errgroup-Group？" class="headerlink" title="一、为什么需要 errgroup.Group？"></a>一、为什么需要 <code>errgroup.Group</code>？</h2><p>在 Go 语言中进行并发编程时，经常会遇到以下场景：</p>
<ol>
<li><strong>启动多个 goroutine 处理子任务</strong>：一个大任务可能需要分解成多个独立的子任务，并行的由不同的 goroutine 执行。</li>
<li><strong>等待所有 goroutine 完成</strong>：主 goroutine 需要知道所有子任务都已完成才能继续或返回。</li>
<li><strong>处理子任务的错误</strong>：任何一个子任务的失败都可能意味着整个大任务的失败，需要将错误传递回主 goroutine。</li>
<li><strong>及时取消</strong>：当一个子任务失败时，其他正在运行的子任务可能不再需要继续执行，应该被及时取消以节省资源。</li>
</ol>
<p>如果手动实现这些逻辑，通常需要结合使用 <code>sync.WaitGroup</code> 来等待 goroutine，使用 <code>chan error</code> 来收集错误，并通过 <code>context.WithCancel</code> 手动传递取消信号。这个过程会相对繁琐且容易出错，尤其是在复杂场景下。</p>
<p><code>errgroup.Group</code> 就是为了解决这些痛点而诞生的，它将上述常用模式封装起来，提供了一套简洁的 API。</p>
<h2 id="二、核心概念与结构"><a href="#二、核心概念与结构" class="headerlink" title="二、核心概念与结构"></a>二、核心概念与结构</h2><p><code>errgroup.Group</code> 包含两个主要组件：</p>
<ol>
<li><strong><code>context.Context</code></strong>：<code>Group</code> 内部会创建一个 <code>context.Context</code> (通常是 <code>context.WithCancel</code> 的结果)。当任何一个由 <code>Group</code> 启动的 goroutine <strong>返回非 nil 错误</strong>时，这个 <code>Context</code> 会被自动取消。这将触发所有监听该 <code>Context</code> 的 goroutine 提前退出。</li>
<li><strong><code>sync.WaitGroup</code></strong>：<code>Group</code> 内部使用了 <code>sync.WaitGroup</code> 来跟踪所有由它启动的 goroutine。<code>Wait()</code> 方法会阻塞直到所有 goroutine 完成。</li>
</ol>
<h3 id="errgroup-Group-的定义-简化"><a href="#errgroup-Group-的定义-简化" class="headerlink" title="errgroup.Group 的定义 (简化)"></a><code>errgroup.Group</code> 的定义 (简化)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上是 `golang.org/x/sync/errgroup` 包中的类型</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="comment">// 取消函数，用于取消内部 Context</span></span><br><span class="line">	wg     sync.WaitGroup <span class="comment">// 等待组，用于等待所有 goroutine 完成</span></span><br><span class="line"></span><br><span class="line">	once   sync.Once <span class="comment">// 确保只记录第一个错误</span></span><br><span class="line">	err    <span class="type">error</span>     <span class="comment">// 存储第一个非 nil 错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group 的主要方法:</span></span><br><span class="line"><span class="comment">// func WithContext(ctx context.Context) (*Group, context.Context)</span></span><br><span class="line"><span class="comment">// func (g *Group) Go(f func() error)</span></span><br><span class="line"><span class="comment">// func (g *Group) Wait() error</span></span><br></pre></td></tr></table></figure>

<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><ul>
<li><strong><code>WithContext(ctx context.Context) (*Group, context.Context)</code></strong>：<ul>
<li>创建一个新的 <code>*Group</code> 实例，并返回一个从传入 <code>ctx</code> 派生出的子 <code>Context</code>。</li>
<li>这个返回的 <code>Context</code> 会在 <code>Group</code> 中任何一个 <code>Go</code> 启动的 goroutine <strong>返回非 nil 错误时</strong>自动调用 <code>cancel</code> 函数而取消。</li>
<li>通常，我们会将这个新的 <code>Context</code> 传递给由 <code>Group.Go</code> 启动的 goroutine，以便它们能够响应取消信号。</li>
</ul>
</li>
<li><strong><code>Go(f func() error)</code></strong>：<ul>
<li>在一个新的 goroutine 中执行一个函数 <code>f</code>。</li>
<li>函数 <code>f</code> 必须返回一个 <code>error</code>。如果 <code>f</code> 返回非 <code>nil</code> 错误，<code>Group</code> 会记录这个错误，并触发内部 <code>Context</code> 的取消。</li>
<li><code>Go</code> 方法会自动调用 <code>wg.Add(1)</code>。</li>
</ul>
</li>
<li><strong><code>Wait() error</code></strong>：<ul>
<li>阻塞直到所有由 <code>Go</code> 启动的 goroutine 都已完成。</li>
<li>返回第一个由 <code>Go</code> 启动的 goroutine 返回的<strong>非 nil 错误</strong>。如果没有 goroutine 返回错误，则返回 <code>nil</code>。</li>
</ul>
</li>
</ul>
<h2 id="三、errgroup-Group-的典型用法"><a href="#三、errgroup-Group-的典型用法" class="headerlink" title="三、errgroup.Group 的典型用法"></a>三、<code>errgroup.Group</code> 的典型用法</h2><h3 id="3-1-基本用法：等待全部完成并收集错误"><a href="#3-1-基本用法：等待全部完成并收集错误" class="headerlink" title="3.1 基本用法：等待全部完成并收集错误"></a>3.1 基本用法：等待全部完成并收集错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">taskOne</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Task One completed.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 模拟成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">taskTwo</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Task Two completed.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error from Task Two&quot;</span>) <span class="comment">// 模拟失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">taskThree</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Task Three completed.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 模拟成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Starting tasks...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 errgroup.Group 管理 goroutine</span></span><br><span class="line">	<span class="keyword">var</span> g errgroup.Group</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动第一个任务</span></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> taskOne()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动第二个任务</span></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> taskTwo()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动第三个任务</span></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> taskThree()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所有任务完成，并获取可能的错误</span></span><br><span class="line">	<span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Some task failed: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;All tasks completed successfully.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;All done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出示例 (不确定任务执行顺序，但错误会被捕获)</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Starting tasks...</span><br><span class="line">Task Three completed.</span><br><span class="line">Task One completed.</span><br><span class="line">Task Two completed.</span><br><span class="line">Some task failed: error from Task Two</span><br><span class="line">All done.</span><br></pre></td></tr></table></figure>
<p>在这个例子中，即使 <code>taskTwo</code> 失败，<code>g.Wait()</code> 也会等待所有任务都完成，然后返回 <code>taskTwo</code> 的错误。</p>
<h3 id="3-2-结合-Context-实现及时取消"><a href="#3-2-结合-Context-实现及时取消" class="headerlink" title="3.2 结合 Context 实现及时取消"></a>3.2 结合 <code>Context</code> 实现及时取消</h3><p>这是 <code>errgroup.Group</code> 最强大的特性之一。通过 <code>WithContext</code> 获取的 <code>Context</code> 可以用于通知其他 goroutine 停止工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchDataFromDB</span><span class="params">(ctx context.Context, id <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;DB Fetcher %d: 开始查询...\n&quot;</span>, id)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second): <span class="comment">// 模拟耗时操作，持续3秒</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;DB Fetcher %d: 查询完成。\n&quot;</span>, id)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 收到取消信号</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;DB Fetcher %d: 收到取消信号 (%v)，中断查询。\n&quot;</span>, id, ctx.Err())</span><br><span class="line">		<span class="keyword">return</span> ctx.Err() <span class="comment">// 返回 Context 的错误</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callExternalAPI</span><span class="params">(ctx context.Context, id <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;API Caller %d: 开始调用外部API...\n&quot;</span>, id)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second): <span class="comment">// 模拟较快操作，持续1秒</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;API Caller %d: 外部API调用失败！\n&quot;</span>, id)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to call external API for %d&quot;</span>, id) <span class="comment">// 模拟失败</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 收到取消信号</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;API Caller %d: 收到取消信号 (%v)，中断调用。\n&quot;</span>, id, ctx.Err())</span><br><span class="line">		<span class="keyword">return</span> ctx.Err() <span class="comment">// 返回 Context 的错误</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Starting concurrent operations...&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个父 Context，并从它派生出一个带有 cancel 功能的 Context</span></span><br><span class="line">	parentCtx := context.Background()</span><br><span class="line">	group, ctx := errgroup.WithContext(parentCtx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动数据库查询</span></span><br><span class="line">	group.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fetchDataFromDB(ctx, <span class="number">1</span>) <span class="comment">// 传递 group 派生的 Context</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动外部API调用</span></span><br><span class="line">	group.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> callExternalAPI(ctx, <span class="number">2</span>) <span class="comment">// 传递 group 派生的 Context</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所有任务完成</span></span><br><span class="line">	<span class="keyword">if</span> err := group.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Main: 至少一个任务失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Main: 所有任务成功完成。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: 所有 goroutine 已停止。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Starting concurrent operations...</span><br><span class="line">DB Fetcher 1: 开始查询...</span><br><span class="line">API Caller 2: 开始调用外部API...</span><br><span class="line">API Caller 2: 外部API调用失败！</span><br><span class="line">DB Fetcher 1: 收到取消信号 (context canceled)，中断查询。</span><br><span class="line">Main: 至少一个任务失败: failed to call external API for 2</span><br><span class="line">Main: 所有 goroutine 已停止。</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>callExternalAPI</code> 仅用时 1 秒就失败了。由于它返回了非 <code>nil</code> 错误，<code>errgroup.Group</code> 立即取消了它内部的 <code>Context</code>。<code>fetchDataFromDB</code> 在其 <code>select</code> 语句中检测到了这个取消信号，并提前退出了，避免了不必要的 3 秒等待。</p>
<h3 id="3-3-限制并发数-可选"><a href="#3-3-限制并发数-可选" class="headerlink" title="3.3 限制并发数 (可选)"></a>3.3 限制并发数 (可选)</h3><p><code>errgroup.Group</code> 本身不提供限制并发数的功能。如果需要限制并发，可以结合 <code>chan struct&#123;&#125;</code> 或 <code>semaphore</code> 来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processItem</span><span class="params">(ctx context.Context, itemID <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	delay := time.Duration(rand.Intn(<span class="number">500</span>)+<span class="number">100</span>) * time.Millisecond <span class="comment">// 随机延迟</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Processing item %d: started, will take %v\n&quot;</span>, itemID, delay)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(delay):</span><br><span class="line">		<span class="keyword">if</span> itemID == <span class="number">5</span> &#123; <span class="comment">// 模拟某个特定项处理失败</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Processing item %d: FAILED!\n&quot;</span>, itemID)</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;item %d processing failed&quot;</span>, itemID)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Processing item %d: finished\n&quot;</span>, itemID)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Processing item %d: cancelled (%v)\n&quot;</span>, itemID, ctx.Err())</span><br><span class="line">		<span class="keyword">return</span> ctx.Err()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Starting batch processing...&quot;</span>)</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	parentCtx := context.Background()</span><br><span class="line">	group, ctx := errgroup.WithContext(parentCtx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 channel 限制并发数，例如设置最大并发为 3</span></span><br><span class="line">	concurrencyLimit := <span class="number">3</span></span><br><span class="line">	sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, concurrencyLimit)</span><br><span class="line"></span><br><span class="line">	itemsToProcess := <span class="number">10</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= itemsToProcess; i++ &#123;</span><br><span class="line">		itemID := i <span class="comment">// 捕获循环变量</span></span><br><span class="line">		sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取一个令牌，如果 channel 已满则阻塞</span></span><br><span class="line">		group.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem &#125;() <span class="comment">// 释放令牌</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> processItem(ctx, itemID)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := group.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Batch processing finished with error: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Batch processing finished successfully.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Main: All done.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、errgroup-Group-的优缺点"><a href="#四、errgroup-Group-的优缺点" class="headerlink" title="四、errgroup.Group 的优缺点"></a>四、<code>errgroup.Group</code> 的优缺点</h2><h3 id="4-1-优点："><a href="#4-1-优点：" class="headerlink" title="4.1 优点："></a>4.1 优点：</h3><ol>
<li><strong>代码简洁</strong>：显著简化了多个 goroutine 的错误处理、取消和等待逻辑。</li>
<li><strong>自动取消</strong>：任何一个 goroutine 返回错误都会自动取消 <code>Context</code>，进而通知其他 goroutine 停止。</li>
<li><strong>错误聚合</strong>：<code>Wait()</code> 方法返回第一个非 <code>nil</code> 错误，避免了手动收集错误。</li>
<li><strong>与 <code>Context</code> 集成</strong>：天然地与 Go 的 <code>Context</code> 机制结合，方便在请求链路中传递取消信号。</li>
</ol>
<h3 id="4-2-缺点："><a href="#4-2-缺点：" class="headerlink" title="4.2 缺点："></a>4.2 缺点：</h3><ol>
<li><strong>只返回第一个错误</strong>：如果多个 goroutine 同时返回错误，<code>Wait()</code> 只会返回其中一个错误。如果需要收集所有错误，需要额外的逻辑。</li>
<li><strong>不处理 panic</strong>：<code>errgroup.Go</code> 不会捕获 <code>panic</code>。如果 goroutine 发生 <code>panic</code>，程序通常会崩溃。需要在 <code>Go</code> 的函数内部进行 <code>recover</code>。</li>
<li><strong>不能限制并发数</strong>：<code>errgroup.Group</code> 本身没有内置的并发限制功能，需要结合 <code>channel</code> 或 <code>semaphore</code> 等其他机制来实现。</li>
</ol>
<h2 id="五、errgroup-Group-对比-sync-WaitGroup-和-context-WithCancel"><a href="#五、errgroup-Group-对比-sync-WaitGroup-和-context-WithCancel" class="headerlink" title="五、errgroup.Group 对比 sync.WaitGroup 和 context.WithCancel"></a>五、<code>errgroup.Group</code> 对比 <code>sync.WaitGroup</code> 和 <code>context.WithCancel</code></h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>sync.WaitGroup</code></th>
<th align="left"><code>context.WithCancel</code> (手动与 WaitGroup 结合)</th>
<th align="left"><code>errgroup.Group</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>功能焦点</strong></td>
<td align="left">等待一组 goroutine 完成</td>
<td align="left">手动取消 goroutine 集合</td>
<td align="left">等待 goroutine 完成，收集第一个错误，自动取消协程</td>
</tr>
<tr>
<td align="left"><strong>错误处理</strong></td>
<td align="left">无内建错误收集机制，需手动实现</td>
<td align="left">需手动实现错误收集和判断逻辑</td>
<td align="left"><strong>自动收集第一个非 nil 错误</strong></td>
</tr>
<tr>
<td align="left"><strong>取消传播</strong></td>
<td align="left">无内建取消机制，需结合 <code>context.WithCancel</code> 手动实现</td>
<td align="left">可实现取消，但需手动管理 <code>CancelFunc</code> 和 <code>Done</code> channel</td>
<td align="left"><strong>自动在任一 goroutine 失败时取消所有其他 goroutine</strong></td>
</tr>
<tr>
<td align="left"><strong>Context 管理</strong></td>
<td align="left">无</td>
<td align="left">需手动创建并传递 <code>Context</code> 和 <code>CancelFunc</code></td>
<td align="left"><strong>提供一个可自动取消和传播的 <code>Context</code></strong></td>
</tr>
<tr>
<td align="left"><strong>代码复杂度</strong></td>
<td align="left">简单（仅等待），错误和取消需额外代码</td>
<td align="left">中等（需要协调 WaitGroup, Context, 错误 channel）</td>
<td align="left"><strong>简洁</strong>（封装了 WaitGroup, Context, 错误处理逻辑）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">仅需要等待 goroutine 完成，不关心错误或取消</td>
<td align="left">对错误和取消有精细控制需求，但允许手动管理复杂性</td>
<td align="left"><strong>并行执行多个任务，需要快速失败和统一错误处理的场景</strong></td>
</tr>
</tbody></table>
<h2 id="六、安全性考虑与最佳实践"><a href="#六、安全性考虑与最佳实践" class="headerlink" title="六、安全性考虑与最佳实践"></a>六、安全性考虑与最佳实践</h2><ol>
<li><strong>始终使用 <code>WithContext</code></strong>：为了能够利用 <code>errgroup</code> 的自动取消机制，务必使用 <code>errgroup.WithContext(parentCtx)</code> 来初始化 <code>Group</code> 并获取其派生的 <code>Context</code>。</li>
<li><strong>将 <code>ctx</code> 传递给子 goroutine</strong>：将 <code>errgroup.WithContext</code> 返回的 <code>ctx</code> 传递给由 <code>group.Go</code> 启动的函数，并在这些函数内部通过 <code>select &#123; case &lt;-ctx.Done(): ... &#125;</code> 监听取消信号。</li>
<li><strong>Defer <code>cancel()</code> (如果手动创建 Context)</strong>：如果你直接使用 <code>context.WithCancel</code> 生成 <code>Context</code> 并将其提供给 <code>errgroup.WithContext</code>，那么你需要确保在适当的时候调用 <code>cancel()</code>。然而，通常 <code>errgroup.WithContext</code> 会为你管理 <code>cancel</code> 调用。</li>
<li><strong>错误返回</strong>：确保由 <code>group.Go</code> 启动的函数在需要时返回有意义的错误。</li>
<li><strong>处理 <code>panic</code></strong>：对于可能发生 <code>panic</code> 的 goroutine，务必在 <code>group.Go</code> 传入的闭包函数中添加 <code>defer func() &#123; if r := recover(); r != nil &#123; /* 处理 panic */ &#125; &#125;()</code> 以保证程序的稳定性。</li>
<li><strong>并发限制</strong>：在处理大量任务时，如果资源有限，应结合 <code>chan struct&#123;&#125;</code> 或 <code>golang.org/x/sync/semaphore</code> 等工具来限制并发数，防止资源耗尽。</li>
<li><strong>理解取消机制</strong>：明确 <code>Group</code> 的 <code>Context</code> 仅在<strong>有 goroutine 返回非 <code>nil</code> 错误</strong>时才会被取消。如果所有 goroutine 都成功返回 <code>nil</code>，或者它们没有监听 <code>ctx.Done()</code>，则不会被取消。</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>errgroup.Group</code> 是 Go 语言并发编程中的一个非常实用的模式，它将 <code>sync.WaitGroup</code> 和 <code>context.WithCancel</code> 的常见用法封装起来，提供了一个简洁高效的 API。它特别适用于需要并行执行一组任务、等待所有这些任务完成、并在任何任务失败时能够及时取消其他任务的场景。掌握 <code>errgroup.Group</code> 的使用，能够显著提升 Go 并发代码的健壮性和可维护性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/6a755772301d/">https://blog.tbf1211.xx.kg/6a755772301d/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/goroutine/">goroutine</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/9f5a2c0e7ea7/" title="Goroutine 相比 OS 线程，为什么能规模化？"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Goroutine 相比 OS 线程，为什么能规模化？</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是其并发模型的核心。与传统的操作系统 (OS) 线程相比，Goroutine 展现出了惊人的规模化能力，使得 Go 程序能够轻松地并发处理成千上万甚至数百万的任务。这种规模化的差异并非偶然，而是由 Goroutine 独特的设计哲学和 Go 运行时（runtime）的智能调度机制所决定的。  核心思想：Goroutine 之所以能规模化，是因为它是一种轻量级的用户态协程，由 Go 运行时在少数 OS 线程上进行多路复用和调度，从而避免了 OS 线程的高开销和上下文切换代价。   一、Goroutine 与 OS 线程的本质区别在深入探讨为什么 Goroutine 能够规模化之前，我们需要理解它与 OS 线程之间的根本不同。 1.1 OS 线程 (Operating System Thread) 内核态实体：OS 线程是由操作系统内核调度的执行单元。每次创建、销毁或切换线程都需要进行系统调用（进入内核态），这会带来较大的开销。 内存开销大：每个 OS 线程通常会分配一个固定大小的栈（例如，Linux 上默认 8MB），即使实际只使用了很小一部...</div></div></div></a><a class="pagination-related" href="/7642665c9bbb/" title="Golang context 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Golang context 详解</div></div><div class="info-2"><div class="info-item-1"> context 包 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递请求范围的数据 (request-scoped data)、取消信号 (cancellation signals) 和截止时间 (deadlines) 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，context 包是管理 Goroutine 生命周期和避免资源泄露的基石。  核心思想：context.Context 接口允许在 Goroutine 树中安全地传递控制流信息。其核心价值在于实现对计算任务的统一取消、超时控制和值传递，从而提升程序的健壮性和资源利用效率。   一、context 包的必要性在 Go 语言中，Goroutine 是轻量级并发的基础。然而，当应用程序的并发逻辑变得复杂时，以下问题会变得突出：  并发操作的取消：当一个上游操作（如用户取消请求）不再需要其下游的所有并发子任务时，如何有效地通知并停止这些子任务，避免不必要的计算和资源消耗？ 操作超时控制：如何在复杂的请求链中，为整个链条或其中某个环节设置统一的...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/7642665c9bbb/" title="Golang context 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-03</div><div class="info-item-2">Golang context 详解</div></div><div class="info-2"><div class="info-item-1"> context 包 是 Go 语言标准库中的一个关键组件，自 Go 1.7 版本引入，它提供了一种在 Goroutine 之间传递请求范围的数据 (request-scoped data)、取消信号 (cancellation signals) 和截止时间 (deadlines) 的标准机制。在构建复杂的并发系统、微服务架构以及处理网络请求链时，context 包是管理 Goroutine 生命周期和避免资源泄露的基石。  核心思想：context.Context 接口允许在 Goroutine 树中安全地传递控制流信息。其核心价值在于实现对计算任务的统一取消、超时控制和值传递，从而提升程序的健壮性和资源利用效率。   一、context 包的必要性在 Go 语言中，Goroutine 是轻量级并发的基础。然而，当应用程序的并发逻辑变得复杂时，以下问题会变得突出：  并发操作的取消：当一个上游操作（如用户取消请求）不再需要其下游的所有并发子任务时，如何有效地通知并停止这些子任务，避免不必要的计算和资源消耗？ 操作超时控制：如何在复杂的请求链中，为整个链条或其中某个环节设置统一的...</div></div></div></a><a class="pagination-related" href="/099de403ef3d/" title="Golang 缓冲Channel和无缓冲Channel的区别"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Golang 缓冲Channel和无缓冲Channel的区别</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言的并发编程模型中，Channel 是 Goroutine 之间通信和同步的核心机制。Channel 提供了一种安全、同步的方式来传递数据。根据其容量大小，Channel 可以分为两种类型：无缓冲 Channel (Unbuffered Channel) 和 缓冲 Channel (Buffered Channel)。理解这两种 Channel 的区别以及它们各自的适用场景，是编写高效、正确 Go 并发代码的关键。  核心思想：无缓冲 Channel 强调“同步”通信，发送方和接收方必须同时就绪。缓冲 Channel 则允许“异步”通信，发送方可以在接收方未就绪时发送数据，但容量有限。   一、Channel 简介在 Go 中，Channel 是类型化的管道，可以通过它们发送和接收特定类型的值。它遵循“通过通信共享内存，而不是通过共享内存来通信”的并发哲学。 声明 Channel 的基本语法： 12345// 声明一个传递 int 类型数据的无缓冲 Channelvar ch1 chan int// 声明一个传递 string 类型数据的缓冲 Channel，容量为...</div></div></div></a><a class="pagination-related" href="/9f5a2c0e7ea7/" title="Goroutine 相比 OS 线程，为什么能规模化？"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">Goroutine 相比 OS 线程，为什么能规模化？</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是其并发模型的核心。与传统的操作系统 (OS) 线程相比，Goroutine 展现出了惊人的规模化能力，使得 Go 程序能够轻松地并发处理成千上万甚至数百万的任务。这种规模化的差异并非偶然，而是由 Goroutine 独特的设计哲学和 Go 运行时（runtime）的智能调度机制所决定的。  核心思想：Goroutine 之所以能规模化，是因为它是一种轻量级的用户态协程，由 Go 运行时在少数 OS 线程上进行多路复用和调度，从而避免了 OS 线程的高开销和上下文切换代价。   一、Goroutine 与 OS 线程的本质区别在深入探讨为什么 Goroutine 能够规模化之前，我们需要理解它与 OS 线程之间的根本不同。 1.1 OS 线程 (Operating System Thread) 内核态实体：OS 线程是由操作系统内核调度的执行单元。每次创建、销毁或切换线程都需要进行系统调用（进入内核态），这会带来较大的开销。 内存开销大：每个 OS 线程通常会分配一个固定大小的栈（例如，Linux 上默认 8MB），即使实际只使用了很小一部...</div></div></div></a><a class="pagination-related" href="/10866559bfd1/" title="Go 语言中的组合 (Composition) 与接口 (Interfaces) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-20</div><div class="info-item-2">Go 语言中的组合 (Composition) 与接口 (Interfaces) 详解</div></div><div class="info-2"><div class="info-item-1"> Go 语言在设计之初就摒弃了传统面向对象编程 (OOP) 语言中的类继承机制。相反，它提供了一套独特且强大的机制来实现代码复用、扩展性和多态性：组合 (Composition) 通过结构体嵌入 (Struct Embedding)，以及多态通过接口 (Interfaces)。理解并熟练运用这两者，是编写地道 (idiomatic) 和高效 Go 代码的关键。  核心思想：Go 语言通过组合构建“has-a”关系来复用代码和数据结构，通过接口定义“behaves-like-a”关系来实现多态和松耦合。   一、Go 语言的设计哲学：组合优于继承传统 OOP 语言中的继承机制，尽管在代码复用和构建类型层次方面有所优势，但也常常导致紧耦合、僵化的类结构和“脆弱的基类问题”。Go 语言的设计者意识到了这些局限性，并选择了一条不同的道路：  避免继承的复杂性：Go 没有类，也没有继承，从而避免了多重继承带来的菱形问题和复杂的类层次结构。 强调行为而非类型：通过接口，Go 更关注“一个对象能做什么”，而不是“一个对象是什么类型”。 鼓励松耦合：组合和接口共同促进了组件之间的解耦，使得系统更...</div></div></div></a><a class="pagination-related" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-31</div><div class="info-item-2">如何防止 Golang Goroutine 泄漏</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，Goroutine 是轻量级的并发执行单元，相比操作系统线程，其创建和销毁的开销极小。然而，这并不意味着我们可以随意创建 Goroutine 而不进行管理。当一个 Goroutine 启动后，如果它无法正常退出，就会一直占用内存和 CPU 资源，这种现象称为 Goroutine 泄漏 (Goroutine Leak)。Goroutine 泄漏会导致程序内存持续增长，最终耗尽系统资源，甚至引发 OOM (Out Of Memory) 错误，严重影响程序的稳定性和性能。  核心思想：Goroutine 泄漏的本质是，一个 Goroutine 完成了其预期的任务，但由于某种原因无法终止或被回收，持续占用资源。防止泄漏的关键在于确保每个 Goroutine 都有明确的退出条件和机制。   一、什么是 Goroutine 泄漏？Goroutine 泄漏是指 Goroutine 在其生命周期结束后未能被 Go 运行时回收，从而持续驻留在内存中。一个泄漏的 Goroutine 会一直占用：  栈内存：每个 Goroutine 都会分配栈空间 (初始 2KB 并动态伸缩)。大...</div></div></div></a><a class="pagination-related" href="/5f39b91cbb70/" title="Golang flag 包详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-12</div><div class="info-item-2">Golang flag 包详解</div></div><div class="info-2"><div class="info-item-1"> Golang flag 包 是 Go 语言标准库中的一个核心组件，用于解析命令行参数（或称命令行标志）。它提供了一种简单且标准化的方式，让开发者能够为应用程序定义并处理各种类型的命令行选项，从而允许用户在执行程序时自定义其行为。  核心思想：通过注册预期接受的命令行标志及其默认值和使用说明，然后调用 flag.Parse() 函数，flag 包会自动解析命令行输入，并将标志值赋给对应的变量。   一、为什么需要 flag 包？在命令行环境中，应用程序经常需要接受用户提供的参数来改变其执行逻辑或配置。例如：  ./myprogram -port 8080 -verbose ./compiler -o output.exe source.go  手动解析这些参数（例如，通过 os.Args 数组）会涉及大量的字符串操作、类型转换和错误处理，这不仅繁琐且容易出错。flag 包就是为了解决这个问题而设计的：  标准化解析：遵循 POSIX 或 GNU 风格的命令行标志约定（如 -flag 或 --flag）。 类型安全：支持 string, int, bool, time.Durati...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-errgroup-Group%EF%BC%9F"><span class="toc-text">一、为什么需要 errgroup.Group？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-text">二、核心概念与结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#errgroup-Group-%E7%9A%84%E5%AE%9A%E4%B9%89-%E7%AE%80%E5%8C%96"><span class="toc-text">errgroup.Group 的定义 (简化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">属性和方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81errgroup-Group-%E7%9A%84%E5%85%B8%E5%9E%8B%E7%94%A8%E6%B3%95"><span class="toc-text">三、errgroup.Group 的典型用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%9A%E7%AD%89%E5%BE%85%E5%85%A8%E9%83%A8%E5%AE%8C%E6%88%90%E5%B9%B6%E6%94%B6%E9%9B%86%E9%94%99%E8%AF%AF"><span class="toc-text">3.1 基本用法：等待全部完成并收集错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BB%93%E5%90%88-Context-%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%97%B6%E5%8F%96%E6%B6%88"><span class="toc-text">3.2 结合 Context 实现及时取消</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0-%E5%8F%AF%E9%80%89"><span class="toc-text">3.3 限制并发数 (可选)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81errgroup-Group-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">四、errgroup.Group 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">4.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">4.2 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81errgroup-Group-%E5%AF%B9%E6%AF%94-sync-WaitGroup-%E5%92%8C-context-WithCancel"><span class="toc-text">五、errgroup.Group 对比 sync.WaitGroup 和 context.WithCancel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">六、安全性考虑与最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>