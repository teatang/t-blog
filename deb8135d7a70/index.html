<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NAT 类型详解与穿越机制 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我">
<meta property="og:type" content="article">
<meta property="og:title" content="NAT 类型详解与穿越机制">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/deb8135d7a70/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg">
<meta property="article:published_time" content="2024-02-12T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:29:10.726Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="NAT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "NAT 类型详解与穿越机制",
  "url": "https://blog.tbf1211.xx.kg/deb8135d7a70/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg",
  "datePublished": "2024-02-12T22:24:00.000Z",
  "dateModified": "2026-02-01T09:29:10.726Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/deb8135d7a70/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NAT 类型详解与穿越机制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-13.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">NAT 类型详解与穿越机制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">NAT 类型详解与穿越机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-02-12T22:24:00.000Z" title="发表于 2024-02-13 06:24:00">2024-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>NAT (Network Address Translation)</strong> 是一种在 IP 数据包通过路由器或防火墙时，<strong>修改 IP 地址信息 (通常是 IP 地址和端口号)</strong> 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。</p>
</blockquote>
<div class="note info flat"><p>通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。</p>
</div>
<hr>
<h2 id="一、NAT-的基本概念与作用"><a href="#一、NAT-的基本概念与作用" class="headerlink" title="一、NAT 的基本概念与作用"></a>一、NAT 的基本概念与作用</h2><p><strong>基本概念：</strong> NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。</p>
<p><strong>主要作用：</strong></p>
<ol>
<li><strong>缓解 IPv4 地址枯竭</strong>：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。</li>
<li><strong>隐藏内部网络拓扑</strong>：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，增加了一定的安全性。</li>
<li><strong>连接外部网络</strong>：内部设备可以通过 NAT 访问外部互联网资源。</li>
</ol>
<h2 id="二、NAT-的核心挑战：P2P-通信"><a href="#二、NAT-的核心挑战：P2P-通信" class="headerlink" title="二、NAT 的核心挑战：P2P 通信"></a>二、NAT 的核心挑战：P2P 通信</h2><p>虽然 NAT 带来了诸多便利，但对需要直接通信的 P2P 应用（如 VoIP、视频会议、在线游戏、文件共享）而言，却是巨大的障碍。主要原因如下：</p>
<ul>
<li><strong>地址翻译</strong>：外部设备无法直接通过私有 IP 地址定位到内网设备。</li>
<li><strong>不请自来连接的困难</strong>：NAT 设备通常只会转发“已建立连接”或“由内网主动发起”的流量。外部设备主动发起的请求，如果没有预先的映射或打洞，通常会被 NAT 丢弃。</li>
<li><strong>NAT 类型多样性</strong>：不同 NAT 设备对流量的转发规则差异很大，导致 NAT 穿越的复杂性增加。</li>
</ul>
<h2 id="三、NAT-类型详解"><a href="#三、NAT-类型详解" class="headerlink" title="三、NAT 类型详解"></a>三、NAT 类型详解</h2><p>RFC 3489 和后续的 RFC 5780 (更新) 定义了不同类型的 NAT，这些类型决定了 NAT 穿越的难易程度。主要分为四种：</p>
<h3 id="3-1-全锥型-NAT-Full-Cone-NAT"><a href="#3-1-全锥型-NAT-Full-Cone-NAT" class="headerlink" title="3.1 全锥型 NAT (Full Cone NAT)"></a>3.1 全锥型 NAT (Full Cone NAT)</h3><ul>
<li><strong>定义</strong>：一旦内部 IP 地址 (Internal IP) 和端口 (Internal Port) 映射到外部 IP 地址 (External IP) 和端口 (External Port) 后，任何外部主机都可以向这个外部 IP:端口发送数据包，并被 NAT 设备转发到内部主机。原始请求的源地址和端口对后续通信没有影响。</li>
<li><strong>行为特征</strong>：<ul>
<li><strong>映射行为</strong>：内部私有 IP:端口 A 总是映射到相同的外部公网 IP:端口 B。</li>
<li><strong>过滤行为</strong>：当有数据包从外部流向内部映射端口 B 时，NAT 不会关心是谁发送的，只要目标是 B，就转发给 A。</li>
</ul>
</li>
<li><strong>P2P 友好度</strong>：<strong>最友好</strong>。一旦打洞成功，任何外部客户端都可以与之通信。</li>
<li><strong>穿越难度</strong>：<strong>最简单</strong>。STUN 协议可以轻松应对。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内网客户端 A (192.168.1.10:5000)</span><br><span class="line">    ↓ 发送数据到 公网主机 X (203.0.113.1:80)</span><br><span class="line">NAT 设备 (公网 IP: 203.0.113.1)</span><br><span class="line">    ↓ 映射：192.168.1.10:5000 -&gt; 203.0.113.1:PortX (映射固定)</span><br><span class="line">公网主机 X (203.0.113.1:80)</span><br><span class="line">    ↓ 接收数据</span><br><span class="line">==========</span><br><span class="line">现在，任何公网主机 (如 Y: 198.51.100.1:80)</span><br><span class="line">    ↓ 都可以发送数据到 203.0.113.1:PortX</span><br><span class="line">NAT 设备</span><br><span class="line">    ↓ 将数据转发给 192.168.1.10:5000</span><br><span class="line">内网客户端 A (192.168.1.10:5000)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-地址限制锥型-NAT-Address-Restricted-Cone-NAT"><a href="#3-2-地址限制锥型-NAT-Address-Restricted-Cone-NAT" class="headerlink" title="3.2 地址限制锥型 NAT (Address-Restricted Cone NAT)"></a>3.2 地址限制锥型 NAT (Address-Restricted Cone NAT)</h3><ul>
<li><strong>定义</strong>：一旦内部 IP:端口映射到外部 IP:端口，只有当内部主机已经向某个<strong>外部主机 IP</strong> 发送过数据包后，该外部主机才能向这个外部 IP:端口发送数据包，并被转发。外部主机的<strong>端口号</strong>不影响转发。</li>
<li><strong>行为特征</strong>：<ul>
<li><strong>映射行为</strong>：内部私有 IP:端口 A 总是映射到相同的外部公网 IP:端口 B。</li>
<li><strong>过滤行为</strong>：当有数据包从外部流向内部映射端口 B 时，NAT 会检查数据包的<strong>源 IP 地址</strong>。如果内部主机之前曾向这个源 IP 发送过数据包，则转发；否则丢弃。</li>
</ul>
</li>
<li><strong>P2P 友好度</strong>：<strong>中等友好</strong>。需要先由内部客户端发起一次通信才能打洞。</li>
<li><strong>穿越难度</strong>：<strong>中等</strong>。STUN 协议可以应对，但需要多次探测。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内网客户端 A (192.168.1.10:5000)</span><br><span class="line">    ↓ 发送数据到 公网主机 X (203.0.113.1:P1)</span><br><span class="line">NAT 设备 (公网 IP: 203.0.113.1)</span><br><span class="line">    ↓ 映射：192.168.1.10:5000 -&gt; 203.0.113.1:PortX (映射固定)</span><br><span class="line">公网主机 X (203.0.113.1:P1)</span><br><span class="line">    ↓ 接收数据</span><br><span class="line">==========</span><br><span class="line">现在，公网主机 X (203.0.113.1:P2，P2可变)</span><br><span class="line">    ↓ 可以发送数据到 203.0.113.1:PortX</span><br><span class="line">NAT 设备</span><br><span class="line">    ↓ 将数据转发给 192.168.1.10:5000 (因为源 IP 203.0.113.1 已被 &quot;允许&quot;)</span><br><span class="line">内网客户端 A (192.168.1.10:5000)</span><br><span class="line"></span><br><span class="line">但如果公网主机 Y (198.51.100.1:80) 发送数据到 203.0.113.1:PortX，将被 NAT 丢弃，因为 A 从未主动向 Y 发送过数据。</span><br></pre></td></tr></table></figure>

<h3 id="3-3-端口限制锥型-NAT-Port-Restricted-Cone-NAT"><a href="#3-3-端口限制锥型-NAT-Port-Restricted-Cone-NAT" class="headerlink" title="3.3 端口限制锥型 NAT (Port-Restricted Cone NAT)"></a>3.3 端口限制锥型 NAT (Port-Restricted Cone NAT)</h3><ul>
<li><strong>定义</strong>：比地址限制型更严格。只有当内部主机已经向某个<strong>外部主机 IP 和端口</strong>发送过数据包后，且外部主机从该<strong>特定源 IP 和源端口</strong>发送数据包时，才能被 NAT 转发。</li>
<li><strong>行为特征</strong>：<ul>
<li><strong>映射行为</strong>：内部私有 IP:端口 A 总是映射到相同的外部公网 IP:端口 B。</li>
<li><strong>过滤行为</strong>：当有数据包从外部流向内部映射端口 B 时，NAT 会严格检查数据包的<strong>源 IP 地址和源端口</strong>。只有当内部主机之前曾向这个特定的源 IP 和源端口发送过数据包，才转发；否则丢弃。</li>
</ul>
</li>
<li><strong>P2P 友好度</strong>：<strong>较低</strong>。需要严格匹配源 IP 和端口才能打洞。</li>
<li><strong>穿越难度</strong>：<strong>较高</strong>。STUN 协议可以应对，但打洞成功率取决于双方 NAT 类型组合。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">内网客户端 A (192.168.1.10:5000)</span><br><span class="line">    ↓ 发送数据到 公网主机 X (203.0.113.1:P1)</span><br><span class="line">NAT 设备 (公网 IP: 203.0.113.1)</span><br><span class="line">    ↓ 映射：192.168.1.10:5000 -&gt; 203.0.113.1:PortX (映射固定)</span><br><span class="line">公网主机 X (203.0.113.1:P1)</span><br><span class="line">    ↓ 接收数据</span><br><span class="line">==========</span><br><span class="line">现在，公网主机 X (203.0.113.1:P1)</span><br><span class="line">    ↓ 可以发送数据到 203.0.113.1:PortX</span><br><span class="line">NAT 设备</span><br><span class="line">    ↓ 将数据转发给 192.168.1.10:5000 (因为源 IP:Port 203.0.113.1:P1 已被 &quot;允许&quot;)</span><br><span class="line">内网客户端 A (192.168.1.10:5000)</span><br><span class="line"></span><br><span class="line">如果公网主机 X (203.0.113.1:P2，P2与P1不同) 发送数据到 203.0.113.1:PortX，将被 NAT 丢弃。</span><br><span class="line">如果公网主机 Y (198.51.100.1:80) 发送数据到 203.0.113.1:PortX，也将被 NAT 丢弃。</span><br></pre></td></tr></table></figure>

<h3 id="3-4-对称型-NAT-Symmetric-NAT"><a href="#3-4-对称型-NAT-Symmetric-NAT" class="headerlink" title="3.4 对称型 NAT (Symmetric NAT)"></a>3.4 对称型 NAT (Symmetric NAT)</h3><ul>
<li><strong>定义</strong>：每次内部主机向<strong>不同的目标 IP 地址或目标端口</strong>发送数据包时，NAT 设备都会为其分配<strong>一个新的外部端口</strong>进行通信。</li>
<li><strong>行为特征</strong>：<ul>
<li><strong>映射行为</strong>：<ul>
<li>内部 IP1:Port1 -&gt; 外部 IPX:PortA (目标 TgtIP1:TgtPort1)</li>
<li>内部 IP1:Port1 -&gt; 外部 IPX:PortB (目标 TgtIP1:TgtPort2) (PortB !&#x3D; PortA)</li>
<li>内部 IP1:Port1 -&gt; 外部 IPX:PortC (目标 TgtIP2:TgtPort1) (PortC !&#x3D; PortA, PortC !&#x3D; PortB)</li>
<li>总之，外部端口号取决于目标地址和端口。</li>
</ul>
</li>
<li><strong>过滤行为</strong>：与端口限制型 NAT 类似，只转发来自之前内部主机已与之通信过的特定源 IP 和源端口的数据包。</li>
</ul>
</li>
<li><strong>P2P 友好度</strong>：<strong>最不友好</strong>。外部端口不固定，无法预测。</li>
<li><strong>穿越难度</strong>：<strong>最高</strong>。STUN 协议无法有效穿透，通常需要 TURN 服务器中继。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">内网客户端 A (192.168.1.10:5000)</span><br><span class="line">    ↓ 发送数据到 公网主机 X (203.0.113.1:P1)</span><br><span class="line">NAT 设备 (公网 IP: 203.0.113.1)</span><br><span class="line">    ↓ 映射：192.168.1.10:5000 -&gt; 203.0.113.1:PortX (针对 X:P1)</span><br><span class="line">公网主机 X (203.0.113.1:P1)</span><br><span class="line">    ↓ 接收数据</span><br><span class="line">==========</span><br><span class="line">内网客户端 A (192.168.1.10:5000)</span><br><span class="line">    ↓ 发送数据到 公网主机 Y (198.51.100.1:P2)</span><br><span class="line">NAT 设备 (公网 IP: 203.0.113.1)</span><br><span class="line">    ↓ 映射：192.168.1.10:5000 -&gt; 203.0.113.1:PortY (针对 Y:P2，PortY != PortX)</span><br><span class="line">公网主机 Y (198.51.100.1:P2)</span><br><span class="line">    ↓ 接收数据</span><br><span class="line">==========</span><br><span class="line">此时，即使公网主机 X 想要向 203.0.113.1:PortX 发送数据，也可能无法成功，因为 PortX 只是针对 X:P1 的映射。如果 X 的源端口发生变化，或者 A 再次向 X 发送数据时，NAT 可能会使用一个全新的外部端口。</span><br></pre></td></tr></table></figure>

<h3 id="3-5-运营商级-NAT-Carrier-Grade-NAT-CGN"><a href="#3-5-运营商级-NAT-Carrier-Grade-NAT-CGN" class="headerlink" title="3.5 运营商级 NAT (Carrier-Grade NAT &#x2F; CGN)"></a>3.5 运营商级 NAT (Carrier-Grade NAT &#x2F; CGN)</h3><ul>
<li><strong>特殊情况</strong>：这是一种特殊的 NAT 实现，通常由 ISP (互联网服务提供商) 在其网络内部部署，为多个用户提供私有 IP 地址，然后这些私有 IP 地址再通过另一层 NAT 映射到 ISP 的公网 IP 地址。</li>
<li><strong>多层 NAT</strong>：本质上就是<strong>多层 NAT</strong>。客户端可能位于两层甚至更多层 NAT 之后。</li>
<li><strong>P2P 影响</strong>：使得 NAT 穿越变得异常困难，因为需要穿越多层 NAT，每一层 NAT 都可能增加额外的限制。大多数 P2P 直连在 CGN 环境下都会失败，往往需要 TURN 服务器进行中继。</li>
</ul>
<h2 id="四、如何判断-NAT-类型？"><a href="#四、如何判断-NAT-类型？" class="headerlink" title="四、如何判断 NAT 类型？"></a>四、如何判断 NAT 类型？</h2><p>通常使用 STUN 协议来判断 NAT 类型。STUN 客户端通过向 STUN 服务器发送一系列精心设计的请求，并分析服务器的响应以及从不同源地址&#x2F;端口发来的数据包，来推断出它所处的 NAT 类型。</p>
<p><strong>简化流程：</strong></p>
<ol>
<li>客户端向 STUN 服务器发送请求，获取自身公网地址 (External IP:Port A)。</li>
<li>客户端向 STUN 服务器的<strong>不同端口</strong>发送请求，如果获取到不同的公网地址 (External IP:Port B !&#x3D; External IP:Port A)，则为对称型 NAT。</li>
<li>如果不是对称型 NAT，STUN 服务器尝试从<strong>不同源 IP</strong> 向客户端的 External IP:Port A 发送数据。如果能收到，则为全锥型 NAT。</li>
<li>如果收不到，STUN 服务器尝试从<strong>相同源 IP 不同源端口</strong>向客户端的 External IP:Port A 发送数据。如果能收到，则为地址限制锥型 NAT。</li>
<li>如果收不到，则为端口限制锥型 NAT。</li>
</ol>
<h2 id="五、NAT-穿越机制"><a href="#五、NAT-穿越机制" class="headerlink" title="五、NAT 穿越机制"></a>五、NAT 穿越机制</h2><p>根据 NAT 类型的不同，我们采取不同的穿越策略：</p>
<ol>
<li><p><strong>UDP 打洞 (UDP Hole Punching)</strong>：</p>
<ul>
<li><strong>原理</strong>：在对称型 NAT 之外的锥型 NAT 中有效。客户端首先向 STUN 服务器或对方客户端发送 UDP 数据包，让自己的 NAT 打开一个临时的打洞映射。然后，即使对方的 NAT 也在类似锥型 NAT 之后，也可以尝试直接向这个打通的洞发送数据进行连接。</li>
<li><strong>适用类型</strong>：全锥型、地址限制锥型、端口限制锥型 NAT。</li>
<li><strong>技术</strong>：主要依赖 STUN 协议获取公网地址和 NAT 类型，然后尝试直接连接。</li>
</ul>
</li>
<li><p><strong>TCP 打洞 (TCP Hole Punching)</strong>：</p>
<ul>
<li><strong>原理</strong>：比 UDP 打洞复杂得多，因为 TCP 是面向连接的，需要三次握手。但基本思想类似，通过同时发送 SYN 包来“猜测”并打开一个临时的连接。</li>
<li><strong>适用类型</strong>：锥型 NAT，成功率不如 UDP。</li>
</ul>
</li>
<li><p><strong>中继 (Relaying)</strong>：</p>
<ul>
<li><strong>原理</strong>：当打洞无法成功时 (最常见于对称型 NAT 或多层 NAT)，引入一个第三方服务器 (TURN 服务器) 作为中继，转发两个客户端之间的所有数据。</li>
<li><strong>适用类型</strong>：所有 NAT 类型，尤其是对称型 NAT 和 CGN。</li>
<li><strong>代价</strong>：增加网络延迟和服务器负载。</li>
<li><strong>技术</strong>：主要依赖 TURN 协议。</li>
</ul>
</li>
<li><p><strong>端口映射 (Port Mapping Protocols)</strong>：</p>
<ul>
<li><strong>原理</strong>：通过在内网路由器上配置端口映射规则，将内部端口映射到外部的特定端口，使其对外部可见。</li>
<li><strong>技术</strong>：UPnP (Universal Plug and Play) IGD (Internet Gateway Device) 和 NAT-PMP (NAT Port Mapping Protocol)。这些协议允许内网应用程序自动请求 NAT 设备进行端口映射。</li>
<li><strong>限制</strong>：需要路由器支持并启用这些功能，且存在一定的安全风险。</li>
</ul>
</li>
<li><p><strong>ICE (Interactive Connectivity Establishment)</strong>：</p>
<ul>
<li><strong>原理</strong>：一个综合性的 NAT 穿越框架。它结合了 STUN、TURN 和其他打洞技术，通过收集所有可能的通信路径 (候选地址)，然后进行连通性检查，并最终选择最佳的连接路径。</li>
<li><strong>适用类型</strong>：所有复杂场景。</li>
<li><strong>地位</strong>：WebRTC 等现代 P2P 通信技术中必不可少的组件。</li>
</ul>
</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>NAT 类型是理解和实现 P2P 通信的关键。从最开放的<strong>全锥型 NAT</strong> 到最严格的<strong>对称型 NAT</strong>，以及复杂的<strong>运营商级 NAT</strong>，它们对网络数据包的转发行为各不相同。针对不同的 NAT 类型，我们需要采取相应的 NAT 穿越策略，从简单的 UDP 打洞 (STUN) 到复杂的媒体中继 (TURN) 和智能路径选择 (ICE)，以确保 P2P 通信的<strong>连通性、效率和可靠性</strong>。深入理解这些机制对于开发稳定且高性能的实时通信应用至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/deb8135d7a70/">https://blog.tbf1211.xx.kg/deb8135d7a70/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/NAT/">NAT</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/25324aef0ab0/" title="Git Merge vs. Rebase 对比详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git Merge vs. Rebase 对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Git 版本控制系统中，git merge 和 git rebase 是两种常用的代码集成命令，它们都用于将一个分支的更改合并到另一个分支。尽管目的相同，但它们实现这一目标的方式截然不同，对项目的历史记录产生的影响也大相径庭。理解这两种策略的优缺点及适用场景，对于维护清晰、可追溯的 Git 历史以及高效的团队协作至关重要。  核心思想：git merge 通过创建新的合并提交来集成更改，保留了所有分支的历史；git rebase 通过重写提交历史将一个分支的提交应用到另一个分支的顶部，从而创建线性的历史记录。   一、Git Merge (合并)1.1 定义git merge 命令用于将来自一个或多个分支的独立开发历史合并到当前分支。它通过创建一个新的合并提交 (merge commit) 来实现这一点，这个合并提交的父提交指向两个被合并分支的最新提交。这意味着 git merge 会保留所有分支的原始提交历史，并显式地记录合并发生的时间和地点。 1.2 工作原理当执行 git merge &lt;branch_name&gt; 时：  Git 找到当前分支 (HEAD) ...</div></div></div></a><a class="pagination-related" href="/0f6de86a0220/" title="STUN (Session Traversal Utilities for NAT) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">STUN (Session Traversal Utilities for NAT) 详解</div></div><div class="info-2"><div class="info-item-1"> STUN (Session Traversal Utilities for NAT)，即 NAT 会话穿越工具，是一种网络协议，它允许位于NAT (Network Address Translation，网络地址转换) 设备之后的客户端发现其外部（公共）IP 地址和端口号，以及 NAT 设备的类型。STUN 的主要目的是协助建立对等连接 (P2P)，尤其是在 VoIP、视频会议和 WebRTC 等实时通信应用中。  核心思想：帮助内网主机探测 NAT 类型和获取公网 IP:Port，为 P2P 连接做准备。   一、为什么需要 STUN？现代互联网中，IPv4 地址资源日益枯竭，导致大多数终端设备都部署在 NAT 设备（如路由器）之后。NAT 设备通过将内部私有 IP 地址映射到外部公共 IP 地址和端口，允许多个内部设备共享一个公共 IP 地址访问互联网。 然而，NAT 给直接的点对点 (P2P) 通信带来了巨大的挑战：  内网 IP 地址不可路由：内部私有 IP 地址在公共互联网上是不可见的，外部设备无法直接通过私有 IP 地址联系到内部设备。 端口映射不确定：NAT 设备...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ba096d7d0780/" title="虚拟局域网 (VLAN) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="info-item-2">虚拟局域网 (VLAN) 详解</div></div><div class="info-2"><div class="info-item-1"> 虚拟局域网 (VLAN - Virtual Local Area Network) 是一种在物理上共享同一网络基础设施（如交换机、网线）的局域网中，通过逻辑划分而不是物理划分来创建多个独立广播域的技术。它允许网络管理员将一个物理局域网划分成多个逻辑上独立的网络，每个 VLAN 都是一个独立的广播域。VLAN 技术是现代企业网络设计中不可或缺的组成部分，它极大地增强了网络的安全性、性能、灵活性和可管理性。  核心思想：在不改变物理连接的情况下，将一个物理交换机划分出多个逻辑隔离的广播域，实现设备间的逻辑分段通信。   一、什么是 VLAN？在传统的以太网中，所有连接到同一个交换机或集线器的设备都属于同一个广播域 (Broadcast Domain)。这意味着当任何一台设备发送一个广播帧（例如 ARP 请求），这个广播帧会到达该域内的所有其他设备。随着网络规模的扩大，广播流量会显著增加，导致网络性能下降并带来安全隐患。 VLAN 技术应运而生，它通过在数据链路层（OSI 模型第二层）对以太网帧进行标识和处理，从而实现：  逻辑隔离：即使设备物理上连接在同一台交换机上，如果它们属于不...</div></div></div></a><a class="pagination-related" href="/eae983954311/" title="NAT (Network Address Translation) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-03</div><div class="info-item-2">NAT (Network Address Translation) 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是一种在 IP 数据包通过路由器或防火墙时，修改其 IP 地址信息（有时也包括端口号）的技术。NAT 是 IPv4 时代的核心网络技术之一，它在缓解 IPv4 地址枯竭和提高内部网络安全性方面发挥了不可或缺的作用。  核心思想：NAT 允许一个拥有私有 IP 地址的内部网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信，从而实现地址共享和隐藏内部拓扑。    一、NAT 的背景与重要性1.1 IPv4 地址枯竭原始的 IPv4 地址空间大约为 40 亿个地址。随着互联网和智能设备的普及，全球对 IP 地址的需求爆炸式增长，远超 IPv4 的设计容量。NAT 的出现使得多个设备可以共享一个公有 IP 地址，极大地延缓了 IPv4 地址耗尽的速度。 1.2 网络安全考量通过 NAT，内部网络的私有 IP 地址空间对外部网络是不可见的。外部攻击者无法直接访问内部主机，因为他们只看到 NAT 设备的公共 IP 地址。这为内部网络提供了一层基本的安全屏障。 1.3 灵活的网络设计NAT 允许企业和...</div></div></div></a><a class="pagination-related" href="/b8edc2276249/" title="雪花算法 (Snowflake Algorithm) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-19</div><div class="info-item-2">雪花算法 (Snowflake Algorithm) 详解</div></div><div class="info-2"><div class="info-item-1"> 雪花算法 (Snowflake Algorithm) 是 Twitter 公司开源的一种分布式唯一 ID 生成算法。它旨在解决在分布式系统中生成全局唯一、递增（但非严格递增）且高性能 ID 的需求。其生成的 ID 是一个 64 位的整数，具有时间有序性，并且不依赖于数据库，易于扩展。  核心思想：将 64 位的 Long 型 ID 拆分为多个字段，分别存储时间戳、数据中心 ID、机器 ID 和序列号，通过位运算拼接以保证全局唯一性和大致的时间有序性。   一、为什么需要雪花算法？在分布式系统中，传统的单点自增 ID 方案面临巨大挑战：  唯一性问题：不同的数据库实例或服务节点可能生成相同的 ID。 性能瓶颈：为了保证唯一性，可能需要引入中心化的 ID 生成服务或数据库锁，成为系统瓶颈。 可用性问题：中心化服务一旦宕机，整个系统的 ID 生成将受影响。  虽然 UUID 能够保证全局唯一性，但它存在一些缺点：  存储和传输效率低：128 位，比 64 位 ID 更占用空间，索引性能较差。 无序性：UUID 是无序的，插入数据库时会导致 B+ 树索引频繁分裂和重建，影响数据库性能。...</div></div></div></a><a class="pagination-related" href="/45a8b220c3e8/" title="中国移动 CMI 网络详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-18</div><div class="info-item-2">中国移动 CMI 网络详解</div></div><div class="info-2"><div class="info-item-1"> CMI (China Mobile International)，即中国移动国际网络，是中国移动的国际出口骨干网络。与中国电信的 CN2 和中国联通的 AS4837&#x2F;AS9929 类似，CMI 专注于提供中国移动用户的高质量国际互联服务。它随着中国移动国际业务的扩张而迅速发展，成为连接中国大陆与全球各地的重要网络基础设施之一。  核心思想：CMI 是中国移动为提升其用户国际访问体验而建立的国际骨干网络。它通过建设自有海缆和海外节点，提供相对稳定、大带宽的国际互联通道。   一、为什么需要 CMI？1.1 中国移动网络的挑战在早期的国际互联方面，中国移动（China Mobile）主要依靠租用其他运营商的国际出口带宽，或者将流量转接到中国电信或中国联通的网络进行国际互联。这种方式存在一些固有的问题：  网络质量不稳定：路由路径通常较长，经过的中间运营商和节点多，导致延迟高、丢包率大。 带宽不足：租用带宽的成本和可用性限制，使得在国际流量高峰期容易出现拥堵。 服务不可控：缺乏对国际链路的端到端控制，难以保证服务质量 (QoS)。 成本高昂：长期租用国际带宽的成本较高。  ...</div></div></div></a><a class="pagination-related" href="/da4a047de713/" title="中国电信 CN2 网络详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="info-item-2">中国电信 CN2 网络详解</div></div><div class="info-2"><div class="info-item-1"> CN2 (ChinaNet Next Generation Carrying Network)，即中国电信下一代承载网络，是中国电信于 2005 年推出的新一代骨干网络。它旨在提供高质量、高可靠、低延迟的网络服务，主要面向政府、企业和高端个人用户。CN2 与传统的 ChinaNet (AS4134，163骨干网) 在架构和技术上都有显著区别，以提供更优质的国际互联体验。  核心思想：将互联网流量分为“优质”和“普通”两类通道，CN2 提供优质通道，通过更少的跳数、更小的丢包率和更低的延迟，显著提升国际互联的稳定性和速度。   一、为什么需要 CN2？1.1 ChinaNet (163骨干网) 的局限性传统的中国电信互联网骨干网，通常被称为 163 网（因其 AS 号为 4134，而 163 是其常用接入号），是国内用户最广泛使用的网络。然而，163 网在国际互联方面存在一些固有的问题：  链路拥堵：作为最常用的骨干网，163 网承载了大量流量，尤其在国际出口处容易出现拥堵，导致延迟高、丢包率大。 路由跳数多：在国际互联时，163 网的路由路径通常较长，经过的中间节点和运营商较多...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81NAT-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-text">一、NAT 的基本概念与作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81NAT-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98%EF%BC%9AP2P-%E9%80%9A%E4%BF%A1"><span class="toc-text">二、NAT 的核心挑战：P2P 通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81NAT-%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">三、NAT 类型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%85%A8%E9%94%A5%E5%9E%8B-NAT-Full-Cone-NAT"><span class="toc-text">3.1 全锥型 NAT (Full Cone NAT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%9C%B0%E5%9D%80%E9%99%90%E5%88%B6%E9%94%A5%E5%9E%8B-NAT-Address-Restricted-Cone-NAT"><span class="toc-text">3.2 地址限制锥型 NAT (Address-Restricted Cone NAT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%AB%AF%E5%8F%A3%E9%99%90%E5%88%B6%E9%94%A5%E5%9E%8B-NAT-Port-Restricted-Cone-NAT"><span class="toc-text">3.3 端口限制锥型 NAT (Port-Restricted Cone NAT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AF%B9%E7%A7%B0%E5%9E%8B-NAT-Symmetric-NAT"><span class="toc-text">3.4 对称型 NAT (Symmetric NAT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%BF%90%E8%90%A5%E5%95%86%E7%BA%A7-NAT-Carrier-Grade-NAT-CGN"><span class="toc-text">3.5 运营商级 NAT (Carrier-Grade NAT &#x2F; CGN)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-NAT-%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">四、如何判断 NAT 类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81NAT-%E7%A9%BF%E8%B6%8A%E6%9C%BA%E5%88%B6"><span class="toc-text">五、NAT 穿越机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-13.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>