<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>HTTP/3 协议深度详解：构建更快、更可靠的未来 Web | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP&#x2F;3 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 QUIC (Quick UDP Internet Connections) 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/6479020306f5/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="HTTP&#x2F;3 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 QUIC (Quick UDP Internet Connections) 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-23.jpg">
<meta property="article:published_time" content="2023-03-25T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-27T11:54:24.661Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="HTTP">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-23.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HTTP/3 协议深度详解：构建更快、更可靠的未来 Web",
  "url": "https://blog.tbf1211.xx.kg/6479020306f5/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-23.jpg",
  "datePublished": "2023-03-25T22:24:00.000Z",
  "dateModified": "2025-12-27T11:54:24.661Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/6479020306f5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HTTP/3 协议深度详解：构建更快、更可靠的未来 Web',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">438</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">224</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-23.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">HTTP/3 协议深度详解：构建更快、更可靠的未来 Web</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">HTTP/3 协议深度详解：构建更快、更可靠的未来 Web</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-25T22:24:00.000Z" title="发表于 2023-03-26 06:24:00">2023-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>HTTP&#x2F;3</strong> 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 <strong>QUIC (Quick UDP Internet Connections)</strong> 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全性及在复杂网络环境下的韧性，从而彻底改变 Web 资源的传输方式。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：HTTP&#x2F;3 运行在 <strong>QUIC</strong> 协议之上，而 QUIC 又运行在 <strong>UDP</strong> 协议之上。通过在传输层而非应用层引入多路复用、内置 TLS 1.3 加密、连接迁移等特性，HTTP&#x2F;3 提供了一个比 HTTP&#x2F;2 更快、更稳定、更安全的 Web 体验，尤其在移动网络和有损网络环境下表现突出。</p>
</div>
<hr>
<h2 id="一、HTTP-2-的局限性与-HTTP-3-的出现背景"><a href="#一、HTTP-2-的局限性与-HTTP-3-的出现背景" class="headerlink" title="一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景"></a>一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景</h2><p>HTTP&#x2F;2 作为 HTTP&#x2F;1.1 的继任者，通过头部压缩、多路复用和服务器推送等机制，显著提升了 Web 性能。然而，HTTP&#x2F;2 依然存在一个固有的瓶颈：</p>
<ol>
<li><strong>底层 TCP 的队头阻塞 (Head-of-Line Blocking at TCP Layer)</strong>：<ul>
<li>HTTP&#x2F;2 的多路复用是在应用层实现的，所有的 HTTP 流都共享同一个 TCP 连接。</li>
<li>虽然应用层帧的传输可以交错，但如果底层 TCP 连接上的<strong>任何一个数据包丢失</strong>，TCP 协议会触发重传机制。</li>
<li>由于 TCP 无法区分这些丢失的包属于哪个 HTTP 流，它会暂停<strong>整个 TCP 连接上所有流</strong>的数据传输，直到丢失的包被成功重传并按序确认。这就是所谓的“底层 TCP 的队头阻塞”。即使其他 HTTP 流的数据已经到达并被应用层处理完成，它们也必须等待那个丢失的包。</li>
<li>在 Wi-Fi 和移动网络等丢包率较高的环境下，这种 TCP 层面的队头阻塞会严重拖慢页面加载速度。</li>
</ul>
</li>
<li><strong>TCP 连接建立的延迟 (RTT 往返时间)</strong>：<ul>
<li>传统的 TCP 连接建立需要 3 次握手，之后再进行 TLS 握手（如果使用 HTTPS）通常需要额外的 2-3 次往返，总共可能需要 2-3 个 RTT 才能开始传输应用数据。这带来了显著的启动延迟。</li>
</ul>
</li>
<li><strong>连接迁移困难</strong>：<ul>
<li>当客户端的网络环境发生变化（如从 Wi-Fi 切换到移动数据），设备的 IP 地址会改变。传统的 TCP 连接是与 IP 地址和端口号强绑定的，IP 地址改变意味着 TCP 连接必须断开并重新建立。这会导致正在进行的传输中断，用户体验受损。</li>
</ul>
</li>
</ol>
<p>为了彻底解决这些问题，HTTP&#x2F;3 应运而生，它选择了全新的传输协议 <strong>QUIC</strong>。</p>
<h2 id="二、QUIC-协议的核心特性-HTTP-3-的基石"><a href="#二、QUIC-协议的核心特性-HTTP-3-的基石" class="headerlink" title="二、QUIC 协议的核心特性 (HTTP&#x2F;3 的基石)"></a>二、QUIC 协议的核心特性 (HTTP&#x2F;3 的基石)</h2><p>QUIC (Quick UDP Internet Connections) 是 HTTP&#x2F;3 的底层传输协议。它由 Google 开发，旨在重构传输层，将原本在 TCP 和 TLS 层实现的功能迁移到 UDP 之上，并加以改进。</p>
<h3 id="2-1-1-基于-UDP：摆脱-TCP-的束缚"><a href="#2-1-1-基于-UDP：摆脱-TCP-的束缚" class="headerlink" title="2.1 1. 基于 UDP：摆脱 TCP 的束缚"></a>2.1 1. 基于 UDP：摆脱 TCP 的束缚</h3><ul>
<li>QUIC 协议运行在 UDP 之上，而不是 TCP。UDP 是一个无连接、不可靠的传输协议，但 QUIC 在 UDP 之上自己实现了可靠传输、拥塞控制、流控等机制。</li>
<li><strong>优势</strong>：<ul>
<li><strong>规避操作系统内核限制</strong>：TCP 协议栈通常在操作系统内核中实现，更新和部署缓慢。QUIC 在应用层实现，更易于快速迭代和部署。</li>
<li><strong>独立处理流</strong>：UDP 是无序的，QUIC 可以自行管理流的排序和重传，避免了 TCP 的队头阻塞。</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-原生多路复用-Multiplexing"><a href="#2-2-2-原生多路复用-Multiplexing" class="headerlink" title="2.2 2. 原生多路复用 (Multiplexing)"></a>2.2 2. 原生多路复用 (Multiplexing)</h3><ul>
<li>与 HTTP&#x2F;2 在应用层实现多路复用不同，QUIC 在传输层就原生支持多路复用。每个 HTTP 流都有独立的序号空间。</li>
<li><strong>核心优势</strong>：<ul>
<li><strong>彻底消除底层队头阻塞</strong>：如果一个流的数据包丢失，只有该流的数据会被暂停重传，其他流的数据可以继续传输，不会受到影响。这一点是 HTTP&#x2F;3 相较于 HTTP&#x2F;2 的最大性能提升。</li>
</ul>
</li>
</ul>
<h3 id="2-3-3-0-RTT-1-RTT-连接建立-Fast-Connection-Setup"><a href="#2-3-3-0-RTT-1-RTT-连接建立-Fast-Connection-Setup" class="headerlink" title="2.3 3. 0-RTT&#x2F;1-RTT 连接建立 (Fast Connection Setup)"></a>2.3 3. 0-RTT&#x2F;1-RTT 连接建立 (Fast Connection Setup)</h3><p>QUIC 整合了握手和加密过程，大幅减少了连接建立的延迟：</p>
<ul>
<li><strong>首次连接 (1-RTT)</strong>：在客户端第一次连接服务器时，完成加密握手和传输层握手只需要一个 RTT。这比 TCP + TLS 的 2-3 个 RTT 更快。服务器在响应中发送必要的信息，供客户端缓存。</li>
<li><strong>后续连接 (0-RTT)</strong>：如果客户端之前连接过服务器，并缓存了会话信息（如加密密钥和协议配置），则在建立连接时可以在<strong>第一个数据包</strong>中就发送应用数据（0-RTT），几乎消除了连接建立的延迟。这对于移动应用和频繁的短连接尤其重要。</li>
<li><strong>优势</strong>：大幅减少了用户等待时间，特别是在高延迟或移动网络环境下。</li>
</ul>
<h3 id="2-4-4-内置-TLS-1-3-加密-Always-on-Security"><a href="#2-4-4-内置-TLS-1-3-加密-Always-on-Security" class="headerlink" title="2.4 4. 内置 TLS 1.3 加密 (Always-on Security)"></a>2.4 4. 内置 TLS 1.3 加密 (Always-on Security)</h3><ul>
<li>QUIC 在设计之初就强制使用 TLS 1.3 进行加密。所有的 QUIC 连接都是加密的，包括握手信息。</li>
<li><strong>优势</strong>：<ul>
<li><strong>安全性更高</strong>：默认加密，防止中间人攻击、嗅探和协议降级攻击。</li>
<li><strong>简化协议栈</strong>：TCP + TLS 需要两层独立的握手，QUIC 将其合并。</li>
<li><strong>抗头部注入</strong>：不像 HTTP&#x2F;1.1 和 HTTP&#x2F;2 可能因为代理修改头部而产生问题，QUIC 的大部分传输头部也被加密，提高了安全性。</li>
</ul>
</li>
</ul>
<h3 id="2-5-5-连接迁移-Connection-Migration"><a href="#2-5-5-连接迁移-Connection-Migration" class="headerlink" title="2.5 5. 连接迁移 (Connection Migration)"></a>2.5 5. 连接迁移 (Connection Migration)</h3><ul>
<li>QUIC 连接不再与客户端的 IP 地址和端口号强绑定，而是使用一个 64 位或 128 位的随机<strong>连接 ID (Connection ID)</strong> 来标识连接。</li>
<li><strong>优势</strong>：<ul>
<li><strong>无缝网络切换</strong>：当客户端 IP 地址或端口号改变（如从 Wi-Fi 切换到蜂窝网络，或从一个 Wi-Fi 热点切换到另一个），QUIC 连接可以保持活跃而不会中断，用户体验更加流畅。这对于频繁移动的移动设备用户至关重要。</li>
</ul>
</li>
</ul>
<h3 id="2-6-6-更好的拥塞控制与可插拔性"><a href="#2-6-6-更好的拥塞控制与可插拔性" class="headerlink" title="2.6 6. 更好的拥塞控制与可插拔性"></a>2.6 6. 更好的拥塞控制与可插拔性</h3><ul>
<li>QUIC 的拥塞控制算法是在用户空间中实现的，可以更容易地进行更新和实验新的拥塞控制算法（如 Cubic, BBR 等），以适应不同的网络环境，而无需等待操作系统内核升级。</li>
<li><strong>优势</strong>：可以针对网络状况动态调整拥塞控制策略，提供更好的带宽利用率和更低的延迟。</li>
</ul>
<h2 id="三、HTTP-3-的核心特性与-HTTP-2-的相似之处"><a href="#三、HTTP-3-的核心特性与-HTTP-2-的相似之处" class="headerlink" title="三、HTTP&#x2F;3 的核心特性与 HTTP&#x2F;2 的相似之处"></a>三、HTTP&#x2F;3 的核心特性与 HTTP&#x2F;2 的相似之处</h2><p>除了 QUIC 带来的底层巨大改进，HTTP&#x2F;3 在其上层依旧继承了 HTTP&#x2F;2 的一些优秀特性：</p>
<ol>
<li><strong>二进制分帧</strong>：HTTP&#x2F;3 仍然使用二进制帧来传输 HTTP 消息，但这些帧是运行在 QUIC 流之上的。</li>
<li><strong>头部压缩 (QPACK)</strong>：HTTP&#x2F;3 使用类似 HPACK 的 <strong>QPACK</strong> 头部压缩算法。QPACK 针对 QUIC 的多流特性进行了优化，解决了 HPACK 在多流并发下可能出现的队头阻塞问题，即允许在不完全依赖按序传输的情况下使用动态字典。</li>
<li><strong>服务器推送 (Server Push)</strong>：HTTP&#x2F;3 继续支持服务器推送，允许服务器预测并主动发送客户端可能需要的资源。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    User --&gt; Browser
    Browser -- HTTP&#x2F;3 请求&#x2F;响应 --&gt; QUIC客户端
    QUIC客户端 -- QUIC帧 (加密) over UDP --&gt; QUIC服务器
    QUIC服务器 -- HTTP&#x2F;3 请求&#x2F;响应 --&gt; Web服务器

    subgraph HTTP&#x2F;3 协议栈
        direction LR
        应用层[HTTP&#x2F;3] -- 头部压缩(QPACK) --&gt; 传输层[QUIC]
        传输层 -- 原生多路复用 &amp; 0-RTT&#x2F;1-RTT &amp; 连接迁移 &amp; 内置TLS1.3 --&gt; 网络层[UDP]
        网络层 --&gt; 物理层[IP]
    end

  </pre></div>
<p>上图展示了 HTTP&#x2F;3 协议栈的核心组成部分及其关系。</p>
<h2 id="四、HTTP-3-的优缺点"><a href="#四、HTTP-3-的优缺点" class="headerlink" title="四、HTTP&#x2F;3 的优缺点"></a>四、HTTP&#x2F;3 的优缺点</h2><h3 id="4-1-优点："><a href="#4-1-优点：" class="headerlink" title="4.1 优点："></a>4.1 优点：</h3><ul>
<li><strong>彻底消除底层 TCP 的队头阻塞</strong>：通过 QUIC 的原生多路复用，即使部分数据包丢失，其他流也能继续。</li>
<li><strong>快速连接建立 (0-RTT&#x2F;1-RTT)</strong>：大大减少了握手延迟，尤其在移动设备和物联网场景下优势明显。</li>
<li><strong>无缝连接迁移</strong>：用户在 Wi-Fi 和移动网络之间切换时，连接可以保持不中断，提供更流畅的用户体验。</li>
<li><strong>强制内置安全性</strong>：TLS 1.3 内置于 QUIC 握手，确保所有通信都默认加密。</li>
<li><strong>更好的网络适应性</strong>：拥塞控制算法在用户空间实现，可快速迭代和优化，更能适应复杂多变的网络环境。</li>
<li><strong>更低的延迟和更高的吞吐量</strong>：综合以上特性，HTTP&#x2F;3 在大部分场景下都能提供更优异的性能。</li>
</ul>
<h3 id="4-2-缺点："><a href="#4-2-缺点：" class="headerlink" title="4.2 缺点："></a>4.2 缺点：</h3><ul>
<li><strong>UDP 阻碍</strong>：一些老旧的防火墙或网络设备可能对 UDP 流量进行限制或阻断，这可能导致 HTTP&#x2F;3 无法建立连接，需要回退到 HTTP&#x2F;2 或 HTTP&#x2F;1.1。</li>
<li><strong>性能回退到 TCP</strong>：为了解决 UDP 阻碍问题，HTTP&#x2F;3 客户端通常需要一个回退机制，即如果 QUIC 连接失败，则尝试通过 TCP 使用 HTTP&#x2F;2 或 HTTP&#x2F;1.1。</li>
<li><strong>CPU 消耗</strong>：由于加密和拥塞控制都在用户空间实现，QUIC 和 HTTP&#x2F;3 可能会比传统的 TCP+TLS 消耗更多的 CPU 资源，尤其是在处理大量连接时。</li>
<li><strong>部署复杂性</strong>：需要服务器和客户端都支持新的 QUIC 协议栈，且现有的网络监控和调试工具可能不完全兼容。</li>
<li><strong>安全性考量 (0-RTT)</strong>：0-RTT 连接虽然快，但存在潜在的<strong>重放攻击</strong>风险。QUIC 采取了措施（如一次性密钥、防重放窗口）来缓解，但服务器仍需谨慎处理 0-RTT 请求以防止潜在的滥用。</li>
</ul>
<h2 id="五、HTTP-3-的部署与未来"><a href="#五、HTTP-3-的部署与未来" class="headerlink" title="五、HTTP&#x2F;3 的部署与未来"></a>五、HTTP&#x2F;3 的部署与未来</h2><ul>
<li><strong>客户端支持</strong>：主流浏览器（Chrome, Firefox, Edge, Safari）已逐步支持 HTTP&#x2F;3，通常需要服务器发送 <code>Alt-Svc</code> 响应头来告知客户端可以尝试使用 HTTP&#x2F;3。</li>
<li><strong>服务器支持</strong>：越来越多的 CDN (如 Cloudflare, Google Cloud CDN) 和 Web 服务器 (如 Nginx, Caddy, Envoy) 已经实现了对 HTTP&#x2F;3 的支持。</li>
<li><strong>前景</strong>：HTTP&#x2F;3 代表了 Web 协议发展的未来方向。随着其部署的普及和相关工具链的成熟，它将为用户带来更快速、更可靠、更安全的在线体验，尤其是在移动优先和物联网的时代。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>HTTP&#x2F;3 是一次对 Web 传输协议的根本性革新。通过将底层协议从 TCP 切换到 QUIC，它不仅解决了 HTTP&#x2F;2 在 TCP 层面的队头阻塞问题，还带来了 0-RTT 连接建立、无缝连接迁移和内置 TLS 1.3 加密等一系列性能和安全上的巨大飞跃。尽管面临一些部署挑战和兼容性问题，HTTP&#x2F;3 的优势足以使其成为未来 Web 通信的主流。理解 HTTP&#x2F;3 背后的 QUIC 协议及其核心特性，是构建和优化现代高性能 Web 服务的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/6479020306f5/">https://blog.tbf1211.xx.kg/6479020306f5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/HTTP/">HTTP</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-23.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/17f0b7d45152/" title="Linux 常用命令详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 常用命令详解</div></div><div class="info-2"><div class="info-item-1"> Linux 命令行界面 (CLI) 是与 Linux 系统交互的强大工具。通过在终端中输入命令，用户可以高效地执行从基本文件操作到复杂系统管理的各种任务。掌握常用命令是成为 Linux 高效使用者的第一步。  一个典型的 Linux 命令遵循以下结构：command [options] [arguments]  command: 要执行的程序或命令的名称 (如 ls, cp)。 options (或称 flags&#x2F;switches): 修改命令行为的参数，通常以 - (短选项，如 -l) 或 -- (长选项，如 --list) 开头。 arguments: 命令操作的对象，通常是文件名、目录路径或字符串。    一、文件与目录管理这是最基本也是最常用的一类命令，用于浏览和操作文件系统。 1.1 ls - 列出目录内容作用：列出指定目录下的文件和子目录。 常用选项：  -l: 使用长列表格式显示，包含权限、所有者、大小、修改日期等详细信息。 -a: 显示所有文件，包括以 . 开头的隐藏文件。 -h: 与 -l 结合使用，以人类可读的格式显示文件大小 (如 1K, 23M...</div></div></div></a><a class="pagination-related" href="/a8d205bac226/" title="HTTP/2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">HTTP/2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/abf64f03363d/" title="HTTP Upgrade 请求详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-24</div><div class="info-item-2">HTTP Upgrade 请求详解</div></div><div class="info-2"><div class="info-item-1"> HTTP Upgrade 请求 是一种特殊的 HTTP&#x2F;1.1 机制，允许客户端和服务器在已经建立的 TCP 连接上，将当前协议从 HTTP&#x2F;1.1 切换到另一个不同的、更高级别的协议。最常见的应用场景是将 HTTP 连接升级到 WebSocket 协议，从而实现全双工、低延迟的持久连接。  核心思想：Upgrade 请求是 HTTP&#x2F;1.1 中用于协议协商的机制，允许在一个已有的 TCP 连接上，在客户端和服务器都同意的情况下，从 HTTP 切换到其他协议，避免了重新建立连接的开销，并开启更强大的通信模式。   一、为什么需要 HTTP Upgrade？HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 都是无状态的请求-响应协议。对于每个请求，客户端发送请求，服务器发送响应，然后连接可以关闭（非持久连接）或保持一段时间用于后续的 HTTP 请求（持久连接，Keep-Alive）。 这种请求-响应模式对于传统的 Web 页面浏览非常高效。然而，随着 Web 应用复杂度的增加，许多场景需要更高级的通信模式：  实时通信：聊天应用、在线游戏、...</div></div></div></a><a class="pagination-related" href="/a8d205bac226/" title="HTTP&#x2F;2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="info-item-2">HTTP&#x2F;2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a><a class="pagination-related" href="/378a51590e55/" title="HTTP&#x2F;1.1 协议深度详解：Web 通信的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="info-item-2">HTTP&#x2F;1.1 协议深度详解：Web 通信的基石</div></div><div class="info-2"><div class="info-item-1"> HTTP (HyperText Transfer Protocol - 超文本传输协议) 是 Web 浏览器和 Web 服务器之间用于传输超文本数据（如 HTML、图片、视频、JSON 等）的应用层协议。HTTP&#x2F;1.1 作为其最重要的一个版本，自 1999 年发布以来，长期作为现代 Web 通信的核心协议，至今仍被广泛使用。它在 HTTP&#x2F;1.0 的基础上进行了诸多改进，极大地提升了 Web 的性能和功能。  核心思想：HTTP&#x2F;1.1 定义了客户端如何请求资源和服务器如何响应资源。它的主要特点是基于请求-响应模型，并通过一系列改进（如持久连接、管线化、缓存控制等）提升了 Web 资源的传输效率和灵活性。   一、HTTP&#x2F;1.0 到 HTTP&#x2F;1.1 的演进：解决痛点HTTP&#x2F;1.0 (1996 年) 是 HTTP 的第一个正式版本，奠定了 Web 通信的基础。然而，它在实际应用中暴露出一些性能瓶颈和功能不足：  短连接 (Short Connection)：HTTP&#x2F;1.0 默认每个请求&#x2F;响应...</div></div></div></a><a class="pagination-related" href="/5d5f7c78ff8d/" title="五层因特网协议栈深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-14</div><div class="info-item-2">五层因特网协议栈深度详解</div></div><div class="info-2"><div class="info-item-1"> 五层因特网协议栈，也常被称为 TCP&#x2F;IP 五层模型，是现代互联网架构中实际使用和教学中最常见的网络模型。它结合了 OSI (开放系统互连) 参考模型的层次化思想和 TCP&#x2F;IP 协议族的实际应用，将复杂的网络通信功能划分为五个逻辑层级，每个层级负责特定的任务，并通过定义良好的接口与相邻层交互。与 OSI 七层模型相比，五层协议栈更贴近实际实现，是理解互联网如何工作的核心。  核心思想：将互联网的通信过程划分为五个逻辑层级，自顶向下依次为应用层、传输层、网络层、数据链路层和物理层，每层负责不同的通信职责，协同工作以实现全球互联。   一、为什么选择五层协议栈？尽管 OSI 七层模型提供了非常详细的理论分层，但由于其设计时在标准制定上花费了大量时间，并且部分层次划分在实际实现中显得过于细致，导致其未能大规模落地。相反，TCP&#x2F;IP 协议族在互联网的早期发展中迅速崛起并成为事实标准。五层协议栈结合了二者的优点：  实用性：它直接反映了 TCP&#x2F;IP 协议族栈的工作方式，是互联网实际运行的写照。 简洁性：相比 OSI 七层模型，它将 OSI 的...</div></div></div></a><a class="pagination-related" href="/7bd4a820ad36/" title="TCP&#x2F;IP协议栈深度详解：因特网的核心基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-11</div><div class="info-item-2">TCP&#x2F;IP协议栈深度详解：因特网的核心基石</div></div><div class="info-2"><div class="info-item-1"> TCP&#x2F;IP 协议栈 (Transmission Control Protocol&#x2F;Internet Protocol Suite) 并不是一个单一的协议，而是一个由一系列网络协议组成的协议族。它是因特网的基石和核心，定义了数据如何在网络中进行封装、传输和路由的规则。TCP&#x2F;IP 协议栈的设计目标是提供一个鲁棒、可靠并且能够跨异构网络工作的通信框架。  核心思想：TCP&#x2F;IP 协议栈通过标准化的分层结构和一系列协议（最著名的是 TCP 和 IP），解决了在复杂、异构的网络环境中，如何实现不同设备之间可靠、高效、互通的端到端通信问题。   一、TCP&#x2F;IP 协议栈的起源与重要性TCP&#x2F;IP 协议栈最早起源于 20 世纪 70 年代初美国国防部高级研究计划局（ARPA）开发的 ARPANET 项目。随着 ARPANET 演变为今天的因特网，TCP&#x2F;IP 也逐渐成为全球计算机网络的通用标准。 为什么它如此重要？  因特网的基石：没有 TCP&#x2F;IP 协议，就没有今天的因特网。世界上几乎所有的网络设备都支持 ...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">438</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">224</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP-2-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E-HTTP-3-%E7%9A%84%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF"><span class="toc-text">一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81QUIC-%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-HTTP-3-%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-text">二、QUIC 协议的核心特性 (HTTP&#x2F;3 的基石)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%9F%BA%E4%BA%8E-UDP%EF%BC%9A%E6%91%86%E8%84%B1-TCP-%E7%9A%84%E6%9D%9F%E7%BC%9A"><span class="toc-text">2.1 1. 基于 UDP：摆脱 TCP 的束缚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%8E%9F%E7%94%9F%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-Multiplexing"><span class="toc-text">2.2 2. 原生多路复用 (Multiplexing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-0-RTT-1-RTT-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B-Fast-Connection-Setup"><span class="toc-text">2.3 3. 0-RTT&#x2F;1-RTT 连接建立 (Fast Connection Setup)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E5%86%85%E7%BD%AE-TLS-1-3-%E5%8A%A0%E5%AF%86-Always-on-Security"><span class="toc-text">2.4 4. 内置 TLS 1.3 加密 (Always-on Security)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB-Connection-Migration"><span class="toc-text">2.5 5. 连接迁移 (Connection Migration)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-6-%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E6%8F%92%E6%8B%94%E6%80%A7"><span class="toc-text">2.6 6. 更好的拥塞控制与可插拔性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP-3-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E-HTTP-2-%E7%9A%84%E7%9B%B8%E4%BC%BC%E4%B9%8B%E5%A4%84"><span class="toc-text">三、HTTP&#x2F;3 的核心特性与 HTTP&#x2F;2 的相似之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81HTTP-3-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">四、HTTP&#x2F;3 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">4.1 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">4.2 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81HTTP-3-%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%9C%AA%E6%9D%A5"><span class="toc-text">五、HTTP&#x2F;3 的部署与未来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-23.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>