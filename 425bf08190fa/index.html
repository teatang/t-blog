<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TLS Encrypted Client Hello (ECH) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 I">
<meta property="og:type" content="article">
<meta property="og:title" content="TLS Encrypted Client Hello (ECH) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/425bf08190fa/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="TLS Encrypted Client Hello (ECH) 是对 TLS 1.3 协议 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的明文 Server Name Indication (SNI) 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 I">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg">
<meta property="article:published_time" content="2023-04-09T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:29:10.711Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta property="article:tag" content="TLS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TLS Encrypted Client Hello (ECH) 详解",
  "url": "https://blog.tbf1211.xx.kg/425bf08190fa/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-32.jpg",
  "datePublished": "2023-04-09T22:24:00.000Z",
  "dateModified": "2026-02-01T09:29:10.711Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/425bf08190fa/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TLS Encrypted Client Hello (ECH) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-32.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">TLS Encrypted Client Hello (ECH) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TLS Encrypted Client Hello (ECH) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-04-09T22:24:00.000Z" title="发表于 2023-04-10 06:24:00">2023-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>TLS Encrypted Client Hello (ECH)</strong> 是对 <strong>TLS 1.3 协议</strong> 的一项重要扩展，旨在解决传输层安全性 (TLS) 握手过程中客户端发送的<strong>明文 Server Name Indication (SNI)</strong> 扩展所带来的隐私和审查问题。通过 ECH，客户端可以在 TLS 握手的第一个消息——Client Hello 中加密它想要连接的服务器主机名，从而阻止网络中间方（如 ISP、审查机构或广告商）窥探用户正在访问的具体网站。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想</strong>：<strong>在 TLS 握手开始阶段，通过加密客户端请求的服务器主机名 (SNI)，隐藏用户的访问目标，提升网络隐私和抗审查能力。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-ECH？SNI-的隐私痛点"><a href="#一、为什么需要-ECH？SNI-的隐私痛点" class="headerlink" title="一、为什么需要 ECH？SNI 的隐私痛点"></a>一、为什么需要 ECH？SNI 的隐私痛点</h2><p>在深入了解 ECH 之前，我们首先需要理解它所要解决的核心问题：<strong>明文 SNI (Server Name Indication)</strong>。</p>
<h3 id="1-1-SNI-的作用"><a href="#1-1-SNI-的作用" class="headerlink" title="1.1 SNI 的作用"></a>1.1 SNI 的作用</h3><p><strong>SNI</strong> 是 TLS 协议的一个扩展，用于解决<strong>虚拟主机 (Virtual Hosting)</strong> 问题。在 HTTP&#x2F;1.1 时代，多个网站（具有不同的域名，如 <code>example.com</code> 和 <code>another.com</code>）可以共享同一个 IP 地址。当客户端发起 HTTP 请求时，它会在请求头中包含 <code>Host</code> 字段来指定要访问的域名。</p>
<p>对于 HTTPS (基于 TLS 的 HTTP) 来说，在 TLS 握手阶段，服务器需要知道客户端想要访问哪个域名，以便加载正确的 TLS 证书。因为 TLS 握手发生在 HTTP 请求之前，服务器无法从 HTTP <code>Host</code> 头获取域名信息。SNI 就是为此而生：客户端在 TLS Client Hello 消息中明确告知服务器它希望连接的域名。</p>
<h3 id="1-2-SNI-带来的隐私问题"><a href="#1-2-SNI-带来的隐私问题" class="headerlink" title="1.2 SNI 带来的隐私问题"></a>1.2 SNI 带来的隐私问题</h3><p>尽管 SNI 对于虚拟主机是必要的，但它有一个关键的隐私缺陷：<strong>SNI 字段在 TLS 握手的第一阶段以明文形式传输</strong>。这意味着，即使整个 TLS 会话后续是加密的，任何位于客户端和服务器之间的网络中间方（如 ISP、路由器、防火墙、审查设备等）都可以轻易地读取 SNI 字段，从而得知客户端正在访问哪个具体的域名。</p>
<p><strong>这种明文泄露导致的问题包括：</strong></p>
<ul>
<li><strong>流量分析</strong>：中间方可以构建用户访问网站的历史记录，进行用户画像和行为分析。</li>
<li><strong>网络审查</strong>：审查机构可以根据 SNI 过滤或阻止用户访问特定网站。</li>
<li><strong>定向广告和监控</strong>：广告公司或监控机构可以利用这些信息进行更精准的追踪。</li>
</ul>
<h3 id="1-3-ESNI-Encrypted-SNI-的尝试与局限"><a href="#1-3-ESNI-Encrypted-SNI-的尝试与局限" class="headerlink" title="1.3 ESNI (Encrypted SNI) 的尝试与局限"></a>1.3 ESNI (Encrypted SNI) 的尝试与局限</h3><p>为了解决 SNI 的隐私问题，IETF 在 TLS 1.3 中提出了 <strong>ESNI (Encrypted SNI)</strong> 扩展。ESNI 的基本思路是：通过 DNS TXT 记录预先发布服务器的公钥，客户端获取公钥后，使用该公钥加密 SNI 字段。</p>
<p>然而，ESNI 存在一些局限性：</p>
<ol>
<li><strong>依赖 DNSSEC</strong>：ESNI 要求 DNS 记录必须经过 DNSSEC 签名验证，以防止攻击者篡改公钥。但 DNSSEC 的部署并不普及。</li>
<li><strong>密钥轮换复杂性</strong>：ESNI 密钥的轮换和管理相对复杂。</li>
<li><strong>Client Hello 结构限制</strong>：ESNI 只加密了 SNI 扩展本身，而 Client Hello 消息中仍然可能包含其他可以泄露目标网站信息的数据（如 ALPN 协议列表、Session ID 等），造成侧信道攻击的风险。</li>
</ol>
<p>ECH 作为 ESNI 的继任者，旨在克服这些局限性，提供更全面的 Client Hello 加密。</p>
<h2 id="二、ECH-的工作原理"><a href="#二、ECH-的工作原理" class="headerlink" title="二、ECH 的工作原理"></a>二、ECH 的工作原理</h2><p>ECH 的核心思想是将整个 Client Hello 消息分为<strong>外部 (Outer)</strong> 和<strong>内部 (Inner)</strong> 两个部分，并加密内部部分。</p>
<h3 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h3><ul>
<li><strong>Outer Client Hello (OCH)</strong>：<ul>
<li>未加密的部分，对所有网络观察者可见。</li>
<li>包含一个**“假”或“通用”的 SNI (public_name)**，通常是 CDN 或代理服务的域名（例如 <code>cloudflare-ech.com</code>）。这个假 SNI 旨在欺骗中间盒，使其认为连接的是一个无害的公共服务。</li>
<li>包含一个 ECH 扩展，其中含有加密后的 Inner Client Hello。</li>
</ul>
</li>
<li><strong>Inner Client Hello (ICH)</strong>：<ul>
<li>加密的部分，只有预期的服务器能够解密。</li>
<li>包含<strong>真实的 SNI (real_name)</strong> 和其他敏感的 TLS 扩展（如 ALPN、Session ID 等）。</li>
<li>使用一种称为 <strong>HPKE (Hybrid Public Key Encryption)</strong> 的公钥加密方案进行加密。</li>
</ul>
</li>
</ul>
<h3 id="2-2-ECH-密钥的获取"><a href="#2-2-ECH-密钥的获取" class="headerlink" title="2.2 ECH 密钥的获取"></a>2.2 ECH 密钥的获取</h3><p>为了加密 Inner Client Hello，客户端需要服务器的公共 ECH 密钥。这个密钥是通过 DNS 查询获得的。</p>
<ul>
<li><strong>HTTPS 记录 (HTTPS Resource Record)</strong>：IETF 引入了一种新的 DNS 记录类型 <code>HTTPS</code> (也称为 <code>SVCB</code> 记录的别名)。这个记录类型不仅可以返回 IP 地址，还可以包含服务的额外参数，其中就包括服务器的 ECH 公钥配置 (<code>echconfig</code> 参数)。</li>
</ul>
<p><strong>DNS HTTPS RR 记录示例（概念性）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_443._tcp.www.example.com. IN HTTPS 1 . echconfig=&quot;...&quot; alpn=&quot;...&quot;</span><br></pre></td></tr></table></figure>

<p>其中 <code>echconfig</code> 字段包含了服务器用于 ECH 的公钥信息。客户端在发起连接前，会先查询目标域名的 HTTPS 记录，获取 <code>echconfig</code>。</p>
<h3 id="2-3-ECH-握手流程"><a href="#2-3-ECH-握手流程" class="headerlink" title="2.3 ECH 握手流程"></a>2.3 ECH 握手流程</h3><p>以下是启用 ECH 后的 TLS 握手简化流程：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    sequenceDiagram
    participant Client as 客户端
    participant DNS as DNS 解析器
    participant FrontingServer as 前置服务器 (例如 Cloudflare Edge)
    participant OriginServer as 源站服务器

    Client-&gt;&gt;DNS: 1. 查询 www.example.com 的 HTTPS RR (包含 ECHConfig)
    DNS--&gt;&gt;Client: 2. 返回 HTTPS RR (包含 ECHConfigValue)

    Client-&gt;&gt;Client: 3. 使用 ECHConfigValue 中的公钥加密真实的 SNI (real_name) 和其他敏感扩展，生成 Inner Client Hello (ICH)
    Client-&gt;&gt;Client: 4. 构建 Outer Client Hello (OCH)，包含假的 SNI (public_name) 和加密的 ICH
    Client-&gt;&gt;FrontingServer: 5. 发送 OCH (包含 public_name 和加密的 ICH)

    FrontingServer-&gt;&gt;FrontingServer: 6. 尝试使用其私钥解密 ECH 扩展中的 ICH
    alt 解密成功 (说明客户端尝试连接到由FrontingServer管理的域名)
        FrontingServer-&gt;&gt;FrontingServer: 7. 获取真实的 SNI (real_name) 和其他扩展
        alt FrontingServer是实际的OriginServer
            FrontingServer-&gt;&gt;Client: 8a. 使用 real_name 对应的证书继续 TLS 握手
        else FrontingServer是代理 (如CDN)
            FrontingServer-&gt;&gt;OriginServer: 8b. 将请求转发到 OriginServer (可能通过内部加密通道)
            OriginServer-&gt;&gt;FrontingServer: 9. 返回响应
            FrontingServer-&gt;&gt;Client: 10. 将响应返回给客户端
        end
    else 解密失败 (可能不是ECH流量，或公钥不匹配)
        FrontingServer-&gt;&gt;Client: 8c. 发送 TLS Alert (例如 &quot;unrecognized_name&quot;) 或回退到传统 TLS 握手 (取决于配置)
    end
  </pre></div>

<p><strong>详细步骤解析：</strong></p>
<ol>
<li><strong>DNS 查询</strong>：客户端首先通过 DNS 解析目标域名（例如 <code>www.example.com</code>）的 <code>HTTPS</code> 记录。</li>
<li><strong>获取 ECH 配置</strong>：DNS 返回的 <code>HTTPS</code> 记录包含服务器的 ECH 配置（<code>echconfig</code>），其中包含了用于加密的公共 ECH 密钥和服务器的 <code>public_name</code>（假的 SNI）。</li>
<li><strong>构建 Client Hello</strong>：<ul>
<li>客户端使用 <code>echconfig</code> 中的公钥加密真实的 SNI (<code>www.example.com</code>) 和其他敏感的 TLS 扩展，生成 Inner Client Hello (ICH)。</li>
<li>客户端构建 Outer Client Hello (OCH)，其中包含从 <code>echconfig</code> 获取的 <code>public_name</code> 作为 SNI，以及加密后的 ICH 作为 ECH 扩展。</li>
</ul>
</li>
<li><strong>发送 OCH</strong>：客户端将 OCH 发送给服务器。此时，网络中间方只能看到 <code>public_name</code>（例如 <code>cloudflare-ech.com</code>），而无法看到真实的 <code>www.example.com</code>。</li>
<li><strong>服务器处理</strong>：<ul>
<li>服务器接收到 OCH 后，会尝试使用其对应的私钥来解密 ECH 扩展中的 ICH。</li>
<li>如果解密成功，服务器将获得真实的 SNI (<code>www.example.com</code>)。服务器会使用这个真实的 SNI 来选择正确的 TLS 证书，并继续完成 TLS 握手。</li>
<li>如果解密失败（例如，客户端的 ECH 配置已过期，或者连接的不是支持 ECH 的服务器），服务器可以选择拒绝连接或回退到传统的 TLS 握手（如果 <code>public_name</code> 也是一个有效的、未加密的 SNI）。</li>
</ul>
</li>
</ol>
<h3 id="2-4-HPKE-Hybrid-Public-Key-Encryption"><a href="#2-4-HPKE-Hybrid-Public-Key-Encryption" class="headerlink" title="2.4 HPKE (Hybrid Public Key Encryption)"></a>2.4 HPKE (Hybrid Public Key Encryption)</h3><p><strong>HPKE (Hybrid Public Key Encryption)</strong> 是一种灵活的公钥加密方案，它结合了非对称加密（用于密钥交换）和对称加密（用于数据加密）的优势。在 ECH 中，HPKE 用于加密 Inner Client Hello 中的敏感信息。其基本流程是：</p>
<ol>
<li>发送方使用接收方的公钥加密一个对称密钥。</li>
<li>发送方使用这个对称密钥加密实际数据。</li>
<li>接收方使用其私钥解密对称密钥。</li>
<li>接收方使用解密出的对称密钥解密实际数据。</li>
</ol>
<p>这种混合方案提供了前向保密性，并且比纯粹的非对称加密效率更高。</p>
<h2 id="三、ECH-的优势"><a href="#三、ECH-的优势" class="headerlink" title="三、ECH 的优势"></a>三、ECH 的优势</h2><ol>
<li><strong>增强用户隐私</strong>：彻底解决了明文 SNI 泄露问题，保护了用户访问网站的隐私，使网络中间方无法轻易得知用户访问了哪个具体网站。</li>
<li><strong>对抗网络审查</strong>：由于 SNI 被加密，审查设备难以根据域名进行阻断，从而增加了网络审查的难度。</li>
<li><strong>流量分析防御</strong>：使得中间方更难进行大规模的流量分析和用户画像。</li>
<li><strong>更全面的加密</strong>：相比 ESNI，ECH 加密了整个 Client Hello 的敏感部分，包括 SNI 和其他可能泄露信息的扩展，提供了更强大的保护。</li>
<li><strong>简化部署</strong>：通过 <code>HTTPS</code> DNS 记录分发 ECH 配置，避免了 ESNI 对 DNSSEC 的强制依赖，简化了部署难度（虽然 DNSSEC 仍然是推荐的安全实践）。</li>
<li><strong>零信任架构集成</strong>：与 Cloudflare 等服务结合，ECH 成为零信任架构中的重要组成部分，进一步强化了端到端安全和隐私。</li>
</ol>
<h2 id="四、部署与实现现状"><a href="#四、部署与实现现状" class="headerlink" title="四、部署与实现现状"></a>四、部署与实现现状</h2><h3 id="4-1-客户端支持"><a href="#4-1-客户端支持" class="headerlink" title="4.1 客户端支持"></a>4.1 客户端支持</h3><p>主流浏览器正在逐步支持 ECH：</p>
<ul>
<li><strong>Firefox</strong>：自 Firefox 113 起默认启用 ECH。</li>
<li><strong>Chrome&#x2F;Edge</strong>：正在积极测试和部署中，可能需要通过实验性 Flag 开启。</li>
<li><strong>其他浏览器</strong>：正在跟进。</li>
</ul>
<h3 id="4-2-服务器端支持"><a href="#4-2-服务器端支持" class="headerlink" title="4.2 服务器端支持"></a>4.2 服务器端支持</h3><p>服务器端实现 ECH 主要依赖于：</p>
<ul>
<li><strong>TLS 库</strong>：需要支持 ECH 的 TLS 库，例如 <strong>OpenSSL 3.x</strong> 及更高版本。</li>
<li><strong>CDN&#x2F;代理服务</strong>：像 Cloudflare 这样的 CDN 服务是 ECH 的主要推动者和部署者。它们作为前端代理服务器，能够承担 ECH 的解密和转发工作，并为客户提供简便的 ECH 启用方式。<ul>
<li><strong>Cloudflare</strong> 已全面支持 ECH，并帮助其客户轻松部署。当用户通过 Cloudflare 代理时，Cloudflare 的边缘服务器充当 <code>FrontingServer</code>，处理 ECH 解密并将真实请求转发给源站。</li>
</ul>
</li>
<li><strong>Web 服务器</strong>：Nginx、Apache 等 Web 服务器需要与支持 ECH 的 OpenSSL 版本配合，并进行相应的配置。这通常比通过 CDN 部署要复杂。</li>
</ul>
<h3 id="4-3-DNS-配置"><a href="#4-3-DNS-配置" class="headerlink" title="4.3 DNS 配置"></a>4.3 DNS 配置</h3><p>域名的 DNS 服务商需要支持 <code>HTTPS</code> 记录类型，以便发布 ECH 配置。</p>
<h2 id="五、安全性考虑"><a href="#五、安全性考虑" class="headerlink" title="五、安全性考虑"></a>五、安全性考虑</h2><ol>
<li><strong>密钥管理</strong>：服务器端 ECH 私钥的妥善保管至关重要。一旦私钥泄露，攻击者可以解密客户端的 Inner Client Hello。</li>
<li><strong>DNS 安全</strong>：尽管 ECH 不强制要求 DNSSEC，但为了防止 DNS 缓存投毒或中间人攻击篡改 <code>HTTPS</code> 记录中的 ECH 配置，强烈建议使用 DNSSEC 保护域名的 DNS 记录。</li>
<li><strong>回退攻击</strong>：如果 ECH 握手失败（例如，服务器不支持 ECH 或密钥不匹配），客户端可能会回退到传统的明文 SNI 握手。攻击者可能会尝试通过干扰 ECH 握手来强制客户端回退，从而继续窃取 SNI。协议设计中包含机制来缓解此问题，但客户端和服务器的正确实现至关重要。</li>
<li><strong>服务器指纹识别</strong>：即使 SNI 被加密，Client Hello 中的其他参数（如支持的密码套件、扩展列表、ALPN 协议等）仍然可能被用于对客户端或服务器进行指纹识别。ECH 旨在尽可能多地加密这些敏感信息，但完全消除指纹识别是长期挑战。</li>
<li><strong>流量分析的复杂性</strong>：ECH 使得传统的基于 SNI 的审查和流量分析变得更加困难，但这并不意味着完全不可能。更复杂的深度包检测 (DPI) 技术仍可能通过其他信息（如 IP 地址、证书指纹、流量模式等）来推断用户行为。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>TLS Encrypted Client Hello (ECH) 是互联网隐私保护和抗审查方面的一个里程碑式进展。它通过加密 TLS 握手初期最敏感的信息——客户端请求的服务器主机名，有效地阻断了网络中间方的窥探，为用户提供了更强大的隐私保护。</p>
<p>随着主流浏览器和 CDN 服务提供商的积极推动，ECH 的部署和普及正在加速。虽然部署仍面临一些挑战（如客户端和服务器的兼容性、DNS 配置等），但其带来的隐私和安全效益将显著提升全球互联网的健壮性和用户体验，是构建一个更加私密、开放和安全的网络环境的重要一步。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/425bf08190fa/">https://blog.tbf1211.xx.kg/425bf08190fa/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a><a class="post-meta__tags" href="/tags/TLS/">TLS</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/8fad93ea4f62/" title="ALPN (Application-Layer Protocol Negotiation) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ALPN (Application-Layer Protocol Negotiation) 详解</div></div><div class="info-2"><div class="info-item-1"> ALPN (Application-Layer Protocol Negotiation)，即应用层协议协商，是 TLS (传输层安全) 协议的一个扩展，允许客户端和服务器在进行 TLS 握手时，协商决定在加密连接上使用哪个应用层协议。它在 RFC 7301 中被定义。ALPN 的出现，极大地简化了现代网络协议的部署和使用，尤其是对于 HTTP&#x2F;2 和未来的 QUIC 等协议。  核心思想：ALPN 将应用层协议的选择过程集成到 TLS 握手阶段，使得在建立加密连接的同时，也完成了应用层协议的确定，避免了额外的往返延迟，并允许在同一端口上运行多种应用层协议。   一、为什么需要 ALPN？在 ALPN 出现之前，协商应用层协议通常面临以下挑战：  端口绑定：传统的做法是为不同的应用层协议使用不同的端口。例如，HTTP 使用 80 端口，HTTPS 使用 443 端口，FTP 使用 21 端口。当引入新的协议（如 HTTP&#x2F;2 或 SPDY）时，如果想与现有协议共存，就必须使用新的端口，这会增加防火墙配置、负载均衡设置的复杂性，并且用户可能需要记住非标准的端口...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/22aa4c322dbd/" title="TLS (传输层安全协议) 深度详解：网络通信的守护者"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="info-item-2">TLS (传输层安全协议) 深度详解：网络通信的守护者</div></div><div class="info-2"><div class="info-item-1"> TLS (Transport Layer Security)，即传输层安全性协议，是用于在计算机网络上提供端到端安全通信的加密协议。它是 SSL (Secure Sockets Layer) 协议的继任者，两者常被混用，但技术上，现代网络浏览器及服务器都已使用 TLS 协议。TLS 主要提供数据隐私、数据完整性以及通信双方的身份认证，是互联网上最广泛使用的安全协议，例如 HTTPS (HTTP over TLS)、SMTPS、LDAPS 等都依赖于 TLS。  核心思想：在不可信的网络上，通过加密、认证和完整性校验，建立一个可信的加密通信通道。   一、为什么需要 TLS？互联网的早期（例如纯 HTTP 时代），数据在传输过程中是明文的。这意味着：  窃听 (Eavesdropping)：任何中间人（如 ISP、路由器管理员、恶意攻击者）都可以截获并读取传输中的数据，包括用户密码、银行卡信息、私人消息等。 篡改 (Tampering)：中间人不仅可以读取数据，还可以修改数据，例如在网页中植入恶意代码，或者更改用户提交的表单内容。 身份伪装 (Impersonation)：客户端...</div></div></div></a><a class="pagination-related" href="/bd05c017c301/" title="SNI (Server Name Indication) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="info-item-2">SNI (Server Name Indication) 详解</div></div><div class="info-2"><div class="info-item-1"> SNI (Server Name Indication) 是 TLS (Transport Layer Security) 协议的一个扩展，它允许客户端在建立 TLS&#x2F;SSL 握手时，在 Client Hello 报文中指定其尝试连接的主机名（域名）。SNI 主要解决了在单个 IP 地址和端口上托管多个 HTTPS 网站（每个网站有不同的域名和证书）的问题。  核心思想：TLS 握手阶段，客户端告诉服务器它想访问哪个域名，这样服务器就知道应该提供哪个域名的证书。   一、为什么需要 SNI？在 SNI 出现之前，建立 HTTPS 连接的过程是这样的：  客户端通过 IP 地址和端口 (通常是 443) 连接到服务器。 服务器接收连接，然后发送其数字证书给客户端。 客户端验证证书，然后建立加密通信。  这里的问题在于，一个服务器 IP 地址可以托管多个网站，每个网站都有其自己的域名。在 HTTPS 中，每个域名都需要一张匹配的 SSL&#x2F;TLS 证书。 没有 SNI 的局限性：  IP 地址瓶颈：服务器在收到客户端的连接请求时，它只知道客户端连接的是哪个 IP ...</div></div></div></a><a class="pagination-related" href="/8fad93ea4f62/" title="ALPN (Application-Layer Protocol Negotiation) 详解"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="info-item-2">ALPN (Application-Layer Protocol Negotiation) 详解</div></div><div class="info-2"><div class="info-item-1"> ALPN (Application-Layer Protocol Negotiation)，即应用层协议协商，是 TLS (传输层安全) 协议的一个扩展，允许客户端和服务器在进行 TLS 握手时，协商决定在加密连接上使用哪个应用层协议。它在 RFC 7301 中被定义。ALPN 的出现，极大地简化了现代网络协议的部署和使用，尤其是对于 HTTP&#x2F;2 和未来的 QUIC 等协议。  核心思想：ALPN 将应用层协议的选择过程集成到 TLS 握手阶段，使得在建立加密连接的同时，也完成了应用层协议的确定，避免了额外的往返延迟，并允许在同一端口上运行多种应用层协议。   一、为什么需要 ALPN？在 ALPN 出现之前，协商应用层协议通常面临以下挑战：  端口绑定：传统的做法是为不同的应用层协议使用不同的端口。例如，HTTP 使用 80 端口，HTTPS 使用 443 端口，FTP 使用 21 端口。当引入新的协议（如 HTTP&#x2F;2 或 SPDY）时，如果想与现有协议共存，就必须使用新的端口，这会增加防火墙配置、负载均衡设置的复杂性，并且用户可能需要记住非标准的端口...</div></div></div></a><a class="pagination-related" href="/058452c6e7a6/" title="TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="info-item-2">TCP (传输控制协议) 深度详解：可靠、面向连接的字节流基石</div></div><div class="info-2"><div class="info-item-1"> TCP (Transmission Control Protocol)，即传输控制协议，是 Internet 协议套件 (Internet Protocol Suite) 中的核心协议之一，位于传输层。它提供可靠的、面向连接的、基于字节流的全双工通信服务。TCP 协议确保了数据能够按序、无差错地从一个应用进程传输到另一个应用进程。  核心思想：在不可靠的 IP 层之上，通过一系列机制（如序号、确认、重传、流量控制、拥塞控制）构建一个高度可靠、有序的数据传输通道。   一、为什么需要 TCP？在网络模型中，IP 协议（网络层）提供了尽力而为 (best-effort) 的数据报服务，它不保证数据包的到达、顺序或不重复。然而，大多数应用（如网页浏览、文件传输、电子邮件）都需要一个可靠的数据传输服务。TCP 正是为了弥补 IP 协议的这些不足而设计的，它在应用层和网络层之间提供了一个可靠的、虚拟的通信管道。 TCP 的主要职责包括：  可靠性：确保数据无损、无错地到达目的地。 有序性：确保数据包以正确的顺序交付给接收方。 流量控制：防止发送方发送数据过快，导致接收方缓冲区溢出。 拥塞...</div></div></div></a><a class="pagination-related" href="/dff8568b9553/" title="UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="info-item-2">UDP (用户数据报协议) 深度详解：轻量、高效、无连接的传输基石</div></div><div class="info-2"><div class="info-item-1"> 用户数据报协议 (UDP - User Datagram Protocol) 是互联网协议套件 (TCP&#x2F;IP) 中位于传输层的一个简单而高效的协议。与复杂的 TCP 不同，UDP 提供了一种无连接 (Connectionless)、不可靠 (Unreliable) 的数据报服务，强调传输速度和资源效率，而非数据的完整性和顺序性。它不对数据包进行排序、不保证送达、不进行错误重传、不提供流量控制和拥塞控制。  核心思想：UDP 就像邮局的平信服务。你把信投进去，邮局尽力送达，但不保证一定能送到，也不告诉你有没有送到。它不操心信的顺序，不提供回执，也不管你的信封里装了多少页纸。   一、UDP 的核心特性与设计哲学UDP 的设计目标是提供一个最小化的传输层协议，只做传输层最基本的事情——多路复用和少量的错误校验。它将大部分的可靠性职责留给应用程序自行处理。  无连接 (Connectionless)：  在数据传输之前，通信双方无需建立或维护任何连接状态。 发送方可以直接向目的端发送数据报。 每个数据报都是独立的，包含完整的源地址和目的地址信息。   不可靠传输 (Unr...</div></div></div></a><a class="pagination-related" href="/7bd4a820ad36/" title="TCP&#x2F;IP协议栈深度详解：因特网的核心基石"><img class="cover" src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-11</div><div class="info-item-2">TCP&#x2F;IP协议栈深度详解：因特网的核心基石</div></div><div class="info-2"><div class="info-item-1"> TCP&#x2F;IP 协议 (Transmission Control Protocol&#x2F;Internet Protocol) 是一组用于互联网通信的协议集合，通常被称为 TCP&#x2F;IP 协议族 (TCP&#x2F;IP Protocol Suite) 或 TCP&#x2F;IP 协议栈 (TCP&#x2F;IP Protocol Stack)。它是现代互联网和局域网 (LAN) 的基石，定义了数据如何在网络中传输、路由和接收。TCP&#x2F;IP 协议族以其分层结构而闻名，将复杂的网络通信任务分解为更小、更易于管理的子任务。  核心思想：将复杂的网络通信过程划分为独立的层次，每层负责特定的功能，并通过协议进行协作，从而实现高效、可靠且可扩展的全球通信。   一、为什么需要 TCP&#x2F;IP 协议？在计算机网络发展的早期，各种网络设备和操作系统拥有各自不兼容的通信协议，导致不同厂商的设备之间难以互联互通。为了解决这一问题，美国国防部高级研究计划局 (ARPA) 资助开发了 ARPANET 项目，并在此基础上逐步发展出了 TCP&#x2F;IP 协议。...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ECH%EF%BC%9FSNI-%E7%9A%84%E9%9A%90%E7%A7%81%E7%97%9B%E7%82%B9"><span class="toc-text">一、为什么需要 ECH？SNI 的隐私痛点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-SNI-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1.1 SNI 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-SNI-%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%9A%90%E7%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">1.2 SNI 带来的隐私问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-ESNI-Encrypted-SNI-%E7%9A%84%E5%B0%9D%E8%AF%95%E4%B8%8E%E5%B1%80%E9%99%90"><span class="toc-text">1.3 ESNI (Encrypted SNI) 的尝试与局限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ECH-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、ECH 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-ECH-%E5%AF%86%E9%92%A5%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">2.2 ECH 密钥的获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-ECH-%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B"><span class="toc-text">2.3 ECH 握手流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-HPKE-Hybrid-Public-Key-Encryption"><span class="toc-text">2.4 HPKE (Hybrid Public Key Encryption)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ECH-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">三、ECH 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%8E%B0%E7%8A%B6"><span class="toc-text">四、部署与实现现状</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%AF%E6%8C%81"><span class="toc-text">4.1 客户端支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%94%AF%E6%8C%81"><span class="toc-text">4.2 服务器端支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-DNS-%E9%85%8D%E7%BD%AE"><span class="toc-text">4.3 DNS 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">五、安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src= "/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-32.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>