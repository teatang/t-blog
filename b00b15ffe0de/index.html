<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>日志采集方案Loki详解：轻量、高效、可扩展 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在云原生时代，日志是可观测性（Observability）的三大支柱之一（另外两个是指标和链路追踪）。传统的日志系统（如 ELK Stack）虽然功能强大，但其高昂的存储成本和复杂的运维管理一直是挑战。Loki 作为一种新一代的日志聚合系统，以其独特的“只索引标签，不索引全文”的设计理念，提供了成本效益高、易于部署和管理的日志解决方案，尤其适合 Kubernetes 环境。  核心思想：Loki">
<meta property="og:type" content="article">
<meta property="og:title" content="日志采集方案Loki详解：轻量、高效、可扩展">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/b00b15ffe0de/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在云原生时代，日志是可观测性（Observability）的三大支柱之一（另外两个是指标和链路追踪）。传统的日志系统（如 ELK Stack）虽然功能强大，但其高昂的存储成本和复杂的运维管理一直是挑战。Loki 作为一种新一代的日志聚合系统，以其独特的“只索引标签，不索引全文”的设计理念，提供了成本效益高、易于部署和管理的日志解决方案，尤其适合 Kubernetes 环境。  核心思想：Loki">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg">
<meta property="article:published_time" content="2025-02-10T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-28T10:16:29.727Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="Prometheus">
<meta property="article:tag" content="Grafana">
<meta property="article:tag" content="数据监控">
<meta property="article:tag" content="Loki">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "日志采集方案Loki详解：轻量、高效、可扩展",
  "url": "https://blog.tbf1211.xx.kg/b00b15ffe0de/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-13.jpg",
  "datePublished": "2025-02-10T22:24:00.000Z",
  "dateModified": "2026-01-28T10:16:29.727Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/b00b15ffe0de/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '日志采集方案Loki详解：轻量、高效、可扩展',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">529</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-13.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">日志采集方案Loki详解：轻量、高效、可扩展</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">日志采集方案Loki详解：轻量、高效、可扩展</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-02-10T22:24:00.000Z" title="发表于 2025-02-11 06:24:00">2025-02-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7/">数据监控</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在云原生时代，日志是可观测性（Observability）的三大支柱之一（另外两个是指标和链路追踪）。传统的日志系统（如 ELK Stack）虽然功能强大，但其高昂的存储成本和复杂的运维管理一直是挑战。<strong>Loki</strong> 作为一种新一代的日志聚合系统，以其独特的“只索引标签，不索引全文”的设计理念，提供了成本效益高、易于部署和管理的日志解决方案，尤其适合 Kubernetes 环境。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<br><strong>Loki 是一个受 Prometheus 启发而设计的日志聚合系统，它不索引日志内容本身，而是通过少量标签对日志流（log stream）进行索引。这种设计显著降低了存储和索引的成本，使得用户可以通过标签过滤日志流，然后进行 Grep 式的全文搜索。它是 Grafana Labs 家族产品的一员，与 Prometheus 和 Grafana 紧密集成，提供了统一的可观测性体验。</strong></p>
</div>

<hr>
<h2 id="一、Loki-简介与核心理念"><a href="#一、Loki-简介与核心理念" class="headerlink" title="一、Loki 简介与核心理念"></a>一、Loki 简介与核心理念</h2><p>Loki 是 Grafana Labs 于 2018 年开源的日志聚合系统。其设计的核心理念与 Prometheus 有着异曲同工之处：</p>
<ul>
<li><strong>受 Prometheus 启发</strong>：Loki 的数据模型、标签（labels）使用、查询语言（LogQL）和架构设计都深受 Prometheus 的影响。</li>
<li><strong>只索引标签 (Index Labels Only)</strong>：这是 Loki 最核心的创新。与传统日志系统不同，Loki 不对日志的全文内容进行索引。它只提取和索引与日志流相关的少量元数据标签。这意味着：<ul>
<li><strong>低存储成本</strong>：因为没有全文索引，索引数据量远小于传统方案。</li>
<li><strong>低运维复杂度</strong>：索引规模小，管理起来更简单。</li>
<li><strong>快速查询，但有局限性</strong>：查询首先通过标签快速筛选出相关的日志流，然后对这些日志流的原始内容进行 Grep 式的文本搜索。这意味着在没有特定标签的情况下进行大规模的全文搜索可能会很慢。</li>
</ul>
</li>
</ul>
<h3 id="1-1-为什么要选择-Loki？"><a href="#1-1-为什么要选择-Loki？" class="headerlink" title="1.1 为什么要选择 Loki？"></a>1.1 为什么要选择 Loki？</h3><ol>
<li><strong>成本效益</strong>：显著降低日志存储和索引的成本，这一点对于大规模分布式系统尤为重要。</li>
<li><strong>简单易用</strong>：部署和配置相对简单，尤其是对于熟悉 Prometheus 的用户。</li>
<li><strong>与 Grafana 紧密集成</strong>：作为 Grafana Labs 的产品，Loki 与 Grafana 的集成达到了无缝对接的程度，提供了统一的指标、日志和追踪数据的可观测性平台。</li>
<li><strong>Prometheus 风格的查询语言 (LogQL)</strong>：对于熟悉 PromQL 的用户，学习 LogQL 的曲线非常平缓。</li>
<li><strong>云原生友好</strong>：为 Kubernetes 环境设计优化，可以方便地通过 DaemonSet 部署 <code>Promtail</code> 进行日志采集。</li>
</ol>
<h3 id="1-2-Loki-的术语与概念"><a href="#1-2-Loki-的术语与概念" class="headerlink" title="1.2 Loki 的术语与概念"></a>1.2 Loki 的术语与概念</h3><ul>
<li><strong>日志流 (Log Stream)</strong>：由一个唯一的标签集（例如 <code>&#123;job=&quot;nginx&quot;, instance=&quot;web-01&quot;&#125;</code>）标识的一组时间排序的日志条目。Loki 的索引就是这些标签集。</li>
<li><strong>标签 (Labels)</strong>：与 Prometheus 类似，标签是键值对，用于唯一标识一个日志流。它们是 Loki 查询的关键。</li>
<li><strong>条目 (Entry)</strong>：日志流中的单个日志行，包含一个时间戳和一个原始日志文本。</li>
<li><strong>LogQL</strong>：Loki 的查询语言，用于查询和聚合日志数据。它结合了标签选择器和文本过滤器。</li>
<li><strong>Chunk (块)</strong>：Loki 内部存储日志的基本单元。每个 Chunk 包含一个或多个日志流的日志条目，并以压缩格式存储。</li>
<li><strong>Ingester (摄取器)</strong>：Loki 的组件，负责接收 <code>Promtail</code> 等客户端发送的日志，进行标签处理，并将日志写入 Chunk，最终持久化到存储。</li>
<li><strong>Querier (查询器)</strong>：Loki 的组件，负责接收 LogQL 查询，从索引读取标签并找到相关的 Chunk，然后从存储中拉取 Chunk 进行文本搜索和返回结果。</li>
<li><strong>Distributor (分配器)</strong>：Loki 的前端服务，负责接收 <code>Promtail</code> 发送的日志，并将其负载均衡到 Ingester。</li>
<li><strong>Pusher (推送器)</strong>：<code>Promtail</code> 内部的组件，负责将日志推送到 <code>Distributor</code>。</li>
</ul>
<h2 id="二、Loki-架构"><a href="#二、Loki-架构" class="headerlink" title="二、Loki 架构"></a>二、Loki 架构</h2><p>Loki 的架构设计与 Prometheus 类似，通常采用微服务组件化，但在小规模部署时也可以作为单一二进制文件运行（<code>monolithic</code> 模式）。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph &quot;Clients (Log Collectors)&quot;
        P1[Promtail&#x2F;Fluent Bit&#x2F;Fluentd] --- D;
        P2[Application Logs] -- Instrument --&gt; P1;
        P3[System Logs] -- Instrument --&gt; P1;
    end

    subgraph Loki Cluster
        D[Distributor]
        I[Ingester]
        Q[Querier]
        C[&quot;Compactor (Optional)&quot;]
        R[&quot;Ruler (Alerting, Optional)&quot;]
        H[&quot;Index Store (Boltdb, Cassandra, S3, etc.)&quot;] -- Index --&gt; D;
        H -- Index --&gt; Q;
        S[&quot;Chunk Store (S3, GCS, MinIO, Filesystem)&quot;] -- Chunks --&gt; I;
        S -- Chunks --&gt; Q;

        D -- write logs --&gt; I;
        Q -- query logs --&gt; I;
        Q -- query logs --&gt; S;
    end

    subgraph Visualization &amp; Alerting
        B[Grafana] --&gt; Q;
        R --&gt; Alertmanager;
    end
  </pre></div>

<p><strong>主要组件：</strong></p>
<ol>
<li><strong>Clients (日志收集器)</strong>：<ul>
<li><strong>Promtail</strong> (推荐)：Grafana Labs 官方提供的日志收集代理，设计用于与 Loki 配合使用。它部署在每个节点上，负责从指定路径、Docker 日志等文件中抓取日志，并将其标签化（从 Kubernetes 元数据、文件名路径等提取），然后推送到 Loki 的 Distributor。</li>
<li><strong>Fluent Bit &#x2F; Fluentd</strong>：也可以用于收集日志并将其转发到 Loki。需要配置相应的 Loki 输出插件。</li>
</ul>
</li>
<li><strong>Distributor (分配器)</strong>：<ul>
<li>接收来自客户端的日志流。</li>
<li>对接收到的日志进行验证和预处理。</li>
<li>通过一致性哈希将日志流分配给 Ingester 进行处理，确保相同标签集的日志流被路由到同一个 Ingester。</li>
</ul>
</li>
<li><strong>Ingester (摄取器)</strong>：<ul>
<li>负责接收 Distributor 分配的日志流。</li>
<li>将收到的日志条目压缩并构建成内存中的 Chunk。</li>
<li>定期将 Chunk 刷写（flush）到 Chunk Store（如 S3）。</li>
<li>将日志流的标签索引写入 Index Store（如 DynamoDB）。</li>
</ul>
</li>
<li><strong>Querier (查询器)</strong>：<ul>
<li>接收 LogQL 查询。</li>
<li>首先通过 Index Store 查找与查询标签匹配的日志流。</li>
<li>然后向所有 Ingester 查询内存中的 Chunk，以及向 Chunk Store 查询已持久化的 Chunk。</li>
<li>对查询到的原始日志数据执行 Grep 式的文本过滤和处理。</li>
<li>将结果返回给客户端 (Grafana)。</li>
</ul>
</li>
<li><strong>Index Store (索引存储)</strong>：<ul>
<li>存储日志流的标签索引，而非日志全文。这是 Loki 低成本的核心。</li>
<li>支持多种后端，如 AWS DynamoDB, Google Bigtable, Apache Cassandra, BoltDB（单体模式）。</li>
</ul>
</li>
<li><strong>Chunk Store (块存储)</strong>：<ul>
<li>存储实际的原始日志数据 Chunk。</li>
<li>支持多种后端，如 AWS S3, Google Cloud Storage, Azure Blob Storage, MinIO, 文件系统。</li>
</ul>
</li>
<li><strong>Compactor (压缩器)</strong> (可选)：在某些存储后端（如 S3）上，可以将小的 Chunk 合并成更大的 Chunk，以优化存储和查询效率。</li>
<li><strong>Ruler (规则管理器)</strong> (可选)：允许用户基于 LogQL 表达式定义警报规则，并在满足条件时触发警报到 Alertmanager。</li>
</ol>
<h2 id="三、Promtail-日志采集代理"><a href="#三、Promtail-日志采集代理" class="headerlink" title="三、Promtail - 日志采集代理"></a>三、Promtail - 日志采集代理</h2><p><strong>Promtail</strong> 是 Loki 的官方日志收集代理，被设计成与 Loki 和 Kubernetes 环境紧密集成。</p>
<h3 id="3-1-Promtail-的工作原理"><a href="#3-1-Promtail-的工作原理" class="headerlink" title="3.1 Promtail 的工作原理"></a>3.1 Promtail 的工作原理</h3><ol>
<li><strong>Tailing (跟踪)</strong>：Promtail 像 <code>tail -f</code> 一样跟踪本地文件系统上的日志文件。</li>
<li><strong>提取标签 (Scraping&#x2F;Labeling)</strong>：Promtail 从日志文件的路径、Kubernetes Pod 的元数据（如 Pod 名称、Namespace、容器名称）中提取标签。它还支持通过 <code>relabel_configs</code> 从日志内容中提取额外标签。</li>
<li><strong>日志流化 (Stream Creation)</strong>：每个独特的标签集构成了 Loki 中的一个日志流。</li>
<li><strong>推送 (Pushing)</strong>：Promtail 将带有标签的日志条目推送到 Loki 的 Distributor。</li>
</ol>
<h3 id="3-2-Promtail-配置示例-promtail-config-yaml"><a href="#3-2-Promtail-配置示例-promtail-config-yaml" class="headerlink" title="3.2 Promtail 配置示例 (promtail-config.yaml)"></a>3.2 Promtail 配置示例 (promtail-config.yaml)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http_listen_port:</span> <span class="number">9080</span></span><br><span class="line">  <span class="attr">grpc_listen_port:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">positions:</span></span><br><span class="line">  <span class="attr">filename:</span> <span class="string">/tmp/positions.yaml</span> <span class="comment"># 记录 Promtail 已处理的日志文件位置，防止重复收集</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clients:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">http://loki.loki.svc.cluster.local:3100/loki/api/v1/push</span> <span class="comment"># Loki Distributor 的地址</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># 监听 Kubernetes Pod 日志</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">kubernetes-pods</span></span><br><span class="line">    <span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">role:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="comment"># 获取 namespace 标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_namespace</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">namespace</span></span><br><span class="line">      <span class="comment"># 获取 Pod 名称标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_name</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">pod</span></span><br><span class="line">      <span class="comment"># 获取容器名称标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_container_name</span>]</span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">container</span></span><br><span class="line">      <span class="comment"># 从文件路径中获取 app 标签（假设日志路径是 /var/log/pods/&lt;namespace&gt;_&lt;pod-name&gt;/&lt;container-name&gt;/&lt;app-name&gt;*.log）</span></span><br><span class="line">      <span class="comment"># 更常见的做法是从 k8s annotations 获取，这里简化</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_uid</span>] <span class="comment"># 确保唯一性，日志文件路径一般包含UID</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">_temp_pod_uid</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 匹配日志文件的实际路径</span></span><br><span class="line">      <span class="comment"># 通常 Kubernetes 日志路径格式为 /var/log/pods/&lt;namespace&gt;_&lt;pod-name&gt;_&lt;pod-uid&gt;/&lt;container-name&gt;/&lt;replica-id&gt;.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_annotation_kubernetes_io_config_hash</span>] <span class="comment"># 使用可以从pod annotation提取的稳定标识</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">_temp_app_name</span> <span class="comment"># 临时标签用于后续提取</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__path__</span>] <span class="comment"># promtail 会默认添加 __path__ 标签</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">.*\/pods\/(?:a-z0-9</span> [<span class="string">&lt;sup&gt;1&lt;/sup&gt;</span>]<span class="string">(?:[-a-z0-9]*[a-z0-9])?_)&#123;1,&#125;(?P&lt;pod_name&gt;a-z0-9</span> [<span class="string">&lt;sup&gt;1&lt;/sup&gt;</span>]<span class="string">(?:[-a-z0-9]*[a-z0-9])?(?:_a-z0-9</span> [<span class="string">&lt;sup&gt;1&lt;/sup&gt;</span>]<span class="string">(?:[-a-z0-9]*[a-z0-9])?)*)\/(?P&lt;container_name&gt;a-z0-9</span> [<span class="string">&lt;sup&gt;2&lt;/sup&gt;</span>]<span class="string">((_?[a-z0-9])*)?)(\/.*)?\.log</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__path__</span> <span class="comment"># 保持原始 __path__</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_container_name</span>]</span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">container</span> <span class="comment"># 重置以确保准确性</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 提取 job 标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> [<span class="string">__meta_kubernetes_pod_label_app</span>] <span class="comment"># 假设 Pod 有 app 标签</span></span><br><span class="line">        <span class="attr">action:</span> <span class="string">replace</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">(.+)</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 最终日志流标签：job, namespace, pod, container, app</span></span><br><span class="line">      <span class="comment"># 重要的： drop 掉 Promtail 内部不需要的标签，只保留最终发送给 Loki 的实际标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labelmap</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">__meta_kubernetes_pod_label_(.+)</span> <span class="comment"># 将所有 pod label 转换为日志标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labeldrop</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">&quot;__meta_kubernetes_.*&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labeldrop</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">&quot;filename|path&quot;</span> <span class="comment"># 避免将 filename 和 path 作为标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">labeldrop</span></span><br><span class="line">        <span class="attr">regex:</span> <span class="string">&quot;_temp_.*&quot;</span> <span class="comment"># 删除临时标签</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">pipeline_stages:</span></span><br><span class="line">      <span class="comment"># 解析 JSON 格式日志</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">json:</span></span><br><span class="line">          <span class="attr">expressions:</span></span><br><span class="line">            <span class="attr">level:</span> <span class="string">level</span> <span class="comment"># 将 JSON 字段 level 提取为 label level</span></span><br><span class="line">            <span class="attr">msg:</span> <span class="string">message</span> <span class="comment"># 将 JSON 字段 message 作为日志内容</span></span><br><span class="line">          <span class="comment"># set_extra_label: &#123; &quot;log_type&quot;: &quot;json&quot; &#125; # 也可以添加固定标签</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 或者解析 Regex 格式日志</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">regex:</span></span><br><span class="line">          <span class="attr">expression:</span> <span class="string">&#x27;^(?P&lt;time&gt;\S+)\s+(?P&lt;level&gt;\S+)\s+(?P&lt;caller&gt;\S+)\s+(?P&lt;message&gt;.*)$&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">level:</span> <span class="comment"># 将正则提取的 level 字段作为标签</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">timestamp:</span></span><br><span class="line">          <span class="attr">format:</span> <span class="string">RFC3339Nano</span></span><br><span class="line">          <span class="attr">source:</span> <span class="string">time</span> <span class="comment"># 将正则提取的 time 字段作为时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义要从哪些路径抓取日志</span></span><br><span class="line">    <span class="comment"># 通常 Promtail 运行在 Kubernetes DaemonSet 中，会挂载 /var/log/pods</span></span><br><span class="line">    <span class="comment"># 或 /var/lib/docker/containers/&lt;container-id&gt;/*.log 路径</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">__path__:</span> <span class="string">/var/log/pods/*/*/*.log</span></span><br></pre></td></tr></table></figure>

<p>注意：上述 Promtail 配置针对 Kubernetes 环境下的日志抓取和标签提取是一个复杂且高度可定制的过程。实际生产环境的 <code>relabel_configs</code> 和 <code>pipeline_stages</code> 会更复杂，需要根据具体的日志格式和 Kubernetes 资源标签进行调整。</p>
<h2 id="四、LogQL-Loki-的查询语言"><a href="#四、LogQL-Loki-的查询语言" class="headerlink" title="四、LogQL - Loki 的查询语言"></a>四、LogQL - Loki 的查询语言</h2><p><strong>LogQL</strong> 是 Loki 的查询语言，其语法灵感来源于 Prometheus 的 PromQL。它允许你通过标签选择器过滤日志流，然后通过文本过滤器进一步筛选日志内容，甚至进行日志内容的聚合和转换。</p>
<p>LogQL 查询通常分为两个部分：</p>
<ol>
<li><strong>日志流选择器 (Log Stream Selector)</strong>：用于匹配日志流的标签。</li>
<li><strong>日志管道 (Log Pipeline)</strong>：对匹配到的日志流中的日志内容进行过滤、解析和转换。</li>
</ol>
<h3 id="4-1-日志流选择器"><a href="#4-1-日志流选择器" class="headerlink" title="4.1 日志流选择器"></a>4.1 日志流选择器</h3><p>与 PromQL 类似，使用 <code>&#123;&#125;</code> 来匹配标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 匹配所有 job=nginx 的日志流</span><br><span class="line">&#123;job=&quot;nginx&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 匹配 namespace 为 default 且 pod 是以 web- 开头的日志流</span><br><span class="line">&#123;namespace=&quot;default&quot;, pod=~&quot;web-.*&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 匹配容器名称不是 promtail 的所有日志流</span><br><span class="line">&#123;container!=&quot;promtail&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-日志管道-Log-Pipeline"><a href="#4-2-日志管道-Log-Pipeline" class="headerlink" title="4.2 日志管道 (Log Pipeline)"></a>4.2 日志管道 (Log Pipeline)</h3><p>日志管道允许你对日志流中的文本条目进行进一步处理。</p>
<h4 id="4-2-1-文本过滤器-Line-Filters"><a href="#4-2-1-文本过滤器-Line-Filters" class="headerlink" title="4.2.1 文本过滤器 (Line Filters)"></a>4.2.1 文本过滤器 (Line Filters)</h4><p>用于 Grep 式的文本匹配。</p>
<ul>
<li><strong><code>|=</code> (包含)</strong>：查询包含指定字符串的日志行。</li>
<li><strong><code>!=</code> (不包含)</strong>：查询不包含指定字符串的日志行。</li>
<li><strong><code>|~</code> (正则匹配)</strong>：查询匹配指定正则表达式的日志行。</li>
<li><strong><code>!~</code> (正则不匹配)</strong>：查询不匹配指定正则表达式的日志行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 匹配包含 &quot;error&quot; 字符串的日志行</span><br><span class="line">&#123;job=&quot;nginx&quot;&#125; |= &quot;error&quot;</span><br><span class="line"></span><br><span class="line"># 匹配不包含 &quot;health check&quot; 的日志行</span><br><span class="line">&#123;job=&quot;nginx&quot;&#125; != &quot;health check&quot;</span><br><span class="line"></span><br><span class="line"># 匹配包含 &quot;failed&quot; 或 &quot;denied&quot; 的日志行</span><br><span class="line">&#123;job=&quot;nginx&quot;&#125; |~ &quot;failed|denied&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-解析器-Parsers"><a href="#4-2-2-解析器-Parsers" class="headerlink" title="4.2.2 解析器 (Parsers)"></a>4.2.2 解析器 (Parsers)</h4><p>用于从日志行中提取结构化数据，可以是从 JSON、Logfmt 或者正则表达式中提取。</p>
<ul>
<li><strong><code>| json</code></strong>: 解析 JSON 格式日志，提取字段。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 假设日志是 &#123;&quot;level&quot;:&quot;info&quot;, &quot;message&quot;:&quot;User logged in&quot;&#125;</span><br><span class="line">&#123;job=&quot;my_app&quot;&#125; | json</span><br><span class="line"># 现在你可以通过 `level` 标签进行过滤，或者在 Metrics Query 中使用</span><br><span class="line">&#123;job=&quot;my_app&quot;&#125; | json | level=&quot;info&quot;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>| logfmt</code></strong>: 解析 Logfmt 格式日志。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 假设日志是 level=info msg=&quot;User logged in&quot; user_id=123</span><br><span class="line">&#123;job=&quot;my_app&quot;&#125; | logfmt</span><br><span class="line">&#123;job=&quot;my_app&quot;&#125; | logfmt | level=&quot;info&quot; | user_id=&quot;123&quot;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>| regexp &quot;&lt;regex&gt;&quot;</code></strong>: 使用正则表达式提取字段。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 假设日志是 &quot;time=2023-01-01 level=INFO msg=Request from 192.168.1.1&quot;</span><br><span class="line">&#123;job=&quot;my_app&quot;&#125; | regexp &quot;msg=Request from (?P&lt;client_ip&gt;\\S+)&quot;</span><br><span class="line"># 现在你可以通过 `client_ip` 标签进行过滤</span><br><span class="line">&#123;job=&quot;my_app&quot;&#125; | regexp &quot;msg=Request from (?P&lt;client_ip&gt;\\S+)&quot; | client_ip=&quot;192.168.1.1&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-2-3-标签过滤器-Label-Filters"><a href="#4-2-3-标签过滤器-Label-Filters" class="headerlink" title="4.2.3 标签过滤器 (Label Filters)"></a>4.2.3 标签过滤器 (Label Filters)</h4><p>对解析器提取的临时标签进行过滤。</p>
<ul>
<li><code>| &lt;label_name&gt; = &quot;value&quot;</code></li>
<li><code>| &lt;label_name&gt; != &quot;value&quot;</code></li>
<li><code>| &lt;label_name&gt; =~ &quot;regex&quot;</code></li>
<li><code>| &lt;label_name&gt; !~ &quot;regex&quot;</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提取 level 字段后，过滤 level 为 error 的日志</span><br><span class="line">&#123;job=&quot;my_app&quot;&#125; | json | level=&quot;error&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-格式化器-Formatter"><a href="#4-2-4-格式化器-Formatter" class="headerlink" title="4.2.4 格式化器 (Formatter)"></a>4.2.4 格式化器 (Formatter)</h4><ul>
<li><code>| line_format &quot;&#123;&#123;.level&#125;&#125; &#123;&#123;.message&#125;&#125;&quot;</code>: 重新格式化输出的日志行。</li>
</ul>
<h4 id="4-2-5-行限制器-Line-Limiter"><a href="#4-2-5-行限制器-Line-Limiter" class="headerlink" title="4.2.5 行限制器 (Line Limiter)"></a>4.2.5 行限制器 (Line Limiter)</h4><ul>
<li><code>| limit &lt;number&gt;</code>: 限制返回的日志行数。</li>
</ul>
<h3 id="4-3-LogQL-度量查询-Metrics-Query"><a href="#4-3-LogQL-度量查询-Metrics-Query" class="headerlink" title="4.3 LogQL 度量查询 (Metrics Query)"></a>4.3 LogQL 度量查询 (Metrics Query)</h3><p>LogQL 不仅仅用于查看原始日志，它还可以将日志数据转换为指标，这与 PromQL 的功能类似。这在 Grafana 中非常有用，可以将日志中的特定模式转换为可绘制的图表。</p>
<p>常用的度量聚合函数：</p>
<ul>
<li><code>count_over_time(range_vector)</code>：计算在给定时间范围内每个日志流的日志条目数量。</li>
<li><code>sum_by(label_list) (range_vector)</code>：按标签求和。</li>
<li><code>rate(range_vector)</code>：计算每个日志流的每秒日志行数。</li>
<li><code>bytes_rate(range_vector)</code>：计算每个日志流的每秒字节数。</li>
<li><code>bytes_over_time(range_vector)</code>：计算在给定时间范围内每个日志流的总字节数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 统计过去 5 分钟内，每个 job 和 level 的日志出现次数</span><br><span class="line">sum by (job, level) (</span><br><span class="line">  count_over_time(&#123;namespace=&quot;default&quot;&#125; | json | level=~&quot;info|warn|error&quot;[5m])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 计算过去 1 分钟内，每个 pod 的错误日志速率</span><br><span class="line">sum by (pod) (</span><br><span class="line">  rate(&#123;namespace=&quot;default&quot;&#125; |= &quot;error&quot;[1m])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 计算 nginx 服务的 4xx 错误请求率（假设日志中包含 status_code 字段）</span><br><span class="line">sum by (job) (</span><br><span class="line">  rate(&#123;job=&quot;nginx&quot;&#125; | json | status_code=~&quot;4\\d&#123;2&#125;&quot;[1m])</span><br><span class="line">)</span><br><span class="line">/</span><br><span class="line">sum by (job) (</span><br><span class="line">  rate(&#123;job=&quot;nginx&quot;&#125;[1m])</span><br><span class="line">) * 100</span><br></pre></td></tr></table></figure>

<h3 id="4-4-LogQL-警报规则"><a href="#4-4-LogQL-警报规则" class="headerlink" title="4.4 LogQL 警报规则"></a>4.4 LogQL 警报规则</h3><p>你可以在 Loki 的 Ruler 或 Grafana 中基于 LogQL 表达式创建警报规则。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Loki Ruler 告警规则示例</span></span><br><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">loki_alerts</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">HighErrorRate</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="string">sum</span> <span class="string">by</span> <span class="string">(job)</span> <span class="string">(rate(&#123;job=&quot;my_app&quot;&#125;</span> <span class="string">|=</span> <span class="string">&quot;error&quot;</span>[<span class="string">5m</span>]<span class="string">))</span> <span class="string">&gt;</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">warning</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">&quot;应用 <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> 错误率过高&quot;</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">&quot;应用 <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> 在过去 5 分钟内每秒错误日志数量超过 10 条。&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、Grafana-与-Loki-的集成"><a href="#五、Grafana-与-Loki-的集成" class="headerlink" title="五、Grafana 与 Loki 的集成"></a>五、Grafana 与 Loki 的集成</h2><p>Grafana 是 Loki 最常用的前端。它提供了直观的界面来查询和可视化 Loki 中的日志数据。</p>
<h3 id="5-1-配置-Loki-数据源"><a href="#5-1-配置-Loki-数据源" class="headerlink" title="5.1 配置 Loki 数据源"></a>5.1 配置 Loki 数据源</h3><ol>
<li>在 Grafana 中，进入 <code>Configuration</code> -&gt; <code>Data Sources</code>。</li>
<li>点击 <code>Add data source</code>，选择 <code>Loki</code>。</li>
<li>在 <code>URL</code> 字段中输入 Loki Distributor 的地址，例如 <code>http://localhost:3100</code> 或 <code>http://loki.loki.svc.cluster.local:3100</code>。</li>
<li>点击 <code>Save &amp; Test</code>。</li>
</ol>
<h3 id="5-2-Explore-中使用-Loki"><a href="#5-2-Explore-中使用-Loki" class="headerlink" title="5.2 Explore 中使用 Loki"></a>5.2 Explore 中使用 Loki</h3><p>Grafana 的 <code>Explore</code> 功能专门用于探索和调试数据。</p>
<ol>
<li>切换到 <code>Explore</code> 页面。</li>
<li>选择 Loki 数据源。</li>
<li>在查询编辑器中输入 LogQL 表达式。</li>
<li>你可以看到原始日志输出，并且在上方可以切换到 <code>Metrics</code> 模式，将 LogQL 度量查询结果以图表形式展示。</li>
</ol>
<h3 id="5-3-仪表盘中创建日志面板"><a href="#5-3-仪表盘中创建日志面板" class="headerlink" title="5.3 仪表盘中创建日志面板"></a>5.3 仪表盘中创建日志面板</h3><p>可以像创建 Prometheus 面板一样，在 Grafana 仪表盘中创建基于 Loki 的面板。</p>
<ol>
<li>创建一个新的 Dashborad 或编辑现有 Dashboard。</li>
<li>添加一个新的 <code>Logs</code> 面板。</li>
<li>选择 Loki 数据源，输入 LogQL 查询。</li>
<li><code>Logs</code> 面板会直接显示查询到的原始日志数据。</li>
<li>也可以添加 <code>Time Series</code> 面板，输入 LogQL 度量查询，将日志数据转换成图表。</li>
</ol>
<h3 id="5-4-关联指标与日志（Grafana-Loki-Links）"><a href="#5-4-关联指标与日志（Grafana-Loki-Links）" class="headerlink" title="5.4 关联指标与日志（Grafana Loki Links）"></a>5.4 关联指标与日志（Grafana Loki Links）</h3><p>Grafana 提供了一个强大的功能，可以在指标面板和日志面板之间创建关联。当你在一个指标图上发现异常时，可以直接点击图上的点，跳转到相关的日志流，查看对应时间点的详细日志，极大地提高了故障排查效率。</p>
<p>配置步骤：</p>
<ol>
<li><p>在 Prometheus 数据源配置中，添加一个 <code>Data links</code>。</p>
</li>
<li><p>设置 <code>Title</code> 和 <code>URL</code>。URL 可以是 Loki Explore 页面的 URL，并使用模板变量 (<code>$__range_from</code>, <code>$__range_to</code>, <code>$__interval_ms</code>, <code>$__series.labels.&lt;LABEL_NAME&gt;</code>) 来传递标签和时间范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 示例 URL，会跳转到 Loki Explore 页面，并带上 job 标签和时间范围</span><br><span class="line">/explore?orgId=1&amp;left=[&quot;now-1h&quot;,&quot;now&quot;,&quot;LokiDS&quot;,&#123;&quot;expr&quot;:&quot;&#123;job=\&quot;$__series.labels.job\&quot;&#125;&quot;&#125;,&quot;Logs&quot;]</span><br></pre></td></tr></table></figure></li>
<li><p>在 Prometheus 指标面板中，当点击数据点时，就会出现跳转到 Loki 日志的链接。</p>
</li>
</ol>
<h2 id="六、部署与高可用"><a href="#六、部署与高可用" class="headerlink" title="六、部署与高可用"></a>六、部署与高可用</h2><p><strong>部署模式：</strong></p>
<ul>
<li><strong>单体模式 (Monolithic)</strong>：所有 Loki 组件（Distributor, Ingester, Querier, Index, Chunk）都运行在一个进程中。适合小规模部署、测试和开发环境。使用 BoltDB 作为索引，文件系统作为 Chunk Store。</li>
<li><strong>微服务模式 (Microservices)</strong>：每个组件独立运行，可以横向扩展。适合生产环境，可以使用云存储（S3&#x2F;GCS）作为 Chunk Store，DynamoDB&#x2F;Cassandra 等作为 Index Store。</li>
</ul>
<p><strong>高可用性：</strong></p>
<ul>
<li><strong>Distributor&#x2F;Querier</strong>：无状态，通过负载均衡器（如 Nginx, Load Balancer）进行多实例部署，实现高可用。</li>
<li><strong>Ingester</strong>：有状态，通常使用 Kubernetes StatefulSet 部署。需要启用 <strong><code>HA Tracker</code></strong>（基于 Consul 或 Memberlist），确保多个 Ingester 副本之间数据的一致性，防止数据丢失（即当一个 Ingester 宕机时，其负责的日志，在未刷写（flush）到 Chunk Store 之前，由另一个 Ingester 接管）。<strong>Loki 默认有一个短期的 <code>retention</code> 窗口，Ingester 会在内存中保留一段时间的 Chunk，以保证 Ingester 故障时日志不丢失或仅丢失很少量。</strong></li>
<li><strong>存储后端</strong>：通过选择高可用的 Index Store 和 Chunk Store（如云服务商提供的对象存储和 NoSQL 数据库）来保证数据的持久性和可用性。</li>
</ul>
<h2 id="七、Loki-的优缺点"><a href="#七、Loki-的优缺点" class="headerlink" title="七、Loki 的优缺点"></a>七、Loki 的优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li><strong>极高的成本效益</strong>：只索引标签的策略大幅降低了存储和索引成本。</li>
<li><strong>部署和运维简单</strong>：尤其是单体模式，非常轻量。</li>
<li><strong>与 Grafana 无缝集成</strong>：提供统一的可观测性平台。</li>
<li><strong>Prometheus 风格的 LogQL</strong>：降低了学习曲线。</li>
<li><strong>云原生友好</strong>：专为 Kubernetes 和容器化环境设计。</li>
<li><strong>高效的数据压缩</strong>：原始日志数据存储效率高。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>不适合大规模全文搜索</strong>：当需要在大范围（没有特定标签过滤）进行非结构化文本搜索时，性能可能低于传统日志系统。</li>
<li><strong>标签设计至关重要</strong>：查询性能严重依赖于优秀的标签设计。如果标签不够精细，查询可能需要扫描大量日志。</li>
<li><strong>数据模型局限性</strong>：不如 Elasticsearch 那样灵活，无法进行复杂的聚合和分析（例如，不能直接计算平均请求延迟，只能统计日志行的数量或字节数）。</li>
<li><strong>实时性</strong>：日志写入 Ingester 后有一段在内存中缓存的时间，才会刷入永久存储，这可能导致在 Ingester 故障时短时间内的数据丢失（尽管有 HA Tracker 机制来缓解）。</li>
</ul>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>Loki 作为云原生时代的新型日志聚合系统，以其独特的设计理念，成功地平衡了日志可观测性的成本与功能。它通过高度抽象的标签索引和 Grep 式的查询模式，为用户提供了一个轻量、高效且与 Prometheus 和 Grafana 完美集成的日志解决方案。虽然它在某些方面不如传统的 ELK Stack 强大，但在许多场景下，特别是对存储成本敏感且希望获得统一可观测体验的用户而言，Loki 是一个极具吸引力的选择。理解其架构、Promtail 的配置和 LogQL 的使用是成功部署和利用 Loki 的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/b00b15ffe0de/">https://blog.tbf1211.xx.kg/b00b15ffe0de/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/Prometheus/">Prometheus</a><a class="post-meta__tags" href="/tags/Grafana/">Grafana</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7/">数据监控</a><a class="post-meta__tags" href="/tags/Loki/">Loki</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-13.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/08a7bab723f9/" title="Metasploit exploit/multi/handler 模块详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Metasploit exploit/multi/handler 模块详解</div></div><div class="info-2"><div class="info-item-1"> exploit/multi/handler 是 Metasploit 框架中一个极其重要且应用广泛的模块。它本身并不是一个漏洞利用模块，而是一个通用的监听器（Listener），用于接收由 Metasploit 或 msfvenom 生成的各种 Payload 发起的反向连接（Reverse Shell）。它提供了一个灵活且强大的平台，用于管理渗透测试过程中获取的 Shell 会话，特别是 Meterpreter 会话。  核心思想：提供一个通用的、模块化的监听接口，等待远程目标系统主动连接，从而建立一个控制通道。它与用于生成Payload的msfvenom紧密配合，实现无缝的端到端攻击链。   一、exploit/multi/handler 简介1.1 什么是 exploit/multi/handler？exploit/multi/handler 是 Metasploit 中的一个混合型模块 (Auxiliary&#x2F;Exploit)。它被归类为 exploit，因为它最终目的是“利用”系统并获得 Shell，但它实际上不包含任何漏洞利用代码。它的主要功能是：  监听反...</div></div></div></a><a class="pagination-related" href="/13596be529bf/" title="Python神库Pydantic深度解析：数据验证与设置管理的利器"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python神库Pydantic深度解析：数据验证与设置管理的利器</div></div><div class="info-2"><div class="info-item-1"> Pydantic 是一个 Python 库，用于数据验证和设置管理，它利用 Python 的类型提示 (type hints) 来定义数据模式。Pydantic 在运行时强制执行类型提示，并为您的数据提供友好的错误信息，使得数据模型更加健壮、可维护和自文档化。它广泛应用于 Web API (如 FastAPI)、数据科学、配置管理等领域。  核心思想：将 Python 的类型提示转化为强大的运行时数据验证和序列化工具，从而提高代码的健壮性和开发效率。   一、为什么需要 Pydantic？在现代 Python 应用开发中，数据从外部来源（如 JSON API、数据库、配置文件、用户输入）进入系统是常态。这些外部数据往往不可信，结构复杂且容易出错。传统的 Python 处理方式存在一些问题：  缺乏数据验证：直接使用字典或弱类型对象，无法保证数据的结构和类型正确性，容易导致运行时错误。 手动验证繁琐：编写大量的 if/else 语句进行数据类型检查和值验证，导致代码冗长、难以维护。 序列化&#x2F;反序列化复杂：将 Python 对象转换为 JSON&#x2F;XML 或反之，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/279d3819bd1b/" title="Prometheus与Grafana详解：现代监控的黄金组合"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-27</div><div class="info-item-2">Prometheus与Grafana详解：现代监控的黄金组合</div></div><div class="info-2"><div class="info-item-1"> 在现代的云原生和微服务架构中，系统监控是确保服务高可用和性能稳定的基石。Prometheus 和 Grafana 是这一领域中最受欢迎且功能强大的组合。Prometheus 负责数据的收集和存储，而 Grafana 则专注于数据的可视化和警报。两者协同工作，为开发者和运维人员提供了全面的可观测性和洞察力。  核心思想：Prometheus 是一个开源的系统监控和警报工具包，以其基于 Pull 模型的指标采集方式和强大的多维数据模型而闻名。Grafana 是一个开源的数据可视化和仪表盘工具，支持多种数据源，提供高度定制化的图表和警报功能。它们共同构成了高效、灵活的监控解决方案。    一、Prometheus 详解1.1 Prometheus 简介与核心概念Prometheus 是一个开源的监控系统，最初由 SoundCloud 开发并于 2016 年加入云原生计算基金会（CNCF），成为第二个毕业项目（第一个是 Kubernetes）。它以其强大的多维数据模型、灵活的查询语言（PromQL）和出色的可扩展性而备受青睐。 核心概念：  拉取模型 (Pull Model)：Prom...</div></div></div></a><a class="pagination-related" href="/1432fb2ff226/" title="PromQL详解：深入理解Prometheus查询语言"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-04</div><div class="info-item-2">PromQL详解：深入理解Prometheus查询语言</div></div><div class="info-2"><div class="info-item-1"> PromQL (Prometheus Query Language) 是 Prometheus 监控系统中用于实时查询和聚合时间序列数据的强大表达式语言。它是 Prometheus 核心价值的体现之一，通过 PromQL，用户可以灵活地对指标数据进行筛选、聚合、计算和转换，从而深入洞察系统行为、发现问题模式并支持警报规则的定义。掌握 PromQL 是有效利用 Prometheus 进行监控和可观测性的关键。  核心思想：PromQL 允许用户通过组合指标名称、标签选择器、范围选择器、运算符和函数，从 Prometheus 的时序数据库 (TSDB) 中提取、转换和计算数据。它的多维数据模型和向量操作使其在处理和分析复杂的时序数据方面表现出色。    一、PromQL 基础PromQL 表达式返回的结果类型可以是以下四种之一：  即时向量 (Instant vector)：由一组时间序列组成，每个时间序列包含一个时间戳和一个样本值。所有时间序列共享相同的时间戳。例如：http_requests_total。 范围向量 (Range vector)：由一组时间序列组成，每个时间序列...</div></div></div></a><a class="pagination-related" href="/8be247b5e9ae/" title="微调大模型 (Finetuning LLMs) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-20</div><div class="info-item-2">微调大模型 (Finetuning LLMs) 详解</div></div><div class="info-2"><div class="info-item-1"> 微调 (Finetuning) 是人工智能领域，特别是大语言模型 (LLM) 领域中的一项关键技术。它指的是在预训练好的大型模型基础上，使用特定任务或领域的数据集进一步训练模型的过程。通过微调，我们可以将一个通用的、在海量数据上学习到基础语言理解和生成能力的大模型，高效地适配到具体的场景需求，从而显著提升模型在该特定任务上的性能、准确性和可靠性。  核心思想：微调的核心在于利用通用大模型强大的“基础能力”，并通过小规模、高质量的领域数据进行“二次开发”，使其专业化。对于LLM而言，参数高效微调 (PEFT) 极大降低了微调的资源门槛，使其在实践中变得可行且高效。   一、为什么需要微调大模型？通用大语言模型（如 GPT-系列、Llama、Mistral 等）在预训练阶段学习了海量的文本数据，拥有强大的泛化能力、语言理解能力和常识。然而，它们在直接应用于特定任务或领域时仍存在局限性：  知识截止日期 (Knowledge Cut-off)：预训练数据通常有截止日期，模型无法获取最新信息。 幻觉 (Hallucination)：模型可能会生成看似合理但实际上错误或捏造的信息。 领域...</div></div></div></a><a class="pagination-related" href="/18a421861554/" title="Golang 项目的 Makefile 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-17</div><div class="info-item-2">Golang 项目的 Makefile 详解</div></div><div class="info-2"><div class="info-item-1"> Makefile 是一种自动化构建工具，它通过定义文件之间的依赖关系和生成这些文件的命令，帮助开发者管理和自动化项目中的各种任务。尽管 Golang 自身提供了强大的内置工具链 (go build, go test, go run 等)，Makefile 在 Go 项目中依然扮演着重要角色，尤其是在需要协调多个任务、管理复杂构建流程、实现跨平台编译、集成外部工具或自动化部署脚本的场景下。  核心思想：将一系列 go 命令、Shell 脚本以及其他工具的调用封装成可复用的、有依赖关系的任务，实现一键式项目管理和自动化。   一、为什么 Go 项目需要 Makefile？Go 语言的工具链设计得非常出色，go build 能够自动处理依赖，go test 能够运行测试，go run 可以直接运行源代码。那么，为什么我们还需要 Makefile 呢？  任务编排与自动化： 一个 Go 项目通常不仅仅是编译代码。它可能涉及代码格式化 (go fmt)、静态分析 (go vet, golangci-lint)、代码生成 (go generate)、测试、构建 Docker 镜像、部署、清...</div></div></div></a><a class="pagination-related" href="/737a469a0dcc/" title="Golang Testify (Go 测试库) 深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-25</div><div class="info-item-2">Golang Testify (Go 测试库) 深度解析</div></div><div class="info-2"><div class="info-item-1"> Go Testify (github.com/stretchr/testify) 是 Go 语言中一个功能强大且广泛使用的测试工具集。它在 Go 标准库 testing 的基础上，提供了更富有表现力的断言、灵活的 Mock 框架和便捷的测试套件管理功能，旨在简化 Go 程序的测试编写过程，提高测试代码的可读性和可维护性。  核心思想：将 Go 标准测试包的低级别错误检查提升为高级、语义化的断言，并提供解耦的 Mock 和 Suite 管理机制。 这使得测试代码更清晰、更易于编写和理解。   一、为什么需要 Testify？标准库 testing 的局限性Go 语言标准库的 testing 包提供了基础的测试框架，包括测试运行器、t.Error &#x2F; t.Fail &#x2F; t.Fatalf 等错误报告方法。然而，在实际项目中，纯粹使用 testing 包编写测试可能会遇到一些局限性：  断言冗长：标准库没有内置的断言函数。开发者通常需要手动编写大量的 if/else 语句来比较预期值和实际值，并手动报告错误。例如：123if actual != expected &...</div></div></div></a><a class="pagination-related" href="/8f9f1342d7a2/" title="Golang 如何等待多个 Goroutine"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-10</div><div class="info-item-2">Golang 如何等待多个 Goroutine</div></div><div class="info-2"><div class="info-item-1"> Goroutine 是 Go 语言轻量级并发的核心，它使得在程序中同时运行多个任务变得简单高效。然而，当启动多个 Goroutine 后，主程序或管理 Goroutine 常常需要知道这些并发任务何时完成，或者需要等待它们全部完成后再继续执行。这种“等待 Goroutine 完成”的机制是并发编程中至关重要的一环，确保了程序的正确性、资源的有序释放以及结果的汇总。  核心思想：管理 Goroutine 的生命周期是并发编程的关键。Go 提供了 sync.WaitGroup、Channels 以及 context.Context 结合 errgroup.Group 等多种机制，以适应不同复杂度和需求的 Goroutine 等待场景。   一、为什么需要等待 Goroutine？在 Go 语言中，main 函数的 Goroutine 启动后，即使它退出了，其他未完成的 Goroutine 也会继续运行。但通常情况下，我们希望：  确保任务完成：等待所有子 Goroutine 完成计算、I&#x2F;O 操作或数据处理，以避免数据丢失或不完整。 结果汇总：在所有 Goroutine ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">529</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Loki-%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5"><span class="toc-text">一、Loki 简介与核心理念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%89%E6%8B%A9-Loki%EF%BC%9F"><span class="toc-text">1.1 为什么要选择 Loki？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Loki-%E7%9A%84%E6%9C%AF%E8%AF%AD%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text">1.2 Loki 的术语与概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Loki-%E6%9E%B6%E6%9E%84"><span class="toc-text">二、Loki 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Promtail-%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E4%BB%A3%E7%90%86"><span class="toc-text">三、Promtail - 日志采集代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Promtail-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">3.1 Promtail 的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Promtail-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B-promtail-config-yaml"><span class="toc-text">3.2 Promtail 配置示例 (promtail-config.yaml)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81LogQL-Loki-%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-text">四、LogQL - Loki 的查询语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%97%A5%E5%BF%97%E6%B5%81%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-text">4.1 日志流选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%97%A5%E5%BF%97%E7%AE%A1%E9%81%93-Log-Pipeline"><span class="toc-text">4.2 日志管道 (Log Pipeline)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%96%87%E6%9C%AC%E8%BF%87%E6%BB%A4%E5%99%A8-Line-Filters"><span class="toc-text">4.2.1 文本过滤器 (Line Filters)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E8%A7%A3%E6%9E%90%E5%99%A8-Parsers"><span class="toc-text">4.2.2 解析器 (Parsers)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%A0%87%E7%AD%BE%E8%BF%87%E6%BB%A4%E5%99%A8-Label-Filters"><span class="toc-text">4.2.3 标签过滤器 (Label Filters)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8-Formatter"><span class="toc-text">4.2.4 格式化器 (Formatter)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E8%A1%8C%E9%99%90%E5%88%B6%E5%99%A8-Line-Limiter"><span class="toc-text">4.2.5 行限制器 (Line Limiter)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-LogQL-%E5%BA%A6%E9%87%8F%E6%9F%A5%E8%AF%A2-Metrics-Query"><span class="toc-text">4.3 LogQL 度量查询 (Metrics Query)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-LogQL-%E8%AD%A6%E6%8A%A5%E8%A7%84%E5%88%99"><span class="toc-text">4.4 LogQL 警报规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Grafana-%E4%B8%8E-Loki-%E7%9A%84%E9%9B%86%E6%88%90"><span class="toc-text">五、Grafana 与 Loki 的集成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%85%8D%E7%BD%AE-Loki-%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">5.1 配置 Loki 数据源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Explore-%E4%B8%AD%E4%BD%BF%E7%94%A8-Loki"><span class="toc-text">5.2 Explore 中使用 Loki</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BB%AA%E8%A1%A8%E7%9B%98%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97%E9%9D%A2%E6%9D%BF"><span class="toc-text">5.3 仪表盘中创建日志面板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%85%B3%E8%81%94%E6%8C%87%E6%A0%87%E4%B8%8E%E6%97%A5%E5%BF%97%EF%BC%88Grafana-Loki-Links%EF%BC%89"><span class="toc-text">5.4 关联指标与日志（Grafana Loki Links）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">六、部署与高可用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Loki-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">七、Loki 的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-13.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>