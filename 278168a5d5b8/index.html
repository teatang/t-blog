<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>PHP 惰性求值与生成器 (Generators) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="惰性求值 (Lazy Evaluation) 是一种编程策略，它将表达式的计算延迟到真正需要其结果时才进行。在 PHP 中，实现惰性求值最主要的机制就是生成器 (Generators)。生成器允许开发者编写像迭代器一样遍历数据集合的函数，而无需将整个集合一次性加载到内存中。这对于处理大型数据集、无限序列或需要节省内存的场景至关重要。  核心思想：生成器通过 yield 关键字实现了惰性求值，它允">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP 惰性求值与生成器 (Generators) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/278168a5d5b8/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="惰性求值 (Lazy Evaluation) 是一种编程策略，它将表达式的计算延迟到真正需要其结果时才进行。在 PHP 中，实现惰性求值最主要的机制就是生成器 (Generators)。生成器允许开发者编写像迭代器一样遍历数据集合的函数，而无需将整个集合一次性加载到内存中。这对于处理大型数据集、无限序列或需要节省内存的场景至关重要。  核心思想：生成器通过 yield 关键字实现了惰性求值，它允">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2023-02-23T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-09T14:05:11.590Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="PHP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PHP 惰性求值与生成器 (Generators) 详解",
  "url": "https://blog.tbf1211.xx.kg/278168a5d5b8/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2023-02-23T22:24:00.000Z",
  "dateModified": "2026-01-09T14:05:11.590Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/278168a5d5b8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PHP 惰性求值与生成器 (Generators) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">481</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">PHP 惰性求值与生成器 (Generators) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">PHP 惰性求值与生成器 (Generators) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-02-23T22:24:00.000Z" title="发表于 2023-02-24 06:24:00">2023-02-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PHP/">PHP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>惰性求值 (Lazy Evaluation)</strong> 是一种编程策略，它将表达式的计算延迟到真正需要其结果时才进行。在 PHP 中，实现惰性求值最主要的机制就是<strong>生成器 (Generators)</strong>。生成器允许开发者编写像迭代器一样遍历数据集合的函数，而无需将整个集合一次性加载到内存中。这对于处理大型数据集、无限序列或需要节省内存的场景至关重要。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>生成器通过 <code>yield</code> 关键字实现了惰性求值，它允许函数暂停执行并返回一个值，并在下次需要时从暂停的地方继续执行，从而按需生成数据，大幅减少内存占用。</strong></p>
</div>
<hr>
<h2 id="一、理解惰性求值-Lazy-Evaluation"><a href="#一、理解惰性求值-Lazy-Evaluation" class="headerlink" title="一、理解惰性求值 (Lazy Evaluation)"></a>一、理解惰性求值 (Lazy Evaluation)</h2><h3 id="1-1-什么是惰性求值？"><a href="#1-1-什么是惰性求值？" class="headerlink" title="1.1 什么是惰性求值？"></a>1.1 什么是惰性求值？</h3><p>传统的“饥饿求值 (Eager Evaluation)”或“及早求值”模式下，当一个函数或表达式被调用时，其所有参数都会在函数体执行前被完全计算。例如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"><span class="keyword">int</span> <span class="variable">$a</span>, <span class="keyword">int</span> <span class="variable">$b</span></span>): <span class="title">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span> + <span class="variable">$b</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sum</span>(<span class="title function_ invoke__">expensiveCalculationA</span>(), <span class="title function_ invoke__">expensiveCalculationB</span>()); <span class="comment">// 两个计算都会立即执行</span></span><br></pre></td></tr></table></figure>

<p>而<strong>惰性求值</strong>则相反，它不会立即计算表达式的结果，而是返回一个“承诺”或“句柄”，只有当结果真正被使用时，才会触发实际的计算。</p>
<h3 id="1-2-惰性求值的优势"><a href="#1-2-惰性求值的优势" class="headerlink" title="1.2 惰性求值的优势"></a>1.2 惰性求值的优势</h3><ol>
<li><strong>内存效率</strong>：对于大型数据集或无限序列，无需一次性将所有数据加载到内存中。数据按需生成，显著降低内存消耗。</li>
<li><strong>性能提升</strong>：避免了不必要的计算。如果某些数据最终没有被使用，那么生成它的开销就完全避免了。</li>
<li><strong>处理无限序列</strong>：可以轻松表示和处理无限序列（例如斐波那契数列、自然数序列），因为它们永远不会被完全生成。</li>
<li><strong>更好的抽象</strong>：允许将数据生成逻辑与数据消费逻辑分离，提高了代码的模块化。</li>
</ol>
<h3 id="1-3-PHP-中的惰性求值实现：生成器"><a href="#1-3-PHP-中的惰性求值实现：生成器" class="headerlink" title="1.3 PHP 中的惰性求值实现：生成器"></a>1.3 PHP 中的惰性求值实现：生成器</h3><p>在 PHP 中，生成器是实现惰性求值的核心机制。一个生成器函数看起来像普通函数，但它使用 <code>yield</code> 关键字而不是 <code>return</code> 关键字来返回值。当一个生成器函数被调用时，它不会立即执行函数体，而是返回一个 <code>Generator</code> 对象。只有当这个 <code>Generator</code> 对象被遍历时，函数体才会被逐步执行。</p>
<h2 id="二、PHP-生成器-Generators-详解"><a href="#二、PHP-生成器-Generators-详解" class="headerlink" title="二、PHP 生成器 (Generators) 详解"></a>二、PHP 生成器 (Generators) 详解</h2><h3 id="2-1-如何创建生成器？"><a href="#2-1-如何创建生成器？" class="headerlink" title="2.1 如何创建生成器？"></a>2.1 如何创建生成器？</h3><p>一个包含 <code>yield</code> 关键字的函数就是一个生成器函数。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myGenerator</span>(<span class="params"></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Generator started.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">// 暂停并返回 1</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Generator resumed after yielding 1.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">// 暂停并返回 2</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Generator resumed after yielding 2.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>; <span class="comment">// 暂停并返回 3</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Generator finished.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用生成器函数不会立即执行其内部代码</span></span><br><span class="line"><span class="variable">$generator</span> = <span class="title function_ invoke__">myGenerator</span>(); </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Generator function called, but not executed yet.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历生成器会触发其内部代码的逐步执行</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$generator</span> <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Received value: &quot;</span> . <span class="variable">$value</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Loop finished.\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Generator function called, but not executed yet.</span><br><span class="line">Generator started.</span><br><span class="line">Received value: 1</span><br><span class="line">Generator resumed after yielding 1.</span><br><span class="line">Received value: 2</span><br><span class="line">Generator resumed after yielding 2.</span><br><span class="line">Received value: 3</span><br><span class="line">Generator finished.</span><br><span class="line">Loop finished.</span><br></pre></td></tr></table></figure>

<p>从输出可以看出：</p>
<ol>
<li>调用 <code>myGenerator()</code> 返回了一个 <code>Generator</code> 对象，但函数体并没有执行。</li>
<li><code>foreach</code> 循环开始时，<code>myGenerator()</code> 的函数体才开始执行，直到第一个 <code>yield</code> 语句。</li>
<li>每次循环获取下一个值时，生成器从上次 <code>yield</code> 暂停的地方继续执行。</li>
</ol>
<h3 id="2-2-yield-关键字"><a href="#2-2-yield-关键字" class="headerlink" title="2.2 yield 关键字"></a>2.2 <code>yield</code> 关键字</h3><p><code>yield</code> 关键字是生成器的核心。它有两个主要作用：</p>
<ol>
<li><strong>暂停执行并返回值</strong>：当生成器遇到 <code>yield value;</code> 时，它会暂停当前函数的执行，并将 <code>value</code> 返回给调用者。</li>
<li><strong>保存状态</strong>：生成器在暂停时会保存其内部状态（包括局部变量、参数和当前执行位置），以便下次从中断点继续执行。</li>
</ol>
<p><code>yield</code> 也可以带有键值对，例如 <code>yield $key =&gt; $value;</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keyValueGenerator</span>(<span class="params"></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span> =&gt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span> =&gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">keyValueGenerator</span>() <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Key: <span class="subst">&#123;$key&#125;</span>, Value: <span class="subst">&#123;$value&#125;</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Generator-对象的方法"><a href="#2-3-Generator-对象的方法" class="headerlink" title="2.3 Generator 对象的方法"></a>2.3 <code>Generator</code> 对象的方法</h3><p>当调用生成器函数时，它返回一个 <code>Generator</code> 类的实例，该类实现了 <code>Iterator</code> 接口，因此可以直接在 <code>foreach</code> 循环中使用。此外，它还提供了一些额外的方法：</p>
<ul>
<li><strong><code>current(): mixed</code></strong>：返回当前 <code>yield</code> 的值。</li>
<li><strong><code>key(): mixed</code></strong>：返回当前 <code>yield</code> 的键。</li>
<li><strong><code>next(): void</code></strong>：恢复生成器的执行，直到下一个 <code>yield</code> 或函数结束。</li>
<li><strong><code>valid(): bool</code></strong>：检查生成器是否还有更多值可生成。</li>
<li><strong><code>rewind(): void</code></strong>：将生成器倒回到起始位置。<strong>注意：大多数生成器只能被遍历一次。尝试对已完成的生成器 <code>rewind()</code> 通常会导致错误。</strong></li>
<li><strong><code>send(mixed $value): mixed</code></strong>：向生成器内部发送一个值，该值将作为 <code>yield</code> 表达式的结果。</li>
<li><strong><code>throw(Throwable $exception): mixed</code></strong>：在生成器暂停的地方抛出一个异常。</li>
<li><strong><code>getReturn(): mixed</code></strong>：在生成器完成执行（即没有更多的 <code>yield</code> 且函数正常结束）后，获取生成器函数中的 <code>return</code> 语句返回的值。</li>
</ul>
<h3 id="2-4-send-方法：双向通信"><a href="#2-4-send-方法：双向通信" class="headerlink" title="2.4 send() 方法：双向通信"></a>2.4 <code>send()</code> 方法：双向通信</h3><p><code>send()</code> 方法允许向生成器内部发送数据，实现生成器与外部的双向通信。<code>send()</code> 传递的值会成为生成器内部 <code>yield</code> 表达式的返回值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">talkativeGenerator</span>(<span class="params"></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$input</span> = <span class="keyword">yield</span> <span class="string">&quot;Please enter your name: &quot;</span>; <span class="comment">// 暂停并返回提示</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Generator received: &quot;</span> . <span class="variable">$input</span> . <span class="string">&quot;\n&quot;</span>; <span class="comment">// 从这里恢复，并接收到外部发送的值</span></span><br><span class="line">  </span><br><span class="line">    <span class="variable">$age</span> = <span class="keyword">yield</span> <span class="string">&quot;Please enter your age: &quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Generator received age: &quot;</span> . <span class="variable">$age</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Goodbye!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$generator</span> = <span class="title function_ invoke__">talkativeGenerator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次 next() 或 current() 会执行到第一个 yield</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$generator</span>-&gt;<span class="title function_ invoke__">current</span>(); <span class="comment">// 输出: Please enter your name: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向生成器发送值 &quot;Alice&quot;，它会成为 `yield &quot;...&quot;` 表达式的结果</span></span><br><span class="line"><span class="variable">$generator</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 这里是 next() 和 send() 的结合，会执行到下一个 yield</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$generator</span>-&gt;<span class="title function_ invoke__">current</span>(); <span class="comment">// 输出: Please enter your age: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次发送值</span></span><br><span class="line"><span class="variable">$generator</span>-&gt;<span class="title function_ invoke__">send</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器已完成，获取返回值</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Generator finished with: &quot;</span> . <span class="variable">$generator</span>-&gt;<span class="title function_ invoke__">getReturn</span>() . <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please enter your name: Generator received: Alice</span><br><span class="line">Please enter your age: Generator received age: 30</span><br><span class="line">Generator finished with: Goodbye!</span><br></pre></td></tr></table></figure>

<h3 id="2-5-yield-from-表达式-PHP-7-0"><a href="#2-5-yield-from-表达式-PHP-7-0" class="headerlink" title="2.5 yield from 表达式 (PHP 7.0+)"></a>2.5 <code>yield from</code> 表达式 (PHP 7.0+)</h3><p><code>yield from</code> 表达式允许将一个生成器（或任何 <code>Traversable</code> 对象）委托给另一个生成器。它会遍历委托的生成器，并将其所有值直接 <code>yield</code> 出来。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerGenerator</span>(<span class="params"></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Inner done!&#x27;</span>; <span class="comment">// PHP 7.0+ 才能获取生成器的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerGenerator</span>(<span class="params"></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="variable">$returnValue</span> = <span class="keyword">yield</span> <span class="keyword">from</span> <span class="title function_ invoke__">innerGenerator</span>(); <span class="comment">// 委托给 innerGenerator</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Inner generator returned: &quot;</span> . <span class="variable">$returnValue</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">outerGenerator</span>() <span class="keyword">as</span> <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Outer generator yielded: &quot;</span> . <span class="variable">$value</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在PHP 7.0+中，可以获取到 outerGenerator 的最终返回值 (如果它有)</span></span><br><span class="line"><span class="comment">// var_dump($outerGenerator-&gt;getReturn());</span></span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Outer generator yielded: 1</span><br><span class="line">Outer generator yielded: a</span><br><span class="line">Outer generator yielded: b</span><br><span class="line">Inner generator returned: Inner done!</span><br><span class="line">Outer generator yielded: 2</span><br></pre></td></tr></table></figure>

<p><code>yield from</code> 使得组合多个生成器变得非常方便，可以构建更复杂的迭代逻辑。</p>
<h2 id="三、生成器的应用场景"><a href="#三、生成器的应用场景" class="headerlink" title="三、生成器的应用场景"></a>三、生成器的应用场景</h2><h3 id="3-1-处理大型文件"><a href="#3-1-处理大型文件" class="headerlink" title="3.1 处理大型文件"></a>3.1 处理大型文件</h3><p>这是生成器最经典的用例。一次性读取大文件会导致内存溢出，而生成器可以逐行读取和处理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLargeFile</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$filePath</span></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$handle</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$filePath</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$handle</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;Could not open file: <span class="subst">&#123;$filePath&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$handle</span>)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="title function_ invoke__">fgets</span>(<span class="variable">$handle</span>); <span class="comment">// 逐行读取</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$handle</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个名为 large_data.txt 的大文件</span></span><br><span class="line"><span class="variable">$filePath</span> = <span class="string">&#x27;large_data.txt&#x27;</span>; </span><br><span class="line"><span class="comment">// 创建一个文件用于测试</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filePath</span>, <span class="title function_ invoke__">implode</span>(<span class="string">&quot;\n&quot;</span>, <span class="title function_ invoke__">array_map</span>(fn(<span class="variable">$i</span>) =&gt; <span class="string">&quot;Line &quot;</span> . <span class="variable">$i</span>, <span class="title function_ invoke__">range</span>(<span class="number">1</span>, <span class="number">100000</span>))));</span><br><span class="line"></span><br><span class="line"><span class="variable">$startTime</span> = <span class="title function_ invoke__">microtime</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$memoryUsage</span> = <span class="title function_ invoke__">memory_get_usage</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="title function_ invoke__">readLargeFile</span>(<span class="variable">$filePath</span>) <span class="keyword">as</span> <span class="variable">$line</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理每一行数据，例如打印或计数</span></span><br><span class="line">    <span class="comment">// echo $line;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Memory usage after processing (MB): &quot;</span> . (<span class="title function_ invoke__">memory_get_usage</span>() - <span class="variable">$memoryUsage</span>) / (<span class="number">1024</span> * <span class="number">1024</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Peak memory usage (MB): &quot;</span> . (<span class="title function_ invoke__">memory_get_peak_usage</span>() / (<span class="number">1024</span> * <span class="number">1024</span>)) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Time taken (s): &quot;</span> . (<span class="title function_ invoke__">microtime</span>(<span class="literal">true</span>) - <span class="variable">$startTime</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">unlink</span>(<span class="variable">$filePath</span>); <span class="comment">// 清理测试文件</span></span><br></pre></td></tr></table></figure>

<p><strong>对比不使用生成器的情况：</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用生成器读取大文件 (可能导致内存溢出)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLargeFileNonGenerator</span>(<span class="params"><span class="keyword">string</span> <span class="variable">$filePath</span></span>): <span class="title">array</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">file</span>(<span class="variable">$filePath</span>); <span class="comment">// 一次性读取所有行到数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $lines = readLargeFileNonGenerator($filePath); // 可能会内存溢出</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-数据库查询"><a href="#3-2-数据库查询" class="headerlink" title="3.2 数据库查询"></a>3.2 数据库查询</h3><p>当从数据库查询大量记录时，ORM 框架通常会一次性将所有结果封装成对象数组，这同样会占用大量内存。许多 ORM 框架（如 Laravel 的 Eloquent）提供了 <code>cursor()</code> 方法，其底层就是使用生成器。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个 PDO 连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchLargeResults</span>(<span class="params">PDO <span class="variable">$pdo</span>, <span class="keyword">string</span> <span class="variable">$query</span></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>(PDO::<span class="variable constant_">FETCH_ASSOC</span>)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable">$row</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="comment">// $pdo = new PDO(...);</span></span><br><span class="line"><span class="comment">// foreach (fetchLargeResults($pdo, &#x27;SELECT * FROM very_large_table&#x27;) as $row) &#123;</span></span><br><span class="line"><span class="comment">//     // 处理每一行数据</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-无限序列生成"><a href="#3-3-无限序列生成" class="headerlink" title="3.3 无限序列生成"></a>3.3 无限序列生成</h3><p>生成器可以非常方便地创建无限序列，例如斐波那契数列、自然数序列等。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciSequence</span>(<span class="params"></span>): <span class="title">Generator</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$a</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable">$a</span>;</span><br><span class="line">        [<span class="variable">$a</span>, <span class="variable">$b</span>] = [<span class="variable">$b</span>, <span class="variable">$a</span> + <span class="variable">$b</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$fib</span> = <span class="title function_ invoke__">fibonacciSequence</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">10</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$fib</span>-&gt;<span class="title function_ invoke__">current</span>() . <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="variable">$fib</span>-&gt;<span class="title function_ invoke__">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出: 0 1 1 2 3 5 8 13 21 34</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-任务调度-协程-PHP-5-5-PHP-8-1"><a href="#3-4-任务调度-协程-PHP-5-5-PHP-8-1" class="headerlink" title="3.4 任务调度&#x2F;协程 (PHP 5.5 - PHP 8.1)"></a>3.4 任务调度&#x2F;协程 (PHP 5.5 - PHP 8.1)</h3><p>在 PHP 8.1 引入 Fibers 之前，生成器是 PHP 中实现用户空间协程和任务调度的主要方式。通过一个外部调度器，可以 <code>send()</code> 值给生成器并 <code>next()</code> 它，模拟上下文切换。虽然现在有了更原生的 Fibers，但理解生成器在此方面的应用有助于理解历史和复杂框架的实现。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个非常简化的协程调度器示例</span></span><br><span class="line"><span class="comment">// 实际的 ReactPHP/Amphp 会更复杂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span>(<span class="params"></span>): <span class="title">Generator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Task A started.\n&quot;</span>;</span><br><span class="line">    <span class="variable">$data</span> = <span class="keyword">yield</span> <span class="string">&#x27;Waiting for data from A&#x27;</span>; <span class="comment">// 暂停，等待外部发送数据</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Task A received: &quot;</span> . <span class="variable">$data</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Task A finished&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskB</span>(<span class="params"></span>): <span class="title">Generator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Task B started.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Waiting for data from B&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Task B finished&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$tasks</span> = [<span class="title function_ invoke__">taskA</span>(), <span class="title function_ invoke__">taskB</span>()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="keyword">empty</span>(<span class="variable">$tasks</span>)) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$tasks</span> <span class="keyword">as</span> <span class="variable">$i</span> =&gt; <span class="variable">$task</span>) &#123;</span><br><span class="line">        <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">next</span>(); <span class="comment">// 推动任务执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$task</span>-&gt;<span class="title function_ invoke__">valid</span>()) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Scheduler received from task <span class="subst">&#123;$i&#125;</span>: &quot;</span> . <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">current</span>() . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$task</span> === <span class="variable">$tasks</span>[<span class="number">0</span>] &amp;&amp; <span class="variable">$task</span>-&gt;<span class="title function_ invoke__">current</span>() === <span class="string">&#x27;Waiting for data from A&#x27;</span>) &#123;</span><br><span class="line">                <span class="variable">$tasks</span>[<span class="number">0</span>]-&gt;<span class="title function_ invoke__">send</span>(<span class="string">&#x27;Hello from Scheduler!&#x27;</span>); <span class="comment">// 向 Task A 发送数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 任务完成</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Task <span class="subst">&#123;$i&#125;</span> completed.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">unset</span>(<span class="variable">$tasks</span>[<span class="variable">$i</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>PHP 生成器是实现惰性求值和优化内存使用的强大工具。通过 <code>yield</code> 关键字，它们允许函数暂停执行、按需生成数据并保存内部状态，从而避免一次性加载所有数据到内存。这在处理大型文件、数据库查询结果、无限序列以及在 PHP 8.1 之前构建协程时都发挥了关键作用。</p>
<p>理解并熟练使用生成器，对于编写高性能、内存高效的 PHP 应用程序至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/278168a5d5b8/">https://blog.tbf1211.xx.kg/278168a5d5b8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/PHP/">PHP</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/234c44d5851b/" title="HTML5 单页面应用 (SPA) 路由实现详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">HTML5 单页面应用 (SPA) 路由实现详解</div></div><div class="info-2"><div class="info-item-1"> 单页面应用 (Single Page Application, SPA) 是一种 Web 应用程序模型，它通过动态重写当前页面而非从服务器加载整个新页面来实现与用户的交互。这种模式极大地提升了用户体验，使其更接近桌面应用。SPA 的核心技术之一是客户端路由 (Client-Side Routing)，它允许应用程序在不进行整页刷新的情况下，根据 URL 路径的变化渲染不同的视图。  核心思想：HTML5 History API 允许 Web 应用程序在客户端直接操纵浏览器会话历史记录，从而实现 URL 的无刷新更新和状态管理，这是现代 SPA 路由的基础。   一、传统页面跳转与 SPA 路由的区别在深入探讨 SPA 路由之前，我们首先理解传统多页面应用 (Multi-Page Application, MPA) 的页面跳转机制及其与 SPA 的根本不同：  传统 MPA 页面跳转：  用户点击链接或提交表单。 浏览器向服务器发送 HTTP 请求，请求新的 HTML 页面。 服务器响应并发送完整的 HTML 文档。 浏览器销毁当前页面，加载并渲染新的 HTML 文档。   特点...</div></div></div></a><a class="pagination-related" href="/109739b91598/" title="Python Matplotlib 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python Matplotlib 详解</div></div><div class="info-2"><div class="info-item-1"> Matplotlib 是一个用于创建静态、动态和交互式可视化在 Python 中的综合库。它提供了强大的工具集，用于生成各种出版质量级别的图表，从简单的线图、散点图到复杂的3D图表和动画。它是 Python 科学计算生态系统（如 NumPy, SciPy, Pandas）中不可或缺的一部分。  核心思想：提供一个灵活、可高度定制的绘图框架，让开发者能够精确控制图表的每一个细节，以满足从数据探索到学术出版的各种可视化需求。   一、为什么需要 Matplotlib？在数据分析、科学研究、工程计算等领域，数据可视化是理解数据、发现模式和传达洞察的关键。然而，手动绘制图表或使用通用工具往往效率低下且难以定制。Matplotlib 旨在解决以下问题：  数据理解：海量数据以表格形式呈现时难以理解，通过图表能够直观展示数据的分布、趋势和关系。 报告与演示：需要高质量、专业级的图表用于学术论文、商业报告或演示文稿。 定制化需求：通用绘图工具可能无法满足特定的可视化需求，需要能够对图表的每个元素（颜色、字体、线条、布局等）进行精确控制。 编程集成：希望在 Python 程序中直接生成和操作图...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2fe79cc940de/" title="PHP 编码规范详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-03</div><div class="info-item-2">PHP 编码规范详解</div></div><div class="info-2"><div class="info-item-1"> PHP 编码规范 旨在提供一套指导原则和最佳实践，以确保 PHP 代码的一致性、可读性、可维护性和团队协作效率。在 PHP 社区中，PSR (PHP Standards Recommendations) 是最广泛接受和遵循的编码规范。遵循这些规范不仅能让你的代码更容易被其他 PHP 开发者理解，也能提高代码本身的质量和减少潜在错误，同时促进不同框架和库之间的互操作性。  核心思想：一致性至关重要。代码是写给人看的，不是机器。清晰、简洁、可读的代码能够极大地提高开发效率和项目成功率。遵循 PSR 规范，让你的代码更具通用性和专业性。   一、PHP 编码哲学与 PSRPHP 语言虽然以其灵活性和“快速启动”而闻名，但其社区也逐渐形成了一套成熟的编码约定，以解决早期版本中常见的代码风格混乱问题。PSR (PHP Standards Recommendations) 正是这些约定的核心。 PSR 是什么？PSR 是由 PHP 框架互操作性组 (PHP Framework Interoperability Group, FIG) 制定和推荐的一系列规范。它并非强制性标准，但被绝大多数现...</div></div></div></a><a class="pagination-related" href="/6a5fbe75d3cc/" title="PHP 内存溢出解决方案详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="info-item-2">PHP 内存溢出解决方案详解</div></div><div class="info-2"><div class="info-item-1"> PHP 内存溢出 (Memory Exhausted) 是 PHP 应用程序开发中一个常见的问题，通常表现为 Fatal error: Allowed memory size of X bytes exhausted。这意味着 PHP 脚本在执行过程中尝试分配的内存超出了配置允许的最大值。理解其原因并掌握有效的解决方案对于构建稳定、高性能的 PHP 应用至关重要。  核心思想：PHP 内存溢出通常源于：1. 配置限制；2. 代码中大量数据处理或未释放的资源；3. 内存泄漏。解决的关键在于合理配置、优化代码和有效管理内存。   一、理解 PHP 内存溢出的原因PHP 内存溢出主要有以下几方面的原因：  PHP 配置限制： memory_limit 配置项：这是 PHP 限制单个脚本可以使用的最大内存量。如果脚本尝试使用的内存超过这个值，就会触发内存溢出错误。 服务器资源限制：即使 memory_limit 很高，宿主机本身的内存资源也有限。   代码层面问题： 处理大量数据：一次性从数据库中查询大量记录、处理大型文件、或对大型数组&#x2F;字符串进行操作，都可能导致内存瞬时暴增...</div></div></div></a><a class="pagination-related" href="/ab53b79e305e/" title="PHP this, self, static 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-06</div><div class="info-item-2">PHP this, self, static 详解</div></div><div class="info-2"><div class="info-item-1"> 在 PHP 面向对象编程中，$this、self 和 static 是三个至关重要的关键词，它们用于在类内部访问成员属性和方法。理解它们之间的区别和用法是掌握 PHP 对象模型，特别是后期静态绑定 (Late Static Binding) 的关键。  核心思想：$this 指向当前对象实例，self 指向当前类，static 结合后期静态绑定机制，根据运行时调用者来确定指向的类。    一、$this 关键字1.1 定义与用途$this 关键字用于引用当前对象实例。它只能在非静态方法中使用，用于访问当前对象实例的非静态属性和非静态方法。 当一个类被实例化为一个对象后，$this 就代表了该对象。 1.2 访问方式通过 -&gt; 运算符访问：$this-&gt;propertyName 或 $this-&gt;methodName()。 1.3 示例12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Car &#123;    public $color; // 非静态属性    p...</div></div></div></a><a class="pagination-related" href="/80bef8aa6c96/" title="PHP 数组 (Array) 相关函数详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-14</div><div class="info-item-2">PHP 数组 (Array) 相关函数详解</div></div><div class="info-2"><div class="info-item-1"> PHP 数组 (Array) 是一种特殊的数据类型，可以存储多个值在一个变量中。PHP 数组是高度灵活的，既可以作为普通索引数组（数值键），也可以作为关联数组（字符串键），甚至可以两者混合使用，或者作为多维数组。PHP 提供了极其丰富和强大的内置函数来操作数组，涵盖了从创建、遍历、排序、过滤到搜索、合并等几乎所有常见的数组操作需求。深入理解并熟练运用这些函数，是高效编写 PHP 代码的关键。  核心思想：PHP 数组函数旨在提供强大、灵活且高效的方式来管理和操作复杂的数据集合，简化开发者对数据的处理。    一、数组基础知识回顾在深入函数之前，快速回顾 PHP 数组的几个核心特性：  异构性 (Heterogeneous)：数组中的元素可以是不同数据类型（字符串、数字、布尔、对象、其他数组等）。 动态大小 (Dynamic Sizing)：数组大小不是固定的，可以随时添加或删除元素。 索引与关联： 索引数组 (Indexed Array)：键是整数，默认从 0 开始。12$indexedArray = [&#x27;apple&#x27;, &#x27;banana&#x27;...</div></div></div></a><a class="pagination-related" href="/38c508ec9ee0/" title="PHP Fibers (协程) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="info-item-2">PHP Fibers (协程) 详解</div></div><div class="info-2"><div class="info-item-1"> Fibers (协程) 是 PHP 8.1 引入的一个重要新特性，它为 PHP 带来了原生的用户空间并发能力。与传统的线程或进程不同，Fibers 允许代码在执行过程中暂停和恢复，而无需使用生成器 (Generators) 或复杂的事件循环回调。这使得开发者能够编写更具可读性和可维护性的异步非阻塞代码，从而更好地应对 I&#x2F;O 密集型任务，如网络请求、数据库查询等。  核心思想：Fibers 是一种轻量级的并发原语，允许 PHP 代码在用户空间中实现非阻塞操作，通过显式地暂停和恢复执行，简化了异步代码的编写。   一、为什么需要 Fibers？在 PHP 8.1 之前，实现异步非阻塞代码通常依赖于以下两种方式：  Callbacks (回调函数)： 优点：简单直接，适用于简单的异步操作。 缺点：容易陷入“回调地狱 (Callback Hell)”，代码可读性和维护性差，错误处理复杂。   Generators (生成器)： 优点：通过 yield 实现了伪协程，可以在一定程度上改善回调地狱，允许代码暂停和恢复。 缺点：生成器本质上是迭代器，其语义更偏向于数据生成。将生成...</div></div></div></a><a class="pagination-related" href="/8258d22937ed/" title="Vue3 ref和reactive对比解析：深入理解响应式数据"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-04</div><div class="info-item-2">Vue3 ref和reactive对比解析：深入理解响应式数据</div></div><div class="info-2"><div class="info-item-1"> 在 Vue 3 的 Composition API 中，ref 和 reactive 是创建响应式状态的两个核心函数。它们都旨在将普通 JavaScript 数据转换为响应式数据，以便在数据变化时自动触发视图更新。然而，它们在处理数据类型、访问方式和底层机制上存在显著差异。理解这些差异对于有效地使用 Composition API 至关重要。  核心思想：ref 用于处理原始值和对象，通过 .value 访问其内部值，而 reactive 专门用于处理对象，直接访问对象的属性，且底层基于 Proxy 实现。   一、ref：处理原始值和对象ref 函数接受一个内部值（inner value），并返回一个响应式的 ref 对象。这个 ref 对象只有一个 value 属性，用来指向内部值。 1.1 定义和用法 定义：ref 可以接收任何类型的值作为参数：原始值 (string, number, boolean, null, undefined, Symbol) 或对象 (Object, Array)。 访问：在 JavaScript 中访问 ref 对象时，需要通过其 .valu...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">481</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">226</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%90%86%E8%A7%A3%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC-Lazy-Evaluation"><span class="toc-text">一、理解惰性求值 (Lazy Evaluation)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%EF%BC%9F"><span class="toc-text">1.1 什么是惰性求值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">1.2 惰性求值的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-PHP-%E4%B8%AD%E7%9A%84%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">1.3 PHP 中的惰性求值实现：生成器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81PHP-%E7%94%9F%E6%88%90%E5%99%A8-Generators-%E8%AF%A6%E8%A7%A3"><span class="toc-text">二、PHP 生成器 (Generators) 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9F"><span class="toc-text">2.1 如何创建生成器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-yield-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">2.2 yield 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Generator-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2.3 Generator 对象的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-send-%E6%96%B9%E6%B3%95%EF%BC%9A%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1"><span class="toc-text">2.4 send() 方法：双向通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-yield-from-%E8%A1%A8%E8%BE%BE%E5%BC%8F-PHP-7-0"><span class="toc-text">2.5 yield from 表达式 (PHP 7.0+)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">三、生成器的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%A4%84%E7%90%86%E5%A4%A7%E5%9E%8B%E6%96%87%E4%BB%B6"><span class="toc-text">3.1 处理大型文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.2 数据库查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%97%A0%E9%99%90%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90"><span class="toc-text">3.3 无限序列生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6-%E5%8D%8F%E7%A8%8B-PHP-5-5-PHP-8-1"><span class="toc-text">3.4 任务调度&#x2F;协程 (PHP 5.5 - PHP 8.1)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">四、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何防止 Golang Goroutine 泄漏"/></a><div class="content"><a class="title" href="/4e0d929e572f/" title="如何防止 Golang Goroutine 泄漏">如何防止 Golang Goroutine 泄漏</a><time datetime="2025-12-30T22:24:00.000Z" title="发表于 2025-12-31 06:24:00">2025-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>