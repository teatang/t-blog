<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unicode 与 UTF-8 编码深度解析 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在现代计算机系统中，处理和显示全球范围内的各种文字和符号是至关重要的。Unicode (统一码) 和 UTF-8 是实现这一目标的两个核心标准。它们通常被提及，但其确切含义和关系有时会混淆。简而言之，Unicode 定义了字符的唯一标识，而 UTF-8 则是 Unicode 字符的一种高效、可变长度的编码方式，尤其适用于互联网传输。  核心思想：Unicode 是一个巨大的“字符字典”，为每个字">
<meta property="og:type" content="article">
<meta property="og:title" content="Unicode 与 UTF-8 编码深度解析">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/a98d6341806e/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="在现代计算机系统中，处理和显示全球范围内的各种文字和符号是至关重要的。Unicode (统一码) 和 UTF-8 是实现这一目标的两个核心标准。它们通常被提及，但其确切含义和关系有时会混淆。简而言之，Unicode 定义了字符的唯一标识，而 UTF-8 则是 Unicode 字符的一种高效、可变长度的编码方式，尤其适用于互联网传输。  核心思想：Unicode 是一个巨大的“字符字典”，为每个字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg">
<meta property="article:published_time" content="2023-11-20T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-25T12:41:00.573Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Unicode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unicode 与 UTF-8 编码深度解析",
  "url": "https://blog.tbf1211.xx.kg/a98d6341806e/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-28.jpg",
  "datePublished": "2023-11-20T22:24:00.000Z",
  "dateModified": "2026-01-25T12:41:00.573Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/a98d6341806e/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unicode 与 UTF-8 编码深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">519</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-28.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Unicode 与 UTF-8 编码深度解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unicode 与 UTF-8 编码深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-11-20T22:24:00.000Z" title="发表于 2023-11-21 06:24:00">2023-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/">其他</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>在现代计算机系统中，处理和显示全球范围内的各种文字和符号是至关重要的。<strong>Unicode (统一码)</strong> 和 <strong>UTF-8</strong> 是实现这一目标的两个核心标准。它们通常被提及，但其确切含义和关系有时会混淆。简而言之，Unicode 定义了字符的唯一标识，而 UTF-8 则是 Unicode 字符的一种高效、可变长度的编码方式，尤其适用于互联网传输。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>Unicode 是一个巨大的“字符字典”，为每个字符分配一个唯一的数字（码点）；UTF-8 是一种聪明的“翻译规则”，将这些码点以字节序列的形式存储或传输，且具有向 ASCII 兼容的优势。</strong></p>
</div>
<hr>
<h2 id="一、字符编码的演进：从-ASCII-到-Unicode"><a href="#一、字符编码的演进：从-ASCII-到-Unicode" class="headerlink" title="一、字符编码的演进：从 ASCII 到 Unicode"></a>一、字符编码的演进：从 ASCII 到 Unicode</h2><p>在 Unicode 出现之前，计算机世界充满了各种相互冲突的字符编码标准，这导致了“乱码”问题的普遍存在。</p>
<ul>
<li><strong>ASCII (American Standard Code for Information Interchange)</strong>：最早且最广泛使用的字符编码标准。它使用 7 位表示 128 个字符，主要包括英文字母、数字和一些标点符号。<ul>
<li><strong>局限性</strong>：无法表示非英文字符。</li>
</ul>
</li>
<li><strong>扩展 ASCII (Extended ASCII)</strong>：为了解决 ASCII 的局限性，出现了许多 8 位编码标准（如 ISO-8859-1、GBK、Big5），它们在 ASCII 的基础上增加了 128 个字符，用于表示特定语言的字符。<ul>
<li><strong>局限性</strong>：这些标准之间互不兼容，导致同一份文本在不同编码下显示为乱码。例如，使用 GBK 编码的中文字符在 ISO-8859-1 环境下会显示为乱码。</li>
</ul>
</li>
</ul>
<p>这种“信息孤岛”的状态急需一个统一的解决方案，于是 <strong>Unicode</strong> 应运而生。</p>
<h2 id="二、Unicode：统一的字符集"><a href="#二、Unicode：统一的字符集" class="headerlink" title="二、Unicode：统一的字符集"></a>二、Unicode：统一的字符集</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Unicode</strong> 是一个<strong>字符集 (Character Set)</strong>，它为世界上所有语言的字符、符号和表情符号等分配一个<strong>唯一的、非负的数字 ID</strong>，这个 ID 称为<strong>码点 (Code Point)</strong>。Unicode 的目标是囊括所有已知的文字系统，为每个字符提供一个全球唯一的名称和编号。</p>
<ul>
<li><strong>码点表示</strong>：码点通常用 <code>U+</code> 后跟四到六位十六进制数字表示，例如：<ul>
<li><code>A</code> 的码点是 <code>U+0041</code></li>
<li><code>中</code> 的码点是 <code>U+4E2D</code></li>
<li><code>€</code> (欧元符号) 的码点是 <code>U+20AC</code></li>
<li><code>😄</code> (笑脸表情) 的码点是 <code>U+1F604</code></li>
</ul>
</li>
</ul>
<h3 id="2-2-Unicode-的组织"><a href="#2-2-Unicode-的组织" class="headerlink" title="2.2 Unicode 的组织"></a>2.2 Unicode 的组织</h3><p>Unicode 将码点划分为不同的<strong>平面 (Planes)</strong>。目前主要使用的有：</p>
<ul>
<li><strong>基本多语言平面 (Basic Multilingual Plane, BMP)</strong>：范围从 <code>U+0000</code> 到 <code>U+FFFF</code>。包含了绝大多数常用字符，包括常用的拉丁字母、希腊字母、西里尔字母、日韩汉字 (CJK Unified Ideographs)、符号等。</li>
<li><strong>辅助平面 (Supplementary Planes)</strong>：<code>U+10000</code> 到 <code>U+10FFFF</code>。用于存储不常用的汉字、古文字、表情符号、数学符号等。</li>
</ul>
<p>Unicode 目前最多可以表示 <code>17 * 65536</code> 即超过 100 万个字符（从 <code>U+0000</code> 到 <code>U+10FFFF</code>）。</p>
<h3 id="2-3-Unicode-与编码方案的关系"><a href="#2-3-Unicode-与编码方案的关系" class="headerlink" title="2.3 Unicode 与编码方案的关系"></a>2.3 Unicode 与编码方案的关系</h3><p>Unicode <strong>只是一个字符集</strong>，它定义了字符和码点之间的映射关系。它<strong>没有规定</strong>这些码点在计算机内存或磁盘中如何存储为字节序列。将 Unicode 码点转换为字节序列的规则称为<strong>编码方案 (Encoding Scheme)</strong> 或<strong>字符编码 (Character Encoding)</strong>。</p>
<p>常见的 Unicode 编码方案包括：</p>
<ul>
<li><strong>UTF-8</strong> (UCS Transformation Format-8)</li>
<li><strong>UTF-16</strong> (UCS Transformation Format-16)</li>
<li><strong>UTF-32</strong> (UCS Transformation Format-32)</li>
</ul>
<h2 id="三、UTF-8：Unicode-最流行的编码方式"><a href="#三、UTF-8：Unicode-最流行的编码方式" class="headerlink" title="三、UTF-8：Unicode 最流行的编码方式"></a>三、UTF-8：Unicode 最流行的编码方式</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p><strong>UTF-8</strong> 是一种<strong>变长 (Variable-width)</strong> 的 Unicode 字符编码方案，它使用 1 到 4 个字节来表示一个 Unicode 码点。UTF-8 的设计目标是：</p>
<ul>
<li><strong>完全兼容 ASCII</strong>：UTF-8 中，单字节字符的编码与 ASCII 完全一致，这意味着一个纯 ASCII 文件也是一个有效的 UTF-8 文件，可以直接被识别。</li>
<li><strong>高效存储</strong>：对于常用字符（尤其是 ASCII 字符），它只占用一个字节，比固定长度的编码（如 UTF-16、UTF-32）更节省空间。</li>
<li><strong>字节顺序无关 (Byte Order Mark, BOM)</strong>：UTF-8 不需要字节顺序标记（BOM），因为其编码规则本身就确保了字节顺序不会混淆。</li>
</ul>
<h3 id="3-2-UTF-8-的编码规则"><a href="#3-2-UTF-8-的编码规则" class="headerlink" title="3.2 UTF-8 的编码规则"></a>3.2 UTF-8 的编码规则</h3><p>UTF-8 是一种自同步编码，其多字节序列的每个字节都有特定的模式，使得解码器能够识别每个字符的起始和结束。</p>
<table>
<thead>
<tr>
<th>码点范围</th>
<th>字节数</th>
<th>字节 1</th>
<th>字节 2</th>
<th>字节 3</th>
<th>字节 4</th>
</tr>
</thead>
<tbody><tr>
<td><code>U+0000</code> - <code>U+007F</code></td>
<td>1</td>
<td><code>0xxxxxxx</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0080</code> - <code>U+07FF</code></td>
<td>2</td>
<td><code>110xxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>U+0800</code> - <code>U+FFFF</code></td>
<td>3</td>
<td><code>1110xxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td></td>
</tr>
<tr>
<td><code>U+10000</code> - <code>U+10FFFF</code></td>
<td>4</td>
<td><code>11110xxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
<td><code>10xxxxxx</code></td>
</tr>
</tbody></table>
<p>其中 <code>x</code> 表示用于编码码点的比特位。</p>
<p><strong>编码示例：</strong></p>
<ol>
<li><p><strong>字符 <code>A</code> (U+0041)</strong></p>
<ul>
<li>在 <code>U+0000</code> - <code>U+007F</code> 范围内，使用 1 个字节。</li>
<li><code>0041</code> (十六进制) &#x3D; <code>0100 0001</code> (二进制)</li>
<li>编码为 <code>01000001</code> (二进制) &#x3D; <code>41</code> (十六进制)</li>
<li>结果：<code>0x41</code> (1 字节) — 与 ASCII 完全一致。</li>
</ul>
</li>
<li><p><strong>字符 <code>€</code> (U+20AC)</strong></p>
<ul>
<li>在 <code>U+0800</code> - <code>U+FFFF</code> 范围内，使用 3 个字节。</li>
<li><code>20AC</code> (十六进制) &#x3D; <code>0010 0000 1010 1100</code> (二进制)</li>
<li>将其 <code>x</code> 部分填充到 3 字节模式：<code>1110xxxx 10xxxxxx 10xxxxxx</code><ul>
<li><code>1110</code> <code>0010</code> <code>10</code> <code>000010</code> <code>10</code> <code>101100</code> (拆分 <code>0010000010101100</code> 为 <code>0010</code> <code>000010</code> <code>101100</code>)</li>
<li><code>E2</code> <code>82</code> <code>AC</code> (十六进制)</li>
</ul>
</li>
<li>结果：<code>0xE2 0x82 0xAC</code> (3 字节)</li>
</ul>
</li>
<li><p><strong>字符 <code>😄</code> (U+1F604)</strong></p>
<ul>
<li>在 <code>U+10000</code> - <code>U+10FFFF</code> 范围内，使用 4 个字节。</li>
<li><code>1F604</code> (十六进制) &#x3D; <code>0001 1111 0110 0000 0100</code> (二进制)</li>
<li>将其 <code>x</code> 部分填充到 4 字节模式：<code>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code><ul>
<li><code>11110</code> <code>000</code> <code>10</code> <code>011111</code> <code>10</code> <code>011000</code> <code>10</code> <code>000100</code> (拆分 <code>00011111011000000100</code> 为 <code>000</code> <code>011111</code> <code>011000</code> <code>000100</code>)</li>
<li><code>F0</code> <code>9F</code> <code>98</code> <code>84</code> (十六进制)</li>
</ul>
</li>
<li>结果：<code>0xF0 0x9F 0x98 0x84</code> (4 字节)</li>
</ul>
</li>
</ol>
<h3 id="3-3-UTF-8-的优势"><a href="#3-3-UTF-8-的优势" class="headerlink" title="3.3 UTF-8 的优势"></a>3.3 UTF-8 的优势</h3><ul>
<li><strong>向后兼容 ASCII</strong>：纯 ASCII 文本也是有效的 UTF-8 文本，无需转换。</li>
<li><strong>节省空间</strong>：对于以拉丁字符为主的文本，UTF-8 比 UTF-16 或 UTF-32 更节省空间。这对于网络传输和存储非常有利。</li>
<li><strong>鲁棒性</strong>：多字节序列的起始字节和后续字节有明确的模式，有助于在数据损坏时快速恢复，避免将损坏的字节序列误解为其他字符。</li>
<li><strong>跨平台通用</strong>：几乎所有现代操作系统、编程语言和应用程序都支持 UTF-8 作为首选编码。</li>
</ul>
<h2 id="四、UTF-16-与-UTF-32-了解"><a href="#四、UTF-16-与-UTF-32-了解" class="headerlink" title="四、UTF-16 与 UTF-32 (了解)"></a>四、UTF-16 与 UTF-32 (了解)</h2><h3 id="4-1-UTF-16"><a href="#4-1-UTF-16" class="headerlink" title="4.1 UTF-16"></a>4.1 UTF-16</h3><ul>
<li><strong>定义</strong>：一种变长编码，使用 2 或 4 个字节来表示 Unicode 码点。BMP 中的字符使用 2 字节，辅助平面的字符使用 4 字节（通过代理对 Surrogate Pair）。</li>
<li><strong>特点</strong>：<ul>
<li>对于 BMP 中的字符，它比 UTF-8 占用更多的空间（2 字节 vs 1-3 字节）。</li>
<li>对于辅助平面的字符，它与 UTF-8 占用相同的空间（4 字节）。</li>
<li>存在<strong>字节序问题 (Byte Order)</strong>：<code>0xFEFF</code> 或 <code>0xFFFE</code> (BOM) 用于指示字节序是大端 (Big-Endian) 还是小端 (Little-Endian)。</li>
</ul>
</li>
<li><strong>应用</strong>：Windows 系统内部和 Java 语言内部通常使用 UTF-16。</li>
</ul>
<h3 id="4-2-UTF-32"><a href="#4-2-UTF-32" class="headerlink" title="4.2 UTF-32"></a>4.2 UTF-32</h3><ul>
<li><strong>定义</strong>：一种固定长度编码，每个 Unicode 码点都使用 4 个字节表示。</li>
<li><strong>特点</strong>：<ul>
<li><strong>简单</strong>：字符的索引和字节偏移量之间有直接的映射关系，便于字符串操作。</li>
<li><strong>浪费空间</strong>：对于 ASCII 字符或 BMP 中的字符，它会浪费大量的空间。例如，<code>A</code> (U+0041) 占用 4 字节 (<code>0x00 0x00 0x00 0x41</code>)。</li>
<li>存在字节序问题。</li>
</ul>
</li>
<li><strong>应用</strong>：很少用于存储或传输，主要用于一些内部处理或特定的计算场景。</li>
</ul>
<h2 id="五、Unicode-与-UTF-8-的关系总结"><a href="#五、Unicode-与-UTF-8-的关系总结" class="headerlink" title="五、Unicode 与 UTF-8 的关系总结"></a>五、Unicode 与 UTF-8 的关系总结</h2><div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[所有字符&#x2F;符号] --&gt; B(Unicode 标准);
    B -- 分配唯一码点 --&gt; C{&quot;Unicode 码点 &lt;br&#x2F;&gt; (e.g., U+0041, U+4E2D)&quot;};
    C -- 编码规则 --&gt; D[UTF-8];
    C -- 编码规则 --&gt; E[UTF-16];
    C -- 编码规则 --&gt; F[UTF-32];

    D -- 变长字节序列 --&gt; G[&quot;存储&#x2F;传输数据 &lt;br&#x2F;&gt; (e.g., 0x41 for &#39;A&#39;, 0xE282AC for &#39;€&#39;)&quot;];
    E -- 变长字节序列 --&gt; G;
    F -- 定长字节序列 --&gt; G;

    subgraph 字符集
        B; C;
    end

    subgraph 编码方案
        D; E; F;
    end
  </pre></div>

<p><strong>关键关系：</strong></p>
<ul>
<li><strong>Unicode 是字符集</strong>：它定义了“字符”是什么以及它们的唯一编号。</li>
<li><strong>UTF-8 是编码方案</strong>：它定义了“如何将 Unicode 码点表示为字节序列”以便存储和传输。</li>
<li><strong>Unicode 就像字典，UTF-8 就像翻译官。</strong> 字典告诉我们每个字的意思（码点），翻译官告诉我们如何用字节把它写出来。</li>
</ul>
<h2 id="六、常见问题与最佳实践"><a href="#六、常见问题与最佳实践" class="headerlink" title="六、常见问题与最佳实践"></a>六、常见问题与最佳实践</h2><h3 id="6-1-什么是乱码？"><a href="#6-1-什么是乱码？" class="headerlink" title="6.1 什么是乱码？"></a>6.1 什么是乱码？</h3><p>当文本的<strong>实际编码</strong>与<strong>解码器期望的编码</strong>不一致时，就会发生乱码。例如，一个 UTF-8 编码的文件被当作 GBK 解码，就会出现乱码。</p>
<h3 id="6-2-BOM-Byte-Order-Mark"><a href="#6-2-BOM-Byte-Order-Mark" class="headerlink" title="6.2 BOM (Byte Order Mark)"></a>6.2 BOM (Byte Order Mark)</h3><ul>
<li><strong>UTF-8 BOM</strong>：UTF-8 文件通常<strong>不建议</strong>使用 BOM (文件开头通常是 <code>0xEF 0xBB 0xBF</code>)。因为它对于 UTF-8 来说不是必须的，反而可能在某些解析器中引起问题（例如，某些脚本语言会将 BOM 视为文件内容的一部分）。</li>
<li><strong>UTF-16 BOM</strong>：对于 UTF-16 文件，BOM 是<strong>必须的</strong>，因为它指示了字节序（大端或小端）。</li>
</ul>
<h3 id="6-3-最佳实践"><a href="#6-3-最佳实践" class="headerlink" title="6.3 最佳实践"></a>6.3 最佳实践</h3><ul>
<li><strong>始终使用 UTF-8</strong>：在现代开发中，无论是文件存储、网络传输、数据库字符集还是编程语言内部处理，UTF-8 都应该是首选的编码。它兼容 ASCII，效率高，且得到了广泛支持。</li>
<li><strong>明确声明编码</strong>：在 HTML 页面中使用 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>，在 HTTP 响应头中使用 <code>Content-Type: text/html; charset=utf-8</code>，在数据库配置中指定 UTF-8 字符集。</li>
<li><strong>避免混合编码</strong>：确保整个系统（从前端到后端，从应用到数据库）都使用一致的 UTF-8 编码。</li>
</ul>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Unicode 和 UTF-8 是现代计算机处理全球化文本的基石。Unicode 提供了统一的字符标识，解决了字符集冲突的根本问题；而 UTF-8 作为 Unicode 最优秀的实现之一，以其高效、兼容 ASCII 和自同步的特性，成为了互联网和跨平台环境中事实上的标准。理解这两者的关系和工作原理，对于任何从事软件开发或数据处理的专业人士都至关重要，它是避免乱码、构建健壮国际化系统的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/a98d6341806e/">https://blog.tbf1211.xx.kg/a98d6341806e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Unicode/">Unicode</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f9907953525a/" title="Java try-catch-finally 与 try-with-resources 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java try-catch-finally 与 try-with-resources 详解</div></div><div class="info-2"><div class="info-item-1"> 在 Java 编程中，异常处理是确保程序健壮性和可靠性的关键。try-catch-finally 结构是 Java 异常处理的基石，而 try-with-resources (自 Java 7 引入) 则是为了更优雅、更安全地管理资源而设计的语法糖。本文将详细探讨这两种机制的工作原理、使用场景、优缺点以及最佳实践。  核心思想：  try-catch-finally：提供了一个结构化的方式来捕获和处理可能发生的运行时错误 (异常)，并确保在异常发生或不发生的情况下，特定代码块（通常用于资源清理）能够执行。 try-with-resources：针对需要关闭的资源（如文件流、数据库连接等），提供了一种自动管理资源生命周期的方式，确保资源在使用完毕后被正确关闭，即使发生异常。     一、try-catch-finally 详解try-catch-finally 是 Java 异常处理的核心机制。  try 块：包含可能抛出异常的代码。 catch 块：用于捕获 try 块中抛出的特定类型的异常，并进行相应的处理。一个 try 块可以跟多个 catch 块，以处理不同类型的异常。 ...</div></div></div></a><a class="pagination-related" href="/56481bc27387/" title="Docker Swarm 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Docker Swarm 详解</div></div><div class="info-2"><div class="info-item-1"> Docker Swarm 是 Docker 官方提供的原生容器编排工具。它将一组 Docker 主机（宿主机）聚合成一个集群，并将这些主机视为单个虚拟的 Docker 主机。通过 Docker Swarm，用户可以轻松地部署、管理和扩展在多个节点上运行的容器化应用程序。它简化了容器集群的搭建和管理，特别适合那些希望在不引入过多复杂性的情况下，实现容器高可用和负载均衡的用户。  核心思想：将多台物理机&#x2F;虚拟机抽象成一个统一的资源池，并提供原生 Docker API 接口，从而实现容器的集群化部署、服务发现、负载均衡和故障恢复。    一、为什么需要 Docker Swarm？Docker Compose 解决了单机多容器应用的编排问题，但现代分布式应用程序通常需要运行在多台服务器（节点）上，以实现：  高可用性 (High Availability)：单个节点故障不影响整个应用程序的运行。 负载均衡 (Load Balancing)：将流量均匀分配到多个容器实例，提高应用程序的响应速度和吞吐量。 伸缩性 (Scalability)：根据需求动态增加或减少应用程序的容器实...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/bbac3d35a168/" title="Zsh (Z Shell) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="info-item-2">Zsh (Z Shell) 详解</div></div><div class="info-2"><div class="info-item-1"> Zsh (Z Shell) 是一款功能强大的 Unix Shell，与 Bash、Ksh、TCSH 等 Shell 类似，但它在功能和可定制性方面提供了显著的增强。Zsh 提供了更强大的命令补全、历史记录、参数展开、拼写纠正、主题和插件支持等功能，极大地提升了命令行用户的体验和效率。许多 macOS 和 Linux 用户选择 Zsh 作为他们的默认 Shell，特别是结合 Oh My Zsh 等框架使用时。  核心思想：Zsh 是 Bash 的一个强大且高度可定制的超集，旨在提供更智能、更高效的命令行交互体验。   一、Zsh 概览与核心优势1.1 什么是 Zsh？Zsh 是一个兼容 POSIX 标准的命令行解释器。它在 Bash 的基础上进行了大量的改进和扩展，提供了许多 Bash 没有的功能。它最初由 Paul Falstad 在 1990 年开发。 1.2 Zsh 相较于 Bash 的优势虽然 Bash 已经非常强大和普及，但 Zsh 在以下方面提供了显著优势：  更强大的自动补全 (Autocompletion)： 智能感知上下文，能够补全命令、文件路径、选项、变量、甚...</div></div></div></a><a class="pagination-related" href="/793b1126e524/" title="Tomcat、Jetty 和 Undertow 对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-28</div><div class="info-item-2">Tomcat、Jetty 和 Undertow 对比详解</div></div><div class="info-2"><div class="info-item-1"> Tomcat、Jetty 和 Undertow 都是流行的 Java Web 服务器和 Servlet 容器，它们实现了 Java Servlet 规范、JavaServer Pages (JSP) 规范、Java Expression Language (EL) 规范以及 WebSocket 规范。在 Java 企业级应用开发中，特别是在 Spring Boot 等框架盛行的微服务时代，选择一个合适的内嵌或独立 Web 服务器变得尤为重要。虽然它们功能相似，但在架构设计、性能特点、内存占用、灵活性和社区支持等方面各有侧重。  核心思想：理解这些 Web 服务器的内部机制和特点，有助于在不同场景下做出最优选择。Tomcat 以稳定和功能全面闻名，Jetty 以轻量和可嵌入性见长，而 Undertow 则以高性能和低资源消耗脱颖而出。   一、基本概念和共通性在深入对比之前，我们先明确一些基本概念：  Web 服务器：能够响应 HTTP 请求，提供静态内容（如 HTML, CSS, JavaScript, 图片）。 Servlet 容器：实现了 Java Servlet 规范，能...</div></div></div></a><a class="pagination-related" href="/0458ba8f01d5/" title="以太坊（Ethereum）智能合约深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-20</div><div class="info-item-2">以太坊（Ethereum）智能合约深度解析</div></div><div class="info-2"><div class="info-item-1"> 以太坊（Ethereum）作为全球领先的智能合约平台，开创了“可编程区块链”的时代。智能合约是其核心基石，它让开发者能够在区块链上构建去中心化应用（DApp），实现各种复杂的逻辑而无需信任第三方。本文将深入探讨以太坊智能合约的各个层面，包括其定义、工作原理、开发语言、生命周期以及关键特性。  “智能合约是运行在区块链上的代码，它在特定条件下自动执行预设的协议条款。”   一、什么是智能合约？智能合约（Smart Contract）由尼克·萨博（Nick Szabo）在1994年首次提出，他将其描述为“一个数字化的，可以自我执行协议的计算机交易协议”。在区块链语境下，特别是以太坊中，智能合约的含义更为具体：  代码与数据：智能合约是一段存储在以太坊区块链上的代码（用高级语言如 Solidity 编写，编译为 EVM 字节码）和一个地址，这个地址还存储着该合约的当前状态（数据）。 不可篡改：一旦部署到区块链上，合约的代码和数据都是不可篡改的。 自动执行：当满足预设的条件时，合约会根据其代码逻辑自动执行，无需人工干预。 无需信任：合约的执行结果由区块链网络中的所有节点共同验证，保证了...</div></div></div></a><a class="pagination-related" href="/c0ed8953ea7d/" title="Python 编码规范详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="info-item-2">Python 编码规范详解</div></div><div class="info-2"><div class="info-item-1"> Python 编码规范 旨在提供一套指导原则和最佳实践，以确保 Python 代码的一致性、可读性、可维护性、可协作性和**“Pythonic”**（符合 Python 语言哲学）风格。Python 社区的核心编码规范是 PEP 8 (Python Enhancement Proposal 8)，它定义了 Python 代码的风格指南。遵循 PEP 8 不仅能让你的代码更容易被其他 Python 开发者理解，也能提高代码本身的质量和减少潜在错误。  核心思想：一致性至关重要。代码是写给人看的，不是机器。清晰、简洁、可读的代码能够极大地提高开发效率和项目成功率。   一、Python 编码哲学与 PEP 8Python 语言的设计哲学（可在 import this 中查看“The Zen of Python”）强调简洁、明确和可读性。PEP 8 是将这些哲学转化为具体编码实践的基石。 PEP 8 是什么？PEP 8 是 Python 官方的风格指南，由 Guido van Rossum (Python 创始人)、Barry Warsaw 和 Nick Coghlan 共同撰写。它...</div></div></div></a><a class="pagination-related" href="/be930ce35928/" title="Java 常用设计模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-30</div><div class="info-item-2">Java 常用设计模式详解</div></div><div class="info-2"><div class="info-item-1"> 设计模式 (Design Patterns) 是在软件工程中，针对特定问题场景提出的一套经过验证的、可复用的解决方案。它们是从实践中总结出来的，是软件开发过程中的最佳实践。学习和应用设计模式，可以帮助开发者构建出结构清晰、可维护、可扩展、复用性强的软件系统，同时也能促进团队成员之间的沟通。  核心思想：设计模式的目标是提升软件的灵活性 (Flexibility)、可重用性 (Reusability) 和可扩展性 (Extensibility)，同时降低维护成本 (Maintainability)。它们不是代码，而是解决特定问题的思想和方法。   一、设计模式的分类根据 GoF (Gang of Four，《设计模式：可复用面向对象软件的基础》的四位作者) 的经典分类，设计模式主要分为三类：  创建型模式 (Creational Patterns)： 关注对象的创建机制，目标是解耦对象的创建与使用，从而提供更大的灵活性。 包括：单例 (Singleton)、工厂方法 (Factory Method)、抽象工厂 (Abstract Factory)、建造者 (Builder)、原型...</div></div></div></a><a class="pagination-related" href="/91353ff26772/" title="Peewee ORM 详解：接口使用与实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">Peewee ORM 详解：接口使用与实践</div></div><div class="info-2"><div class="info-item-1"> Peewee 是一个小型、富有表现力、功能齐全的 Python ORM (Object-Relational Mapper)。它提供了一种简单且 Pythonic 的方式来与数据库进行交互，支持 SQLite、PostgreSQL 和 MySQL 等多种关系型数据库。Peewee 的设计理念是轻量级和易用性，使得开发者可以快速地构建应用程序，而无需编写大量的 SQL 语句。  核心思想：将数据库表映射为 Python 类，将表的行映射为类的实例，将表的列映射为类的属性。 通过 Python 对象和方法来操作数据库，从而抽象掉底层的 SQL 细节。   一、为什么选择 Peewee？在 Python 生态中，存在多种 ORM 解决方案，如 SQLAlchemy、Django ORM 等。Peewee 在其中脱颖而出，主要归因于以下特点：  轻量级与简洁性：Peewee 本身代码量较少，API 设计简洁直观，学习曲线平缓。 富有表现力：其查询 API 允许开发者使用类似 Python 原生语法的方式链式调用，构建复杂的查询。 兼容性强：支持 SQLite、PostgreSQL 和 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">519</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E-ASCII-%E5%88%B0-Unicode"><span class="toc-text">一、字符编码的演进：从 ASCII 到 Unicode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Unicode%EF%BC%9A%E7%BB%9F%E4%B8%80%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">二、Unicode：统一的字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Unicode-%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">2.2 Unicode 的组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Unicode-%E4%B8%8E%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">2.3 Unicode 与编码方案的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81UTF-8%EF%BC%9AUnicode-%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">三、UTF-8：Unicode 最流行的编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-UTF-8-%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99"><span class="toc-text">3.2 UTF-8 的编码规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-UTF-8-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">3.3 UTF-8 的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81UTF-16-%E4%B8%8E-UTF-32-%E4%BA%86%E8%A7%A3"><span class="toc-text">四、UTF-16 与 UTF-32 (了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-UTF-16"><span class="toc-text">4.1 UTF-16</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-UTF-32"><span class="toc-text">4.2 UTF-32</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Unicode-%E4%B8%8E-UTF-8-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93"><span class="toc-text">五、Unicode 与 UTF-8 的关系总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">六、常见问题与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%B1%E7%A0%81%EF%BC%9F"><span class="toc-text">6.1 什么是乱码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-BOM-Byte-Order-Mark"><span class="toc-text">6.2 BOM (Byte Order Mark)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">6.3 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-28.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>