<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UUID (Universally Unique Identifier) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="UUID (Universally Unique Identifier)，即通用唯一标识符，是一个由 128 位数字组成的标识符，用于在计算机系统中保证局部或全局的唯一性。它也被称为 GUID (Globally Unique Identifier)，特别是在微软的实现中。UUID 的设计目标是在不依赖中央协调机构的情况下，使得分布式系统中的每个实体都能拥有一个足够唯一的标识符，从而避免冲突。">
<meta property="og:type" content="article">
<meta property="og:title" content="UUID (Universally Unique Identifier) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/dd818a0507ce/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="UUID (Universally Unique Identifier)，即通用唯一标识符，是一个由 128 位数字组成的标识符，用于在计算机系统中保证局部或全局的唯一性。它也被称为 GUID (Globally Unique Identifier)，特别是在微软的实现中。UUID 的设计目标是在不依赖中央协调机构的情况下，使得分布式系统中的每个实体都能拥有一个足够唯一的标识符，从而避免冲突。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg">
<meta property="article:published_time" content="2024-02-23T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-28T09:37:21.855Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="分布式系统">
<meta property="article:tag" content="UUID">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UUID (Universally Unique Identifier) 详解",
  "url": "https://blog.tbf1211.xx.kg/dd818a0507ce/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-17.jpg",
  "datePublished": "2024-02-23T22:24:00.000Z",
  "dateModified": "2026-02-28T09:37:21.855Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/dd818a0507ce/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 7
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UUID (Universally Unique Identifier) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">UUID (Universally Unique Identifier) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">UUID (Universally Unique Identifier) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-02-23T22:24:00.000Z" title="发表于 2024-02-24 06:24:00">2024-02-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">加密算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>UUID (Universally Unique Identifier)</strong>，即<strong>通用唯一标识符</strong>，是一个由 128 位数字组成的标识符，用于在计算机系统中保证局部或全局的唯一性。它也被称为 <strong>GUID (Globally Unique Identifier)</strong>，特别是在微软的实现中。UUID 的设计目标是在不依赖中央协调机构的情况下，使得分布式系统中的每个实体都能拥有一个足够唯一的标识符，从而避免冲突。</p>
</blockquote>
<div class="note info flat"><p>核心思想：UUID 是一种 128 位的数字，通过特定的算法生成，旨在在分布式环境中提供极高的唯一性，无需中央协调。</p>
</div>

<hr>
<h2 id="一、为什么需要-UUID？"><a href="#一、为什么需要-UUID？" class="headerlink" title="一、为什么需要 UUID？"></a>一、为什么需要 UUID？</h2><p>在现代分布式系统、微服务架构和大型数据库应用中，生成唯一标识符是一个常见而关键的需求。传统的自增 ID（如数据库主键）存在以下问题：</p>
<ul>
<li><strong>中心化瓶颈：</strong> 需要一个中心化的数据库来管理和生成 ID，成为系统的单点故障或性能瓶颈。</li>
<li><strong>分布式冲突：</strong> 在多个服务或节点独立生成 ID 时，容易发生冲突。</li>
<li><strong>可预测性：</strong> 连续的自增 ID 容易被预测，可能带来安全风险。</li>
<li><strong>数据迁移和合并：</strong> 合并来自不同数据库的数据时，自增 ID 可能会重复。</li>
</ul>
<p>UUID 提供了一种去中心化的解决方案，允许在任何地方独立生成标识符，而无需担心重复。</p>
<h2 id="二、关键概念定义"><a href="#二、关键概念定义" class="headerlink" title="二、关键概念定义"></a>二、关键概念定义</h2><h3 id="2-1-UUID-Universally-Unique-Identifier"><a href="#2-1-UUID-Universally-Unique-Identifier" class="headerlink" title="2.1 UUID (Universally Unique Identifier)"></a>2.1 UUID (Universally Unique Identifier)</h3><p>一个 128 位长的数字，用于标识信息。它按照特定的算法生成，旨在保证在全球范围内的极高唯一性。通常表示为 32 个十六进制数字，分为 5 组，由连字符隔开，例如：<code>123e4567-e89b-12d3-a456-426614174000</code>。</p>
<h3 id="2-2-GUID-Globally-Unique-Identifier"><a href="#2-2-GUID-Globally-Unique-Identifier" class="headerlink" title="2.2 GUID (Globally Unique Identifier)"></a>2.2 GUID (Globally Unique Identifier)</h3><p>与 UUID 同义，主要在 Microsoft 产品和技术中使用。</p>
<h3 id="2-3-碰撞-Collision"><a href="#2-3-碰撞-Collision" class="headerlink" title="2.3 碰撞 (Collision)"></a>2.3 碰撞 (Collision)</h3><p>指两个或多个不同的实体被分配了相同的标识符。对于 UUID 而言，碰撞的概率极低，但并非为零。</p>
<h3 id="2-4-熵-Entropy"><a href="#2-4-熵-Entropy" class="headerlink" title="2.4 熵 (Entropy)"></a>2.4 熵 (Entropy)</h3><p>衡量随机性或不可预测性的指标。更高的熵意味着更难预测或重复。在 UUID 生成中，随机数源的熵越高，生成的 UUID 越不容易重复。</p>
<h3 id="2-5-命名空间-Namespace"><a href="#2-5-命名空间-Namespace" class="headerlink" title="2.5 命名空间 (Namespace)"></a>2.5 命名空间 (Namespace)</h3><p>在生成基于名称的 UUID (版本 3 和 5) 时使用。一个命名空间是一个 UUID，结合一个“名称”可以生成一个新的 UUID。同一个命名空间和名称总是会生成相同的 UUID。这确保了如果一个特定实体在同一命名空间下始终拥有相同的名称，那么它的 UUID 也将始终相同。</p>
<h2 id="三、UUID-的结构"><a href="#三、UUID-的结构" class="headerlink" title="三、UUID 的结构"></a>三、UUID 的结构</h2><p>UUID 是一个 128 位的数字，通常表示为 32 个十六进制字符，并以连字符分隔成 5 组，共 36 个字符 (32 个十六进制数字 + 4 个连字符)。</p>
<p><code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx</code></p>
<p>其中：</p>
<ul>
<li>前 8 位 (<code>xxxxxxxx</code>)：<code>time_low</code></li>
<li>接下来的 4 位 (<code>xxxx</code>)：<code>time_mid</code></li>
<li>接下来的 4 位 (<code>Mxxx</code>)：<code>time_high_and_version</code>，其中 <code>M</code> 表示 UUID 的版本 (1-5)。</li>
<li>接下来的 4 位 (<code>Nxxx</code>)：<code>clock_seq_high_and_variant</code>，其中 <code>N</code> 表示 UUID 的变体。</li>
<li>最后 12 位 (<code>xxxxxxxxxxxx</code>)：<code>node</code></li>
</ul>
<p><strong>版本 (Version) 字段：</strong> 位于 <code>time_high_and_version</code> 字段的最高 4 位，指示 UUID 的生成算法类型。<br><strong>变体 (Variant) 字段：</strong> 位于 <code>clock_seq_high_and_variant</code> 字段的最高 2 或 3 位，指示 UUID 的布局。目前最常用的是 RFC 4122 定义的变体 (值为 <code>10xx</code>b，即十六进制的 <code>8</code>, <code>9</code>, <code>A</code>, <code>B</code>)。</p>
<h2 id="四、UUID-的版本详解"><a href="#四、UUID-的版本详解" class="headerlink" title="四、UUID 的版本详解"></a>四、UUID 的版本详解</h2><p>RFC 4122 定义了五种主要的 UUID 版本（Version 1 到 Version 5），以及一些草案中的新版本（Version 6, 7, 8）。</p>
<h3 id="4-1-Version-1-基于时间的-UUID-Time-based-UUID"><a href="#4-1-Version-1-基于时间的-UUID-Time-based-UUID" class="headerlink" title="4.1 Version 1: 基于时间的 UUID (Time-based UUID)"></a>4.1 Version 1: 基于时间的 UUID (Time-based UUID)</h3><ul>
<li><strong>生成方式：</strong> 结合当前时间戳（自公元 1582 年 10 月 15 日格林威治时间午夜，即 Gregorian Calendar 的开始）和 MAC 地址（网卡物理地址）生成。时间戳占据了 UUID 的高位部分，确保了趋势上的单调递增性。</li>
<li><strong>结构：</strong><ul>
<li><code>time_low</code> (32 位)</li>
<li><code>time_mid</code> (16 位)</li>
<li><code>time_high_and_version</code> (16 位，包含 4 位版本号 <code>0001</code>b)</li>
<li><code>clock_seq_high_and_variant</code> (8 位，包含 2-3 位变体)</li>
<li><code>clock_seq_low</code> (8 位)</li>
<li><code>node</code> (48 位，通常是 MAC 地址)</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li>在分布式系统中具有很高的唯一性，因为时间戳和 MAC 地址的组合几乎不可能重复。</li>
<li>在同一机器上，它们是严格单调递增的（如果时钟不回拨），可以利用这个特性进行索引优化。</li>
<li>生成速度快。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>隐私泄露：</strong> 包含 MAC 地址，可能泄露生成 UUID 的机器信息。</li>
<li><strong>时钟回拨问题：</strong> 如果系统时钟回拨，可能会生成重复的 UUID。为了避免这种情况，通常会使用一个“时钟序列”字段，在时钟回拨时递增，或者使用持久化存储来记录上次生成的时间。</li>
<li><strong>顺序性：</strong> 虽然时间戳部分是递增的，但在 UUID 的标准字符串表示中，时间戳的高位在中间，导致其字符串表示不是直接可排序的。</li>
</ul>
</li>
</ul>
<h3 id="4-2-Version-2-DCE-安全-UUID-DCE-Security-UUID"><a href="#4-2-Version-2-DCE-安全-UUID-DCE-Security-UUID" class="headerlink" title="4.2 Version 2: DCE 安全 UUID (DCE Security UUID)"></a>4.2 Version 2: DCE 安全 UUID (DCE Security UUID)</h3><ul>
<li><strong>生成方式：</strong> 类似于 Version 1，但增加了 DCE Security 特有的“本地域”和“用户&#x2F;组 ID”字段。</li>
<li><strong>应用场景：</strong> 主要用于分布式计算环境（DCE）的安全服务，在一般应用中极少使用。</li>
<li><strong>缺点：</strong> 复杂且不通用，很少有现代系统采用。</li>
</ul>
<h3 id="4-3-Version-3-基于名称和-MD5-散列的-UUID-Name-based-UUID-MD5"><a href="#4-3-Version-3-基于名称和-MD5-散列的-UUID-Name-based-UUID-MD5" class="headerlink" title="4.3 Version 3: 基于名称和 MD5 散列的 UUID (Name-based UUID, MD5)"></a>4.3 Version 3: 基于名称和 MD5 散列的 UUID (Name-based UUID, MD5)</h3><ul>
<li><strong>生成方式：</strong> 通过对一个命名空间 UUID 和一个名称字符串进行 MD5 散列计算来生成。同一个命名空间 UUID 和名称字符串总是会生成相同的 Version 3 UUID。</li>
<li><strong>结构：</strong><ul>
<li>将命名空间 UUID (128位) 和名称 (变长字节串) 拼接起来。</li>
<li>对拼接后的结果计算 MD5 散列。</li>
<li>将散列值的特定位设置为版本号 (<code>0011</code>b) 和变体。</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li><strong>可预测性&#x2F;可重复性：</strong> 给定相同的命名空间和名称，总是能生成相同的 UUID。这在需要为特定资源提供稳定标识符，且资源标识符依赖于其名称时非常有用。</li>
<li><strong>去中心化：</strong> 无需中央协调，只要知道命名空间和名称即可生成。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>碰撞风险：</strong> MD5 算法已被证明存在碰撞（虽然在 UUID 场景下，实际碰撞的概率依然极低）。</li>
<li><strong>不可随机：</strong> 不适用于需要随机或隐私保护的场景。</li>
<li><strong>不具有排序性。</strong></li>
</ul>
</li>
</ul>
<h3 id="4-4-Version-4-基于随机数的-UUID-Random-based-UUID"><a href="#4-4-Version-4-基于随机数的-UUID-Random-based-UUID" class="headerlink" title="4.4 Version 4: 基于随机数的 UUID (Random-based UUID)"></a>4.4 Version 4: 基于随机数的 UUID (Random-based UUID)</h3><ul>
<li><strong>生成方式：</strong> UUID 的大部分位是纯粹的随机或伪随机数，只有版本号（<code>0100</code>b）和变体位是固定的。</li>
<li><strong>结构：</strong><ul>
<li>其余 122 位为随机数。</li>
<li>版本号 <code>0100</code>b。</li>
<li>变体字段。</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li><strong>简单易用：</strong> 最简单，最常用的 UUID 类型，生成只需一个高质量的随机数源。</li>
<li><strong>隐私保护：</strong> 不包含任何机器或时间信息。</li>
<li><strong>极低的碰撞概率：</strong> 即使在高并发环境下，碰撞概率也极低（生成 2^122 个 UUID 才会期望发生一次碰撞）。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>无序性：</strong> 随机性导致 UUID 字符串表示完全无序，这在数据库索引中可能导致页分裂，降低数据库性能。</li>
<li><strong>无法通过 UUID 本身获取任何信息。</strong></li>
</ul>
</li>
</ul>
<h3 id="4-5-Version-5-基于名称和-SHA-1-散列的-UUID-Name-based-UUID-SHA-1"><a href="#4-5-Version-5-基于名称和-SHA-1-散列的-UUID-Name-based-UUID-SHA-1" class="headerlink" title="4.5 Version 5: 基于名称和 SHA-1 散列的 UUID (Name-based UUID, SHA-1)"></a>4.5 Version 5: 基于名称和 SHA-1 散列的 UUID (Name-based UUID, SHA-1)</h3><ul>
<li><strong>生成方式：</strong> 与 Version 3 类似，但使用 SHA-1 散列算法替代 MD5。</li>
<li><strong>结构：</strong><ul>
<li>将命名空间 UUID 和名称拼接。</li>
<li>对拼接后的结果计算 SHA-1 散列。</li>
<li>将散列值的特定位设置为版本号 (<code>0101</code>b) 和变体。</li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li>与 Version 3 类似的可预测性&#x2F;可重复性。</li>
<li><strong>更高的安全性：</strong> SHA-1 比 MD5 更安全，碰撞风险更低。因此，<strong>Version 5 是 Version 3 的推荐替代品。</strong></li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>SHA-1 算法也已被证明存在理论上的碰撞，但实际应用中对于 UUID 而言风险仍非常低。</li>
<li>不具有排序性。</li>
<li>不可随机。</li>
</ul>
</li>
</ul>
<h3 id="4-6-新版本草案-Version-6-7-8"><a href="#4-6-新版本草案-Version-6-7-8" class="headerlink" title="4.6 新版本草案 (Version 6, 7, 8)"></a>4.6 新版本草案 (Version 6, 7, 8)</h3><p>随着分布式系统和数据库技术的发展，人们对 UUID 的需求也更加精细，尤其关注其在数据库中的排序性能。IETF 正在制定新的 UUID 版本草案，旨在解决现有版本的一些痛点。</p>
<ul>
<li><p><strong>Version 6: Reordered Time-based UUID</strong></p>
<ul>
<li><strong>核心思想：</strong> 将 Version 1 的时间戳字段重新排列，使其在字符串表示上具有单调递增性。</li>
<li><strong>优点：</strong> 保留了 Version 1 的时间特性和 MAC 地址，同时解决了 Version 1 在数据库中索引效率低的问题。</li>
<li><strong>缺点：</strong> 依然包含 MAC 地址，存在隐私问题。</li>
</ul>
</li>
<li><p><strong>Version 7: Unix Epoch Time-based UUID</strong></p>
<ul>
<li><strong>核心思想：</strong> 使用 Unix epoch 时间（自 1970-01-01 UTC 起的毫秒或微秒）作为 UUID 的前缀，后跟随机数。</li>
<li><strong>优点：</strong><ul>
<li><strong>严格的时间顺序：</strong> 能够直接进行字典序排序，非常适合作为数据库主键。</li>
<li><strong>不泄露 MAC 地址。</strong></li>
<li>结合了时间序和随机性，提供了良好的唯一性和低碰撞概率。</li>
<li>时间戳是标准 Unix 时间，易于理解和转换。</li>
</ul>
</li>
<li><strong>缺点：</strong> 需要高质量的随机数源。</li>
</ul>
</li>
<li><p><strong>Version 8: Custom UUID</strong></p>
<ul>
<li><strong>核心思想：</strong> 允许用户自定义 UUID 的生成算法和数据布局，以满足特定应用场景的需求。</li>
<li><strong>优点：</strong> 极高的灵活性。</li>
<li><strong>缺点：</strong> 缺乏标准化，可能导致互操作性问题，需要使用者自行确保唯一性。</li>
</ul>
</li>
</ul>
<h2 id="五、UUID-版本选择指南"><a href="#五、UUID-版本选择指南" class="headerlink" title="五、UUID 版本选择指南"></a>五、UUID 版本选择指南</h2><p>选择 UUID 版本取决于具体应用场景的需求。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph LR
    A[Start] --&gt; B{需要可预测的ID或&lt;br&gt;基于名称的ID?};
    B -- Yes --&gt; C{需要更强的哈希算法?};
    C -- Yes --&gt; V5[&quot;Version 5 (SHA-1)&quot;];
    C -- No --&gt; V3[&quot;Version 3 (MD5)&quot;];
    B -- No --&gt; D{需要在数据库中高效排序?};
    D -- Yes --&gt; E{&quot;对隐私敏感(MAC)?&quot;};
    E -- No --&gt; V6[&quot;Version 6 &lt;br&gt;(Reordered Time&#x2F;MAC)&quot;];
    E -- Yes --&gt; V7[&quot;Version 7 &lt;br&gt;(Unix Epoch Time&#x2F;Random
    )&quot;];
    D -- No --&gt; F{对生成ID的机器隐私敏感?};
    F -- Yes --&gt; V4[&quot;Version 4 (Random)&quot;];
    F -- No --&gt; V1[&quot;Version 1 (Time&#x2F;MAC)&quot;];
    V1 --&gt; G[考虑替代: 雪花算法&#x2F;ULID];
    V4 --&gt; G;
    V6 --&gt; G;
    V7 --&gt; G;
    V3 --&gt; G;
    V5 --&gt; G;
    G[End];
  </pre></div>

<h2 id="六、UUID-的优缺点"><a href="#六、UUID-的优缺点" class="headerlink" title="六、UUID 的优缺点"></a>六、UUID 的优缺点</h2><h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h3><ul>
<li><strong>高唯一性：</strong> 碰撞概率极低，足以满足绝大多数应用的需求。</li>
<li><strong>分布式生成：</strong> 无需中心化服务，可在任何地方独立生成，降低系统复杂性和单点故障风险。</li>
<li><strong>隐私保护 (V4, V5, V7)：</strong> 某些版本不包含任何可识别的机器或时间信息。</li>
<li><strong>与数据库无关：</strong> 不依赖特定数据库或存储系统的自增机制。</li>
<li><strong>易于集成：</strong> 大多数编程语言都提供了生成 UUID 的标准库或第三方库。</li>
</ul>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h3><ul>
<li><strong>存储空间：</strong> UUID 为 16 字节（128 位），比传统的 4 字节（int）或 8 字节（bigint）整数占用更多存储空间。</li>
<li><strong>性能影响：</strong><ul>
<li><strong>索引碎片：</strong> Version 4 的随机性可能导致数据库索引页分裂，影响查询和写入性能。Version 1&#x2F;6&#x2F;7 通过引入时间排序可以缓解此问题。</li>
<li><strong>缓存效率：</strong> 随机的 UUID 导致数据在磁盘上的物理存储不连续，降低缓存命中率。</li>
</ul>
</li>
<li><strong>可读性差：</strong> 长的十六进制字符串对人类不友好，难以记忆和调试。</li>
<li><strong>数据类型：</strong> 在某些数据库中，将 UUID 存储为 <code>VARCHAR</code> 或 <code>TEXT</code> 类型会进一步增加存储和性能开销。推荐使用 <code>BINARY(16)</code> 或数据库原生 UUID 类型。</li>
</ul>
<h2 id="七、Go-语言中生成-UUID-示例"><a href="#七、Go-语言中生成-UUID-示例" class="headerlink" title="七、Go 语言中生成 UUID 示例"></a>七、Go 语言中生成 UUID 示例</h2><p>Go 语言标准库 <code>crypto/rand</code> 提供了生成随机数的能力，但没有直接的 UUID 实现。通常使用 <code>github.com/google/uuid</code> 等第三方库。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/google/uuid&quot;</span> <span class="comment">// go get github.com/google/uuid</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Version 1 (Time-based UUID)</span></span><br><span class="line">	<span class="comment">// 包含MAC地址和时间信息，具有一定顺序性</span></span><br><span class="line">	uuidV1, err := uuid.NewV1()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Error generating V1 UUID: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Version 1 UUID: %s\n&quot;</span>, uuidV1.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Version 3 (Name-based, MD5)</span></span><br><span class="line">	<span class="comment">// 基于命名空间和名称，MD5哈希，可重复生成</span></span><br><span class="line">	namespace := uuid.MustParse(<span class="string">&quot;6ba7b810-9dad-11d1-80b4-00c04fd430c8&quot;</span>) <span class="comment">// 示例命名空间</span></span><br><span class="line">	name := <span class="string">&quot;example.com&quot;</span></span><br><span class="line">	uuidV3 := uuid.NewV3(namespace, name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Version 3 UUID (for &#x27;%s&#x27; in namespace &#x27;%s&#x27;): %s\n&quot;</span>, name, namespace, uuidV3.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Version 4 (Random-based UUID)</span></span><br><span class="line">	<span class="comment">// 最常用，纯随机数，无任何可识别信息，但无序</span></span><br><span class="line">	uuidV4 := uuid.New() <span class="comment">// 默认生成V4</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Version 4 UUID: %s\n&quot;</span>, uuidV4.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Version 5 (Name-based, SHA-1)</span></span><br><span class="line">	<span class="comment">// 基于命名空间和名称，SHA-1哈希，可重复生成，比V3更安全</span></span><br><span class="line">	uuidV5 := uuid.NewV5(namespace, name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Version 5 UUID (for &#x27;%s&#x27; in namespace &#x27;%s&#x27;): %s\n&quot;</span>, name, namespace, uuidV5.String())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 演示UUID对象的字节表示和解析</span></span><br><span class="line">	uuidBytes := uuidV4.Node() <span class="comment">// 获取MAC地址部分 (仅V1有效)</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;V4 UUID as bytes: %x\n&quot;</span>, uuidV4.Node()) <span class="comment">// 对于V4，Node()返回一个空切片</span></span><br><span class="line"></span><br><span class="line">	parsedUUID, err := uuid.Parse(uuidV4.String())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Error parsing UUID: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Parsed UUID: %s\n&quot;</span>, parsedUUID.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、Python-中生成-UUID-示例"><a href="#八、Python-中生成-UUID-示例" class="headerlink" title="八、Python 中生成 UUID 示例"></a>八、Python 中生成 UUID 示例</h2><p>Python 的 <code>uuid</code> 标准库提供了非常完善的 UUID 生成功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Version 1 (Time-based UUID)</span></span><br><span class="line"><span class="comment"># 包含MAC地址和时间信息，具有一定顺序性</span></span><br><span class="line">uuid_v1 = uuid.uuid1()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Version 1 UUID: <span class="subst">&#123;uuid_v1&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Version 3 (Name-based, MD5)</span></span><br><span class="line"><span class="comment"># 基于命名空间和名称，MD5哈希，可重复生成</span></span><br><span class="line"><span class="comment"># uuid.NAMESPACE_DNS 是一个预定义的命名空间</span></span><br><span class="line">name = <span class="string">&quot;example.com&quot;</span></span><br><span class="line">uuid_v3 = uuid.uuid3(uuid.NAMESPACE_DNS, name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Version 3 UUID (for &#x27;<span class="subst">&#123;name&#125;</span>&#x27; in NAMESPACE_DNS): <span class="subst">&#123;uuid_v3&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Version 4 (Random-based UUID)</span></span><br><span class="line"><span class="comment"># 最常用，纯随机数，无任何可识别信息，但无序</span></span><br><span class="line">uuid_v4 = uuid.uuid4()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Version 4 UUID: <span class="subst">&#123;uuid_v4&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Version 5 (Name-based, SHA-1)</span></span><br><span class="line"><span class="comment"># 基于命名空间和名称，SHA-1哈希，可重复生成，比V3更安全</span></span><br><span class="line">uuid_v5 = uuid.uuid5(uuid.NAMESPACE_DNS, name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Version 5 UUID (for &#x27;<span class="subst">&#123;name&#125;</span>&#x27; in NAMESPACE_DNS): <span class="subst">&#123;uuid_v5&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取UUID的各个部分</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nUUID V1 fields:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Time low: <span class="subst">&#123;uuid_v1.time_low&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Time mid: <span class="subst">&#123;uuid_v1.time_mid&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Time high and version: <span class="subst">&#123;uuid_v1.time_high_and_version&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Clock seq high and variant: <span class="subst">&#123;uuid_v1.clock_seq_high_and_variant&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Clock seq low: <span class="subst">&#123;uuid_v1.clock_seq_low&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Node (MAC address): <span class="subst">&#123;<span class="built_in">hex</span>(uuid_v1.node)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Version: <span class="subst">&#123;uuid_v1.version&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  Variant: <span class="subst">&#123;uuid_v1.variant&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>UUID 是一种强大且广泛应用的全局唯一标识符，尤其适用于分布式系统。理解不同版本的生成机制、优缺点以及适用场景，对于在系统设计中做出明智的标识符选择至关重要。虽然 Version 4 是最常用的 UUID 类型，但为了优化数据库性能和满足特定业务需求，Version 1、Version 6 和 Version 7 (一旦标准化) 提供了更好的排序特性，而 Version 3 和 Version 5 则提供了基于名称的确定性标识。在实际应用中，还应考虑将 UUID 存储为 <code>BINARY(16)</code> 类型以节省空间和提高查询效率。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/dd818a0507ce/">https://blog.tbf1211.xx.kg/dd818a0507ce/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a><a class="post-meta__tags" href="/tags/UUID/">UUID</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/9d4cfe955d7d/" title="计算机随机数生成原理详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机随机数生成原理详解</div></div><div class="info-2"><div class="info-item-1">在计算机科学和工程领域，随机数扮演着极其重要的角色，从游戏娱乐到科学模拟，从数据加密到安全协议，几乎处处都需要随机数的支持。然而，计算机本质上是确定性机器，要生成“真正”的随机数并非易事。因此，理解计算机如何生成随机数及其背后的原理变得尤为关键。  随机数是指在一定范围内无法预测，且每个数值出现的概率相等的一组数。在计算机中，我们通常将随机数分为两大类：伪随机数 (Pseudo-Random Number) 和 真随机数 (True Random Number)。  核心概念：随机数并非“无序”，而是指其不可预测性和统计均匀性。    一、伪随机数生成器 (PRNG)伪随机数生成器 (Pseudo-Random Number Generator, PRNG) 是一种算法，它通过一个初始的“种子”(seed) 值，生成一个看似随机的数值序列。这个序列在统计学上表现出随机的特性，但实际上是完全确定性的，即可重现的。 1.1 工作原理PRNG 的核心思想是确定性算法。给定相同的初始种子，PRNG 总是会生成相同的随机数序列。其工作流程通常如下：      graph TB     %%...</div></div></div></a><a class="pagination-related" href="/b8afac30c52e/" title="开源协议详解：理解与选择的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">开源协议详解：理解与选择的艺术</div></div><div class="info-2"><div class="info-item-1"> 在开源软件的世界里，开源协议 (Open Source License) 扮演着至关重要的角色。它定义了你对开源代码的权利和义务：你可以做什么，不能做什么，以及当你修改或分发代码时需要遵守哪些规则。理解这些协议对于开发者、公司和代码使用者来说都至关重要，它不仅关乎合法合规，更影响着项目的成长、社区的形成以及商业模式的选择。  “开源协议是开源世界的宪法，明确了游戏规则，确保了开放与合作的平衡。”   一、什么是开源协议？为什么需要它？开源协议是一份法律文件，它授予用户使用、修改和分发开源软件的权利，但同时也会施加一定的条件和限制。 为什么需要开源协议？  界定权利与义务：明确使用者可以对代码做什么（使用、修改、分发），以及必须做什么（保留版权信息、公开源码等）。 保护贡献者：允许贡献者保留版权，同时授权他人使用，确保其辛勤工作不会被恶意独占。 促进创新：降低了他人基于现有代码进行二次开发和创新的门槛。 建立信任：协议的公开透明有助于社区形成共识，促进协作。 避免法律纠纷：明确的协议条款可以减少因代码使用引起的所有权、责任和版权争议。  核心问题：任何没有明确开源协议的代码，默认...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/b8edc2276249/" title="雪花算法 (Snowflake Algorithm) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-19</div><div class="info-item-2">雪花算法 (Snowflake Algorithm) 详解</div></div><div class="info-2"><div class="info-item-1"> 雪花算法 (Snowflake Algorithm) 是 Twitter 公司开源的一种分布式唯一 ID 生成算法。它旨在解决在分布式系统中生成全局唯一、递增（但非严格递增）且高性能 ID 的需求。其生成的 ID 是一个 64 位的整数，具有时间有序性，并且不依赖于数据库，易于扩展。  核心思想：将 64 位的 Long 型 ID 拆分为多个字段，分别存储时间戳、数据中心 ID、机器 ID 和序列号，通过位运算拼接以保证全局唯一性和大致的时间有序性。   一、为什么需要雪花算法？在分布式系统中，传统的单点自增 ID 方案面临巨大挑战：  唯一性问题：不同的数据库实例或服务节点可能生成相同的 ID。 性能瓶颈：为了保证唯一性，可能需要引入中心化的 ID 生成服务或数据库锁，成为系统瓶颈。 可用性问题：中心化服务一旦宕机，整个系统的 ID 生成将受影响。  虽然 UUID 能够保证全局唯一性，但它存在一些缺点：  存储和传输效率低：128 位，比 64 位 ID 更占用空间，索引性能较差。 无序性：UUID 是无序的，插入数据库时会导致 B+ 树索引频繁分裂和重建，影响数据库性能。...</div></div></div></a><a class="pagination-related" href="/9d4cfe955d7d/" title="计算机随机数生成原理详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-25</div><div class="info-item-2">计算机随机数生成原理详解</div></div><div class="info-2"><div class="info-item-1">在计算机科学和工程领域，随机数扮演着极其重要的角色，从游戏娱乐到科学模拟，从数据加密到安全协议，几乎处处都需要随机数的支持。然而，计算机本质上是确定性机器，要生成“真正”的随机数并非易事。因此，理解计算机如何生成随机数及其背后的原理变得尤为关键。  随机数是指在一定范围内无法预测，且每个数值出现的概率相等的一组数。在计算机中，我们通常将随机数分为两大类：伪随机数 (Pseudo-Random Number) 和 真随机数 (True Random Number)。  核心概念：随机数并非“无序”，而是指其不可预测性和统计均匀性。    一、伪随机数生成器 (PRNG)伪随机数生成器 (Pseudo-Random Number Generator, PRNG) 是一种算法，它通过一个初始的“种子”(seed) 值，生成一个看似随机的数值序列。这个序列在统计学上表现出随机的特性，但实际上是完全确定性的，即可重现的。 1.1 工作原理PRNG 的核心思想是确定性算法。给定相同的初始种子，PRNG 总是会生成相同的随机数序列。其工作流程通常如下：      graph TB     %%...</div></div></div></a><a class="pagination-related" href="/56d360e5bda1/" title="SNAT 与 DNAT 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">SNAT 与 DNAT 详解</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation，网络地址转换) 是 IPv4 网络中一项基本而关键的技术，它在数据包流经网络设备（如路由器或防火墙）时修改其 IP 地址信息（有时也包括端口号）。NAT 根据修改方向和目的主要分为两大类型：源网络地址转换 (SNAT - Source Network Address Translation) 和 目的网络地址转换 (DNAT - Destination Network Address Translation)。理解这两种机制对于网络设计、故障排查和安全性至关重要。  核心思想：  SNAT：解决“内部网络中主机如何安全地、共享地访问外部网络资源”的问题，修改出站数据包的源地址。 DNAT：解决“外部网络中主机如何安全地访问内部提供的服务”的问题，修改入站数据包的目的地址。     一、网络地址转换 (NAT) 概述NAT 技术最初是为了缓解 IPv4 地址枯竭问题而设计，它允许一个内部私有 IP 网络通过一个或几个公共 IP 地址与外部网络（如互联网）通信。除了地址共享，NAT 也为内部网络提供了一层基本的安全隔...</div></div></div></a><a class="pagination-related" href="/dec2dcdddd31/" title="单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-14</div><div class="info-item-2">单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解</div></div><div class="info-2"><div class="info-item-1"> 在计算机网络中，数据包从一个源发送到多个目的地的策略被称为通信模式。理解这些模式——单播 (Unicast)、组播 (Multicast)、广播 (Broadcast) 和任播 (Anycast)——对于网络设计、数据传输优化以及故障排除至关重要。它们定义了数据如何寻址和如何在网络中传播，各自适用于不同的应用场景，并对网络性能和资源消耗有着显著影响。  核心思想：根据数据包的目的地数量和选择策略，将网络通信划分为四种基本模式，每种模式都有其独特的传输效率、资源利用和应用场景。   一、传输模式概述   传输模式 描述 接收方数量 IP 地址类型 传输效率 主要应用    单播 一对一传输。最常见的模式。 1 普通 IP 地址 高 (点对点) HTTP, TCP, Telnet, SSH, FTP   广播 一对所有传输，限于同一广播域内。 所有 广播地址 (255.255.255.255) 低 (网络泛洪) ARP, DHCP, OLPC, 唤醒局域网   组播 一对多传输，发送给特定组中的成员。 多个 组播地址 (224.0.0.0/4) 高 (路由支持) 视频直播, 在线游...</div></div></div></a><a class="pagination-related" href="/6920c2a60356/" title="Substitution-box (S-box) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-13</div><div class="info-item-2">Substitution-box (S-box) 详解</div></div><div class="info-2"><div class="info-item-1"> 在现代对称密钥密码算法，特别是分组密码 (Block Ciphers) 中，Substitution-box (S-box) 是一个至关重要的组件。S-box 的引入是为了提供算法的非线性性 (Non-linearity)，这是确保密码安全性的核心要素之一。如果一个密码算法是线性的，攻击者可以利用线性代数方法轻松破解它。S-box 通过将输入位模式映射到不同的输出位模式，使得整个加密过程变得高度复杂和混沌，从而抵抗各种密码分析攻击。  核心思想：S-box 的核心作用是在分组密码中引入非线性变换，将输入位序列替换为与输入不呈线性关系的输出位序列，从而增强密码的混淆性 (confusion) 和扩散性 (diffusion)，抵抗线性密码分析和差分密码分析等攻击。   一、什么是 S-box？1.1 定义Substitution-box (S-box)，也称为替换盒，是一个查找表 (lookup table)，它接受一个固定长度的输入位序列（通常是若干位），并生成一个不同或相同长度的输出位序列。S-box 的设计目的是实现非线性变换：它不是一个简单的位移、异或 (XOR) 或加法...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">567</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">233</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">85</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-UUID%EF%BC%9F"><span class="toc-text">一、为什么需要 UUID？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="toc-text">二、关键概念定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-UUID-Universally-Unique-Identifier"><span class="toc-text">2.1 UUID (Universally Unique Identifier)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-GUID-Globally-Unique-Identifier"><span class="toc-text">2.2 GUID (Globally Unique Identifier)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%A2%B0%E6%92%9E-Collision"><span class="toc-text">2.3 碰撞 (Collision)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%86%B5-Entropy"><span class="toc-text">2.4 熵 (Entropy)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-Namespace"><span class="toc-text">2.5 命名空间 (Namespace)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81UUID-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">三、UUID 的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81UUID-%E7%9A%84%E7%89%88%E6%9C%AC%E8%AF%A6%E8%A7%A3"><span class="toc-text">四、UUID 的版本详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Version-1-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84-UUID-Time-based-UUID"><span class="toc-text">4.1 Version 1: 基于时间的 UUID (Time-based UUID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Version-2-DCE-%E5%AE%89%E5%85%A8-UUID-DCE-Security-UUID"><span class="toc-text">4.2 Version 2: DCE 安全 UUID (DCE Security UUID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Version-3-%E5%9F%BA%E4%BA%8E%E5%90%8D%E7%A7%B0%E5%92%8C-MD5-%E6%95%A3%E5%88%97%E7%9A%84-UUID-Name-based-UUID-MD5"><span class="toc-text">4.3 Version 3: 基于名称和 MD5 散列的 UUID (Name-based UUID, MD5)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Version-4-%E5%9F%BA%E4%BA%8E%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84-UUID-Random-based-UUID"><span class="toc-text">4.4 Version 4: 基于随机数的 UUID (Random-based UUID)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Version-5-%E5%9F%BA%E4%BA%8E%E5%90%8D%E7%A7%B0%E5%92%8C-SHA-1-%E6%95%A3%E5%88%97%E7%9A%84-UUID-Name-based-UUID-SHA-1"><span class="toc-text">4.5 Version 5: 基于名称和 SHA-1 散列的 UUID (Name-based UUID, SHA-1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%96%B0%E7%89%88%E6%9C%AC%E8%8D%89%E6%A1%88-Version-6-7-8"><span class="toc-text">4.6 新版本草案 (Version 6, 7, 8)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81UUID-%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97"><span class="toc-text">五、UUID 版本选择指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81UUID-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">六、UUID 的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BC%98%E7%82%B9"><span class="toc-text">6.1 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BC%BA%E7%82%B9"><span class="toc-text">6.2 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%94%9F%E6%88%90-UUID-%E7%A4%BA%E4%BE%8B"><span class="toc-text">七、Go 语言中生成 UUID 示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Python-%E4%B8%AD%E7%94%9F%E6%88%90-UUID-%E7%A4%BA%E4%BE%8B"><span class="toc-text">八、Python 中生成 UUID 示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">九、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go.sum 文件中特殊哈希计算详解"/></a><div class="content"><a class="title" href="/cd5b6fd178d8/" title="go.sum 文件中特殊哈希计算详解">go.sum 文件中特殊哈希计算详解</a><time datetime="2026-02-23T22:24:00.000Z" title="发表于 2026-02-24 06:24:00">2026-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d819fc26cbc7/" title="共识算法详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="共识算法详解"/></a><div class="content"><a class="title" href="/d819fc26cbc7/" title="共识算法详解">共识算法详解</a><time datetime="2026-02-19T22:24:00.000Z" title="发表于 2026-02-20 06:24:00">2026-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1c5cbb334a2a/" title="计算机中熵的详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机中熵的详解"/></a><div class="content"><a class="title" href="/1c5cbb334a2a/" title="计算机中熵的详解">计算机中熵的详解</a><time datetime="2026-02-17T22:24:00.000Z" title="发表于 2026-02-18 06:24:00">2026-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/9ed85cc18e8a/" title="CSP并发模型详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSP并发模型详解"/></a><div class="content"><a class="title" href="/9ed85cc18e8a/" title="CSP并发模型详解">CSP并发模型详解</a><time datetime="2026-02-15T22:24:00.000Z" title="发表于 2026-02-16 06:24:00">2026-02-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0d177e0002e6/" title="程序错误处理详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序错误处理详解"/></a><div class="content"><a class="title" href="/0d177e0002e6/" title="程序错误处理详解">程序错误处理详解</a><time datetime="2026-02-13T22:24:00.000Z" title="发表于 2026-02-14 06:24:00">2026-02-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-17.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>