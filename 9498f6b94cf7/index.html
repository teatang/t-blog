<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>交换机 (Switch) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="交换机 (Switch) 是一种工作在 OSI 模型数据链路层（第二层）或更高层（如第三层）的网络设备。它的主要功能是连接局域网 (LAN) 中的多个网络设备（计算机、服务器、打印机等），并根据 MAC 地址智能地转发数据帧，从而在物理上分割冲突域，优化网络性能。与传统的集线器 (Hub) 相比，交换机能够提供更高的网络效率和更好的安全性。  核心功能：根据 MAC 地址智能转发数据帧，隔离冲突">
<meta property="og:type" content="article">
<meta property="og:title" content="交换机 (Switch) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/9498f6b94cf7/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="交换机 (Switch) 是一种工作在 OSI 模型数据链路层（第二层）或更高层（如第三层）的网络设备。它的主要功能是连接局域网 (LAN) 中的多个网络设备（计算机、服务器、打印机等），并根据 MAC 地址智能地转发数据帧，从而在物理上分割冲突域，优化网络性能。与传统的集线器 (Hub) 相比，交换机能够提供更高的网络效率和更好的安全性。  核心功能：根据 MAC 地址智能转发数据帧，隔离冲突">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg">
<meta property="article:published_time" content="2024-07-29T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-01T09:41:47.051Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="硬件相关">
<meta property="article:tag" content="网络设备">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "交换机 (Switch) 详解",
  "url": "https://blog.tbf1211.xx.kg/9498f6b94cf7/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg",
  "datePublished": "2024-07-29T22:24:00.000Z",
  "dateModified": "2026-02-01T09:41:47.051Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/9498f6b94cf7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '交换机 (Switch) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">交换机 (Switch) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">交换机 (Switch) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-07-29T22:24:00.000Z" title="发表于 2024-07-30 06:24:00">2024-07-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/">硬件相关</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>交换机 (Switch)</strong> 是一种工作在 OSI 模型数据链路层（第二层）或更高层（如第三层）的网络设备。它的主要功能是连接局域网 (LAN) 中的多个网络设备（计算机、服务器、打印机等），并根据 MAC 地址智能地转发数据帧，从而在物理上分割冲突域，优化网络性能。与传统的集线器 (Hub) 相比，交换机能够提供更高的网络效率和更好的安全性。</p>
</blockquote>
<div class="note info flat"><p>核心功能：根据 MAC 地址智能转发数据帧，隔离冲突域，提高局域网效率。</p>
</div>
<hr>
<h2 id="一、什么是交换机？"><a href="#一、什么是交换机？" class="headerlink" title="一、什么是交换机？"></a>一、什么是交换机？</h2><p>交换机，全称是<strong>以太网交换机 (Ethernet Switch)</strong>，是现代局域网 (LAN) 中最常见的连接设备。它拥有多个端口，每个端口都可以连接一个独立的网络设备或子网。当数据帧到达交换机的一个端口时，交换机会检查数据帧中的目标 MAC 地址，并将其精确地转发到目标设备所连接的端口，而不是像集线器那样泛洪到所有端口。</p>
<p><strong>交换机在网络中的作用：</strong></p>
<ul>
<li><strong>连接设备</strong>：将多台计算机、服务器、网络打印机等设备连接到同一个局域网中。</li>
<li><strong>数据转发</strong>：根据学习到的 MAC 地址信息，实现数据帧的智能、高效转发。</li>
<li><strong>隔离冲突域</strong>：每个交换机端口都构成一个独立的冲突域，有效减少了网络拥堵。</li>
<li><strong>支持多种功能</strong>：提供如 VLAN、QoS、端口聚合、PoE 等高级功能，满足不同网络需求。</li>
</ul>
<h2 id="二、交换机的工作原理"><a href="#二、交换机的工作原理" class="headerlink" title="二、交换机的工作原理"></a>二、交换机的工作原理</h2><p>交换机主要工作在 OSI 模型的数据链路层（第二层），其核心工作机制基于 MAC 地址。</p>
<h3 id="2-1-MAC-地址学习-MAC-Address-Learning"><a href="#2-1-MAC-地址学习-MAC-Address-Learning" class="headerlink" title="2.1 MAC 地址学习 (MAC Address Learning)"></a>2.1 MAC 地址学习 (MAC Address Learning)</h3><p>当交换机启动并接收到数据帧时，它会执行 MAC 地址学习以构建其内部的 <strong>MAC 地址表 (MAC Address Table)</strong>，也称为 <strong>CAM 表 (Content Addressable Memory table)</strong>。</p>
<ol>
<li><strong>检查源 MAC 地址</strong>：当一个数据帧从某个端口进入交换机时，交换机会读取数据帧的<strong>源 MAC 地址</strong>。</li>
<li><strong>记录映射关系</strong>：交换机将这个源 MAC 地址与接收该数据帧的<strong>端口号</strong>进行绑定，并将其记录在 MAC 地址表中。</li>
<li><strong>老化时间</strong>：MAC 地址表中的条目通常有超时时间（老化时间）。如果在一定时间内没有再次接收到来自该 MAC 地址的数据帧，该条目将被删除，以避免存储过时信息，并适应网络拓扑的变化。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant DeviceA as 设备A (MAC_A)
    participant DeviceB as 设备B (MAC_B)
    participant Switch as 交换机
    participant Port1 as 端口1
    participant Port2 as 端口2

    DeviceA-&gt;&gt;Port1: 发送数据帧 (源MAC: MAC_A, 目的MAC: MAC_B)
    activate Switch
    Switch-&gt;&gt;Switch: 1. 检查帧源MAC地址 (MAC_A)
    Switch-&gt;&gt;Switch: 2. 学习：MAC_A &lt;-&gt; 端口1
    Switch-&gt;&gt;Switch: 3. 更新MAC地址表
    Switch-&gt;&gt;Switch: 4. 检查帧目的MAC地址 (MAC_B)
    alt MAC_B 在表中
        Switch-&gt;&gt;Port2: 5a. 转发到对应端口 (MAC_B&lt;-&gt;端口2)
        Port2-&gt;&gt;DeviceB: 6a. 接收数据帧
    else MAC_B 不在表中 or 是广播地址
        Switch-&gt;&gt;AllPortsExceptSource: 5b. 泛洪 (除接收端口外)
        Port2-&gt;&gt;DeviceB: 6b. 接收泛洪数据 (如ARP请求)
    end
    deactivate Switch
  </pre></div>

<h3 id="2-2-帧转发、过滤与泛洪-Frame-Forwarding-Filtering-Flooding"><a href="#2-2-帧转发、过滤与泛洪-Frame-Forwarding-Filtering-Flooding" class="headerlink" title="2.2 帧转发、过滤与泛洪 (Frame Forwarding, Filtering, Flooding)"></a>2.2 帧转发、过滤与泛洪 (Frame Forwarding, Filtering, Flooding)</h3><p>在学习到 MAC 地址后，交换机根据数据帧的<strong>目的 MAC 地址</strong>执行以下操作：</p>
<ul>
<li><strong>转发 (Forwarding)</strong>：<br>如果目的 MAC 地址在 MAC 地址表中找到，并且对应的端口不是数据帧进入的端口，交换机就将数据帧只转发到与目的 MAC 地址绑定的那个特定端口。这是最理想的情况，实现了单播通信。</li>
<li><strong>过滤 (Filtering)</strong>：<br>如果目的 MAC 地址在 MAC 地址表中找到，并且对应的端口就是数据帧进入的端口（例如，设备A向设备A自己发送数据包，或者数据包被某设备捕获后又重新发回），交换机就不会再将数据帧转发到其他端口，直接丢弃该数据帧，避免不必要的网络流量。</li>
<li><strong>泛洪 (Flooding)</strong>：<br>如果目的 MAC 地址不在 MAC 地址表中，或者目的 MAC 地址是一个<strong>广播地址 (Broadcast MAC, FF:FF:FF:FF:FF:FF)</strong>，交换机则会将数据帧发送到除接收端口之外的所有其他端口。这种行为称为泛洪。泛洪常用于 ARP 请求 (Address Resolution Protocol) 或其他广播通信，通过泛洪，目标设备有机会响应，从而使交换机学习到其 MAC 地址。</li>
</ul>
<h3 id="2-3-冲突域与广播域-Collision-Domain-vs-Broadcast-Domain"><a href="#2-3-冲突域与广播域-Collision-Domain-vs-Broadcast-Domain" class="headerlink" title="2.3 冲突域与广播域 (Collision Domain vs. Broadcast Domain)"></a>2.3 冲突域与广播域 (Collision Domain vs. Broadcast Domain)</h3><p><strong>冲突域 (Collision Domain)</strong>：指网络中所有设备竞争同一传输介质的范围。当两个或多个设备同时发送数据时，就会发生碰撞。</p>
<ul>
<li><strong>集线器 (Hub)</strong>：所有连接到集线器的设备都处于同一个巨大的冲突域中。</li>
<li><strong>交换机 (Switch)</strong>：通过全双工通信和微区段化，交换机的<strong>每个端口都形成一个独立的冲突域</strong>。这意味着连接到不同交换机端口的设备可以同时发送和接收数据而不会发生冲突，大大提高了网络效率。</li>
</ul>
<p><strong>广播域 (Broadcast Domain)</strong>：指网络中所有设备都能接收到彼此广播帧的范围。</p>
<ul>
<li><strong>交换机</strong>：默认情况下，所有连接到同一个交换机（或多个未划分 VLAN 的交换机连接在一起）的设备都位于<strong>同一个广播域</strong>中。广播帧会泛洪到所有端口。</li>
<li><strong>路由器 (Router)</strong>：隔离广播域。每个路由器端口连接的网络都属于一个独立的广播域。</li>
<li><strong>VLAN (虚拟局域网)</strong>：可以在交换机上逻辑地划分广播域，将一个物理交换机划分为多个虚拟交换机。</li>
</ul>
<h2 id="三、交换机的关键特性与技术"><a href="#三、交换机的关键特性与技术" class="headerlink" title="三、交换机的关键特性与技术"></a>三、交换机的关键特性与技术</h2><p>现代交换机不仅仅是简单的二层转发设备，还集成了许多高级功能以满足复杂的网络需求。</p>
<h3 id="3-1-VLAN-虚拟局域网-Virtual-Local-Area-Network"><a href="#3-1-VLAN-虚拟局域网-Virtual-Local-Area-Network" class="headerlink" title="3.1 VLAN (虚拟局域网, Virtual Local Area Network)"></a>3.1 VLAN (虚拟局域网, Virtual Local Area Network)</h3><ul>
<li><strong>定义</strong>：VLAN 是一种将物理上连接在同一台交换机（或多台交换机）上的设备，逻辑上划分为多个独立广播域的技术。不同 VLAN 之间的设备不能直接通信，需要通过路由器进行转发。</li>
<li><strong>作用</strong>：提高网络安全性（隔离不同部门的流量）、降低广播流量、简化网络管理、灵活组网。</li>
<li><strong>原理</strong>：通过在以太网帧中添加 VLAN 标签 (Tagging，如 IEEE 802.1Q) 来标识帧所属的 VLAN。</li>
</ul>
<h3 id="3-2-STP-生成树协议-Spanning-Tree-Protocol"><a href="#3-2-STP-生成树协议-Spanning-Tree-Protocol" class="headerlink" title="3.2 STP (生成树协议, Spanning Tree Protocol)"></a>3.2 STP (生成树协议, Spanning Tree Protocol)</h3><ul>
<li><strong>定义</strong>：STP (IEEE 802.1D) 是一种用于在以太网交换网络中消除环路，从而防止广播风暴和 MAC 地址表震荡的协议。</li>
<li><strong>作用</strong>：通过阻塞冗余链路，创建无环路的逻辑拓扑，同时提供链路冗余，提高网络的可靠性。</li>
<li><strong>原理</strong>：交换机之间交换 BPDUs (Bridge Protocol Data Units) 来选举根桥 (Root Bridge)，并计算到达根桥的最短路径，阻塞非路径上的冗余端口。</li>
<li><strong>变体</strong>：RSTP (Rapid STP) 提供了更快的收敛速度，MSTP (Multiple STP) 支持基于 VLAN 的多个生成树实例。</li>
</ul>
<h3 id="3-3-LAG-链路聚合组-Link-Aggregation-Group-EtherChannel"><a href="#3-3-LAG-链路聚合组-Link-Aggregation-Group-EtherChannel" class="headerlink" title="3.3 LAG (链路聚合组, Link Aggregation Group) &#x2F; EtherChannel"></a>3.3 LAG (链路聚合组, Link Aggregation Group) &#x2F; EtherChannel</h3><ul>
<li><strong>定义</strong>：将多个物理以太网链路捆绑成一个逻辑链路的技术。</li>
<li><strong>作用</strong>：增加链路带宽（负载均衡）和提高链路冗余（链路故障时流量自动切换到其他成员链路）。</li>
<li><strong>标准</strong>：IEEE 802.3ad (LACP - Link Aggregation Control Protocol)。</li>
</ul>
<h3 id="3-4-PoE-以太网供电-Power-over-Ethernet"><a href="#3-4-PoE-以太网供电-Power-over-Ethernet" class="headerlink" title="3.4 PoE (以太网供电, Power over Ethernet)"></a>3.4 PoE (以太网供电, Power over Ethernet)</h3><ul>
<li><strong>定义</strong>：PoE 允许以太网交换机通过标准以太网电缆为网络设备（如无线接入点、IP 摄像头、VoIP 电话）提供电力。</li>
<li><strong>作用</strong>：简化布线，降低部署成本，提高部署灵活性。</li>
<li><strong>标准</strong>：IEEE 802.3af (PoE), 802.3at (PoE+), 802.3bt (PoE++)。</li>
</ul>
<h3 id="3-5-QoS-服务质量-Quality-of-Service"><a href="#3-5-QoS-服务质量-Quality-of-Service" class="headerlink" title="3.5 QoS (服务质量, Quality of Service)"></a>3.5 QoS (服务质量, Quality of Service)</h3><ul>
<li><strong>定义</strong>：QoS 是一系列技术，用于在网络拥塞时优先处理某些类型的网络流量，确保关键应用的性能。</li>
<li><strong>作用</strong>：保证语音、视频等对延迟和带宽敏感的应用有更好的体验。</li>
<li><strong>原理</strong>：通过流量分类、标记、整形、调度等机制实现。</li>
</ul>
<h3 id="3-6-端口镜像-Port-Mirroring-SPAN-Switched-Port-Analyzer"><a href="#3-6-端口镜像-Port-Mirroring-SPAN-Switched-Port-Analyzer" class="headerlink" title="3.6 端口镜像 (Port Mirroring) &#x2F; SPAN (Switched Port Analyzer)"></a>3.6 端口镜像 (Port Mirroring) &#x2F; SPAN (Switched Port Analyzer)</h3><ul>
<li><strong>定义</strong>：将一个或多个源端口的流量复制到另一个目的端口，而不影响源端口的正常通信。</li>
<li><strong>作用</strong>：用于网络监控、故障诊断、入侵检测等。</li>
</ul>
<h3 id="3-7-安全特性"><a href="#3-7-安全特性" class="headerlink" title="3.7 安全特性"></a>3.7 安全特性</h3><ul>
<li><strong>端口安全 (Port Security)</strong>：限制每个交换机端口允许学习的 MAC 地址数量，或指定特定 MAC 地址才能访问。</li>
<li><strong>DHCP Snooping</strong>：防止恶意 DHCP 服务器攻击，确保 DHCP 报文的合法性。</li>
<li><strong>ARP Inspection (动态 ARP 检测)</strong>：防止 ARP 欺骗攻击，验证 ARP 请求和响应的合法性。</li>
<li><strong>ACL (访问控制列表, Access Control List)</strong>：基于 MAC 地址、IP 地址、端口号等信息对流量进行过滤和控制。</li>
</ul>
<h2 id="四、交换机的分类"><a href="#四、交换机的分类" class="headerlink" title="四、交换机的分类"></a>四、交换机的分类</h2><p>交换机可以根据管理方式、OSI 层级、结构和在网络中的位置进行多种分类。</p>
<h3 id="4-1-按管理方式"><a href="#4-1-按管理方式" class="headerlink" title="4.1 按管理方式"></a>4.1 按管理方式</h3><ul>
<li><strong>非网管型交换机 (Unmanaged Switch)</strong>：<ul>
<li><strong>特点</strong>：即插即用，无需任何配置，价格便宜。</li>
<li><strong>适用场景</strong>：小型家庭网络或办公室，需求简单。</li>
</ul>
</li>
<li><strong>网管型交换机 (Managed Switch)</strong>：<ul>
<li><strong>特点</strong>：提供命令行界面 (CLI)、Web 界面、SNMP 等管理方式，支持 VLAN、QoS、STP 等高级功能。</li>
<li><strong>适用场景</strong>：中大型企业网络、数据中心，需要精细控制和高级功能。</li>
</ul>
</li>
</ul>
<h3 id="4-2-按-OSI-层级"><a href="#4-2-按-OSI-层级" class="headerlink" title="4.2 按 OSI 层级"></a>4.2 按 OSI 层级</h3><ul>
<li><strong>二层交换机 (Layer 2 Switch)</strong>：<ul>
<li><strong>特点</strong>：基于 MAC 地址转发数据帧，工作在数据链路层。是最常见的交换机类型。</li>
<li><strong>作用</strong>：隔离冲突域，提供高速帧转发。</li>
</ul>
</li>
<li><strong>三层交换机 (Layer 3 Switch)</strong>：<ul>
<li><strong>特点</strong>：不仅具备二层交换功能，还具备路由功能，能够进行基于 IP 地址的报文转发。</li>
<li><strong>作用</strong>：在大型局域网中实现不同 VLAN 之间的路由，或作为小型网络的边缘路由器，提供更快的内部路由速度。</li>
</ul>
</li>
<li><strong>多层交换机 (Multilayer Switch)</strong>：<ul>
<li><strong>特点</strong>：能够工作在 OSI 模型更多层（如四层甚至七层），进行更复杂的流量分类和处理（基于 TCP&#x2F;UDP 端口、应用协议等）。</li>
<li><strong>作用</strong>：用于更高级的流量管理、负载均衡、应用优化等场景。</li>
</ul>
</li>
</ul>
<h3 id="4-3-按结构"><a href="#4-3-按结构" class="headerlink" title="4.3 按结构"></a>4.3 按结构</h3><ul>
<li><strong>固定配置型交换机 (Fixed-Configuration Switch)</strong>：<ul>
<li><strong>特点</strong>：端口数量、类型以及功能都是固定的，不可扩展。</li>
<li><strong>适用场景</strong>：成本敏感、端口需求明确的场景。</li>
</ul>
</li>
<li><strong>模块化型交换机 (Modular Switch)</strong>：<ul>
<li><strong>特点</strong>：具有扩展槽，可以通过添加不同功能的模块（如不同端口密度的以太网模块、光纤模块、电源模块）来增加端口数量或功能。</li>
<li><strong>适用场景</strong>：大型企业网络、数据中心，需要高可扩展性、高密度和灵活性。</li>
</ul>
</li>
</ul>
<h3 id="4-4-按网络层次（三层网络架构）"><a href="#4-4-按网络层次（三层网络架构）" class="headerlink" title="4.4 按网络层次（三层网络架构）"></a>4.4 按网络层次（三层网络架构）</h3><p>在大型网络设计中，通常采用三层架构：接入层、汇聚层和核心层。</p>
<ul>
<li><strong>接入层交换机 (Access Layer Switch)</strong>：<ul>
<li><strong>位置</strong>：直接连接终端设备（PC、服务器、IP 电话、AP）。</li>
<li><strong>功能</strong>：提供端口密度、PoE、端口安全等功能。</li>
</ul>
</li>
<li><strong>汇聚层交换机 (Distribution Layer Switch)</strong>：<ul>
<li><strong>位置</strong>：连接接入层交换机和核心层交换机，提供接入层设备的二层转发和汇聚，以及三层路由功能。</li>
<li><strong>功能</strong>：VLAN 间路由、策略路由、ACL、LACP、STP。</li>
</ul>
</li>
<li><strong>核心层交换机 (Core Layer Switch)</strong>：<ul>
<li><strong>位置</strong>：网络的骨干，连接所有汇聚层交换机，提供高速、低延迟的转发通路。</li>
<li><strong>功能</strong>：高带宽、高可靠性、快速路由交换。</li>
</ul>
</li>
</ul>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[核心层交换机] --&gt; B1[汇聚层交换机1]
    A --&gt; B2[汇聚层交换机2]

    B1 --&gt; C1[接入层交换机1]
    B1 --&gt; C2[接入层交换机2]
    B2 --&gt; C3[接入层交换机3]
    B2 --&gt; C4[接入层交换机4]

    C1 --&gt; D1[终端设备A]
    C1 --&gt; D2[终端设备B]
    C2 --&gt; D3[终端设备C]
    C2 --&gt; D4[终端设备D]
    C3 --&gt; D5[终端设备E]
    C4 --&gt; D6[终端设备F]

    subgraph Core Layer
        A
    end

    subgraph Distribution Layer
        B1
        B2
    end

    subgraph Access Layer
        C1
        C2
        C3
        C4
    end

    subgraph End Devices
        D1
        D2
        D3
        D4
        D5
        D6
    end
  </pre></div>

<h2 id="五、交换机的优势"><a href="#五、交换机的优势" class="headerlink" title="五、交换机的优势"></a>五、交换机的优势</h2><p>与早期的集线器相比，交换机带来了显著的优势：</p>
<ol>
<li><strong>提高网络性能</strong>：通过隔离冲突域，避免了数据碰撞，每个端口可以独立进行全双工通信，显著提升了局域网的吞吐量和整体性能。</li>
<li><strong>增强网络安全</strong>：MAC 地址学习和单播转发减少了不必要的流量泛洪，结合 VLAN、端口安全等特性，可以逻辑隔离网络，提高数据安全性。</li>
<li><strong>灵活的网络管理</strong>：网管型交换机提供了丰富的配置选项，使得网络管理员可以对流量、优先级、带宽等进行精细控制。</li>
<li><strong>支持高级功能</strong>：VLAN 划分、链路聚合、PoE 供电、QoS 等功能，满足了企业和数据中心日益增长的复杂需求。</li>
<li><strong>降低网络成本</strong>：虽然单个交换机可能比集线器贵，但其提升的效率和节省的故障排除时间最终会降低总体拥有成本。</li>
</ol>
<h2 id="六、交换机与集线器、路由器的区别"><a href="#六、交换机与集线器、路由器的区别" class="headerlink" title="六、交换机与集线器、路由器的区别"></a>六、交换机与集线器、路由器的区别</h2><p>理解交换机，最好将其与集线器和路由器进行对比：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">集线器 (Hub)</th>
<th align="left">交换机 (Switch)</th>
<th align="left">路由器 (Router)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>OSI 层</strong></td>
<td align="left">物理层 (Layer 1)</td>
<td align="left">数据链路层 (Layer 2)</td>
<td align="left">网络层 (Layer 3)</td>
</tr>
<tr>
<td align="left"><strong>转发依据</strong></td>
<td align="left">无（信号放大）</td>
<td align="left">MAC 地址</td>
<td align="left">IP 地址</td>
</tr>
<tr>
<td align="left"><strong>冲突域</strong></td>
<td align="left">单一冲突域（所有端口）</td>
<td align="left">每个端口一个独立冲突域</td>
<td align="left">每个端口一个独立冲突域</td>
</tr>
<tr>
<td align="left"><strong>广播域</strong></td>
<td align="left">单一广播域（所有端口）</td>
<td align="left">单一广播域（默认，可VLAN划分）</td>
<td align="left">每个端口一个独立广播域</td>
</tr>
<tr>
<td align="left"><strong>数据单位</strong></td>
<td align="left">比特流</td>
<td align="left">数据帧</td>
<td align="left">数据包</td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left">信号放大与广播</td>
<td align="left">智能转发、VLAN、STP、QoS 等</td>
<td align="left">路由选择、广域网互连、NAT、防火墙等</td>
</tr>
<tr>
<td align="left"><strong>互连对象</strong></td>
<td align="left">局域网内设备</td>
<td align="left">局域网内设备、多台交换机、路由器</td>
<td align="left">广域网、不同IP子网的局域网</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">旧有技术，现代网络极少使用</td>
<td align="left">局域网内部连接，构建企业网络骨干</td>
<td align="left">连接不同网络、实现互联网访问</td>
</tr>
</tbody></table>
<h2 id="七、应用场景"><a href="#七、应用场景" class="headerlink" title="七、应用场景"></a>七、应用场景</h2><p>交换机是现代网络中无处不在的设备，其应用场景极其广泛：</p>
<ul>
<li><strong>企业局域网</strong>：连接办公室的电脑、服务器、打印机等设备，构建高速、可靠的内部网络。</li>
<li><strong>数据中心</strong>：作为服务器和存储设备之间的高速连接，支持虚拟化和云计算环境。</li>
<li><strong>家庭网络</strong>：当家庭设备较多，需要连接多台电脑、智能电视、游戏机等时，交换机提供额外的有线端口。</li>
<li><strong>监控系统</strong>：PoE 交换机为 IP 摄像头供电并传输视频数据。</li>
<li><strong>无线覆盖</strong>：PoE 交换机为无线 AP (Access Point) 供电并传输数据，构建无线网络。</li>
<li><strong>工业自动化</strong>：工业级交换机在恶劣环境下提供可靠的网络连接。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>交换机作为局域网的核心连接设备，通过 MAC 地址的智能学习和转发机制，有效地隔离了冲突域，显著提升了网络效率和数据传输速度。其丰富的特性，如 VLAN、STP、LAG、PoE 和 QoS 等，使其能够满足从小型家庭网络到大型企业数据中心等各种复杂场景的需求。理解交换机的工作原理和分类，对于构建、维护和优化现代网络至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/9498f6b94cf7/">https://blog.tbf1211.xx.kg/9498f6b94cf7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/">硬件相关</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/">网络设备</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/460c8465e54b/" title="路由器 (Router) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">路由器 (Router) 详解</div></div><div class="info-2"><div class="info-item-1"> 路由器 (Router) 是一种工作在 OSI 模型网络层（第三层）的网络设备。它的核心功能是连接多个异构网络（如局域网 LANs 和广域网 WANs），并根据 IP 地址执行路由选择 (Routing) 和数据包转发 (Packet Forwarding)。路由器通过维护一张路由表 (Routing Table) 来决定数据包的最佳路径，从而跨越不同的网络段，实现设备间的通信。  核心功能：基于 IP 地址选择最佳路径并转发数据包，连接不同网络，隔离广播域。   一、什么是路由器？路由器是连接两个或多个离散网络（通常是不同 IP 子网）的互联设备。它负责接收来自一个网络的数据包，解析其目的 IP 地址，然后根据其内部的路由表，将数据包转发到前往目的网络的下一个路由器或最终目的主机。路由器是互联网的基础，没有路由器，数据包就无法跨越不同的网络到达目的地。 路由器在网络中的作用：  互联网络：连接不同的局域网、广域网，甚至是互联网。 路由选择：通过复杂的算法（路由协议）或静态配置，确定数据包从源到目的地的最佳路径。 数据包转发：将数据包从一个网络接口接收，再从另一个网络接口发送出...</div></div></div></a><a class="pagination-related" href="/544a32bf949e/" title="TypeScript泛型约束详解：精细化类型参数能力"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TypeScript泛型约束详解：精细化类型参数能力</div></div><div class="info-2"><div class="info-item-1"> TypeScript 泛型约束 (Generic Constraints) 是泛型机制中一个至关重要的概念。它允许我们限制泛型类型参数可以表示的类型范围。通过泛型约束，我们可以在泛型代码内部安全地访问泛型类型参数的特定属性或方法，从而编写出既通用又具备类型安全性的代码。  核心思想：泛型约束的本质是使用 extends 关键字来声明一个类型参数必须是某个特定类型或实现某个接口的子类型。这为编译器提供了足够的类型信息，使其能够在泛型函数、类或接口内部进行更精确的类型检查。   一、为什么需要泛型约束？在上一篇泛型详解中，我们了解到泛型允许我们编写处理任何类型的代码。但有时，我们希望泛型处理的类型具有某种共同的特性。 考虑一个场景：我们想编写一个函数，它接受一个列表，并返回列表中元素的长度之和。 问题示例： 12345678910111213function sumLengths&lt;T&gt;(items: T[]): number &#123;  let totalLength = 0;  for (let item of items) &#123;    // 报错: Pr...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/460c8465e54b/" title="路由器 (Router) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="info-item-2">路由器 (Router) 详解</div></div><div class="info-2"><div class="info-item-1"> 路由器 (Router) 是一种工作在 OSI 模型网络层（第三层）的网络设备。它的核心功能是连接多个异构网络（如局域网 LANs 和广域网 WANs），并根据 IP 地址执行路由选择 (Routing) 和数据包转发 (Packet Forwarding)。路由器通过维护一张路由表 (Routing Table) 来决定数据包的最佳路径，从而跨越不同的网络段，实现设备间的通信。  核心功能：基于 IP 地址选择最佳路径并转发数据包，连接不同网络，隔离广播域。   一、什么是路由器？路由器是连接两个或多个离散网络（通常是不同 IP 子网）的互联设备。它负责接收来自一个网络的数据包，解析其目的 IP 地址，然后根据其内部的路由表，将数据包转发到前往目的网络的下一个路由器或最终目的主机。路由器是互联网的基础，没有路由器，数据包就无法跨越不同的网络到达目的地。 路由器在网络中的作用：  互联网络：连接不同的局域网、广域网，甚至是互联网。 路由选择：通过复杂的算法（路由协议）或静态配置，确定数据包从源到目的地的最佳路径。 数据包转发：将数据包从一个网络接口接收，再从另一个网络接口发送出...</div></div></div></a><a class="pagination-related" href="/19a6c2b992d7/" title="IPv6 (Internet Protocol Version 6) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">IPv6 (Internet Protocol Version 6) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv6 (Internet Protocol Version 6) 是互联网协议 (IP) 的最新版本，旨在取代其前身 IPv4。它解决了 IPv4 长期存在的地址枯竭问题，并引入了多项设计改进，以更好地适应现代互联网的需求，包括支持更简单的头部处理、增强的安全性、更好的服务质量 (QoS) 和更强大的移动性功能。  核心思想：从根本上解决 IPv4 地址短缺问题，同时优化协议设计，为万物互联 (IoT)、5G 和未来网络应用提供坚实基础。    一、为什么需要 IPv6？IPv4 (Internet Protocol Version 4) 作为互联网的核心协议已成功运行数十年，但随着互联网的爆炸式增长，其固有的设计局限性日益凸显：  地址枯竭 (Address Exhaustion)：IPv4 地址空间为 32 位，最多有约 43 亿个地址。尽管采取了无类别域间路由 (CIDR) 和网络地址转换 (NAT) 等技术来延缓地址枯竭，但根源问题并未解决。全球各区域的 IPv4 地址池已基本分配完毕，成为互联网进一步发展的瓶颈。 NAT 的复杂性与限制：网络地址转换 (NAT) ...</div></div></div></a><a class="pagination-related" href="/da4a047de713/" title="中国电信 CN2 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="info-item-2">中国电信 CN2 网络详解</div></div><div class="info-2"><div class="info-item-1"> CN2 (ChinaNet Next Generation Carrying Network)，即中国电信下一代承载网络，是中国电信于 2005 年推出的新一代骨干网络。它旨在提供高质量、高可靠、低延迟的网络服务，主要面向政府、企业和高端个人用户。CN2 与传统的 ChinaNet (AS4134，163骨干网) 在架构和技术上都有显著区别，以提供更优质的国际互联体验。  核心思想：将互联网流量分为“优质”和“普通”两类通道，CN2 提供优质通道，通过更少的跳数、更小的丢包率和更低的延迟，显著提升国际互联的稳定性和速度。   一、为什么需要 CN2？1.1 ChinaNet (163骨干网) 的局限性传统的中国电信互联网骨干网，通常被称为 163 网（因其 AS 号为 4134，而 163 是其常用接入号），是国内用户最广泛使用的网络。然而，163 网在国际互联方面存在一些固有的问题：  链路拥堵：作为最常用的骨干网，163 网承载了大量流量，尤其在国际出口处容易出现拥堵，导致延迟高、丢包率大。 路由跳数多：在国际互联时，163 网的路由路径通常较长，经过的中间节点和运营商较多...</div></div></div></a><a class="pagination-related" href="/deb8135d7a70/" title="NAT 类型详解与穿越机制"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-13</div><div class="info-item-2">NAT 类型详解与穿越机制</div></div><div class="info-2"><div class="info-item-1"> NAT (Network Address Translation) 是一种在 IP 数据包通过路由器或防火墙时，修改 IP 地址信息 (通常是 IP 地址和端口号) 的技术。其主要目的是缓解 IPv4 地址枯竭问题，并为内部网络提供地址隐藏和一定的安全性。然而，NAT 也为点对点 (P2P) 通信带来了挑战，因为不同类型的 NAT 对数据包的转发行为差异巨大。  通过了解 NAT 的不同类型，我们可以选择合适的 NAT 穿越技术 (如 STUN, TURN, ICE) 来实现内网设备间的直接通信。   一、NAT 的基本概念与作用基本概念： NAT 是将一个 IP 地址空间映射到另一个 IP 地址空间的技术。最常见的是将私有 IP 地址（如 10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16）映射到公有 IP 地址。 主要作用：  缓解 IPv4 地址枯竭：允许一个公网 IP 地址被多个内网设备共享，大大减少所需公网 IP 的数量。 隐藏内部网络拓扑：对外只暴露一个或少数几个公网 IP 地址，内部网络结构对外部透明，...</div></div></div></a><a class="pagination-related" href="/1b3da8339be2/" title="中国联通 AS4837 &#x2F; AS9929 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="info-item-2">中国联通 AS4837 &#x2F; AS9929 网络详解</div></div><div class="info-2"><div class="info-item-1"> 中国联通 (China Unicom) 在国际互联方面，主要通过其两个自治系统 (AS, Autonomous System) 来承载流量：AS4837（通常被称为“联通 169 网络”）和 AS9929（通常被称为“联通 A 级精品网络”）。它们类似于中国电信的 163 网和 CN2，旨在为不同需求的用户提供差异化的国际互联服务。了解这两个 AS 的特点，对于选择合适的联通国际线路至关重要。  核心思想：AS4837 是联通的骨干网络，承载大部分流量，经济实惠但国际互联速度一般。AS9929 是联通的精品网络，提供更高质量、低延迟、低丢包率的国际互联服务，但成本较高。   一、为什么中国联通需要多个 AS 号？与中国电信类似，中国联通面对庞大的用户群和不断增长的国际互联需求，也需要对其网络进行分层和优化，以提供差异化的服务。  分担流量：不同的 AS 号可以帮助联通在逻辑上区分和管理不同优先级或性质的流量。 提供差异化服务：通过部署不同等级的网络基础设施和路由策略，为普通用户和高端企业用户提供不同的质量保证。 满足国际互联需求：随着国际业务的扩张和国际数据流量的剧增，需要建设...</div></div></div></a><a class="pagination-related" href="/ba096d7d0780/" title="虚拟局域网 (VLAN) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="info-item-2">虚拟局域网 (VLAN) 详解</div></div><div class="info-2"><div class="info-item-1"> 虚拟局域网 (VLAN - Virtual Local Area Network) 是一种在物理上共享同一网络基础设施（如交换机、网线）的局域网中，通过逻辑划分而不是物理划分来创建多个独立广播域的技术。它允许网络管理员将一个物理局域网划分成多个逻辑上独立的网络，每个 VLAN 都是一个独立的广播域。VLAN 技术是现代企业网络设计中不可或缺的组成部分，它极大地增强了网络的安全性、性能、灵活性和可管理性。  核心思想：在不改变物理连接的情况下，将一个物理交换机划分出多个逻辑隔离的广播域，实现设备间的逻辑分段通信。   一、什么是 VLAN？在传统的以太网中，所有连接到同一个交换机或集线器的设备都属于同一个广播域 (Broadcast Domain)。这意味着当任何一台设备发送一个广播帧（例如 ARP 请求），这个广播帧会到达该域内的所有其他设备。随着网络规模的扩大，广播流量会显著增加，导致网络性能下降并带来安全隐患。 VLAN 技术应运而生，它通过在数据链路层（OSI 模型第二层）对以太网帧进行标识和处理，从而实现：  逻辑隔离：即使设备物理上连接在同一台交换机上，如果它们属于不...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">536</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%9F"><span class="toc-text">一、什么是交换机？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">二、交换机的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-MAC-%E5%9C%B0%E5%9D%80%E5%AD%A6%E4%B9%A0-MAC-Address-Learning"><span class="toc-text">2.1 MAC 地址学习 (MAC Address Learning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B8%A7%E8%BD%AC%E5%8F%91%E3%80%81%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%B3%9B%E6%B4%AA-Frame-Forwarding-Filtering-Flooding"><span class="toc-text">2.2 帧转发、过滤与泛洪 (Frame Forwarding, Filtering, Flooding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%86%B2%E7%AA%81%E5%9F%9F%E4%B8%8E%E5%B9%BF%E6%92%AD%E5%9F%9F-Collision-Domain-vs-Broadcast-Domain"><span class="toc-text">2.3 冲突域与广播域 (Collision Domain vs. Broadcast Domain)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E4%B8%8E%E6%8A%80%E6%9C%AF"><span class="toc-text">三、交换机的关键特性与技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-VLAN-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91-Virtual-Local-Area-Network"><span class="toc-text">3.1 VLAN (虚拟局域网, Virtual Local Area Network)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-STP-%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE-Spanning-Tree-Protocol"><span class="toc-text">3.2 STP (生成树协议, Spanning Tree Protocol)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-LAG-%E9%93%BE%E8%B7%AF%E8%81%9A%E5%90%88%E7%BB%84-Link-Aggregation-Group-EtherChannel"><span class="toc-text">3.3 LAG (链路聚合组, Link Aggregation Group) &#x2F; EtherChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-PoE-%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BE%9B%E7%94%B5-Power-over-Ethernet"><span class="toc-text">3.4 PoE (以太网供电, Power over Ethernet)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-QoS-%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F-Quality-of-Service"><span class="toc-text">3.5 QoS (服务质量, Quality of Service)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E7%AB%AF%E5%8F%A3%E9%95%9C%E5%83%8F-Port-Mirroring-SPAN-Switched-Port-Analyzer"><span class="toc-text">3.6 端口镜像 (Port Mirroring) &#x2F; SPAN (Switched Port Analyzer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7"><span class="toc-text">3.7 安全特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">四、交换机的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%8C%89%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">4.1 按管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%8C%89-OSI-%E5%B1%82%E7%BA%A7"><span class="toc-text">4.2 按 OSI 层级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%8C%89%E7%BB%93%E6%9E%84"><span class="toc-text">4.3 按结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%8C%89%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%EF%BC%88%E4%B8%89%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="toc-text">4.4 按网络层次（三层网络架构）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">五、交换机的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8E%E9%9B%86%E7%BA%BF%E5%99%A8%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">六、交换机与集线器、路由器的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">七、应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>