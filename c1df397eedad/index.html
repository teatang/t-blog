<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版) | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TypeScript 是由 Microsoft 开发和维护的一种开源编程语言。它是 JavaScript 的一个超集，添加了可选的静态类型、类、接口等特性，旨在提高大型应用开发的效率和可维护性。自 2012 年首次发布以来，TypeScript 社区每月或每季度发布一个新版本，不断引入新的语言特性、编译器优化、工具改进和类型系统增强。理解这些版本特性对于 TypeScript 开发者来说至关重要">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/c1df397eedad/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="TypeScript 是由 Microsoft 开发和维护的一种开源编程语言。它是 JavaScript 的一个超集，添加了可选的静态类型、类、接口等特性，旨在提高大型应用开发的效率和可维护性。自 2012 年首次发布以来，TypeScript 社区每月或每季度发布一个新版本，不断引入新的语言特性、编译器优化、工具改进和类型系统增强。理解这些版本特性对于 TypeScript 开发者来说至关重要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg">
<meta property="article:published_time" content="2025-04-16T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-30T03:02:39.229Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="TypeScript">
<meta property="article:tag" content="语言版本">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)",
  "url": "https://blog.tbf1211.xx.kg/c1df397eedad/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-14.jpg",
  "datePublished": "2025-04-16T22:24:00.000Z",
  "dateModified": "2025-12-30T03:02:39.229Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/c1df397eedad/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">445</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-14.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-04-16T22:24:00.000Z" title="发表于 2025-04-17 06:24:00">2025-04-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/TypeScript/">TypeScript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>TypeScript</strong> 是由 Microsoft 开发和维护的一种开源编程语言。它是 JavaScript 的一个超集，添加了可选的静态类型、类、接口等特性，旨在提高大型应用开发的效率和可维护性。自 2012 年首次发布以来，TypeScript 社区每月或每季度发布一个新版本，不断引入新的语言特性、编译器优化、工具改进和类型系统增强。理解这些版本特性对于 TypeScript 开发者来说至关重要，它能帮助我们编写更健壮、更现代化且更易于维护的代码。</p>
</blockquote>
<div class="note info flat"><p><strong>核心思想：</strong> TypeScript 的版本迭代始终围绕着“提升开发者体验、增强类型安全性、更好地支持 JavaScript 新特性、改进工具链”这些目标，旨在弥合 JavaScript 的动态性与大型应用开发对静态分析需求的差距。</p>
</div>
<hr>
<h2 id="一、TypeScript-1-0-1-8：早期奠基与核心功能"><a href="#一、TypeScript-1-0-1-8：早期奠基与核心功能" class="headerlink" title="一、TypeScript 1.0 - 1.8：早期奠基与核心功能"></a>一、TypeScript 1.0 - 1.8：早期奠基与核心功能</h2><p>TypeScript 在早期版本主要关注语言的稳定、核心功能的完善以及与 JavaScript 的兼容性。</p>
<h3 id="1-1-TypeScript-1-0-2014-04-02"><a href="#1-1-TypeScript-1-0-2014-04-02" class="headerlink" title="1.1 TypeScript 1.0 (2014-04-02)"></a>1.1 TypeScript 1.0 (2014-04-02)</h3><ul>
<li><strong>第一个稳定版本</strong>：标志着 TypeScript 正式可以用于生产环境。</li>
<li><strong>核心静态类型系统</strong>：变量、函数参数和返回值的类型注解。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="title function_">greet</span>(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>类 (Classes)</strong>、<strong>接口 (Interfaces)</strong>、<strong>模块 (Modules)</strong>：支持面向对象编程和模块化开发。</li>
<li><strong>编译到 JavaScript</strong>：将 TypeScript 代码编译成纯 JavaScript。</li>
<li><strong>类型定义文件 (<code>.d.ts</code>)</strong>：允许为现有的 JavaScript 库添加类型信息。</li>
</ul>
<h3 id="1-2-TypeScript-1-4-2015-01-20"><a href="#1-2-TypeScript-1-4-2015-01-20" class="headerlink" title="1.2 TypeScript 1.4 (2015-01-20)"></a>1.2 TypeScript 1.4 (2015-01-20)</h3><ul>
<li><strong>联合类型 (Union Types)</strong>：允许变量可以是多种类型之一。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">123</span>;</span><br><span class="line">id = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>let</code> 和 <code>const</code> 声明</strong>：支持 ES6 的块级作用域变量声明。</li>
<li><strong>ES6 模块 (Modules)</strong>：支持 <code>import</code> 和 <code>export</code> 语法。</li>
</ul>
<h3 id="1-3-TypeScript-1-5-2015-07-20"><a href="#1-3-TypeScript-1-5-2015-07-20" class="headerlink" title="1.3 TypeScript 1.5 (2015-07-20)"></a>1.3 TypeScript 1.5 (2015-07-20)</h3><ul>
<li><strong>ES6 Decorators (装饰器)</strong>：实验性支持，用于增强类、方法、属性等。</li>
<li><strong>命名空间 (Namespaces)</strong>：取代了内部模块，用于组织代码。</li>
<li><strong><code>for...of</code> 循环</strong>：支持 ES6 的迭代协议。</li>
<li><strong>JSX 支持</strong>：开始支持 React 应用中使用的 JSX 语法。</li>
<li><strong>新的模块加载策略</strong>：<code>umd</code> 和 <code>system</code>。</li>
</ul>
<h3 id="1-4-TypeScript-1-6-2015-09-16"><a href="#1-4-TypeScript-1-6-2015-09-16" class="headerlink" title="1.4 TypeScript 1.6 (2015-09-16)"></a>1.4 TypeScript 1.6 (2015-09-16)</h3><ul>
<li><strong>React JSX 支持改进</strong>：更强大的 JSX 类型检查。</li>
<li><strong>泛型默认类型参数</strong>：为泛型参数提供默认值。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray&lt;T = <span class="built_in">string</span>&gt;(<span class="attr">length</span>: <span class="built_in">number</span>, <span class="attr">value</span>: T): T[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>(length).<span class="title function_">fill</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> strs = <span class="title function_">createArray</span>(<span class="number">3</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">// T 默认为 string</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-5-TypeScript-1-7-2015-11-30"><a href="#1-5-TypeScript-1-7-2015-11-30" class="headerlink" title="1.5 TypeScript 1.7 (2015-11-30)"></a>1.5 TypeScript 1.7 (2015-11-30)</h3><ul>
<li><strong><code>async</code> &#x2F; <code>await</code> 支持 (ES6 Target)</strong>：在编译到 ES6 时支持异步函数。</li>
<li><strong>多态 <code>this</code> 类型</strong>：允许方法返回派生类的实例类型。</li>
</ul>
<h3 id="1-6-TypeScript-1-8-2016-02-23"><a href="#1-6-TypeScript-1-8-2016-02-23" class="headerlink" title="1.6 TypeScript 1.8 (2016-02-23)"></a>1.6 TypeScript 1.8 (2016-02-23)</h3><ul>
<li><strong>F-Bounded 多态类型</strong>：支持更复杂的继承关系。</li>
<li><strong>字符串字面量类型 (String Literal Types)</strong>：限制字符串变量只能取特定字符串值。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Direction</span> = <span class="string">&quot;north&quot;</span> | <span class="string">&quot;south&quot;</span> | <span class="string">&quot;east&quot;</span> | <span class="string">&quot;west&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="title class_">Direction</span> = <span class="string">&quot;north&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>控制流分析改进</strong>：更智能地推断类型。</li>
<li><strong>对 React 和 JSX 的更多改进</strong>。</li>
</ul>
<h2 id="二、TypeScript-2-0-2-x：Nullable-Types-与更强大的类型系统"><a href="#二、TypeScript-2-0-2-x：Nullable-Types-与更强大的类型系统" class="headerlink" title="二、TypeScript 2.0 - 2.x：Nullable Types 与更强大的类型系统"></a>二、TypeScript 2.0 - 2.x：Nullable Types 与更强大的类型系统</h2><p>TypeScript 2.0 引入了空值安全，这是类型系统的一大进步，此后版本持续在类型推断和安全性上发力。</p>
<h3 id="2-1-TypeScript-2-0-2016-09-22"><a href="#2-1-TypeScript-2-0-2016-09-22" class="headerlink" title="2.1 TypeScript 2.0 (2016-09-22)"></a>2.1 TypeScript 2.0 (2016-09-22)</h3><ul>
<li><strong>空值和未定义检查 (<code>--strictNullChecks</code>)</strong>：<ul>
<li><code>null</code> 和 <code>undefined</code> 不再是所有类型的子类型，必须显式声明为联合类型。</li>
<li>显著减少运行时空指针异常。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">string</span> = <span class="literal">null</span>; <span class="comment">// Error with --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s2</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></li>
<li><strong>非空断言运算符 (<code>!</code>)</strong>：告诉编译器变量不是 <code>null</code> 或 <code>undefined</code>。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">string</span> | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x!.<span class="property">length</span>); <span class="comment">// 告诉编译器 x 不是 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>never</code> 类型</strong>：表示永远不会发生的类型，用于穷举检查。</li>
<li><strong><code>readonly</code> 属性修饰符</strong>：使类属性或接口属性只读。</li>
<li><strong><code>this</code> 类型推断改进</strong>。</li>
<li><strong><code>@types</code> 支持</strong>：通过 <code>npm install @types/packagename</code> 获取类型定义。</li>
</ul>
<h3 id="2-2-TypeScript-2-1-2016-11-08"><a href="#2-2-TypeScript-2-1-2016-11-08" class="headerlink" title="2.2 TypeScript 2.1 (2016-11-08)"></a>2.2 TypeScript 2.1 (2016-11-08)</h3><ul>
<li><strong><code>keyof</code> 和查找类型 (Indexed Access Types)</strong>：<ul>
<li><code>keyof T</code>：获取类型 <code>T</code> 的所有公共属性名（字符串字面量联合类型）。</li>
<li><code>T[K]</code>：查找类型，根据键 <code>K</code> 获取类型 <code>T</code> 中的属性类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PKeys</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot; | &quot;age&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameType</span> = <span class="title class_">Person</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li>
<li><strong>映射类型 (Mapped Types)</strong>：基于现有类型创建新类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>隐式 <code>any</code> 错误 (<code>--noImplicitAny</code>) 改进</strong>。</li>
<li><strong><code>async</code> &#x2F; <code>await</code> 支持 (ES3&#x2F;ES5 Target)</strong>：通过 Promise polyfill 实现。</li>
</ul>
<h3 id="2-3-TypeScript-2-2-2017-02-27"><a href="#2-3-TypeScript-2-2-2017-02-27" class="headerlink" title="2.3 TypeScript 2.2 (2017-02-27)"></a>2.3 TypeScript 2.2 (2017-02-27)</h3><ul>
<li><strong><code>object</code> 类型</strong>：表示非原始类型（非 <code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code>, <code>undefined</code>）。</li>
<li><strong><code>--jsx</code> flag 改进</strong>。</li>
<li><strong>支持 <code>new.target</code> (ES6)</strong>。</li>
</ul>
<h3 id="2-4-TypeScript-2-3-2017-04-27"><a href="#2-4-TypeScript-2-3-2017-04-27" class="headerlink" title="2.4 TypeScript 2.3 (2017-04-27)"></a>2.4 TypeScript 2.3 (2017-04-27)</h3><ul>
<li><strong><code>--strict</code> 标志</strong>：组合了所有严格检查选项（如 <code>strictNullChecks</code>, <code>noImplicitAny</code>, <code>noImplicitThis</code> 等）。</li>
<li><strong>泛型参数的默认值</strong>。</li>
<li><strong>生成器函数改进</strong>。</li>
</ul>
<h3 id="2-5-TypeScript-2-4-2017-07-27"><a href="#2-5-TypeScript-2-4-2017-07-27" class="headerlink" title="2.5 TypeScript 2.4 (2017-07-27)"></a>2.5 TypeScript 2.4 (2017-07-27)</h3><ul>
<li><strong>字符串字面量泛型</strong>：在泛型中支持字符串字面量类型。</li>
<li><strong>回调函数参数严格检查</strong>：对回调函数的参数类型进行更严格的检查。</li>
<li><strong>弱类型检测</strong>：对所有属性都是可选的类型进行特殊处理。</li>
</ul>
<h3 id="2-6-TypeScript-2-5-2017-08-31"><a href="#2-6-TypeScript-2-5-2017-08-31" class="headerlink" title="2.6 TypeScript 2.5 (2017-08-31)"></a>2.6 TypeScript 2.5 (2017-08-31)</h3><ul>
<li><strong>可选捕获参数</strong>：<code>try...catch</code> 语句中的 <code>catch</code> 块可以省略参数。</li>
<li><strong>JSX 改进</strong>。</li>
<li><strong><code>checkJs</code> (JavaScript 类型检查)</strong>：允许在 JavaScript 文件中使用 JSDoc 进行类型检查。</li>
</ul>
<h3 id="2-7-TypeScript-2-6-2017-10-31"><a href="#2-7-TypeScript-2-6-2017-10-31" class="headerlink" title="2.7 TypeScript 2.6 (2017-10-31)"></a>2.7 TypeScript 2.6 (2017-10-31)</h3><ul>
<li><strong><code>--strictFunctionTypes</code></strong>：对函数参数进行协变检查（更严格）。</li>
<li><strong>上下文类型推断改进</strong>。</li>
</ul>
<h3 id="2-8-TypeScript-2-7-2018-01-31"><a href="#2-8-TypeScript-2-7-2018-01-31" class="headerlink" title="2.8 TypeScript 2.7 (2018-01-31)"></a>2.8 TypeScript 2.7 (2018-01-31)</h3><ul>
<li><strong>固定属性检查 (Fixed Property Checking)</strong>：对对象字面量进行更严格的属性检查。</li>
<li><strong><code>--esModuleInterop</code></strong>：改善了 CommonJS 和 ES 模块之间的互操作性。</li>
<li><strong>数字字面量分隔符</strong>：支持 <code>1_000_000</code> 这样的数字表示。</li>
</ul>
<h3 id="2-9-TypeScript-2-8-2018-03-27"><a href="#2-9-TypeScript-2-8-2018-03-27" class="headerlink" title="2.9 TypeScript 2.8 (2018-03-27)"></a>2.9 TypeScript 2.8 (2018-03-27)</h3><ul>
<li><strong>条件类型 (Conditional Types)</strong>：根据条件选择不同的类型。<ul>
<li><code>T extends U ? X : Y</code></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">NonNullable</span>&lt;<span class="built_in">string</span> | <span class="literal">null</span>&gt;; <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li>
<li><strong>预定义条件类型 (Predefined Conditional Types)</strong>：<code>Exclude</code>, <code>Extract</code>, <code>NonNullable</code>, <code>ReturnType</code>, <code>InstanceType</code>。<ul>
<li><code>ReturnType&lt;T&gt;</code>：获取函数类型 <code>T</code> 的返回类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">number</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooReturn</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> foo&gt;; <span class="comment">// number</span></span><br></pre></td></tr></table></figure></li>
<li><strong>映射类型中 <code>infer</code> 关键字</strong>：用于在条件类型中推断类型。</li>
</ul>
<h2 id="三、TypeScript-3-0-3-x：Project-References-与新语法糖"><a href="#三、TypeScript-3-0-3-x：Project-References-与新语法糖" class="headerlink" title="三、TypeScript 3.0 - 3.x：Project References 与新语法糖"></a>三、TypeScript 3.0 - 3.x：Project References 与新语法糖</h2><p>TypeScript 3.x 系列重点关注大型项目的可伸缩性、新的语法特性和类型系统的实用性。</p>
<h3 id="3-1-TypeScript-3-0-2018-07-30"><a href="#3-1-TypeScript-3-0-2018-07-30" class="headerlink" title="3.1 TypeScript 3.0 (2018-07-30)"></a>3.1 TypeScript 3.0 (2018-07-30)</h3><ul>
<li><strong>Project References (项目引用)</strong>：允许将大型 TypeScript 项目拆分为更小的子项目，提高编译速度和管理性。</li>
<li><strong>元组类型中剩余元素 (<code>...</code> 语法)</strong>：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = [<span class="built_in">number</span>, ...<span class="built_in">string</span>[]]; <span class="comment">// [number, string, string, ...]</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>unknown</code> 类型</strong>：比 <code>any</code> 更安全，必须进行类型断言或缩小才能使用。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">length</span>); <span class="comment">// x 现在是 string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>声明文件中的默认导入支持</strong>。</li>
</ul>
<h3 id="3-2-TypeScript-3-1-2018-09-27"><a href="#3-2-TypeScript-3-1-2018-09-27" class="headerlink" title="3.2 TypeScript 3.1 (2018-09-27)"></a>3.2 TypeScript 3.1 (2018-09-27)</h3><ul>
<li><strong>映射类型和元组&#x2F;数组</strong>：映射类型可以作用于元组和数组。</li>
<li><strong>属性在函数上断言 (Property Assignments on Functions)</strong>：支持函数声明时直接赋值属性。</li>
</ul>
<h3 id="3-3-TypeScript-3-2-2018-11-29"><a href="#3-3-TypeScript-3-2-2018-11-29" class="headerlink" title="3.3 TypeScript 3.2 (2018-11-29)"></a>3.3 TypeScript 3.2 (2018-11-29)</h3><ul>
<li><strong><code>Object.entries</code> 和 <code>Object.fromEntries</code> 类型改进</strong>。</li>
<li><strong><code>strictBindCallApply</code> 标志</strong>：对 <code>call</code>, <code>apply</code>, <code>bind</code> 方法进行更严格的类型检查。</li>
<li><strong>泛型展开语法 (Generic Spread Expressions)</strong>：改进了对象和数组展开运算符的类型推断。</li>
</ul>
<h3 id="3-4-TypeScript-3-3-2019-01-31"><a href="#3-4-TypeScript-3-3-2019-01-31" class="headerlink" title="3.4 TypeScript 3.3 (2019-01-31)"></a>3.4 TypeScript 3.3 (2019-01-31)</h3><ul>
<li><strong><code>--build</code> 模式下的增量编译</strong>：大幅提升项目引用下的编译速度。</li>
<li><strong>对 <code>yield*</code> 的类型检查改进</strong>。</li>
</ul>
<h3 id="3-5-TypeScript-3-4-2019-03-28"><a href="#3-5-TypeScript-3-4-2019-03-28" class="headerlink" title="3.5 TypeScript 3.4 (2019-03-28)"></a>3.5 TypeScript 3.4 (2019-03-28)</h3><ul>
<li><strong><code>readonly</code> 元组</strong>：<code>readonly [string, number]</code>。</li>
<li><strong><code>const</code> 断言</strong>：将变量或表达式标记为 <code>const</code>，使其类型变为最窄的字面量类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">1</span>, <span class="number">2</span>] <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// type is readonly [1, 2]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>类型推断改进</strong>：包括高阶函数。</li>
</ul>
<h3 id="3-6-TypeScript-3-7-2019-11-05"><a href="#3-6-TypeScript-3-7-2019-11-05" class="headerlink" title="3.6 TypeScript 3.7 (2019-11-05)"></a>3.6 TypeScript 3.7 (2019-11-05)</h3><ul>
<li><strong>可选链 (Optional Chaining)</strong>：访问可能为 <code>null</code> 或 <code>undefined</code> 的属性或方法。<ul>
<li><code>a?.b</code> (属性)</li>
<li><code>a?.()</code> (方法)</li>
<li><code>a?.[b]</code> (索引)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">address</span>?: &#123;</span><br><span class="line">        <span class="attr">street</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span>?.<span class="property">street</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li><strong>空值合并运算符 (Nullish Coalescing)</strong>：<code>??</code> 运算符，当左侧为 <code>null</code> 或 <code>undefined</code> 时返回右侧。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = someValue ?? <span class="string">&quot;default&quot;</span>; <span class="comment">// 如果 someValue 是 null/undefined，则 foo 为 &quot;default&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>断言函数 (Assertion Functions)</strong>：用于告诉编译器在函数返回后，某些变量的类型被断言为特定类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assertIsString</span>(<span class="params"><span class="attr">val</span>: <span class="built_in">any</span></span>): asserts val is <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> val !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not a string!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="title function_">assertIsString</span>(x);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">length</span>); <span class="comment">// x 现在被推断为 string</span></span><br></pre></td></tr></table></figure></li>
<li><strong>递归类型别名改进</strong>。</li>
</ul>
<h3 id="3-7-TypeScript-3-8-2020-02-20"><a href="#3-7-TypeScript-3-8-2020-02-20" class="headerlink" title="3.7 TypeScript 3.8 (2020-02-20)"></a>3.7 TypeScript 3.8 (2020-02-20)</h3><ul>
<li><strong><code>type</code> 导入&#x2F;导出</strong>：允许显式地只导入&#x2F;导出类型，避免运行时开销。<ul>
<li><code>import type &#123; Foo &#125; from &quot;./bar&quot;;</code></li>
</ul>
</li>
<li><strong>ES 模块私有字段 (<code>#</code>)</strong>：支持 ES2020 的私有类字段。</li>
<li><strong><code>export * as ns</code> 语法</strong>：<ul>
<li><code>export * as utils from &quot;./utils&quot;;</code></li>
</ul>
</li>
<li><strong>Top-level <code>await</code> (ES Modules)</strong>。</li>
<li><strong>JSDoc 属性推断改进</strong>。</li>
</ul>
<h3 id="3-8-TypeScript-3-9-2020-05-12"><a href="#3-8-TypeScript-3-9-2020-05-12" class="headerlink" title="3.8 TypeScript 3.9 (2020-05-12)"></a>3.8 TypeScript 3.9 (2020-05-12)</h3><ul>
<li><strong>性能改进</strong>：编译器性能提升，特别是对大型代码库。</li>
<li><strong>类型推断改进</strong>：特别是对 Promise 和 <code>Array.prototype.flat</code> 的推断。</li>
</ul>
<h2 id="四、TypeScript-4-0-4-x：元组类型改进与模板字面量"><a href="#四、TypeScript-4-0-4-x：元组类型改进与模板字面量" class="headerlink" title="四、TypeScript 4.0 - 4.x：元组类型改进与模板字面量"></a>四、TypeScript 4.0 - 4.x：元组类型改进与模板字面量</h2><p>TypeScript 4.x 系列继续在类型系统的高级功能和工具链的易用性上发力，引入了更强大的元组类型和模板字面量类型。</p>
<h3 id="4-1-TypeScript-4-0-2020-08-20"><a href="#4-1-TypeScript-4-0-2020-08-20" class="headerlink" title="4.1 TypeScript 4.0 (2020-08-20)"></a>4.1 TypeScript 4.0 (2020-08-20)</h3><ul>
<li><strong>可变参数元组类型 (Variadic Tuple Types)</strong>：允许在元组类型中使用剩余参数，结合泛型实现更灵活的函数签名。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Arr</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];</span><br><span class="line"><span class="keyword">function</span> concat&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>[], U <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt;(<span class="attr">arr1</span>: T, <span class="attr">arr2</span>: U): [...T, ...U] &#123;</span><br><span class="line">    <span class="keyword">return</span> [...arr1, ...arr2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">concat</span>([<span class="string">&quot;hello&quot;</span>], [<span class="number">10</span>, <span class="literal">true</span>]); <span class="comment">// [&quot;hello&quot;, 10, true]</span></span><br></pre></td></tr></table></figure></li>
<li><strong>Labeled Tuple Elements (带有标签的元组元素)</strong>：为元组中的元素添加名称，提高可读性，但不会影响类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = [<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure></li>
<li><strong><code>--noPropertyAccessFromIndexSignature</code></strong>：更严格地检查通过索引签名访问属性。</li>
<li><strong>IDE 方面的改进</strong>：更智能的自动完成和重构。</li>
</ul>
<h3 id="4-2-TypeScript-4-1-2020-11-19"><a href="#4-2-TypeScript-4-1-2020-11-19" class="headerlink" title="4.2 TypeScript 4.1 (2020-11-19)"></a>4.2 TypeScript 4.1 (2020-11-19)</h3><ul>
<li><strong>模板字面量类型 (Template Literal Types)</strong>：允许在类型系统中使用模板字符串，创建基于字符串内容的类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventName</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>Changed`</span> | <span class="string">`<span class="subst">$&#123;T&#125;</span>Deleted`</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserEvents</span> = <span class="title class_">EventName</span>&lt;<span class="string">&quot;user&quot;</span>&gt;; <span class="comment">// &quot;userChanged&quot; | &quot;userDeleted&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>递归条件类型</strong>：条件类型现在支持一定程度的递归。</li>
<li><strong>键重映射 (Key Remapping) in Mapped Types</strong>：允许在映射类型中重命名属性键。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;T&gt; = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; K&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> T[K]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>对 <code>infer</code> 的更深入支持</strong>。</li>
</ul>
<h3 id="4-3-TypeScript-4-2-2021-02-23"><a href="#4-3-TypeScript-4-2-2021-02-23" class="headerlink" title="4.3 TypeScript 4.2 (2021-02-23)"></a>4.3 TypeScript 4.2 (2021-02-23)</h3><ul>
<li><strong>抽象构造签名 (Abstract Construct Signatures)</strong>：允许在接口中定义抽象类的构造函数签名。</li>
<li><strong>性能改进</strong>：对大型代码库的类型检查速度提升。</li>
</ul>
<h3 id="4-4-TypeScript-4-3-2021-05-26"><a href="#4-4-TypeScript-4-3-2021-05-26" class="headerlink" title="4.4 TypeScript 4.3 (2021-05-26)"></a>4.4 TypeScript 4.3 (2021-05-26)</h3><ul>
<li><strong><code>override</code> 关键字</strong>：显式标记子类方法覆盖父类方法。</li>
<li><strong><code>static</code> 块</strong>：ES2022 的静态初始化块支持。</li>
<li><strong><code>setter</code> &#x2F; <code>getter</code> 的 <code>string</code> &#x2F; <code>symbol</code> 索引签名支持</strong>。</li>
</ul>
<h3 id="4-5-TypeScript-4-4-2021-08-26"><a href="#4-5-TypeScript-4-4-2021-08-26" class="headerlink" title="4.5 TypeScript 4.4 (2021-08-26)"></a>4.5 TypeScript 4.4 (2021-08-26)</h3><ul>
<li><strong>控制流分析增强</strong>：更智能地处理别名和条件。</li>
<li><strong><code>symbol</code> 和模板字面量类型作为索引签名</strong>。</li>
<li><strong><code>--exactOptionalPropertyTypes</code></strong>：更严格地检查可选属性，区分 <code>undefined</code> 和不存在的属性。</li>
</ul>
<h3 id="4-6-TypeScript-4-5-2021-11-17"><a href="#4-6-TypeScript-4-5-2021-11-17" class="headerlink" title="4.6 TypeScript 4.5 (2021-11-17)"></a>4.6 TypeScript 4.5 (2021-11-17)</h3><ul>
<li><strong><code>Awaited</code> 类型</strong>：模拟 <code>await</code> 关键字对 <code>Promise</code> 类型的解包行为。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P = <span class="title class_">Promise</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Awaited</span>&lt;P&gt;; <span class="comment">// number</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>module es2022</code> 模块解析</strong>。</li>
<li><strong><code>import</code> 断言 (Import Assertions)</strong>：ES2022 提案，为 <code>import</code> 语句添加元数据。</li>
<li><strong>私有字段检查</strong>：对私有字段 (<code>#</code>) 的检查改进。</li>
</ul>
<h3 id="4-7-TypeScript-4-6-2022-02-24"><a href="#4-7-TypeScript-4-6-2022-02-24" class="headerlink" title="4.7 TypeScript 4.6 (2022-02-24)"></a>4.7 TypeScript 4.6 (2022-02-24)</h3><ul>
<li><strong>控制流分析对解构赋值的支持</strong>。</li>
<li><strong>更好的递归类型别名检查</strong>。</li>
<li><strong>性能改进</strong>：对 <code>tslib</code> 和 IDE 响应速度的优化。</li>
</ul>
<h3 id="4-8-TypeScript-4-7-2022-05-24"><a href="#4-8-TypeScript-4-7-2022-05-24" class="headerlink" title="4.8 TypeScript 4.7 (2022-05-24)"></a>4.8 TypeScript 4.7 (2022-05-24)</h3><ul>
<li><strong>ESM 模块支持改进 (Node.js)</strong>：增加了对 <code>moduleResolution: &quot;node16&quot;</code> 和 <code>&quot;nodenext&quot;</code> 的支持，以更好地处理 ESM。</li>
<li><strong>实例化表达式 (Instantiation Expressions)</strong>：允许对泛型函数进行部分类型应用。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBox = <span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt;; <span class="comment">// 等同于 (x: string) =&gt; Box&lt;string&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>extends</code> 约束中的 <code>infer</code> 关键字</strong>。</li>
<li><strong><code>Object</code> 类型的改进</strong>。</li>
</ul>
<h3 id="4-9-TypeScript-4-8-2022-08-25"><a href="#4-9-TypeScript-4-8-2022-08-25" class="headerlink" title="4.9 TypeScript 4.8 (2022-08-25)"></a>4.9 TypeScript 4.8 (2022-08-25)</h3><ul>
<li><strong>改进的交叉类型推断</strong>：在某些情况下，交叉类型推断会更智能。</li>
<li><strong>文件监视改进</strong>：在文件系统变更时，更高效地重新编译。</li>
<li><strong>性能提升</strong>。</li>
</ul>
<h3 id="4-10-TypeScript-4-9-2022-11-15"><a href="#4-10-TypeScript-4-9-2022-11-15" class="headerlink" title="4.10 TypeScript 4.9 (2022-11-15)"></a>4.10 TypeScript 4.9 (2022-11-15)</h3><ul>
<li><strong><code>satisfies</code> 运算符</strong>：允许在不影响原始类型推断的情况下，验证表达式是否满足某个类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Colors</span> = <span class="string">&quot;red&quot;</span> | <span class="string">&quot;green&quot;</span> | <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">    <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="attr">green</span>: <span class="string">&quot;#00FF00&quot;</span>,</span><br><span class="line">    <span class="attr">blue</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]</span><br><span class="line">&#125; <span class="keyword">satisfies</span> <span class="title class_">Record</span>&lt;<span class="title class_">Colors</span>, <span class="built_in">string</span> | <span class="built_in">number</span>[]&gt;;</span><br><span class="line"><span class="comment">// palette.red 的类型仍是 number[], 不会被拓宽为 string | number[]</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>in</code> 运算符的类型缩小改进</strong>：在 <code>if (key in obj)</code> 中，<code>obj</code> 的类型可以更好地被缩小。</li>
<li><strong><code>typeof</code> 运算符的类型缩小改进</strong>。</li>
<li><strong><code>--exactOptionalPropertyTypes</code> 成为默认</strong>。</li>
</ul>
<h2 id="五、TypeScript-5-0-最新稳定版：装饰器-V2-与更强大的模块系统"><a href="#五、TypeScript-5-0-最新稳定版：装饰器-V2-与更强大的模块系统" class="headerlink" title="五、TypeScript 5.0 - 最新稳定版：装饰器 V2 与更强大的模块系统"></a>五、TypeScript 5.0 - 最新稳定版：装饰器 V2 与更强大的模块系统</h2><p>TypeScript 5.x 系列是 TypeScript 发展的重要阶段，聚焦于标准化新的 ECMAScript 提案、提升编译性能和进一步增强类型系统。</p>
<h3 id="5-1-TypeScript-5-0-2023-03-16"><a href="#5-1-TypeScript-5-0-2023-03-16" class="headerlink" title="5.1 TypeScript 5.0 (2023-03-16)"></a>5.1 TypeScript 5.0 (2023-03-16)</h3><ul>
<li><strong>ECMAScript Decorators (装饰器)</strong>：支持 TC39 Stage 3 的装饰器提案，并兼容旧版装饰器。这是核心语言特性的一大升级。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logMethod</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="title function_">myMethod</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>新的模块解析策略 (<code>--moduleResolution bundler</code>)</strong>：旨在更好地与现代打包工具 (如 Webpack, Vite) 协同工作，简化配置。</li>
<li><strong>新的 JSDoc 语法</strong>：支持 JSDoc 中的 <code>@satisfies</code>。</li>
<li><strong>枚举类型 (Enums) 的联合类型</strong>：可以将枚举视为字面量联合类型，提高兼容性。</li>
<li><strong>性能改进</strong>：编译速度显著提升，尤其是大型项目。</li>
</ul>
<h3 id="5-2-TypeScript-5-1-2023-05-24"><a href="#5-2-TypeScript-5-1-2023-05-24" class="headerlink" title="5.2 TypeScript 5.1 (2023-05-24)"></a>5.2 TypeScript 5.1 (2023-05-24)</h3><ul>
<li><strong>getter 和 setter 属性的独立类型</strong>：现在可以为 getter 和 setter 定义不同的类型，这对于只读属性或计算属性非常有用。</li>
<li><strong>JSX 标签中更宽松的类型声明</strong>。</li>
<li><strong><code>void</code> 返回类型推断改进</strong>。</li>
</ul>
<h3 id="5-3-TypeScript-5-2-2023-08-24"><a href="#5-3-TypeScript-5-2-2023-08-24" class="headerlink" title="5.3 TypeScript 5.2 (2023-08-24)"></a>5.3 TypeScript 5.2 (2023-08-24)</h3><ul>
<li><strong>使用 <code>using</code> 声明 (ECMAScript Explicit Resource Management)</strong>：支持 TC39 Stage 3 的 <code>using</code> 声明，用于自动管理资源。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">using</span> file = <span class="title function_">openFile</span>(<span class="string">&quot;path/to/file&quot;</span>);</span><br><span class="line">    <span class="comment">// file 会在函数结束时自动关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>--declaration</code> 和 <code>--emitDeclarationOnly</code> 改进</strong>：在生成声明文件时更加灵活。</li>
<li><strong>命名空间和类型别名的改进</strong>。</li>
</ul>
<h3 id="5-4-TypeScript-5-3-2023-11-16"><a href="#5-4-TypeScript-5-3-2023-11-16" class="headerlink" title="5.4 TypeScript 5.3 (2023-11-16)"></a>5.4 TypeScript 5.3 (2023-11-16)</h3><ul>
<li><strong><code>import type</code> 语句的改进</strong>：现在可以在 <code>import</code> 语句中使用 <code>type</code> 关键字，以确保导入的是类型而不是值。</li>
<li><strong><code>resolution-mode</code> 类型导入属性</strong>：在单个导入中使用不同的模块解析策略。</li>
<li><strong><code>switch (true)</code> 的类型缩小</strong>：更智能地缩小 <code>switch (true)</code> 语句中的类型。</li>
<li><strong><code>--compilerOptions</code> 参数改进</strong>。</li>
</ul>
<h3 id="5-5-TypeScript-5-4-最新稳定版，2024-03-01"><a href="#5-5-TypeScript-5-4-最新稳定版，2024-03-01" class="headerlink" title="5.5 TypeScript 5.4 (最新稳定版，2024-03-01)"></a>5.5 TypeScript 5.4 (最新稳定版，2024-03-01)</h3><ul>
<li><strong><code>Object.groupBy</code> 和 <code>Map.groupBy</code> 类型支持 (ECMAScript Stage 3)</strong>：为这些新的数组分组方法提供类型定义。</li>
<li><strong>改进了闭包中类型变量的类型检查</strong>。</li>
<li><strong><code>--module no-cjs-exports</code> 选项</strong>：强制 CommonJS 模块不能有命名导出。</li>
<li><strong>性能和稳定性改进</strong>。</li>
</ul>
<h3 id="5-6-TypeScript-5-x-展望-未来版本，例如-5-5"><a href="#5-6-TypeScript-5-x-展望-未来版本，例如-5-5" class="headerlink" title="5.6 TypeScript 5.x 展望 (未来版本，例如 5.5+)"></a>5.6 TypeScript 5.x 展望 (未来版本，例如 5.5+)</h3><p>TypeScript 的发展是一个持续的过程，我们可以期待未来版本在以下方面继续推进：</p>
<ul>
<li><strong>新的 ECMAScript 提案支持</strong>：紧跟 TC39 提案的进展，如 Records and Tuples、Pattern Matching 等，逐步在 TypeScript 中提供支持。</li>
<li><strong>编译器性能优化</strong>：持续提升类型检查和编译的速度，尤其是在大型 monorepo 项目中。</li>
<li><strong>更强大的类型推断</strong>：减少手动类型注解的需求，让 TypeScript 更智能地理解代码意图。</li>
<li><strong>工具链和 IDE 体验改进</strong>：提供更强大的代码补全、重构和错误提示。</li>
<li><strong><code>d.ts</code> 文件生成改进</strong>：使类型定义文件的生成更加精确和灵活。</li>
<li><strong>更细粒度的控制流分析</strong>。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>TypeScript 从最初的类型注解和面向对象支持，逐步发展到拥有强大的空值安全、高级类型操作（如条件类型、映射类型、模板字面量类型）、现代 JavaScript 特性支持（如可选链、空值合并）、以及对大型项目和模块化开发的全面支持。每个版本的发布都旨在让 JavaScript 生态系统更加健壮、可维护，并为开发者提供更愉悦的开发体验。持续学习和掌握 TypeScript 的新特性，是现代前端和后端（Node.js）开发者提升专业能力的关键。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/c1df397eedad/">https://blog.tbf1211.xx.kg/c1df397eedad/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC/">语言版本</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/f71cbfee727d/" title="Go 语言 Cron 任务调度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Go 语言 Cron 任务调度详解</div></div><div class="info-2"><div class="info-item-1"> Cron 是一种广泛应用于 Unix-like 操作系统中的时间任务调度工具。在 Go 语言中，为了方便地实现类似的功能，开发者通常会借助第三方库。其中，github.com/robfig/cron/v3 是一个功能强大、广泛采用且维护良好的 Go 语言 Cron 库，它提供了一个灵活、可靠的方式来定义和执行周期性任务。  核心思想：将遵循标准 Cron 表达式的任务调度逻辑封装在一个 Go 协程安全 (Goroutine-safe) 的调度器中，允许开发者以声明式的方式定义定时任务，并自动在指定时间触发执行。   一、为什么需要 Cron 任务调度？在软件开发中，许多场景需要定时执行特定的任务，例如：  数据同步与备份：每天凌晨备份数据库，或每小时同步一次外部数据源。 报告生成：每周、每月自动生成业务报表。 清理任务：定期清理过期缓存、日志文件或无效用户数据。 监控与告警：每隔几分钟检查系统状态或服务健康状况。 批量处理：在业务低峰期处理大量离线数据。  手动触发或简单的 time.Sleep 循环无法有效管理这些任务：  time.Sleep 难以处理复杂的时间规则（如“每...</div></div></div></a><a class="pagination-related" href="/e208a03b114e/" title="JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)</div></div><div class="info-2"><div class="info-item-1"> JavaScript，正式名称为 ECMAScript (ES)，自 1997 年标准化以来，一直在不断发展。尤其是从 ES6 (ES2015) 开始，它进入了一个快速迭代的时代，每年都会发布一个新版本，引入大量的新特性、语法糖和标准库改进。理解这些新特性对于现代 JavaScript 开发者至关重要，它能帮助我们编写更简洁、更强大、更符合未来趋势的代码。  核心思想： ECMAScript 的版本迭代致力于提升开发效率、代码可读性、执行性能，并引入现代编程范式（如异步编程、模块化），同时保持向后兼容性。   一、早期版本：奠定基础 (ES1 - ES5)早期版本的 ECMAScript 奠定了 JavaScript 的基本语法和核心功能，但发展速度相对较慢。 1.1 ES1 (1997) - ES3 (1999) 基本语法：变量声明 (var)、函数、条件语句、循环、基本数据类型（字符串、数字、布尔、null、undefined）。 对象和数组：字面量创建、属性访问。 原型继承：基于原型的继承机制。 函数作用域：变量作用域规则。 try...catch：错误处理。 eval(...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/e208a03b114e/" title="JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="info-item-2">JavaScript (ECMAScript) 各版本新特性详解 (ES1 至 ES2025)</div></div><div class="info-2"><div class="info-item-1"> JavaScript，正式名称为 ECMAScript (ES)，自 1997 年标准化以来，一直在不断发展。尤其是从 ES6 (ES2015) 开始，它进入了一个快速迭代的时代，每年都会发布一个新版本，引入大量的新特性、语法糖和标准库改进。理解这些新特性对于现代 JavaScript 开发者至关重要，它能帮助我们编写更简洁、更强大、更符合未来趋势的代码。  核心思想： ECMAScript 的版本迭代致力于提升开发效率、代码可读性、执行性能，并引入现代编程范式（如异步编程、模块化），同时保持向后兼容性。   一、早期版本：奠定基础 (ES1 - ES5)早期版本的 ECMAScript 奠定了 JavaScript 的基本语法和核心功能，但发展速度相对较慢。 1.1 ES1 (1997) - ES3 (1999) 基本语法：变量声明 (var)、函数、条件语句、循环、基本数据类型（字符串、数字、布尔、null、undefined）。 对象和数组：字面量创建、属性访问。 原型继承：基于原型的继承机制。 函数作用域：变量作用域规则。 try...catch：错误处理。 eval(...</div></div></div></a><a class="pagination-related" href="/cdecf00b2f41/" title="GoLang Wails 框架详解：用 Web 技术构建桌面应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">GoLang Wails 框架详解：用 Web 技术构建桌面应用</div></div><div class="info-2"><div class="info-item-1"> Wails 是一个 Go 语言编写的框架，用于使用 Go 语言的强大后端能力和熟悉的 Web 前端技术（HTML、CSS、JavaScript&#x2F;TypeScript、以及任何前端框架如 React、Vue、Angular、Svelte 等）构建轻量级、高性能、原生的跨平台桌面应用程序。它与 Tauri 类似，都是 Electron 的替代品，但 Wails 的核心优势在于其后端是 Go 语言，这对于 Go 开发者来说更具亲和力。  核心思想：将现代 Web 前端技术与 Go 语言编写的原生后端无缝结合，通过操作系统的 WebView 渲染 UI，实现高性能、低资源消耗且易于 Go 开发者上手的桌面应用开发。    一、为什么选择 Wails？与 Electron 相比，Wails 提供了一系列优势，特别吸引 Go 语言开发者：  极小的捆包体积：Wails 应用同样不捆绑 Chromium 或 Node.js 运行时。它利用操作系统自带的 WebView 控件（如 Windows 上的 WebView2&#x2F;EdgeHTML、macOS 上的 WKWebView...</div></div></div></a><a class="pagination-related" href="/9474fb1165cb/" title="React 详解：核心 API 深度解读"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-27</div><div class="info-item-2">React 详解：核心 API 深度解读</div></div><div class="info-2"><div class="info-item-1"> React 是一个用于构建用户界面的 JavaScript 库。它以声明式的方式让开发者可以轻松构建复杂且交互性强的 UI。要真正驾驭 React，深入理解其核心 API 至关重要。这些 API 是构建组件、管理状态、处理副作用、优化性能以及与其他系统交互的基础。本文将对 React 的核心 API 进行深度解读，涵盖从组件定义到高级优化等各个方面。  核心思想：React 核心 API 围绕组件化、声明式UI、单向数据流和性能优化展开，通过 Hooks 极大地简化了函数组件的状态管理和副作用处理，使复杂逻辑更易组织和复用。   一、React 的核心模块与入口React 库被拆分为两个主要模块：react 和 react-dom。  react: 包含构建组件和定义其行为所需的核心 API（如 Component, useState, useEffect, createContext 等）。 react-dom: 提供与 DOM 交互的特定方法（如 render, createRoot 等），用于将 React 组件渲染到浏览器环境。  react-dom 主要 API1. ...</div></div></div></a><a class="pagination-related" href="/f3d77a2d04c2/" title="TypeScript高级类型"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-26</div><div class="info-item-2">TypeScript高级类型</div></div><div class="info-2"><div class="info-item-1"> TypeScript 高级类型 提供了强大的工具，允许开发者以更灵活、更精确的方式定义和操作类型。这些高级类型不仅增强了代码的类型安全性，还提升了开发体验，使得复杂的数据结构和业务逻辑能够更清晰地表达和维护。掌握 TypeScript 的这些高级特性，是成为一名高效 TypeScript 开发者的关键。  核心思想：高级类型允许我们基于现有类型进行转换、组合、提取，以及根据不同条件生成新类型，从而构建出更健壮、更具表达力的类型系统。   一、联合类型 (Union Types)联合类型表示一个值可以是多种类型中的任意一种。使用 | 符号连接不同的类型。 1.1 定义与使用1234567891011121314// 定义一个联合类型，表示一个变量可以是 string 或 numbertype StringOrNumber = string | number;let id: StringOrNumber;id = &quot;123&quot;; // OKid = 123;   // OK// id = true; // Error: Type &#x27;boolean&#x2...</div></div></div></a><a class="pagination-related" href="/b25babd84514/" title="Vue3 defineModel详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-03</div><div class="info-item-2">Vue3 defineModel详解</div></div><div class="info-2"><div class="info-item-1"> defineModel 是 Vue 3.4 版本中引入的一个新的宏 (macro)，旨在简化组件中双向绑定 v-model 的实现。在 Composition API 的 setup 语法糖 (&lt;script setup&gt;) 中使用时，它极大地减少了为组件实现 v-model 所需的样板代码，使其更加直观和便捷。  核心思想：defineModel 是 defineProps 和 defineEmits 的语法糖，它声明了一个可双向绑定的 props，并自动处理了 modelValue prop 的接收和相应的 update:modelValue 事件的触发，让自定义组件的 v-model 用法变得和原生表单元素一样简洁。   一、为什么需要 defineModel？在 defineModel 出现之前，如果你想在 Vue 3 的自定义组件中实现 v-model 双向绑定，你需要手动完成以下步骤：  通过 defineProps 声明一个名为 modelValue 的 prop 来接收父组件传递的值。 通过 defineEmits 声明一个名为 update:mod...</div></div></div></a><a class="pagination-related" href="/eebf85c66545/" title="hls.js 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-17</div><div class="info-item-2">hls.js 详解</div></div><div class="info-2"><div class="info-item-1"> hls.js 是一个开源的 JavaScript 库，它实现了 HTTP Live Streaming (HLS) 协议，使浏览器能够通过标准的 HTML5 &lt;video&gt; 标签播放 HLS 视频流。HLS 是 Apple 公司开发的一种流媒体传输协议，被广泛应用于音视频内容的分发。由于原生浏览器通常只支持播放 MP4 等直接文件格式或特定 HLS 实现（如 Safari），而 Chrome、Firefox 等浏览器缺乏对 HLS 的原生支持，hls.js 填补了这一空白，让开发者能够在几乎所有现代浏览器中提供 HLS 流媒体服务。  核心思想：hls.js 通过 JavaScript 解析 HLS manifest (M3U8) 文件，动态加载和拼接 TS (MPEG-2 Transport Stream) 片段，并利用 Media Source Extensions (MSE) API 将这些片段喂给 HTML5 &lt;video&gt; 元素进行播放，从而实现浏览器对 HLS 流媒体的广泛支持。   一、为什么需要 hls.js？HLS 协议是目前最流行的流...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">445</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81TypeScript-1-0-1-8%EF%BC%9A%E6%97%A9%E6%9C%9F%E5%A5%A0%E5%9F%BA%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-text">一、TypeScript 1.0 - 1.8：早期奠基与核心功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-TypeScript-1-0-2014-04-02"><span class="toc-text">1.1 TypeScript 1.0 (2014-04-02)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-TypeScript-1-4-2015-01-20"><span class="toc-text">1.2 TypeScript 1.4 (2015-01-20)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-TypeScript-1-5-2015-07-20"><span class="toc-text">1.3 TypeScript 1.5 (2015-07-20)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-TypeScript-1-6-2015-09-16"><span class="toc-text">1.4 TypeScript 1.6 (2015-09-16)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-TypeScript-1-7-2015-11-30"><span class="toc-text">1.5 TypeScript 1.7 (2015-11-30)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-TypeScript-1-8-2016-02-23"><span class="toc-text">1.6 TypeScript 1.8 (2016-02-23)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TypeScript-2-0-2-x%EF%BC%9ANullable-Types-%E4%B8%8E%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">二、TypeScript 2.0 - 2.x：Nullable Types 与更强大的类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-TypeScript-2-0-2016-09-22"><span class="toc-text">2.1 TypeScript 2.0 (2016-09-22)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-TypeScript-2-1-2016-11-08"><span class="toc-text">2.2 TypeScript 2.1 (2016-11-08)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-TypeScript-2-2-2017-02-27"><span class="toc-text">2.3 TypeScript 2.2 (2017-02-27)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-TypeScript-2-3-2017-04-27"><span class="toc-text">2.4 TypeScript 2.3 (2017-04-27)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-TypeScript-2-4-2017-07-27"><span class="toc-text">2.5 TypeScript 2.4 (2017-07-27)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-TypeScript-2-5-2017-08-31"><span class="toc-text">2.6 TypeScript 2.5 (2017-08-31)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-TypeScript-2-6-2017-10-31"><span class="toc-text">2.7 TypeScript 2.6 (2017-10-31)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-TypeScript-2-7-2018-01-31"><span class="toc-text">2.8 TypeScript 2.7 (2018-01-31)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-TypeScript-2-8-2018-03-27"><span class="toc-text">2.9 TypeScript 2.8 (2018-03-27)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TypeScript-3-0-3-x%EF%BC%9AProject-References-%E4%B8%8E%E6%96%B0%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-text">三、TypeScript 3.0 - 3.x：Project References 与新语法糖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-TypeScript-3-0-2018-07-30"><span class="toc-text">3.1 TypeScript 3.0 (2018-07-30)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-TypeScript-3-1-2018-09-27"><span class="toc-text">3.2 TypeScript 3.1 (2018-09-27)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-TypeScript-3-2-2018-11-29"><span class="toc-text">3.3 TypeScript 3.2 (2018-11-29)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-TypeScript-3-3-2019-01-31"><span class="toc-text">3.4 TypeScript 3.3 (2019-01-31)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-TypeScript-3-4-2019-03-28"><span class="toc-text">3.5 TypeScript 3.4 (2019-03-28)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-TypeScript-3-7-2019-11-05"><span class="toc-text">3.6 TypeScript 3.7 (2019-11-05)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-TypeScript-3-8-2020-02-20"><span class="toc-text">3.7 TypeScript 3.8 (2020-02-20)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-TypeScript-3-9-2020-05-12"><span class="toc-text">3.8 TypeScript 3.9 (2020-05-12)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81TypeScript-4-0-4-x%EF%BC%9A%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%94%B9%E8%BF%9B%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">四、TypeScript 4.0 - 4.x：元组类型改进与模板字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-TypeScript-4-0-2020-08-20"><span class="toc-text">4.1 TypeScript 4.0 (2020-08-20)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-TypeScript-4-1-2020-11-19"><span class="toc-text">4.2 TypeScript 4.1 (2020-11-19)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-TypeScript-4-2-2021-02-23"><span class="toc-text">4.3 TypeScript 4.2 (2021-02-23)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-TypeScript-4-3-2021-05-26"><span class="toc-text">4.4 TypeScript 4.3 (2021-05-26)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-TypeScript-4-4-2021-08-26"><span class="toc-text">4.5 TypeScript 4.4 (2021-08-26)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-TypeScript-4-5-2021-11-17"><span class="toc-text">4.6 TypeScript 4.5 (2021-11-17)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-TypeScript-4-6-2022-02-24"><span class="toc-text">4.7 TypeScript 4.6 (2022-02-24)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-TypeScript-4-7-2022-05-24"><span class="toc-text">4.8 TypeScript 4.7 (2022-05-24)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-TypeScript-4-8-2022-08-25"><span class="toc-text">4.9 TypeScript 4.8 (2022-08-25)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-TypeScript-4-9-2022-11-15"><span class="toc-text">4.10 TypeScript 4.9 (2022-11-15)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81TypeScript-5-0-%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%89%88%EF%BC%9A%E8%A3%85%E9%A5%B0%E5%99%A8-V2-%E4%B8%8E%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F"><span class="toc-text">五、TypeScript 5.0 - 最新稳定版：装饰器 V2 与更强大的模块系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-TypeScript-5-0-2023-03-16"><span class="toc-text">5.1 TypeScript 5.0 (2023-03-16)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-TypeScript-5-1-2023-05-24"><span class="toc-text">5.2 TypeScript 5.1 (2023-05-24)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-TypeScript-5-2-2023-08-24"><span class="toc-text">5.3 TypeScript 5.2 (2023-08-24)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-TypeScript-5-3-2023-11-16"><span class="toc-text">5.4 TypeScript 5.3 (2023-11-16)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-TypeScript-5-4-%E6%9C%80%E6%96%B0%E7%A8%B3%E5%AE%9A%E7%89%88%EF%BC%8C2024-03-01"><span class="toc-text">5.5 TypeScript 5.4 (最新稳定版，2024-03-01)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-TypeScript-5-x-%E5%B1%95%E6%9C%9B-%E6%9C%AA%E6%9D%A5%E7%89%88%E6%9C%AC%EF%BC%8C%E4%BE%8B%E5%A6%82-5-5"><span class="toc-text">5.6 TypeScript 5.x 展望 (未来版本，例如 5.5+)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-14.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>