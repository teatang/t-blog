<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>DNS (Domain Name System) 协议详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DNS (Domain Name System) 是互联网的一项核心服务，它将人类可读的域名（如 www.example.com）转换为机器可读的 IP 地址（如 192.168.1.1 或 2001:0db8::1）。这种翻译功能使得用户可以方便地通过记忆友好的域名来访问网站和其他网络资源，而无需记住复杂的数字 IP 地址。DNS 本质上是一个分布式数据库系统，运行在应用层，通常使用 UDP">
<meta property="og:type" content="article">
<meta property="og:title" content="DNS (Domain Name System) 协议详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/18f2ce1e9660/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="DNS (Domain Name System) 是互联网的一项核心服务，它将人类可读的域名（如 www.example.com）转换为机器可读的 IP 地址（如 192.168.1.1 或 2001:0db8::1）。这种翻译功能使得用户可以方便地通过记忆友好的域名来访问网站和其他网络资源，而无需记住复杂的数字 IP 地址。DNS 本质上是一个分布式数据库系统，运行在应用层，通常使用 UDP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg">
<meta property="article:published_time" content="2023-03-18T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-27T10:04:33.663Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络协议">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DNS (Domain Name System) 协议详解",
  "url": "https://blog.tbf1211.xx.kg/18f2ce1e9660/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-25.jpg",
  "datePublished": "2023-03-18T22:24:00.000Z",
  "dateModified": "2026-01-27T10:04:33.663Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/18f2ce1e9660/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'DNS (Domain Name System) 协议详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">522</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-25.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">DNS (Domain Name System) 协议详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">DNS (Domain Name System) 协议详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-18T22:24:00.000Z" title="发表于 2023-03-19 06:24:00">2023-03-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>DNS (Domain Name System)</strong> 是互联网的一项核心服务，它将人类可读的域名（如 <code>www.example.com</code>）转换为机器可读的 IP 地址（如 <code>192.168.1.1</code> 或 <code>2001:0db8::1</code>）。这种翻译功能使得用户可以方便地通过记忆友好的域名来访问网站和其他网络资源，而无需记住复杂的数字 IP 地址。DNS 本质上是一个<strong>分布式数据库系统</strong>，运行在应用层，通常使用 <strong>UDP 的 53 端口</strong>进行查询，TCP 53 端口用于区域传输 (zone transfer)。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将域名映射到 IP 地址，提供一套全球性的、分层的、分布式数据库系统，从而实现互联网资源的定位和访问。</strong></p>
</div>
<hr>
<h2 id="一、为什么需要-DNS？"><a href="#一、为什么需要-DNS？" class="headerlink" title="一、为什么需要 DNS？"></a>一、为什么需要 DNS？</h2><p>在互联网的早期，少量的计算机通过一个名为 <code>HOSTS.TXT</code> 的静态文件来完成主机名到 IP 地址的映射。然而，随着计算机数量的爆发式增长，这种中心化的、静态的管理方式变得不可行，主要原因如下：</p>
<ul>
<li><strong>人类记忆限制</strong>：用户难以记住大量复杂且不断变化的 IP 地址。</li>
<li><strong>管理困难</strong>：集中式文件更新和同步的效率低下，无法适应全球范围内的网络变化。</li>
<li><strong>扩展性差</strong>：集中式系统无法承载全球互联网的数据量和查询负载。</li>
</ul>
<p>为了解决这些问题，DNS 应运而生。它提供了一个<strong>分层、分布式、可扩展</strong>的解决方案，使得：</p>
<ul>
<li>用户可以通过易于记忆的域名访问网络服务。</li>
<li>IP 地址可以随时更改，而用户看到的域名保持不变。</li>
<li>负载均衡和容错可以通过 DNS 配置实现，例如一个域名可以对应多个 IP 地址。</li>
</ul>
<h2 id="二、DNS-域名空间与层次结构"><a href="#二、DNS-域名空间与层次结构" class="headerlink" title="二、DNS 域名空间与层次结构"></a>二、DNS 域名空间与层次结构</h2><p>DNS 采用树状的、层次化的结构来管理域名，这种结构被称为<strong>域名空间 (Domain Name Space)</strong>。</p>
<h3 id="2-1-顶级域-Top-Level-Domain-TLD"><a href="#2-1-顶级域-Top-Level-Domain-TLD" class="headerlink" title="2.1 顶级域 (Top-Level Domain, TLD)"></a>2.1 顶级域 (Top-Level Domain, TLD)</h3><p>域名空间的根在最顶层，通常表示为 <code>.</code>。在其之下是顶级域，分为几类：</p>
<ul>
<li><strong>国家代码顶级域 (ccTLD)</strong>：<code>cn</code>, <code>us</code>, <code>jp</code>, <code>uk</code> 等。</li>
<li><strong>通用顶级域 (gTLD)</strong>：<code>com</code>, <code>org</code>, <code>net</code>, <code>gov</code>, <code>edu</code>, <code>info</code>, <code>biz</code> 以及新的 <code>top</code>, <code>xyz</code> 等。</li>
<li><strong>基础设施顶级域 (ARPA)</strong>：特殊的 <code>.arpa</code> 域，主要用于反向 DNS 查询。</li>
</ul>
<h3 id="2-2-二级域-Second-Level-Domain-SLD"><a href="#2-2-二级域-Second-Level-Domain-SLD" class="headerlink" title="2.2 二级域 (Second-Level Domain, SLD)"></a>2.2 二级域 (Second-Level Domain, SLD)</h3><p>在顶级域之下，是二级域。通常，组织或个人会注册一个二级域，例如 <code>example.com</code> 中的 <code>example</code>。</p>
<h3 id="2-3-三级域及其他子域"><a href="#2-3-三级域及其他子域" class="headerlink" title="2.3 三级域及其他子域"></a>2.3 三级域及其他子域</h3><p>在二级域之下，可以创建任意多层子域，例如 <code>www.example.com</code> 中的 <code>www</code>。每个点 <code>.</code> 之间代表一个层级。</p>
<p><strong>示例：<code>mail.server.example.com.</code></strong></p>
<ul>
<li><code>.</code>：根域</li>
<li><code>com</code>：顶级域 (gTLD)</li>
<li><code>example</code>：二级域</li>
<li><code>server</code>：三级域</li>
<li><code>mail</code>：四级域 (主机名)</li>
</ul>
<h2 id="三、DNS-服务器类型"><a href="#三、DNS-服务器类型" class="headerlink" title="三、DNS 服务器类型"></a>三、DNS 服务器类型</h2><p>DNS 系统由多种类型的服务器协同工作，共同完成域名解析任务。</p>
<h3 id="3-1-根域名服务器-Root-Name-Servers"><a href="#3-1-根域名服务器-Root-Name-Servers" class="headerlink" title="3.1 根域名服务器 (Root Name Servers)"></a>3.1 根域名服务器 (Root Name Servers)</h3><p>根域名服务器是 DNS 层次结构的最高层，它们存储着所有顶级域服务器的地址。全球有 13 组根服务器，由不同的组织运营。它们不直接解析域名，而是指导 DNS 解析器去查询正确的顶级域服务器。</p>
<h3 id="3-2-顶级域名服务器-Top-Level-Domain-Name-Servers-TLD-Name-Servers"><a href="#3-2-顶级域名服务器-Top-Level-Domain-Name-Servers-TLD-Name-Servers" class="headerlink" title="3.2 顶级域名服务器 (Top-Level Domain Name Servers, TLD Name Servers)"></a>3.2 顶级域名服务器 (Top-Level Domain Name Servers, TLD Name Servers)</h3><p>TLD 服务器负责管理其管辖范围内的所有二级域的权威域名服务器信息。例如，<code>.com</code> TLD 服务器知道哪些权威服务器负责 <code>example.com</code>、<code>google.com</code> 等。</p>
<h3 id="3-3-权威域名服务器-Authoritative-Name-Servers"><a href="#3-3-权威域名服务器-Authoritative-Name-Servers" class="headerlink" title="3.3 权威域名服务器 (Authoritative Name Servers)"></a>3.3 权威域名服务器 (Authoritative Name Servers)</h3><p>权威域名服务器是真正存储特定域的 DNS 记录的地方。当一个 DNS 解析器查询 <code>example.com</code> 的 IP 地址时，最终会向负责 <code>example.com</code> 的权威域名服务器发送请求。只有权威服务器能为它所管理的域提供准确的解析结果。</p>
<h3 id="3-4-递归域名服务器-Recursive-Name-Servers-DNS-Resolvers"><a href="#3-4-递归域名服务器-Recursive-Name-Servers-DNS-Resolvers" class="headerlink" title="3.4 递归域名服务器 (Recursive Name Servers &#x2F; DNS Resolvers)"></a>3.4 递归域名服务器 (Recursive Name Servers &#x2F; DNS Resolvers)</h3><p>递归域名服务器（也常被称为 DNS 解析器或缓存 DNS 服务器）是客户端最先接触的 DNS 服务器。它不直接存储域名信息，而是<strong>代表客户端</strong>向其他 DNS 服务器（根、TLD、权威）发出查询，并最终将查询结果返回给客户端。 ISP (互联网服务提供商) 通常会提供自己的递归 DNS 服务器，也有像 Google Public DNS (8.8.8.8) 和 Cloudflare (1.1.1.1) 这样的公共递归 DNS 服务器。</p>
<h2 id="四、DNS-解析流程"><a href="#四、DNS-解析流程" class="headerlink" title="四、DNS 解析流程"></a>四、DNS 解析流程</h2><p>当用户在浏览器中输入一个域名时，DNS 解析器会执行一系列步骤来获取对应的 IP 地址。这个过程通常涉及<strong>递归查询</strong>和<strong>迭代查询</strong>的组合。</p>
<ol>
<li><p><strong>客户端发起递归查询</strong>：用户电脑（或其他网络设备）的操作系统会向其配置的<strong>本地 DNS 解析器</strong>（通常是 ISP 提供或手动配置）发送一个包含域名 <code>www.example.com</code> 的查询请求。这是一个<strong>递归查询</strong>，意味着客户端期望本地解析器返回最终的 IP 地址，而不是另一个 DNS 服务器的地址。</p>
</li>
<li><p><strong>本地 DNS 解析器查询缓存</strong>：本地解析器首先检查其本地缓存。如果找到 <code>www.example.com</code> 的 IP 地址，且未过期，它会直接返回给客户端。解析结束。</p>
</li>
<li><p><strong>本地 DNS 解析器向根域名服务器发起迭代查询</strong>：如果本地缓存中没有，本地解析器会向<strong>根域名服务器</strong>发起一个迭代查询，询问 <code>www.example.com</code> 的 IP 地址。</p>
</li>
<li><p><strong>根域名服务器响应 TLD 服务器地址</strong>：根服务器没有 <code>www.example.com</code> 的 IP 地址，但它知道负责 <code>.com</code> 域的 TLD 服务器的地址，于是将其返回给本地解析器。</p>
</li>
<li><p><strong>本地 DNS 解析器向 TLD 服务器发起迭代查询</strong>：本地解析器接着向 <code>.com</code> TLD 服务器发起一个迭代查询，询问 <code>www.example.com</code> 的 IP 地址。</p>
</li>
<li><p><strong>TLD 服务器响应权威服务器地址</strong>：<code>.com</code> TLD 服务器也无法直接提供 IP 地址，但它知道负责 <code>example.com</code> 的<strong>权威域名服务器</strong>的地址，于是将其返回给本地解析器。</p>
</li>
<li><p><strong>本地 DNS 解析器向权威服务器发起迭代查询</strong>：本地解析器最后向 <code>example.com</code> 的权威域名服务器发起一个迭代查询，询问 <code>www.example.com</code> 的 IP 地址。</p>
</li>
<li><p><strong>权威域名服务器响应最终 IP 地址</strong>：<code>example.com</code> 的权威域名服务器会查找其记录，找到 <code>www.example.com</code> 对应的 IP 地址，并将其返回给本地解析器。</p>
</li>
<li><p><strong>本地 DNS 解析器缓存并返回结果</strong>：本地解析器接收到 IP 地址后，会将其缓存起来，然后将 IP 地址返回给客户端。</p>
</li>
<li><p><strong>客户端发起 HTTP 请求</strong>：客户端得到 IP 地址后，便可以使用这个 IP 地址与目标服务器建立连接（通常是 TCP 连接），并发送 HTTP 请求。</p>
</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    sequenceDiagram
    participant Client as 客户端 (浏览器&#x2F;OS)
    participant LocalResolver as 本地 DNS 解析器
    participant RootServer as 根域名服务器
    participant TLDServer as TLD 域名服务器 (.com)
    participant AuthoritativeServer as 权威域名服务器 (example.com)

    Client-&gt;&gt;LocalResolver: 1. 递归查询 www.example.com?
    LocalResolver-&gt;&gt;LocalResolver: 2. 检查本地缓存
    alt 缓存命中
        LocalResolver--&gt;&gt;Client: 3. 返回 IP 地址 (缓存)
    else 缓存未命中
        LocalResolver-&gt;&gt;RootServer: 3. 迭代查询 www.example.com?
        RootServer--&gt;&gt;LocalResolver: 4. 返回 .com TLD 服务器地址
        LocalResolver-&gt;&gt;TLDServer: 5. 迭代查询 www.example.com?
        TLDServer--&gt;&gt;LocalResolver: 6. 返回 example.com 权威服务器地址
        LocalResolver-&gt;&gt;AuthoritativeServer: 7. 迭代查询 www.example.com?
        AuthoritativeServer--&gt;&gt;LocalResolver: 8. 返回 www.example.com 的 IP 地址
        LocalResolver-&gt;&gt;LocalResolver: 9. 缓存 IP 地址及其 TTL
        LocalResolver--&gt;&gt;Client: 10. 返回 IP 地址
    end
    Client-&gt;&gt;www.example.com: 11. 使用 IP 地址建立 TCP 连接并发送 HTTP 请求
  </pre></div>

<h2 id="五、DNS-记录类型-Resource-Records-RRs"><a href="#五、DNS-记录类型-Resource-Records-RRs" class="headerlink" title="五、DNS 记录类型 (Resource Records, RRs)"></a>五、DNS 记录类型 (Resource Records, RRs)</h2><p>DNS 数据库中存储的信息以资源记录 (Resource Records, RRs) 的形式存在。每条记录都包含特定的信息。</p>
<table>
<thead>
<tr>
<th align="left">记录类型</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>A</strong></td>
<td align="left"><strong>Address Record</strong>：将域名映射到 <strong>IPv4</strong> 地址。这是最常见的记录类型。</td>
<td align="left"><code>example.com. IN A 192.0.2.1</code></td>
</tr>
<tr>
<td align="left"><strong>AAAA</strong></td>
<td align="left"><strong>IPv6 Address Record</strong>：将域名映射到 <strong>IPv6</strong> 地址。</td>
<td align="left"><code>example.com. IN AAAA 2001:0db8::1</code></td>
</tr>
<tr>
<td align="left"><strong>CNAME</strong></td>
<td align="left"><strong>Canonical Name Record</strong>：将一个域名映射到另一个规范域名（Alias，别名）。被映射的域名不能有其他记录（除 DNSSEC 相关）。</td>
<td align="left"><code>www.example.com. IN CNAME example.com.</code></td>
</tr>
<tr>
<td align="left"><strong>MX</strong></td>
<td align="left"><strong>Mail Exchange Record</strong>：指定负责接收特定域电子邮件的邮件服务器。包含优先级和邮件服务器的域名。</td>
<td align="left"><code>example.com. IN MX 10 mail.example.com.</code></td>
</tr>
<tr>
<td align="left"><strong>NS</strong></td>
<td align="left"><strong>Name Server Record</strong>：指定负责特定域的权威域名服务器。</td>
<td align="left"><code>example.com. IN NS ns1.example.com.</code></td>
</tr>
<tr>
<td align="left"><strong>PTR</strong></td>
<td align="left"><strong>Pointer Record</strong>：用于<strong>反向 DNS 查询</strong>，将 IP 地址映射回域名。主要用于邮件服务器验证和日志记录。</td>
<td align="left"><code>1.2.0.192.in-addr.arpa. IN PTR host.example.com.</code></td>
</tr>
<tr>
<td align="left"><strong>TXT</strong></td>
<td align="left"><strong>Text Record</strong>：用于存储任意文本信息。常用于 SPF (Sender Policy Framework)、DKIM (DomainKeys Identified Mail) 等邮件验证机制，或验证域名的所有权。</td>
<td align="left"><code>example.com. IN TXT &quot;v=spf1 include:_spf.google.com ~all&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>SRV</strong></td>
<td align="left"><strong>Service Record</strong>：指定特定服务（如 SIP、XMPP 等）的主机和端口。</td>
<td align="left"><code>_sip._tcp.example.com. IN SRV 0 5 5060 sipserver.example.com.</code></td>
</tr>
<tr>
<td align="left"><strong>SOA</strong></td>
<td align="left"><strong>Start of Authority Record</strong>：标志着一个 DNS 区域的开始，包含该区域管理的基本信息，如主权威服务器、管理员邮箱、序列号、刷新间隔等。</td>
<td align="left"><code>example.com. IN SOA ns1.example.com. admin.example.com. ( 2023010101 7200 3600 1209600 3600 )</code></td>
</tr>
</tbody></table>
<h2 id="六、DNS-缓存"><a href="#六、DNS-缓存" class="headerlink" title="六、DNS 缓存"></a>六、DNS 缓存</h2><p>DNS 缓存是 DNS 系统性能优化的关键机制。为了减少每次查询都重复整个解析过程的开销，DNS 服务器和客户端会在本地存储已解析的域名到 IP 地址的映射。</p>
<ul>
<li><strong>本地 DNS 解析器缓存</strong>：ISP 提供的递归 DNS 服务器会缓存它查询到的结果。</li>
<li><strong>操作系统缓存</strong>：客户端操作系统也会维护一个 DNS 缓存。</li>
<li><strong>浏览器缓存</strong>：部分浏览器甚至会维护自己的 DNS 缓存。</li>
</ul>
<p>缓存记录的有效期由 DNS 记录中的 <strong>TTL (Time To Live)</strong> 值决定。当 TTL 过期后，缓存中的记录会被删除，下次查询时需要重新进行解析。</p>
<h2 id="七、DNS-安全性考虑"><a href="#七、DNS-安全性考虑" class="headerlink" title="七、DNS 安全性考虑"></a>七、DNS 安全性考虑</h2><p>DNS 作为互联网基础设施的关键部分，其安全性至关重要。面临的威胁包括：</p>
<h3 id="7-1-DNS-欺骗-DNS-Spoofing-缓存投毒-Cache-Poisoning"><a href="#7-1-DNS-欺骗-DNS-Spoofing-缓存投毒-Cache-Poisoning" class="headerlink" title="7.1 DNS 欺骗 (DNS Spoofing) &#x2F; 缓存投毒 (Cache Poisoning)"></a>7.1 DNS 欺骗 (DNS Spoofing) &#x2F; 缓存投毒 (Cache Poisoning)</h3><p>攻击者通过向 DNS 解析器发送伪造的 DNS 响应，使其缓存错误的域名到 IP 地址的映射。当用户试图访问该域名时，会被重定向到攻击者控制的恶意网站。</p>
<h3 id="7-2-DDoS-攻击-Distributed-Denial-of-Service"><a href="#7-2-DDoS-攻击-Distributed-Denial-of-Service" class="headerlink" title="7.2 DDoS 攻击 (Distributed Denial of Service)"></a>7.2 DDoS 攻击 (Distributed Denial of Service)</h3><p>攻击者可能针对 DNS 服务器发起 DDoS 攻击，通过大量的查询请求或反射攻击使其瘫痪，从而导致域名解析服务中断。</p>
<h3 id="7-3-DNS-隐私问题"><a href="#7-3-DNS-隐私问题" class="headerlink" title="7.3 DNS 隐私问题"></a>7.3 DNS 隐私问题</h3><p>传统的 DNS 查询是未加密的，查询请求和响应在网络中以明文传输，可能被窃听，从而暴露用户的互联网活动。</p>
<h3 id="7-4-解决方案与改进"><a href="#7-4-解决方案与改进" class="headerlink" title="7.4 解决方案与改进"></a>7.4 解决方案与改进</h3><ol>
<li><p><strong>DNSSEC (DNS Security Extensions)</strong>：</p>
<ul>
<li>通过数字签名和公钥加密来验证 DNS 数据的完整性和真实性。它为 DNS 记录添加了加密签名，允许解析器验证其来源和数据未被篡改。DNSSEC 旨在保护 DNS 客户端免受伪造 DNS 数据（如 DNS 缓存投毒）的侵害。</li>
</ul>
</li>
<li><p><strong>DNS over HTTPS (DoH) 和 DNS over TLS (DoT)</strong>：</p>
<ul>
<li>DoH 和 DoT 通过加密信道（HTTPS 或 TLS）传输 DNS 查询，防止中间人窃听和篡改。</li>
<li><strong>DoT</strong> (DNS over TLS) 使用 TLS 协议对 DNS 查询进行加密，通常运行在 853 端口。</li>
<li><strong>DoH</strong> (DNS over HTTPS) 将 DNS 查询封装在 HTTPS 请求中，使用 443 端口。</li>
</ul>
</li>
</ol>
<h2 id="八、代码示例：在-Python-或-Go-中进行-DNS-查询"><a href="#八、代码示例：在-Python-或-Go-中进行-DNS-查询" class="headerlink" title="八、代码示例：在 Python 或 Go 中进行 DNS 查询"></a>八、代码示例：在 Python 或 Go 中进行 DNS 查询</h2><h3 id="8-1-Python-示例"><a href="#8-1-Python-示例" class="headerlink" title="8.1 Python 示例"></a>8.1 Python 示例</h3><p>Python 的 <code>socket</code> 模块可以进行基本的 IP 地址查找。更高级的功能可以使用 <code>dnspython</code> 库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> dns.resolver <span class="comment"># 需要安装：pip install dnspython</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resolve_domain_socket</span>(<span class="params">domain</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 socket 模块解析域名到 IPv4 地址&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ip_address = socket.gethostbyname(domain)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Socket 模块解析 <span class="subst">&#123;domain&#125;</span> -&gt; IPv4: <span class="subst">&#123;ip_address&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> socket.gaierror <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Socket 模块解析 <span class="subst">&#123;domain&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resolve_domain_dnspython</span>(<span class="params">domain</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 dnspython 库解析域名并获取 A, AAAA, MX 记录&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 查询 A 记录 (IPv4)</span></span><br><span class="line">        a_records = dns.resolver.resolve(domain, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Dnspython 解析 <span class="subst">&#123;domain&#125;</span> A 记录:&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> a_records:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  IPv4: <span class="subst">&#123;record.address&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查询 AAAA 记录 (IPv6)</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            aaaa_records = dns.resolver.resolve(domain, <span class="string">&#x27;AAAA&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Dnspython 解析 <span class="subst">&#123;domain&#125;</span> AAAA 记录:&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> record <span class="keyword">in</span> aaaa_records:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;  IPv6: <span class="subst">&#123;record.address&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> dns.resolver.NoAnswer:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;domain&#125;</span> 没有 AAAA 记录&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查询 MX 记录 (邮件交换)</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            mx_records = dns.resolver.resolve(domain, <span class="string">&#x27;MX&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Dnspython 解析 <span class="subst">&#123;domain&#125;</span> MX 记录:&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> record <span class="keyword">in</span> mx_records:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;  优先级: <span class="subst">&#123;record.preference&#125;</span>, 邮件服务器: <span class="subst">&#123;record.exchange&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> dns.resolver.NoAnswer:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;domain&#125;</span> 没有 MX 记录&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Dnspython 解析 <span class="subst">&#123;domain&#125;</span> 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test_domain = <span class="string">&quot;www.google.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- 使用 socket 模块 ---&quot;</span>)</span><br><span class="line">    resolve_domain_socket(test_domain)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- 使用 dnspython 模块 ---&quot;</span>)</span><br><span class="line">    resolve_domain_dnspython(test_domain)</span><br><span class="line"></span><br><span class="line">    test_domain_no_ipv6 = <span class="string">&quot;example.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n--- 测试 <span class="subst">&#123;test_domain_no_ipv6&#125;</span> ---&quot;</span>)</span><br><span class="line">    resolve_domain_dnspython(test_domain_no_ipv6)</span><br></pre></td></tr></table></figure>

<h3 id="8-2-Go-示例"><a href="#8-2-Go-示例" class="headerlink" title="8.2 Go 示例"></a>8.2 Go 示例</h3><p>Go 语言标准库 <code>net</code> 提供了强大的 DNS 查询功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveDomain</span><span class="params">(domain <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;--- 解析 %s ---\n&quot;</span>, domain)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 IPv4 和 IPv6 地址 (A 和 AAAA 记录)</span></span><br><span class="line">	ips, err := net.LookupIP(domain)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;LookupIP 失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, ip := <span class="keyword">range</span> ips &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;  IP 地址: %s\n&quot;</span>, ip.String())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 CNAME 记录</span></span><br><span class="line">	cname, err := net.LookupCNAME(domain)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;LookupCNAME 失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> cname != domain+<span class="string">&quot;.&quot;</span> &#123; <span class="comment">// CNAME 返回规范域名，末尾带点</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;  CNAME: %s\n&quot;</span>, cname)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 MX (邮件交换) 记录</span></span><br><span class="line">	mxs, err := net.LookupMX(domain)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;LookupMX 失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;  邮件服务器 (MX):&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, mx := <span class="keyword">range</span> mxs &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;    主机: %s, 优先级: %d\n&quot;</span>, mx.Host, mx.Pref)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 NS (域名服务器) 记录</span></span><br><span class="line">	nss, err := net.LookupNS(domain)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;LookupNS 失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;  域名服务器 (NS):&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, ns := <span class="keyword">range</span> nss &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;    主机: %s\n&quot;</span>, ns.Host)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析 TXT 记录</span></span><br><span class="line">	txts, err := net.LookupTXT(domain)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;LookupTXT 失败: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;  文本记录 (TXT):&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, txt := <span class="keyword">range</span> txts &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;    内容: %s\n&quot;</span>, txt)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resolveDomain(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	resolveDomain(<span class="string">&quot;example.com&quot;</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	resolveDomain(<span class="string">&quot;mail.example.com&quot;</span>) <span class="comment">// 一个可能存在 MX 记录的子域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>DNS 协议是互联网的基石之一，它通过一个全球性的、分层的、分布式数据库系统，将人类友好的域名转换为机器可识别的 IP 地址，极大地提高了互联网的可用性和可访问性。理解 DNS 的工作原理、其关键组件（如各种服务器类型和记录类型）以及解析流程，对于任何网络专业人员和开发者都至关重要。同时，随着网络威胁的不断演进，DNSSEC、DoH 和 DoT 等安全扩展也在不断加强 DNS 的安全性，保护用户免受欺骗和窥探。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/18f2ce1e9660/">https://blog.tbf1211.xx.kg/18f2ce1e9660/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-25.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/65edca489ee4/" title="DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS over TLS (DoT) 和 DNS over HTTPS (DoH) 是旨在增强 DNS (Domain Name System) 查询和响应隐私性 (Privacy) 与安全性 (Security) 的两种协议。它们通过对 DNS 流量进行加密，防止网络中间方（如 ISP、政府机构或恶意攻击者）窥探用户的域名解析请求或篡改 DNS 响应，从而解决了传统 DNS 协议固有的安全和隐私缺陷。  核心思想：将明文传输的 DNS 查询封装到加密的传输层安全 (TLS) 或超文本传输安全 (HTTPS) 连接中，以保护用户隐私、防止 DNS 劫持和对抗网络审查。   一、传统 DNS 的隐私与安全痛点传统的 DNS 协议通常通过 UDP (User Datagram Protocol) 或 TCP (Transmission Control Protocol) 的 53 号端口进行通信。这种通信方式存在以下固有的安全和隐私缺陷：  明文传输 (Plaintext Transmission)：DNS 查询和响应在网络上以明文形式传输。  隐私泄露：任何能够嗅探网络流量的中间...</div></div></div></a><a class="pagination-related" href="/82faa099bd25/" title="FTP (File Transfer Protocol) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">FTP (File Transfer Protocol) 协议详解</div></div><div class="info-2"><div class="info-item-1"> FTP (File Transfer Protocol) 是一个用于在网络上进行文件传输的标准网络协议，是 TCP&#x2F;IP 协议族中的一个应用层协议。它允许客户端和服务器之间传输文件，支持上传、下载、删除、重命名文件，以及创建和删除目录等操作。FTP 是最早期的互联网协议之一，设计初衷是为了在不同的操作系统和文件系统之间提供统一的文件传输服务。  核心思想：基于客户端-服务器模式，利用独立的控制连接和数据连接，高效可靠地传输文件。   一、为什么需要 FTP？在二十世纪七十年代，互联网的前身 ARPANET 还在发展初期，用户需要一种可靠的方式在不同的计算机系统之间共享文件。FTP 因此被设计出来，解决了以下痛点：  跨平台文件传输：允许不同操作系统（如 Unix、Windows）之间传输文件，统一了文件传输的格式和控制命令。 可靠性：基于 TCP 协议，保证文件传输的可靠性（数据不丢失、不重复、按序到达）。 大文件传输：能够处理大文件的传输，并通过数据流控制确保传输效率。 用户权限管理：支持用户认证，可以根据用户身份分配不同的文件访问权限。  尽管 FTP 历史悠久、...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/bfc3178a0093/" title="FRP (Fast Reverse Proxy) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-26</div><div class="info-item-2">FRP (Fast Reverse Proxy) 详解</div></div><div class="info-2"><div class="info-item-1"> FRP (Fast Reverse Proxy) 是一个高性能的内网穿透和反向代理工具，它允许您将位于内网（局域网）中的服务（如 Web 服务器、SSH、数据库等）通过一台具有公网 IP 的服务器暴露给公网用户访问。在当前 IPv4 地址资源日益紧张，许多家庭和小型办公室难以获取公网 IP 的背景下，FRP 提供了便捷、高效的解决方案。  核心思想：FRP 通过在公网服务器上运行一个 frps (服务端) 和在内网机器上运行一个 frpc (客户端) 来建立连接。内网流量经由 frpc 转发到 frps，再由 frps 转发到公网用户，实现内网服务的公网访问。   一、为什么需要 FRP？在许多场景下，我们需要从外部网络访问位于内网的服务，但常常面临以下问题：  没有公网 IP：大多数家庭宽带用户和一些小型企业用户不再拥有独立的公网 IPv4 地址。他们处于运营商的 NAT (Network Address Translation) 之后，无法直接从外部访问内网设备。 端口转发困难：即使有公网 IP，也可能需要手动在路由器上配置端口转发规则，这对于不熟悉网络配置的用户来说可能比...</div></div></div></a><a class="pagination-related" href="/65edca489ee4/" title="DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="info-item-2">DNS over TLS (DoT) 与 DNS over HTTPS (DoH) 协议详解</div></div><div class="info-2"><div class="info-item-1"> DNS over TLS (DoT) 和 DNS over HTTPS (DoH) 是旨在增强 DNS (Domain Name System) 查询和响应隐私性 (Privacy) 与安全性 (Security) 的两种协议。它们通过对 DNS 流量进行加密，防止网络中间方（如 ISP、政府机构或恶意攻击者）窥探用户的域名解析请求或篡改 DNS 响应，从而解决了传统 DNS 协议固有的安全和隐私缺陷。  核心思想：将明文传输的 DNS 查询封装到加密的传输层安全 (TLS) 或超文本传输安全 (HTTPS) 连接中，以保护用户隐私、防止 DNS 劫持和对抗网络审查。   一、传统 DNS 的隐私与安全痛点传统的 DNS 协议通常通过 UDP (User Datagram Protocol) 或 TCP (Transmission Control Protocol) 的 53 号端口进行通信。这种通信方式存在以下固有的安全和隐私缺陷：  明文传输 (Plaintext Transmission)：DNS 查询和响应在网络上以明文形式传输。  隐私泄露：任何能够嗅探网络流量的中间...</div></div></div></a><a class="pagination-related" href="/7bd4a820ad36/" title="TCP&#x2F;IP协议栈深度详解：因特网的核心基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-11</div><div class="info-item-2">TCP&#x2F;IP协议栈深度详解：因特网的核心基石</div></div><div class="info-2"><div class="info-item-1"> TCP&#x2F;IP 协议 (Transmission Control Protocol&#x2F;Internet Protocol) 是一组用于互联网通信的协议集合，通常被称为 TCP&#x2F;IP 协议族 (TCP&#x2F;IP Protocol Suite) 或 TCP&#x2F;IP 协议栈 (TCP&#x2F;IP Protocol Stack)。它是现代互联网和局域网 (LAN) 的基石，定义了数据如何在网络中传输、路由和接收。TCP&#x2F;IP 协议族以其分层结构而闻名，将复杂的网络通信任务分解为更小、更易于管理的子任务。  核心思想：将复杂的网络通信过程划分为独立的层次，每层负责特定的功能，并通过协议进行协作，从而实现高效、可靠且可扩展的全球通信。   一、为什么需要 TCP&#x2F;IP 协议？在计算机网络发展的早期，各种网络设备和操作系统拥有各自不兼容的通信协议，导致不同厂商的设备之间难以互联互通。为了解决这一问题，美国国防部高级研究计划局 (ARPA) 资助开发了 ARPANET 项目，并在此基础上逐步发展出了 TCP&#x2F;IP 协议。...</div></div></div></a><a class="pagination-related" href="/6479020306f5/" title="HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="info-item-2">HTTP&#x2F;3 协议深度详解：构建更快、更可靠的未来 Web</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;3 是 HTTP 协议的最新主要版本，于 2022 年 6 月被 IETF 正式标准化 (RFC 9114)。它的最根本变化在于将底层传输协议从使用了数十年的 TCP 替换为全新的 QUIC (Quick UDP Internet Connections) 协议。这一革新性举措旨在克服 HTTP&#x2F;2 仍然无法解决的底层传输效率问题，并提供更快的连接建立、更强大的安全性及在复杂网络环境下的韧性，从而彻底改变 Web 资源的传输方式。  核心思想：HTTP&#x2F;3 运行在 QUIC 协议之上，而 QUIC 又运行在 UDP 协议之上。通过在传输层而非应用层引入多路复用、内置 TLS 1.3 加密、连接迁移等特性，HTTP&#x2F;3 提供了一个比 HTTP&#x2F;2 更快、更稳定、更安全的 Web 体验，尤其在移动网络和有损网络环境下表现突出。   一、HTTP&#x2F;2 的局限性与 HTTP&#x2F;3 的出现背景HTTP&#x2F;2 作为 HTTP&#x2F;1.1 的继任者，通过头部压缩、多路复用和服务器推送等机制，显著提升了...</div></div></div></a><a class="pagination-related" href="/8fad93ea4f62/" title="ALPN (Application-Layer Protocol Negotiation) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="info-item-2">ALPN (Application-Layer Protocol Negotiation) 详解</div></div><div class="info-2"><div class="info-item-1"> ALPN (Application-Layer Protocol Negotiation)，即应用层协议协商，是 TLS (传输层安全) 协议的一个扩展，允许客户端和服务器在进行 TLS 握手时，协商决定在加密连接上使用哪个应用层协议。它在 RFC 7301 中被定义。ALPN 的出现，极大地简化了现代网络协议的部署和使用，尤其是对于 HTTP&#x2F;2 和未来的 QUIC 等协议。  核心思想：ALPN 将应用层协议的选择过程集成到 TLS 握手阶段，使得在建立加密连接的同时，也完成了应用层协议的确定，避免了额外的往返延迟，并允许在同一端口上运行多种应用层协议。   一、为什么需要 ALPN？在 ALPN 出现之前，协商应用层协议通常面临以下挑战：  端口绑定：传统的做法是为不同的应用层协议使用不同的端口。例如，HTTP 使用 80 端口，HTTPS 使用 443 端口，FTP 使用 21 端口。当引入新的协议（如 HTTP&#x2F;2 或 SPDY）时，如果想与现有协议共存，就必须使用新的端口，这会增加防火墙配置、负载均衡设置的复杂性，并且用户可能需要记住非标准的端口...</div></div></div></a><a class="pagination-related" href="/a8d205bac226/" title="HTTP&#x2F;2 协议深度详解：Web 性能的飞跃"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="info-item-2">HTTP&#x2F;2 协议深度详解：Web 性能的飞跃</div></div><div class="info-2"><div class="info-item-1"> HTTP&#x2F;2 协议是 HTTP 协议的第二个主要版本，于 2015 年发布 (RFC 7540)。它基于 Google 开发的实验性协议 SPDY，旨在解决 HTTP&#x2F;1.1 长期存在的性能瓶颈，从而显著提升 Web 应用程序的加载速度和响应能力。HTTP&#x2F;2 不改变 HTTP 语义 (请求方法、状态码、URI 等)，而是改变了数据的传输方式，使其在网络层更高效。  核心思想：HTTP&#x2F;2 通过引入二进制分帧、多路复用、头部压缩和服务器推送等新特性，克服了 HTTP&#x2F;1.1 面临的队头阻塞和冗余开销问题，实现了在单个 TCP 连接上并行传输多个请求和响应，从而达到更快的页面加载速度和更好的用户体验。   一、HTTP&#x2F;1.1 的痛点与 HTTP&#x2F;2 的诞生背景尽管 HTTP&#x2F;1.1 通过持久连接和缓存机制解决了 HTTP&#x2F;1.0 的很多问题，但随着 Web 页面复杂度的急剧增加（大量 CSS、JavaScript、图片、字体等资源），HTTP&#x2F;1.1 仍暴露出一些严重的性能瓶颈：...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">522</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-DNS%EF%BC%9F"><span class="toc-text">一、为什么需要 DNS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81DNS-%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">二、DNS 域名空间与层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%A1%B6%E7%BA%A7%E5%9F%9F-Top-Level-Domain-TLD"><span class="toc-text">2.1 顶级域 (Top-Level Domain, TLD)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BA%8C%E7%BA%A7%E5%9F%9F-Second-Level-Domain-SLD"><span class="toc-text">2.2 二级域 (Second-Level Domain, SLD)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%B8%89%E7%BA%A7%E5%9F%9F%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AD%90%E5%9F%9F"><span class="toc-text">2.3 三级域及其他子域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">三、DNS 服务器类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%B9%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-Root-Name-Servers"><span class="toc-text">3.1 根域名服务器 (Root Name Servers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-Top-Level-Domain-Name-Servers-TLD-Name-Servers"><span class="toc-text">3.2 顶级域名服务器 (Top-Level Domain Name Servers, TLD Name Servers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9D%83%E5%A8%81%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-Authoritative-Name-Servers"><span class="toc-text">3.3 权威域名服务器 (Authoritative Name Servers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%80%92%E5%BD%92%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8-Recursive-Name-Servers-DNS-Resolvers"><span class="toc-text">3.4 递归域名服务器 (Recursive Name Servers &#x2F; DNS Resolvers)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81DNS-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">四、DNS 解析流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81DNS-%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B-Resource-Records-RRs"><span class="toc-text">五、DNS 记录类型 (Resource Records, RRs)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81DNS-%E7%BC%93%E5%AD%98"><span class="toc-text">六、DNS 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81DNS-%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-text">七、DNS 安全性考虑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-DNS-%E6%AC%BA%E9%AA%97-DNS-Spoofing-%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92-Cache-Poisoning"><span class="toc-text">7.1 DNS 欺骗 (DNS Spoofing) &#x2F; 缓存投毒 (Cache Poisoning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-DDoS-%E6%94%BB%E5%87%BB-Distributed-Denial-of-Service"><span class="toc-text">7.2 DDoS 攻击 (Distributed Denial of Service)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-DNS-%E9%9A%90%E7%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">7.3 DNS 隐私问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%8E%E6%94%B9%E8%BF%9B"><span class="toc-text">7.4 解决方案与改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9C%A8-Python-%E6%88%96-Go-%E4%B8%AD%E8%BF%9B%E8%A1%8C-DNS-%E6%9F%A5%E8%AF%A2"><span class="toc-text">八、代码示例：在 Python 或 Go 中进行 DNS 查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Python-%E7%A4%BA%E4%BE%8B"><span class="toc-text">8.1 Python 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Go-%E7%A4%BA%E4%BE%8B"><span class="toc-text">8.2 Go 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">九、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-25.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>