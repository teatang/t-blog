<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSDLC (安全软件开发生命周期) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SSDLC (Secure Software Development Life Cycle，安全软件开发生命周期) 是一种将安全实践和活动集成到整个软件开发生命周期 (SDLC) 各个阶段的方法。它旨在从项目启动到软件部署和维护的每一个环节，系统地识别、缓解和消除软件漏洞，确保构建出本质上更安全的应用程序。  传统的软件开发往往将安全性视为一个后期添加的特性或“事后”的活动，导致在开发后期才发现">
<meta property="og:type" content="article">
<meta property="og:title" content="SSDLC (安全软件开发生命周期) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/c58da3f1e952/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="SSDLC (Secure Software Development Life Cycle，安全软件开发生命周期) 是一种将安全实践和活动集成到整个软件开发生命周期 (SDLC) 各个阶段的方法。它旨在从项目启动到软件部署和维护的每一个环节，系统地识别、缓解和消除软件漏洞，确保构建出本质上更安全的应用程序。  传统的软件开发往往将安全性视为一个后期添加的特性或“事后”的活动，导致在开发后期才发现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg">
<meta property="article:published_time" content="2025-10-02T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-24T14:25:00.989Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSDLC (安全软件开发生命周期) 详解",
  "url": "https://blog.tbf1211.xx.kg/c58da3f1e952/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-03.jpg",
  "datePublished": "2025-10-02T22:24:00.000Z",
  "dateModified": "2026-01-24T14:25:00.989Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/c58da3f1e952/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSDLC (安全软件开发生命周期) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">518</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-03.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">SSDLC (安全软件开发生命周期) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SSDLC (安全软件开发生命周期) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-10-02T22:24:00.000Z" title="发表于 2025-10-03 06:24:00">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>SSDLC (Secure Software Development Life Cycle，安全软件开发生命周期)</strong> 是一种将安全实践和活动集成到整个软件开发生命周期 (SDLC) 各个阶段的方法。它旨在从项目启动到软件部署和维护的每一个环节，系统地识别、缓解和消除软件漏洞，确保构建出本质上更安全的应用程序。</p>
</blockquote>
<div class="note info flat"><p>传统的软件开发往往将安全性视为一个后期添加的特性或“事后”的活动，导致在开发后期才发现大量安全缺陷，修复成本高昂，甚至可能导致项目延期。SSDLC 强调“<strong>安全左移 (Shift-Left Security)</strong>”理念，这意味着安全工作应尽早开始，贯穿整个开发过程，而不是仅在代码编写完成后进行安全测试。</p>
</div>
<hr>
<h2 id="一、为什么需要-SSDLC？"><a href="#一、为什么需要-SSDLC？" class="headerlink" title="一、为什么需要 SSDLC？"></a>一、为什么需要 SSDLC？</h2><p>在数字化转型的浪潮中，软件已成为业务的核心驱动力，但随之而来的安全风险也日益凸显。传统 SDLC 面临以下安全挑战：</p>
<ol>
<li><strong>后期发现的漏洞成本高昂</strong>：在生产环境中发现的漏洞，其修复成本可能是设计阶段发现的几十甚至上百倍。这包括重新编码、测试、部署，甚至可能面临经济损失和品牌损害。</li>
<li><strong>快速迭代下的安全风险累积</strong>：DevOps 和敏捷开发模式强调快速交付，如果安全没有融入流程，可能会为了速度牺牲安全，导致安全债务累积。</li>
<li><strong>合规性要求日益严格</strong>：GDPR、PCI DSS、HIPAA 等法规对数据保护和软件安全提出了更高要求，不符合规范可能面临巨额罚款。</li>
<li><strong>供应链攻击风险</strong>：广泛使用的第三方库、开源组件及其依赖项可能引入已知漏洞，需要贯穿整个生命周期的安全管理。</li>
<li><strong>0-Day 和高级持续性威胁 (APT)</strong>：攻击者持续寻找新的漏洞，要求软件具备更强的韧性。</li>
<li><strong>安全成为业务风险</strong>：数据泄露、服务中断不仅是技术问题，更是直接影响企业声誉和生存的业务风险。</li>
</ol>
<p>SSDLC 通过将安全考量融入每个阶段，从根本上解决这些问题，确保软件从设计之初就具备安全性，而不是后期打补丁。</p>
<h2 id="二、SSDLC-的核心原则和目标"><a href="#二、SSDLC-的核心原则和目标" class="headerlink" title="二、SSDLC 的核心原则和目标"></a>二、SSDLC 的核心原则和目标</h2><p>SSDLC 的核心在于转变安全思维，将安全性内建于软件，而非外加。其主要原则和目标包括：</p>
<ol>
<li><strong>安全左移 (Shift Left)</strong>：将安全活动尽可能地提前到 SDLC 的早期阶段（需求、设计），预防性地解决问题。</li>
<li><strong>安全是贯穿始终的责任</strong>：强调所有参与者（开发者、测试人员、架构师、运维人员）都有责任保障软件安全。</li>
<li><strong>自动化优先</strong>：尽可能地自动化安全测试和检查，减少人工干预，提高效率和一致性。</li>
<li><strong>可衡量性</strong>：定义清晰的安全指标和目标，持续监控和改进安全态势。</li>
<li><strong>持续改进</strong>：通过漏洞分析、回顾和经验教训的积累，不断优化安全流程和实践。</li>
<li><strong>最小权限原则 (Principle of Least Privilege)</strong>：在设计和实现中，确保模块、服务和用户仅拥有完成其功能所需的最小权限。</li>
<li><strong>深度防御 (Defense in Depth)</strong>：采用多层安全控制，即使某一层被突破，其他层也能提供保护。</li>
<li><strong>故障安全 (Fail Securely)</strong>：当系统发生故障时，应默认进入最安全的状态，而不是暴露潜在风险。</li>
</ol>
<h2 id="三、SSDLC-的主要阶段及安全活动"><a href="#三、SSDLC-的主要阶段及安全活动" class="headerlink" title="三、SSDLC 的主要阶段及安全活动"></a>三、SSDLC 的主要阶段及安全活动</h2><p>SSDLC 将安全活动融入传统 SDLC 的各个阶段。一个典型的 SSDLC 流程图如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[需求分析] --&gt; B[安全需求识别 &amp; 威胁建模];
    B --&gt; C[设计阶段];
    C --&gt; D[安全架构设计 &amp; 安全设计审查];
    D --&gt; E[编码阶段];
    E --&gt; F[安全编码规范 &amp; SAST &amp; 秘钥管理];
    F --&gt; G[测试阶段];
    G --&gt; H[DAST &amp; IAST &amp; 渗透测试 &amp; Fuzz测试];
    H --&gt; I[部署阶段];
    I --&gt; J[安全配置 &amp; 硬化 &amp; 漏洞扫描];
    J --&gt; K[维护与监控];
    K --&gt; L[日志审计 &amp; 漏洞管理 &amp; 应急响应 &amp; 持续监控];
    L --&gt; B;
  </pre></div>

<h3 id="3-1-需求分析与规划-Requirements-Planning"><a href="#3-1-需求分析与规划-Requirements-Planning" class="headerlink" title="3.1 需求分析与规划 (Requirements &amp; Planning)"></a>3.1 需求分析与规划 (Requirements &amp; Planning)</h3><p>在项目启动之初，安全团队与业务团队、开发团队协作，明确安全目标和非功能性安全需求。</p>
<ul>
<li><p><strong>安全需求收集</strong>：</p>
<ul>
<li>识别所有与安全性相关的业务和用户需求（如认证、授权、数据隐私、日志审计、可用性）。</li>
<li>参照行业标准（如 OWASP ASVS）或公司内部安全策略定义安全要求。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 系统必须能够抵御 OWASP Top 10 中列出的所有漏洞。</span><br><span class="line">- 所有用户敏感数据必须进行端到端加密存储。</span><br><span class="line">- 用户的认证机制必须符合 FIPS 140-2 标准。</span><br><span class="line">- 所有访问尝试（成功或失败）都必须记录日志。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>威胁建模 (Threat Modeling) 启动</strong>：</p>
<ul>
<li>初步识别可能存在的威胁和攻击面。</li>
<li>通过工具 (如 Microsoft Threat Modeling Tool) 或框架 (如 STRIDE) 开始分析。</li>
<li>确定资产、威胁来源和潜在漏洞。</li>
</ul>
</li>
<li><p><strong>风险评估</strong>：</p>
<ul>
<li>评估潜在威胁对业务的影响和发生的可能性。</li>
<li>根据评估结果确定安全工作的优先级。</li>
</ul>
</li>
</ul>
<h3 id="3-2-设计阶段-Design"><a href="#3-2-设计阶段-Design" class="headerlink" title="3.2 设计阶段 (Design)"></a>3.2 设计阶段 (Design)</h3><p>将安全需求转化为具体的设计方案，确保安全机制从架构层面就得到支持。</p>
<ul>
<li><strong>详细威胁建模 (Deep Threat Modeling)</strong>：<ul>
<li>深入分析系统架构、组件交互和数据流，识别潜在的攻击路径。</li>
<li>应用 STRIDE (Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege) 或 DREAD 等模型评估威胁。</li>
<li><strong>示例</strong>：针对一个微服务架构，分析服务间的认证鉴权机制、API 网关的安全策略、数据库访问控制等。</li>
</ul>
</li>
<li><strong>安全架构设计</strong>：<ul>
<li>采用安全设计模式和原则（如最小权限、纵深防御、故障安全）。</li>
<li>设计身份和访问管理 (IAM)、数据加密、安全通信协议、日志和审计机制、输入验证等。</li>
</ul>
</li>
<li><strong>安全设计审查 (Security Design Review)</strong>：<ul>
<li>由安全专家评审架构设计和详细设计文档，发现潜在的设计缺陷和安全漏洞。</li>
<li>确保安全控制与威胁缓解措施的有效性。</li>
</ul>
</li>
</ul>
<h3 id="3-3-编码与实现阶段-Implementation-Coding"><a href="#3-3-编码与实现阶段-Implementation-Coding" class="headerlink" title="3.3 编码与实现阶段 (Implementation &amp; Coding)"></a>3.3 编码与实现阶段 (Implementation &amp; Coding)</h3><p>开发者编写代码时，需遵循安全编码规范，并利用自动化工具进行初步的安全检查。</p>
<ul>
<li><strong>安全编码规范</strong>：<ul>
<li>遵循安全编码最佳实践（如 OWASP Secure Coding Practices Quick Reference Guide）。</li>
<li>对输入数据进行严格验证和净化，防止注入攻击。</li>
<li>避免硬编码敏感信息。</li>
<li>使用安全的API和库。</li>
</ul>
</li>
<li><strong>静态应用安全测试 (SAST)</strong>：<ul>
<li><strong>工具</strong>：Synopsys Coverity, Checkmarx, Fortify, SonarQube, Bandit (Python), gosec (Go) 等。</li>
<li><strong>集成</strong>：将 SAST 工具集成到开发者的 IDE 和 CI&#x2F;CD 管道中，对源代码、字节码或二进制代码进行分析，识别漏洞。</li>
<li><strong>示例 (CI&#x2F;CD 阶段运行 SAST)</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml 或 .github/workflows/main.yml</span></span><br><span class="line"><span class="attr">sast_scan:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">docker/tool_image_with_sast_scanner</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Running SAST scan...&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/path/to/sast_scanner</span> <span class="string">--source-dir=.</span> <span class="string">--output-format=json</span> <span class="string">&gt;</span> <span class="string">sast_report.json</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span> <span class="string">sast_report.json</span> <span class="comment"># 打印报告</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">if</span> [ <span class="string">$(jq</span> <span class="string">&#x27;.vulnerabilities | length&#x27;</span> <span class="string">sast_report.json)</span> <span class="string">-gt</span> <span class="number">0</span> ]<span class="string">;</span> <span class="string">then</span> <span class="string">exit</span> <span class="number">1</span><span class="string">;</span> <span class="string">fi</span> <span class="comment"># 如果发现漏洞则失败</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sast_report.json</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>软件成分分析 (SCA)</strong>：<ul>
<li><strong>工具</strong>：Trivy, Snyk, WhiteSource, OWASP Dependency-Check 等。</li>
<li>扫描项目中使用的第三方库、开源组件及其依赖，发现已知的安全漏洞。</li>
</ul>
</li>
<li><strong>秘密管理 (Secrets Management)</strong>：<ul>
<li>使用专门的工具（如 HashiCorp Vault, AWS Secrets Manager, Azure Key Vault）来存储和管理应用程序的敏感凭证，而不是硬编码在代码中。</li>
</ul>
</li>
</ul>
<h3 id="3-4-测试阶段-Testing"><a href="#3-4-测试阶段-Testing" class="headerlink" title="3.4 测试阶段 (Testing)"></a>3.4 测试阶段 (Testing)</h3><p>在应用程序的功能和性能测试之外，进行全面的安全测试，以发现动态运行时出现的漏洞。</p>
<ul>
<li><strong>动态应用安全测试 (DAST)</strong>：<ul>
<li><strong>工具</strong>：OWASP ZAP, Burp Suite Pro, Acunetix, Nessus 等。</li>
<li><strong>方法</strong>：模拟攻击者的行为，对运行中的应用程序进行扫描和探测，发现配置错误、认证缺陷、会话管理问题、XSS、CSRF、SQL注入等漏洞。</li>
</ul>
</li>
<li><strong>交互式应用安全测试 (IAST)</strong>：<ul>
<li><strong>工具</strong>：Contrast Security, Synopsys Seeker 等。</li>
<li><strong>方法</strong>：结合 SAST 和 DAST 的优势，在应用程序运行时进行深入分析，实时监控代码执行路径，发现漏洞并提供高精度的漏洞信息。</li>
</ul>
</li>
<li><strong>渗透测试 (Penetration Testing)</strong>：<ul>
<li>由专业渗透测试人员模拟真实攻击，手动发现自动化工具难以找到的业务逻辑漏洞、组合攻击路径或高级威胁。</li>
</ul>
</li>
<li><strong>模糊测试 (Fuzz Testing)</strong>：<ul>
<li><strong>工具</strong>：AFL,peach-fuzzer 等。</li>
<li>向应用程序的输入接口发送大量畸形、随机或意外的数据，观察系统响应，以发现潜在的崩溃、资源泄露或拒绝服务漏洞。</li>
</ul>
</li>
</ul>
<h3 id="3-5-部署阶段-Deployment"><a href="#3-5-部署阶段-Deployment" class="headerlink" title="3.5 部署阶段 (Deployment)"></a>3.5 部署阶段 (Deployment)</h3><p>在部署应用程序到生产环境之前，确保部署环境和配置本身是安全的。</p>
<ul>
<li><strong>安全配置与硬化</strong>：<ul>
<li>遵循最小权限原则配置服务器、操作系统、数据库和网络设备。</li>
<li>禁用不必要的服务和端口。</li>
<li>使用强化指南（如 CIS Benchmarks）来加固系统。</li>
</ul>
</li>
<li><strong>容器和基础设施安全扫描</strong>：<ul>
<li><strong>工具</strong>：Trivy, Clair, Aqua Security 等。</li>
<li>扫描容器镜像中的已知漏洞和错误配置。</li>
<li>IaC (Infrastructure as Code) 安全扫描（如 Terraform, Kubernetes Manifest）识别基础设施配置漏洞。</li>
</ul>
</li>
<li><strong>自动化部署安全检查</strong>：<ul>
<li>在 CI&#x2F;CD 管道中包含部署前检查，验证配置是否符合安全基线。</li>
</ul>
</li>
</ul>
<h3 id="3-6-维护与监控阶段-Maintenance-Monitoring"><a href="#3-6-维护与监控阶段-Maintenance-Monitoring" class="headerlink" title="3.6 维护与监控阶段 (Maintenance &amp; Monitoring)"></a>3.6 维护与监控阶段 (Maintenance &amp; Monitoring)</h3><p>安全工作并不会随着部署而结束，而是需要持续的监控、响应和改进。</p>
<ul>
<li><strong>持续监控与日志审计</strong>：<ul>
<li>部署安全信息和事件管理 (SIEM) 系统，集中收集和分析日志，实时监控异常行为和潜在攻击。</li>
<li>实施应用程序性能监控 (APM) 工具，关注与安全相关的指标。</li>
</ul>
</li>
<li><strong>漏洞管理</strong>：<ul>
<li>建立漏洞报告和响应流程，及时处理新发现的漏洞（包括自发现和外部报告的）。</li>
<li>定期进行漏洞扫描和安全评估。</li>
</ul>
</li>
<li><strong>应急响应与事件管理</strong>：<ul>
<li>制定和演练应急响应计划，以便在安全事件发生时能够快速、有效地进行响应、恢复和事后分析。</li>
</ul>
</li>
<li><strong>安全补丁管理</strong>：<ul>
<li>及时应用操作系统、库、框架和依赖项的安全补丁。</li>
</ul>
</li>
<li><strong>反馈与改进</strong>：<ul>
<li>从安全事件、漏洞发现和安全审计中吸取经验教训，反馈到 SDLC 的早期阶段，持续改进安全流程和实践。</li>
</ul>
</li>
</ul>
<h2 id="四、SSDLC-的关键推动者和工具"><a href="#四、SSDLC-的关键推动者和工具" class="headerlink" title="四、SSDLC 的关键推动者和工具"></a>四、SSDLC 的关键推动者和工具</h2><p>为了高效实施 SSDLC，需要一系列工具和实践来支持：</p>
<ul>
<li><strong>威胁情报</strong>：了解最新的攻击技术和漏洞趋势。</li>
<li><strong>安全编码培训</strong>：提升开发人员的安全意识和编码技能。</li>
<li><strong>SAST (静态应用安全测试)</strong>：Checkmarx, Fortify, SonarQube, Bandit, gosec 等。</li>
<li><strong>SCA (软件成分分析)</strong>：Trivy, Snyk, Black Duck, OWASP Dependency-Check 等。</li>
<li><strong>DAST (动态应用安全测试)</strong>：OWASP ZAP, Burp Suite, Acunetix 等。</li>
<li><strong>IAST (交互式应用安全测试)</strong>：Contrast Security, Synopsys Seeker 等。</li>
<li><strong>容器安全扫描</strong>：Trivy, Clair, Anchore Engine 等。</li>
<li><strong>IaC 安全扫描</strong>：Terrascan, Checkov, Kube-bench 等。</li>
<li><strong>秘密管理工具</strong>：HashiCorp Vault, AWS Secrets Manager, Azure Key Vault 等。</li>
<li><strong>安全信息与事件管理 (SIEM)</strong>：Splunk, ELK Stack, Azure Sentinel 等。</li>
<li><strong>Bug Tracking &#x2F; Issue Management</strong>：Jira, GitLab Issues 等，用于跟踪和管理安全漏洞。</li>
</ul>
<h2 id="五、实施-SSDLC-的益处"><a href="#五、实施-SSDLC-的益处" class="headerlink" title="五、实施 SSDLC 的益处"></a>五、实施 SSDLC 的益处</h2><ul>
<li><strong>降低漏洞修复成本</strong>：越早发现漏洞，修复成本越低。</li>
<li><strong>提高软件质量和可靠性</strong>：减少安全缺陷，提升应用程序的整体健壮性。</li>
<li><strong>加速交付周期</strong>：通过自动化安全检查减少后期返工，提升开发效率。</li>
<li><strong>增强合规性</strong>：帮助组织满足各种行业标准和法规要求。</li>
<li><strong>提升品牌声誉</strong>：更安全的软件可以赢得客户信任，避免因安全事件造成的负面影响。</li>
<li><strong>建立安全文化</strong>：将安全意识融入团队日常工作，培养全员安全责任感。</li>
</ul>
<h2 id="六、实施-SSDLC-面临的挑战"><a href="#六、实施-SSDLC-面临的挑战" class="headerlink" title="六、实施 SSDLC 面临的挑战"></a>六、实施 SSDLC 面临的挑战</h2><ol>
<li><strong>初始投资大</strong>：引入新的工具、流程和培训需要前期投入。</li>
<li><strong>观念转变困难</strong>：开发者可能对新的安全工作流感到不适应，需要时间适应。</li>
<li><strong>误报处理</strong>：自动化工具可能产生大量误报，需要投入时间进行筛选和验证。</li>
<li><strong>专业技能缺乏</strong>：团队可能缺乏专业的安全技能，需要外部支持或内部培训。</li>
<li><strong>集成复杂性</strong>：将安全工具无缝集成到现有CI&#x2F;CD管道可能很复杂。</li>
<li><strong>文化阻力</strong>：改变团队根深蒂固的工作习惯，推行安全为先的文化需要耐心和领导力。</li>
</ol>
<h2 id="七、SSDLC-最佳实践"><a href="#七、SSDLC-最佳实践" class="headerlink" title="七、SSDLC 最佳实践"></a>七、SSDLC 最佳实践</h2><ol>
<li><strong>高层支持</strong>：确保管理层对 SSDLC 的推行有清晰的认识和坚定不移的支持。</li>
<li><strong>渐进式实施</strong>：不要试图一次性引入所有安全实践，可以从小范围或关键项目开始，逐步推广。</li>
<li><strong>自动化优先</strong>：尽可能自动化安全测试，减少手动干预，提高效率。</li>
<li><strong>培训与赋能</strong>：定期对开发、测试和运维人员进行安全培训，提升他们的安全技能和意识。</li>
<li><strong>建立安全冠军</strong>：在团队中培养安全专家或“安全冠军”，作为安全知识的传播者和实践者。</li>
<li><strong>明确安全职责</strong>：确保每个角色在 SDLC 各阶段的安全职责清晰明确。</li>
<li><strong>选择合适的工具</strong>：根据项目语言、技术栈和团队规模，选择最适合的 SAST、DAST、SCA 等工具。</li>
<li><strong>持续反馈和改进</strong>：通过定期的安全审查、漏洞分析和事后总结，不断优化 SSDLC 流程。</li>
<li><strong>衡量和报告</strong>：定义关键安全指标，定期报告安全态势和 SSDLC 成效，增强团队的投入感。</li>
</ol>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>SSDLC 是构建安全软件的基石，它将安全性从一个额外负担转变为软件开发的核心组成部分。通过将安全实践集成到 SDLC 的每个阶段，从需求分析到部署和维护，组织能够系统地预防、发现和修复漏洞，从而交付更安全、更可靠的应用程序。在当前复杂的网络安全环境中，采用 SSDLC 不仅是最佳实践，更是企业保护自身资产、用户数据和品牌声誉的必然选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/c58da3f1e952/">https://blog.tbf1211.xx.kg/c58da3f1e952/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-03.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/eb8d4a4bab0b/" title="TresJS详解：用Vue的方式构建Three.js场景"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TresJS详解：用Vue的方式构建Three.js场景</div></div><div class="info-2"><div class="info-item-1"> TresJS 是一个基于 Vue.js 和 Three.js 的声明式 3D 渲染框架。它允许开发者像编写 Vue 组件一样，通过声明式的方式构建复杂的 Three.js 场景，从而大大降低 Three.js 的学习曲线和开发复杂度，特别适合 Vue 开发者快速进入 3D 领域。  核心思想：将 Three.js 对象抽象为 Vue 组件，用 Vue 的响应式和组件化思维管理 3D 场景。   一、什么是 TresJS？Three.js 是一个强大的 JavaScript 3D 库，用于在浏览器中创建和渲染 3D 图形。然而，直接使用 Three.js API 需要编写大量的命令式（或说是“指令式”）代码来创建几何体、材质、网格、灯光、摄像机、场景以及设置渲染循环等。这对于不熟悉 3D 图形编程的开发者来说，上手较难，且代码维护复杂。 TresJS 的出现就是为了解决这个问题。它提供了一套 Vue 组件，每个组件都对应 Three.js 中的一个核心概念（如 &lt;TresCanvas&gt;, &lt;TresMesh&gt;, &lt;TresPerspectiveCam...</div></div></div></a><a class="pagination-related" href="/b10b8bccf756/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go语言指向指针的指针(Pointer to Pointer)详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，指针是一种重要的概念，它存储了一个变量的内存地址。我们通常通过 * 运算符来解引用指针，获取指针指向的值。但 Go 语言还支持更复杂的指针类型，例如指向指针的指针 (Pointer to Pointer)，也称为二级指针 (Double Pointer)。虽然在日常开发中不常用，但理解其工作原理对于深入理解内存管理、某些高级数据结构（如链表、树的修改操作）或在特定场景下修改指针本身的值至关重要。  核心概念：一个指针变量存储一个普通变量的地址，而指向指针的指针存储一个指针变量的地址。   一、基本指针回顾在深入指向指针的指针之前，我们先快速回顾一下 Go 语言中的基本指针：  定义指针：使用 * 符号和类型名来声明一个指针变量，例如 *int 表示一个指向 int 类型的指针。 获取地址：使用 &amp; 运算符来获取一个变量的内存地址。 解引用：使用 * 运算符来访问指针指向的内存中的值。  示例： 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/7420d7912dc7/" title="CSS 注入 (CSS Injection) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-31</div><div class="info-item-2">CSS 注入 (CSS Injection) 详解</div></div><div class="info-2"><div class="info-item-1"> CSS 注入 (CSS Injection) 是一种客户端攻击技术，攻击者通过在网页中注入恶意的 Cascading Style Sheets (CSS) 代码，从而实现对页面样式、布局的篡改，甚至是窃取用户信息、进行用户行为监控、绕过某些安全机制等目的。它与常见的 XSS (Cross-Site Scripting) 攻击有所不同，CSS 注入本身不会直接执行 JavaScript 代码，但其危害不容小觑。  CSS 注入通常发生在 Web 应用程序未能正确净化或编码用户提供的输入，并将其不加识别地插入到 HTML &lt;style&gt; 标签、HTML 元素的 style 属性或外部 CSS 文件链接中时。它的强大之处在于能够利用 CSS 选择器和属性的特性，实现一些意想不到的攻击效果。   一、CSS 注入的产生机制CSS 注入的核心在于攻击者能够控制页面中 CSS 的一部分或全部。这通常发生在以下几种情况：  用户输入直接插入 &lt;style&gt; 标签内部：当应用程序允许用户输入的数据直接被渲染到 HTML 页面中的 &lt;style&gt; 标签内部时，...</div></div></div></a><a class="pagination-related" href="/1046db413419/" title="Reverse TCP Shell 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-07</div><div class="info-item-2">Reverse TCP Shell 详解</div></div><div class="info-2"><div class="info-item-1"> Reverse TCP Shell (反向 TCP Shell) 是一种在渗透测试和恶意软件领域中广泛使用的技术，它允许攻击者在受害机器上获得一个交互式命令行会话。与传统的正向连接 Shell (Bind Shell) 不同，反向 Shell 的连接方向是从受害机器到攻击机器，这使得它在穿越防火墙和 NAT 设备方面具有显著优势。  核心思想：攻击者在其机器上设置一个监听器，等待受害机器主动发起连接，从而绕过目标网络对入站连接的限制。   一、Shell 简介在计算机系统中，Shell (命令行解释器) 是用户与操作系统内核进行交互的接口。通过 Shell，用户可以输入命令来执行程序、管理文件和系统资源等。 在渗透测试中，获取目标系统的 Shell 权限是至关重要的一步，它意味着攻击者可以在目标机器上执行任意命令。 1.1 Shell 的分类 命令行 Shell (Command Shell)：  提供基本的命令行交互界面，如 Windows 的 cmd.exe 或 PowerShell，Linux 的 bash 或 sh。 功能相对简单，通常需要手动输入命令。   高级 Sh...</div></div></div></a><a class="pagination-related" href="/1c9fa79b93e5/" title="Msfvenom 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="info-item-2">Msfvenom 详解</div></div><div class="info-2"><div class="info-item-1"> Msfvenom 是 Metasploit 框架中的一个强大而独立的命令行工具，它结合了 msfpayload（载荷生成器）和 msfencode（编码器）的功能，旨在生成各种格式的恶意载荷（Payload）并对其进行编码，以规避安全检测。它是渗透测试人员和红队成员创建自定义后门和绕过防御机制的利器。  核心思想：将攻击载荷（Shellcode）和输出格式（如 EXE、ELF、ASPX 等）分离，允许用户自由组合并按需编码，生成高度定制化的恶意文件。   一、Msfvenom 简介1.1 什么是 Msfvenom？msfvenom 是一个命令行工具，属于 Metasploit Framework 的一部分。它的主要功能是：  载荷生成 (Payload Generation)：创建各种操作系统（Windows, Linux, macOS, Android 等）和架构（x86, x64 等）的恶意载荷。 编码 (Encoding)：对生成的载荷进行编码，以尝试绕过杀毒软件的签名检测或处理特殊字符（如 NUL \x00）。 格式化 (Formatting)：将生成的载荷输出为多种文...</div></div></div></a><a class="pagination-related" href="/08a7bab723f9/" title="Metasploit exploit&#x2F;multi&#x2F;handler 模块详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-14</div><div class="info-item-2">Metasploit exploit&#x2F;multi&#x2F;handler 模块详解</div></div><div class="info-2"><div class="info-item-1"> exploit/multi/handler 是 Metasploit 框架中一个极其重要且应用广泛的模块。它本身并不是一个漏洞利用模块，而是一个通用的监听器（Listener），用于接收由 Metasploit 或 msfvenom 生成的各种 Payload 发起的反向连接（Reverse Shell）。它提供了一个灵活且强大的平台，用于管理渗透测试过程中获取的 Shell 会话，特别是 Meterpreter 会话。  核心思想：提供一个通用的、模块化的监听接口，等待远程目标系统主动连接，从而建立一个控制通道。它与用于生成Payload的msfvenom紧密配合，实现无缝的端到端攻击链。   一、exploit/multi/handler 简介1.1 什么是 exploit/multi/handler？exploit/multi/handler 是 Metasploit 中的一个混合型模块 (Auxiliary&#x2F;Exploit)。它被归类为 exploit，因为它最终目的是“利用”系统并获得 Shell，但它实际上不包含任何漏洞利用代码。它的主要功能是：  监听反...</div></div></div></a><a class="pagination-related" href="/309197e65213/" title="DOM Clobbering 漏洞详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-07</div><div class="info-item-2">DOM Clobbering 漏洞详解</div></div><div class="info-2"><div class="info-item-1"> DOM Clobbering (DOM 覆盖) 是一种特殊的 Web 安全漏洞，它允许攻击者通过可控的 HTML 片段，意外地覆盖（”clobber”）或修改网页中的全局 JavaScript 变量、对象或属性。这种攻击方式利用了浏览器对带有 id 或 name 属性的 HTML 元素在全局 window 对象上创建引用或在 document 对象上创建属性的机制，从而篡改前端脚本的执行逻辑，最终可能导致 XSS (Cross-Site Scripting) 或其他客户端逻辑问题。  核心思想：通过注入特定的 HTML 元素（通常带有 id 或 name 属性），欺骗浏览器，使其将这些 HTML 元素作为 JavaScript 代码中预期的全局变量或对象属性来处理，从而导致类型混淆或值替换。   一、为什么会存在 DOM Clobbering？DOM Clobbering 漏洞的根源在于浏览器的一些遗留特性 (Legacy Features) 和 JavaScript 的设计原则：  全局命名空间污染：浏览器为了方便，将具有 id 属性的 HTML 元素自动作为 window ...</div></div></div></a><a class="pagination-related" href="/340c8b6e7b0a/" title="SAST (Static Application Security Testing) 工具详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-30</div><div class="info-item-2">SAST (Static Application Security Testing) 工具详解</div></div><div class="info-2"><div class="info-item-1"> SAST (Static Application Security Testing，静态应用安全测试) 是一种白盒 (White-box) 安全测试方法，它通过不执行代码的方式，对应用程序的源代码、字节码或二进制代码进行分析，以识别潜在的安全漏洞和缺陷。SAST 工具旨在开发生命周期 (SDLC) 的早期阶段（“左移”）发现问题，使得开发者可以在发布前修复这些漏洞。  SAST 工具通过深入分析代码逻辑、数据流和控制流，识别出可能导致安全问题的编码模式、配置错误或不安全的API使用。它是 DevSecOps 实践中不可或缺的一部分，能够帮助团队在开发早期以自动化方式持续保障软件质量和安全性。   一、为什么需要 SAST？在现代软件开发流程中，应用程序的复杂性不断增加，发布周期日益缩短。传统的后期安全测试（例如渗透测试）往往在开发周期的末尾进行，此时发现的漏洞修复成本高昂，且可能延误发布。SAST 旨在解决以下问题：  “左移”安全 (Shift-Left Security)：在编码阶段就发现并修复漏洞，避免其进入后续开发阶段，从而降低修复成本和时间。 早期漏洞检测：在不运行代...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">518</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-SSDLC%EF%BC%9F"><span class="toc-text">一、为什么需要 SSDLC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SSDLC-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-text">二、SSDLC 的核心原则和目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SSDLC-%E7%9A%84%E4%B8%BB%E8%A6%81%E9%98%B6%E6%AE%B5%E5%8F%8A%E5%AE%89%E5%85%A8%E6%B4%BB%E5%8A%A8"><span class="toc-text">三、SSDLC 的主要阶段及安全活动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%84%E5%88%92-Requirements-Planning"><span class="toc-text">3.1 需求分析与规划 (Requirements &amp; Planning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5-Design"><span class="toc-text">3.2 设计阶段 (Design)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E7%A0%81%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%B6%E6%AE%B5-Implementation-Coding"><span class="toc-text">3.3 编码与实现阶段 (Implementation &amp; Coding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5-Testing"><span class="toc-text">3.4 测试阶段 (Testing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%83%A8%E7%BD%B2%E9%98%B6%E6%AE%B5-Deployment"><span class="toc-text">3.5 部署阶段 (Deployment)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E7%BB%B4%E6%8A%A4%E4%B8%8E%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B5-Maintenance-Monitoring"><span class="toc-text">3.6 维护与监控阶段 (Maintenance &amp; Monitoring)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SSDLC-%E7%9A%84%E5%85%B3%E9%94%AE%E6%8E%A8%E5%8A%A8%E8%80%85%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">四、SSDLC 的关键推动者和工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E6%96%BD-SSDLC-%E7%9A%84%E7%9B%8A%E5%A4%84"><span class="toc-text">五、实施 SSDLC 的益处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%9E%E6%96%BD-SSDLC-%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">六、实施 SSDLC 面临的挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81SSDLC-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">七、SSDLC 最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Trivy (通用安全扫描器) 详解"/></a><div class="content"><a class="title" href="/d863aad4b106/" title="Trivy (通用安全扫描器) 详解">Trivy (通用安全扫描器) 详解</a><time datetime="2026-01-10T22:24:00.000Z" title="发表于 2026-01-11 06:24:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-03.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>