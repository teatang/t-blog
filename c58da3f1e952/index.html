<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSDLC (安全软件开发生命周期) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SSDLC (Secure Software Development Life Cycle，安全软件开发生命周期) 是一种将安全实践和活动集成到整个软件开发生命周期 (SDLC) 各个阶段的方法。它旨在从项目启动到软件部署和维护的每一个环节，系统地识别、缓解和消除软件漏洞，确保构建出本质上更安全的应用程序。  传统的软件开发往往将安全性视为一个后期添加的特性或“事后”的活动，导致在开发后期才发现">
<meta property="og:type" content="article">
<meta property="og:title" content="SSDLC (安全软件开发生命周期) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/c58da3f1e952/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="SSDLC (Secure Software Development Life Cycle，安全软件开发生命周期) 是一种将安全实践和活动集成到整个软件开发生命周期 (SDLC) 各个阶段的方法。它旨在从项目启动到软件部署和维护的每一个环节，系统地识别、缓解和消除软件漏洞，确保构建出本质上更安全的应用程序。  传统的软件开发往往将安全性视为一个后期添加的特性或“事后”的活动，导致在开发后期才发现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg">
<meta property="article:published_time" content="2025-10-02T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-28T09:11:10.485Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络安全">
<meta property="article:tag" content="2025">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SSDLC (安全软件开发生命周期) 详解",
  "url": "https://blog.tbf1211.xx.kg/c58da3f1e952/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-16.jpg",
  "datePublished": "2025-10-02T22:24:00.000Z",
  "dateModified": "2026-01-28T09:11:10.485Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/c58da3f1e952/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSDLC (安全软件开发生命周期) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">527</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-16.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">SSDLC (安全软件开发生命周期) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">SSDLC (安全软件开发生命周期) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-10-02T22:24:00.000Z" title="发表于 2025-10-03 06:24:00">2025-10-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>SSDLC (Secure Software Development Life Cycle，安全软件开发生命周期)</strong> 是一种将安全实践和活动集成到整个软件开发生命周期 (SDLC) 各个阶段的方法。它旨在从项目启动到软件部署和维护的每一个环节，系统地识别、缓解和消除软件漏洞，确保构建出本质上更安全的应用程序。</p>
</blockquote>
<div class="note info flat"><p>传统的软件开发往往将安全性视为一个后期添加的特性或“事后”的活动，导致在开发后期才发现大量安全缺陷，修复成本高昂，甚至可能导致项目延期。SSDLC 强调“<strong>安全左移 (Shift-Left Security)</strong>”理念，这意味着安全工作应尽早开始，贯穿整个开发过程，而不是仅在代码编写完成后进行安全测试。</p>
</div>
<hr>
<h2 id="一、为什么需要-SSDLC？"><a href="#一、为什么需要-SSDLC？" class="headerlink" title="一、为什么需要 SSDLC？"></a>一、为什么需要 SSDLC？</h2><p>在数字化转型的浪潮中，软件已成为业务的核心驱动力，但随之而来的安全风险也日益凸显。传统 SDLC 面临以下安全挑战：</p>
<ol>
<li><strong>后期发现的漏洞成本高昂</strong>：在生产环境中发现的漏洞，其修复成本可能是设计阶段发现的几十甚至上百倍。这包括重新编码、测试、部署，甚至可能面临经济损失和品牌损害。</li>
<li><strong>快速迭代下的安全风险累积</strong>：DevOps 和敏捷开发模式强调快速交付，如果安全没有融入流程，可能会为了速度牺牲安全，导致安全债务累积。</li>
<li><strong>合规性要求日益严格</strong>：GDPR、PCI DSS、HIPAA 等法规对数据保护和软件安全提出了更高要求，不符合规范可能面临巨额罚款。</li>
<li><strong>供应链攻击风险</strong>：广泛使用的第三方库、开源组件及其依赖项可能引入已知漏洞，需要贯穿整个生命周期的安全管理。</li>
<li><strong>0-Day 和高级持续性威胁 (APT)</strong>：攻击者持续寻找新的漏洞，要求软件具备更强的韧性。</li>
<li><strong>安全成为业务风险</strong>：数据泄露、服务中断不仅是技术问题，更是直接影响企业声誉和生存的业务风险。</li>
</ol>
<p>SSDLC 通过将安全考量融入每个阶段，从根本上解决这些问题，确保软件从设计之初就具备安全性，而不是后期打补丁。</p>
<h2 id="二、SSDLC-的核心原则和目标"><a href="#二、SSDLC-的核心原则和目标" class="headerlink" title="二、SSDLC 的核心原则和目标"></a>二、SSDLC 的核心原则和目标</h2><p>SSDLC 的核心在于转变安全思维，将安全性内建于软件，而非外加。其主要原则和目标包括：</p>
<ol>
<li><strong>安全左移 (Shift Left)</strong>：将安全活动尽可能地提前到 SDLC 的早期阶段（需求、设计），预防性地解决问题。</li>
<li><strong>安全是贯穿始终的责任</strong>：强调所有参与者（开发者、测试人员、架构师、运维人员）都有责任保障软件安全。</li>
<li><strong>自动化优先</strong>：尽可能地自动化安全测试和检查，减少人工干预，提高效率和一致性。</li>
<li><strong>可衡量性</strong>：定义清晰的安全指标和目标，持续监控和改进安全态势。</li>
<li><strong>持续改进</strong>：通过漏洞分析、回顾和经验教训的积累，不断优化安全流程和实践。</li>
<li><strong>最小权限原则 (Principle of Least Privilege)</strong>：在设计和实现中，确保模块、服务和用户仅拥有完成其功能所需的最小权限。</li>
<li><strong>深度防御 (Defense in Depth)</strong>：采用多层安全控制，即使某一层被突破，其他层也能提供保护。</li>
<li><strong>故障安全 (Fail Securely)</strong>：当系统发生故障时，应默认进入最安全的状态，而不是暴露潜在风险。</li>
</ol>
<h2 id="三、SSDLC-的主要阶段及安全活动"><a href="#三、SSDLC-的主要阶段及安全活动" class="headerlink" title="三、SSDLC 的主要阶段及安全活动"></a>三、SSDLC 的主要阶段及安全活动</h2><p>SSDLC 将安全活动融入传统 SDLC 的各个阶段。一个典型的 SSDLC 流程图如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[需求分析] --&gt; B[安全需求识别 &amp; 威胁建模];
    B --&gt; C[设计阶段];
    C --&gt; D[安全架构设计 &amp; 安全设计审查];
    D --&gt; E[编码阶段];
    E --&gt; F[安全编码规范 &amp; SAST &amp; 秘钥管理];
    F --&gt; G[测试阶段];
    G --&gt; H[DAST &amp; IAST &amp; 渗透测试 &amp; Fuzz测试];
    H --&gt; I[部署阶段];
    I --&gt; J[安全配置 &amp; 硬化 &amp; 漏洞扫描];
    J --&gt; K[维护与监控];
    K --&gt; L[日志审计 &amp; 漏洞管理 &amp; 应急响应 &amp; 持续监控];
    L --&gt; B;
  </pre></div>

<h3 id="3-1-需求分析与规划-Requirements-Planning"><a href="#3-1-需求分析与规划-Requirements-Planning" class="headerlink" title="3.1 需求分析与规划 (Requirements &amp; Planning)"></a>3.1 需求分析与规划 (Requirements &amp; Planning)</h3><p>在项目启动之初，安全团队与业务团队、开发团队协作，明确安全目标和非功能性安全需求。</p>
<ul>
<li><p><strong>安全需求收集</strong>：</p>
<ul>
<li>识别所有与安全性相关的业务和用户需求（如认证、授权、数据隐私、日志审计、可用性）。</li>
<li>参照行业标准（如 OWASP ASVS）或公司内部安全策略定义安全要求。</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 系统必须能够抵御 OWASP Top 10 中列出的所有漏洞。</span><br><span class="line">- 所有用户敏感数据必须进行端到端加密存储。</span><br><span class="line">- 用户的认证机制必须符合 FIPS 140-2 标准。</span><br><span class="line">- 所有访问尝试（成功或失败）都必须记录日志。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>威胁建模 (Threat Modeling) 启动</strong>：</p>
<ul>
<li>初步识别可能存在的威胁和攻击面。</li>
<li>通过工具 (如 Microsoft Threat Modeling Tool) 或框架 (如 STRIDE) 开始分析。</li>
<li>确定资产、威胁来源和潜在漏洞。</li>
</ul>
</li>
<li><p><strong>风险评估</strong>：</p>
<ul>
<li>评估潜在威胁对业务的影响和发生的可能性。</li>
<li>根据评估结果确定安全工作的优先级。</li>
</ul>
</li>
</ul>
<h3 id="3-2-设计阶段-Design"><a href="#3-2-设计阶段-Design" class="headerlink" title="3.2 设计阶段 (Design)"></a>3.2 设计阶段 (Design)</h3><p>将安全需求转化为具体的设计方案，确保安全机制从架构层面就得到支持。</p>
<ul>
<li><strong>详细威胁建模 (Deep Threat Modeling)</strong>：<ul>
<li>深入分析系统架构、组件交互和数据流，识别潜在的攻击路径。</li>
<li>应用 STRIDE (Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege) 或 DREAD 等模型评估威胁。</li>
<li><strong>示例</strong>：针对一个微服务架构，分析服务间的认证鉴权机制、API 网关的安全策略、数据库访问控制等。</li>
</ul>
</li>
<li><strong>安全架构设计</strong>：<ul>
<li>采用安全设计模式和原则（如最小权限、纵深防御、故障安全）。</li>
<li>设计身份和访问管理 (IAM)、数据加密、安全通信协议、日志和审计机制、输入验证等。</li>
</ul>
</li>
<li><strong>安全设计审查 (Security Design Review)</strong>：<ul>
<li>由安全专家评审架构设计和详细设计文档，发现潜在的设计缺陷和安全漏洞。</li>
<li>确保安全控制与威胁缓解措施的有效性。</li>
</ul>
</li>
</ul>
<h3 id="3-3-编码与实现阶段-Implementation-Coding"><a href="#3-3-编码与实现阶段-Implementation-Coding" class="headerlink" title="3.3 编码与实现阶段 (Implementation &amp; Coding)"></a>3.3 编码与实现阶段 (Implementation &amp; Coding)</h3><p>开发者编写代码时，需遵循安全编码规范，并利用自动化工具进行初步的安全检查。</p>
<ul>
<li><strong>安全编码规范</strong>：<ul>
<li>遵循安全编码最佳实践（如 OWASP Secure Coding Practices Quick Reference Guide）。</li>
<li>对输入数据进行严格验证和净化，防止注入攻击。</li>
<li>避免硬编码敏感信息。</li>
<li>使用安全的API和库。</li>
</ul>
</li>
<li><strong>静态应用安全测试 (SAST)</strong>：<ul>
<li><strong>工具</strong>：Synopsys Coverity, Checkmarx, Fortify, SonarQube, Bandit (Python), gosec (Go) 等。</li>
<li><strong>集成</strong>：将 SAST 工具集成到开发者的 IDE 和 CI&#x2F;CD 管道中，对源代码、字节码或二进制代码进行分析，识别漏洞。</li>
<li><strong>示例 (CI&#x2F;CD 阶段运行 SAST)</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml 或 .github/workflows/main.yml</span></span><br><span class="line"><span class="attr">sast_scan:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">docker/tool_image_with_sast_scanner</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;Running SAST scan...&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/path/to/sast_scanner</span> <span class="string">--source-dir=.</span> <span class="string">--output-format=json</span> <span class="string">&gt;</span> <span class="string">sast_report.json</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span> <span class="string">sast_report.json</span> <span class="comment"># 打印报告</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">if</span> [ <span class="string">$(jq</span> <span class="string">&#x27;.vulnerabilities | length&#x27;</span> <span class="string">sast_report.json)</span> <span class="string">-gt</span> <span class="number">0</span> ]<span class="string">;</span> <span class="string">then</span> <span class="string">exit</span> <span class="number">1</span><span class="string">;</span> <span class="string">fi</span> <span class="comment"># 如果发现漏洞则失败</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sast_report.json</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>软件成分分析 (SCA)</strong>：<ul>
<li><strong>工具</strong>：Trivy, Snyk, WhiteSource, OWASP Dependency-Check 等。</li>
<li>扫描项目中使用的第三方库、开源组件及其依赖，发现已知的安全漏洞。</li>
</ul>
</li>
<li><strong>秘密管理 (Secrets Management)</strong>：<ul>
<li>使用专门的工具（如 HashiCorp Vault, AWS Secrets Manager, Azure Key Vault）来存储和管理应用程序的敏感凭证，而不是硬编码在代码中。</li>
</ul>
</li>
</ul>
<h3 id="3-4-测试阶段-Testing"><a href="#3-4-测试阶段-Testing" class="headerlink" title="3.4 测试阶段 (Testing)"></a>3.4 测试阶段 (Testing)</h3><p>在应用程序的功能和性能测试之外，进行全面的安全测试，以发现动态运行时出现的漏洞。</p>
<ul>
<li><strong>动态应用安全测试 (DAST)</strong>：<ul>
<li><strong>工具</strong>：OWASP ZAP, Burp Suite Pro, Acunetix, Nessus 等。</li>
<li><strong>方法</strong>：模拟攻击者的行为，对运行中的应用程序进行扫描和探测，发现配置错误、认证缺陷、会话管理问题、XSS、CSRF、SQL注入等漏洞。</li>
</ul>
</li>
<li><strong>交互式应用安全测试 (IAST)</strong>：<ul>
<li><strong>工具</strong>：Contrast Security, Synopsys Seeker 等。</li>
<li><strong>方法</strong>：结合 SAST 和 DAST 的优势，在应用程序运行时进行深入分析，实时监控代码执行路径，发现漏洞并提供高精度的漏洞信息。</li>
</ul>
</li>
<li><strong>渗透测试 (Penetration Testing)</strong>：<ul>
<li>由专业渗透测试人员模拟真实攻击，手动发现自动化工具难以找到的业务逻辑漏洞、组合攻击路径或高级威胁。</li>
</ul>
</li>
<li><strong>模糊测试 (Fuzz Testing)</strong>：<ul>
<li><strong>工具</strong>：AFL,peach-fuzzer 等。</li>
<li>向应用程序的输入接口发送大量畸形、随机或意外的数据，观察系统响应，以发现潜在的崩溃、资源泄露或拒绝服务漏洞。</li>
</ul>
</li>
</ul>
<h3 id="3-5-部署阶段-Deployment"><a href="#3-5-部署阶段-Deployment" class="headerlink" title="3.5 部署阶段 (Deployment)"></a>3.5 部署阶段 (Deployment)</h3><p>在部署应用程序到生产环境之前，确保部署环境和配置本身是安全的。</p>
<ul>
<li><strong>安全配置与硬化</strong>：<ul>
<li>遵循最小权限原则配置服务器、操作系统、数据库和网络设备。</li>
<li>禁用不必要的服务和端口。</li>
<li>使用强化指南（如 CIS Benchmarks）来加固系统。</li>
</ul>
</li>
<li><strong>容器和基础设施安全扫描</strong>：<ul>
<li><strong>工具</strong>：Trivy, Clair, Aqua Security 等。</li>
<li>扫描容器镜像中的已知漏洞和错误配置。</li>
<li>IaC (Infrastructure as Code) 安全扫描（如 Terraform, Kubernetes Manifest）识别基础设施配置漏洞。</li>
</ul>
</li>
<li><strong>自动化部署安全检查</strong>：<ul>
<li>在 CI&#x2F;CD 管道中包含部署前检查，验证配置是否符合安全基线。</li>
</ul>
</li>
</ul>
<h3 id="3-6-维护与监控阶段-Maintenance-Monitoring"><a href="#3-6-维护与监控阶段-Maintenance-Monitoring" class="headerlink" title="3.6 维护与监控阶段 (Maintenance &amp; Monitoring)"></a>3.6 维护与监控阶段 (Maintenance &amp; Monitoring)</h3><p>安全工作并不会随着部署而结束，而是需要持续的监控、响应和改进。</p>
<ul>
<li><strong>持续监控与日志审计</strong>：<ul>
<li>部署安全信息和事件管理 (SIEM) 系统，集中收集和分析日志，实时监控异常行为和潜在攻击。</li>
<li>实施应用程序性能监控 (APM) 工具，关注与安全相关的指标。</li>
</ul>
</li>
<li><strong>漏洞管理</strong>：<ul>
<li>建立漏洞报告和响应流程，及时处理新发现的漏洞（包括自发现和外部报告的）。</li>
<li>定期进行漏洞扫描和安全评估。</li>
</ul>
</li>
<li><strong>应急响应与事件管理</strong>：<ul>
<li>制定和演练应急响应计划，以便在安全事件发生时能够快速、有效地进行响应、恢复和事后分析。</li>
</ul>
</li>
<li><strong>安全补丁管理</strong>：<ul>
<li>及时应用操作系统、库、框架和依赖项的安全补丁。</li>
</ul>
</li>
<li><strong>反馈与改进</strong>：<ul>
<li>从安全事件、漏洞发现和安全审计中吸取经验教训，反馈到 SDLC 的早期阶段，持续改进安全流程和实践。</li>
</ul>
</li>
</ul>
<h2 id="四、SSDLC-的关键推动者和工具"><a href="#四、SSDLC-的关键推动者和工具" class="headerlink" title="四、SSDLC 的关键推动者和工具"></a>四、SSDLC 的关键推动者和工具</h2><p>为了高效实施 SSDLC，需要一系列工具和实践来支持：</p>
<ul>
<li><strong>威胁情报</strong>：了解最新的攻击技术和漏洞趋势。</li>
<li><strong>安全编码培训</strong>：提升开发人员的安全意识和编码技能。</li>
<li><strong>SAST (静态应用安全测试)</strong>：Checkmarx, Fortify, SonarQube, Bandit, gosec 等。</li>
<li><strong>SCA (软件成分分析)</strong>：Trivy, Snyk, Black Duck, OWASP Dependency-Check 等。</li>
<li><strong>DAST (动态应用安全测试)</strong>：OWASP ZAP, Burp Suite, Acunetix 等。</li>
<li><strong>IAST (交互式应用安全测试)</strong>：Contrast Security, Synopsys Seeker 等。</li>
<li><strong>容器安全扫描</strong>：Trivy, Clair, Anchore Engine 等。</li>
<li><strong>IaC 安全扫描</strong>：Terrascan, Checkov, Kube-bench 等。</li>
<li><strong>秘密管理工具</strong>：HashiCorp Vault, AWS Secrets Manager, Azure Key Vault 等。</li>
<li><strong>安全信息与事件管理 (SIEM)</strong>：Splunk, ELK Stack, Azure Sentinel 等。</li>
<li><strong>Bug Tracking &#x2F; Issue Management</strong>：Jira, GitLab Issues 等，用于跟踪和管理安全漏洞。</li>
</ul>
<h2 id="五、实施-SSDLC-的益处"><a href="#五、实施-SSDLC-的益处" class="headerlink" title="五、实施 SSDLC 的益处"></a>五、实施 SSDLC 的益处</h2><ul>
<li><strong>降低漏洞修复成本</strong>：越早发现漏洞，修复成本越低。</li>
<li><strong>提高软件质量和可靠性</strong>：减少安全缺陷，提升应用程序的整体健壮性。</li>
<li><strong>加速交付周期</strong>：通过自动化安全检查减少后期返工，提升开发效率。</li>
<li><strong>增强合规性</strong>：帮助组织满足各种行业标准和法规要求。</li>
<li><strong>提升品牌声誉</strong>：更安全的软件可以赢得客户信任，避免因安全事件造成的负面影响。</li>
<li><strong>建立安全文化</strong>：将安全意识融入团队日常工作，培养全员安全责任感。</li>
</ul>
<h2 id="六、实施-SSDLC-面临的挑战"><a href="#六、实施-SSDLC-面临的挑战" class="headerlink" title="六、实施 SSDLC 面临的挑战"></a>六、实施 SSDLC 面临的挑战</h2><ol>
<li><strong>初始投资大</strong>：引入新的工具、流程和培训需要前期投入。</li>
<li><strong>观念转变困难</strong>：开发者可能对新的安全工作流感到不适应，需要时间适应。</li>
<li><strong>误报处理</strong>：自动化工具可能产生大量误报，需要投入时间进行筛选和验证。</li>
<li><strong>专业技能缺乏</strong>：团队可能缺乏专业的安全技能，需要外部支持或内部培训。</li>
<li><strong>集成复杂性</strong>：将安全工具无缝集成到现有CI&#x2F;CD管道可能很复杂。</li>
<li><strong>文化阻力</strong>：改变团队根深蒂固的工作习惯，推行安全为先的文化需要耐心和领导力。</li>
</ol>
<h2 id="七、SSDLC-最佳实践"><a href="#七、SSDLC-最佳实践" class="headerlink" title="七、SSDLC 最佳实践"></a>七、SSDLC 最佳实践</h2><ol>
<li><strong>高层支持</strong>：确保管理层对 SSDLC 的推行有清晰的认识和坚定不移的支持。</li>
<li><strong>渐进式实施</strong>：不要试图一次性引入所有安全实践，可以从小范围或关键项目开始，逐步推广。</li>
<li><strong>自动化优先</strong>：尽可能自动化安全测试，减少手动干预，提高效率。</li>
<li><strong>培训与赋能</strong>：定期对开发、测试和运维人员进行安全培训，提升他们的安全技能和意识。</li>
<li><strong>建立安全冠军</strong>：在团队中培养安全专家或“安全冠军”，作为安全知识的传播者和实践者。</li>
<li><strong>明确安全职责</strong>：确保每个角色在 SDLC 各阶段的安全职责清晰明确。</li>
<li><strong>选择合适的工具</strong>：根据项目语言、技术栈和团队规模，选择最适合的 SAST、DAST、SCA 等工具。</li>
<li><strong>持续反馈和改进</strong>：通过定期的安全审查、漏洞分析和事后总结，不断优化 SSDLC 流程。</li>
<li><strong>衡量和报告</strong>：定义关键安全指标，定期报告安全态势和 SSDLC 成效，增强团队的投入感。</li>
</ol>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>SSDLC 是构建安全软件的基石，它将安全性从一个额外负担转变为软件开发的核心组成部分。通过将安全实践集成到 SDLC 的每个阶段，从需求分析到部署和维护，组织能够系统地预防、发现和修复漏洞，从而交付更安全、更可靠的应用程序。在当前复杂的网络安全环境中，采用 SSDLC 不仅是最佳实践，更是企业保护自身资产、用户数据和品牌声誉的必然选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/c58da3f1e952/">https://blog.tbf1211.xx.kg/c58da3f1e952/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a><a class="post-meta__tags" href="/tags/2025/">2025</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-16.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/eb8d4a4bab0b/" title="TresJS详解：用Vue的方式构建Three.js场景"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TresJS详解：用Vue的方式构建Three.js场景</div></div><div class="info-2"><div class="info-item-1"> TresJS 是一个基于 Vue.js 和 Three.js 的声明式 3D 渲染框架。它允许开发者像编写 Vue 组件一样，通过声明式的方式构建复杂的 Three.js 场景，从而大大降低 Three.js 的学习曲线和开发复杂度，特别适合 Vue 开发者快速进入 3D 领域。  核心思想：将 Three.js 对象抽象为 Vue 组件，用 Vue 的响应式和组件化思维管理 3D 场景。   一、什么是 TresJS？Three.js 是一个强大的 JavaScript 3D 库，用于在浏览器中创建和渲染 3D 图形。然而，直接使用 Three.js API 需要编写大量的命令式（或说是“指令式”）代码来创建几何体、材质、网格、灯光、摄像机、场景以及设置渲染循环等。这对于不熟悉 3D 图形编程的开发者来说，上手较难，且代码维护复杂。 TresJS 的出现就是为了解决这个问题。它提供了一套 Vue 组件，每个组件都对应 Three.js 中的一个核心概念（如 &lt;TresCanvas&gt;, &lt;TresMesh&gt;, &lt;TresPerspectiveCam...</div></div></div></a><a class="pagination-related" href="/b10b8bccf756/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go语言指向指针的指针(Pointer to Pointer)详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，指针是一种重要的概念，它存储了一个变量的内存地址。我们通常通过 * 运算符来解引用指针，获取指针指向的值。但 Go 语言还支持更复杂的指针类型，例如指向指针的指针 (Pointer to Pointer)，也称为二级指针 (Double Pointer)。虽然在日常开发中不常用，但理解其工作原理对于深入理解内存管理、某些高级数据结构（如链表、树的修改操作）或在特定场景下修改指针本身的值至关重要。  核心概念：一个指针变量存储一个普通变量的地址，而指向指针的指针存储一个指针变量的地址。   一、基本指针回顾在深入指向指针的指针之前，我们先快速回顾一下 Go 语言中的基本指针：  定义指针：使用 * 符号和类型名来声明一个指针变量，例如 *int 表示一个指向 int 类型的指针。 获取地址：使用 &amp; 运算符来获取一个变量的内存地址。 解引用：使用 * 运算符来访问指针指向的内存中的值。  示例： 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/9f2624d10b42/" title="NoSQL 注入详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-07</div><div class="info-item-2">NoSQL 注入详解</div></div><div class="info-2"><div class="info-item-1"> NoSQL 注入 是一种Web安全漏洞，类似于传统的 SQL 注入，但它针对的是 NoSQL 数据库系统。当应用程序在构建 NoSQL 数据库查询时，未能正确地清洗或参数化来自用户输入的数据时，攻击者可以通过注入恶意构造的字符串或数据结构，来篡改查询的逻辑，从而绕过认证、获取未经授权的数据，甚至执行远程代码。  核心思想：利用 NoSQL 数据库查询语言的灵活性及其对数据类型（特别是 JSON 或类似 BSON 格式）的处理方式，将恶意数据作为查询逻辑的一部分注入，从而改变预期的查询行为。   一、为什么存在 NoSQL 注入？对传统 SQL 注入的继承与发展NoSQL 数据库因其高可伸缩性、灵活性和无模式（schema-less）特性而广受欢迎，但随着其普及，也带来了新的安全挑战。NoSQL 注入就是其中之一。 与 SQL 注入的共性：  输入验证不足：核心原因都是应用程序未能正确地验证、过滤或转义用户输入。 查询构建不当：攻击者能够操纵应用程序构建的数据库查询或命令。 信任用户输入：应用程序盲目信任并直接将用户输入拼接到查询中。  与 SQL 注入的区别：  查询语言不同：...</div></div></div></a><a class="pagination-related" href="/1c9fa79b93e5/" title="Msfvenom 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-26</div><div class="info-item-2">Msfvenom 详解</div></div><div class="info-2"><div class="info-item-1"> Msfvenom 是 Metasploit 框架中的一个强大而独立的命令行工具，它结合了 msfpayload（载荷生成器）和 msfencode（编码器）的功能，旨在生成各种格式的恶意载荷（Payload）并对其进行编码，以规避安全检测。它是渗透测试人员和红队成员创建自定义后门和绕过防御机制的利器。  核心思想：将攻击载荷（Shellcode）和输出格式（如 EXE、ELF、ASPX 等）分离，允许用户自由组合并按需编码，生成高度定制化的恶意文件。   一、Msfvenom 简介1.1 什么是 Msfvenom？msfvenom 是一个命令行工具，属于 Metasploit Framework 的一部分。它的主要功能是：  载荷生成 (Payload Generation)：创建各种操作系统（Windows, Linux, macOS, Android 等）和架构（x86, x64 等）的恶意载荷。 编码 (Encoding)：对生成的载荷进行编码，以尝试绕过杀毒软件的签名检测或处理特殊字符（如 NUL \x00）。 格式化 (Formatting)：将生成的载荷输出为多种文...</div></div></div></a><a class="pagination-related" href="/ac609e6566a8/" title="DAST (Dynamic Application Security Testing) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-02</div><div class="info-item-2">DAST (Dynamic Application Security Testing) 详解</div></div><div class="info-2"><div class="info-item-1"> DAST (Dynamic Application Security Testing)，中文译为动态应用程序安全测试，是一种黑盒安全测试方法。它通过模拟恶意攻击者的行为，在不接触应用程序源代码的情况下，对正在运行的应用程序（包括Web应用、API和服务）进行测试，以发现运行时存在的安全漏洞。 DAST 工具会向应用程序发送各种恶意输入和请求，然后分析应用程序的响应，以识别潜在的漏洞，例如 SQL 注入、跨站脚本 (XSS)、不安全的直接对象引用等。  核心思想：DAST 从外部视角模拟真实世界的攻击，测试应用程序在实际运行环境中的安全性。它关注的是应用程序在被部署和运行时可能暴露出的漏洞，而非代码本身的缺陷。   一、为什么需要 DAST？在软件开发生命周期 (SDLC) 中，确保应用程序安全至关重要。虽然静态应用程序安全测试 (SAST) 可以从代码层面发现漏洞，但 DAST 弥补了 SAST 的不足：  真实运行环境：DAST 在应用程序部署后运行，测试的是实际的配置、部署环境和第三方组件交互，能够发现只在运行时暴露的漏洞（例如，不正确的服务器配置、环境变量泄露、跨域资源共...</div></div></div></a><a class="pagination-related" href="/902d004f5ccc/" title="浏览器指纹 (Browser Fingerprinting) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">浏览器指纹 (Browser Fingerprinting) 详解</div></div><div class="info-2"><div class="info-item-1"> 浏览器指纹 (Browser Fingerprinting) 是一种用于识别或追踪用户在线行为的技术，即使在用户清除了 cookies、使用无痕模式甚至更换 IP 地址之后，它也能尝试标识出唯一的用户或设备。与 cookies 不同，浏览器指纹不是存储在用户设备上的数据，而是通过收集用户浏览器的各种配置和设置信息来生成的。  “你的浏览器就像你的手纹一样，看似普通，却独一无二。”   一、什么是浏览器指纹？浏览器指纹是指网站或在线服务通过收集用户浏览器和设备的大量可公开信息（如操作系统、浏览器类型和版本、屏幕分辨率、字体、插件、MIME 类型、时区、语言设置、GPU 信息、Canvas 渲染结果、AudioContext 信息等），并将这些信息综合起来生成一个近似唯一的“指纹”，从而在一定概率上识别单个用户或设备的技术。 这个“指纹”的强大之处在于其持久性和隐蔽性，用户很难通过常规手段进行清除或规避。 二、浏览器指纹的工作原理网站通过 JavaScript 或其他客户端脚本，在用户访问时执行一系列操作来获取其浏览器和设备特征。这些特征包括： 1. HTTP 请求头信息 (HTT...</div></div></div></a><a class="pagination-related" href="/29965d782f2a/" title="Metasploit 框架详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-18</div><div class="info-item-2">Metasploit 框架详解</div></div><div class="info-2"><div class="info-item-1"> Metasploit 框架 是一个广为人知且功能强大的开源渗透测试工具。它提供了一个全面的平台，用于开发、测试和执行漏洞利用（exploit）。无论是安全研究人员、渗透测试工程师还是红队成员，Metasploit 都是他们工具箱中不可或缺的一部分。  核心思想：将漏洞利用、载荷生成、后渗透模块等功能模块化，提供统一的接口和工具链，简化复杂的渗透测试流程。   一、Metasploit 简介1.1 什么是 Metasploit？Metasploit 是由 Rapid7 公司维护的一个著名的开源项目。它是一个漏洞利用框架，旨在协助渗透测试人员识别、利用和验证漏洞。它不仅仅是一个简单的漏洞扫描器，更是一个提供多种工具和方法的集成环境，几乎覆盖了渗透测试的整个生命周期。 1.2 Metasploit 的发展历史 2003年：由 H.D. Moore 发起，最初是一个 Perl 语言的项目。 2004年：发布 2.0 版本，首次引入了模块化架构。 2007年：框架被重写，使用 Ruby 语言，提高了灵活性和可维护性。 209年：Rapid7 收购 Metasploit 项目，并继续其开发...</div></div></div></a><a class="pagination-related" href="/ffc98223e029/" title="OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-02</div><div class="info-item-2">OAuth2.0 PKCE机制详解：提升公共客户端安全性的标准实践</div></div><div class="info-2"><div class="info-item-1"> OAuth 2.0 (Open Authorization 2.0) 是一种授权框架，允许第三方应用程序在不获取用户凭据的情况下访问用户在另一个服务商的受保护资源。然而，传统的 OAuth 2.0 授权码流在某些客户端类型（如公共客户端，Public Clients）中存在安全隐患。为了解决这些问题，PKCE（Proof Key for Code Exchange by OAuth Public Clients） 机制应运而生。  核心思想：PKCE 通过在授权码流中引入一个动态生成的密钥对，有效防止了授权码被恶意截取后被非法使用的风险，极大增强了公共客户端（如移动应用、单页应用）的安全性。    一、为什么需要 PKCE？公共客户端面临的挑战传统的 OAuth 2.0 授权码流 (Authorization Code Flow) 是最安全、最推荐的流程，它通过将授权码 (Authorization Code) 发送给客户端，然后客户端使用授权码和客户端秘钥 (Client Secret) 交换访问令牌 (Access Token)。 然而，这种传统的授权码流在用于公共客户端 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">527</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">229</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-SSDLC%EF%BC%9F"><span class="toc-text">一、为什么需要 SSDLC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SSDLC-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-text">二、SSDLC 的核心原则和目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SSDLC-%E7%9A%84%E4%B8%BB%E8%A6%81%E9%98%B6%E6%AE%B5%E5%8F%8A%E5%AE%89%E5%85%A8%E6%B4%BB%E5%8A%A8"><span class="toc-text">三、SSDLC 的主要阶段及安全活动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%84%E5%88%92-Requirements-Planning"><span class="toc-text">3.1 需求分析与规划 (Requirements &amp; Planning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5-Design"><span class="toc-text">3.2 设计阶段 (Design)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BC%96%E7%A0%81%E4%B8%8E%E5%AE%9E%E7%8E%B0%E9%98%B6%E6%AE%B5-Implementation-Coding"><span class="toc-text">3.3 编码与实现阶段 (Implementation &amp; Coding)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5-Testing"><span class="toc-text">3.4 测试阶段 (Testing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E9%83%A8%E7%BD%B2%E9%98%B6%E6%AE%B5-Deployment"><span class="toc-text">3.5 部署阶段 (Deployment)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E7%BB%B4%E6%8A%A4%E4%B8%8E%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B5-Maintenance-Monitoring"><span class="toc-text">3.6 维护与监控阶段 (Maintenance &amp; Monitoring)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SSDLC-%E7%9A%84%E5%85%B3%E9%94%AE%E6%8E%A8%E5%8A%A8%E8%80%85%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">四、SSDLC 的关键推动者和工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E6%96%BD-SSDLC-%E7%9A%84%E7%9B%8A%E5%A4%84"><span class="toc-text">五、实施 SSDLC 的益处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%9E%E6%96%BD-SSDLC-%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">六、实施 SSDLC 面临的挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81SSDLC-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">七、SSDLC 最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">八、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 核心对象：Commit, Tree, Blob 详解"/></a><div class="content"><a class="title" href="/0b52cb819619/" title="Git 核心对象：Commit, Tree, Blob 详解">Git 核心对象：Commit, Tree, Blob 详解</a><time datetime="2026-01-21T22:24:00.000Z" title="发表于 2026-01-22 06:24:00">2026-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1d2a942bda1e/" title="Terraform 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Terraform 详解"/></a><div class="content"><a class="title" href="/1d2a942bda1e/" title="Terraform 详解">Terraform 详解</a><time datetime="2026-01-19T22:24:00.000Z" title="发表于 2026-01-20 06:24:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/26cdb2447b3d/" title="WebView 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebView 详解"/></a><div class="content"><a class="title" href="/26cdb2447b3d/" title="WebView 详解">WebView 详解</a><time datetime="2026-01-17T22:24:00.000Z" title="发表于 2026-01-18 06:24:00">2026-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI 辅助编程的关键要点与代码幻觉防范"/></a><div class="content"><a class="title" href="/e62a1e8acade/" title="AI 辅助编程的关键要点与代码幻觉防范">AI 辅助编程的关键要点与代码幻觉防范</a><time datetime="2026-01-15T22:24:00.000Z" title="发表于 2026-01-16 06:24:00">2026-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-16.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>