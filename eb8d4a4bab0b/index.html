<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>TresJS详解：用Vue的方式构建Three.js场景 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TresJS 是一个基于 Vue.js 和 Three.js 的声明式 3D 渲染框架。它允许开发者像编写 Vue 组件一样，通过声明式的方式构建复杂的 Three.js 场景，从而大大降低 Three.js 的学习曲线和开发复杂度，特别适合 Vue 开发者快速进入 3D 领域。  核心思想：将 Three.js 对象抽象为 Vue 组件，用 Vue 的响应式和组件化思维管理 3D 场景。">
<meta property="og:type" content="article">
<meta property="og:title" content="TresJS详解：用Vue的方式构建Three.js场景">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/eb8d4a4bab0b/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="TresJS 是一个基于 Vue.js 和 Three.js 的声明式 3D 渲染框架。它允许开发者像编写 Vue 组件一样，通过声明式的方式构建复杂的 Three.js 场景，从而大大降低 Three.js 的学习曲线和开发复杂度，特别适合 Vue 开发者快速进入 3D 领域。  核心思想：将 Three.js 对象抽象为 Vue 组件，用 Vue 的响应式和组件化思维管理 3D 场景。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg">
<meta property="article:published_time" content="2025-10-05T22:24:00.000Z">
<meta property="article:modified_time" content="2025-12-29T14:27:26.324Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="前端技术">
<meta property="article:tag" content="Vue">
<meta property="article:tag" content="2025">
<meta property="article:tag" content="WebGL">
<meta property="article:tag" content="Three.js">
<meta property="article:tag" content="TresJS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TresJS详解：用Vue的方式构建Three.js场景",
  "url": "https://blog.tbf1211.xx.kg/eb8d4a4bab0b/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-22.jpg",
  "datePublished": "2025-10-05T22:24:00.000Z",
  "dateModified": "2025-12-29T14:27:26.324Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/eb8d4a4bab0b/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TresJS详解：用Vue的方式构建Three.js场景',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">443</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-22.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">TresJS详解：用Vue的方式构建Three.js场景</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">TresJS详解：用Vue的方式构建Three.js场景</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-10-05T22:24:00.000Z" title="发表于 2025-10-06 06:24:00">2025-10-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BA%93/">库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>TresJS</strong> 是一个基于 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://vuejs.org/">Vue.js</a> 和 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://threejs.org/">Three.js</a> 的声明式 3D 渲染框架。它允许开发者像编写 Vue 组件一样，通过声明式的方式构建复杂的 Three.js 场景，从而大大降低 Three.js 的学习曲线和开发复杂度，特别适合 Vue 开发者快速进入 3D 领域。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>将 Three.js 对象抽象为 Vue 组件，用 Vue 的响应式和组件化思维管理 3D 场景。</strong></p>
</div>
<hr>
<h2 id="一、什么是-TresJS？"><a href="#一、什么是-TresJS？" class="headerlink" title="一、什么是 TresJS？"></a>一、什么是 TresJS？</h2><p>Three.js 是一个强大的 JavaScript 3D 库，用于在浏览器中创建和渲染 3D 图形。然而，直接使用 Three.js API 需要编写大量的命令式（或说是“指令式”）代码来创建几何体、材质、网格、灯光、摄像机、场景以及设置渲染循环等。这对于不熟悉 3D 图形编程的开发者来说，上手较难，且代码维护复杂。</p>
<p>TresJS 的出现就是为了解决这个问题。它提供了一套 Vue 组件，每个组件都对应 Three.js 中的一个核心概念（如 <code>&lt;TresCanvas&gt;</code>, <code>&lt;TresMesh&gt;</code>, <code>&lt;TresPerspectiveCamera&gt;</code>, <code>&lt;TresAmbientLight&gt;</code> 等）。通过这些组件，你可以：</p>
<ul>
<li><strong>声明式构建场景</strong>：像 Vue 模板一样嵌套组件，直接在模板中描述 3D 场景的结构。</li>
<li><strong>响应式数据绑定</strong>：利用 Vue 的响应式系统，数据的变化会自动触发 3D 场景的更新。</li>
<li><strong>组件化开发</strong>：将复杂的 3D 元素封装成可复用的 Vue 组件。</li>
<li><strong>TypeScript 支持</strong>：提供良好的类型推断。</li>
</ul>
<p>TresJS 并不是对 Three.js 的简单封装，它更像是一个 Vue 的渲染器或编译器，能够将 Vue 的虚拟 DOM 转换为 Three.js 的场景对象。</p>
<h2 id="二、为什么选择-TresJS？"><a href="#二、为什么选择-TresJS？" class="headerlink" title="二、为什么选择 TresJS？"></a>二、为什么选择 TresJS？</h2><ol>
<li><strong>降低 Three.js 学习门槛</strong>：如果你熟悉 Vue.js，那么 TresJS 会让你对 Three.js 的概念理解和使用变得更加直观。</li>
<li><strong>提高开发效率</strong>：声明式 API 减少了大量的手动对象创建、属性设置和渲染循环管理的代码。</li>
<li><strong>更好的代码组织</strong>：将 3D 场景分解为独立的、可复用的 Vue 组件，提高了代码的可维护性和可读性。</li>
<li><strong>Vue 生态集成</strong>：可以无缝地与其他 Vue 生态工具（Vue Router, Pinia, Vite 等）集成。</li>
<li><strong>响应式更新</strong>：利用 Vue 的响应式系统，动态更新 3D 场景的属性变得非常简单。</li>
<li><strong>性能优化</strong>：TresJS 在内部处理了 Three.js 的渲染循环和性能优化，通常情况下无需开发者手动干预。</li>
</ol>
<h2 id="三、TresJS-核心概念与组件"><a href="#三、TresJS-核心概念与组件" class="headerlink" title="三、TresJS 核心概念与组件"></a>三、TresJS 核心概念与组件</h2><p>TresJS 的核心是围绕 Three.js 的几个主要对象构建的 Vue 组件。</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3.1 &lt;TresCanvas&gt;"></a>3.1 <code>&lt;TresCanvas&gt;</code></h3><ul>
<li><strong>作用</strong>：TresJS 应用程序的根组件，它创建并管理一个 Three.js 场景 (Scene)、渲染器 (Renderer) 和一个默认的摄像机 (Camera)。所有的 3D 元素都必须嵌套在这个组件内部。</li>
<li><strong>重要属性</strong>：<ul>
<li><code>shadows</code>：是否启用阴影 (默认为 false)。</li>
<li><code>alpha</code>：渲染器是否透明 (默认为 false)。</li>
<li><code>flat</code>：启用平面色调映射 (Flat Tone Mapping)。</li>
<li><code>dpr</code>：设备像素比，用于优化高分屏渲染。</li>
<li><code>preset</code>：预设相机和灯光配置 (如 <code>&quot;soft&quot;</code>, <code>&quot;realistic&quot;</code>)。</li>
<li><code>log</code>：是否在控制台打印 TresJS 内部日志。</li>
<li><code>camera</code>：可以传入一个自定义的摄像机组件实例。</li>
</ul>
</li>
<li><strong>事件</strong>：可以监听 थ्री维对象的点击、hover 等事件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;!-- 所有 3D 元素都在这里 --&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-几何体-Geometries"><a href="#3-2-几何体-Geometries" class="headerlink" title="3.2 几何体 (Geometries)"></a>3.2 几何体 (Geometries)</h3><p>对应 Three.js 中的 <code>THREE.BufferGeometry</code> 及其子类。<br>TresJS 提供了以 <code>Tres</code> 开头的组件，例如：</p>
<ul>
<li><code>&lt;TresBoxGeometry&gt;</code></li>
<li><code>&lt;TresSphereGeometry&gt;</code></li>
<li><code>&lt;TresPlaneGeometry&gt;</code></li>
<li><code>&lt;TresCylinderGeometry&gt;</code></li>
<li><code>&lt;TresTorusGeometry&gt;</code></li>
<li><code>&lt;TresExtrudeGeometry&gt;</code></li>
<li>…以及更多</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresMesh&gt;</span><br><span class="line">      &lt;TresBoxGeometry :args=&quot;[1, 1, 1]&quot; /&gt; &lt;!-- args 对应 Three.js 构造函数的参数 --&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-材质-Materials"><a href="#3-3-材质-Materials" class="headerlink" title="3.3 材质 (Materials)"></a>3.3 材质 (Materials)</h3><p>对应 Three.js 中的 <code>THREE.Material</code> 及其子类。<br>TresJS 提供了以 <code>Tres</code> 开头，以 <code>Material</code> 结尾的组件，例如：</p>
<ul>
<li><code>&lt;TresMeshStandardMaterial&gt;</code> (物理渲染，支持灯光、阴影)</li>
<li><code>&lt;TresMeshBasicMaterial&gt;</code> (基本材质，不受灯光影响)</li>
<li><code>&lt;TresMeshLambertMaterial&gt;</code> (非物理渲染，支持点光源)</li>
<li><code>&lt;TresMeshPhongMaterial&gt;</code></li>
<li><code>&lt;TresShaderMaterial&gt;</code> (自定义着色器)</li>
<li>…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresMesh&gt;</span><br><span class="line">      &lt;TresBoxGeometry :args=&quot;[1, 1, 1]&quot; /&gt;</span><br><span class="line">      &lt;TresMeshStandardMaterial color=&quot;hotpink&quot; /&gt; &lt;!-- 颜色等属性作为 prop 传递 --&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-网格-Meshes"><a href="#3-4-网格-Meshes" class="headerlink" title="3.4 网格 (Meshes)"></a>3.4 网格 (Meshes)</h3><p>对应 Three.js 中的 <code>THREE.Mesh</code>。它是几何体和材质的组合，表示场景中的一个三维对象。</p>
<ul>
<li><strong>重要属性</strong>：<ul>
<li><code>position</code>：对象的 (x, y, z) 坐标。</li>
<li><code>rotation</code>：对象的旋转 (欧拉角)。</li>
<li><code>scale</code>：对象的缩放。</li>
<li><code>cast-shadow</code>, <code>receive-shadow</code>：是否投射&#x2F;接收阴影。</li>
<li><code>name</code>：名称，用于组织和查找对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresMesh :position=&quot;[1, 0, 0]&quot; :rotation=&quot;[Math.PI / 4, 0, 0]&quot;&gt;</span><br><span class="line">      &lt;TresBoxGeometry :args=&quot;[1, 1, 1]&quot; /&gt;</span><br><span class="line">      &lt;TresMeshStandardMaterial color=&quot;hotpink&quot; /&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-灯光-Lights"><a href="#3-5-灯光-Lights" class="headerlink" title="3.5 灯光 (Lights)"></a>3.5 灯光 (Lights)</h3><p>对应 Three.js 中的 <code>THREE.Light</code> 及其子类。</p>
<ul>
<li><code>&lt;TresAmbientLight&gt;</code> (环境光，均匀照亮所有物体)</li>
<li><code>&lt;TresDirectionalLight&gt;</code> (平行光，如太阳光)</li>
<li><code>&lt;TresPointLight&gt;</code> (点光源，如灯泡)</li>
<li><code>&lt;TresSpotLight&gt;</code> (聚光灯)</li>
<li>…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresAmbientLight :intensity=&quot;0.5&quot; /&gt;</span><br><span class="line">    &lt;TresDirectionalLight :position=&quot;[0, 5, 5]&quot; :intensity=&quot;1&quot; cast-shadow /&gt;</span><br><span class="line">    &lt;!-- ...其他 3D 元素 --&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-摄像机-Cameras"><a href="#3-6-摄像机-Cameras" class="headerlink" title="3.6 摄像机 (Cameras)"></a>3.6 摄像机 (Cameras)</h3><p>对应 Three.js 中的 <code>THREE.Camera</code> 及其子类。</p>
<ul>
<li><code>&lt;TresPerspectiveCamera&gt;</code> (透视相机，模拟人眼观看效果)</li>
<li><code>&lt;TresOrthographicCamera&gt;</code> (正交相机，无透视效果，常用于 CAD 或 2D 游戏)</li>
<li>可以放在 <code>&lt;TresCanvas&gt;</code> 内部作为默认相机，或者通过 <code>useTresContext()</code> 获取后手动激活。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresPerspectiveCamera :position=&quot;[0, 2, 5]&quot; :fov=&quot;45&quot; :near=&quot;0.1&quot; :far=&quot;1000&quot; /&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-辅助工具-Helpers"><a href="#3-7-辅助工具-Helpers" class="headerlink" title="3.7 辅助工具 (Helpers)"></a>3.7 辅助工具 (Helpers)</h3><p>如 <code>&lt;TresAxesHelper&gt;</code>、<code>&lt;TresGridHelper&gt;</code> 等，用于辅助开发和调试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresAxesHelper /&gt;  &lt;!-- 显示坐标轴 --&gt;</span><br><span class="line">    &lt;TresGridHelper /&gt;  &lt;!-- 显示网格 --&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="四、TresJS-的动画与交互"><a href="#四、TresJS-的动画与交互" class="headerlink" title="四、TresJS 的动画与交互"></a>四、TresJS 的动画与交互</h2><h3 id="4-1-动画"><a href="#4-1-动画" class="headerlink" title="4.1 动画"></a>4.1 动画</h3><p>TresJS 可以很方便地实现动画，通常结合 Vue 的 <code>ref</code> 和响应式数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; useRenderLoop &#125; from &#x27;@tresjs/core&#x27;;</span><br><span class="line"></span><br><span class="line">const cubeRef = ref();</span><br><span class="line">const &#123; onLoop &#125; = useRenderLoop();</span><br><span class="line"></span><br><span class="line">// 在每一帧渲染循环中执行</span><br><span class="line">onLoop((&#123; delta, elapsed &#125;) =&gt; &#123;</span><br><span class="line">  if (cubeRef.value) &#123;</span><br><span class="line">    cubeRef.value.rotation.y += delta; // 围绕 Y 轴旋转</span><br><span class="line">    cubeRef.value.position.x = Math.sin(elapsed) * 2; // 左右摆动</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresPerspectiveCamera :position=&quot;[0, 2, 5]&quot; /&gt;</span><br><span class="line">    &lt;TresMesh ref=&quot;cubeRef&quot;&gt;</span><br><span class="line">      &lt;TresBoxGeometry /&gt;</span><br><span class="line">      &lt;TresMeshStandardMaterial color=&quot;blue&quot; /&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line">    &lt;TresAmbientLight :intensity=&quot;0.5&quot; /&gt;</span><br><span class="line">    &lt;TresDirectionalLight :position=&quot;[0, 5, 5]&quot; :intensity=&quot;1&quot; /&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-交互-Pointer-Events"><a href="#4-2-交互-Pointer-Events" class="headerlink" title="4.2 交互 (Pointer Events)"></a>4.2 交互 (Pointer Events)</h3><p>TresJS 提供了 <code>@click</code>, <code>@hover-move</code>, <code>@hover-enter</code>, <code>@hover-leave</code> 等事件，可以直接在 Tres 组件上使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresMesh @click=&quot;handleClick&quot; @hover-enter=&quot;handleHoverEnter&quot; @hover-leave=&quot;handleHoverLeave&quot;&gt;</span><br><span class="line">      &lt;TresBoxGeometry /&gt;</span><br><span class="line">      &lt;TresMeshStandardMaterial :color=&quot;isHovered ? &#x27;lime&#x27; : &#x27;red&#x27;&quot; /&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const isHovered = ref(false);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  alert(&#x27;方块被点击了！&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleHoverEnter() &#123;</span><br><span class="line">  isHovered.value = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function handleHoverLeave() &#123;</span><br><span class="line">  isHovered.value = false;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-轨道控制器-OrbitControls"><a href="#4-3-轨道控制器-OrbitControls" class="headerlink" title="4.3 轨道控制器 (OrbitControls)"></a>4.3 轨道控制器 (OrbitControls)</h3><p>通过 <code>@tresjs/cientos</code> (一个 TresJS 的实用工具库)，可以轻松引入常用的 Three.js 控件。</p>
<ol>
<li><strong>安装 Cientos</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tresjs/cientos</span><br></pre></td></tr></table></figure></li>
<li><strong>使用</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; OrbitControls &#125; from &#x27;@tresjs/cientos&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresPerspectiveCamera :position=&quot;[0, 2, 5]&quot; /&gt;</span><br><span class="line">    &lt;OrbitControls /&gt; &lt;!-- 引入轨道控制器 --&gt;</span><br><span class="line">    &lt;TresMesh&gt;</span><br><span class="line">      &lt;TresBoxGeometry /&gt;</span><br><span class="line">      &lt;TresMeshStandardMaterial color=&quot;blue&quot; /&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line">    &lt;TresAmbientLight :intensity=&quot;0.5&quot; /&gt;</span><br><span class="line">    &lt;TresDirectionalLight :position=&quot;[0, 5, 5]&quot; :intensity=&quot;1&quot; /&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五、生态系统：Cientos"><a href="#五、生态系统：Cientos" class="headerlink" title="五、生态系统：Cientos"></a>五、生态系统：Cientos</h2><p><code>@tresjs/cientos</code> 是 TresJS 的一个伴生库，灵感来源于 <code>react-three/drei</code>，它提供了大量实用的 Three.js 抽象和组件，进一步简化开发：</p>
<ul>
<li><strong>相机控制器</strong>：<code>OrbitControls</code>, <code>PointerLockControls</code></li>
<li><strong>加载器</strong>：<code>useGLTF</code>, <code>useTexture</code> (加载 glTF 模型、纹理)</li>
<li><strong>实用几何体</strong>：<code>Sphere</code>, <code>Plane</code>, <code>Box</code> (更简洁的 Mesh 封装)</li>
<li><strong>后处理效果</strong>：<code>EffectComposer</code></li>
<li><strong>其他工具</strong>：<code>ScreenQuad</code>, <code>HTML</code>, <code>Text3D</code> 等。</li>
</ul>
<p>大大减少了重复代码，例如加载 3D 模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; TresCanvas &#125; from &#x27;@tresjs/core&#x27;;</span><br><span class="line">import &#123; useGLTF, OrbitControls &#125; from &#x27;@tresjs/cientos&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; scene: model &#125; = await useGLTF(&#x27;/model.glb&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas&gt;</span><br><span class="line">    &lt;TresPerspectiveCamera :position=&quot;[0, 2, 5]&quot; /&gt;</span><br><span class="line">    &lt;OrbitControls /&gt;</span><br><span class="line">    &lt;TresAmbientLight :intensity=&quot;0.5&quot; /&gt;</span><br><span class="line">    &lt;primitive :object=&quot;model&quot; :scale=&quot;0.5&quot; /&gt; &lt;!-- 使用 primitive 渲染加载的模型 --&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="六、入门示例-一个旋转的立方体"><a href="#六、入门示例-一个旋转的立方体" class="headerlink" title="六、入门示例 (一个旋转的立方体)"></a>六、入门示例 (一个旋转的立方体)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;; // 引入 Vue 的 ref</span><br><span class="line">import &#123; useRenderLoop &#125; from &#x27;@tresjs/core&#x27;; // 引入 TresJS 的渲染循环 hook</span><br><span class="line"></span><br><span class="line">// 创建一个响应式引用来存储立方体网格对象</span><br><span class="line">const boxRef = ref();</span><br><span class="line"></span><br><span class="line">// 获取渲染循环的句柄</span><br><span class="line">const &#123; onLoop &#125; = useRenderLoop();</span><br><span class="line"></span><br><span class="line">// 监听每一帧的渲染循环</span><br><span class="line">onLoop((&#123; delta &#125;) =&gt; &#123;</span><br><span class="line">  // 确保 boxRef.value 存在，即立方体已被渲染</span><br><span class="line">  if (boxRef.value) &#123;</span><br><span class="line">    // 让立方体围绕 Y 轴旋转，delta 是上一帧和当前帧之间的间隔时间</span><br><span class="line">    boxRef.value.rotation.y += delta;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;TresCanvas clear-color=&quot;#82DBC5&quot;&gt; &lt;!-- 设置背景色 --&gt;</span><br><span class="line">    &lt;!-- 摄像机：透视相机，位置在 (0, 2, 5)，视野 45 度 --&gt;</span><br><span class="line">    &lt;TresPerspectiveCamera :position=&quot;[0, 2, 5]&quot; :fov=&quot;45&quot; :near=&quot;0.1&quot; :far=&quot;1000&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 环境光：提供基础照明 --&gt;</span><br><span class="line">    &lt;TresAmbientLight :intensity=&quot;0.5&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 平行光：模拟太阳光，从 (0, 5, 5) 位置照射，强度 1，并开启投射阴影 --&gt;</span><br><span class="line">    &lt;TresDirectionalLight :position=&quot;[0, 5, 5]&quot; :intensity=&quot;1&quot; cast-shadow /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 立方体网格： --&gt;</span><br><span class="line">    &lt;TresMesh ref=&quot;boxRef&quot; :position=&quot;[0, 0, 0]&quot; :cast-shadow=&quot;true&quot;&gt;</span><br><span class="line">      &lt;!-- 几何体：一个边长为 1 的立方体 --&gt;</span><br><span class="line">      &lt;TresBoxGeometry :args=&quot;[1, 1, 1]&quot; /&gt;</span><br><span class="line">      &lt;!-- 材质：一个标准网格材质，颜色为 hotpink --&gt;</span><br><span class="line">      &lt;TresMeshStandardMaterial color=&quot;hotpink&quot; /&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 地面平面：接收阴影 --&gt;</span><br><span class="line">    &lt;TresMesh :rotation=&quot;[-Math.PI / 2, 0, 0]&quot; :position=&quot;[0, -1, 0]&quot; :receive-shadow=&quot;true&quot;&gt;</span><br><span class="line">      &lt;TresPlaneGeometry :args=&quot;[10, 10]&quot; /&gt;</span><br><span class="line">      &lt;TresMeshStandardMaterial color=&quot;#ffffff&quot; /&gt;</span><br><span class="line">    &lt;/TresMesh&gt;</span><br><span class="line">  &lt;/TresCanvas&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="七、总结与展望"><a href="#七、总结与展望" class="headerlink" title="七、总结与展望"></a>七、总结与展望</h2><p>TresJS 为 Vue 开发者提供了一种非常优雅和高效的方式来构建 Three.js 场景。它抹平了 Three.js 的一部分复杂性，使得 3D 体验的开发不再是少数专业图形工程师的专利，而是更广泛的前端开发者可以触及的领域。</p>
<p>如果你是 Vue 开发者，想要在项目中添加 3D 效果，或者想学习 Three.js 而又不想被繁琐的命令式代码所困扰，那么 TresJS 绝对是你的首选。</p>
<p>未来，社区对 WebGL、WebGPU 的兴趣日益高涨，像 TresJS 这样的声明式框架将扮演越来越重要的角色，降低 3D 内容创作的门槛，推动 Web 3D 应用的普及。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/eb8d4a4bab0b/">https://blog.tbf1211.xx.kg/eb8d4a4bab0b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/2025/">2025</a><a class="post-meta__tags" href="/tags/WebGL/">WebGL</a><a class="post-meta__tags" href="/tags/Three-js/">Three.js</a><a class="post-meta__tags" href="/tags/TresJS/">TresJS</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-22.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/6d6856b2b7ad/" title="Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hyper-V 深度详解：Windows 平台上的专业级虚拟化技术</div></div><div class="info-2"><div class="info-item-1"> Hyper-V 是微软提供的一款基于 Hypervisor 的虚拟化技术，它允许用户在单一物理服务器上运行多个独立的虚拟机 (Virtual Machines, VMs)。作为 Windows Server 操作系统的一个角色功能，以及 Windows 客户端操作系统（Pro、Enterprise、Education 版本）的一个可选功能，Hyper-V 提供了一个可靠、高效且可扩展的平台，用于创建、运行和管理虚拟机。它支持运行多种操作系统，包括 Windows、Linux 以及其他变体，是企业级数据中心、开发测试环境以及个人专业用户不可或缺的工具。  核心思想：Hyper-V 在硬件和操作系统之间插入一个薄薄的虚拟化层——Hypervisor (管理程序)。这个 Hypervisor 直接管理物理硬件资源，并高效地分配给多个虚拟机，每个虚拟机都像一台独立的物理机器一样运行，拥有自己的操作系统和应用程序，从而实现资源的隔离和高效利用。   一、虚拟化技术概述与 Hyper-V 的定位1.1 什么是虚拟化？虚拟化是一种创建事物虚拟版本（而不是物理版本）的技术，通常指创建虚拟计算机...</div></div></div></a><a class="pagination-related" href="/b10b8bccf756/" title="Go语言指向指针的指针(Pointer to Pointer)详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Go语言指向指针的指针(Pointer to Pointer)详解</div></div><div class="info-2"><div class="info-item-1"> 在 Go 语言中，指针是一种重要的概念，它存储了一个变量的内存地址。我们通常通过 * 运算符来解引用指针，获取指针指向的值。但 Go 语言还支持更复杂的指针类型，例如指向指针的指针 (Pointer to Pointer)，也称为二级指针 (Double Pointer)。虽然在日常开发中不常用，但理解其工作原理对于深入理解内存管理、某些高级数据结构（如链表、树的修改操作）或在特定场景下修改指针本身的值至关重要。  核心概念：一个指针变量存储一个普通变量的地址，而指向指针的指针存储一个指针变量的地址。   一、基本指针回顾在深入指向指针的指针之前，我们先快速回顾一下 Go 语言中的基本指针：  定义指针：使用 * 符号和类型名来声明一个指针变量，例如 *int 表示一个指向 int 类型的指针。 获取地址：使用 &amp; 运算符来获取一个变量的内存地址。 解引用：使用 * 运算符来访问指针指向的内存中的值。  示例： 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/914c30a1659f/" title="Three.js 进阶教程：从核心概念到高级应用"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-14</div><div class="info-item-2">Three.js 进阶教程：从核心概念到高级应用</div></div><div class="info-2"><div class="info-item-1"> Three.js 不仅仅是一个库，它是一个通往 3D 世界的大门。通过它，我们可以在 Web 浏览器中构建出令人惊叹的交互式体验。本教程将带你超越入门，深入了解 Three.js 的核心组件、工作原理以及一些高级技巧，助你构建更复杂、更酷炫的 3D 应用。  “深入 Three.js，你将发现 Web 前端的无限可能性。”   一、Three.js 核心工作流回顾与进阶在入门教程中，我们介绍了 Three.js 的“四大件”：场景 (Scene)、相机 (Camera)、渲染器 (Renderer) 和物体 (Object &#x3D; Geometry + Material)。它们是构建任何 Three.js 应用的基础。 1.1 渲染管线概览     graph TD     A[JavaScript Code （Three.js）] --&gt; B(初始化: Scene, Camera, Renderer);     B --&gt; C(创建 Mesh: Geometry + Material);     C --&gt; D(添加 Lights);     C --...</div></div></div></a><a class="pagination-related" href="/b25babd84514/" title="Vue3 defineModel详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-03</div><div class="info-item-2">Vue3 defineModel详解</div></div><div class="info-2"><div class="info-item-1"> defineModel 是 Vue 3.4 版本中引入的一个新的宏 (macro)，旨在简化组件中双向绑定 v-model 的实现。在 Composition API 的 setup 语法糖 (&lt;script setup&gt;) 中使用时，它极大地减少了为组件实现 v-model 所需的样板代码，使其更加直观和便捷。  核心思想：defineModel 是 defineProps 和 defineEmits 的语法糖，它声明了一个可双向绑定的 props，并自动处理了 modelValue prop 的接收和相应的 update:modelValue 事件的触发，让自定义组件的 v-model 用法变得和原生表单元素一样简洁。   一、为什么需要 defineModel？在 defineModel 出现之前，如果你想在 Vue 3 的自定义组件中实现 v-model 双向绑定，你需要手动完成以下步骤：  通过 defineProps 声明一个名为 modelValue 的 prop 来接收父组件传递的值。 通过 defineEmits 声明一个名为 update:mod...</div></div></div></a><a class="pagination-related" href="/f1d2005549f2/" title="HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-28</div><div class="info-item-2">HTMX详解：用HTML属性直接驱动AJAX、CSS过渡和WebSocket</div></div><div class="info-2"><div class="info-item-1"> 在过去十年中，前端开发领域由 JavaScript 框架（如 React, Vue, Angular）占据主导地位，它们将整个用户界面放在客户端，通过 API 与后端交互。然而，这种“单页应用 (SPA)”模式并非总是最佳选择，它带来了复杂的构建流程、初始加载性能问题、SEO 挑战以及较高的开发和维护成本。 HTMX 的出现，挑战了这一主流范式。它主张将交互逻辑回归到服务器端，通过简单的 HTML 属性就能实现 AJAX 请求、CSS 过渡、WebSocket 和服务器发送事件 (SSE)，在不编写一行 JavaScript 代码的情况下，实现丰富的动态用户体验。  本文将深入探讨 HTMX 的核心理念、工作原理、主要特性、优缺点以及适用场景，帮助你理解这个“返璞归真”但又极具创新力的工具。   一、 HTMX 是什么？核心理念与哲学HTMX 是一个小型 (约 15KB gzipped) 的 JavaScript 库，它通过扩展 HTML 原生能力，允许你在 HTML 元素上直接指定 AJAX 请求、CSS 动画、WebSocket 和服务器发送事件 (SSE) 行为。 其核心...</div></div></div></a><a class="pagination-related" href="/c1df397eedad/" title="TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="info-item-2">TypeScript 各版本新特性详解 (TypeScript 1.0 至 最新稳定版)</div></div><div class="info-2"><div class="info-item-1"> TypeScript 是由 Microsoft 开发和维护的一种开源编程语言。它是 JavaScript 的一个超集，添加了可选的静态类型、类、接口等特性，旨在提高大型应用开发的效率和可维护性。自 2012 年首次发布以来，TypeScript 社区每月或每季度发布一个新版本，不断引入新的语言特性、编译器优化、工具改进和类型系统增强。理解这些版本特性对于 TypeScript 开发者来说至关重要，它能帮助我们编写更健壮、更现代化且更易于维护的代码。  核心思想： TypeScript 的版本迭代始终围绕着“提升开发者体验、增强类型安全性、更好地支持 JavaScript 新特性、改进工具链”这些目标，旨在弥合 JavaScript 的动态性与大型应用开发对静态分析需求的差距。   一、TypeScript 1.0 - 1.8：早期奠基与核心功能TypeScript 在早期版本主要关注语言的稳定、核心功能的完善以及与 JavaScript 的兼容性。 1.1 TypeScript 1.0 (2014-04-02) 第一个稳定版本：标志着 TypeScript 正式可以用于生产环境...</div></div></div></a><a class="pagination-related" href="/be24ef88e59a/" title="WebRTC 技术详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-28</div><div class="info-item-2">WebRTC 技术详解</div></div><div class="info-2"><div class="info-item-1"> WebRTC (Web Real-Time Communication) 是一项开放标准 (由 W3C 和 IETF 制定)，它允许 Web 应用程序和站点在不需要任何内部或外部插件的情况下，实现浏览器之间的实时语音、视频通信以及数据传输。WebRTC 的核心思想是实现点对点 (P2P) 传输，从而减少服务器负载并降低延迟，提供高质量的实时交互体验。  核心思想：利用浏览器内置的 API，通过一套标准化协议，安全高效地建立客户端之间的直接连接，实现低延迟的实时通信。WebRTC 关注的是客户端之间的数据传输，而连接的协调（如谁与谁连接）则依赖于信令服务器。    一、为什么需要 WebRTC？在 WebRTC 出现之前，实现浏览器间的实时通信通常需要依赖 Flash、Java Applet 或各种插件，这些方案存在以下问题：  插件依赖：用户需要安装特定插件，增加了使用门槛和兼容性问题。 不开放标准：缺乏统一标准，不同方案之间难以互通。 安全性问题：插件可能引入安全漏洞。 服务器集中：大部分实时通信方案依赖中心化服务器进行数据传输，导致服务器开销大、延迟高。  WebRTC 旨...</div></div></div></a><a class="pagination-related" href="/f67db260675a/" title="Vue3 Hook(组合式 API)与Mixin对比详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="info-item-2">Vue3 Hook(组合式 API)与Mixin对比详解</div></div><div class="info-2"><div class="info-item-1"> 在 Vue.js 的开发中，逻辑复用 一直是一个核心且具有挑战性的问题。从 Vue 2 时代的 Mixin (混入) 到 Vue 3 推出的 Composition API (组合式 API，常被称为“Hook”模式)，Vue 提供了不同的解决方案来组织和复用组件逻辑。  本文将深入探讨 Vue 3 的 Hook (组合式 API) 和 Vue 2 &#x2F; Vue 3 都支持的 Mixin 两种逻辑复用模式，从多方面进行对比分析，帮助开发者理解它们各自的优缺点，并选择最适合自己项目和团队的模式。   一、 理解 Vue 中的逻辑复用在 Vue 组件开发中，我们经常会遇到需要在多个组件中共享相同的逻辑（例如：处理鼠标位置、计时器、表单验证、主题切换等）。如果没有有效的复用机制，这些逻辑就会在不同组件中重复编写，导致代码冗余、难以维护。  Vue 提供了以下主要方式来解决逻辑复用问题：  Mixin (混入)：Vue 2 的主要逻辑复用方式，也在 Vue 3 中继续支持。 Composition API (组合式 API &#x2F; Vue 3 Hook)：Vue 3 引入...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">443</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">80</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-TresJS%EF%BC%9F"><span class="toc-text">一、什么是 TresJS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-TresJS%EF%BC%9F"><span class="toc-text">二、为什么选择 TresJS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TresJS-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%84%E4%BB%B6"><span class="toc-text">三、TresJS 核心概念与组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1"><span class="toc-text">3.1 &lt;TresCanvas&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%87%A0%E4%BD%95%E4%BD%93-Geometries"><span class="toc-text">3.2 几何体 (Geometries)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9D%90%E8%B4%A8-Materials"><span class="toc-text">3.3 材质 (Materials)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%BD%91%E6%A0%BC-Meshes"><span class="toc-text">3.4 网格 (Meshes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E7%81%AF%E5%85%89-Lights"><span class="toc-text">3.5 灯光 (Lights)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E6%91%84%E5%83%8F%E6%9C%BA-Cameras"><span class="toc-text">3.6 摄像机 (Cameras)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7-Helpers"><span class="toc-text">3.7 辅助工具 (Helpers)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81TresJS-%E7%9A%84%E5%8A%A8%E7%94%BB%E4%B8%8E%E4%BA%A4%E4%BA%92"><span class="toc-text">四、TresJS 的动画与交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8A%A8%E7%94%BB"><span class="toc-text">4.1 动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BA%A4%E4%BA%92-Pointer-Events"><span class="toc-text">4.2 交互 (Pointer Events)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BD%A8%E9%81%93%E6%8E%A7%E5%88%B6%E5%99%A8-OrbitControls"><span class="toc-text">4.3 轨道控制器 (OrbitControls)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%EF%BC%9ACientos"><span class="toc-text">五、生态系统：Cientos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B-%E4%B8%80%E4%B8%AA%E6%97%8B%E8%BD%AC%E7%9A%84%E7%AB%8B%E6%96%B9%E4%BD%93"><span class="toc-text">六、入门示例 (一个旋转的立方体)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-text">七、总结与展望</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-06.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CFFI (C Foreign Function Interface for Python) 详解"/></a><div class="content"><a class="title" href="/0c48c5fa5942/" title="CFFI (C Foreign Function Interface for Python) 详解">CFFI (C Foreign Function Interface for Python) 详解</a><time datetime="2025-12-23T22:24:00.000Z" title="发表于 2025-12-24 06:24:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行为驱动开发 (BDD) 详解"/></a><div class="content"><a class="title" href="/03cebd3cc28a/" title="行为驱动开发 (BDD) 详解">行为驱动开发 (BDD) 详解</a><time datetime="2025-12-21T22:24:00.000Z" title="发表于 2025-12-22 06:24:00">2025-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试驱动开发 (TDD) 详解"/></a><div class="content"><a class="title" href="/7bb082434be0/" title="测试驱动开发 (TDD) 详解">测试驱动开发 (TDD) 详解</a><time datetime="2025-12-19T22:24:00.000Z" title="发表于 2025-12-20 06:24:00">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPFS (InterPlanetary File System) 详解"/></a><div class="content"><a class="title" href="/24ffc0bedb41/" title="IPFS (InterPlanetary File System) 详解">IPFS (InterPlanetary File System) 详解</a><time datetime="2025-12-16T22:24:00.000Z" title="发表于 2025-12-17 06:24:00">2025-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="L7 负载均衡详解 (Layer 7 Load Balancing Explained)"/></a><div class="content"><a class="title" href="/974825c9c64f/" title="L7 负载均衡详解 (Layer 7 Load Balancing Explained)">L7 负载均衡详解 (Layer 7 Load Balancing Explained)</a><time datetime="2025-12-14T22:24:00.000Z" title="发表于 2025-12-15 06:24:00">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-22.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>