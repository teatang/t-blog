<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IPv4 (Internet Protocol version 4) 详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IPv4 (Internet Protocol version 4) 是互联网协议家族（TCP&#x2F;IP 协议族）中最核心的协议之一，也是当前互联网上使用最广泛的协议。它位于 OSI 模型的网络层（第三层），负责在复杂的互联网中数据包的寻址和路由。IPv4 定义了数据包的格式以及在网络中传输和转发的机制，使得不同网络中的设备能够相互通信。尽管其地址耗尽问题催生了 IPv6，但 IPv4 仍">
<meta property="og:type" content="article">
<meta property="og:title" content="IPv4 (Internet Protocol version 4) 详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/6b3b0892e720/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="IPv4 (Internet Protocol version 4) 是互联网协议家族（TCP&#x2F;IP 协议族）中最核心的协议之一，也是当前互联网上使用最广泛的协议。它位于 OSI 模型的网络层（第三层），负责在复杂的互联网中数据包的寻址和路由。IPv4 定义了数据包的格式以及在网络中传输和转发的机制，使得不同网络中的设备能够相互通信。尽管其地址耗尽问题催生了 IPv6，但 IPv4 仍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg">
<meta property="article:published_time" content="2024-11-15T22:24:00.000Z">
<meta property="article:modified_time" content="2026-02-05T09:25:21.071Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="网络技术">
<meta property="article:tag" content="2024">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "IPv4 (Internet Protocol version 4) 详解",
  "url": "https://blog.tbf1211.xx.kg/6b3b0892e720/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-24.jpg",
  "datePublished": "2024-11-15T22:24:00.000Z",
  "dateModified": "2026-02-05T09:25:21.071Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/6b3b0892e720/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IPv4 (Internet Protocol version 4) 详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">545</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-24.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">IPv4 (Internet Protocol version 4) 详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">IPv4 (Internet Protocol version 4) 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-11-15T22:24:00.000Z" title="发表于 2024-11-16 06:24:00">2024-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>IPv4 (Internet Protocol version 4)</strong> 是互联网协议家族（TCP&#x2F;IP 协议族）中最核心的协议之一，也是当前互联网上使用最广泛的协议。它位于 OSI 模型的网络层（第三层），负责在复杂的互联网中<strong>数据包的寻址和路由</strong>。IPv4 定义了数据包的格式以及在网络中传输和转发的机制，使得不同网络中的设备能够相互通信。尽管其地址耗尽问题催生了 IPv6，但 IPv4 仍是支撑全球互联网运行的基石。</p>
</blockquote>
<div class="note info flat"><p>核心思想：在互联网这个异构网络中，为每个连接的设备提供一个唯一的逻辑地址，并设计一种数据包转发机制，确保数据能从源头准确无误地传输到目的地。</p>
</div>
<hr>
<h2 id="一、什么是-IPv4？"><a href="#一、什么是-IPv4？" class="headerlink" title="一、什么是 IPv4？"></a>一、什么是 IPv4？</h2><p>IPv4 是互联网协议的第四个版本。它是一种<strong>无连接的协议</strong>，意味着每个数据包都独立发送，不保证顺序或可靠性（这些由上层协议如 TCP 负责）。IPv4 的主要职责包括：</p>
<ul>
<li><strong>寻址 (Addressing)</strong>：为网络上的每个设备分配一个唯一的 32 位数字地址（IP 地址），用于标识设备。</li>
<li><strong>路由 (Routing)</strong>：根据数据包的目的 IP 地址，决定数据包在网络中传输的最佳路径，并将其转发到下一个路由器。</li>
<li><strong>分片 (Fragmentation)</strong>：当数据包大小超过了网络路径中链路的最大传输单元 (MTU) 时，IPv4 会将数据包分割成更小的片段进行传输，并在目的地重新组装。</li>
</ul>
<h2 id="二、IPv4-地址"><a href="#二、IPv4-地址" class="headerlink" title="二、IPv4 地址"></a>二、IPv4 地址</h2><p>IPv4 地址是一个 32 位的二进制数字，通常以<strong>点分十进制 (Dotted Decimal Notation)</strong> 的形式表示，例如 <code>192.168.1.1</code>。</p>
<h3 id="2-1-地址结构"><a href="#2-1-地址结构" class="headerlink" title="2.1 地址结构"></a>2.1 地址结构</h3><p>一个 IPv4 地址被分为四个 <strong>八位字节 (octet)</strong>，每个八位字节的取值范围是 0 到 255。</p>
<ul>
<li><strong>32 位</strong>：这决定了 IPv4 地址空间的总量为 $2^{32} \approx 4.3$ 亿个地址。</li>
<li><strong>点分十进制</strong>：为了方便人类阅读和记忆，我们将 32 位二进制地址每 8 位分为一组，转换为十进制数字，并用点号隔开。</li>
</ul>
<p><strong>示例：</strong><br>二进制：<code>11000000.10101000.00000001.00000001</code><br>十进制：<code>192.168.1.1</code></p>
<h3 id="2-2-IP-地址的组成：网络部分和主机部分"><a href="#2-2-IP-地址的组成：网络部分和主机部分" class="headerlink" title="2.2 IP 地址的组成：网络部分和主机部分"></a>2.2 IP 地址的组成：网络部分和主机部分</h3><p>一个 IP 地址包含两部分信息：</p>
<ol>
<li><strong>网络部分 (Network Portion)</strong>：标识设备所属的网络。在同一个网络中的设备，其 IP 地址的网络部分是相同的。</li>
<li><strong>主机部分 (Host Portion)</strong>：标识网络中的具体设备。在同一个网络中，每台设备的 IP 地址的主机部分是唯一的。</li>
</ol>
<p>如何区分网络部分和主机部分？这需要<strong>子网掩码 (Subnet Mask)</strong>。</p>
<h3 id="2-3-子网掩码-Subnet-Mask"><a href="#2-3-子网掩码-Subnet-Mask" class="headerlink" title="2.3 子网掩码 (Subnet Mask)"></a>2.3 子网掩码 (Subnet Mask)</h3><p>子网掩码也是一个 32 位的二进制数字，与 IP 地址对应。它的作用是：</p>
<ul>
<li><strong>网络部分的标识</strong>：子网掩码中，<strong>连续的 1</strong> 对应 IP 地址的<strong>网络部分</strong>。</li>
<li><strong>主机部分的标识</strong>：子网掩码中，<strong>连续的 0</strong> 对应 IP 地址的<strong>主机部分</strong>。</li>
</ul>
<p>子网掩码通常也以点分十进制表示，例如 <code>255.255.255.0</code>。<br>或者使用 <strong>CIDR (Classless Inter-Domain Routing) 表示法</strong>，即在 IP 地址后面加上斜杠和网络部分的位数，例如 <code>192.168.1.1/24</code>。<code>/24</code> 表示网络部分有 24 位。</p>
<p><strong>示例：</strong><br>IP 地址：<code>192.168.1.1</code><br>子网掩码：<code>255.255.255.0</code> (CIDR: <code>/24</code>)</p>
<ul>
<li><code>192.168.1</code> 是网络部分。</li>
<li><code>1</code> 是主机部分。</li>
</ul>
<h3 id="2-4-网络地址和广播地址"><a href="#2-4-网络地址和广播地址" class="headerlink" title="2.4 网络地址和广播地址"></a>2.4 网络地址和广播地址</h3><p>在任何一个子网中，有两个特殊的 IP 地址不能分配给主机：</p>
<ul>
<li><strong>网络地址 (Network Address)</strong>：主机部分全为 0 的地址。它代表整个子网，用于路由表中标识子网。<ul>
<li>例如：<code>192.168.1.0/24</code> 中的 <code>192.168.1.0</code>。</li>
</ul>
</li>
<li><strong>广播地址 (Broadcast Address)</strong>：主机部分全为 1 的地址。向此地址发送的数据包会发送到该子网内的所有设备。<ul>
<li>例如：<code>192.168.1.0/24</code> 中的 <code>192.168.1.255</code>。</li>
</ul>
</li>
</ul>
<h3 id="2-5-IP-地址分类-历史遗留"><a href="#2-5-IP-地址分类-历史遗留" class="headerlink" title="2.5 IP 地址分类 (历史遗留)"></a>2.5 IP 地址分类 (历史遗留)</h3><p>在 CIDR 出现之前，IPv4 地址被划分为不同的类别 (Class A, B, C, D, E)。虽然现在已不再严格使用分类，但了解它们有助于理解网络历史和某些概念：</p>
<ul>
<li><strong>A 类地址</strong>：网络部分 8 位，主机部分 24 位。 (第一位为 <code>0</code>)<ul>
<li><code>1.0.0.0</code> - <code>126.255.255.255</code></li>
<li>默认子网掩码：<code>255.0.0.0</code> (<code>/8</code>)</li>
<li>适用于大型网络。</li>
</ul>
</li>
<li><strong>B 类地址</strong>：网络部分 16 位，主机部分 16 位。 (前两位为 <code>10</code>)<ul>
<li><code>128.0.0.0</code> - <code>191.255.255.255</code></li>
<li>默认子网掩码：<code>255.255.0.0</code> (<code>/16</code>)</li>
<li>适用于中型网络。</li>
</ul>
</li>
<li><strong>C 类地址</strong>：网络部分 24 位，主机部分 8 位。 (前三位为 <code>110</code>)<ul>
<li><code>192.0.0.0</code> - <code>223.255.255.255</code></li>
<li>默认子网掩码：<code>255.255.255.0</code> (<code>/24</code>)</li>
<li>适用于小型网络。</li>
</ul>
</li>
<li><strong>D 类地址</strong>：组播地址 (Multicast)。 (前四位为 <code>1110</code>)<ul>
<li><code>224.0.0.0</code> - <code>239.255.255.255</code></li>
</ul>
</li>
<li><strong>E 类地址</strong>：保留地址，用于研究。 (前四位为 <code>1111</code>)<ul>
<li><code>240.0.0.0</code> - <code>255.255.255.255</code></li>
</ul>
</li>
</ul>
<h3 id="2-6-私有-IP-地址和公共-IP-地址"><a href="#2-6-私有-IP-地址和公共-IP-地址" class="headerlink" title="2.6 私有 IP 地址和公共 IP 地址"></a>2.6 私有 IP 地址和公共 IP 地址</h3><p>为了缓解 IPv4 地址枯竭问题，IETF 定义了以下私有 IP 地址范围，这些地址只能在<strong>本地局域网 (LAN)</strong> 内部使用，不能在互联网上直接路由。</p>
<ul>
<li><strong>A 类私有地址</strong>：<code>10.0.0.0</code> - <code>10.255.255.255</code> (即 <code>10.0.0.0/8</code>)</li>
<li><strong>B 类私有地址</strong>：<code>172.16.0.0</code> - <code>172.31.255.255</code> (即 <code>172.16.0.0/12</code>)</li>
<li><strong>C 类私有地址</strong>：<code>192.168.0.0</code> - <code>192.168.255.255</code> (即 <code>192.168.0.0/16</code>)</li>
</ul>
<p><strong>公共 IP 地址 (Public IP Address)</strong> 则是由 ISP (互联网服务提供商) 分配的，可以在互联网上直接访问和路由的全球唯一地址。</p>
<p><strong>NAT (Network Address Translation - 网络地址转换)</strong> 技术允许多个使用私有 IP 地址的设备共享一个或少数几个公共 IP 地址访问互联网。</p>
<h3 id="2-7-特殊的-IPv4-地址"><a href="#2-7-特殊的-IPv4-地址" class="headerlink" title="2.7 特殊的 IPv4 地址"></a>2.7 特殊的 IPv4 地址</h3><ul>
<li><strong><code>0.0.0.0</code></strong>：<ul>
<li>在路由表中，表示<strong>默认路由</strong>，即“任何地址”。</li>
<li>在服务器监听端口时，表示“监听所有可用接口上的指定端口”。</li>
</ul>
</li>
<li><strong><code>127.0.0.1</code></strong>：<strong>回环地址 (Loopback Address)</strong>。用于指代本机，通常用于测试网络服务。</li>
<li><strong><code>255.255.255.255</code></strong>：受限广播地址，用于向当前网络发送广播，但不会被路由器转发。</li>
</ul>
<h2 id="三、IPv4-数据报文格式"><a href="#三、IPv4-数据报文格式" class="headerlink" title="三、IPv4 数据报文格式"></a>三、IPv4 数据报文格式</h2><p>IPv4 数据报文由<strong>头部 (Header)</strong> 和<strong>数据部分 (Payload&#x2F;Data)</strong> 组成。头部包含控制信息，数据部分是上层协议（如 TCP、UDP）的数据。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    A[IPv4 数据报文] --&gt; B[&quot;IPv4 头部 (Header)&quot;]
    A --&gt; C[&quot;数据部分 (Payload)&quot;]

    subgraph &quot;IPv4 头部 (20-60 字节)&quot;
        B1[&quot;版本 (4 bits) \n IHL (4 bits)&quot;]
        B2[&quot;服务类型 (8 bits)&quot;]
        B3[&quot;总长度 (16 bits)&quot;]
        B4[&quot;标识 (16 bits)&quot;]
        B5[&quot;标志 (3 bits) \n 片偏移 (13 bits)&quot;]
        B6[&quot;生存时间 (TTL - 8 bits)&quot;]
        B7[&quot;协议 (8 bits)&quot;]
        B8[&quot;头部校验和 (16 bits)&quot;]
        B9[&quot;源 IP 地址 (32 bits)&quot;]
        B10[&quot;目的 IP 地址 (32 bits)&quot;]
        B11[&quot;选项 (0-40 字节)&quot;]
        B12[&quot;填充 (Padding)&quot;]
    end

    B1 --- B2 --- B3
    B4 --- B5 --- B6
    B7 --- B8 --- B9
    B10 --- B11 --- B12
  </pre></div>

<p><strong>IPv4 头部字段解释：</strong></p>
<ul>
<li><strong>版本 (Version)</strong> (4 bits)：永远是 <code>0100</code>，表示 IPv4。</li>
<li><strong>IHL (Internet Header Length)</strong> (4 bits)：IPv4 头部长度，以 32 位字 (4 字节) 为单位。最小值是 5 (20 字节)，最大值是 15 (60 字节)。</li>
<li><strong>服务类型 (Type of Service&#x2F;DSCP)</strong> (8 bits)：用于 QoS (服务质量)。</li>
<li><strong>总长度 (Total Length)</strong> (16 bits)：整个 IPv4 数据报文的长度（头部 + 数据），以字节为单位。最大长度为 65535 字节。</li>
<li><strong>标识 (Identification)</strong> (16 bits)：用于唯一标识一个原始数据报文。当数据报文被分片时，所有片段都使用相同的标识号，以便在目的地正确重组。</li>
<li><strong>标志 (Flags)</strong> (3 bits)：<ul>
<li>第 0 位（Reserved）：保留，必须为 0。</li>
<li>第 1 位（Don’t Fragment - DF）：如果设置为 1，则表示该数据报文不允许被分片。如果路由器必须分片才能转发，就会丢弃该数据报文并返回一个 ICMP 错误。</li>
<li>第 2 位（More Fragments - MF）：如果设置为 1，表示后面还有该数据报文的更多片段。最后一个片段的 MF 位为 0。</li>
</ul>
</li>
<li><strong>片偏移 (Fragment Offset)</strong> (13 bits)：表示该片段在原始数据报文中的相对位置，以 8 字节为单位。</li>
<li><strong>生存时间 (Time To Live - TTL)</strong> (8 bits)：数据报文在网络中可以经过的最大跳数（路由器数）。每经过一个路由器，TTL 值减 1。当 TTL 减到 0 时，路由器会丢弃该数据报文并返回一个 ICMP 错误，防止数据报文在网络中无限循环。</li>
<li><strong>协议 (Protocol)</strong> (8 bits)：标识数据部分承载的上层协议类型，例如：<ul>
<li><code>1</code>：ICMP (Internet Control Message Protocol)</li>
<li><code>6</code>：TCP (Transmission Control Protocol)</li>
<li><code>17</code>：UDP (User Datagram Protocol)</li>
</ul>
</li>
<li><strong>头部校验和 (Header Checksum)</strong> (16 bits)：仅对 IPv4 头部进行校验，确保头部在传输过程中没有损坏。每经过一个路由器，TTL 会改变，校验和也必须重新计算。</li>
<li><strong>源 IP 地址 (Source IP Address)</strong> (32 bits)：发送数据报文的设备的 IP 地址。</li>
<li><strong>目的 IP 地址 (Destination IP Address)</strong> (32 bits)：接收数据报文的设备的 IP 地址。</li>
<li><strong>选项 (Options)</strong> (0-40 字节)：不常用，用于扩展 IPv4 头部功能，例如记录路径、时间戳等。</li>
<li><strong>填充 (Padding)</strong>：如果选项字段的长度不足 32 位字的倍数，会用 0 填充到 32 位字的倍数，以保证头部长度是 32 位字的整数倍。</li>
</ul>
<h2 id="四、IP-地址的获取方式"><a href="#四、IP-地址的获取方式" class="headerlink" title="四、IP 地址的获取方式"></a>四、IP 地址的获取方式</h2><p>设备获取 IP 地址主要有以下几种方式：</p>
<ol>
<li><strong>静态配置 (Static IP)</strong>：手动为设备配置 IP 地址、子网掩码、默认网关和 DNS 服务器。适用于服务器、路由器等需要固定地址的设备。</li>
<li><strong>DHCP (Dynamic Host Configuration Protocol)</strong>：动态主机配置协议。客户端设备在启动时自动向 DHCP 服务器请求 IP 地址和其他网络配置信息。这是大多数普通用户设备（PC、手机）获取 IP 地址的方式。</li>
<li><strong>PPPoE (Point-to-Point Protocol over Ethernet)</strong>：以太网上的点对点协议。通常用于 ADSL 或光纤宽带拨号上网，通过用户名和密码进行认证，然后由运营商分配公共 IP 地址。</li>
</ol>
<h2 id="五、IPv4-路由"><a href="#五、IPv4-路由" class="headerlink" title="五、IPv4 路由"></a>五、IPv4 路由</h2><p>IP 路由是根据目标 IP 地址选择数据包转发路径的过程。</p>
<ol>
<li><strong>直接连接网络</strong>：如果数据包的目的 IP 地址与发送设备在同一个子网内，设备会直接通过二层协议（如 ARP 解析 MAC 地址）将数据包发送给目标设备。</li>
<li><strong>间接连接网络</strong>：如果目的 IP 地址不在本子网内，发送设备会将数据包发送给<strong>默认网关 (Default Gateway)</strong> (通常是局域网中的路由器)。</li>
<li><strong>路由器转发</strong>：路由器接收到数据包后，会查询其<strong>路由表 (Routing Table)</strong>。路由表包含了目的地网络和到达该目的地的下一跳 (Next Hop) 地址的映射关系。<ul>
<li>如果找到匹配的路由，路由器会将数据包转发给下一跳路由器。</li>
<li>如果找不到特定匹配，路由器会发送给默认路由（如果有配置）。</li>
<li>如果都找不到，数据包将被丢弃。</li>
</ul>
</li>
<li><strong>TTL 机制</strong>：TTL 字段确保数据包不会在网络中无限循环，一旦 TTL 归零即被丢弃。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    ClientA[&quot;Client A (192.168.1.10&#x2F;24)&quot;] --&gt; L2SwitchA[L2 Switch A]
    ServerB[&quot;Server B (192.168.1.20&#x2F;24)&quot;] --&gt; L2SwitchA

    ClientC[&quot;Client C (10.0.0.10&#x2F;8)&quot;] --&gt; L2SwitchB[L2 Switch B]
    ServerD[&quot;Server D (10.0.0.20&#x2F;8)&quot;] --&gt; L2SwitchB

    L2SwitchA --- RouterA[&quot;Router A (GW: 192.168.1.1)&quot;]
    L2SwitchB --- RouterB[&quot;Router B (GW: 10.0.0.1)&quot;]

    RouterA --- Internet[Internet &#x2F; Core Router]
    RouterB --- Internet

    subgraph &quot;Network 1 (192.168.1.0&#x2F;24)&quot;
        ClientA
        ServerB
        L2SwitchA
        RouterA
    end

    subgraph &quot;Network 2 (10.0.0.0&#x2F;8)&quot;
        ClientC
        ServerD
        L2SwitchB
        RouterB
    end
  
    ClientA -- PING 192.168.1.20 --&gt; ServerB
    ClientA -- PING 10.0.0.10 (跨网络) --&gt; RouterA
    RouterA -- Forward --&gt; Internet
    Internet -- Forward --&gt; RouterB
    RouterB -- Forward --&gt; ClientC
  
    style RouterA fill:#DAE8FC,stroke:#1E90FF,stroke-width:2px;
    style RouterB fill:#DAE8FC,stroke:#1E90FF,stroke-width:2px;
  </pre></div>

<h2 id="六、IPv4-地址枯竭问题"><a href="#六、IPv4-地址枯竭问题" class="headerlink" title="六、IPv4 地址枯竭问题"></a>六、IPv4 地址枯竭问题</h2><p>IPv4 地址空间总共只有约 4.3 亿个地址。随着互联网用户的爆炸式增长以及物联网设备的不断涌现，IPv4 地址的枯竭问题日益严重。虽然 NAT 技术在一定程度上缓解了这个问题，但它并非长久之计，且增加了网络复杂性。</p>
<p><strong>解决策略：</strong></p>
<ol>
<li><strong>CIDR (Classless Inter-Domain Routing)</strong>：无类别域间路由，取代了传统的 A&#x2F;B&#x2F;C 类地址划分，允许更灵活地分配 IP 地址块，有效提高了地址利用率。</li>
<li><strong>NAT (Network Address Translation)</strong>：网络地址转换，允许多个私有 IP 地址的设备共享少数几个公共 IP 地址访问互联网。</li>
<li><strong>IPv6 (Internet Protocol version 6)</strong>：提供 128 位地址空间，理论上地址数量为 $2^{128}$，旨在彻底解决 IPv4 地址枯竭问题，并提供更优的功能。目前 IPv4 和 IPv6 正在共存并逐步过渡。</li>
</ol>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>IPv4 作为互联网的核心协议，成功地支撑了全球信息网络的蓬勃发展。它通过 32 位的逻辑地址和健全的路由机制，实现了全球范围内的设备互联。尽管面临地址枯竭的挑战，并逐渐被 IPv6 所替代，但深入理解 IPv4 的地址结构、子网划分、报文格式和路由原理，依然是所有网络工程师和开发者掌握网络基础知识的基石。在很长一段时间内，IPv4 仍将与 IPv6 并存，共同构成我们所依赖的互联网。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/6b3b0892e720/">https://blog.tbf1211.xx.kg/6b3b0892e720/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/">网络技术</a><a class="post-meta__tags" href="/tags/2024/">2024</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-24.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2d02d2ae2866/" title="PostCSS详解：一个用JavaScript转换CSS的工具"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-31.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">PostCSS详解：一个用JavaScript转换CSS的工具</div></div><div class="info-2"><div class="info-item-1"> PostCSS 是一个使用 JavaScript 工具和插件来转换 CSS 代码的平台。它本身不是一个 CSS 预处理器（如 Sass、Less），也不是一个 CSS 后处理器，而是一个CSS 处理引擎。它的强大之处在于其插件生态系统，能够让你根据需求自定义 CSS 的转换流程。  PostCSS 的核心理念：提供 CSS 的 AST (Abstract Syntax Tree)，让开发者可以通过插件以 JavaScript 的强大能力处理 CSS。   一、什么是 PostCSS？想象一下，你有一个工具箱，里面有各种功能不同的螺丝刀、扳手、锤子。PostCSS 就是这个工具箱本身，它提供了一个开放的结构，你可以往里面放各种插件（工具）。每个插件都负责一个特定的任务，比如给 CSS 属性自动添加浏览器前缀、将未来的 CSS 语法转换为当前可用的语法、优化 CSS 代码等等。 PostCSS 的工作流程大致如下：  解析 (Parse)：PostCSS 接收原始 CSS 代码字符串。 生成 AST (Abstract Syntax Tree)：将 CSS 代码解析成一个抽象语法树...</div></div></div></a><a class="pagination-related" href="/dec2dcdddd31/" title="单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解</div></div><div class="info-2"><div class="info-item-1"> 在计算机网络中，数据包从一个源发送到多个目的地的策略被称为通信模式。理解这些模式——单播 (Unicast)、组播 (Multicast)、广播 (Broadcast) 和任播 (Anycast)——对于网络设计、数据传输优化以及故障排除至关重要。它们定义了数据如何寻址和如何在网络中传播，各自适用于不同的应用场景，并对网络性能和资源消耗有着显著影响。  核心思想：根据数据包的目的地数量和选择策略，将网络通信划分为四种基本模式，每种模式都有其独特的传输效率、资源利用和应用场景。   一、传输模式概述   传输模式 描述 接收方数量 IP 地址类型 传输效率 主要应用    单播 一对一传输。最常见的模式。 1 普通 IP 地址 高 (点对点) HTTP, TCP, Telnet, SSH, FTP   广播 一对所有传输，限于同一广播域内。 所有 广播地址 (255.255.255.255) 低 (网络泛洪) ARP, DHCP, OLPC, 唤醒局域网   组播 一对多传输，发送给特定组中的成员。 多个 组播地址 (224.0.0.0/4) 高 (路由支持) 视频直播, 在线游...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dec2dcdddd31/" title="单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-14</div><div class="info-item-2">单播、组播、广播、任播 (Unicast, Multicast, Broadcast, Anycast) 详解</div></div><div class="info-2"><div class="info-item-1"> 在计算机网络中，数据包从一个源发送到多个目的地的策略被称为通信模式。理解这些模式——单播 (Unicast)、组播 (Multicast)、广播 (Broadcast) 和任播 (Anycast)——对于网络设计、数据传输优化以及故障排除至关重要。它们定义了数据如何寻址和如何在网络中传播，各自适用于不同的应用场景，并对网络性能和资源消耗有着显著影响。  核心思想：根据数据包的目的地数量和选择策略，将网络通信划分为四种基本模式，每种模式都有其独特的传输效率、资源利用和应用场景。   一、传输模式概述   传输模式 描述 接收方数量 IP 地址类型 传输效率 主要应用    单播 一对一传输。最常见的模式。 1 普通 IP 地址 高 (点对点) HTTP, TCP, Telnet, SSH, FTP   广播 一对所有传输，限于同一广播域内。 所有 广播地址 (255.255.255.255) 低 (网络泛洪) ARP, DHCP, OLPC, 唤醒局域网   组播 一对多传输，发送给特定组中的成员。 多个 组播地址 (224.0.0.0/4) 高 (路由支持) 视频直播, 在线游...</div></div></div></a><a class="pagination-related" href="/ba096d7d0780/" title="虚拟局域网 (VLAN) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-06</div><div class="info-item-2">虚拟局域网 (VLAN) 详解</div></div><div class="info-2"><div class="info-item-1"> 虚拟局域网 (VLAN - Virtual Local Area Network) 是一种在物理上共享同一网络基础设施（如交换机、网线）的局域网中，通过逻辑划分而不是物理划分来创建多个独立广播域的技术。它允许网络管理员将一个物理局域网划分成多个逻辑上独立的网络，每个 VLAN 都是一个独立的广播域。VLAN 技术是现代企业网络设计中不可或缺的组成部分，它极大地增强了网络的安全性、性能、灵活性和可管理性。  核心思想：在不改变物理连接的情况下，将一个物理交换机划分出多个逻辑隔离的广播域，实现设备间的逻辑分段通信。   一、什么是 VLAN？在传统的以太网中，所有连接到同一个交换机或集线器的设备都属于同一个广播域 (Broadcast Domain)。这意味着当任何一台设备发送一个广播帧（例如 ARP 请求），这个广播帧会到达该域内的所有其他设备。随着网络规模的扩大，广播流量会显著增加，导致网络性能下降并带来安全隐患。 VLAN 技术应运而生，它通过在数据链路层（OSI 模型第二层）对以太网帧进行标识和处理，从而实现：  逻辑隔离：即使设备物理上连接在同一台交换机上，如果它们属于不...</div></div></div></a><a class="pagination-related" href="/62ea6394243a/" title="RPC(Remote Procedure Call)远程过程调用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="info-item-2">RPC(Remote Procedure Call)远程过程调用详解</div></div><div class="info-2"><div class="info-item-1"> RPC (Remote Procedure Call)，即远程过程调用，是一种分布式计算技术，它允许程序调用位于不同地址空间（通常是不同计算机上）的子程序或函数，就像调用本地子程序一样。RPC 屏蔽了底层网络通信的复杂性，让开发者可以专注于业务逻辑，提高开发效率。  核心思想： RPC 的目标是透明化 (Transparency) 远程服务的调用过程，让客户端感觉就像在调用本地方法，而实际上调用的请求被序列化并通过网络传输到远程服务，远程服务执行后将结果序列化并返回给客户端。   一、为什么需要 RPC？在传统的单体应用中，所有功能都运行在同一个进程中，方法调用直接发生在内存中。然而，随着业务复杂性和系统规模的增长，单体应用面临诸多挑战：  扩展性差：难以针对不同模块的负载压力独立扩展。 开发效率低：团队协作困难，代码冲突多。 容错性差：单个模块故障可能导致整个系统崩溃。 技术栈限制：难以在不同模块中使用最佳技术栈。  为了解决这些问题，系统架构逐渐向分布式系统和微服务架构演进。在这种架构中，一个大型应用被拆分成多个独立的服务，每个服务运行在不同的进程中，甚至不同的物理机器上。...</div></div></div></a><a class="pagination-related" href="/19a6c2b992d7/" title="IPv6 (Internet Protocol Version 6) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">IPv6 (Internet Protocol Version 6) 详解</div></div><div class="info-2"><div class="info-item-1"> IPv6 (Internet Protocol Version 6) 是互联网协议 (IP) 的最新版本，旨在取代其前身 IPv4。它解决了 IPv4 长期存在的地址枯竭问题，并引入了多项设计改进，以更好地适应现代互联网的需求，包括支持更简单的头部处理、增强的安全性、更好的服务质量 (QoS) 和更强大的移动性功能。  核心思想：从根本上解决 IPv4 地址短缺问题，同时优化协议设计，为万物互联 (IoT)、5G 和未来网络应用提供坚实基础。    一、为什么需要 IPv6？IPv4 (Internet Protocol Version 4) 作为互联网的核心协议已成功运行数十年，但随着互联网的爆炸式增长，其固有的设计局限性日益凸显：  地址枯竭 (Address Exhaustion)：IPv4 地址空间为 32 位，最多有约 43 亿个地址。尽管采取了无类别域间路由 (CIDR) 和网络地址转换 (NAT) 等技术来延缓地址枯竭，但根源问题并未解决。全球各区域的 IPv4 地址池已基本分配完毕，成为互联网进一步发展的瓶颈。 NAT 的复杂性与限制：网络地址转换 (NAT) ...</div></div></div></a><a class="pagination-related" href="/e95632ff76ac/" title="gRPC 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="info-item-2">gRPC 详解</div></div><div class="info-2"><div class="info-item-1"> gRPC (Google Remote Procedure Call) 是由 Google 开发的一款高性能、开源的通用 RPC 框架。它基于 HTTP&#x2F;2 协议，并使用 Protocol Buffers (Protobuf) 作为其接口定义语言 (IDL) 和消息序列化协议。gRPC 旨在提供一种语言中立、平台中立、高效且可扩展的方式来连接服务，非常适合微服务架构中的服务间通信。  核心思想： gRPC 结合了 HTTP&#x2F;2 的多路复用和二进制帧特性，以及 Protobuf 的高效序列化，旨在实现比传统 RESTful API 更低的延迟、更高的吞吐量，并提供强类型接口和多种服务交互模型（如流式 RPC）。   一、为什么需要 gRPC？传统的基于 HTTP&#x2F;1.1 和 JSON&#x2F;XML 的 RESTful API 在以下方面存在一些局限性：  性能开销： HTTP&#x2F;1.1 的队头阻塞：每个请求需要独立的 TCP 连接或通过连接复用，但存在队头阻塞问题。 文本协议 (JSON&#x2F;XML)：数据量大，解析开销高，效率相对...</div></div></div></a><a class="pagination-related" href="/da4a047de713/" title="中国电信 CN2 网络详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="info-item-2">中国电信 CN2 网络详解</div></div><div class="info-2"><div class="info-item-1"> CN2 (ChinaNet Next Generation Carrying Network)，即中国电信下一代承载网络，是中国电信于 2005 年推出的新一代骨干网络。它旨在提供高质量、高可靠、低延迟的网络服务，主要面向政府、企业和高端个人用户。CN2 与传统的 ChinaNet (AS4134，163骨干网) 在架构和技术上都有显著区别，以提供更优质的国际互联体验。  核心思想：将互联网流量分为“优质”和“普通”两类通道，CN2 提供优质通道，通过更少的跳数、更小的丢包率和更低的延迟，显著提升国际互联的稳定性和速度。   一、为什么需要 CN2？1.1 ChinaNet (163骨干网) 的局限性传统的中国电信互联网骨干网，通常被称为 163 网（因其 AS 号为 4134，而 163 是其常用接入号），是国内用户最广泛使用的网络。然而，163 网在国际互联方面存在一些固有的问题：  链路拥堵：作为最常用的骨干网，163 网承载了大量流量，尤其在国际出口处容易出现拥堵，导致延迟高、丢包率大。 路由跳数多：在国际互联时，163 网的路由路径通常较长，经过的中间节点和运营商较多...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">545</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">230</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">84</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-IPv4%EF%BC%9F"><span class="toc-text">一、什么是 IPv4？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IPv4-%E5%9C%B0%E5%9D%80"><span class="toc-text">二、IPv4 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">2.1 地址结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86%E5%92%8C%E4%B8%BB%E6%9C%BA%E9%83%A8%E5%88%86"><span class="toc-text">2.2 IP 地址的组成：网络部分和主机部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81-Subnet-Mask"><span class="toc-text">2.3 子网掩码 (Subnet Mask)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E5%92%8C%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-text">2.4 网络地址和广播地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-IP-%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB-%E5%8E%86%E5%8F%B2%E9%81%97%E7%95%99"><span class="toc-text">2.5 IP 地址分类 (历史遗留)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%A7%81%E6%9C%89-IP-%E5%9C%B0%E5%9D%80%E5%92%8C%E5%85%AC%E5%85%B1-IP-%E5%9C%B0%E5%9D%80"><span class="toc-text">2.6 私有 IP 地址和公共 IP 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E7%89%B9%E6%AE%8A%E7%9A%84-IPv4-%E5%9C%B0%E5%9D%80"><span class="toc-text">2.7 特殊的 IPv4 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81IPv4-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">三、IPv4 数据报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-text">四、IP 地址的获取方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81IPv4-%E8%B7%AF%E7%94%B1"><span class="toc-text">五、IPv4 路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81IPv4-%E5%9C%B0%E5%9D%80%E6%9E%AF%E7%AB%AD%E9%97%AE%E9%A2%98"><span class="toc-text">六、IPv4 地址枯竭问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/10349b09ff78/" title="Signal Protocol 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Signal Protocol 详解"/></a><div class="content"><a class="title" href="/10349b09ff78/" title="Signal Protocol 详解">Signal Protocol 详解</a><time datetime="2026-02-03T22:24:00.000Z" title="发表于 2026-02-04 06:24:00">2026-02-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECMAScript ShadowRealm 详解"/></a><div class="content"><a class="title" href="/f81355a662b8/" title="ECMAScript ShadowRealm 详解">ECMAScript ShadowRealm 详解</a><time datetime="2026-02-01T22:24:00.000Z" title="发表于 2026-02-02 06:24:00">2026-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/88fea7b52158/" title="Gzip 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-32.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gzip 详解"/></a><div class="content"><a class="title" href="/88fea7b52158/" title="Gzip 详解">Gzip 详解</a><time datetime="2026-01-29T22:24:00.000Z" title="发表于 2026-01-30 06:24:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解"/></a><div class="content"><a class="title" href="/8fc7e3e72510/" title="前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解">前端渲染模式：CSR, SSR, SSG, ISR, DPR 详解</a><time datetime="2026-01-27T22:24:00.000Z" title="发表于 2026-01-28 06:24:00">2026-01-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5341a0037256/" title="CSS-in-JS 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS-in-JS 详解"/></a><div class="content"><a class="title" href="/5341a0037256/" title="CSS-in-JS 详解">CSS-in-JS 详解</a><time datetime="2026-01-25T22:24:00.000Z" title="发表于 2026-01-26 06:24:00">2026-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-24.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (false) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.4"></script></div></div></body></html>