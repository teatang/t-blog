<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AWS Lambda与Serverless详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AWS Lambda 是亚马逊网络服务 (Amazon Web Services, AWS) 提供的核心 Serverless 计算服务，也是函数即服务 (Function-as-a-Service, FaaS) 的开创者和领导者。它允许开发者运行代码，而无需配置或管理服务器。开发者只需上传代码，Lambda 会自动处理运行代码所需的一切，包括容量预置、扩展、打补丁和维护。  核心思想：AWS">
<meta property="og:type" content="article">
<meta property="og:title" content="AWS Lambda与Serverless详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/6842deb76626/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="AWS Lambda 是亚马逊网络服务 (Amazon Web Services, AWS) 提供的核心 Serverless 计算服务，也是函数即服务 (Function-as-a-Service, FaaS) 的开创者和领导者。它允许开发者运行代码，而无需配置或管理服务器。开发者只需上传代码，Lambda 会自动处理运行代码所需的一切，包括容量预置、扩展、打补丁和维护。  核心思想：AWS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg">
<meta property="article:published_time" content="2024-01-12T22:24:00.000Z">
<meta property="article:modified_time" content="2026-01-14T10:02:47.450Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2024">
<meta property="article:tag" content="Serverless">
<meta property="article:tag" content="云服务">
<meta property="article:tag" content="AWS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AWS Lambda与Serverless详解",
  "url": "https://blog.tbf1211.xx.kg/6842deb76626/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-15.jpg",
  "datePublished": "2024-01-12T22:24:00.000Z",
  "dateModified": "2026-01-14T10:02:47.450Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/6842deb76626/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AWS Lambda与Serverless详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">494</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-15.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">AWS Lambda与Serverless详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li><li><a class="site-page child" href="/archives/2026/"><i class="fa-fw fa-solid fa-code-branch"></i><span> 2026</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">AWS Lambda与Serverless详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-01-12T22:24:00.000Z" title="发表于 2024-01-13 06:24:00">2024-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>AWS Lambda</strong> 是亚马逊网络服务 (Amazon Web Services, AWS) 提供的<strong>核心 Serverless 计算服务</strong>，也是<strong>函数即服务 (Function-as-a-Service, FaaS)</strong> 的开创者和领导者。它允许开发者运行代码，而无需配置或管理服务器。开发者只需上传代码，Lambda 会自动处理运行代码所需的一切，包括容量预置、扩展、打补丁和维护。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>AWS Lambda 是 AWS Serverless 生态的核心，它将代码作为“函数”运行在无服务器环境中，由各种 AWS 事件触发，按需执行，自动伸缩，并按实际使用量计费。</strong></p>
</div>
<hr>
<h2 id="一、AWS-Lambda-概览"><a href="#一、AWS-Lambda-概览" class="headerlink" title="一、AWS Lambda 概览"></a>一、AWS Lambda 概览</h2><p>AWS Lambda 于 2014 年推出，彻底改变了云计算的开发和部署模式。它让开发者能够将后端逻辑解耦为一系列独立、短生命周期的函数，从而极大地简化了运维。</p>
<h3 id="1-1-Lambda-的核心概念"><a href="#1-1-Lambda-的核心概念" class="headerlink" title="1.1 Lambda 的核心概念"></a>1.1 Lambda 的核心概念</h3><ol>
<li><strong>函数 (Function)</strong>：这是 Lambda 中的基本部署单元，包含你的代码和相关配置（如运行时、内存、超时时间、环境变量）。</li>
<li><strong>事件 (Event)</strong>：触发 Lambda 函数执行的任何操作。事件源可以是 AWS 服务（如 S3 文件上传、DynamoDB 变更流、API Gateway HTTP 请求）或自定义事件。</li>
<li><strong>运行时 (Runtime)</strong>：Lambda 支持多种编程语言的运行时环境，例如 Node.js, Python, Java, C#, Go, Ruby。你也可以使用 <strong>自定义运行时</strong> 来运行任何语言的代码。</li>
<li><strong>并发 (Concurrency)</strong>：Lambda 函数可以同时处理的请求数量。每个并发执行的函数实例都被称为一个“调用”。Lambda 默认提供大量并发，并可根据需要配置。</li>
<li><strong>内存 (Memory)</strong>：你为函数分配的内存量，从 128MB 到 10240MB。内存越多，可用的 CPU 份额通常也越多。</li>
<li><strong>超时 (Timeout)</strong>：函数允许运行的最长时间，从 1 秒到 15 分钟。</li>
<li><strong>触发器 (Trigger)</strong>：连接事件源和 Lambda 函数的配置。</li>
<li><strong>层 (Layers)</strong>：用于共享代码和依赖项的机制，方便跨多个函数重用。</li>
</ol>
<h3 id="1-2-Lambda-的工作原理"><a href="#1-2-Lambda-的工作原理" class="headerlink" title="1.2 Lambda 的工作原理"></a>1.2 Lambda 的工作原理</h3><ol>
<li><strong>代码上传</strong>：开发者编写代码（通常打包成 ZIP 文件），并将其上传到 Lambda。</li>
<li><strong>配置函数</strong>：开发者为函数配置运行时、内存、超时、触发器等。</li>
<li><strong>事件触发</strong>：当配置的事件源发生事件时（例如，用户通过 API Gateway 发送 HTTP 请求），Lambda 服务会接收到这个事件。</li>
<li><strong>创建执行环境</strong>：Lambda 会根据事件负载，快速启动一个执行环境（本质上是一个轻量级容器或 micro-VM）。如果已有空闲的执行环境，则会重用。</li>
<li><strong>代码执行</strong>：将事件数据注入到函数中，并执行函数代码。</li>
<li><strong>结果返回</strong>：函数执行完毕后，返回结果给调用者或事件源。</li>
<li><strong>资源释放&#x2F;保留</strong>：执行环境会在一段时间后被释放，或保留一段时间以备后续快速调用（减少冷启动）。</li>
</ol>
<div class="mermaid-wrap"><pre class="mermaid-src" data-config="{}" hidden>
    graph TD
    subgraph 开发者
        A[编写代码] --&gt; B[&quot;打包代码 (ZIP)&quot;]
        B --&gt; C[配置 Lambda 函数]
    end

    subgraph AWS Lambda 服务
        D[接收事件] --&gt; E{检查空闲执行环境}
        E -- 有 --&gt; F[重用环境]
        E -- 无 --&gt; G[&quot;创建新环境 (冷启动)&quot;]
        F --&gt; H[加载函数代码]
        G --&gt; H
        H --&gt; I[执行函数代码]
        I -- 结果&#x2F;日志 --&gt; J[返回结果 &#x2F; CloudWatch Logs]
    end

    subgraph &quot;事件源 (Trigger)&quot;
        K[API Gateway HTTP 请求] --&gt; D
        L[S3 文件上传] --&gt; D
        M[DynamoDB 流事件] --&gt; D
        N[SQS 消息] --&gt; D
        O[CloudWatch 定时任务] --&gt; D
        P[自定义事件] --&gt; D
    end
  </pre></div>

<h2 id="二、AWS-Lambda-的核心优势"><a href="#二、AWS-Lambda-的核心优势" class="headerlink" title="二、AWS Lambda 的核心优势"></a>二、AWS Lambda 的核心优势</h2><ol>
<li><strong>无服务器管理 (No Server Management)</strong>：AWS 完全负责底层基础设施的配置、维护、打补丁和扩展，开发者无需关心服务器。</li>
<li><strong>自动伸缩 (Automatic Scaling)</strong>：Lambda 会根据传入事件的流量自动扩展函数的并发实例，无需手动配置或预估容量。</li>
<li><strong>按实际使用付费 (Pay-per-Execution)</strong>：只为代码实际运行的时间（以毫秒计）、调用的次数和分配的内存付费。没有代码运行时，不收取费用。</li>
<li><strong>高可用性和容错性 (High Availability &amp; Fault Tolerance)</strong>：Lambda 默认在多个可用区 (Availability Zones) 中运行函数，提供内置的高可用性。</li>
<li><strong>事件驱动模型 (Event-Driven)</strong>：与丰富的 AWS 服务生态系统深度集成，可以响应各种事件。</li>
<li><strong>多语言支持</strong>：支持主流编程语言，并通过自定义运行时支持更多语言。</li>
</ol>
<h2 id="三、AWS-Lambda-的局限性与挑战"><a href="#三、AWS-Lambda-的局限性与挑战" class="headerlink" title="三、AWS Lambda 的局限性与挑战"></a>三、AWS Lambda 的局限性与挑战</h2><ol>
<li><strong>冷启动 (Cold Start)</strong>：当函数长时间未被调用，或第一次被调用时，Lambda 需要初始化执行环境并加载代码，这会导致额外的延迟。可以通过预置并发 (Provisioned Concurrency) 缓解。</li>
<li><strong>运行时限制</strong>：<ul>
<li><strong>最大执行时间</strong>：函数最长运行 15 分钟。</li>
<li><strong>内存限制</strong>：最大 10240MB (10GB)。</li>
<li><strong>包大小限制</strong>：未压缩代码包最大 50MB，压缩后最大 250MB (含层)。</li>
<li><strong>临时存储</strong>：每个函数有 512MB 的 <code>/tmp</code> 目录，可用于临时文件存储。</li>
</ul>
</li>
<li><strong>调试复杂性</strong>：分布式和事件驱动的特性使得在本地调试 Serverless 应用和模拟完整的 AWS 环境变得复杂。</li>
<li><strong>供应商锁定 (Vendor Lock-in)</strong>：Lambda 的 API 和生态系统与 AWS 深度绑定，迁移到其他云平台可能需要重构。</li>
<li><strong>成本不可预测性</strong>：虽然按需计费，但对于高并发、高流量且未经优化的函数，成本可能累积。</li>
<li><strong>状态管理</strong>：Lambda 函数是无状态的，如果需要持久化状态，必须依赖外部服务（如 DynamoDB, S3, RDS），增加了架构复杂性。</li>
<li><strong>网络和 VPC 集成</strong>：将 Lambda 函数部署到 VPC (Virtual Private Cloud) 以访问私有资源时，可能会增加冷启动时间。</li>
</ol>
<h2 id="四、AWS-Lambda-的典型应用场景"><a href="#四、AWS-Lambda-的典型应用场景" class="headerlink" title="四、AWS Lambda 的典型应用场景"></a>四、AWS Lambda 的典型应用场景</h2><ol>
<li><p><strong>Web 应用后端 &#x2F; RESTful API</strong>：结合 <strong>API Gateway</strong>，构建高性能、高可用的无服务器 API。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-lambda-go/events&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/aws/aws-lambda-go/lambda&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyEvent <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleRequest</span><span class="params">(ctx context.Context, event events.APIGatewayProxyRequest)</span></span> (events.APIGatewayProxyResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析请求体</span></span><br><span class="line">    <span class="keyword">var</span> req MyEvent</span><br><span class="line">    err := json.Unmarshal([]<span class="type">byte</span>(event.Body), &amp;req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> events.APIGatewayProxyResponse&#123;</span><br><span class="line">            StatusCode: <span class="number">400</span>,</span><br><span class="line">            Body:       <span class="string">&quot;Error parsing request body&quot;</span>,</span><br><span class="line">        &#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理业务逻辑</span></span><br><span class="line">    message := fmt.Sprintf(<span class="string">&quot;Hello, %s!&quot;</span>, req.Name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建响应</span></span><br><span class="line">    responseBody, _ := json.Marshal(MyResponse&#123;Message: message&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> events.APIGatewayProxyResponse&#123;</span><br><span class="line">        StatusCode: <span class="number">200</span>,</span><br><span class="line">        Headers:    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>&#125;,</span><br><span class="line">        Body:       <span class="type">string</span>(responseBody),</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lambda.Start(HandleRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>上述 Go 语言代码示例展示了一个简单的 Lambda 函数，它接收来自 API Gateway 的 HTTP 请求，解析 JSON 请求体，并返回一个 JSON 响应。</em></p>
</li>
<li><p><strong>实时文件处理</strong>：例如，当文件上传到 S3 存储桶时，自动触发 Lambda 函数进行图片缩放、视频转码、文档解析、病毒扫描等。</p>
</li>
<li><p><strong>数据变更处理</strong>：当 DynamoDB 表中的数据发生变化时，Lambda 函数可以订阅 DynamoDB Streams，实时处理变更，例如同步到其他数据库、触发通知。</p>
</li>
<li><p><strong>定时任务 (Cron Jobs)</strong>：结合 <strong>Amazon EventBridge (CloudWatch Events)</strong>，按计划定期触发 Lambda 函数，执行数据备份、报告生成、系统清理等任务。</p>
</li>
<li><p><strong>后端工作流编排</strong>：结合 <strong>AWS Step Functions</strong>，编排多个 Lambda 函数，构建复杂的、有状态的业务流程。</p>
</li>
<li><p><strong>物联网 (IoT) 后端</strong>：处理来自 IoT 设备的数据流，执行数据过滤、分析和存储。</p>
</li>
<li><p><strong>聊天机器人与语音助手</strong>：处理用户请求，调用后端逻辑，生成响应。</p>
</li>
<li><p><strong>ETL (Extract, Transform, Load)</strong>：进行数据抽取、转换和加载操作。</p>
</li>
</ol>
<h2 id="五、AWS-Lambda-的生态系统与相关服务"><a href="#五、AWS-Lambda-的生态系统与相关服务" class="headerlink" title="五、AWS Lambda 的生态系统与相关服务"></a>五、AWS Lambda 的生态系统与相关服务</h2><p>AWS Lambda 并不是孤立的服务，它与 AWS 的其他服务紧密集成，共同构建 Serverless 架构：</p>
<ul>
<li><strong>Amazon API Gateway</strong>：用于创建、发布、维护、监控和保护 REST、HTTP 和 WebSocket API。是 Web 应用前端调用 Lambda 的主要入口。</li>
<li><strong>Amazon S3 (Simple Storage Service)</strong>：对象存储服务，可作为 Lambda 的事件源（文件上传&#x2F;删除）和存储介质。</li>
<li><strong>Amazon DynamoDB</strong>：高性能、可扩展的 NoSQL 数据库，常用于存储 Lambda 函数的状态数据，并可作为 Lambda 的事件源（通过 DynamoDB Streams）。</li>
<li><strong>Amazon SQS (Simple Queue Service)</strong>：消息队列服务，用于异步处理和解耦系统组件，可作为 Lambda 的事件源。</li>
<li><strong>Amazon SNS (Simple Notification Service)</strong>：发布&#x2F;订阅消息服务，可作为 Lambda 的事件源或用于发送通知。</li>
<li><strong>Amazon EventBridge</strong>：无服务器事件总线，用于连接应用程序的各个部分，实现事件驱动架构，可作为 Lambda 的事件源（包括定时任务）。</li>
<li><strong>AWS Step Functions</strong>：无服务器工作流服务，用于编排多个 Lambda 函数和 AWS 服务，构建复杂的、有状态的业务流程。</li>
<li><strong>Amazon CloudWatch</strong>：监控和日志服务，用于收集 Lambda 函数的性能指标和日志。</li>
<li><strong>AWS X-Ray</strong>：分布式追踪服务，用于分析和调试 Serverless 应用中的请求流。</li>
<li><strong>AWS SAM (Serverless Application Model)</strong>：用于定义 Serverless 应用的开源框架，简化 Lambda、API Gateway 等资源的部署。</li>
<li><strong>AWS CDK (Cloud Development Kit)</strong>：使用流行编程语言定义云基础设施的框架，可以更灵活地定义和部署 Lambda 应用。</li>
</ul>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>AWS Lambda 作为 FaaS 的领导者，彻底改变了我们构建和部署应用程序的方式。它通过将基础设施管理从开发者手中解放出来，实现了前所未有的开发效率、弹性伸缩和成本效益。尽管存在冷启动和运行时限制等挑战，但通过结合 AWS 丰富的 Serverless 生态系统，开发者可以构建出强大、可扩展且经济高效的现代化应用程序。理解 Lambda 的核心概念、工作原理及其生态系统，对于拥抱 Serverless 架构和充分利用 AWS 云能力至关重要。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/6842deb76626/">https://blog.tbf1211.xx.kg/6842deb76626/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2024/">2024</a><a class="post-meta__tags" href="/tags/Serverless/">Serverless</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</a><a class="post-meta__tags" href="/tags/AWS/">AWS</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/3ba66d6aee4f/" title="Next.js 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Next.js 详解</div></div><div class="info-2"><div class="info-item-1"> Next.js 是一个基于 React 的 全栈 (Full-stack) Web 框架，由 Vercel 公司开发和维护。它提供了一个开箱即用的解决方案，用于构建高性能、SEO 友好且易于扩展的现代 React 应用程序。Next.js 最大的特点是支持 服务端渲染 (SSR)、静态网站生成 (SSG) 和 客户端渲染 (CSR) 等多种渲染方式，并集成了文件系统路由、API 路由、图片优化、代码分割等诸多功能，极大地提升了开发者体验和应用性能。  核心思想：Next.js 是一个强大的 React 框架，通过多种渲染策略（SSR、SSG、CSR），优化的开发体验和内置功能，帮助开发者高效构建高性能、可扩展的现代 Web 应用。   一、为什么选择 Next.js？React 本身是一个用于构建用户界面的库，它通常在客户端运行 (CSR)。然而，纯客户端渲染的应用存在一些缺点：  SEO 不友好：搜索引擎爬虫可能无法完全索引动态生成的页面内容。 首次加载性能：用户需要等待 JavaScript 下载、解析和执行后才能看到内容，导致白屏时间较长。 Bundle Size：需要将...</div></div></div></a><a class="pagination-related" href="/f5c29582f368/" title="Serverless 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Serverless 详解</div></div><div class="info-2"><div class="info-item-1"> Serverless (无服务器) 是一种云计算的执行模型，它允许开发者构建和运行应用程序而无需管理服务器。在这种模型下，云服务提供商负责服务器的调配、维护和扩展，开发者只需关注自己的代码逻辑。Serverless 并不是指“没有服务器”，而是指“开发者不需要关心服务器”。它通常包含两种核心服务模式：函数即服务 (Function-as-a-Service, FaaS) 和 后端即服务 (Backend-as-a-Service, BaaS)。  核心思想：将基础设施管理完全交给云服务商，开发者只需编写代码并部署，按实际使用量付费，实现极致的弹性伸缩和降低运维成本。   一、为什么需要 Serverless？传统的应用部署模型（物理机、虚拟机、容器）都需要开发者或运维团队投入大量精力进行服务器管理：  资源调配：预估并配置合适的 CPU、内存、存储。 操作系统管理：安装、打补丁、更新。 运行时环境：安装语言运行时、库、依赖。 扩展性：根据流量变化手动或自动伸缩服务器集群。 高可用性：设置负载均衡、故障转移机制。 监控与日志：部署监控 agent，收集日志。  这些“非功能性需求...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/c645d233e96b/" title="Vercel.json详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-11</div><div class="info-item-2">Vercel.json详解</div></div><div class="info-2"><div class="info-item-1"> vercel.json 是 Vercel 平台的核心配置文件，它允许开发者对项目的部署行为、路由规则、Serverless Functions 配置、环境变量、构建过程等进行细粒度的控制。通过 vercel.json，你可以超越 Vercel 的默认零配置行为，根据项目的特定需求定制化部署策略。  核心思想：vercel.json 是一个 JSON 文件，用于声明 Vercel 项目的各种配置，包括路由重写、重定向、HTTP Headers、Serverless Functions 设置、构建步骤和环境变量等，从而实现高级部署功能和优化。   一、vercel.json 的基本结构与作用vercel.json 文件通常位于项目的根目录下。Vercel 在每次部署时会读取这个文件，并根据其中的配置来处理构建、路由和请求。 一个典型的 vercel.json 结构如下： 123456789101112131415&#123;  &quot;version&quot;: 2,  &quot;name&quot;: &quot;my-vercel-project&quot;,  &qu...</div></div></div></a><a class="pagination-related" href="/f5c29582f368/" title="Serverless 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="info-item-2">Serverless 详解</div></div><div class="info-2"><div class="info-item-1"> Serverless (无服务器) 是一种云计算的执行模型，它允许开发者构建和运行应用程序而无需管理服务器。在这种模型下，云服务提供商负责服务器的调配、维护和扩展，开发者只需关注自己的代码逻辑。Serverless 并不是指“没有服务器”，而是指“开发者不需要关心服务器”。它通常包含两种核心服务模式：函数即服务 (Function-as-a-Service, FaaS) 和 后端即服务 (Backend-as-a-Service, BaaS)。  核心思想：将基础设施管理完全交给云服务商，开发者只需编写代码并部署，按实际使用量付费，实现极致的弹性伸缩和降低运维成本。   一、为什么需要 Serverless？传统的应用部署模型（物理机、虚拟机、容器）都需要开发者或运维团队投入大量精力进行服务器管理：  资源调配：预估并配置合适的 CPU、内存、存储。 操作系统管理：安装、打补丁、更新。 运行时环境：安装语言运行时、库、依赖。 扩展性：根据流量变化手动或自动伸缩服务器集群。 高可用性：设置负载均衡、故障转移机制。 监控与日志：部署监控 agent，收集日志。  这些“非功能性需求...</div></div></div></a><a class="pagination-related" href="/cc0334bd16dd/" title="Vercel介绍"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-10.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">Vercel介绍</div></div><div class="info-2"><div class="info-item-1"> Vercel 是一家领先的前端云 (Frontend Cloud) 平台，专注于为前端开发者提供极速的部署、自动化的CI&#x2F;CD、全球化的内容分发 (CDN) 和 Serverless 功能。它以其与 Next.js 框架的深度集成而闻名，旨在帮助开发者以最快速度将 Web 项目从构思变为全球可用的产品，同时提供卓越的性能和开发者体验。  核心思想：Vercel 是一个将前端部署、构建、Hosting 和 Serverless 后端能力融为一体的平台，特别优化了 Next.js 等现代化框架的开发和部署流程，让开发者能够专注于代码，无需管理基础设施。   一、为什么选择 Vercel？在现代 Web 开发中，前端项目的部署和运维变得越来越复杂：  构建优化：代码打包、压缩、Tree Shaking。 性能优化：CDN 分发、图片优化、SEO 优化。 开发体验：持续集成&#x2F;持续部署 (CI&#x2F;CD)、预览部署、分支管理。 后端需求：API 路由、Server-Side Rendering (SSR)、数据获取等，需要 Serverless 或 Node.j...</div></div></div></a><a class="pagination-related" href="/487df70cf615/" title="Vercel Serverless Functions 深度详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-04.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="info-item-2">Vercel Serverless Functions 深度详解</div></div><div class="info-2"><div class="info-item-1"> Vercel Serverless Functions 是 Vercel 平台的核心服务之一，它允许开发者部署并运行后端代码，而无需管理任何服务器基础设施。这些函数是轻量级的、按需执行的计算单元，能够根据流量自动扩缩容，并天然集成到 Vercel 的全球 CDN 和部署工作流中。Vercel Functions 不仅为 Next.js 提供了强大的 API 路由支持，还允许开发者使用多种编程语言（如 Node.js, Python, Go, Ruby 等）构建独立的后端服务。  核心思想：Vercel Serverless Functions 提供了一种高效、自动扩缩容的无状态计算环境，使开发者能够将后端逻辑作为独立的函数部署到 Vercel 的全球边缘网络。其核心优势在于与前端框架的无缝集成、多语言支持、自动管理基础设施，并通过 Git 驱动的部署流程，极大地简化了全栈应用的开发和运维。   一、Vercel Serverless Functions 概览1.1 核心概念 无服务器 (Serverless)：你无需预置或管理任何服务器。Vercel 负责所有基础设施的配置、维...</div></div></div></a><a class="pagination-related" href="/1165e3e15519/" title="边缘计算 (Edge Computing) 详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-05</div><div class="info-item-2">边缘计算 (Edge Computing) 详解</div></div><div class="info-2"><div class="info-item-1"> 边缘计算 (Edge Computing) 是一种分布式计算范式，它将计算和数据存储能力从集中式的云数据中心下沉到网络的边缘，即数据源或数据源附近。其核心思想是在数据产生的地方进行数据处理、分析和存储，而不是将所有数据都传输到远程的云端进行处理。这种模式旨在解决云计算在延迟、带宽、隐私和可靠性方面面临的挑战，特别是在物联网 (IoT)、5G 和人工智能 (AI) 等新兴技术驱动下，变得越来越重要。  核心思想：将计算能力推向数据源头，在网络边缘就近处理数据，以降低延迟、节省带宽、增强隐私和提高可靠性。   一、为什么需要边缘计算？传统的云计算模型将数据发送到远程数据中心进行处理。随着物联网设备的爆炸式增长、5G 网络的高速发展以及AI应用对实时性的高要求，这种中心化的模式暴露出以下问题：  高延迟 (High Latency)：数据从边缘设备传输到云端，再从云端返回，需要较长时间。对于自动驾驶、工业自动化、远程医疗等实时性要求极高的应用，几毫秒的延迟都可能造成严重后果。 带宽限制与成本 (Bandwidth Constraints &amp; Cost)：物联网设备产生海量数据...</div></div></div></a><a class="pagination-related" href="/3aa9e4c628f2/" title="在 Vercel 开发 Next.js 应用详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-12</div><div class="info-item-2">在 Vercel 开发 Next.js 应用详解</div></div><div class="info-2"><div class="info-item-1"> Vercel 是 Next.js 的创建者，也是一个领先的云平台，专为部署和扩展 Web 应用程序而设计，特别是针对 Next.js 应用。它提供了一站式的开发、预览和部署工作流，集成了 Git 仓库，并支持无服务器功能、全球 CDN、自动 SSL 等，极大地简化了 Next.js 应用的部署和管理。  核心思想：在 Vercel 上开发 Next.js 应用，核心在于利用 Vercel 与 Next.js 的深度集成，实现从代码提交到全球部署的自动化工作流。这包括使用 Next.js 的特性（如数据获取、API 路由），配置 Vercel 项目，利用其预览部署、环境变量、无服务器函数等功能，实现高效且可扩展的开发和部署。   一、Next.js 基础在深入 Vercel 之前，确保你对 Next.js 的核心概念有所了解：  文件系统路由 (File-system Routing)：根据 pages (或 app 目录) 目录结构自动生成路由。 数据获取 (Data Fetching)： getServerSideProps (SSR): 服务端渲染，每次请求生成页面。 ge...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">494</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">225</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">83</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81AWS-Lambda-%E6%A6%82%E8%A7%88"><span class="toc-text">一、AWS Lambda 概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Lambda-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 Lambda 的核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Lambda-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.2 Lambda 的工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81AWS-Lambda-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="toc-text">二、AWS Lambda 的核心优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81AWS-Lambda-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E6%8C%91%E6%88%98"><span class="toc-text">三、AWS Lambda 的局限性与挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81AWS-Lambda-%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">四、AWS Lambda 的典型应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81AWS-Lambda-%E7%9A%84%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1"><span class="toc-text">五、AWS Lambda 的生态系统与相关服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fa3d796f3333/" title="MessagePack 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-08.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessagePack 详解"/></a><div class="content"><a class="title" href="/fa3d796f3333/" title="MessagePack 详解">MessagePack 详解</a><time datetime="2026-01-08T22:24:00.000Z" title="发表于 2026-01-09 06:24:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传统命令行工具的现代补强与替代方案详解"/></a><div class="content"><a class="title" href="/82bf00e3828f/" title="传统命令行工具的现代补强与替代方案详解">传统命令行工具的现代补强与替代方案详解</a><time datetime="2026-01-06T22:24:00.000Z" title="发表于 2026-01-07 06:24:00">2026-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IPC (Inter-Process Communication) 详解"/></a><div class="content"><a class="title" href="/cecf96486ef4/" title="IPC (Inter-Process Communication) 详解">IPC (Inter-Process Communication) 详解</a><time datetime="2026-01-04T22:24:00.000Z" title="发表于 2026-01-05 06:24:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3059cdc5f529/" title="Golang sqlc 框架详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-07.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang sqlc 框架详解"/></a><div class="content"><a class="title" href="/3059cdc5f529/" title="Golang sqlc 框架详解">Golang sqlc 框架详解</a><time datetime="2026-01-01T22:24:00.000Z" title="发表于 2026-01-02 06:24:00">2026-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比"/></a><div class="content"><a class="title" href="/2e2570e368f1/" title="Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比">Golang 并发 Map 详解：sync.Mutex、sync.RWMutex 与 sync.Map 对比</a><time datetime="2025-12-31T22:24:00.000Z" title="发表于 2026-01-01 06:24:00">2026-01-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-15.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="🆕 2023">🆕 2023</a><a href="/archives/2024/" target="_blank" title="🆒 2024">🆒 2024</a><a href="/archives/2025/" target="_blank" title="👨‍👩‍👦 2025">👨‍👩‍👦 2025</a><a href="/archives/2026/" target="_blank" title="🆙 2026">🆙 2026</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="📁 分类">📁 分类</a><a href="/tags/" target="_blank" title="🔖 标签">🔖 标签</a><a href="/categories/" target="_blank" title="📽️ 时间线">📽️ 时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="💬 说说">💬 说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2026 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>