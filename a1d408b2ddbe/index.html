<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python多进程实现生产者-消费者模式详解 | 1024 维度</title><meta name="author" content="TeaTang"><meta name="copyright" content="TeaTang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一">
<meta property="og:type" content="article">
<meta property="og:title" content="Python多进程实现生产者-消费者模式详解">
<meta property="og:url" content="https://blog.tbf1211.xx.kg/a1d408b2ddbe/index.html">
<meta property="og:site_name" content="1024 维度">
<meta property="og:description" content="生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 multiprocessing 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。  核心思想：利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg">
<meta property="article:published_time" content="2023-03-14T22:24:00.000Z">
<meta property="article:modified_time" content="2025-11-25T10:04:14.202Z">
<meta property="article:author" content="TeaTang">
<meta property="article:tag" content="2023">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python多进程实现生产者-消费者模式详解",
  "url": "https://blog.tbf1211.xx.kg/a1d408b2ddbe/",
  "image": "https://blog.tbf1211.xx.kg/img/cover/default_cover-21.jpg",
  "datePublished": "2023-03-14T22:24:00.000Z",
  "dateModified": "2025-11-25T10:04:14.202Z",
  "author": [
    {
      "@type": "Person",
      "name": "TeaTang",
      "url": "https://blog.tbf1211.xx.kg"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon-1.ico"><link rel="canonical" href="https://blog.tbf1211.xx.kg/a1d408b2ddbe/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":true,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: TeaTang","link":"链接: ","source":"来源: 1024 维度","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python多进程实现生产者-消费者模式详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="1024 维度" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">320</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">201</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">71</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover/default_cover-21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">1024 维度</span></a><a class="nav-page-title" href="/"><span class="site-name">Python多进程实现生产者-消费者模式详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 我的轨迹</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/2023/"><i class="fa-fw fa-solid fa-bug"></i><span> 2023</span></a></li><li><a class="site-page child" href="/archives/2024/"><i class="fa-fw fa-solid fa-code"></i><span> 2024</span></a></li><li><a class="site-page child" href="/archives/2025/"><i class="fa-fw fa-solid fa-network-wired"></i><span> 2025</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa-solid fa-calendar-days"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Python多进程实现生产者-消费者模式详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-14T22:24:00.000Z" title="发表于 2023-03-15 06:24:00">2023-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python/">Python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="umamiPV" data-path="/a1d408b2ddbe/"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的线程（或进程）同步问题。在 Python 中，可以使用 <code>multiprocessing</code> 模块实现多进程版的生产者-消费者模式，以充分利用多核 CPU 资源。</p>
</blockquote>
<div class="note info flat"><p>核心思想：<strong>利用共享队列作为缓冲，实现生产者与消费者解耦，并通过互斥锁和条件变量（或自带的线程安全队列）进行同步，避免数据不一致和资源竞争。</strong></p>
</div>
<hr>
<h2 id="一、生产者-消费者模式概述"><a href="#一、生产者-消费者模式概述" class="headerlink" title="一、生产者-消费者模式概述"></a>一、生产者-消费者模式概述</h2><p><strong>模式构成：</strong></p>
<ol>
<li><strong>生产者 (Producer)</strong>：负责生成数据，并将其放入共享的缓冲区（队列）中。</li>
<li><strong>消费者 (Consumer)</strong>：负责从共享的缓冲区（队列）中取出数据进行处理。</li>
<li><strong>缓冲区 (Buffer &#x2F; Queue)</strong>：一个共享的数据结构，通常是一个队列，用于存储生产者生产的数据和消费者消费的数据。它充当了生产者和消费者之间的桥梁。</li>
</ol>
<p><strong>解决的问题：</strong></p>
<ul>
<li><strong>解耦</strong>：生产者和消费者可以独立运行，互不干扰，提高系统的灵活性。</li>
<li><strong>并发</strong>：允许多个生产者和多个消费者同时存在，提高处理效率。</li>
<li><strong>削峰填谷</strong>：当生产速度快于消费速度时，缓冲区可以存储多余的数据，防止数据丢失；当消费速度快于生产速度时，消费者可以等待，避免空转。</li>
<li><strong>同步问题</strong>：通过引入缓冲区和适当的同步机制，避免了直接共享数据带来的竞争条件和死锁问题。</li>
</ul>
<h2 id="二、Python-多进程实现的关键模块"><a href="#二、Python-多进程实现的关键模块" class="headerlink" title="二、Python 多进程实现的关键模块"></a>二、Python 多进程实现的关键模块</h2><p>在 Python 中实现多进程的生产者-消费者模式，主要依赖于 <code>multiprocessing</code> 模块。</p>
<h3 id="2-1-multiprocessing-模块"><a href="#2-1-multiprocessing-模块" class="headerlink" title="2.1 multiprocessing 模块"></a>2.1 <code>multiprocessing</code> 模块</h3><p><code>multiprocessing</code> 是 Python 官方提供的一个用于多进程编程的模块。它提供了类似 <code>threading</code> 模块的 API，但使用进程而非线程，可以绕过 GIL (Global Interpreter Lock) 的限制，真正地实现并行计算。</p>
<h3 id="2-2-进程间通信-IPC"><a href="#2-2-进程间通信-IPC" class="headerlink" title="2.2 进程间通信 (IPC)"></a>2.2 进程间通信 (IPC)</h3><p>多进程之间无法直接共享内存，因为每个进程都有自己的独立内存空间。因此，需要特定的机制来实现进程间通信 (IPC)：</p>
<ol>
<li><strong><code>multiprocessing.Queue</code> (队列)</strong>：这是实现生产者-消费者模式最常用且简便的方式。<code>Queue</code> 是进程安全的，内部使用了管道 (Pipe) 和锁 (Lock) 来确保数据的一致性。</li>
<li><strong><code>multiprocessing.Pipe</code> (管道)</strong>：用于两个进程之间的双向或单向通信，但通常没有 <code>Queue</code> 方便用于多对多通信。</li>
<li><strong><code>multiprocessing.Value</code> &#x2F; <code>multiprocessing.Array</code> (共享内存)</strong>：用于共享简单的数值或数组，但需要手动管理锁来保证写入安全。</li>
<li><strong><code>multiprocessing.Manager</code> (管理器)</strong>：可以创建各种共享对象，如列表、字典、命名空间等，但相比 <code>Queue</code> 性能略低。</li>
</ol>
<p><strong>对于生产者-消费者模式，<code>multiprocessing.Queue</code> 是最佳选择。</strong></p>
<h2 id="三、多进程生产者-消费者模式的实现步骤"><a href="#三、多进程生产者-消费者模式的实现步骤" class="headerlink" title="三、多进程生产者-消费者模式的实现步骤"></a>三、多进程生产者-消费者模式的实现步骤</h2><ol>
<li><strong>创建共享队列</strong>：使用 <code>multiprocessing.Queue()</code> 创建一个进程安全的队列，作为生产者和消费者之间传递数据的缓冲区。</li>
<li><strong>定义生产者函数</strong>：<ul>
<li>接收队列作为参数。</li>
<li>循环生成数据。</li>
<li>使用 <code>queue.put()</code> 将数据放入队列。</li>
<li>在生产完成后，可以选择发送一个特殊信号（如 <code>None</code> 或 <code>QUIT</code> 信号）通知消费者停止。</li>
</ul>
</li>
<li><strong>定义消费者函数</strong>：<ul>
<li>接收队列作为参数。</li>
<li>循环从队列中取出数据。</li>
<li>使用 <code>queue.get()</code> 获取数据。</li>
<li>处理数据。</li>
<li>接收到停止信号后，终止循环。</li>
</ul>
</li>
<li><strong>创建并启动进程</strong>：<ul>
<li>使用 <code>multiprocessing.Process</code> 创建生产者和消费者进程实例。</li>
<li>使用 <code>process.start()</code> 启动所有进程。</li>
</ul>
</li>
<li><strong>等待进程结束</strong>：使用 <code>process.join()</code> 等待所有子进程执行完毕。</li>
</ol>
<h2 id="四、代码示例：多进程生产者-消费者"><a href="#四、代码示例：多进程生产者-消费者" class="headerlink" title="四、代码示例：多进程生产者-消费者"></a>四、代码示例：多进程生产者-消费者</h2><p>我们将实现一个简单的场景：一个生产者生成数字，两个消费者处理这些数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义队列中用于终止消费者的特殊值</span></span><br><span class="line">STOP_SIGNAL = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">queue, producer_id, num_items</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_items):</span><br><span class="line">        item = <span class="string">f&quot;生产商<span class="subst">&#123;producer_id&#125;</span>_产品_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.5</span>)) <span class="comment"># 模拟生产时间</span></span><br><span class="line">        <span class="comment"># put() 方法是阻塞的，如果队列满了，它会等待直到有空间</span></span><br><span class="line">        queue.put(item)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产了: <span class="subst">&#123;item&#125;</span>, 队列当前大小: <span class="subst">&#123;queue.qsize()&#125;</span>&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 生产完成后，向队列发送停止信号。</span></span><br><span class="line">    <span class="comment"># 如果有多个消费者，需要发送多个停止信号。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产完毕，发送停止信号。&quot;</span>)</span><br><span class="line">    queue.put(STOP_SIGNAL) <span class="comment"># 这里只有一个生产者，所以只发一个</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 消费者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">queue, consumer_id</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># get() 方法是阻塞的，如果队列为空，它会等待直到有数据</span></span><br><span class="line">        item = queue.get() </span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> STOP_SIGNAL:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 收到停止信号，退出。&quot;</span>)</span><br><span class="line">            <span class="comment"># 收到停止信号后，如果还有其他消费者，需要将信号重新放回队列，以便其他消费者也能接收到</span></span><br><span class="line">            queue.put(STOP_SIGNAL) </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>)) <span class="comment"># 模拟消费时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 消费了: <span class="subst">&#123;item&#125;</span>, 队列当前大小: <span class="subst">&#123;queue.qsize()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 1. 创建共享队列</span></span><br><span class="line">    <span class="comment"># maxsize 设置队列的最大容量，如果为 0 或负数，则表示无限制。</span></span><br><span class="line">    <span class="comment"># 有界队列可以防止生产者无限生产导致内存耗尽。</span></span><br><span class="line">    <span class="comment"># 这里设置为 5，以便观察队列满和空的阻塞行为。</span></span><br><span class="line">    queue = multiprocessing.Queue(maxsize=<span class="number">5</span>) </span><br><span class="line">  </span><br><span class="line">    num_producers = <span class="number">1</span></span><br><span class="line">    num_consumers = <span class="number">2</span></span><br><span class="line">    items_per_producer = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    producers = []</span><br><span class="line">    consumers = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建并启动生产者进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_producers):</span><br><span class="line">        p = multiprocessing.Process(target=producer, args=(queue, i + <span class="number">1</span>, items_per_producer))</span><br><span class="line">        producers.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建并启动消费者进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers):</span><br><span class="line">        c = multiprocessing.Process(target=consumer, args=(queue, i + <span class="number">1</span>))</span><br><span class="line">        consumers.append(c)</span><br><span class="line">        c.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 等待所有生产者进程结束</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> producers:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有生产者进程完成。\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 等待所有消费者进程结束</span></span><br><span class="line">    <span class="comment"># 注意: 如果有N个消费者，且每个生产者发送一个STOP_SIGNAL，</span></span><br><span class="line">    <span class="comment"># 那么当生产者都完成后，队列中应该有 N * num_producers 个 STOP_SIGNAL</span></span><br><span class="line">    <span class="comment"># 此处只有一个生产者，但我们为了确保所有消费者都退出，还是让生产者发送了STOP_SIGNAL。</span></span><br><span class="line">    <span class="comment"># 如果有多个生产者，每个生产者生产完都要发送STOP_SIGNAL。</span></span><br><span class="line">    <span class="comment"># 并且每个消费者收到STOP_SIGNAL后要再放回队列，以确保所有消费者都能收到。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers): <span class="comment"># 每个消费者都会从队列中取出一个信号</span></span><br><span class="line">         queue.put(STOP_SIGNAL) <span class="comment">#确保每个消费者都能接收到终止信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修正消费者停止信号处理逻辑：</span></span><br><span class="line">    <span class="comment"># 当只有一个生产者时，发送一个 STOP_SIGNAL。如果消费者收到后直接退出，</span></span><br><span class="line">    <span class="comment"># 那么另一个消费者将永远等待。因此，每个消费者收到 `STOP_SIGNAL` 后应将其重新放回队列。</span></span><br><span class="line">    <span class="comment"># 或者，更好的方法是让生产者发送 `num_consumers` 个 `STOP_SIGNAL`。</span></span><br><span class="line">    <span class="comment"># 考虑到通用性，我们采用消费者放回的做法。</span></span><br><span class="line">    <span class="comment"># 但是更好的办法是生产者发送跟消费者一样多的STOP_SIGNAL</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> consumers:</span><br><span class="line">        c.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有消费者进程完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序执行完毕。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>代码解析：</strong></p>
<ol>
<li><strong><code>multiprocessing.Queue(maxsize=5)</code></strong>：创建了一个最大容量为 5 的队列。这意味着当队列中有 5 个元素时，如果生产者继续 <code>put()</code>，它会阻塞直到有消费者 <code>get()</code> 释放空间。反之，如果队列为空，消费者 <code>get()</code> 会阻塞直到生产者 <code>put()</code> 放入数据。</li>
<li><strong><code>STOP_SIGNAL = None</code></strong>：定义一个特殊值作为停止信号。当消费者从队列中获取到这个信号时，就知道没有更多的数据需要处理了，从而安全退出。</li>
<li><strong>生产者 (<code>producer</code> 函数)</strong>：<ul>
<li>在循环中模拟生产数据，并使用 <code>queue.put(item)</code> 将数据放入队列。</li>
<li>生产完毕后，发送 <code>STOP_SIGNAL</code>。</li>
</ul>
</li>
<li><strong>消费者 (<code>consumer</code> 函数)</strong>：<ul>
<li>在一个无限循环中，使用 <code>queue.get()</code> 从队列中获取数据。</li>
<li>检查 <code>item == STOP_SIGNAL</code>，如果是，则打印退出信息，并将 <code>STOP_SIGNAL</code> 重新放回队列 (<strong>非常关键</strong>)。这确保了如果有多个消费者，当第一个消费者收到停止信号退出后，后续的消费者也能收到并退出，而不是永远等待。</li>
</ul>
</li>
<li><strong>主程序 (<code>if __name__ == &quot;__main__&quot;:</code>)</strong>：<ul>
<li>创建队列。</li>
<li>创建并启动生产者和消费者进程。</li>
<li>使用 <code>p.join()</code> 和 <code>c.join()</code> 等待所有子进程完成。</li>
<li><strong>重要提示</strong>：在多消费者场景中，生产者需要发送足够多的 <code>STOP_SIGNAL</code>（通常是消费者数量），或者像示例中那样，让消费者在收到 <code>STOP_SIGNAL</code> 后将其重新放回队列，以便其他消费者也能收到。</li>
</ul>
</li>
</ol>
<h2 id="五、运行效果及注意事项"><a href="#五、运行效果及注意事项" class="headerlink" title="五、运行效果及注意事项"></a>五、运行效果及注意事项</h2><p>运行上述代码，你将看到生产者和消费者交替工作的日志输出。当队列满时，生产者会停止生产；当队列空时，消费者会停止消费。最终所有进程都会按预期退出。</p>
<p><strong>关键注意事项：</strong></p>
<ol>
<li><strong><code>Queue</code> 的 <code>put()</code> 和 <code>get()</code> 方法是同步且阻塞的</strong>：它们会处理内部的锁，保证进程安全。如果队列满或空，它们会自动等待。</li>
<li><strong>终止信号的处理</strong>：<ul>
<li>如果只有一个消费者，一个 <code>STOP_SIGNAL</code> 即可。</li>
<li>如果有 N 个消费者，且只有一个生产者，生产者可以选择发送 N 个 <code>STOP_SIGNAL</code>，或者每个消费者在接收到 <code>STOP_SIGNAL</code> 后，将其重新放回队列，以通知下一个消费者。示例中采用了后者。</li>
<li>如果有 M 个生产者和 N 个消费者，每个生产者完成后都需要发送 <code>STOP_SIGNAL</code>。为了确保所有 N 个消费者都能退出，一种常见做法是让每个生产者发送 <code>STOP_SIGNAL</code> 后，消费者收到并自行处理，然后重新放回队列。或者，在生产者都完成后，主进程额外向队列中放入 <code>N</code> 个 <code>STOP_SIGNAL</code>。</li>
</ul>
</li>
<li><strong>进程的清理</strong>：<code>queue.close()</code> 和 <code>queue.join_thread()</code> 在队列不再使用时用于清理内部的线程和资源，但在 <code>multiprocessing.Queue</code> 中，通常在 <code>join()</code> 之后，这些资源会自动清理。</li>
<li><strong>资源开销</strong>：多进程会比多线程消耗更多的内存和 CPU 资源，因为每个进程都会有独立的 GIL 和内存空间。在选择多进程还是多线程时，需要根据任务类型进行权衡（CPU 密集型 vs I&#x2F;O 密集型）。</li>
</ol>
<h2 id="六、多生产者、多消费者示例-更健壮的停止机制"><a href="#六、多生产者、多消费者示例-更健壮的停止机制" class="headerlink" title="六、多生产者、多消费者示例 (更健壮的停止机制)"></a>六、多生产者、多消费者示例 (更健壮的停止机制)</h2><p>当有多个生产者和多个消费者时，停止信号的处理会稍微复杂一些。一个更健壮的方法是使用一个共享计数器来追踪活动的生产者数量，或者让主进程在所有生产者完成后统一发送足够多的停止信号。</p>
<p>这里我们演示一个更明确的停止方案：<strong>主进程在所有生产者完成后，按消费者数量发送停止信号。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer_v2</span>(<span class="params">queue, producer_id, num_items</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_items):</span><br><span class="line">        item = <span class="string">f&quot;生产商<span class="subst">&#123;producer_id&#125;</span>_产品_<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.3</span>))</span><br><span class="line">        queue.put(item)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产了: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生产者 <span class="subst">&#123;producer_id&#125;</span> 生产完毕。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer_v2</span>(<span class="params">queue, consumer_id</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 启动...&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = queue.get() <span class="comment"># 阻塞等待数据</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 收到停止信号</span></span><br><span class="line">            <span class="comment"># 重要：将停止信号放回队列，让其他消费者也能收到</span></span><br><span class="line">            queue.put(<span class="literal">None</span>) </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 收到停止信号，退出。&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.3</span>, <span class="number">0.8</span>)) <span class="comment"># 模拟消费时间</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;消费者 <span class="subst">&#123;consumer_id&#125;</span> 消费了: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    queue_v2 = multiprocessing.Queue(maxsize=<span class="number">10</span>) <span class="comment"># 队列容量设置为10</span></span><br><span class="line">  </span><br><span class="line">    num_producers_v2 = <span class="number">2</span></span><br><span class="line">    num_consumers_v2 = <span class="number">3</span></span><br><span class="line">    items_per_producer_v2 = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    producers_v2 = []</span><br><span class="line">    consumers_v2 = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 创建并启动生产者进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_producers_v2):</span><br><span class="line">        p = multiprocessing.Process(target=producer_v2, args=(queue_v2, i + <span class="number">1</span>, items_per_producer_v2))</span><br><span class="line">        producers_v2.append(p)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建并启动消费者进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers_v2):</span><br><span class="line">        c = multiprocessing.Process(target=consumer_v2, args=(queue_v2, i + <span class="number">1</span>))</span><br><span class="line">        consumers_v2.append(c)</span><br><span class="line">        c.start()</span><br><span class="line">      </span><br><span class="line">    <span class="comment"># 3. 等待所有生产者进程完成</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> producers_v2:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有生产者进程完成。\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 生产者都完成后，向队列中放入与消费者数量相等的 None 信号</span></span><br><span class="line">    <span class="comment"># 以确保所有消费者都能接收到终止信号并安全退出</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_consumers_v2):</span><br><span class="line">        queue_v2.put(<span class="literal">None</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 5. 等待所有消费者进程完成</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> consumers_v2:</span><br><span class="line">        c.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n所有消费者进程完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n多生产者多消费者程序执行完毕。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个增强版更清晰地展示了如何处理多生产者-多消费者场景下的停止。生产者只负责生产，不负责发送停止信号。主进程在所有生产者都完成后，统一发送停止信号，确保每个消费者都能收到。而消费者接收到停止信号后，仍然将其重新放回队列，以“接力”的方式传递给其他等待的消费者。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Python 的 <code>multiprocessing</code> 模块提供了一个强大而灵活的框架来实现多进程编程。生产者-消费者模式是其典型的应用场景之一，尤其适用于需要处理大量数据或 CPU 密集型任务的场景。通过<code>multiprocessing.Queue</code>，我们可以方便地实现进程间安全高效的数据传递，并有效管理生产者和消费者之间的同步问题，从而构建出高性能、高并发的应用程序。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg">TeaTang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.tbf1211.xx.kg/a1d408b2ddbe/">https://blog.tbf1211.xx.kg/a1d408b2ddbe/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.tbf1211.xx.kg" target="_blank">1024 维度</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/2023/">2023</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover-21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/832eaf04ac40/" title="Python多线程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Python多线程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模块实现多线程版的生产者-消费者模式。  核心思想：利用线程安全的共享队列作为缓冲，实现生产者与消费者解耦，并通过队列自带的互斥锁和条件变量进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式与多线程概述1.1 生产者-消费者模式参考 Python 多进程生产者-消费者模式详解 中的概述，其核心构成和解决的问题在多线程场景下是相同的：  生产者 (Producer)：生成数据并放入队列。 消费者 (Consumer)：从队列取出数据并处理。 缓冲区 (Queue)：共享的、线程安全的数据容器。  1.2 Python 多线程与 GIL threading 模块：Python 标...</div></div></div></a><a class="pagination-related" href="/9be87a9e79b5/" title="KCP协议详解：一个快速可靠的UDP上层协议"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">KCP协议详解：一个快速可靠的UDP上层协议</div></div><div class="info-2"><div class="info-item-1"> KCP (Fast and Reliable UDP protocol) 是一个由 skywind3000 (吴云) 在 2014 年开源的快速可靠的 UDP 上层协议。它的设计目标是在网络状况不佳（高延迟、高丢包率）的环境下，提供比 TCP 更快的传输速度和更低的延迟，同时保持数据的可靠性。KCP 并不是一个完整的网络协议栈，而是一个可嵌入式的库，它运行在 UDP 协议之上，提供了 TCP 所具备的可靠性、流量控制和拥塞控制等机制，但针对延迟和重传进行了优化。  核心思想：在保障数据可靠性的前提下，通过优化重传机制、激进发送和控制重传间隔等方法，尽可能地减少传输延迟，以适应游戏、实时音视频等对延迟高度敏感的应用。   一、为什么需要 KCP？TCP 协议是互联网上最常用的可靠传输协议，但它在一些场景下存在明显的局限性：  慢启动 (Slow Start)：TCP 为了避免网络拥塞，在连接建立初期会限制发送速率，逐渐增加。这对于短连接或突发数据传输会增加初始延迟。 队头阻塞 (Head-of-Line Blocking, HOLB)：TCP 的报文是严格按序到达的。如果某个数据...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/832eaf04ac40/" title="Python多线程实现生产者-消费者模式详解"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-30.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="info-item-2">Python多线程实现生产者-消费者模式详解</div></div><div class="info-2"><div class="info-item-1"> 生产者-消费者模式是并发编程中一个非常常见的设计模式，用于解决生产者和消费者之间由于生产和消费的速度不一致而导致的同步问题。在 Python 中，由于全局解释器锁 (GIL) 的存在，多线程在 CPU 密集型任务上并不能真正并行，但在 I&#x2F;O 密集型任务上，多线程仍然可以有效地提高程序的效率和响应速度。本篇将详细介绍如何使用 Python 的 threading 模块和 queue 模块实现多线程版的生产者-消费者模式。  核心思想：利用线程安全的共享队列作为缓冲，实现生产者与消费者解耦，并通过队列自带的互斥锁和条件变量进行同步，避免数据不一致和资源竞争。   一、生产者-消费者模式与多线程概述1.1 生产者-消费者模式参考 Python 多进程生产者-消费者模式详解 中的概述，其核心构成和解决的问题在多线程场景下是相同的：  生产者 (Producer)：生成数据并放入队列。 消费者 (Consumer)：从队列取出数据并处理。 缓冲区 (Queue)：共享的、线程安全的数据容器。  1.2 Python 多线程与 GIL threading 模块：Python 标...</div></div></div></a><a class="pagination-related" href="/3226a64cc8bb/" title="Python元类(Metaclass)深度解析"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="info-item-2">Python元类(Metaclass)深度解析</div></div><div class="info-2"><div class="info-item-1">Python 元类深度解析：从概念到实战  “Everything is an object.” - Python之禅“Classes are objects too.” - 元类的核心思想  在 Python 中，万物皆对象。你用 class 关键字定义的类，例如 str、int、list，它们本身也是对象。那么，是谁创建了这些类对象呢？答案就是“元类”(Metaclass)。元类是创建类的类，它允许我们在类被创建时对其行为进行定制，是 Python 中进行高级面向对象编程的强大工具。 1. 什么是元类？在 Python 中，当你定义一个类 class MyClass: pass 的时候，Python 解释器会自动执行以下步骤：  定义一个类对象：解释器读取 MyClass 的定义，并创建一个名为 MyClass 的类对象。 将类对象绑定到命名空间：这个 MyClass 类对象被绑定到当前的命名空间中。  然后，当你通过 my_instance = MyClass() 来创建实例时，MyClass 这个类对象就会被调用，从而创建并返回一个实例对象。 元类就是用来创建这些类对象的...</div></div></div></a><a class="pagination-related" href="/cb923ba84dd9/" title="Python NumPy详解：科学计算的基石"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="info-item-2">Python NumPy详解：科学计算的基石</div></div><div class="info-2"><div class="info-item-1"> NumPy (Numerical Python) 是 Python 中用于科学计算的核心库。它提供了一个高性能的多维数组对象 ndarray，以及用于处理这些数组的工具。NumPy 是 Python 数据科学和机器学习生态系统的基石，许多其他库（如 SciPy, Pandas, Matplotlib, Scikit-learn）都建立在 NumPy 数组之上。  核心思想：NumPy 引入了高效的 ndarray 数据结构，通过向量化操作显著提升了 Python 处理数值数据的性能。   一、为什么选择 NumPy？Python 语言本身处理列表等数据结构时效率较高，但对于大规模数值计算而言，原生的 Python 列表效率低下。NumPy 通过以下方式解决了这个问题：  高性能 ndarray 对象：ndarray 存储同类型数据，在内存中连续存储，相比 Python 列表，占用的内存更少，访问速度更快。 向量化操作：NumPy 允许对整个数组进行操作，而无需编写显式的循环。这些操作通常在 C 或 Fortran 中实现，执行速度远超 Python 循环。 广播 (Broadc...</div></div></div></a><a class="pagination-related" href="/dbdbe99385cd/" title="Python Pandas详解：数据处理与分析的瑞士军刀"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-21</div><div class="info-item-2">Python Pandas详解：数据处理与分析的瑞士军刀</div></div><div class="info-2"><div class="info-item-1"> Pandas 是 Python 中用于数据分析和处理的核心库。它提供了一套高性能、易于使用的数据结构，最主要的是 DataFrame（二维表格数据）和 Series（一维带标签数组），用于快速处理和分析结构化数据（如 CSV、Excel、数据库表格数据）。Pandas 以其直观的语法和强大的功能，成为数据科学家和数据工程师的首选工具。  核心思想：Pandas 将表格数据抽象为 DataFrame 和 Series 对象，提供类似 SQL 和 Excel 的操作，通过向量化和 C&#x2F;Cython 实现的底层优化，极大提升了数据处理效率。   一、为什么选择 Pandas？在数据驱动的时代，我们经常需要处理各种形式的表格数据。Python 原生的数据结构（如列表、字典）虽然灵活，但在处理大量、复杂、异构的表格数据时显得力不从心。Pandas 解决了这些痛点：  直观的数据结构：DataFrame 和 Series 提供了强大的标签索引功能，使得数据操作更加直观，无需关注底层实现。 高效的数据操作：底层基于 NumPy 优化，利用 C 和 Cython 实现，对于大规模数据...</div></div></div></a><a class="pagination-related" href="/1b5035114ad1/" title="Python Requests库详解：HTTP请求的艺术"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="info-item-2">Python Requests库详解：HTTP请求的艺术</div></div><div class="info-2"><div class="info-item-1"> requests 库 是 Python 生态系统中最流行、最强大、也是最优雅的 HTTP 客户端库之一。它简化了复杂的 HTTP 请求操作，让开发者能够以极少量的代码发送各种类型的 HTTP 请求，并轻松处理响应。与 Python 内置的 urllib 模块相比，requests 提供了更友好、更直观的 API，被誉为“面向人类的 HTTP 服务”。  核心思想：requests 封装了底层 HTTP 协议的复杂性，提供简洁的 API，让开发者专注于业务逻辑而非网络通信的细节。   一、为什么选择 Requests？在 Python 中进行 HTTP 请求有多种方式，例如内置的 urllib 模块。但 requests 库之所以广受欢迎，主要得益于以下优势：  友好的 API：设计直观，易学易用，代码可读性高。 功能强大：支持几乎所有 HTTP 功能，包括 GET, POST, PUT, DELETE 等方法，以及请求头、数据、文件上传、Cookie、身份认证、代理、SSL 验证等。 自动处理：自动处理 URL 编码、重定向、会话管理等常见任务。 JSON 支持：内置 JSON...</div></div></div></a><a class="pagination-related" href="/10b74b4460f9/" title="Python 异步编程详解：从并发到协程"><img class="cover" src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-22</div><div class="info-item-2">Python 异步编程详解：从并发到协程</div></div><div class="info-2"><div class="info-item-1"> Python 异步编程 是一种处理并发任务的编程范式，它允许程序在等待某些操作（如 I&#x2F;O 操作、网络请求、数据库查询）完成时，切换到执行其他任务，从而提高程序的吞吐量和响应速度。与传统的多线程&#x2F;多进程并发模型不同，异步编程通常使用协程 (Coroutines) 和事件循环 (Event Loop) 来实现，避免了线程&#x2F;进程切换的开销，也绕开了 Python 的全局解释器锁 (GIL) 对 CPU 密集型任务的限制（尽管异步编程主要适用于 I&#x2F;O 密集型任务）。  核心思想：异步编程通过在等待 I&#x2F;O 完成时“暂停”当前任务，并“切换”到其他可执行任务，从而在单线程内实现并发和最大化 I&#x2F;O 利用率。   一、为什么需要异步编程？传统的 Python 程序（同步阻塞式）在执行 I&#x2F;O 操作时会阻塞整个程序，直到 I&#x2F;O 完成。例如，一个 Web 服务器在处理一个耗时的网络请求时，就无法处理其他用户的请求，导致性能低下。 1.1 同步阻塞 (Synchronous Blocking)123456789...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">TeaTang</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">320</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">201</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">71</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/teatang"><i class="fab fa-github"></i><span>GitHub主页</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:tea.tang1211@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站更多功能即将上线，敬请期待！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-text">一、生产者-消费者模式概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%B3%E9%94%AE%E6%A8%A1%E5%9D%97"><span class="toc-text">二、Python 多进程实现的关键模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-multiprocessing-%E6%A8%A1%E5%9D%97"><span class="toc-text">2.1 multiprocessing 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-IPC"><span class="toc-text">2.2 进程间通信 (IPC)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">三、多进程生产者-消费者模式的实现步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">四、代码示例：多进程生产者-消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">五、运行效果及注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E7%A4%BA%E4%BE%8B-%E6%9B%B4%E5%81%A5%E5%A3%AE%E7%9A%84%E5%81%9C%E6%AD%A2%E6%9C%BA%E5%88%B6"><span class="toc-text">六、多生产者、多消费者示例 (更健壮的停止机制)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/53e63dc49a04/" title="PyInstaller 深度解析与指令详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PyInstaller 深度解析与指令详解"/></a><div class="content"><a class="title" href="/53e63dc49a04/" title="PyInstaller 深度解析与指令详解">PyInstaller 深度解析与指令详解</a><time datetime="2025-11-24T22:24:00.000Z" title="发表于 2025-11-25 06:24:00">2025-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/61fddda6a7a8/" title="Go 语言 GC (Garbage Collection) 机制详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 语言 GC (Garbage Collection) 机制详解"/></a><div class="content"><a class="title" href="/61fddda6a7a8/" title="Go 语言 GC (Garbage Collection) 机制详解">Go 语言 GC (Garbage Collection) 机制详解</a><time datetime="2025-11-23T22:24:00.000Z" title="发表于 2025-11-24 06:24:00">2025-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="压缩字典树 (Radix Trie/Patricia Trie) 深度解析"/></a><div class="content"><a class="title" href="/fae19f12de23/" title="压缩字典树 (Radix Trie/Patricia Trie) 深度解析">压缩字典树 (Radix Trie/Patricia Trie) 深度解析</a><time datetime="2025-11-17T22:24:00.000Z" title="发表于 2025-11-18 06:24:00">2025-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/c28be5a597e1/" title="Golang 内存对齐详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 内存对齐详解"/></a><div class="content"><a class="title" href="/c28be5a597e1/" title="Golang 内存对齐详解">Golang 内存对齐详解</a><time datetime="2025-11-12T22:24:00.000Z" title="发表于 2025-11-13 06:24:00">2025-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解"><img src="/img/loading.gif" data-lazy-src="/img/cover/default_cover-22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang 空结构体 (struct{}) 详解"/></a><div class="content"><a class="title" href="/7419af632339/" title="Golang 空结构体 (struct{}) 详解">Golang 空结构体 (struct{}) 详解</a><time datetime="2025-11-10T22:24:00.000Z" title="发表于 2025-11-11 06:24:00">2025-11-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/cover/default_cover-21.jpg);"><div class="footer-flex"><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">我的轨迹</div><div class="footer-flex-content"><a href="/archives/2023/" target="_blank" title="📌 2023">📌 2023</a><a href="/archives/2024/" target="_blank" title="❓ 2024">❓ 2024</a><a href="/archives/2025/" target="_blank" title="🚀 2025">🚀 2025</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">维度</div><div class="footer-flex-content"><a href="/categories/" target="_blank" title="分类">分类</a><a href="/tags/" target="_blank" title="标签">标签</a><a href="/categories/" target="_blank" title="时间线">时间线</a></div></div></div><div class="footer-flex-items"><div class="footer-flex-item"><div class="footer-flex-title">其他</div><div class="footer-flex-content"><a href="/shuoshuo" target="_blank" title="说说">说说</a></div></div></div></div><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By TeaTang</span><span class="framework-info"><span class="footer-separator">|</span><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const applyThemeDefaultsConfig = theme => {
    if (theme === 'dark-mode') {
      Chart.defaults.color = "rgba(255, 255, 255, 0.8)"
      Chart.defaults.borderColor = "rgba(255, 255, 255, 0.2)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    } else {
      Chart.defaults.color = "rgba(0, 0, 0, 0.8)"
      Chart.defaults.borderColor = "rgba(0, 0, 0, 0.1)"
      Chart.defaults.scale.ticks.backdropColor = "transparent"
    }
  }

  // Recursively traverse the config object and automatically apply theme-specific color schemes
  const applyThemeConfig = (obj, theme) => {
    if (typeof obj !== 'object' || obj === null) return

    Object.keys(obj).forEach(key => {
      const value = obj[key]
      // If the property is an object and has theme-specific options, apply them
      if (typeof value === 'object' && value !== null) {
        if (value[theme]) {
          obj[key] = value[theme] // Apply the value for the current theme
        } else {
          // Recursively process child objects
          applyThemeConfig(value, theme)
        }
      }
    })
  }

  const runChartJS = ele => {
    window.loadChartJS = true

    Array.from(ele).forEach((item, index) => {
      const chartSrc = item.firstElementChild
      const chartID = item.getAttribute('data-chartjs-id') || ('chartjs-' + index) // Use custom ID or default ID
      const width = item.getAttribute('data-width')
      const existingCanvas = document.getElementById(chartID)

      // If a canvas already exists, remove it to avoid rendering duplicates
      if (existingCanvas) {
          existingCanvas.parentNode.remove()
      }

      const chartDefinition = chartSrc.textContent
      const canvas = document.createElement('canvas')
      canvas.id = chartID

      const div = document.createElement('div')
      div.className = 'chartjs-wrap'

      if (width) {
        div.style.width = width
      }

      div.appendChild(canvas)
      chartSrc.insertAdjacentElement('afterend', div)

      const ctx = document.getElementById(chartID).getContext('2d')

      const config = JSON.parse(chartDefinition)

      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark-mode' : 'light-mode'

      // Set default styles (initial setup)
      applyThemeDefaultsConfig(theme)

      // Automatically traverse the config and apply dual-mode color schemes
      applyThemeConfig(config, theme)

      new Chart(ctx, config)
    })
  }

  const loadChartJS = () => {
    const chartJSEle = document.querySelectorAll('#article-container .chartjs-container')
    if (chartJSEle.length === 0) return

    window.loadChartJS ? runChartJS(chartJSEle) : btf.getScript('https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js').then(() => runChartJS(chartJSEle))
  }

  // Listen for theme change events
  btf.addGlobalFn('themeChange', loadChartJS, 'chartjs')
  btf.addGlobalFn('encrypt', loadChartJS, 'chartjs')

  window.pjax ? loadChartJS() : document.addEventListener('DOMContentLoaded', loadChartJS)
})()</script></div><script data-pjax src="/self/btf.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="ture"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,200,200" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script>(() => {
  const option = null
  const config = {"site_uv":true,"site_pv":true,"page_pv":true,"token":"qTvz1SkmPDt785fgh6BpiA5qiFFIVUwxj8Ft+rPW+cdN59v1hXjwRgSmy0+ji9m+oLlcxvo2NfDSMa6epVl3NTlsN3ejCIwWeP8Y51aEJ0Sbem4UexGmJLspB7AkOBId2SdtT6QWEBlGmFIIQgchQ2zAKYxTmc/kpBED5aLSr+3uvmQ9/G7FJQeVFpveDkK0xM1hu36xq4a6/FSeROxtoEp5zabzTWiYTlLsQzIl/NlELnCq3nxK+oo/vl3UQo/oM/rae/gJX/MaVKsgIUCd2ABJogNkx2KTenBIBpbPki5FzOgPh6/z4GPa4HvhNO51DDVG1SEQZooqEYmt/gnybLBWFbN+7liZWw=="}

  const runTrack = () => {
    if (typeof umami !== 'undefined' && typeof umami.track === 'function') {
      umami.track(props => ({ ...props, url: window.location.pathname, title: GLOBAL_CONFIG_SITE.title }))
    } else {
      console.warn('Umami Analytics: umami.track is not available')
    }
  }

  const loadUmamiJS = () => {
    btf.getScript('https://umami.012700.xyz/script.js', {
      'data-website-id': '2a796d6c-6499-42d8-8eb4-d9a2930b0ff3',
      'data-auto-track': 'false',
      ...option
    }).then(() => {
      runTrack()
    }).catch(error => {
      console.error('Umami Analytics: Error loading script', error)
    })
  }

  const getData = async (isPost) => {
    try {
      const now = Date.now()
      const keyUrl = isPost ? `&url=${window.location.pathname}` : ''
      const headerList = { 'Accept': 'application/json' }

      if (true) {
        headerList['Authorization'] = `Bearer ${config.token}`
      } else {
        headerList['x-umami-api-key'] = config.token
      }

      const res = await fetch(`https://umami.012700.xyz/api/websites/2a796d6c-6499-42d8-8eb4-d9a2930b0ff3/stats?startAt=0000000000&endAt=${now}${keyUrl}`, {
        method: "GET",
        headers: headerList
      })

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`)
      }

      return await res.json()
    } catch (error) {
      console.error('Umami Analytics: Failed to fetch data', error)
      throw error
    }
  }

  const insertData = async () => {
    try {
      if (GLOBAL_CONFIG_SITE.pageType === 'post' && config.page_pv) {
        const pagePV = document.getElementById('umamiPV')
        if (pagePV) {
          const data = await getData(true)
          if (data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            pagePV.textContent = data.pageviews.value
          } else {
            console.warn('Umami Analytics: Invalid page view data received')
          }
        }
      }

      if (config.site_uv || config.site_pv) {
        const data = await getData(false)

        if (config.site_uv) {
          const siteUV = document.getElementById('umami-site-uv')
          if (siteUV && data && data.visitors && typeof data.visitors.value !== 'undefined') {
            siteUV.textContent = data.visitors.value
          } else if (siteUV) {
            console.warn('Umami Analytics: Invalid site UV data received')
          }
        }

        if (config.site_pv) {
          const sitePV = document.getElementById('umami-site-pv')
          if (sitePV && data && data.pageviews && typeof data.pageviews.value !== 'undefined') {
            sitePV.textContent = data.pageviews.value
          } else if (sitePV) {
            console.warn('Umami Analytics: Invalid site PV data received')
          }
        }
      }
    } catch (error) {
      console.error('Umami Analytics: Failed to insert data', error)
    }
  }

  btf.addGlobalFn('pjaxComplete', runTrack, 'umami_analytics_run_track')
  btf.addGlobalFn('pjaxComplete', insertData, 'umami_analytics_insert')


  loadUmamiJS()

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', insertData)
  } else {
    setTimeout(insertData, 100)
  }
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>